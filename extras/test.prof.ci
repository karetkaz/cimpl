
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:13: debug: inline file: `lib/std/debug.ci`
lib/std/debug.ci:48: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/std/debug.ci:69: warn: adding implicit cast variant(expected: int32)
lib/std/debug.ci:70: warn: adding implicit cast variant(returned: int32)
lib/std/debug.ci:71: warn: adding implicit cast char[*](message: char[*])
lib/std/debug.ci:68: debug: using default field initializer: NotEquals.argument := null
lib/std/debug.ci:56: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:19: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/stdlib.ci:20: debug: inline file: `lib/std/math/Complex.ci`
lib/std/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:22: debug: inline file: `lib/std/math/Vector4f.ci`
lib/stdlib.ci:23: debug: inline file: `lib/std/math/Matrix4f.ci`
lib/std/math/Matrix4f.ci:108: warn: adding implicit cast float64(len: float32)
lib/std/math/Matrix4f.ci:132: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:160: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:160: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:160: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:161: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:161: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:161: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:162: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:162: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:162: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:163: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:163: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:163: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:163: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:169: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:169: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:169: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
lib/std/math/Matrix4f.ci:169: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:171: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:171: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:171: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:172: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:172: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:172: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:173: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:173: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:173: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(1: int32)
lib/stdlib.ci:24: debug: inline file: `lib/std/math/Vector2d.ci`
lib/stdlib.ci:29: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:116: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
lib/std/string.ci:122: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:151: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:161: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:164: warn: adding implicit cast uint64(0: int32)
lib/std/string.ci:164: warn: adding implicit cast uint64(radix: int32)
lib/std/string.ci:165: warn: adding implicit cast uint64(radix: int32)
lib/std/string.ci:179: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:184: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:189: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:196: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:203: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:208: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:209: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:209: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:211: warn: adding implicit cast char(0: int32)
lib/std/string.ci:224: warn: adding implicit cast int64(0: int32)
lib/std/string.ci:224: warn: adding implicit cast int32('-': char)
lib/std/string.ci:224: warn: adding implicit cast int64(0: int32)
lib/std/string.ci:226: warn: adding implicit cast int32('-': char)
lib/std/string.ci:228: warn: adding implicit cast int32(value: int16)
lib/std/string.ci:228: warn: adding implicit cast int32('-': char)
lib/std/string.ci:228: warn: adding implicit cast int32(value: int16)
lib/std/string.ci:230: warn: adding implicit cast int32(value: int8)
lib/std/string.ci:230: warn: adding implicit cast int32('-': char)
lib/std/string.ci:230: warn: adding implicit cast int32(value: int8)
lib/std/string.ci:247: warn: adding implicit cast float64(0: int32)
lib/std/string.ci:247: warn: adding implicit cast int32('-': char)
lib/std/string.ci:262: debug: using default field initializer: FormatFlags.showSign := false
lib/std/string.ci:262: debug: using default field initializer: FormatFlags.precision := 0
lib/std/string.ci:262: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:119: warn: adding implicit cast char(0: int32)
lib/std/string.ci:262: debug: using default field initializer: FormatFlags.padLen := 0

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/std/number.ci`
test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/std/memory.ci`
test/test.ci:27: debug: inline file: `test/std/tryExec.ci`
test/std/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/std/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/std/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/std/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/std/test.math.ci`
test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:111: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:112: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:113: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:114: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:150: warn: uninitialized variable `.result`
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/std/debug.ci:41: warn: no code will be generated for statement: 0
lib/std/debug.ci:41: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/string.ci:249: warn: using signed cast for unsigned value: `value`
lib/std/string.ci:253: warn: using signed cast for unsigned value: `fract`
test/std/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
test/lang/method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006178>, cast: static const inline)
.field file: function (size: 0, offs: <@006378>, cast: static const inline)
.field line: function (size: 0, offs: <@006578>, cast: static const inline)
.field name: function (size: 0, offs: <@006778>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/stdlib.ci:17: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 11
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:17: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006178>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006378>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006578>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006778>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:90: referenced as `void`
	test/lang/method.ci:84: referenced as `void`
	test/lang/method.ci:57: referenced as `void`
	test/lang/method.ci:47: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:32: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:18: referenced as `void`
	test/lang/method.ci:10: referenced as `void`
	test/std/tryExec.ci:42: referenced as `void`
	test/std/tryExec.ci:37: referenced as `void`
	test/std/tryExec.ci:23: referenced as `void`
	test/std/tryExec.ci:19: referenced as `void`
	test/std/tryExec.ci:14: referenced as `void`
	test/std/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/std/debug.ci:64: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/std/test.math.ci:68: referenced as `bool`
	test/std/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:113: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/std/debug.ci:45: referenced as `bool`
	lib/std/debug.ci:43: referenced as `bool`
	lib/std/debug.ci:41: referenced as `bool`
	lib/stdlib.ci:3: referenced as `bool`
	internal usages: 1
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/std/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:261: referenced as `char`
	lib/std/string.ci:258: referenced as `char`
	lib/std/string.ci:247: referenced as `char`
	lib/std/string.ci:233: referenced as `char`
	lib/std/string.ci:230: referenced as `char`
	lib/std/string.ci:228: referenced as `char`
	lib/std/string.ci:226: referenced as `char`
	lib/std/string.ci:224: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:220: referenced as `char`
	lib/std/string.ci:218: referenced as `char`
	lib/std/string.ci:216: referenced as `char`
	lib/std/string.ci:173: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:119: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/std/debug.ci:64: referenced as `char`
	lib/std/debug.ci:59: referenced as `char`
	lib/std/debug.ci:43: referenced as `char`
	lib/std/debug.ci:41: referenced as `char`
	lib/std/debug.ci:36: referenced as `char`
	lib/std/debug.ci:34: referenced as `char`
	lib/std/debug.ci:31: referenced as `char`
	lib/std/debug.ci:29: referenced as `char`
	lib/std/debug.ci:26: referenced as `char`
	lib/std/debug.ci:24: referenced as `char`
	lib/std/debug.ci:21: referenced as `char`
	lib/std/debug.ci:19: referenced as `char`
	lib/std/debug.ci:16: referenced as `char`
	lib/std/debug.ci:14: referenced as `char`
	lib/std/debug.ci:11: referenced as `char`
	lib/std/debug.ci:9: referenced as `char`
	lib/std/debug.ci:6: referenced as `char`
	lib/std/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
	lib/std/string.ci:230: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
	lib/std/string.ci:228: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:90: referenced as `int32`
	test/lang/method.ci:84: referenced as `int32`
	test/lang/method.ci:57: referenced as `int32`
	test/lang/method.ci:47: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:32: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:18: referenced as `int32`
	test/lang/method.ci:10: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/std/tryExec.ci:52: referenced as `int32`
	test/std/tryExec.ci:51: referenced as `int32`
	test/std/tryExec.ci:50: referenced as `int32`
	test/std/tryExec.ci:49: referenced as `int32`
	test/std/tryExec.ci:48: referenced as `int32`
	test/std/tryExec.ci:47: referenced as `int32`
	test/std/tryExec.ci:46: referenced as `int32`
	test/std/tryExec.ci:39: referenced as `int32`
	test/std/tryExec.ci:38: referenced as `int32`
	test/std/tryExec.ci:27: referenced as `int32`
	test/std/tryExec.ci:26: referenced as `int32`
	test/std/tryExec.ci:20: referenced as `int32`
	test/std/memory.ci:4: referenced as `int32`
	test/std/memory.ci:3: referenced as `int32`
	test/std/number.ci:66: referenced as `int32`
	test/std/number.ci:65: referenced as `int32`
	test/std/number.ci:63: referenced as `int32`
	test/std/number.ci:62: referenced as `int32`
	test/std/number.ci:60: referenced as `int32`
	test/std/number.ci:59: referenced as `int32`
	test/std/number.ci:58: referenced as `int32`
	test/std/number.ci:57: referenced as `int32`
	test/std/number.ci:55: referenced as `int32`
	test/std/number.ci:35: referenced as `int32`
	test/std/number.ci:34: referenced as `int32`
	test/std/number.ci:33: referenced as `int32`
	test/std/number.ci:31: referenced as `int32`
	test/std/number.ci:30: referenced as `int32`
	test/std/number.ci:29: referenced as `int32`
	test/std/number.ci:27: referenced as `int32`
	test/std/number.ci:26: referenced as `int32`
	test/std/number.ci:25: referenced as `int32`
	test/std/number.ci:23: referenced as `int32`
	test/std/number.ci:22: referenced as `int32`
	test/std/number.ci:21: referenced as `int32`
	test/std/number.ci:19: referenced as `int32`
	test/std/number.ci:18: referenced as `int32`
	test/std/number.ci:16: referenced as `int32`
	test/std/number.ci:15: referenced as `int32`
	test/std/number.ci:14: referenced as `int32`
	test/std/number.ci:12: referenced as `int32`
	test/std/number.ci:12: referenced as `int32`
	test/std/number.ci:12: referenced as `int32`
	test/std/number.ci:10: referenced as `int32`
	test/std/number.ci:10: referenced as `int32`
	test/std/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:30: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:24: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:18: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:12: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:261: referenced as `int32`
	lib/std/string.ci:261: referenced as `int32`
	lib/std/string.ci:261: referenced as `int32`
	lib/std/string.ci:258: referenced as `int32`
	lib/std/string.ci:233: referenced as `int32`
	lib/std/string.ci:233: referenced as `int32`
	lib/std/string.ci:230: referenced as `int32`
	lib/std/string.ci:228: referenced as `int32`
	lib/std/string.ci:226: referenced as `int32`
	lib/std/string.ci:226: referenced as `int32`
	lib/std/string.ci:224: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:220: referenced as `int32`
	lib/std/string.ci:218: referenced as `int32`
	lib/std/string.ci:216: referenced as `int32`
	lib/std/string.ci:202: referenced as `int32`
	lib/std/string.ci:171: referenced as `int32`
	lib/std/string.ci:156: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:116: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:17: referenced as `int32`
	lib/std/debug.ci:76: referenced as `int32`
	lib/std/debug.ci:76: referenced as `int32`
	lib/std/debug.ci:64: referenced as `int32`
	lib/std/debug.ci:64: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/std/memory.ci:30: referenced as `int64`
	test/std/memory.ci:29: referenced as `int64`
	test/std/memory.ci:24: referenced as `int64`
	test/std/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	lib/std/string.ci:224: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/std/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
	lib/std/string.ci:222: referenced as `uint8`
	lib/stdlib.ci:8: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
	lib/std/string.ci:220: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@009918>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009c48>, cast: static const inline)
.field pop: function (size: 0, offs: <@009e48>, cast: static const inline)
.field swap: function (size: 0, offs: <@00a048>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00a248>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00a448>, cast: static const inline)
.field hib: function (size: 0, offs: <@00a648>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a848>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/std/number.ci:63: referenced as `uint32`
	test/std/number.ci:62: referenced as `uint32`
	test/std/number.ci:60: referenced as `uint32`
	test/std/number.ci:59: referenced as `uint32`
	test/std/number.ci:58: referenced as `uint32`
	test/std/number.ci:57: referenced as `uint32`
	test/std/number.ci:56: referenced as `uint32`
	test/std/number.ci:56: referenced as `uint32`
	test/std/number.ci:55: referenced as `uint32`
	test/std/number.ci:35: referenced as `uint32`
	test/std/number.ci:34: referenced as `uint32`
	test/std/number.ci:33: referenced as `uint32`
	test/std/number.ci:31: referenced as `uint32`
	test/std/number.ci:30: referenced as `uint32`
	test/std/number.ci:29: referenced as `uint32`
	test/std/number.ci:27: referenced as `uint32`
	test/std/number.ci:26: referenced as `uint32`
	test/std/number.ci:25: referenced as `uint32`
	test/std/number.ci:23: referenced as `uint32`
	test/std/number.ci:22: referenced as `uint32`
	test/std/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:218: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009918>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/std/number.ci:62: referenced as `zxt`
	test/std/number.ci:31: referenced as `zxt`
	test/std/number.ci:30: referenced as `zxt`
	test/std/number.ci:29: referenced as `zxt`
	test/std/number.ci:23: referenced as `zxt`
	test/std/number.ci:22: referenced as `zxt`
	test/std/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009c48>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/std/number.ci:63: referenced as `sxt`
	test/std/number.ci:35: referenced as `sxt`
	test/std/number.ci:34: referenced as `sxt`
	test/std/number.ci:33: referenced as `sxt`
	test/std/number.ci:27: referenced as `sxt`
	test/std/number.ci:26: referenced as `sxt`
	test/std/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009e48>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/std/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a048>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/std/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a248>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/std/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a448>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/std/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a648>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	test/std/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a848>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(29)
.usages:
	test/std/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00ab70>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00ae98>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/std/number.ci:66: referenced as `uint64`
	test/std/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
	lib/std/string.ci:253: referenced as `uint64`
	lib/std/string.ci:249: referenced as `uint64`
	lib/std/string.ci:230: referenced as `uint64`
	lib/std/string.ci:228: referenced as `uint64`
	lib/std/string.ci:226: referenced as `uint64`
	lib/std/string.ci:224: referenced as `uint64`
	lib/std/string.ci:222: referenced as `uint64`
	lib/std/string.ci:220: referenced as `uint64`
	lib/std/string.ci:218: referenced as `uint64`
	lib/std/string.ci:216: referenced as `uint64`
	lib/std/string.ci:216: referenced as `uint64`
	lib/std/string.ci:143: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab70>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(30)
.usages:
	test/std/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ae98>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(31)
.usages:
	test/std/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00b098>, cast: static const inline)
.field cos: function (size: 0, offs: <@00b298>, cast: static const inline)
.field tan: function (size: 0, offs: <@00b498>, cast: static const inline)
.field log: function (size: 0, offs: <@00b698>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b898>, cast: static const inline)
.field pow: function (size: 0, offs: <@00bb30>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00bd30>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00bfc8>, cast: static const inline)
.value: 0
.usages:
	test/std/test.math.ci:96: referenced as `float32`
	test/std/test.math.ci:95: referenced as `float32`
	test/std/test.math.ci:94: referenced as `float32`
	test/std/test.math.ci:93: referenced as `float32`
	test/std/test.math.ci:91: referenced as `float32`
	test/std/test.math.ci:90: referenced as `float32`
	test/std/test.math.ci:89: referenced as `float32`
	test/std/test.math.ci:88: referenced as `float32`
	test/std/test.math.ci:86: referenced as `float32`
	test/std/test.math.ci:85: referenced as `float32`
	test/std/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/std/number.ci:53: referenced as `float32`
	test/std/number.ci:53: referenced as `float32`
	test/std/number.ci:52: referenced as `float32`
	test/std/number.ci:52: referenced as `float32`
	test/std/number.ci:51: referenced as `float32`
	test/std/number.ci:51: referenced as `float32`
	test/std/number.ci:50: referenced as `float32`
	test/std/number.ci:50: referenced as `float32`
	test/std/number.ci:49: referenced as `float32`
	test/std/number.ci:49: referenced as `float32`
	test/std/number.ci:48: referenced as `float32`
	test/std/number.ci:48: referenced as `float32`
	test/std/number.ci:47: referenced as `float32`
	test/std/number.ci:47: referenced as `float32`
	test/std/number.ci:46: referenced as `float32`
	test/std/number.ci:46: referenced as `float32`
	test/std/number.ci:7: referenced as `float32`
	test/std/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/std/string.ci:258: referenced as `float32`
	lib/std/math/Matrix4f.ci:169: referenced as `float32`
	lib/std/math/Matrix4f.ci:168: referenced as `float32`
	lib/std/math/Matrix4f.ci:158: referenced as `float32`
	lib/std/math/Matrix4f.ci:155: referenced as `float32`
	lib/std/math/Matrix4f.ci:132: referenced as `float32`
	lib/std/math/Matrix4f.ci:131: referenced as `float32`
	lib/std/math/Matrix4f.ci:131: referenced as `float32`
	lib/std/math/Matrix4f.ci:130: referenced as `float32`
	lib/std/math/Matrix4f.ci:130: referenced as `float32`
	lib/std/math/Matrix4f.ci:128: referenced as `float32`
	lib/std/math/Matrix4f.ci:127: referenced as `float32`
	lib/std/math/Matrix4f.ci:126: referenced as `float32`
	lib/std/math/Matrix4f.ci:125: referenced as `float32`
	lib/std/math/Matrix4f.ci:124: referenced as `float32`
	lib/std/math/Matrix4f.ci:123: referenced as `float32`
	lib/std/math/Matrix4f.ci:122: referenced as `float32`
	lib/std/math/Matrix4f.ci:121: referenced as `float32`
	lib/std/math/Matrix4f.ci:120: referenced as `float32`
	lib/std/math/Matrix4f.ci:119: referenced as `float32`
	lib/std/math/Matrix4f.ci:118: referenced as `float32`
	lib/std/math/Matrix4f.ci:117: referenced as `float32`
	lib/std/math/Matrix4f.ci:107: referenced as `float32`
	lib/std/math/Matrix4f.ci:106: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:57: referenced as `float32`
	lib/std/math/Matrix4f.ci:55: referenced as `float32`
	lib/std/math/Matrix4f.ci:53: referenced as `float32`
	lib/std/math/Matrix4f.ci:51: referenced as `float32`
	lib/std/math/Matrix4f.ci:48: referenced as `float32`
	lib/std/math/Matrix4f.ci:46: referenced as `float32`
	lib/std/math/Matrix4f.ci:44: referenced as `float32`
	lib/std/math/Matrix4f.ci:42: referenced as `float32`
	lib/std/math/Matrix4f.ci:39: referenced as `float32`
	lib/std/math/Matrix4f.ci:37: referenced as `float32`
	lib/std/math/Matrix4f.ci:35: referenced as `float32`
	lib/std/math/Matrix4f.ci:33: referenced as `float32`
	lib/std/math/Matrix4f.ci:30: referenced as `float32`
	lib/std/math/Matrix4f.ci:28: referenced as `float32`
	lib/std/math/Matrix4f.ci:26: referenced as `float32`
	lib/std/math/Matrix4f.ci:24: referenced as `float32`
	lib/std/math/Matrix4f.ci:7: referenced as `float32`
	lib/std/math/Matrix4f.ci:4: referenced as `float32`
	lib/std/math/Vector4f.ci:107: referenced as `float32`
	lib/std/math/Vector4f.ci:107: referenced as `float32`
	lib/std/math/Vector4f.ci:102: referenced as `float32`
	lib/std/math/Vector4f.ci:96: referenced as `float32`
	lib/std/math/Vector4f.ci:92: referenced as `float32`
	lib/std/math/Vector4f.ci:88: referenced as `float32`
	lib/std/math/Vector4f.ci:84: referenced as `float32`
	lib/std/math/Vector4f.ci:82: referenced as `float32`
	lib/std/math/Vector4f.ci:40: referenced as `float32`
	lib/std/math/Vector4f.ci:37: referenced as `float32`
	lib/std/math/Vector4f.ci:34: referenced as `float32`
	lib/std/math/Vector4f.ci:34: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:13: referenced as `float32`
	lib/std/math/Vector4f.ci:11: referenced as `float32`
	lib/std/math/Vector4f.ci:9: referenced as `float32`
	lib/std/math/Vector4f.ci:7: referenced as `float32`
	lib/std/math/Vector4f.ci:4: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	lib/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b098>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/std/number.ci:46: referenced as `sin`
	lib/std/math/Matrix4f.ci:130: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b298>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/std/number.ci:47: referenced as `cos`
	lib/std/math/Matrix4f.ci:131: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b498>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/std/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b698>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/std/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b898>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(36)
.usages:
	test/std/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bb30>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(37)
.usages:
	test/std/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bd30>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(38)
.usages:
	test/std/number.ci:52: referenced as `sqrt`
	lib/std/math/Vector4f.ci:102: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bfc8>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(39)
.usages:
	test/std/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00c1c0>, cast: static const inline)
.field cos: function (size: 0, offs: <@00c3b8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c5b0>, cast: static const inline)
.field log: function (size: 0, offs: <@00c7a8>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c9a0>, cast: static const inline)
.field pow: function (size: 0, offs: <@00cc30>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00ce28>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00d0b8>, cast: static const inline)
.value: 0
.usages:
	test/std/test.math.ci:82: referenced as `float64`
	test/std/test.math.ci:81: referenced as `float64`
	test/std/test.math.ci:80: referenced as `float64`
	test/std/test.math.ci:79: referenced as `float64`
	test/std/test.math.ci:77: referenced as `float64`
	test/std/test.math.ci:76: referenced as `float64`
	test/std/test.math.ci:75: referenced as `float64`
	test/std/test.math.ci:74: referenced as `float64`
	test/std/test.math.ci:72: referenced as `float64`
	test/std/test.math.ci:71: referenced as `float64`
	test/std/test.math.ci:70: referenced as `float64`
	test/std/test.math.ci:64: referenced as `float64`
	test/std/test.math.ci:63: referenced as `float64`
	test/std/test.math.ci:61: referenced as `float64`
	test/std/test.math.ci:60: referenced as `float64`
	test/std/test.math.ci:59: referenced as `float64`
	test/std/test.math.ci:58: referenced as `float64`
	test/std/test.math.ci:57: referenced as `float64`
	test/std/test.math.ci:55: referenced as `float64`
	test/std/test.math.ci:54: referenced as `float64`
	test/std/test.math.ci:53: referenced as `float64`
	test/std/test.math.ci:52: referenced as `float64`
	test/std/test.math.ci:51: referenced as `float64`
	test/std/test.math.ci:50: referenced as `float64`
	test/std/test.math.ci:49: referenced as `float64`
	test/std/test.math.ci:48: referenced as `float64`
	test/std/test.math.ci:46: referenced as `float64`
	test/std/test.math.ci:45: referenced as `float64`
	test/std/test.math.ci:44: referenced as `float64`
	test/std/test.math.ci:43: referenced as `float64`
	test/std/test.math.ci:41: referenced as `float64`
	test/std/test.math.ci:40: referenced as `float64`
	test/std/test.math.ci:39: referenced as `float64`
	test/std/test.math.ci:38: referenced as `float64`
	test/std/test.math.ci:36: referenced as `float64`
	test/std/test.math.ci:35: referenced as `float64`
	test/std/test.math.ci:33: referenced as `float64`
	test/std/test.math.ci:32: referenced as `float64`
	test/std/test.math.ci:30: referenced as `float64`
	test/std/test.math.ci:29: referenced as `float64`
	test/std/test.math.ci:27: referenced as `float64`
	test/std/test.math.ci:26: referenced as `float64`
	test/std/test.math.ci:25: referenced as `float64`
	test/std/test.math.ci:24: referenced as `float64`
	test/std/test.math.ci:22: referenced as `float64`
	test/std/test.math.ci:21: referenced as `float64`
	test/std/test.math.ci:20: referenced as `float64`
	test/std/test.math.ci:19: referenced as `float64`
	test/std/test.math.ci:18: referenced as `float64`
	test/std/test.math.ci:17: referenced as `float64`
	test/std/test.math.ci:15: referenced as `float64`
	test/std/test.math.ci:14: referenced as `float64`
	test/std/test.math.ci:13: referenced as `float64`
	test/std/test.math.ci:12: referenced as `float64`
	test/std/test.math.ci:11: referenced as `float64`
	test/std/test.math.ci:10: referenced as `float64`
	test/std/test.math.ci:8: referenced as `float64`
	test/std/test.math.ci:7: referenced as `float64`
	test/std/test.math.ci:6: referenced as `float64`
	test/std/test.math.ci:5: referenced as `float64`
	test/std/test.math.ci:4: referenced as `float64`
	test/std/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/std/number.ci:44: referenced as `float64`
	test/std/number.ci:44: referenced as `float64`
	test/std/number.ci:43: referenced as `float64`
	test/std/number.ci:43: referenced as `float64`
	test/std/number.ci:42: referenced as `float64`
	test/std/number.ci:42: referenced as `float64`
	test/std/number.ci:41: referenced as `float64`
	test/std/number.ci:41: referenced as `float64`
	test/std/number.ci:40: referenced as `float64`
	test/std/number.ci:40: referenced as `float64`
	test/std/number.ci:39: referenced as `float64`
	test/std/number.ci:39: referenced as `float64`
	test/std/number.ci:38: referenced as `float64`
	test/std/number.ci:38: referenced as `float64`
	test/std/number.ci:37: referenced as `float64`
	test/std/number.ci:37: referenced as `float64`
	test/std/number.ci:4: referenced as `float64`
	test/std/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/std/string.ci:258: referenced as `float64`
	lib/std/string.ci:252: referenced as `float64`
	lib/std/string.ci:248: referenced as `float64`
	lib/std/string.ci:233: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:9: referenced as `float64`
	lib/std/math/Vector2d.ci:7: referenced as `float64`
	lib/std/math/Vector2d.ci:4: referenced as `float64`
	lib/std/math/Complex.ci:184: referenced as `float64`
	lib/std/math/Complex.ci:184: referenced as `float64`
	lib/std/math/Complex.ci:148: referenced as `float64`
	lib/std/math/Complex.ci:148: referenced as `float64`
	lib/std/math/Complex.ci:146: referenced as `float64`
	lib/std/math/Complex.ci:146: referenced as `float64`
	lib/std/math/Complex.ci:143: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:138: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:135: referenced as `float64`
	lib/std/math/Complex.ci:135: referenced as `float64`
	lib/std/math/Complex.ci:134: referenced as `float64`
	lib/std/math/Complex.ci:133: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:126: referenced as `float64`
	lib/std/math/Complex.ci:115: referenced as `float64`
	lib/std/math/Complex.ci:111: referenced as `float64`
	lib/std/math/Complex.ci:109: referenced as `float64`
	lib/std/math/Complex.ci:106: referenced as `float64`
	lib/std/math/Complex.ci:104: referenced as `float64`
	lib/std/math/Complex.ci:96: referenced as `float64`
	lib/std/math/Complex.ci:95: referenced as `float64`
	lib/std/math/Complex.ci:89: referenced as `float64`
	lib/std/math/Complex.ci:88: referenced as `float64`
	lib/std/math/Complex.ci:80: referenced as `float64`
	lib/std/math/Complex.ci:78: referenced as `float64`
	lib/std/math/Complex.ci:73: referenced as `float64`
	lib/std/math/Complex.ci:71: referenced as `float64`
	lib/std/math/Complex.ci:66: referenced as `float64`
	lib/std/math/Complex.ci:64: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:24: referenced as `float64`
	lib/std/math/Complex.ci:8: referenced as `float64`
	lib/std/math/Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	lib/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c1c0>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/std/number.ci:37: referenced as `sin`
	lib/std/math/Complex.ci:184: referenced as `sin`
	lib/std/math/Complex.ci:148: referenced as `sin`
	lib/std/math/Complex.ci:146: referenced as `sin`
	lib/std/math/Complex.ci:139: referenced as `sin`
	lib/std/math/Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c3b8>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/std/number.ci:38: referenced as `cos`
	lib/std/math/Complex.ci:184: referenced as `cos`
	lib/std/math/Complex.ci:148: referenced as `cos`
	lib/std/math/Complex.ci:146: referenced as `cos`
	lib/std/math/Complex.ci:138: referenced as `cos`
	lib/std/math/Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c5b0>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/std/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c7a8>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/std/number.ci:40: referenced as `log`
	lib/std/math/Complex.ci:135: referenced as `log`
	lib/std/math/Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c9a0>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(44)
.usages:
	test/std/number.ci:41: referenced as `exp`
	lib/std/math/Complex.ci:136: referenced as `exp`
	lib/std/math/Complex.ci:126: referenced as `exp`
	lib/std/math/Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cc30>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(45)
.usages:
	test/std/number.ci:42: referenced as `pow`
	lib/std/string.ci:252: referenced as `pow`
	lib/std/math/Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ce28>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(46)
.usages:
	test/std/number.ci:43: referenced as `sqrt`
	lib/std/math/Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d0b8>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(47)
.usages:
	test/std/number.ci:44: referenced as `atan2`
	lib/std/math/Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007ff0>, cast: static const inline)
.field fill: function (size: 0, offs: <@008328>, cast: static const inline)
.field copy: function (size: 0, offs: <@008660>, cast: static const inline)
.field move: function (size: 0, offs: <@008990>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/std/tryExec.ci:42: referenced as `pointer`
	test/std/tryExec.ci:37: referenced as `pointer`
	test/std/tryExec.ci:23: referenced as `pointer`
	test/std/tryExec.ci:19: referenced as `pointer`
	test/std/tryExec.ci:14: referenced as `pointer`
	test/std/tryExec.ci:11: referenced as `pointer`
	test/std/memory.ci:30: referenced as `pointer`
	test/std/memory.ci:30: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:14: referenced as `pointer`
	test/std/memory.ci:13: referenced as `pointer`
	test/std/memory.ci:10: referenced as `pointer`
	test/std/memory.ci:9: referenced as `pointer`
	test/std/memory.ci:8: referenced as `pointer`
	test/std/memory.ci:7: referenced as `pointer`
	test/std/memory.ci:5: referenced as `pointer`
	test/std/memory.ci:5: referenced as `pointer`
	test/std/memory.ci:4: referenced as `pointer`
	test/std/memory.ci:3: referenced as `pointer`
	test/std/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007ff0>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(11)
.usages:
	test/std/memory.ci:5: referenced as `alloc`
	test/std/memory.ci:4: referenced as `alloc`
	test/std/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008328>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	test/std/memory.ci:30: referenced as `fill`
	test/std/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008660>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(13)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/std/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008990>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(14)
.usages:
	test/std/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.field is: function (size: 0, offs: <@005ba0>, cast: static const inline)
.field as: function (size: 0, offs: <@005e38>, cast: static const inline)
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/std/debug.ci:56: referenced as `variant`
	lib/std/debug.ci:53: referenced as `variant`
	lib/std/debug.ci:50: referenced as `variant`
	lib/std/debug.ci:41: referenced as `variant`
	lib/std/debug.ci:34: referenced as `variant`
	lib/std/debug.ci:29: referenced as `variant`
	lib/std/debug.ci:24: referenced as `variant`
	lib/std/debug.ci:19: referenced as `variant`
	lib/std/debug.ci:14: referenced as `variant`
	lib/std/debug.ci:9: referenced as `variant`
	lib/std/debug.ci:4: referenced as `variant`
	internal usages: 3
}
variant.is(var: variant, type: typename): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ba0>
.name: 'is'
.owner: variant
.param .result: bool (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
	internal usages: 1
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005e38>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(2)
.usages:
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006a18>, cast: static const inline)
.field as: function (size: 0, offs: <@006cb0>, cast: static const inline)
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
	internal usages: 1
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006a18>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006cb0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:92: referenced as `null`
	test/lang/method.ci:86: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/std/tryExec.ci:52: referenced as `null`
	test/std/tryExec.ci:51: referenced as `null`
	test/std/tryExec.ci:50: referenced as `null`
	test/std/tryExec.ci:49: referenced as `null`
	test/std/tryExec.ci:48: referenced as `null`
	test/std/tryExec.ci:47: referenced as `null`
	test/std/tryExec.ci:47: referenced as `null`
	test/std/tryExec.ci:46: referenced as `null`
	test/std/tryExec.ci:38: referenced as `null`
	test/std/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/std/debug.ci:76: referenced as `null`
	lib/std/debug.ci:59: referenced as `null`
	lib/std/debug.ci:56: referenced as `null`
	lib/std/debug.ci:38: referenced as `null`
	lib/std/debug.ci:36: referenced as `null`
	lib/std/debug.ci:31: referenced as `null`
	lib/std/debug.ci:26: referenced as `null`
	lib/std/debug.ci:21: referenced as `null`
	lib/std/debug.ci:16: referenced as `null`
	lib/std/debug.ci:11: referenced as `null`
	lib/std/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000d38>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000dd8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001198>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001238>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0014b8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a58>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001df0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001fd0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0021a0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002370>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002540>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002710>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002a10>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002e60>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003290>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0036c0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003c20>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@004180>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0045b0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@0049e0>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@004e10>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005240>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005410>, cast: static const typename(void))
.usages:
	test/std/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/std/math/Vector2d.ci:22: referenced as `emit`
	lib/std/math/Vector4f.ci:96: referenced as `emit`
	lib/std/math/Vector4f.ci:92: referenced as `emit`
	lib/std/math/Vector4f.ci:88: referenced as `emit`
	lib/std/math/Vector4f.ci:84: referenced as `emit`
	lib/std/math/Vector4f.ci:82: referenced as `emit`
	lib/std/math/Vector4f.ci:79: referenced as `emit`
	lib/std/math/Vector4f.ci:77: referenced as `emit`
	lib/std/math/Vector4f.ci:75: referenced as `emit`
	lib/std/math/Vector4f.ci:73: referenced as `emit`
	lib/std/math/Vector4f.ci:71: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/std/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001198>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `p4x`
	lib/std/math/Vector4f.ci:92: referenced as `p4x`
	lib/std/math/Vector4f.ci:88: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/std/math/Vector4f.ci:88: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/std/math/Vector4f.ci:92: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001238>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0014b8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/std/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/std/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a58>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001df0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001fd0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0021a0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002370>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002540>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002710>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a10>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002e60>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/std/math/Vector4f.ci:73: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/std/math/Vector4f.ci:73: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003290>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:22: referenced as `sub`
	lib/std/math/Vector4f.ci:75: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/std/math/Vector4f.ci:75: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/std/math/Vector2d.ci:22: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0036c0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/std/math/Vector4f.ci:77: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003c20>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/std/math/Vector4f.ci:79: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/std/math/Vector4f.ci:79: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004180>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0045b0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0049e0>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e10>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005240>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005410>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:84: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/std/math/Vector4f.ci:84: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005900>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007470>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(9)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/std/debug.ci:73: referenced as `abort`
	lib/std/debug.ci:38: referenced as `abort`
	lib/std/debug.ci:36: referenced as `abort`
	lib/std/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/std/debug.ci:31: referenced as `error`
	lib/std/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/std/debug.ci:26: referenced as `warn`
	lib/std/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/std/debug.ci:21: referenced as `info`
	lib/std/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/std/debug.ci:16: referenced as `debug`
	lib/std/debug.ci:14: referenced as `debug`
	lib/std/debug.ci:11: referenced as `debug`
	lib/std/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/std/debug.ci:6: referenced as `verbose`
	lib/std/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/std/debug.ci:26: referenced as `noTrace`
	lib/std/debug.ci:24: referenced as `noTrace`
	lib/std/debug.ci:21: referenced as `noTrace`
	lib/std/debug.ci:19: referenced as `noTrace`
	lib/std/debug.ci:11: referenced as `noTrace`
	lib/std/debug.ci:9: referenced as `noTrace`
	lib/std/debug.ci:6: referenced as `noTrace`
	lib/std/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/std/debug.ci:73: referenced as `defTrace`
	lib/std/debug.ci:38: referenced as `defTrace`
	lib/std/debug.ci:36: referenced as `defTrace`
	lib/std/debug.ci:34: referenced as `defTrace`
	lib/std/debug.ci:31: referenced as `defTrace`
	lib/std/debug.ci:29: referenced as `defTrace`
	lib/std/debug.ci:16: referenced as `defTrace`
	lib/std/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007d50>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(10)
.usages:
	test/std/tryExec.ci:52: referenced as `tryExec`
	test/std/tryExec.ci:51: referenced as `tryExec`
	test/std/tryExec.ci:50: referenced as `tryExec`
	test/std/tryExec.ci:49: referenced as `tryExec`
	test/std/tryExec.ci:48: referenced as `tryExec`
	test/std/tryExec.ci:47: referenced as `tryExec`
	test/std/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0089c0>
.name: 'System'
.field exit: function (size: 0, offs: <@008c38>, cast: static const inline)
.field srand: function (size: 0, offs: <@008e40>, cast: static const inline)
.field rand: function (size: 0, offs: <@008fa8>, cast: static const inline)
.field time: function (size: 0, offs: <@009110>, cast: static const inline)
.field clock: function (size: 0, offs: <@009278>, cast: static const inline)
.field millis: function (size: 0, offs: <@0093e0>, cast: static const inline)
.field sleep: function (size: 0, offs: <@0095e0>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008c38>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(15)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e40>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(16)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008fa8>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009110>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(18)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009278>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(19)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093e0>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(20)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0095e0>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(21)
.usages:
	internal usages: 1
}
true: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'true'
.file: 'lib/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
	lib/stdlib.ci:4: defined as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'false'
.file: 'lib/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:241: referenced as `false`
	lib/std/string.ci:113: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
	lib/stdlib.ci:5: defined as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'lib/stdlib.ci:8'
.value: uint8
.usages:
	lib/stdlib.ci:8: defined as `byte`
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'lib/stdlib.ci:9'
.value: float32
.usages:
	lib/stdlib.ci:9: defined as `float`
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'lib/stdlib.ci:10'
.value: float64
.usages:
	lib/stdlib.ci:10: defined as `double`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/std/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/std/debug.ci:4: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/std/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/std/debug.ci:6: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/std/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/std/memory.ci:33: referenced as `debug`
	test/std/memory.ci:32: referenced as `debug`
	test/std/memory.ci:27: referenced as `debug`
	test/std/memory.ci:26: referenced as `debug`
	lib/std/debug.ci:9: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/std/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:91: referenced as `debug`
	test/lang/method.ci:85: referenced as `debug`
	lib/std/debug.ci:11: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/std/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:58: referenced as `trace`
	test/lang/method.ci:48: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:11: referenced as `trace`
	lib/std/math/Matrix4f.ci:109: referenced as `trace`
	lib/std/debug.ci:14: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/std/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/std/debug.ci:16: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/std/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/std/debug.ci:19: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/std/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/std/debug.ci:21: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/std/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/std/debug.ci:24: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/std/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/std/debug.ci:26: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/std/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/std/debug.ci:29: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/std/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/std/debug.ci:31: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/std/tryExec.ci:34: referenced as `abort`
	lib/std/debug.ci:41: referenced as `abort`
	lib/std/debug.ci:34: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/std/debug.ci:45: referenced as `abort`
	lib/std/debug.ci:43: referenced as `abort`
	lib/std/debug.ci:36: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/std/debug.ci:38: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:161: referenced as `assert`
	lib/std/string.ci:160: referenced as `assert`
	lib/std/debug.ci:41: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/std/debug.ci:43: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:203: referenced as `assert`
	lib/std/string.ci:196: referenced as `assert`
	lib/std/string.ci:189: referenced as `assert`
	lib/std/string.ci:184: referenced as `assert`
	lib/std/debug.ci:45: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0106b0>
.name: 'NotEquals'
.file: 'lib/std/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/std/debug.ci:68: referenced as `NotEquals`
	lib/std/debug.ci:48: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/std/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/std/debug.ci:69: referenced as `expected`
	lib/std/debug.ci:50: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/std/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/std/debug.ci:70: referenced as `returned`
	lib/std/debug.ci:53: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/std/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:56: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/std/debug.ci:59'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:71: referenced as `message`
	lib/std/debug.ci:59: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@055c80>
.name: 'assertEq'
.file: 'lib/std/debug.ci:64'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@055c80> - <@055cde>)
	lib/std/debug.ci:65: (10 bytes: <@055c80> - <@055c8a>): if (bool(returned == expected))
	<assertEq @055c80>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @055c82>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @055c84>    : 57                         ceq.i32
	<assertEq+5 @055c85>    : 06 05 00 00                jz <assertEq+10 @055c8a>
	lib/std/debug.ci:66: (1 byte: <@055c89> - <@055c8a>): return;
	<assertEq+9 @055c89>    : 03                         ret
	lib/std/debug.ci:68: (41 bytes: <@055c8a> - <@055cb3>): details: NotEquals := {...}
	<assertEq+10 @055c8a>   : 09 20 00 00                inc.sp(+32)
	lib/std/debug.ci:69: (11 bytes: <@055c8e> - <@055c99>): void(details.expected := (expected));
	<assertEq+14 @055c8e>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @055c93>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @055c97>   : 14 02                      set.x64 sp(2)
	lib/std/debug.ci:70: (11 bytes: <@055c99> - <@055ca4>): void(details.returned := (returned));
	<assertEq+25 @055c99>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @055c9e>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @055ca2>   : 14 04                      set.x64 sp(4)
	lib/std/debug.ci:71: (3 bytes: <@055ca4> - <@055ca7>): void(details.message := (message));
	<assertEq+36 @055ca4>   : 16 06 09                   mov.x32 sp(6, 9)
	:: (12 bytes: <@055ca7> - <@055cb3>): void(details.argument := (null))
	<assertEq+39 @055ca7>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @055cac>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @055cb1>   : 14 06                      set.x64 sp(6)
	lib/std/debug.ci:73: (38 bytes: <@055cb3> - <@055cd9>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @055cb3>   : 1f b0 d4 00 00             load.ref <@00d4b0> ;"lib/std/debug.ci"
	<assertEq+56 @055cb8>   : 1c 49 00 00 00             load.c32 73
	<assertEq+61 @055cbd>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @055cc2>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @055cc7>   : 1f b6 d7 00 00             load.ref <@00d7b6> ;"assertion failed"
	<assertEq+76 @055ccc>   : 1f b0 06 01 00             load.ref <@0106b0> ;NotEquals
	<assertEq+81 @055cd1>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @055cd5>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @055cd9>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @055cdd>   : 03                         ret
.usages:
	lib/std/debug.ci:76: referenced as `assertEq`
	lib/std/debug.ci:64: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'lib/std/debug.ci:76'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/std/debug.ci:76: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'lib/stdlib.ci:17'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/std/memory.ci:30: referenced as `sizeof`
	test/std/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:17: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@011918>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@055ce0>, cast: static const function)
.field floor: function (size: 24, offs: <@055d38>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@055d50>, cast: static const function)
.field abs: function (size: 18, offs: <@055d68>, cast: static const function)
.field absMod: function (size: 27, offs: <@055d80>, cast: static const function)
.field absMod: function (size: 27, offs: <@055da0>, cast: static const function)
.field min: function (size: 17, offs: <@055dc0>, cast: static const function)
.field min: function (size: 17, offs: <@055dd8>, cast: static const function)
.field max: function (size: 17, offs: <@055df0>, cast: static const function)
.field max: function (size: 17, offs: <@055e08>, cast: static const function)
.field clamp: function (size: 30, offs: <@055e20>, cast: static const function)
.field clamp: function (size: 30, offs: <@055e40>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@055e60>, cast: static const function)
.field max: function (size: 79, offs: <@055eb0>, cast: static const function)
.field sum: function (size: 40, offs: <@055f00>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@055f28>, cast: static const function)
.field cmp: function (size: 57, offs: <@055f58>, cast: static const function)
.field cmp: function (size: 57, offs: <@055f98>, cast: static const function)
.field sinCos: function (size: 335, offs: <@055fd8>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@056128>, cast: static const function)
.field sinh: function (size: 241, offs: <@0562a8>, cast: static const function)
.field cosh: function (size: 75, offs: <@0563a0>, cast: static const function)
.field asin: function (size: 173, offs: <@0563f0>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/std/test.math.ci:96: referenced as `Math`
	test/std/test.math.ci:95: referenced as `Math`
	test/std/test.math.ci:94: referenced as `Math`
	test/std/test.math.ci:93: referenced as `Math`
	test/std/test.math.ci:91: referenced as `Math`
	test/std/test.math.ci:90: referenced as `Math`
	test/std/test.math.ci:89: referenced as `Math`
	test/std/test.math.ci:88: referenced as `Math`
	test/std/test.math.ci:86: referenced as `Math`
	test/std/test.math.ci:85: referenced as `Math`
	test/std/test.math.ci:84: referenced as `Math`
	test/std/test.math.ci:82: referenced as `Math`
	test/std/test.math.ci:81: referenced as `Math`
	test/std/test.math.ci:80: referenced as `Math`
	test/std/test.math.ci:79: referenced as `Math`
	test/std/test.math.ci:77: referenced as `Math`
	test/std/test.math.ci:76: referenced as `Math`
	test/std/test.math.ci:75: referenced as `Math`
	test/std/test.math.ci:74: referenced as `Math`
	test/std/test.math.ci:72: referenced as `Math`
	test/std/test.math.ci:71: referenced as `Math`
	test/std/test.math.ci:70: referenced as `Math`
	test/std/test.math.ci:68: referenced as `Math`
	test/std/test.math.ci:67: referenced as `Math`
	test/std/test.math.ci:64: referenced as `Math`
	test/std/test.math.ci:63: referenced as `Math`
	test/std/test.math.ci:61: referenced as `Math`
	test/std/test.math.ci:61: referenced as `Math`
	test/std/test.math.ci:60: referenced as `Math`
	test/std/test.math.ci:60: referenced as `Math`
	test/std/test.math.ci:59: referenced as `Math`
	test/std/test.math.ci:59: referenced as `Math`
	test/std/test.math.ci:58: referenced as `Math`
	test/std/test.math.ci:58: referenced as `Math`
	test/std/test.math.ci:57: referenced as `Math`
	test/std/test.math.ci:57: referenced as `Math`
	test/std/test.math.ci:55: referenced as `Math`
	test/std/test.math.ci:54: referenced as `Math`
	test/std/test.math.ci:53: referenced as `Math`
	test/std/test.math.ci:52: referenced as `Math`
	test/std/test.math.ci:51: referenced as `Math`
	test/std/test.math.ci:50: referenced as `Math`
	test/std/test.math.ci:49: referenced as `Math`
	test/std/test.math.ci:46: referenced as `Math`
	test/std/test.math.ci:45: referenced as `Math`
	test/std/test.math.ci:44: referenced as `Math`
	test/std/test.math.ci:43: referenced as `Math`
	test/std/test.math.ci:41: referenced as `Math`
	test/std/test.math.ci:40: referenced as `Math`
	test/std/test.math.ci:39: referenced as `Math`
	test/std/test.math.ci:38: referenced as `Math`
	test/std/test.math.ci:36: referenced as `Math`
	test/std/test.math.ci:35: referenced as `Math`
	test/std/test.math.ci:33: referenced as `Math`
	test/std/test.math.ci:32: referenced as `Math`
	test/std/test.math.ci:30: referenced as `Math`
	test/std/test.math.ci:29: referenced as `Math`
	test/std/test.math.ci:27: referenced as `Math`
	test/std/test.math.ci:26: referenced as `Math`
	test/std/test.math.ci:25: referenced as `Math`
	test/std/test.math.ci:24: referenced as `Math`
	test/std/test.math.ci:22: referenced as `Math`
	test/std/test.math.ci:21: referenced as `Math`
	test/std/test.math.ci:20: referenced as `Math`
	test/std/test.math.ci:19: referenced as `Math`
	test/std/test.math.ci:18: referenced as `Math`
	test/std/test.math.ci:17: referenced as `Math`
	test/std/test.math.ci:15: referenced as `Math`
	test/std/test.math.ci:14: referenced as `Math`
	test/std/test.math.ci:13: referenced as `Math`
	test/std/test.math.ci:12: referenced as `Math`
	test/std/test.math.ci:11: referenced as `Math`
	test/std/test.math.ci:10: referenced as `Math`
	test/std/test.math.ci:8: referenced as `Math`
	test/std/test.math.ci:7: referenced as `Math`
	test/std/test.math.ci:6: referenced as `Math`
	test/std/test.math.ci:5: referenced as `Math`
	test/std/test.math.ci:4: referenced as `Math`
	test/std/test.math.ci:3: referenced as `Math`
	lib/std/string.ci:248: referenced as `Math`
	lib/std/string.ci:248: referenced as `Math`
	lib/std/math/Complex.ci:148: referenced as `Math`
	lib/std/math/Complex.ci:148: referenced as `Math`
	lib/std/math/Complex.ci:146: referenced as `Math`
	lib/std/math/Complex.ci:146: referenced as `Math`
	lib/std/math/Complex.ci:87: referenced as `Math`
	lib/std/math/Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/std/test.math.ci:61: referenced as `pi`
	test/std/test.math.ci:60: referenced as `pi`
	test/std/test.math.ci:59: referenced as `pi`
	test/std/test.math.ci:58: referenced as `pi`
	test/std/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@055ce0>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@055ce0> - <@055d36>)
	lib/std/math.ci:23: (63 bytes: <@055ce0> - <@055d1f>): if (bool(x < (1)))
	<modf @055ce0>      : 11 02                      dup.x64 sp(2)
	<modf+2 @055ce2>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @055ceb>   : 88                         clt.f64
	<modf+12 @055cec>   : 06 33 00 00                jz <modf+63 @055d1f>
	lib/std/math.ci:24: (39 bytes: <@055cf0> - <@055d17>): if (bool(x < (0)))
	<modf+16 @055cf0>   : 11 02                      dup.x64 sp(2)
	<modf+18 @055cf2>   : 1a                         load.z64
	<modf+19 @055cf3>   : 88                         clt.f64
	<modf+20 @055cf4>   : 06 23 00 00                jz <modf+55 @055d17>
	lib/std/math.ci:25: (17 bytes: <@055cf8> - <@055d09>): result: float64 := float64(-modf(void(float64(-x), float64(&intPart))))
	<modf+24 @055cf8>   : 1a                         load.z64
	<modf+25 @055cf9>   : 11 04                      dup.x64 sp(4)
	<modf+27 @055cfb>   : 80                         neg.f64
	<modf+28 @055cfc>   : 10 05                      dup.x32 sp(5)
	<modf+30 @055cfe>   : 1f e0 5c 05 00             load.ref <@055ce0> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @055d03>   : 02                         call
	<modf+36 @055d04>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @055d08>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@055d09> - <@055d10>): float64(intPart := float64(-intPart));
	<modf+41 @055d09>   : 10 03                      dup.x32 sp(3)
	<modf+43 @055d0b>   : 23                         load.i64
	<modf+44 @055d0c>   : 80                         neg.f64
	<modf+45 @055d0d>   : 10 05                      dup.x32 sp(5)
	<modf+47 @055d0f>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@055d10> - <@055d13>): return float64(.result := result);
	<modf+48 @055d10>   : 14 06                      set.x64 sp(6)
	<modf+50 @055d12>   : 03                         ret
	<modf+51 @055d13>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@055d17> - <@055d1b>): float64(intPart := (0));
	<modf+55 @055d17>   : 1a                         load.z64
	<modf+56 @055d18>   : 10 03                      dup.x32 sp(3)
	<modf+58 @055d1a>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@055d1b> - <@055d1f>): return float64(.result := x);
	<modf+59 @055d1b>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @055d1e>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@055d1f> - <@055d2b>): result: float64 := float64(x % (1))
	<modf+63 @055d1f>   : 11 02                      dup.x64 sp(2)
	<modf+65 @055d21>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @055d2a>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@055d2b> - <@055d33>): float64(intPart := float64(x - result));
	<modf+75 @055d2b>   : 11 04                      dup.x64 sp(4)
	<modf+77 @055d2d>   : 11 02                      dup.x64 sp(2)
	<modf+79 @055d2f>   : 82                         sub.f64
	<modf+80 @055d30>   : 10 05                      dup.x32 sp(5)
	<modf+82 @055d32>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@055d33> - <@055d36>): return float64(.result := result);
	<modf+83 @055d33>   : 14 06                      set.x64 sp(6)
	<modf+85 @055d35>   : 03                         ret
.usages:
	lib/std/string.ci:248: referenced as `modf`
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@055d38>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <@055d38> - <@055d50>)
	lib/std/math.ci:48: (1 byte: <@055d38> - <@055d39>): result: float64
	<floor @055d38>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@055d39> - <@055d4d>): modf(void(x, float64(&result)));
	<floor+1 @055d39>    : 11 05                      dup.x64 sp(5)
	<floor+3 @055d3b>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @055d3f>    : 1f e0 5c 05 00             load.ref <@055ce0> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @055d44>   : 02                         call
	<floor+13 @055d45>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @055d49>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@055d4d> - <@055d50>): return float64(.result := result);
	<floor+21 @055d4d>   : 14 05                      set.x64 sp(5)
	<floor+23 @055d4f>   : 03                         ret
.usages:
	test/std/test.math.ci:8: referenced as `floor`
	test/std/test.math.ci:7: referenced as `floor`
	test/std/test.math.ci:6: referenced as `floor`
	test/std/test.math.ci:5: referenced as `floor`
	test/std/test.math.ci:4: referenced as `floor`
	test/std/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/std/test.math.ci:15: referenced as `sign`
	test/std/test.math.ci:14: referenced as `sign`
	test/std/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/std/test.math.ci:12: referenced as `sign`
	test/std/test.math.ci:11: referenced as `sign`
	test/std/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@055d50>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@055d50> - <@055d62>)
	lib/std/math.ci:78: (14 bytes: <@055d50> - <@055d5e>): if (bool(x < (0)))
	<abs @055d50>      : 10 01                      dup.x32 sp(1)
	<abs+2 @055d52>    : 19                         load.z32
	<abs+3 @055d53>    : 78                         clt.f32
	<abs+4 @055d54>    : 06 0a 00 00                jz <abs+14 @055d5e>
	lib/std/math.ci:79: (6 bytes: <@055d58> - <@055d5e>): return float32(.result := float32(-x));
	<abs+8 @055d58>    : 10 01                      dup.x32 sp(1)
	<abs+10 @055d5a>   : 70                         neg.f32
	<abs+11 @055d5b>   : 13 03                      set.x32 sp(3)
	<abs+13 @055d5d>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@055d5e> - <@055d62>): return float32(.result := x);
	<abs+14 @055d5e>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @055d61>   : 03                         ret
.usages:
	test/std/test.math.ci:22: referenced as `abs`
	test/std/test.math.ci:21: referenced as `abs`
	test/std/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@055d68>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@055d68> - <@055d7a>)
	lib/std/math.ci:86: (14 bytes: <@055d68> - <@055d76>): if (bool(x < (0)))
	<abs @055d68>      : 11 01                      dup.x64 sp(1)
	<abs+2 @055d6a>    : 1a                         load.z64
	<abs+3 @055d6b>    : 88                         clt.f64
	<abs+4 @055d6c>    : 06 0a 00 00                jz <abs+14 @055d76>
	lib/std/math.ci:87: (6 bytes: <@055d70> - <@055d76>): return float64(.result := float64(-x));
	<abs+8 @055d70>    : 11 01                      dup.x64 sp(1)
	<abs+10 @055d72>   : 80                         neg.f64
	<abs+11 @055d73>   : 14 05                      set.x64 sp(5)
	<abs+13 @055d75>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@055d76> - <@055d7a>): return float64(.result := x);
	<abs+14 @055d76>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @055d79>   : 03                         ret
.usages:
	test/std/test.math.ci:19: referenced as `abs`
	test/std/test.math.ci:18: referenced as `abs`
	test/std/test.math.ci:17: referenced as `abs`
	lib/std/string.ci:248: referenced as `abs`
	lib/std/math/Complex.ci:87: referenced as `abs`
	lib/std/math/Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@055d80>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@055d80> - <@055d9b>)
	lib/std/math.ci:94: (23 bytes: <@055d80> - <@055d97>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @055d80>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @055d82>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @055d84>    : 75                         mod.f32
	<absMod+5 @055d85>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @055d87>    : 13 04                      set.x32 sp(4)
	<absMod+9 @055d89>    : 19                         load.z32
	<absMod+10 @055d8a>   : 78                         clt.f32
	<absMod+11 @055d8b>   : 06 0c 00 00                jz <absMod+23 @055d97>
	lib/std/math.ci:95: (8 bytes: <@055d8f> - <@055d97>): return float32(.result := float32(val + mod));
	<absMod+15 @055d8f>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @055d91>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @055d93>   : 71                         add.f32
	<absMod+20 @055d94>   : 13 04                      set.x32 sp(4)
	<absMod+22 @055d96>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@055d97> - <@055d9b>): return float32(.result := val);
	<absMod+23 @055d97>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @055d9a>   : 03                         ret
.usages:
	test/std/test.math.ci:96: referenced as `absMod`
	test/std/test.math.ci:95: referenced as `absMod`
	test/std/test.math.ci:94: referenced as `absMod`
	test/std/test.math.ci:93: referenced as `absMod`
	test/std/test.math.ci:91: referenced as `absMod`
	test/std/test.math.ci:90: referenced as `absMod`
	test/std/test.math.ci:89: referenced as `absMod`
	test/std/test.math.ci:88: referenced as `absMod`
	test/std/test.math.ci:86: referenced as `absMod`
	test/std/test.math.ci:85: referenced as `absMod`
	test/std/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@055da0>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@055da0> - <@055dbb>)
	lib/std/math.ci:102: (23 bytes: <@055da0> - <@055db7>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @055da0>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @055da2>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @055da4>    : 85                         mod.f64
	<absMod+5 @055da5>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @055da7>    : 14 07                      set.x64 sp(7)
	<absMod+9 @055da9>    : 1a                         load.z64
	<absMod+10 @055daa>   : 88                         clt.f64
	<absMod+11 @055dab>   : 06 0c 00 00                jz <absMod+23 @055db7>
	lib/std/math.ci:103: (8 bytes: <@055daf> - <@055db7>): return float64(.result := float64(val + mod));
	<absMod+15 @055daf>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @055db1>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @055db3>   : 81                         add.f64
	<absMod+20 @055db4>   : 14 07                      set.x64 sp(7)
	<absMod+22 @055db6>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@055db7> - <@055dbb>): return float64(.result := val);
	<absMod+23 @055db7>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @055dba>   : 03                         ret
.usages:
	test/std/test.math.ci:82: referenced as `absMod`
	test/std/test.math.ci:81: referenced as `absMod`
	test/std/test.math.ci:80: referenced as `absMod`
	test/std/test.math.ci:79: referenced as `absMod`
	test/std/test.math.ci:77: referenced as `absMod`
	test/std/test.math.ci:76: referenced as `absMod`
	test/std/test.math.ci:75: referenced as `absMod`
	test/std/test.math.ci:74: referenced as `absMod`
	test/std/test.math.ci:72: referenced as `absMod`
	test/std/test.math.ci:71: referenced as `absMod`
	test/std/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@055dc0>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@055dc0> - <@055dd1>)
	lib/std/math.ci:116: (13 bytes: <@055dc0> - <@055dcd>): if (bool(a < b))
	<min @055dc0>      : 10 02                      dup.x32 sp(2)
	<min+2 @055dc2>    : 10 02                      dup.x32 sp(2)
	<min+4 @055dc4>    : 78                         clt.f32
	<min+5 @055dc5>    : 06 08 00 00                jz <min+13 @055dcd>
	lib/std/math.ci:117: (4 bytes: <@055dc9> - <@055dcd>): return float32(.result := a);
	<min+9 @055dc9>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @055dcc>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@055dcd> - <@055dd1>): return float32(.result := b);
	<min+13 @055dcd>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @055dd0>   : 03                         ret
.usages:
	test/std/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@055dd8>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@055dd8> - <@055de9>)
	lib/std/math.ci:124: (13 bytes: <@055dd8> - <@055de5>): if (bool(a < b))
	<min @055dd8>      : 11 03                      dup.x64 sp(3)
	<min+2 @055dda>    : 11 03                      dup.x64 sp(3)
	<min+4 @055ddc>    : 88                         clt.f64
	<min+5 @055ddd>    : 06 08 00 00                jz <min+13 @055de5>
	lib/std/math.ci:125: (4 bytes: <@055de1> - <@055de5>): return float64(.result := a);
	<min+9 @055de1>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @055de4>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@055de5> - <@055de9>): return float64(.result := b);
	<min+13 @055de5>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @055de8>   : 03                         ret
.usages:
	test/std/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@055df0>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@055df0> - <@055e01>)
	lib/std/math.ci:138: (13 bytes: <@055df0> - <@055dfd>): if (bool(a > b))
	<max @055df0>      : 10 02                      dup.x32 sp(2)
	<max+2 @055df2>    : 10 02                      dup.x32 sp(2)
	<max+4 @055df4>    : 79                         cgt.f32
	<max+5 @055df5>    : 06 08 00 00                jz <max+13 @055dfd>
	lib/std/math.ci:139: (4 bytes: <@055df9> - <@055dfd>): return float32(.result := a);
	<max+9 @055df9>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @055dfc>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@055dfd> - <@055e01>): return float32(.result := b);
	<max+13 @055dfd>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @055e00>   : 03                         ret
.usages:
	test/std/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@055e08>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@055e08> - <@055e19>)
	lib/std/math.ci:146: (13 bytes: <@055e08> - <@055e15>): if (bool(a > b))
	<max @055e08>      : 11 03                      dup.x64 sp(3)
	<max+2 @055e0a>    : 11 03                      dup.x64 sp(3)
	<max+4 @055e0c>    : 89                         cgt.f64
	<max+5 @055e0d>    : 06 08 00 00                jz <max+13 @055e15>
	lib/std/math.ci:147: (4 bytes: <@055e11> - <@055e15>): return float64(.result := a);
	<max+9 @055e11>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @055e14>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@055e15> - <@055e19>): return float64(.result := b);
	<max+13 @055e15>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @055e18>   : 03                         ret
.usages:
	test/std/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@055e20>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@055e20> - <@055e3e>)
	lib/std/math.ci:160: (13 bytes: <@055e20> - <@055e2d>): if (bool(t < a))
	<clamp @055e20>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @055e22>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @055e24>    : 78                         clt.f32
	<clamp+5 @055e25>    : 06 08 00 00                jz <clamp+13 @055e2d>
	lib/std/math.ci:161: (4 bytes: <@055e29> - <@055e2d>): return float32(.result := a);
	<clamp+9 @055e29>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @055e2c>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@055e2d> - <@055e3a>): if (bool(t > b))
	<clamp+13 @055e2d>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @055e2f>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @055e31>   : 79                         cgt.f32
	<clamp+18 @055e32>   : 06 08 00 00                jz <clamp+26 @055e3a>
	lib/std/math.ci:164: (4 bytes: <@055e36> - <@055e3a>): return float32(.result := b);
	<clamp+22 @055e36>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @055e39>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@055e3a> - <@055e3e>): return float32(.result := t);
	<clamp+26 @055e3a>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @055e3d>   : 03                         ret
.usages:
	test/std/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@055e40>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@055e40> - <@055e5e>)
	lib/std/math.ci:171: (13 bytes: <@055e40> - <@055e4d>): if (bool(t < a))
	<clamp @055e40>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @055e42>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @055e44>    : 88                         clt.f64
	<clamp+5 @055e45>    : 06 08 00 00                jz <clamp+13 @055e4d>
	lib/std/math.ci:172: (4 bytes: <@055e49> - <@055e4d>): return float64(.result := a);
	<clamp+9 @055e49>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @055e4c>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@055e4d> - <@055e5a>): if (bool(t > b))
	<clamp+13 @055e4d>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @055e4f>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @055e51>   : 89                         cgt.f64
	<clamp+18 @055e52>   : 06 08 00 00                jz <clamp+26 @055e5a>
	lib/std/math.ci:175: (4 bytes: <@055e56> - <@055e5a>): return float64(.result := b);
	<clamp+22 @055e56>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @055e59>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@055e5a> - <@055e5e>): return float64(.result := t);
	<clamp+26 @055e5a>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @055e5d>   : 03                         ret
.usages:
	test/std/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/std/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/std/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/std/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/std/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@055e60>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@055e60> - <@055eaf>)
	lib/std/math.ci:202: (20 bytes: <@055e60> - <@055e74>): if (bool(data.length == (0)))
	<min @055e60>      : 10 02                      dup.x32 sp(2)
	<min+2 @055e62>    : 19                         load.z32
	<min+3 @055e63>    : 57                         ceq.i32
	<min+4 @055e64>    : 06 10 00 00                jz <min+20 @055e74>
	lib/std/math.ci:203: (12 bytes: <@055e68> - <@055e74>): return float64(.result := nan);
	<min+8 @055e68>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @055e71>   : 14 05                      set.x64 sp(5)
	<min+19 @055e73>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@055e74> - <@055e77>): result: float64 := data[0]
	<min+20 @055e74>   : 10 01                      dup.x32 sp(1)
	<min+22 @055e76>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@055e77> - <@055eac>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+23 @055e77>   : 1c 01 00 00 00             load.c32 1
	<min+28 @055e7c>   : 04 23 00 00                jmp <min+63 @055e9f>
	lib/std/math.ci:207: (27 bytes: <@055e80> - <@055e9b>): if (bool(result > data[i]))
	<min+32 @055e80>   : 11 01                      dup.x64 sp(1)
	<min+34 @055e82>   : 10 06                      dup.x32 sp(6)
	<min+36 @055e84>   : 10 03                      dup.x32 sp(3)
	<min+38 @055e86>   : 0d 08 00 00                mad.u32 8
	<min+42 @055e8a>   : 23                         load.i64
	<min+43 @055e8b>   : 89                         cgt.f64
	<min+44 @055e8c>   : 06 0f 00 00                jz <min+59 @055e9b>
	lib/std/math.ci:208: (11 bytes: <@055e90> - <@055e9b>): float64(result := data[i]);
	<min+48 @055e90>   : 10 04                      dup.x32 sp(4)
	<min+50 @055e92>   : 10 01                      dup.x32 sp(1)
	<min+52 @055e94>   : 0d 08 00 00                mad.u32 8
	<min+56 @055e98>   : 23                         load.i64
	<min+57 @055e99>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes: <@055e9b> - <@055e9f>): int32(i := int32(i + 1))
	<min+59 @055e9b>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@055e9f> - <@055ea8>): bool(i < (data.length))
	<min+63 @055e9f>   : 10 00                      dup.x32 sp(0)
	<min+65 @055ea1>   : 10 06                      dup.x32 sp(6)
	<min+67 @055ea3>   : 58                         clt.i32
	<min+68 @055ea4>   : 05 dc ff ff                jnz <min+32 @055e80>
	<min+72 @055ea8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@055eac> - <@055eaf>): return float64(.result := result);
	<min+76 @055eac>   : 14 05                      set.x64 sp(5)
	<min+78 @055eae>   : 03                         ret
.usages:
	test/std/test.math.ci:39: referenced as `min`
	test/std/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@055eb0>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@055eb0> - <@055eff>)
	lib/std/math.ci:216: (20 bytes: <@055eb0> - <@055ec4>): if (bool(data.length == (0)))
	<max @055eb0>      : 10 02                      dup.x32 sp(2)
	<max+2 @055eb2>    : 19                         load.z32
	<max+3 @055eb3>    : 57                         ceq.i32
	<max+4 @055eb4>    : 06 10 00 00                jz <max+20 @055ec4>
	lib/std/math.ci:217: (12 bytes: <@055eb8> - <@055ec4>): return float64(.result := nan);
	<max+8 @055eb8>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @055ec1>   : 14 05                      set.x64 sp(5)
	<max+19 @055ec3>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@055ec4> - <@055ec7>): result: float64 := data[0]
	<max+20 @055ec4>   : 10 01                      dup.x32 sp(1)
	<max+22 @055ec6>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@055ec7> - <@055efc>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+23 @055ec7>   : 1c 01 00 00 00             load.c32 1
	<max+28 @055ecc>   : 04 23 00 00                jmp <max+63 @055eef>
	lib/std/math.ci:221: (27 bytes: <@055ed0> - <@055eeb>): if (bool(result < data[i]))
	<max+32 @055ed0>   : 11 01                      dup.x64 sp(1)
	<max+34 @055ed2>   : 10 06                      dup.x32 sp(6)
	<max+36 @055ed4>   : 10 03                      dup.x32 sp(3)
	<max+38 @055ed6>   : 0d 08 00 00                mad.u32 8
	<max+42 @055eda>   : 23                         load.i64
	<max+43 @055edb>   : 88                         clt.f64
	<max+44 @055edc>   : 06 0f 00 00                jz <max+59 @055eeb>
	lib/std/math.ci:222: (11 bytes: <@055ee0> - <@055eeb>): float64(result := data[i]);
	<max+48 @055ee0>   : 10 04                      dup.x32 sp(4)
	<max+50 @055ee2>   : 10 01                      dup.x32 sp(1)
	<max+52 @055ee4>   : 0d 08 00 00                mad.u32 8
	<max+56 @055ee8>   : 23                         load.i64
	<max+57 @055ee9>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes: <@055eeb> - <@055eef>): int32(i := int32(i + 1))
	<max+59 @055eeb>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@055eef> - <@055ef8>): bool(i < (data.length))
	<max+63 @055eef>   : 10 00                      dup.x32 sp(0)
	<max+65 @055ef1>   : 10 06                      dup.x32 sp(6)
	<max+67 @055ef3>   : 58                         clt.i32
	<max+68 @055ef4>   : 05 dc ff ff                jnz <max+32 @055ed0>
	<max+72 @055ef8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@055efc> - <@055eff>): return float64(.result := result);
	<max+76 @055efc>   : 14 05                      set.x64 sp(5)
	<max+78 @055efe>   : 03                         ret
.usages:
	test/std/test.math.ci:41: referenced as `max`
	test/std/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@055f00>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@055f00> - <@055f28>)
	lib/std/math.ci:230: (1 byte: <@055f00> - <@055f01>): result: float64 := 0
	<sum @055f00>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@055f01> - <@055f25>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @055f01>    : 6a                         i64.2i32
	<sum+2 @055f02>    : 04 16 00 00                jmp <sum+24 @055f18>
	lib/std/math.ci:232: (14 bytes: <@055f06> - <@055f14>): float64(result := float64(result + data[i]));
	<sum+6 @055f06>    : 11 01                      dup.x64 sp(1)
	<sum+8 @055f08>    : 10 06                      dup.x32 sp(6)
	<sum+10 @055f0a>   : 10 03                      dup.x32 sp(3)
	<sum+12 @055f0c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @055f10>   : 23                         load.i64
	<sum+17 @055f11>   : 81                         add.f64
	<sum+18 @055f12>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes: <@055f14> - <@055f18>): int32(i := int32(i + 1))
	<sum+20 @055f14>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@055f18> - <@055f21>): bool(i < (data.length))
	<sum+24 @055f18>   : 10 00                      dup.x32 sp(0)
	<sum+26 @055f1a>   : 10 06                      dup.x32 sp(6)
	<sum+28 @055f1c>   : 58                         clt.i32
	<sum+29 @055f1d>   : 05 e9 ff ff                jnz <sum+6 @055f06>
	<sum+33 @055f21>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@055f25> - <@055f28>): return float64(.result := result);
	<sum+37 @055f25>   : 14 05                      set.x64 sp(5)
	<sum+39 @055f27>   : 03                         ret
.usages:
	test/std/test.math.ci:46: referenced as `sum`
	test/std/test.math.ci:45: referenced as `sum`
	test/std/test.math.ci:44: referenced as `sum`
	test/std/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/std/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/std/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/std/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/std/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@055f28>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@055f28> - <@055f57>)
	lib/std/math.ci:257: (1 byte: <@055f28> - <@055f29>): result: float64 := 0
	<eval @055f28>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@055f29> - <@055f54>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @055f29>    : 10 04                      dup.x32 sp(4)
	<eval+3 @055f2b>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @055f2f>    : 04 19 00 00                jmp <eval+32 @055f48>
	lib/std/math.ci:259: (17 bytes: <@055f33> - <@055f44>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @055f33>   : 11 01                      dup.x64 sp(1)
	<eval+13 @055f35>   : 11 08                      dup.x64 sp(8)
	<eval+15 @055f37>   : 83                         mul.f64
	<eval+16 @055f38>   : 10 06                      dup.x32 sp(6)
	<eval+18 @055f3a>   : 10 03                      dup.x32 sp(3)
	<eval+20 @055f3c>   : 0d 08 00 00                mad.u32 8
	<eval+24 @055f40>   : 23                         load.i64
	<eval+25 @055f41>   : 81                         add.f64
	<eval+26 @055f42>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:258: (4 bytes: <@055f44> - <@055f48>): int32(i := int32(i - 1))
	<eval+28 @055f44>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@055f48> - <@055f50>): bool(i >= 0)
	<eval+32 @055f48>   : 10 00                      dup.x32 sp(0)
	<eval+34 @055f4a>   : 19                         load.z32
	<eval+35 @055f4b>   : 58                         clt.i32
	<eval+36 @055f4c>   : 06 e7 ff ff                jz <eval+11 @055f33>
	<eval+40 @055f50>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@055f54> - <@055f57>): return float64(.result := result);
	<eval+44 @055f54>   : 14 07                      set.x64 sp(7)
	<eval+46 @055f56>   : 03                         ret
.usages:
	test/std/test.math.ci:55: referenced as `eval`
	test/std/test.math.ci:54: referenced as `eval`
	test/std/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@055f58>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@055f58> - <@055f91>)
	lib/std/math.ci:266: (53 bytes: <@055f58> - <@055f8d>): if (bool(a < b))
	<cmp @055f58>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @055f5a>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @055f5c>    : 78                         clt.f32
	<cmp+5 @055f5d>    : 06 1c 00 00                jz <cmp+33 @055f79>
	lib/std/math.ci:267: (20 bytes: <@055f61> - <@055f75>): if (bool(eps < (float32(b - a))))
	<cmp+9 @055f61>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @055f63>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @055f65>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @055f67>   : 72                         sub.f32
	<cmp+16 @055f68>   : 78                         clt.f32
	<cmp+17 @055f69>   : 06 0c 00 00                jz <cmp+29 @055f75>
	lib/std/math.ci:268: (8 bytes: <@055f6d> - <@055f75>): return int32(.result := int32(-1));
	<cmp+21 @055f6d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @055f72>   : 13 05                      set.x32 sp(5)
	<cmp+28 @055f74>   : 03                         ret
	<cmp+29 @055f75>   : 04 18 00 00                jmp <cmp+53 @055f8d>
	lib/std/math.ci:272: (20 bytes: <@055f79> - <@055f8d>): if (bool(eps < (float32(a - b))))
	<cmp+33 @055f79>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @055f7b>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @055f7d>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @055f7f>   : 72                         sub.f32
	<cmp+40 @055f80>   : 78                         clt.f32
	<cmp+41 @055f81>   : 06 0c 00 00                jz <cmp+53 @055f8d>
	lib/std/math.ci:273: (8 bytes: <@055f85> - <@055f8d>): return int32(.result := int32(+1));
	<cmp+45 @055f85>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @055f8a>   : 13 05                      set.x32 sp(5)
	<cmp+52 @055f8c>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@055f8d> - <@055f91>): return int32(.result := 0);
	<cmp+53 @055f8d>   : 19                         load.z32
	<cmp+54 @055f8e>   : 13 05                      set.x32 sp(5)
	<cmp+56 @055f90>   : 03                         ret
.usages:
	test/std/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@055f98>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@055f98> - <@055fd1>)
	lib/std/math.ci:281: (53 bytes: <@055f98> - <@055fcd>): if (bool(a < b))
	<cmp @055f98>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @055f9a>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @055f9c>    : 88                         clt.f64
	<cmp+5 @055f9d>    : 06 1c 00 00                jz <cmp+33 @055fb9>
	lib/std/math.ci:282: (20 bytes: <@055fa1> - <@055fb5>): if (bool(eps < (float64(b - a))))
	<cmp+9 @055fa1>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @055fa3>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @055fa5>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @055fa7>   : 82                         sub.f64
	<cmp+16 @055fa8>   : 88                         clt.f64
	<cmp+17 @055fa9>   : 06 0c 00 00                jz <cmp+29 @055fb5>
	lib/std/math.ci:283: (8 bytes: <@055fad> - <@055fb5>): return int32(.result := int32(-1));
	<cmp+21 @055fad>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @055fb2>   : 13 08                      set.x32 sp(8)
	<cmp+28 @055fb4>   : 03                         ret
	<cmp+29 @055fb5>   : 04 18 00 00                jmp <cmp+53 @055fcd>
	lib/std/math.ci:287: (20 bytes: <@055fb9> - <@055fcd>): if (bool(eps < (float64(a - b))))
	<cmp+33 @055fb9>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @055fbb>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @055fbd>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @055fbf>   : 82                         sub.f64
	<cmp+40 @055fc0>   : 88                         clt.f64
	<cmp+41 @055fc1>   : 06 0c 00 00                jz <cmp+53 @055fcd>
	lib/std/math.ci:288: (8 bytes: <@055fc5> - <@055fcd>): return int32(.result := int32(+1));
	<cmp+45 @055fc5>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @055fca>   : 13 08                      set.x32 sp(8)
	<cmp+52 @055fcc>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@055fcd> - <@055fd1>): return int32(.result := 0);
	<cmp+53 @055fcd>   : 19                         load.z32
	<cmp+54 @055fce>   : 13 08                      set.x32 sp(8)
	<cmp+56 @055fd0>   : 03                         ret
.usages:
	test/std/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@055fd8>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@055fd8> - <@056127>)
	lib/std/math.ci:309: (2 bytes: <@055fd8> - <@055fda>): x: float64 := arg
	<sinCos @055fd8>      : 11 02                      dup.x64 sp(2)
	lib/std/math.ci:310: (17 bytes: <@055fda> - <@055feb>): if (bool(x < (0)))
	<sinCos+2 @055fda>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @055fdc>    : 1a                         load.z64
	<sinCos+5 @055fdd>    : 88                         clt.f64
	<sinCos+6 @055fde>    : 06 0d 00 00                jz <sinCos+19 @055feb>
	lib/std/math.ci:311: (1 byte: <@055fe2> - <@055fe3>): float64(x := float64(-x));
	<sinCos+10 @055fe2>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@055fe3> - <@055feb>): int32(quad := int32(quad + 2));
	<sinCos+11 @055fe3>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @055fe5>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @055fe9>   : 13 04                      set.x32 sp(4)
	lib/std/math.ci:315: (1 byte: <@055feb> - <@055fec>): y: float64
	<sinCos+19 @055feb>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@055fec> - <@056004>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @055fec>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @055fee>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @055ff7>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @056000>   : 84                         div.f64
	<sinCos+41 @056001>   : 83                         mul.f64
	<sinCos+42 @056002>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:317: (124 bytes: <@056004> - <@056080>): if (bool(x > (32764)))
	<sinCos+44 @056004>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @056006>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05600f>   : 89                         cgt.f64
	<sinCos+56 @056010>   : 06 54 00 00                jz <sinCos+140 @056064>
	lib/std/math.ci:318: (1 byte: <@056014> - <@056015>): e: float64
	<sinCos+60 @056014>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@056015> - <@056027>): float64(y := modf(void(x, float64(&e))));
	<sinCos+61 @056015>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @056017>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05601b>   : 1f e0 5c 05 00             load.ref <@055ce0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @056020>   : 02                         call
	<sinCos+73 @056021>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @056025>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:320: (4 bytes: <@056027> - <@05602b>): float64(e := float64(e + (quad)));
	<sinCos+79 @056027>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @056029>   : 5d                         i32.2f64
	<sinCos+82 @05602a>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@05602b> - <@05602c>): f: float64
	<sinCos+83 @05602b>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@05602c> - <@05604a>): modf(void(float64(0.250000 * e), float64(&f)));
	<sinCos+84 @05602c>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @056035>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @056037>   : 83                         mul.f64
	<sinCos+96 @056038>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @05603c>  : 1f e0 5c 05 00             load.ref <@055ce0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @056041>  : 02                         call
	<sinCos+106 @056042>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @056046>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@05604a> - <@05605c>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @05604a>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @05604c>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @056055>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @056057>  : 83                         mul.f64
	<sinCos+128 @056058>  : 82                         sub.f64
	<sinCos+129 @056059>  : 8a                         f64.2i32
	<sinCos+130 @05605a>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @05605c>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @056060>  : 04 20 00 00                jmp <sinCos+168 @056080>
	lib/std/math.ci:327: (3 bytes: <@056064> - <@056067>): k: int32 := x
	<sinCos+140 @056064>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @056066>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@056067> - <@05606f>): float64(y := float64(x - (k)));
	<sinCos+143 @056067>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @056069>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @05606b>  : 5d                         i32.2f64
	<sinCos+148 @05606c>  : 82                         sub.f64
	<sinCos+149 @05606d>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:329: (7 bytes: <@05606f> - <@056076>): int32(quad := int32(quad + k));
	<sinCos+151 @05606f>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @056071>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @056073>  : 51                         add.i32
	<sinCos+156 @056074>  : 13 07                      set.x32 sp(7)
	lib/std/math.ci:330: (6 bytes: <@056076> - <@05607c>): int32(quad := int32(quad & 3));
	<sinCos+158 @056076>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @056078>  : 3f 02                      b32.and 0x003
	<sinCos+162 @05607a>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @05607c>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@056080> - <@056096>): if (int32(quad & 1))
	<sinCos+168 @056080>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @056082>  : 3f 01                      b32.and 0x001
	<sinCos+172 @056084>  : 06 12 00 00                jz <sinCos+190 @056096>
	lib/std/math.ci:333: (14 bytes: <@056088> - <@056096>): float64(y := float64((1) - y));
	<sinCos+176 @056088>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @056091>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @056093>  : 82                         sub.f64
	<sinCos+188 @056094>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:335: (13 bytes: <@056096> - <@0560a3>): if (bool(quad > 1))
	<sinCos+190 @056096>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @056098>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @05609d>  : 59                         cgt.i32
	<sinCos+198 @05609e>  : 06 05 00 00                jz <sinCos+203 @0560a3>
	lib/std/math.ci:336: (1 byte: <@0560a2> - <@0560a3>): float64(y := float64(-y));
	<sinCos+202 @0560a2>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@0560a3> - <@0560a8>): ysq: float64 := float64(y * y)
	<sinCos+203 @0560a3>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @0560a5>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @0560a7>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@0560a8> - <@0560e8>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @0560a8>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @0560b1>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @0560b3>  : 83                         mul.f64
	<sinCos+220 @0560b4>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @0560bd>  : 81                         add.f64
	<sinCos+230 @0560be>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @0560c0>  : 83                         mul.f64
	<sinCos+233 @0560c1>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @0560ca>  : 81                         add.f64
	<sinCos+243 @0560cb>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @0560cd>  : 83                         mul.f64
	<sinCos+246 @0560ce>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @0560d7>  : 81                         add.f64
	<sinCos+256 @0560d8>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @0560da>  : 83                         mul.f64
	<sinCos+259 @0560db>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @0560e4>  : 81                         add.f64
	<sinCos+269 @0560e5>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @0560e7>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@0560e8> - <@05611b>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @0560e8>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @0560ea>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @0560f3>  : 81                         add.f64
	<sinCos+284 @0560f4>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @0560f6>  : 83                         mul.f64
	<sinCos+287 @0560f7>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @056100>  : 81                         add.f64
	<sinCos+297 @056101>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @056103>  : 83                         mul.f64
	<sinCos+300 @056104>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05610d>  : 81                         add.f64
	<sinCos+310 @05610e>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @056110>  : 83                         mul.f64
	<sinCos+313 @056111>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05611a>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@05611b> - <@056127>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @05611b>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @05611d>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @05611f>  : 84                         div.f64
	<sinCos+328 @056120>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @056122>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @056126>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/std/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/std/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.offset: <@056128>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <@056128> - <@0562a2>)
	lib/std/math.ci:365: (1 byte: <@056128> - <@056129>): complement: bool := false
	<tan @056128>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@056129> - <@05612a>): negate: bool := false
	<tan+1 @056129>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@05612a> - <@056141>): if (bool(arg < (0)))
	<tan+2 @05612a>    : 11 03                      dup.x64 sp(3)
	<tan+4 @05612c>    : 1a                         load.z64
	<tan+5 @05612d>    : 88                         clt.f64
	<tan+6 @05612e>    : 06 13 00 00                jz <tan+25 @056141>
	lib/std/math.ci:369: (5 bytes: <@056132> - <@056137>): float64(arg := float64(-arg));
	<tan+10 @056132>   : 11 03                      dup.x64 sp(3)
	<tan+12 @056134>   : 80                         neg.f64
	<tan+13 @056135>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:370: (10 bytes: <@056137> - <@056141>): bool(negate := true);
	<tan+15 @056137>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @05613c>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @056140>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@056141> - <@056159>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @056141>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @05614a>   : 11 05                      dup.x64 sp(5)
	<tan+36 @05614c>   : 83                         mul.f64
	<tan+37 @05614d>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @056156>   : 84                         div.f64
	<tan+47 @056157>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:374: (1 byte: <@056159> - <@05615a>): e: float64
	<tan+49 @056159>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@05615a> - <@05616a>): x: float64 := modf(void(arg, float64(&e)))
	<tan+50 @05615a>   : 11 07                      dup.x64 sp(7)
	<tan+52 @05615c>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @056160>   : 1f e0 5c 05 00             load.ref <@055ce0> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @056165>   : 02                         call
	<tan+62 @056166>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@05616a> - <@056173>): i: int32 := int32(int32(e) % 4)
	<tan+66 @05616a>   : 11 02                      dup.x64 sp(2)
	<tan+68 @05616c>   : 8a                         f64.2i32
	<tan+69 @05616d>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @056172>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@056173> - <@0561ed>): if (bool(i == 0))
	<tan+75 @056173>   : 10 00                      dup.x32 sp(0)
	<tan+77 @056175>   : 19                         load.z32
	<tan+78 @056176>   : 57                         ceq.i32
	<tan+79 @056177>   : 05 76 00 00                jnz <tan+197 @0561ed>
	lib/std/math.ci:379: (114 bytes: <@05617b> - <@0561ed>): if (bool(i == 1))
	<tan+83 @05617b>   : 10 00                      dup.x32 sp(0)
	<tan+85 @05617d>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @056182>   : 57                         ceq.i32
	<tan+91 @056183>   : 06 20 00 00                jz <tan+123 @0561a3>
	lib/std/math.ci:380: (14 bytes: <@056187> - <@056195>): float64(x := float64((1) - x));
	<tan+95 @056187>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @056190>  : 11 03                      dup.x64 sp(3)
	<tan+106 @056192>  : 82                         sub.f64
	<tan+107 @056193>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:381: (10 bytes: <@056195> - <@05619f>): bool(complement := true);
	<tan+109 @056195>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @05619a>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @05619e>  : 25                         store.i8
	<tan+119 @05619f>  : 04 4e 00 00                jmp <tan+197 @0561ed>
	lib/std/math.ci:383: (74 bytes: <@0561a3> - <@0561ed>): if (bool(i == 2))
	<tan+123 @0561a3>  : 10 00                      dup.x32 sp(0)
	<tan+125 @0561a5>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @0561aa>  : 57                         ceq.i32
	<tan+131 @0561ab>  : 06 1d 00 00                jz <tan+160 @0561c8>
	lib/std/math.ci:384: (11 bytes: <@0561af> - <@0561ba>): bool(negate := bool(!negate));
	<tan+135 @0561af>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @0561b3>  : 20                         load.i8
	<tan+140 @0561b4>  : 0b                         not.b32
	<tan+141 @0561b5>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @0561b9>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@0561ba> - <@0561c4>): bool(complement := true);
	<tan+146 @0561ba>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @0561bf>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @0561c3>  : 25                         store.i8
	<tan+156 @0561c4>  : 04 29 00 00                jmp <tan+197 @0561ed>
	lib/std/math.ci:387: (37 bytes: <@0561c8> - <@0561ed>): if (bool(i == 3))
	<tan+160 @0561c8>  : 10 00                      dup.x32 sp(0)
	<tan+162 @0561ca>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @0561cf>  : 57                         ceq.i32
	<tan+168 @0561d0>  : 06 1d 00 00                jz <tan+197 @0561ed>
	lib/std/math.ci:388: (14 bytes: <@0561d4> - <@0561e2>): float64(x := float64((1) - x));
	<tan+172 @0561d4>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @0561dd>  : 11 03                      dup.x64 sp(3)
	<tan+183 @0561df>  : 82                         sub.f64
	<tan+184 @0561e0>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:389: (11 bytes: <@0561e2> - <@0561ed>): bool(negate := bool(!negate));
	<tan+186 @0561e2>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @0561e6>  : 20                         load.i8
	<tan+191 @0561e7>  : 0b                         not.b32
	<tan+192 @0561e8>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @0561ec>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@0561ed> - <@0561f2>): xsq: float64 := float64(x * x)
	<tan+197 @0561ed>  : 11 01                      dup.x64 sp(1)
	<tan+199 @0561ef>  : 11 03                      dup.x64 sp(3)
	<tan+201 @0561f1>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@0561f2> - <@056232>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @0561f2>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @0561fb>  : 11 02                      dup.x64 sp(2)
	<tan+213 @0561fd>  : 83                         mul.f64
	<tan+214 @0561fe>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @056207>  : 81                         add.f64
	<tan+224 @056208>  : 11 02                      dup.x64 sp(2)
	<tan+226 @05620a>  : 83                         mul.f64
	<tan+227 @05620b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @056214>  : 81                         add.f64
	<tan+237 @056215>  : 11 02                      dup.x64 sp(2)
	<tan+239 @056217>  : 83                         mul.f64
	<tan+240 @056218>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @056221>  : 81                         add.f64
	<tan+250 @056222>  : 11 02                      dup.x64 sp(2)
	<tan+252 @056224>  : 83                         mul.f64
	<tan+253 @056225>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @05622e>  : 81                         add.f64
	<tan+263 @05622f>  : 11 05                      dup.x64 sp(5)
	<tan+265 @056231>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@056232> - <@056259>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @056232>  : 11 02                      dup.x64 sp(2)
	<tan+268 @056234>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @05623d>  : 81                         add.f64
	<tan+278 @05623e>  : 11 04                      dup.x64 sp(4)
	<tan+280 @056240>  : 83                         mul.f64
	<tan+281 @056241>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @05624a>  : 81                         add.f64
	<tan+291 @05624b>  : 11 04                      dup.x64 sp(4)
	<tan+293 @05624d>  : 83                         mul.f64
	<tan+294 @05624e>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @056257>  : 81                         add.f64
	<tan+304 @056258>  : 84                         div.f64
	lib/std/math.ci:396: (47 bytes: <@056259> - <@056288>): if (complement)
	<tan+305 @056259>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @05625d>  : 20                         load.i8
	<tan+310 @05625e>  : 06 2a 00 00                jz <tan+352 @056288>
	lib/std/math.ci:397: (24 bytes: <@056262> - <@05627a>): if (bool(result == (0)))
	<tan+314 @056262>  : 11 00                      dup.x64 sp(0)
	<tan+316 @056264>  : 1a                         load.z64
	<tan+317 @056265>  : 87                         ceq.f64
	<tan+318 @056266>  : 06 14 00 00                jz <tan+338 @05627a>
	lib/std/math.ci:398: (16 bytes: <@05626a> - <@05627a>): return float64(.result := nan);
	<tan+322 @05626a>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @056273>  : 14 10                      set.x64 sp(16)
	<tan+333 @056275>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @056279>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@05627a> - <@056288>): float64(result := float64((1) / result));
	<tan+338 @05627a>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @056283>  : 11 02                      dup.x64 sp(2)
	<tan+349 @056285>  : 84                         div.f64
	<tan+350 @056286>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:402: (19 bytes: <@056288> - <@05629b>): if (negate)
	<tan+352 @056288>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @05628c>  : 20                         load.i8
	<tan+357 @05628d>  : 06 0e 00 00                jz <tan+371 @05629b>
	lib/std/math.ci:403: (10 bytes: <@056291> - <@05629b>): return float64(.result := float64(-result));
	<tan+361 @056291>  : 11 00                      dup.x64 sp(0)
	<tan+363 @056293>  : 80                         neg.f64
	<tan+364 @056294>  : 14 10                      set.x64 sp(16)
	<tan+366 @056296>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @05629a>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@05629b> - <@0562a2>): return float64(.result := result);
	<tan+371 @05629b>  : 14 0e                      set.x64 sp(14)
	<tan+373 @05629d>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @0562a1>  : 03                         ret
.usages:
	test/std/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@0562a8>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@0562a8> - <@056399>)
	lib/std/math.ci:421: (1 byte: <@0562a8> - <@0562a9>): negate: bool := false
	<sinh @0562a8>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@0562a9> - <@0562c0>): if (bool(x < (0)))
	<sinh+1 @0562a9>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @0562ab>    : 1a                         load.z64
	<sinh+4 @0562ac>    : 88                         clt.f64
	<sinh+5 @0562ad>    : 06 13 00 00                jz <sinh+24 @0562c0>
	lib/std/math.ci:423: (5 bytes: <@0562b1> - <@0562b6>): float64(x := float64(-x));
	<sinh+9 @0562b1>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @0562b3>   : 80                         neg.f64
	<sinh+12 @0562b4>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:424: (10 bytes: <@0562b6> - <@0562c0>): bool(negate := true);
	<sinh+14 @0562b6>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @0562bb>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @0562bf>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@0562c0> - <@0562e7>): if (bool(x > (21)))
	<sinh+24 @0562c0>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @0562c2>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @0562cb>   : 89                         cgt.f64
	<sinh+36 @0562cc>   : 06 1b 00 00                jz <sinh+63 @0562e7>
	lib/std/math.ci:428: (23 bytes: <@0562d0> - <@0562e7>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @0562d0>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @0562d2>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<sinh+46 @0562d6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @0562df>   : 84                         div.f64
	<sinh+56 @0562e0>   : 14 06                      set.x64 sp(6)
	<sinh+58 @0562e2>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @0562e6>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@0562e7> - <@0562e8>): result: float64
	<sinh+63 @0562e7>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@0562e8> - <@05637f>): if (bool(x > 0.500000))
	<sinh+64 @0562e8>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @0562ea>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @0562f3>   : 89                         cgt.f64
	<sinh+76 @0562f4>   : 06 22 00 00                jz <sinh+110 @056316>
	lib/std/math.ci:433: (26 bytes: <@0562f8> - <@056312>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @0562f8>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @0562fa>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<sinh+86 @0562fe>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @056300>   : 80                         neg.f64
	<sinh+89 @056301>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<sinh+93 @056305>   : 82                         sub.f64
	<sinh+94 @056306>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @05630f>  : 84                         div.f64
	<sinh+104 @056310>  : 14 02                      set.x64 sp(2)
	<sinh+106 @056312>  : 04 6d 00 00                jmp <sinh+215 @05637f>
	lib/std/math.ci:436: (5 bytes: <@056316> - <@05631b>): sq: float64 := float64(x * x)
	<sinh+110 @056316>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @056318>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @05631a>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@05631b> - <@056350>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @05631b>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @056324>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @056326>  : 83                         mul.f64
	<sinh+127 @056327>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @056330>  : 81                         add.f64
	<sinh+137 @056331>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @056333>  : 83                         mul.f64
	<sinh+140 @056334>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @05633d>  : 81                         add.f64
	<sinh+150 @05633e>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @056340>  : 83                         mul.f64
	<sinh+153 @056341>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @05634a>  : 81                         add.f64
	<sinh+163 @05634b>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @05634d>  : 83                         mul.f64
	<sinh+166 @05634e>  : 14 04                      set.x64 sp(4)
	lib/std/math.ci:438: (43 bytes: <@056350> - <@05637b>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @056350>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @056352>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @056354>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @05635d>  : 81                         add.f64
	<sinh+182 @05635e>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @056360>  : 83                         mul.f64
	<sinh+185 @056361>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @05636a>  : 81                         add.f64
	<sinh+195 @05636b>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @05636d>  : 83                         mul.f64
	<sinh+198 @05636e>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @056377>  : 81                         add.f64
	<sinh+208 @056378>  : 84                         div.f64
	<sinh+209 @056379>  : 14 04                      set.x64 sp(4)
	<sinh+211 @05637b>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@05637f> - <@056392>): if (negate)
	<sinh+215 @05637f>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @056383>  : 20                         load.i8
	<sinh+220 @056384>  : 06 0e 00 00                jz <sinh+234 @056392>
	lib/std/math.ci:442: (10 bytes: <@056388> - <@056392>): return float64(.result := float64(-result));
	<sinh+224 @056388>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @05638a>  : 80                         neg.f64
	<sinh+227 @05638b>  : 14 08                      set.x64 sp(8)
	<sinh+229 @05638d>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @056391>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@056392> - <@056399>): return float64(.result := result);
	<sinh+234 @056392>  : 14 06                      set.x64 sp(6)
	<sinh+236 @056394>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @056398>  : 03                         ret
.usages:
	test/std/test.math.ci:60: referenced as `sinh`
	lib/std/math/Complex.ci:148: referenced as `sinh`
	lib/std/math/Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@0563a0>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@0563a0> - <@0563eb>)
	lib/std/math.ci:449: (13 bytes: <@0563a0> - <@0563ad>): if (bool(x < (0)))
	<cosh @0563a0>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @0563a2>    : 1a                         load.z64
	<cosh+3 @0563a3>    : 88                         clt.f64
	<cosh+4 @0563a4>    : 06 09 00 00                jz <cosh+13 @0563ad>
	lib/std/math.ci:450: (5 bytes: <@0563a8> - <@0563ad>): float64(x := float64(-x));
	<cosh+8 @0563a8>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @0563aa>   : 80                         neg.f64
	<cosh+11 @0563ab>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:452: (35 bytes: <@0563ad> - <@0563d0>): if (bool(x > (21)))
	<cosh+13 @0563ad>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @0563af>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @0563b8>   : 89                         cgt.f64
	<cosh+25 @0563b9>   : 06 17 00 00                jz <cosh+48 @0563d0>
	lib/std/math.ci:453: (19 bytes: <@0563bd> - <@0563d0>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @0563bd>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @0563bf>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<cosh+35 @0563c3>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @0563cc>   : 84                         div.f64
	<cosh+45 @0563cd>   : 14 05                      set.x64 sp(5)
	<cosh+47 @0563cf>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@0563d0> - <@0563eb>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @0563d0>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @0563d2>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<cosh+54 @0563d6>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @0563d8>   : 80                         neg.f64
	<cosh+57 @0563d9>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<cosh+61 @0563dd>   : 81                         add.f64
	<cosh+62 @0563de>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @0563e7>   : 84                         div.f64
	<cosh+72 @0563e8>   : 14 05                      set.x64 sp(5)
	<cosh+74 @0563ea>   : 03                         ret
.usages:
	test/std/test.math.ci:61: referenced as `cosh`
	lib/std/math/Complex.ci:148: referenced as `cosh`
	lib/std/math/Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 173
.offset: <@0563f0>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <@0563f0> - <@05649d>)
	lib/std/math.ci:464: (12 bytes: <@0563f0> - <@0563fc>): if (bool(x == (0)))
	<asin @0563f0>      : 11 01                      dup.x64 sp(1)
	<asin+2 @0563f2>    : 1a                         load.z64
	<asin+3 @0563f3>    : 87                         ceq.f64
	<asin+4 @0563f4>    : 06 08 00 00                jz <asin+12 @0563fc>
	lib/std/math.ci:466: (4 bytes: <@0563f8> - <@0563fc>): return float64(.result := x);
	<asin+8 @0563f8>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @0563fb>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@0563fc> - <@0563fd>): negate: bool := false
	<asin+12 @0563fc>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@0563fd> - <@056414>): if (bool(x < (0)))
	<asin+13 @0563fd>   : 11 02                      dup.x64 sp(2)
	<asin+15 @0563ff>   : 1a                         load.z64
	<asin+16 @056400>   : 88                         clt.f64
	<asin+17 @056401>   : 06 13 00 00                jz <asin+36 @056414>
	lib/std/math.ci:471: (10 bytes: <@056405> - <@05640f>): bool(negate := true);
	<asin+21 @056405>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @05640a>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @05640e>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@05640f> - <@056414>): float64(x := float64(-x));
	<asin+31 @05640f>   : 11 02                      dup.x64 sp(2)
	<asin+33 @056411>   : 80                         neg.f64
	<asin+34 @056412>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:475: (32 bytes: <@056414> - <@056434>): if (bool(x > (1)))
	<asin+36 @056414>   : 11 02                      dup.x64 sp(2)
	<asin+38 @056416>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @05641f>   : 89                         cgt.f64
	<asin+48 @056420>   : 06 14 00 00                jz <asin+68 @056434>
	lib/std/math.ci:477: (16 bytes: <@056424> - <@056434>): return float64(.result := nan);
	<asin+52 @056424>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @05642d>   : 14 06                      set.x64 sp(6)
	<asin+63 @05642f>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @056433>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@056434> - <@056447>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+68 @056434>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @05643d>   : 11 04                      dup.x64 sp(4)
	<asin+79 @05643f>   : 11 06                      dup.x64 sp(6)
	<asin+81 @056441>   : 83                         mul.f64
	<asin+82 @056442>   : 82                         sub.f64
	<asin+83 @056443>   : 01 2e 00 00                nfc(46) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@056447> - <@056483>): if (bool(x > 0.700000))
	<asin+87 @056447>   : 11 04                      dup.x64 sp(4)
	<asin+89 @056449>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @056452>   : 89                         cgt.f64
	<asin+99 @056453>   : 06 26 00 00                jz <asin+137 @056479>
	lib/std/math.ci:482: (30 bytes: <@056457> - <@056475>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+103 @056457>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @056460>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @056469>  : 84                         div.f64
	<asin+122 @05646a>  : 11 02                      dup.x64 sp(2)
	<asin+124 @05646c>  : 11 08                      dup.x64 sp(8)
	<asin+126 @05646e>  : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @056472>  : 82                         sub.f64
	<asin+131 @056473>  : 14 02                      set.x64 sp(2)
	<asin+133 @056475>  : 04 0e 00 00                jmp <asin+147 @056483>
	lib/std/math.ci:485: (10 bytes: <@056479> - <@056483>): float64(result := float64.atan2(void(x, result)));
	<asin+137 @056479>  : 11 04                      dup.x64 sp(4)
	<asin+139 @05647b>  : 11 02                      dup.x64 sp(2)
	<asin+141 @05647d>  : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @056481>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:488: (19 bytes: <@056483> - <@056496>): if (negate)
	<asin+147 @056483>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @056487>  : 20                         load.i8
	<asin+152 @056488>  : 06 0e 00 00                jz <asin+166 @056496>
	lib/std/math.ci:489: (10 bytes: <@05648c> - <@056496>): return float64(.result := float64(-result));
	<asin+156 @05648c>  : 11 00                      dup.x64 sp(0)
	<asin+158 @05648e>  : 80                         neg.f64
	<asin+159 @05648f>  : 14 08                      set.x64 sp(8)
	<asin+161 @056491>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @056495>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@056496> - <@05649d>): return float64(.result := result);
	<asin+166 @056496>  : 14 06                      set.x64 sp(6)
	<asin+168 @056498>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @05649c>  : 03                         ret
.usages:
	test/std/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/std/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01a638>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math/Complex.ci:186: referenced as `Complex`
	lib/std/math/Complex.ci:184: referenced as `Complex`
	lib/std/math/Complex.ci:181: referenced as `Complex`
	lib/std/math/Complex.ci:179: referenced as `Complex`
	lib/std/math/Complex.ci:177: referenced as `Complex`
	lib/std/math/Complex.ci:175: referenced as `Complex`
	lib/std/math/Complex.ci:172: referenced as `Complex`
	lib/std/math/Complex.ci:170: referenced as `Complex`
	lib/std/math/Complex.ci:168: referenced as `Complex`
	lib/std/math/Complex.ci:166: referenced as `Complex`
	lib/std/math/Complex.ci:163: referenced as `Complex`
	lib/std/math/Complex.ci:161: referenced as `Complex`
	lib/std/math/Complex.ci:148: referenced as `Complex`
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:143: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:123: referenced as `Complex`
	lib/std/math/Complex.ci:114: referenced as `Complex`
	lib/std/math/Complex.ci:114: referenced as `Complex`
	lib/std/math/Complex.ci:111: referenced as `Complex`
	lib/std/math/Complex.ci:109: referenced as `Complex`
	lib/std/math/Complex.ci:106: referenced as `Complex`
	lib/std/math/Complex.ci:104: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:80: referenced as `Complex`
	lib/std/math/Complex.ci:78: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:31: referenced as `Complex`
	lib/std/math/Complex.ci:24: referenced as `Complex`
	lib/std/math/Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math/Complex.ci:184: referenced as `re`
	lib/std/math/Complex.ci:184: referenced as `re`
	lib/std/math/Complex.ci:148: referenced as `re`
	lib/std/math/Complex.ci:148: referenced as `re`
	lib/std/math/Complex.ci:146: referenced as `re`
	lib/std/math/Complex.ci:146: referenced as `re`
	lib/std/math/Complex.ci:138: referenced as `re`
	lib/std/math/Complex.ci:136: referenced as `re`
	lib/std/math/Complex.ci:135: referenced as `re`
	lib/std/math/Complex.ci:126: referenced as `re`
	lib/std/math/Complex.ci:126: referenced as `re`
	lib/std/math/Complex.ci:123: referenced as `re`
	lib/std/math/Complex.ci:117: referenced as `re`
	lib/std/math/Complex.ci:117: referenced as `re`
	lib/std/math/Complex.ci:115: referenced as `re`
	lib/std/math/Complex.ci:115: referenced as `re`
	lib/std/math/Complex.ci:111: referenced as `re`
	lib/std/math/Complex.ci:109: referenced as `re`
	lib/std/math/Complex.ci:109: referenced as `re`
	lib/std/math/Complex.ci:98: referenced as `re`
	lib/std/math/Complex.ci:99: referenced as `re`
	lib/std/math/Complex.ci:98: referenced as `re`
	lib/std/math/Complex.ci:96: referenced as `re`
	lib/std/math/Complex.ci:95: referenced as `re`
	lib/std/math/Complex.ci:91: referenced as `re`
	lib/std/math/Complex.ci:92: referenced as `re`
	lib/std/math/Complex.ci:91: referenced as `re`
	lib/std/math/Complex.ci:89: referenced as `re`
	lib/std/math/Complex.ci:88: referenced as `re`
	lib/std/math/Complex.ci:87: referenced as `re`
	lib/std/math/Complex.ci:80: referenced as `re`
	lib/std/math/Complex.ci:78: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:76: referenced as `re`
	lib/std/math/Complex.ci:73: referenced as `re`
	lib/std/math/Complex.ci:71: referenced as `re`
	lib/std/math/Complex.ci:69: referenced as `re`
	lib/std/math/Complex.ci:69: referenced as `re`
	lib/std/math/Complex.ci:66: referenced as `re`
	lib/std/math/Complex.ci:64: referenced as `re`
	lib/std/math/Complex.ci:62: referenced as `re`
	lib/std/math/Complex.ci:62: referenced as `re`
	lib/std/math/Complex.ci:59: referenced as `re`
	lib/std/math/Complex.ci:33: referenced as `re`
	lib/std/math/Complex.ci:26: referenced as `re`
	lib/std/math/Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math/Complex.ci:184: referenced as `im`
	lib/std/math/Complex.ci:184: referenced as `im`
	lib/std/math/Complex.ci:148: referenced as `im`
	lib/std/math/Complex.ci:148: referenced as `im`
	lib/std/math/Complex.ci:146: referenced as `im`
	lib/std/math/Complex.ci:146: referenced as `im`
	lib/std/math/Complex.ci:139: referenced as `im`
	lib/std/math/Complex.ci:136: referenced as `im`
	lib/std/math/Complex.ci:135: referenced as `im`
	lib/std/math/Complex.ci:126: referenced as `im`
	lib/std/math/Complex.ci:126: referenced as `im`
	lib/std/math/Complex.ci:123: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:115: referenced as `im`
	lib/std/math/Complex.ci:115: referenced as `im`
	lib/std/math/Complex.ci:111: referenced as `im`
	lib/std/math/Complex.ci:109: referenced as `im`
	lib/std/math/Complex.ci:109: referenced as `im`
	lib/std/math/Complex.ci:99: referenced as `im`
	lib/std/math/Complex.ci:99: referenced as `im`
	lib/std/math/Complex.ci:98: referenced as `im`
	lib/std/math/Complex.ci:96: referenced as `im`
	lib/std/math/Complex.ci:95: referenced as `im`
	lib/std/math/Complex.ci:92: referenced as `im`
	lib/std/math/Complex.ci:92: referenced as `im`
	lib/std/math/Complex.ci:91: referenced as `im`
	lib/std/math/Complex.ci:89: referenced as `im`
	lib/std/math/Complex.ci:88: referenced as `im`
	lib/std/math/Complex.ci:87: referenced as `im`
	lib/std/math/Complex.ci:80: referenced as `im`
	lib/std/math/Complex.ci:78: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:76: referenced as `im`
	lib/std/math/Complex.ci:73: referenced as `im`
	lib/std/math/Complex.ci:71: referenced as `im`
	lib/std/math/Complex.ci:69: referenced as `im`
	lib/std/math/Complex.ci:69: referenced as `im`
	lib/std/math/Complex.ci:66: referenced as `im`
	lib/std/math/Complex.ci:64: referenced as `im`
	lib/std/math/Complex.ci:62: referenced as `im`
	lib/std/math/Complex.ci:62: referenced as `im`
	lib/std/math/Complex.ci:59: referenced as `im`
	lib/std/math/Complex.ci:34: referenced as `im`
	lib/std/math/Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0564a0>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@0564a0> - <@0564a7>)
	lib/std/math/Complex.ci:25: (7 bytes: <@0564a0> - <@0564a7>): return void(.result := {...});
	<Complex @0564a0>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <@0564a3> - <@0564a6>): void(.result.im := (0))
	<Complex+3 @0564a3>    : 1a                         load.z64
	<Complex+4 @0564a4>    : 14 07                      set.x64 sp(7)
	<Complex+6 @0564a6>    : 03                         ret
.usages:
	lib/std/math/Complex.ci:143: referenced as `Complex`
	lib/std/math/Complex.ci:106: referenced as `Complex`
	lib/std/math/Complex.ci:104: referenced as `Complex`
	lib/std/math/Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0564a8>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@0564a8> - <@0564af>)
	lib/std/math/Complex.ci:32: (7 bytes: <@0564a8> - <@0564af>): return void(.result := {...});
	<Complex @0564a8>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math/Complex.ci:34: (3 bytes: <@0564ab> - <@0564ae>): void(.result.im := im);
	<Complex+3 @0564ab>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @0564ae>    : 03                         ret
.usages:
	lib/std/math/Complex.ci:186: referenced as `Complex`
	lib/std/math/Complex.ci:184: referenced as `Complex`
	lib/std/math/Complex.ci:148: referenced as `Complex`
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:123: referenced as `Complex`
	lib/std/math/Complex.ci:80: referenced as `Complex`
	lib/std/math/Complex.ci:78: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `neg`
	lib/std/math/Complex.ci:168: referenced as `neg`
	lib/std/math/Complex.ci:166: referenced as `neg`
	lib/std/math/Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math/Complex.ci:168: referenced as `add`
	lib/std/math/Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math/Complex.ci:172: referenced as `add`
	lib/std/math/Complex.ci:170: referenced as `add`
	lib/std/math/Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math/Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math/Complex.ci:166: referenced as `sub`
	lib/std/math/Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math/Complex.ci:172: referenced as `sub`
	lib/std/math/Complex.ci:170: referenced as `sub`
	lib/std/math/Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math/Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math/Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math/Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math/Complex.ci:172: referenced as `mul`
	lib/std/math/Complex.ci:172: referenced as `mul`
	lib/std/math/Complex.ci:170: referenced as `mul`
	lib/std/math/Complex.ci:170: referenced as `mul`
	lib/std/math/Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@0564b0>
.name: 'div'
.file: 'lib/std/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@0564b0> - <@05652b>)
	lib/std/math/Complex.ci:87: (79 bytes: <@0564b0> - <@0564ff>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @0564b0>      : 1a                         load.z64
	<div+1 @0564b1>    : 11 03                      dup.x64 sp(3)
	<div+3 @0564b3>    : 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<div+8 @0564b8>    : 02                         call
	<div+9 @0564b9>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @0564bd>   : 1a                         load.z64
	<div+14 @0564be>   : 11 07                      dup.x64 sp(7)
	<div+16 @0564c0>   : 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<div+21 @0564c5>   : 02                         call
	<div+22 @0564c6>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @0564ca>   : 88                         clt.f64
	<div+27 @0564cb>   : 05 34 00 00                jnz <div+79 @0564ff>
	lib/std/math/Complex.ci:88: (5 bytes: <@0564cf> - <@0564d4>): r: float64 := float64(b.im / b.re)
	<div+31 @0564cf>   : 11 03                      dup.x64 sp(3)
	<div+33 @0564d1>   : 11 03                      dup.x64 sp(3)
	<div+35 @0564d3>   : 84                         div.f64
	lib/std/math/Complex.ci:89: (8 bytes: <@0564d4> - <@0564dc>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @0564d4>   : 11 03                      dup.x64 sp(3)
	<div+38 @0564d6>   : 11 02                      dup.x64 sp(2)
	<div+40 @0564d8>   : 11 09                      dup.x64 sp(9)
	<div+42 @0564da>   : 83                         mul.f64
	<div+43 @0564db>   : 81                         add.f64
	lib/std/math/Complex.ci:90: (31 bytes: <@0564dc> - <@0564fb>): return void(.result := {...});
	<div+44 @0564dc>   : 11 09                      dup.x64 sp(9)
	<div+46 @0564de>   : 11 04                      dup.x64 sp(4)
	<div+48 @0564e0>   : 11 0f                      dup.x64 sp(15)
	<div+50 @0564e2>   : 83                         mul.f64
	<div+51 @0564e3>   : 81                         add.f64
	<div+52 @0564e4>   : 11 02                      dup.x64 sp(2)
	<div+54 @0564e6>   : 84                         div.f64
	<div+55 @0564e7>   : 14 0f                      set.x64 sp(15)
	lib/std/math/Complex.ci:92: (13 bytes: <@0564e9> - <@0564f6>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @0564e9>   : 11 0b                      dup.x64 sp(11)
	<div+59 @0564eb>   : 11 04                      dup.x64 sp(4)
	<div+61 @0564ed>   : 11 0d                      dup.x64 sp(13)
	<div+63 @0564ef>   : 83                         mul.f64
	<div+64 @0564f0>   : 82                         sub.f64
	<div+65 @0564f1>   : 11 02                      dup.x64 sp(2)
	<div+67 @0564f3>   : 84                         div.f64
	<div+68 @0564f4>   : 14 11                      set.x64 sp(17)
	<div+70 @0564f6>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @0564fa>   : 03                         ret
	<div+75 @0564fb>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math/Complex.ci:95: (5 bytes: <@0564ff> - <@056504>): r: float64 := float64(b.re / b.im)
	<div+79 @0564ff>   : 11 01                      dup.x64 sp(1)
	<div+81 @056501>   : 11 05                      dup.x64 sp(5)
	<div+83 @056503>   : 84                         div.f64
	lib/std/math/Complex.ci:96: (8 bytes: <@056504> - <@05650c>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @056504>   : 11 05                      dup.x64 sp(5)
	<div+86 @056506>   : 11 02                      dup.x64 sp(2)
	<div+88 @056508>   : 11 07                      dup.x64 sp(7)
	<div+90 @05650a>   : 83                         mul.f64
	<div+91 @05650b>   : 81                         add.f64
	lib/std/math/Complex.ci:97: (31 bytes: <@05650c> - <@05652b>): return void(.result := {...});
	<div+92 @05650c>   : 11 09                      dup.x64 sp(9)
	<div+94 @05650e>   : 11 04                      dup.x64 sp(4)
	<div+96 @056510>   : 83                         mul.f64
	<div+97 @056511>   : 11 0d                      dup.x64 sp(13)
	<div+99 @056513>   : 81                         add.f64
	<div+100 @056514>  : 11 02                      dup.x64 sp(2)
	<div+102 @056516>  : 84                         div.f64
	<div+103 @056517>  : 14 0f                      set.x64 sp(15)
	lib/std/math/Complex.ci:99: (13 bytes: <@056519> - <@056526>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @056519>  : 11 0b                      dup.x64 sp(11)
	<div+107 @05651b>  : 11 04                      dup.x64 sp(4)
	<div+109 @05651d>  : 83                         mul.f64
	<div+110 @05651e>  : 11 0b                      dup.x64 sp(11)
	<div+112 @056520>  : 82                         sub.f64
	<div+113 @056521>  : 11 02                      dup.x64 sp(2)
	<div+115 @056523>  : 84                         div.f64
	<div+116 @056524>  : 14 11                      set.x64 sp(17)
	<div+118 @056526>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @05652a>  : 03                         ret
.usages:
	lib/std/math/Complex.ci:172: referenced as `div`
	lib/std/math/Complex.ci:170: referenced as `div`
	lib/std/math/Complex.ci:163: referenced as `div`
	lib/std/math/Complex.ci:161: referenced as `div`
	lib/std/math/Complex.ci:106: referenced as `div`
	lib/std/math/Complex.ci:104: referenced as `div`
	lib/std/math/Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math/Complex.ci:168: referenced as `div`
	lib/std/math/Complex.ci:166: referenced as `div`
	lib/std/math/Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math/Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'lib/std/math/Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math/Complex.ci:186: referenced as `abs`
	lib/std/math/Complex.ci:133: referenced as `abs`
	lib/std/math/Complex.ci:129: referenced as `abs`
	lib/std/math/Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'lib/std/math/Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math/Complex.ci:186: referenced as `arg`
	lib/std/math/Complex.ci:134: referenced as `arg`
	lib/std/math/Complex.ci:129: referenced as `arg`
	lib/std/math/Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@056530>
.name: 'inv'
.file: 'lib/std/math/Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@056530> - <@05654f>)
	lib/std/math/Complex.ci:115: (11 bytes: <@056530> - <@05653b>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @056530>      : 11 01                      dup.x64 sp(1)
	<inv+2 @056532>    : 11 03                      dup.x64 sp(3)
	<inv+4 @056534>    : 83                         mul.f64
	<inv+5 @056535>    : 11 05                      dup.x64 sp(5)
	<inv+7 @056537>    : 11 07                      dup.x64 sp(7)
	<inv+9 @056539>    : 83                         mul.f64
	<inv+10 @05653a>   : 81                         add.f64
	lib/std/math/Complex.ci:116: (20 bytes: <@05653b> - <@05654f>): return void(.result := {...});
	<inv+11 @05653b>   : 11 03                      dup.x64 sp(3)
	<inv+13 @05653d>   : 11 02                      dup.x64 sp(2)
	<inv+15 @05653f>   : 84                         div.f64
	<inv+16 @056540>   : 14 09                      set.x64 sp(9)
	lib/std/math/Complex.ci:118: (8 bytes: <@056542> - <@05654a>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @056542>   : 11 05                      dup.x64 sp(5)
	<inv+20 @056544>   : 80                         neg.f64
	<inv+21 @056545>   : 11 02                      dup.x64 sp(2)
	<inv+23 @056547>   : 84                         div.f64
	<inv+24 @056548>   : 14 0b                      set.x64 sp(11)
	<inv+26 @05654a>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @05654e>   : 03                         ret
.usages:
	lib/std/math/Complex.ci:181: referenced as `inv`
	lib/std/math/Complex.ci:179: referenced as `inv`
	lib/std/math/Complex.ci:177: referenced as `inv`
	lib/std/math/Complex.ci:175: referenced as `inv`
	lib/std/math/Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'lib/std/math/Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math/Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'lib/std/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math/Complex.ci:172: referenced as `exp`
	lib/std/math/Complex.ci:172: referenced as `exp`
	lib/std/math/Complex.ci:170: referenced as `exp`
	lib/std/math/Complex.ci:170: referenced as `exp`
	lib/std/math/Complex.ci:168: referenced as `exp`
	lib/std/math/Complex.ci:168: referenced as `exp`
	lib/std/math/Complex.ci:166: referenced as `exp`
	lib/std/math/Complex.ci:166: referenced as `exp`
	lib/std/math/Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'lib/std/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math/Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@056550>
.name: 'pow'
.file: 'lib/std/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@056550> - <@0565b4>)
	lib/std/math/Complex.ci:133: (23 bytes: <@056550> - <@056567>): r: float64 := abs(a)
	<pow @056550>      : 12 05                      dup.x128 sp(5)
	<pow+2 @056552>    : 11 00                      dup.x64 sp(0)
	<pow+4 @056554>    : 11 02                      dup.x64 sp(2)
	<pow+6 @056556>    : 83                         mul.f64
	<pow+7 @056557>    : 11 04                      dup.x64 sp(4)
	<pow+9 @056559>    : 11 06                      dup.x64 sp(6)
	<pow+11 @05655b>   : 83                         mul.f64
	<pow+12 @05655c>   : 81                         add.f64
	<pow+13 @05655d>   : 01 2e 00 00                nfc(46) ;float64.sqrt(x: float64): float64
	<pow+17 @056561>   : 14 04                      set.x64 sp(4)
	<pow+19 @056563>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math/Complex.ci:134: (16 bytes: <@056567> - <@056577>): t: float64 := arg(a)
	<pow+23 @056567>   : 12 07                      dup.x128 sp(7)
	<pow+25 @056569>   : 11 00                      dup.x64 sp(0)
	<pow+27 @05656b>   : 11 04                      dup.x64 sp(4)
	<pow+29 @05656d>   : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @056571>   : 14 04                      set.x64 sp(4)
	<pow+35 @056573>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math/Complex.ci:135: (15 bytes: <@056577> - <@056586>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @056577>   : 11 05                      dup.x64 sp(5)
	<pow+41 @056579>   : 11 02                      dup.x64 sp(2)
	<pow+43 @05657b>   : 83                         mul.f64
	<pow+44 @05657c>   : 11 09                      dup.x64 sp(9)
	<pow+46 @05657e>   : 11 06                      dup.x64 sp(6)
	<pow+48 @056580>   : 01 2b 00 00                nfc(43) ;float64.log(x: float64): float64
	<pow+52 @056584>   : 83                         mul.f64
	<pow+53 @056585>   : 81                         add.f64
	lib/std/math/Complex.ci:136: (19 bytes: <@056586> - <@056599>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @056586>   : 11 04                      dup.x64 sp(4)
	<pow+56 @056588>   : 11 09                      dup.x64 sp(9)
	<pow+58 @05658a>   : 01 2d 00 00                nfc(45) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @05658e>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @056590>   : 80                         neg.f64
	<pow+65 @056591>   : 11 06                      dup.x64 sp(6)
	<pow+67 @056593>   : 83                         mul.f64
	<pow+68 @056594>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<pow+72 @056598>   : 83                         mul.f64
	lib/std/math/Complex.ci:137: (27 bytes: <@056599> - <@0565b4>): return void(.result := {...});
	<pow+73 @056599>   : 11 00                      dup.x64 sp(0)
	<pow+75 @05659b>   : 11 04                      dup.x64 sp(4)
	<pow+77 @05659d>   : 01 29 00 00                nfc(41) ;float64.cos(x: float64): float64
	<pow+81 @0565a1>   : 83                         mul.f64
	<pow+82 @0565a2>   : 14 13                      set.x64 sp(19)
	lib/std/math/Complex.ci:139: (11 bytes: <@0565a4> - <@0565af>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @0565a4>   : 11 00                      dup.x64 sp(0)
	<pow+86 @0565a6>   : 11 04                      dup.x64 sp(4)
	<pow+88 @0565a8>   : 01 28 00 00                nfc(40) ;float64.sin(x: float64): float64
	<pow+92 @0565ac>   : 83                         mul.f64
	<pow+93 @0565ad>   : 14 15                      set.x64 sp(21)
	<pow+95 @0565af>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @0565b3>   : 03                         ret
.usages:
	lib/std/math/Complex.ci:143: referenced as `pow`
	lib/std/math/Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'lib/std/math/Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math/Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math/Complex.ci:177: referenced as `sin`
	lib/std/math/Complex.ci:163: referenced as `sin`
	lib/std/math/Complex.ci:161: referenced as `sin`
	lib/std/math/Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math/Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math/Complex.ci:175: referenced as `cos`
	lib/std/math/Complex.ci:163: referenced as `cos`
	lib/std/math/Complex.ci:161: referenced as `cos`
	lib/std/math/Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'lib/std/math/Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math/Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'lib/std/math/Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math/Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'lib/std/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math/Complex.ci:181: referenced as `sinh`
	lib/std/math/Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'lib/std/math/Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math/Complex.ci:179: referenced as `cosh`
	lib/std/math/Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'lib/std/math/Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math/Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'lib/std/math/Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math/Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'lib/std/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math/Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'lib/std/math/Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math/Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'lib/std/math/Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math/Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'lib/std/math/Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math/Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'lib/std/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math/Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'lib/std/math/Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math/Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01fc10>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:2'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/std/math/Matrix4f.ci:168: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:158: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:155: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:106: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:106: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:20: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:18: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:16: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:14: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:10: referenced as `vec4f`
	lib/std/math/Vector4f.ci:107: referenced as `vec4f`
	lib/std/math/Vector4f.ci:104: referenced as `vec4f`
	lib/std/math/Vector4f.ci:102: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:84: referenced as `vec4f`
	lib/std/math/Vector4f.ci:84: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:37: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: referenced as `vec4f`
	lib/std/math/Vector4f.ci:2: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Vector4f.ci:4'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/std/math/Vector4f.ci:4: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Vector4f.ci:108'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/std/math/Vector4f.ci:108: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:174: referenced as `x`
	lib/std/math/Matrix4f.ci:173: referenced as `x`
	lib/std/math/Matrix4f.ci:172: referenced as `x`
	lib/std/math/Matrix4f.ci:171: referenced as `x`
	lib/std/math/Matrix4f.ci:171: referenced as `x`
	lib/std/math/Matrix4f.ci:163: referenced as `x`
	lib/std/math/Matrix4f.ci:162: referenced as `x`
	lib/std/math/Matrix4f.ci:161: referenced as `x`
	lib/std/math/Matrix4f.ci:160: referenced as `x`
	lib/std/math/Matrix4f.ci:160: referenced as `x`
	lib/std/math/Matrix4f.ci:120: referenced as `x`
	lib/std/math/Matrix4f.ci:117: referenced as `x`
	lib/std/math/Matrix4f.ci:92: referenced as `x`
	lib/std/math/Matrix4f.ci:91: referenced as `x`
	lib/std/math/Matrix4f.ci:90: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:70: referenced as `x`
	lib/std/math/Matrix4f.ci:69: referenced as `x`
	lib/std/math/Matrix4f.ci:68: referenced as `x`
	lib/std/math/Matrix4f.ci:67: referenced as `x`
	lib/std/math/Vector4f.ci:107: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:37: referenced as `x`
	lib/std/math/Vector4f.ci:27: referenced as `x`
	lib/std/math/Vector4f.ci:7: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:174: referenced as `y`
	lib/std/math/Matrix4f.ci:173: referenced as `y`
	lib/std/math/Matrix4f.ci:172: referenced as `y`
	lib/std/math/Matrix4f.ci:171: referenced as `y`
	lib/std/math/Matrix4f.ci:172: referenced as `y`
	lib/std/math/Matrix4f.ci:163: referenced as `y`
	lib/std/math/Matrix4f.ci:162: referenced as `y`
	lib/std/math/Matrix4f.ci:161: referenced as `y`
	lib/std/math/Matrix4f.ci:160: referenced as `y`
	lib/std/math/Matrix4f.ci:161: referenced as `y`
	lib/std/math/Matrix4f.ci:121: referenced as `y`
	lib/std/math/Matrix4f.ci:118: referenced as `y`
	lib/std/math/Matrix4f.ci:92: referenced as `y`
	lib/std/math/Matrix4f.ci:91: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:89: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:70: referenced as `y`
	lib/std/math/Matrix4f.ci:69: referenced as `y`
	lib/std/math/Matrix4f.ci:68: referenced as `y`
	lib/std/math/Matrix4f.ci:67: referenced as `y`
	lib/std/math/Vector4f.ci:107: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:37: referenced as `y`
	lib/std/math/Vector4f.ci:27: referenced as `y`
	lib/std/math/Vector4f.ci:9: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:174: referenced as `z`
	lib/std/math/Matrix4f.ci:173: referenced as `z`
	lib/std/math/Matrix4f.ci:172: referenced as `z`
	lib/std/math/Matrix4f.ci:171: referenced as `z`
	lib/std/math/Matrix4f.ci:173: referenced as `z`
	lib/std/math/Matrix4f.ci:163: referenced as `z`
	lib/std/math/Matrix4f.ci:162: referenced as `z`
	lib/std/math/Matrix4f.ci:161: referenced as `z`
	lib/std/math/Matrix4f.ci:160: referenced as `z`
	lib/std/math/Matrix4f.ci:162: referenced as `z`
	lib/std/math/Matrix4f.ci:122: referenced as `z`
	lib/std/math/Matrix4f.ci:119: referenced as `z`
	lib/std/math/Matrix4f.ci:92: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:90: referenced as `z`
	lib/std/math/Matrix4f.ci:89: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:70: referenced as `z`
	lib/std/math/Matrix4f.ci:69: referenced as `z`
	lib/std/math/Matrix4f.ci:68: referenced as `z`
	lib/std/math/Matrix4f.ci:67: referenced as `z`
	lib/std/math/Vector4f.ci:107: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:37: referenced as `z`
	lib/std/math/Vector4f.ci:27: referenced as `z`
	lib/std/math/Vector4f.ci:11: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:174: referenced as `w`
	lib/std/math/Matrix4f.ci:173: referenced as `w`
	lib/std/math/Matrix4f.ci:172: referenced as `w`
	lib/std/math/Matrix4f.ci:171: referenced as `w`
	lib/std/math/Matrix4f.ci:163: referenced as `w`
	lib/std/math/Matrix4f.ci:162: referenced as `w`
	lib/std/math/Matrix4f.ci:161: referenced as `w`
	lib/std/math/Matrix4f.ci:160: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:91: referenced as `w`
	lib/std/math/Matrix4f.ci:90: referenced as `w`
	lib/std/math/Matrix4f.ci:89: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:70: referenced as `w`
	lib/std/math/Matrix4f.ci:69: referenced as `w`
	lib/std/math/Matrix4f.ci:68: referenced as `w`
	lib/std/math/Matrix4f.ci:67: referenced as `w`
	lib/std/math/Vector4f.ci:107: referenced as `w`
	lib/std/math/Vector4f.ci:27: referenced as `w`
	lib/std/math/Vector4f.ci:13: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@0565b8>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@0565b8> - <@0565c5>)
	lib/std/math/Vector4f.ci:27: (13 bytes: <@0565b8> - <@0565c5>): return void(.result := {...});
	<vec4f @0565b8>      : 16 05 04                   mov.x32 sp(5, 4)
	lib/std/math/Vector4f.ci:27: (3 bytes: <@0565bb> - <@0565be>): void(.result.y := y);
	<vec4f+3 @0565bb>    : 16 06 03                   mov.x32 sp(6, 3)
	lib/std/math/Vector4f.ci:27: (3 bytes: <@0565be> - <@0565c1>): void(.result.z := z);
	<vec4f+6 @0565be>    : 16 07 02                   mov.x32 sp(7, 2)
	lib/std/math/Vector4f.ci:27: (3 bytes: <@0565c1> - <@0565c4>): void(.result.w := w);
	<vec4f+9 @0565c1>    : 16 08 01                   mov.x32 sp(8, 1)
	<vec4f+12 @0565c4>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:150: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:114: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:113: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:112: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:111: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:40: referenced as `vec4f`
	lib/std/math/Vector4f.ci:37: referenced as `vec4f`
	lib/std/math/Vector4f.ci:34: referenced as `vec4f`
	lib/std/math/Vector4f.ci:31: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:31'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:31: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
	lib/std/math/Vector4f.ci:34: defined as `vec4f(x: float32, y: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:37'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/std/math/Vector4f.ci:37: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:40'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/std/math/Matrix4f.ci:155: referenced as `vec4f`
	lib/std/math/Vector4f.ci:104: referenced as `vec4f`
	lib/std/math/Vector4f.ci:40: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/std/math/Vector4f.ci:71: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/std/math/Vector4f.ci:73: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/std/math/Vector4f.ci:75: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/std/math/Vector4f.ci:77: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Vector4f.ci:79'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/std/math/Vector4f.ci:104: referenced as `div`
	lib/std/math/Vector4f.ci:79: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/std/math/Vector4f.ci:82'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	lib/std/math/Vector4f.ci:82: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/std/math/Vector4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	lib/std/math/Vector4f.ci:84: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/std/math/Vector4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Vector4f.ci:102: referenced as `dp3`
	lib/std/math/Vector4f.ci:88: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/std/math/Vector4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Vector4f.ci:92: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/std/math/Vector4f.ci:96'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Vector4f.ci:96: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'lib/std/math/Vector4f.ci:99'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/std/math/Vector4f.ci:99: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'lib/std/math/Vector4f.ci:102'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/std/math/Matrix4f.ci:107: referenced as `length`
	lib/std/math/Vector4f.ci:104: referenced as `length`
	lib/std/math/Vector4f.ci:102: defined as `length(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'lib/std/math/Vector4f.ci:104'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
	lib/std/math/Vector4f.ci:104: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math/Vector4f.ci:107'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/std/math/Vector4f.ci:107: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@023388>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:2'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/std/math/Matrix4f.ci:168: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:158: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:106: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:88: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:84: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:82: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:80: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:75: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:62: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:2: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:4: defined as `data`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/std/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:7: defined as `m`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/std/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:10: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:177'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/std/math/Matrix4f.ci:177: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:171: referenced as `x`
	lib/std/math/Matrix4f.ci:160: referenced as `x`
	lib/std/math/Matrix4f.ci:111: referenced as `x`
	lib/std/math/Matrix4f.ci:95: referenced as `x`
	lib/std/math/Matrix4f.ci:95: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:92: referenced as `x`
	lib/std/math/Matrix4f.ci:91: referenced as `x`
	lib/std/math/Matrix4f.ci:90: referenced as `x`
	lib/std/math/Matrix4f.ci:89: referenced as `x`
	lib/std/math/Matrix4f.ci:84: referenced as `x`
	lib/std/math/Matrix4f.ci:82: referenced as `x`
	lib/std/math/Matrix4f.ci:80: referenced as `x`
	lib/std/math/Matrix4f.ci:76: referenced as `x`
	lib/std/math/Matrix4f.ci:67: referenced as `x`
	lib/std/math/Matrix4f.ci:14: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:172: referenced as `y`
	lib/std/math/Matrix4f.ci:161: referenced as `y`
	lib/std/math/Matrix4f.ci:112: referenced as `y`
	lib/std/math/Matrix4f.ci:96: referenced as `y`
	lib/std/math/Matrix4f.ci:96: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:92: referenced as `y`
	lib/std/math/Matrix4f.ci:91: referenced as `y`
	lib/std/math/Matrix4f.ci:90: referenced as `y`
	lib/std/math/Matrix4f.ci:89: referenced as `y`
	lib/std/math/Matrix4f.ci:84: referenced as `y`
	lib/std/math/Matrix4f.ci:82: referenced as `y`
	lib/std/math/Matrix4f.ci:80: referenced as `y`
	lib/std/math/Matrix4f.ci:76: referenced as `y`
	lib/std/math/Matrix4f.ci:68: referenced as `y`
	lib/std/math/Matrix4f.ci:16: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:173: referenced as `z`
	lib/std/math/Matrix4f.ci:162: referenced as `z`
	lib/std/math/Matrix4f.ci:113: referenced as `z`
	lib/std/math/Matrix4f.ci:97: referenced as `z`
	lib/std/math/Matrix4f.ci:97: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:92: referenced as `z`
	lib/std/math/Matrix4f.ci:91: referenced as `z`
	lib/std/math/Matrix4f.ci:90: referenced as `z`
	lib/std/math/Matrix4f.ci:89: referenced as `z`
	lib/std/math/Matrix4f.ci:84: referenced as `z`
	lib/std/math/Matrix4f.ci:82: referenced as `z`
	lib/std/math/Matrix4f.ci:80: referenced as `z`
	lib/std/math/Matrix4f.ci:76: referenced as `z`
	lib/std/math/Matrix4f.ci:69: referenced as `z`
	lib/std/math/Matrix4f.ci:18: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:174: referenced as `w`
	lib/std/math/Matrix4f.ci:163: referenced as `w`
	lib/std/math/Matrix4f.ci:150: referenced as `w`
	lib/std/math/Matrix4f.ci:114: referenced as `w`
	lib/std/math/Matrix4f.ci:98: referenced as `w`
	lib/std/math/Matrix4f.ci:98: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:92: referenced as `w`
	lib/std/math/Matrix4f.ci:91: referenced as `w`
	lib/std/math/Matrix4f.ci:90: referenced as `w`
	lib/std/math/Matrix4f.ci:89: referenced as `w`
	lib/std/math/Matrix4f.ci:84: referenced as `w`
	lib/std/math/Matrix4f.ci:82: referenced as `w`
	lib/std/math/Matrix4f.ci:76: referenced as `w`
	lib/std/math/Matrix4f.ci:70: referenced as `w`
	lib/std/math/Matrix4f.ci:20: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:177'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
	lib/std/math/Matrix4f.ci:177: defined as `<?>`
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:135: referenced as `xx`
	lib/std/math/Matrix4f.ci:24: defined as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:136: referenced as `xy`
	lib/std/math/Matrix4f.ci:26: defined as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:137: referenced as `xz`
	lib/std/math/Matrix4f.ci:28: defined as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:138: referenced as `xw`
	lib/std/math/Matrix4f.ci:30: defined as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:140: referenced as `yx`
	lib/std/math/Matrix4f.ci:33: defined as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:141: referenced as `yy`
	lib/std/math/Matrix4f.ci:35: defined as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:142: referenced as `yz`
	lib/std/math/Matrix4f.ci:37: defined as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:143: referenced as `yw`
	lib/std/math/Matrix4f.ci:39: defined as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:145: referenced as `zx`
	lib/std/math/Matrix4f.ci:42: defined as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:146: referenced as `zy`
	lib/std/math/Matrix4f.ci:44: defined as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:147: referenced as `zz`
	lib/std/math/Matrix4f.ci:46: defined as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:148: referenced as `zw`
	lib/std/math/Matrix4f.ci:48: defined as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:51: defined as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:53: defined as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:55: defined as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:57: defined as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0565c8>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@0565c8> - <@0565f9>)
	lib/std/math/Matrix4f.ci:66: (49 bytes: <@0565c8> - <@0565f9>): return void(.result := {...});
	<mat4f @0565c8>      : 16 11 10                   mov.x32 sp(17, 16)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@0565cb> - <@0565ce>): void(.result.x.y := xy);
	<mat4f+3 @0565cb>    : 16 12 0f                   mov.x32 sp(18, 15)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@0565ce> - <@0565d1>): void(.result.x.z := xz);
	<mat4f+6 @0565ce>    : 16 13 0e                   mov.x32 sp(19, 14)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@0565d1> - <@0565d4>): void(.result.x.w := xw);
	<mat4f+9 @0565d1>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@0565d4> - <@0565d7>): void(.result.y.x := yx);
	<mat4f+12 @0565d4>   : 16 15 0c                   mov.x32 sp(21, 12)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@0565d7> - <@0565da>): void(.result.y.y := yy);
	<mat4f+15 @0565d7>   : 16 16 0b                   mov.x32 sp(22, 11)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@0565da> - <@0565dd>): void(.result.y.z := yz);
	<mat4f+18 @0565da>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@0565dd> - <@0565e0>): void(.result.y.w := yw);
	<mat4f+21 @0565dd>   : 16 18 09                   mov.x32 sp(24, 9)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@0565e0> - <@0565e3>): void(.result.z.x := zx);
	<mat4f+24 @0565e0>   : 16 19 08                   mov.x32 sp(25, 8)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@0565e3> - <@0565e6>): void(.result.z.y := zy);
	<mat4f+27 @0565e3>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@0565e6> - <@0565e9>): void(.result.z.z := zz);
	<mat4f+30 @0565e6>   : 16 1b 06                   mov.x32 sp(27, 6)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@0565e9> - <@0565ec>): void(.result.z.w := zw);
	<mat4f+33 @0565e9>   : 16 1c 05                   mov.x32 sp(28, 5)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@0565ec> - <@0565ef>): void(.result.w.x := wx);
	<mat4f+36 @0565ec>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@0565ef> - <@0565f2>): void(.result.w.y := wy);
	<mat4f+39 @0565ef>   : 16 1e 03                   mov.x32 sp(30, 3)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@0565f2> - <@0565f5>): void(.result.w.z := wz);
	<mat4f+42 @0565f2>   : 16 1f 02                   mov.x32 sp(31, 2)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@0565f5> - <@0565f8>): void(.result.w.w := ww);
	<mat4f+45 @0565f5>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @0565f8>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:62: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@056600>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@056600> - <@056615>)
	lib/std/math/Matrix4f.ci:76: (21 bytes: <@056600> - <@056615>): return void(.result := {...});
	<mat4f @056600>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @056602>    : 24                         load.i128
	<mat4f+3 @056603>    : 15 09                      set.x128 sp(9)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@056605> - <@05660a>): void(.result.y := y);
	<mat4f+5 @056605>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @056607>    : 24                         load.i128
	<mat4f+8 @056608>    : 15 0d                      set.x128 sp(13)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@05660a> - <@05660f>): void(.result.z := z);
	<mat4f+10 @05660a>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @05660c>   : 24                         load.i128
	<mat4f+13 @05660d>   : 15 11                      set.x128 sp(17)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@05660f> - <@056614>): void(.result.w := w);
	<mat4f+15 @05660f>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @056611>   : 24                         load.i128
	<mat4f+18 @056612>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @056614>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:75: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/std/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/std/math/Matrix4f.ci:80: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/std/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/std/math/Matrix4f.ci:82: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/std/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/std/math/Matrix4f.ci:98: referenced as `dp4`
	lib/std/math/Matrix4f.ci:97: referenced as `dp4`
	lib/std/math/Matrix4f.ci:96: referenced as `dp4`
	lib/std/math/Matrix4f.ci:95: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@056618>
.name: 'mul'
.file: 'lib/std/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@056618> - <@0567b9>)
	lib/std/math/Matrix4f.ci:88: (144 bytes: <@056618> - <@0566a8>): transposed: mat4f := {...}
	<mul @056618>      : 09 40 00 00                inc.sp(+64)
	lib/std/math/Matrix4f.ci:89: (5 bytes: <@05661c> - <@056621>): void(transposed.x.x := rhs.x.x);
	<mul+4 @05661c>    : 10 11                      dup.x32 sp(17)
	<mul+6 @05661e>    : 22                         load.i32
	<mul+7 @05661f>    : 13 01                      set.x32 sp(1)
	lib/std/math/Matrix4f.ci:89: (9 bytes: <@056621> - <@05662a>): void(transposed.x.y := rhs.y.x);
	<mul+9 @056621>    : 10 11                      dup.x32 sp(17)
	<mul+11 @056623>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @056627>   : 22                         load.i32
	<mul+16 @056628>   : 13 02                      set.x32 sp(2)
	lib/std/math/Matrix4f.ci:89: (9 bytes: <@05662a> - <@056633>): void(transposed.x.z := rhs.z.x);
	<mul+18 @05662a>   : 10 11                      dup.x32 sp(17)
	<mul+20 @05662c>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @056630>   : 22                         load.i32
	<mul+25 @056631>   : 13 03                      set.x32 sp(3)
	lib/std/math/Matrix4f.ci:89: (9 bytes: <@056633> - <@05663c>): void(transposed.x.w := rhs.w.x);
	<mul+27 @056633>   : 10 11                      dup.x32 sp(17)
	<mul+29 @056635>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @056639>   : 22                         load.i32
	<mul+34 @05663a>   : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:90: (9 bytes: <@05663c> - <@056645>): void(transposed.y.x := rhs.x.y);
	<mul+36 @05663c>   : 10 11                      dup.x32 sp(17)
	<mul+38 @05663e>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @056642>   : 22                         load.i32
	<mul+43 @056643>   : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:90: (9 bytes: <@056645> - <@05664e>): void(transposed.y.y := rhs.y.y);
	<mul+45 @056645>   : 10 11                      dup.x32 sp(17)
	<mul+47 @056647>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @05664b>   : 22                         load.i32
	<mul+52 @05664c>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:90: (9 bytes: <@05664e> - <@056657>): void(transposed.y.z := rhs.z.y);
	<mul+54 @05664e>   : 10 11                      dup.x32 sp(17)
	<mul+56 @056650>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @056654>   : 22                         load.i32
	<mul+61 @056655>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:90: (9 bytes: <@056657> - <@056660>): void(transposed.y.w := rhs.w.y);
	<mul+63 @056657>   : 10 11                      dup.x32 sp(17)
	<mul+65 @056659>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @05665d>   : 22                         load.i32
	<mul+70 @05665e>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:91: (9 bytes: <@056660> - <@056669>): void(transposed.z.x := rhs.x.z);
	<mul+72 @056660>   : 10 11                      dup.x32 sp(17)
	<mul+74 @056662>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @056666>   : 22                         load.i32
	<mul+79 @056667>   : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:91: (9 bytes: <@056669> - <@056672>): void(transposed.z.y := rhs.y.z);
	<mul+81 @056669>   : 10 11                      dup.x32 sp(17)
	<mul+83 @05666b>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @05666f>   : 22                         load.i32
	<mul+88 @056670>   : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:91: (9 bytes: <@056672> - <@05667b>): void(transposed.z.z := rhs.z.z);
	<mul+90 @056672>   : 10 11                      dup.x32 sp(17)
	<mul+92 @056674>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @056678>   : 22                         load.i32
	<mul+97 @056679>   : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:91: (9 bytes: <@05667b> - <@056684>): void(transposed.z.w := rhs.w.z);
	<mul+99 @05667b>   : 10 11                      dup.x32 sp(17)
	<mul+101 @05667d>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @056681>  : 22                         load.i32
	<mul+106 @056682>  : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:92: (9 bytes: <@056684> - <@05668d>): void(transposed.w.x := rhs.x.w);
	<mul+108 @056684>  : 10 11                      dup.x32 sp(17)
	<mul+110 @056686>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @05668a>  : 22                         load.i32
	<mul+115 @05668b>  : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:92: (9 bytes: <@05668d> - <@056696>): void(transposed.w.y := rhs.y.w);
	<mul+117 @05668d>  : 10 11                      dup.x32 sp(17)
	<mul+119 @05668f>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @056693>  : 22                         load.i32
	<mul+124 @056694>  : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:92: (9 bytes: <@056696> - <@05669f>): void(transposed.w.z := rhs.z.w);
	<mul+126 @056696>  : 10 11                      dup.x32 sp(17)
	<mul+128 @056698>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @05669c>  : 22                         load.i32
	<mul+133 @05669d>  : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:92: (9 bytes: <@05669f> - <@0566a8>): void(transposed.w.w := rhs.w.w);
	<mul+135 @05669f>  : 10 11                      dup.x32 sp(17)
	<mul+137 @0566a1>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @0566a5>  : 22                         load.i32
	<mul+142 @0566a6>  : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:94: (273 bytes: <@0566a8> - <@0567b9>): return void(.result := {...});
	<mul+144 @0566a8>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @0566ac>  : 10 13                      dup.x32 sp(19)
	<mul+150 @0566ae>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @0566b2>  : 10 05                      dup.x32 sp(5)
	<mul+156 @0566b4>  : 24                         load.i128
	<mul+157 @0566b5>  : 10 08                      dup.x32 sp(8)
	<mul+159 @0566b7>  : 24                         load.i128
	<mul+160 @0566b8>  : 9b                         dp4.v4f
	<mul+161 @0566b9>  : 10 06                      dup.x32 sp(6)
	<mul+163 @0566bb>  : 0c 10 00 00                inc.i32(+16)
	<mul+167 @0566bf>  : 24                         load.i128
	<mul+168 @0566c0>  : 10 09                      dup.x32 sp(9)
	<mul+170 @0566c2>  : 24                         load.i128
	<mul+171 @0566c3>  : 9b                         dp4.v4f
	<mul+172 @0566c4>  : 10 07                      dup.x32 sp(7)
	<mul+174 @0566c6>  : 0c 20 00 00                inc.i32(+32)
	<mul+178 @0566ca>  : 24                         load.i128
	<mul+179 @0566cb>  : 10 0a                      dup.x32 sp(10)
	<mul+181 @0566cd>  : 24                         load.i128
	<mul+182 @0566ce>  : 9b                         dp4.v4f
	<mul+183 @0566cf>  : 10 08                      dup.x32 sp(8)
	<mul+185 @0566d1>  : 0c 30 00 00                inc.i32(+48)
	<mul+189 @0566d5>  : 24                         load.i128
	<mul+190 @0566d6>  : 10 0b                      dup.x32 sp(11)
	<mul+192 @0566d8>  : 24                         load.i128
	<mul+193 @0566d9>  : 9b                         dp4.v4f
	<mul+194 @0566da>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @0566df>  : 02                         call
	<mul+200 @0566e0>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @0566e4>  : 15 02                      set.x128 sp(2)
	<mul+206 @0566e6>  : 15 17                      set.x128 sp(23)
	lib/std/math/Matrix4f.ci:96: (68 bytes: <@0566e8> - <@05672c>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @0566e8>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @0566ec>  : 10 13                      dup.x32 sp(19)
	<mul+214 @0566ee>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @0566f2>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @0566f6>  : 10 05                      dup.x32 sp(5)
	<mul+224 @0566f8>  : 24                         load.i128
	<mul+225 @0566f9>  : 10 08                      dup.x32 sp(8)
	<mul+227 @0566fb>  : 24                         load.i128
	<mul+228 @0566fc>  : 9b                         dp4.v4f
	<mul+229 @0566fd>  : 10 06                      dup.x32 sp(6)
	<mul+231 @0566ff>  : 0c 10 00 00                inc.i32(+16)
	<mul+235 @056703>  : 24                         load.i128
	<mul+236 @056704>  : 10 09                      dup.x32 sp(9)
	<mul+238 @056706>  : 24                         load.i128
	<mul+239 @056707>  : 9b                         dp4.v4f
	<mul+240 @056708>  : 10 07                      dup.x32 sp(7)
	<mul+242 @05670a>  : 0c 20 00 00                inc.i32(+32)
	<mul+246 @05670e>  : 24                         load.i128
	<mul+247 @05670f>  : 10 0a                      dup.x32 sp(10)
	<mul+249 @056711>  : 24                         load.i128
	<mul+250 @056712>  : 9b                         dp4.v4f
	<mul+251 @056713>  : 10 08                      dup.x32 sp(8)
	<mul+253 @056715>  : 0c 30 00 00                inc.i32(+48)
	<mul+257 @056719>  : 24                         load.i128
	<mul+258 @05671a>  : 10 0b                      dup.x32 sp(11)
	<mul+260 @05671c>  : 24                         load.i128
	<mul+261 @05671d>  : 9b                         dp4.v4f
	<mul+262 @05671e>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @056723>  : 02                         call
	<mul+268 @056724>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @056728>  : 15 02                      set.x128 sp(2)
	<mul+274 @05672a>  : 15 1b                      set.x128 sp(27)
	lib/std/math/Matrix4f.ci:97: (68 bytes: <@05672c> - <@056770>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @05672c>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @056730>  : 10 13                      dup.x32 sp(19)
	<mul+282 @056732>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @056736>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @05673a>  : 10 05                      dup.x32 sp(5)
	<mul+292 @05673c>  : 24                         load.i128
	<mul+293 @05673d>  : 10 08                      dup.x32 sp(8)
	<mul+295 @05673f>  : 24                         load.i128
	<mul+296 @056740>  : 9b                         dp4.v4f
	<mul+297 @056741>  : 10 06                      dup.x32 sp(6)
	<mul+299 @056743>  : 0c 10 00 00                inc.i32(+16)
	<mul+303 @056747>  : 24                         load.i128
	<mul+304 @056748>  : 10 09                      dup.x32 sp(9)
	<mul+306 @05674a>  : 24                         load.i128
	<mul+307 @05674b>  : 9b                         dp4.v4f
	<mul+308 @05674c>  : 10 07                      dup.x32 sp(7)
	<mul+310 @05674e>  : 0c 20 00 00                inc.i32(+32)
	<mul+314 @056752>  : 24                         load.i128
	<mul+315 @056753>  : 10 0a                      dup.x32 sp(10)
	<mul+317 @056755>  : 24                         load.i128
	<mul+318 @056756>  : 9b                         dp4.v4f
	<mul+319 @056757>  : 10 08                      dup.x32 sp(8)
	<mul+321 @056759>  : 0c 30 00 00                inc.i32(+48)
	<mul+325 @05675d>  : 24                         load.i128
	<mul+326 @05675e>  : 10 0b                      dup.x32 sp(11)
	<mul+328 @056760>  : 24                         load.i128
	<mul+329 @056761>  : 9b                         dp4.v4f
	<mul+330 @056762>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @056767>  : 02                         call
	<mul+336 @056768>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @05676c>  : 15 02                      set.x128 sp(2)
	<mul+342 @05676e>  : 15 1f                      set.x128 sp(31)
	lib/std/math/Matrix4f.ci:98: (68 bytes: <@056770> - <@0567b4>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @056770>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @056774>  : 10 13                      dup.x32 sp(19)
	<mul+350 @056776>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @05677a>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @05677e>  : 10 05                      dup.x32 sp(5)
	<mul+360 @056780>  : 24                         load.i128
	<mul+361 @056781>  : 10 08                      dup.x32 sp(8)
	<mul+363 @056783>  : 24                         load.i128
	<mul+364 @056784>  : 9b                         dp4.v4f
	<mul+365 @056785>  : 10 06                      dup.x32 sp(6)
	<mul+367 @056787>  : 0c 10 00 00                inc.i32(+16)
	<mul+371 @05678b>  : 24                         load.i128
	<mul+372 @05678c>  : 10 09                      dup.x32 sp(9)
	<mul+374 @05678e>  : 24                         load.i128
	<mul+375 @05678f>  : 9b                         dp4.v4f
	<mul+376 @056790>  : 10 07                      dup.x32 sp(7)
	<mul+378 @056792>  : 0c 20 00 00                inc.i32(+32)
	<mul+382 @056796>  : 24                         load.i128
	<mul+383 @056797>  : 10 0a                      dup.x32 sp(10)
	<mul+385 @056799>  : 24                         load.i128
	<mul+386 @05679a>  : 9b                         dp4.v4f
	<mul+387 @05679b>  : 10 08                      dup.x32 sp(8)
	<mul+389 @05679d>  : 0c 30 00 00                inc.i32(+48)
	<mul+393 @0567a1>  : 24                         load.i128
	<mul+394 @0567a2>  : 10 0b                      dup.x32 sp(11)
	<mul+396 @0567a4>  : 24                         load.i128
	<mul+397 @0567a5>  : 9b                         dp4.v4f
	<mul+398 @0567a6>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @0567ab>  : 02                         call
	<mul+404 @0567ac>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @0567b0>  : 15 02                      set.x128 sp(2)
	<mul+410 @0567b2>  : 15 23                      set.x128 sp(35)
	<mul+412 @0567b4>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @0567b8>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:87: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 524
.offset: <@0567c0>
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:106'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (524 bytes: <@0567c0> - <@0569cc>)
	lib/std/math/Matrix4f.ci:107: (18 bytes: <@0567c0> - <@0567d2>): len: float32 := length(direction)
	<rotation @0567c0>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @0567c2>    : 24                         load.i128
	<rotation+3 @0567c3>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @0567c5>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @0567c7>    : 9a                         dp3.v4f
	<rotation+8 @0567c8>    : 01 26 00 00                nfc(38) ;float32.sqrt(x: float32): float32
	<rotation+12 @0567cc>   : 13 04                      set.x32 sp(4)
	<rotation+14 @0567ce>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math/Matrix4f.ci:108: (138 bytes: <@0567d2> - <@05685c>): if (bool((len) < 0.000000))
	<rotation+18 @0567d2>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @0567d4>   : 7d                         f32.2f64
	<rotation+21 @0567d5>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @0567de>   : 88                         clt.f64
	<rotation+31 @0567df>   : 06 7d 00 00                jz <rotation+156 @05685c>
	lib/std/math/Matrix4f.ci:109: (36 bytes: <@0567e3> - <@056807>): trace(void("invalid direction of rotation", direction));
	<rotation+35 @0567e3>   : 1f 58 30 02 00             load.ref <@023058> ;"lib/std/math/Matrix4f.ci"
	<rotation+40 @0567e8>   : 1c 6d 00 00 00             load.c32 109
	<rotation+45 @0567ed>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @0567f2>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @0567f7>   : 1f f6 32 02 00             load.ref <@0232f6> ;"invalid direction of rotation"
	<rotation+60 @0567fc>   : 1f 10 fc 01 00             load.ref <@01fc10> ;vec4f
	<rotation+65 @056801>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @056803>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/math/Matrix4f.ci:110: (85 bytes: <@056807> - <@05685c>): return void(.result := {...});
	<rotation+71 @056807>   : 09 10 00 00                inc.sp(+16)
	<rotation+75 @05680b>   : 19                         load.z32
	<rotation+76 @05680c>   : 19                         load.z32
	<rotation+77 @05680d>   : 19                         load.z32
	<rotation+78 @05680e>   : 19                         load.z32
	<rotation+79 @05680f>   : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+84 @056814>   : 02                         call
	<rotation+85 @056815>   : 09 f0 ff ff                inc.sp(-16)
	<rotation+89 @056819>   : 15 09                      set.x128 sp(9)
	lib/std/math/Matrix4f.ci:112: (20 bytes: <@05681b> - <@05682f>): void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+91 @05681b>   : 09 10 00 00                inc.sp(+16)
	<rotation+95 @05681f>   : 19                         load.z32
	<rotation+96 @056820>   : 19                         load.z32
	<rotation+97 @056821>   : 19                         load.z32
	<rotation+98 @056822>   : 19                         load.z32
	<rotation+99 @056823>   : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+104 @056828>  : 02                         call
	<rotation+105 @056829>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+109 @05682d>  : 15 0d                      set.x128 sp(13)
	lib/std/math/Matrix4f.ci:113: (20 bytes: <@05682f> - <@056843>): void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+111 @05682f>  : 09 10 00 00                inc.sp(+16)
	<rotation+115 @056833>  : 19                         load.z32
	<rotation+116 @056834>  : 19                         load.z32
	<rotation+117 @056835>  : 19                         load.z32
	<rotation+118 @056836>  : 19                         load.z32
	<rotation+119 @056837>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+124 @05683c>  : 02                         call
	<rotation+125 @05683d>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+129 @056841>  : 15 11                      set.x128 sp(17)
	lib/std/math/Matrix4f.ci:114: (20 bytes: <@056843> - <@056857>): void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+131 @056843>  : 09 10 00 00                inc.sp(+16)
	<rotation+135 @056847>  : 19                         load.z32
	<rotation+136 @056848>  : 19                         load.z32
	<rotation+137 @056849>  : 19                         load.z32
	<rotation+138 @05684a>  : 19                         load.z32
	<rotation+139 @05684b>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+144 @056850>  : 02                         call
	<rotation+145 @056851>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+149 @056855>  : 15 15                      set.x128 sp(21)
	<rotation+151 @056857>  : 09 fc ff ff                inc.sp(-4)
	<rotation+155 @05685b>  : 03                         ret
	lib/std/math/Matrix4f.ci:117: (6 bytes: <@05685c> - <@056862>): x: float32 := float32(direction.x / len)
	<rotation+156 @05685c>  : 10 03                      dup.x32 sp(3)
	<rotation+158 @05685e>  : 22                         load.i32
	<rotation+159 @05685f>  : 10 01                      dup.x32 sp(1)
	<rotation+161 @056861>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:118: (10 bytes: <@056862> - <@05686c>): y: float32 := float32(direction.y / len)
	<rotation+162 @056862>  : 10 04                      dup.x32 sp(4)
	<rotation+164 @056864>  : 0c 04 00 00                inc.i32(+4)
	<rotation+168 @056868>  : 22                         load.i32
	<rotation+169 @056869>  : 10 02                      dup.x32 sp(2)
	<rotation+171 @05686b>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:119: (10 bytes: <@05686c> - <@056876>): z: float32 := float32(direction.z / len)
	<rotation+172 @05686c>  : 10 05                      dup.x32 sp(5)
	<rotation+174 @05686e>  : 0c 08 00 00                inc.i32(+8)
	<rotation+178 @056872>  : 22                         load.i32
	<rotation+179 @056873>  : 10 03                      dup.x32 sp(3)
	<rotation+181 @056875>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:120: (3 bytes: <@056876> - <@056879>): cx: float32 := center.x
	<rotation+182 @056876>  : 10 07                      dup.x32 sp(7)
	<rotation+184 @056878>  : 22                         load.i32
	lib/std/math/Matrix4f.ci:121: (7 bytes: <@056879> - <@056880>): cy: float32 := center.y
	<rotation+185 @056879>  : 10 08                      dup.x32 sp(8)
	<rotation+187 @05687b>  : 0c 04 00 00                inc.i32(+4)
	<rotation+191 @05687f>  : 22                         load.i32
	lib/std/math/Matrix4f.ci:122: (7 bytes: <@056880> - <@056887>): cz: float32 := center.z
	<rotation+192 @056880>  : 10 09                      dup.x32 sp(9)
	<rotation+194 @056882>  : 0c 08 00 00                inc.i32(+8)
	<rotation+198 @056886>  : 22                         load.i32
	lib/std/math/Matrix4f.ci:123: (5 bytes: <@056887> - <@05688c>): xx: float32 := float32(x * x)
	<rotation+199 @056887>  : 10 05                      dup.x32 sp(5)
	<rotation+201 @056889>  : 10 06                      dup.x32 sp(6)
	<rotation+203 @05688b>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:124: (5 bytes: <@05688c> - <@056891>): xy: float32 := float32(x * y)
	<rotation+204 @05688c>  : 10 06                      dup.x32 sp(6)
	<rotation+206 @05688e>  : 10 06                      dup.x32 sp(6)
	<rotation+208 @056890>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:125: (5 bytes: <@056891> - <@056896>): xz: float32 := float32(x * z)
	<rotation+209 @056891>  : 10 07                      dup.x32 sp(7)
	<rotation+211 @056893>  : 10 06                      dup.x32 sp(6)
	<rotation+213 @056895>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:126: (5 bytes: <@056896> - <@05689b>): yy: float32 := float32(y * y)
	<rotation+214 @056896>  : 10 07                      dup.x32 sp(7)
	<rotation+216 @056898>  : 10 08                      dup.x32 sp(8)
	<rotation+218 @05689a>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:127: (5 bytes: <@05689b> - <@0568a0>): yz: float32 := float32(y * z)
	<rotation+219 @05689b>  : 10 08                      dup.x32 sp(8)
	<rotation+221 @05689d>  : 10 08                      dup.x32 sp(8)
	<rotation+223 @05689f>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:128: (5 bytes: <@0568a0> - <@0568a5>): zz: float32 := float32(z * z)
	<rotation+224 @0568a0>  : 10 08                      dup.x32 sp(8)
	<rotation+226 @0568a2>  : 10 09                      dup.x32 sp(9)
	<rotation+228 @0568a4>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:130: (6 bytes: <@0568a5> - <@0568ab>): s: float32 := float32.sin(angle)
	<rotation+229 @0568a5>  : 10 0e                      dup.x32 sp(14)
	<rotation+231 @0568a7>  : 01 20 00 00                nfc(32) ;float32.sin(x: float32): float32
	lib/std/math/Matrix4f.ci:131: (6 bytes: <@0568ab> - <@0568b1>): c: float32 := float32.cos(angle)
	<rotation+235 @0568ab>  : 10 0f                      dup.x32 sp(15)
	<rotation+237 @0568ad>  : 01 21 00 00                nfc(33) ;float32.cos(x: float32): float32
	lib/std/math/Matrix4f.ci:132: (8 bytes: <@0568b1> - <@0568b9>): k: float32 := float32((1) - c)
	<rotation+241 @0568b1>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+246 @0568b6>  : 10 01                      dup.x32 sp(1)
	<rotation+248 @0568b8>  : 72                         sub.f32
	lib/std/math/Matrix4f.ci:134: (275 bytes: <@0568b9> - <@0569cc>): return void(.result := {...});
	<rotation+249 @0568b9>  : 10 08                      dup.x32 sp(8)
	<rotation+251 @0568bb>  : 10 06                      dup.x32 sp(6)
	<rotation+253 @0568bd>  : 10 05                      dup.x32 sp(5)
	<rotation+255 @0568bf>  : 71                         add.f32
	<rotation+256 @0568c0>  : 10 03                      dup.x32 sp(3)
	<rotation+258 @0568c2>  : 73                         mul.f32
	<rotation+259 @0568c3>  : 71                         add.f32
	<rotation+260 @0568c4>  : 13 15                      set.x32 sp(21)
	lib/std/math/Matrix4f.ci:136: (13 bytes: <@0568c6> - <@0568d3>): void(.result.xy := float32(float32(xy * k) - float32(z * s)));
	<rotation+262 @0568c6>  : 10 07                      dup.x32 sp(7)
	<rotation+264 @0568c8>  : 10 01                      dup.x32 sp(1)
	<rotation+266 @0568ca>  : 73                         mul.f32
	<rotation+267 @0568cb>  : 10 0d                      dup.x32 sp(13)
	<rotation+269 @0568cd>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @0568cf>  : 73                         mul.f32
	<rotation+272 @0568d0>  : 72                         sub.f32
	<rotation+273 @0568d1>  : 13 16                      set.x32 sp(22)
	lib/std/math/Matrix4f.ci:137: (13 bytes: <@0568d3> - <@0568e0>): void(.result.xz := float32(float32(xz * k) + float32(y * s)));
	<rotation+275 @0568d3>  : 10 06                      dup.x32 sp(6)
	<rotation+277 @0568d5>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @0568d7>  : 73                         mul.f32
	<rotation+280 @0568d8>  : 10 0e                      dup.x32 sp(14)
	<rotation+282 @0568da>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @0568dc>  : 73                         mul.f32
	<rotation+285 @0568dd>  : 71                         add.f32
	<rotation+286 @0568de>  : 13 17                      set.x32 sp(23)
	lib/std/math/Matrix4f.ci:138: (43 bytes: <@0568e0> - <@05690b>): void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
	<rotation+288 @0568e0>  : 10 0b                      dup.x32 sp(11)
	<rotation+290 @0568e2>  : 10 06                      dup.x32 sp(6)
	<rotation+292 @0568e4>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @0568e6>  : 71                         add.f32
	<rotation+295 @0568e7>  : 73                         mul.f32
	<rotation+296 @0568e8>  : 10 0f                      dup.x32 sp(15)
	<rotation+298 @0568ea>  : 10 0c                      dup.x32 sp(12)
	<rotation+300 @0568ec>  : 10 10                      dup.x32 sp(16)
	<rotation+302 @0568ee>  : 73                         mul.f32
	<rotation+303 @0568ef>  : 10 0c                      dup.x32 sp(12)
	<rotation+305 @0568f1>  : 10 10                      dup.x32 sp(16)
	<rotation+307 @0568f3>  : 73                         mul.f32
	<rotation+308 @0568f4>  : 71                         add.f32
	<rotation+309 @0568f5>  : 73                         mul.f32
	<rotation+310 @0568f6>  : 72                         sub.f32
	<rotation+311 @0568f7>  : 10 01                      dup.x32 sp(1)
	<rotation+313 @0568f9>  : 73                         mul.f32
	<rotation+314 @0568fa>  : 10 0b                      dup.x32 sp(11)
	<rotation+316 @0568fc>  : 10 0e                      dup.x32 sp(14)
	<rotation+318 @0568fe>  : 73                         mul.f32
	<rotation+319 @0568ff>  : 10 0b                      dup.x32 sp(11)
	<rotation+321 @056901>  : 10 10                      dup.x32 sp(16)
	<rotation+323 @056903>  : 73                         mul.f32
	<rotation+324 @056904>  : 72                         sub.f32
	<rotation+325 @056905>  : 10 04                      dup.x32 sp(4)
	<rotation+327 @056907>  : 73                         mul.f32
	<rotation+328 @056908>  : 71                         add.f32
	<rotation+329 @056909>  : 13 18                      set.x32 sp(24)
	lib/std/math/Matrix4f.ci:140: (13 bytes: <@05690b> - <@056918>): void(.result.yx := float32(float32(xy * k) + float32(z * s)));
	<rotation+331 @05690b>  : 10 07                      dup.x32 sp(7)
	<rotation+333 @05690d>  : 10 01                      dup.x32 sp(1)
	<rotation+335 @05690f>  : 73                         mul.f32
	<rotation+336 @056910>  : 10 0d                      dup.x32 sp(13)
	<rotation+338 @056912>  : 10 04                      dup.x32 sp(4)
	<rotation+340 @056914>  : 73                         mul.f32
	<rotation+341 @056915>  : 71                         add.f32
	<rotation+342 @056916>  : 13 19                      set.x32 sp(25)
	lib/std/math/Matrix4f.ci:141: (13 bytes: <@056918> - <@056925>): void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
	<rotation+344 @056918>  : 10 05                      dup.x32 sp(5)
	<rotation+346 @05691a>  : 10 09                      dup.x32 sp(9)
	<rotation+348 @05691c>  : 10 05                      dup.x32 sp(5)
	<rotation+350 @05691e>  : 71                         add.f32
	<rotation+351 @05691f>  : 10 03                      dup.x32 sp(3)
	<rotation+353 @056921>  : 73                         mul.f32
	<rotation+354 @056922>  : 71                         add.f32
	<rotation+355 @056923>  : 13 1a                      set.x32 sp(26)
	lib/std/math/Matrix4f.ci:142: (13 bytes: <@056925> - <@056932>): void(.result.yz := float32(float32(yz * k) - float32(x * s)));
	<rotation+357 @056925>  : 10 04                      dup.x32 sp(4)
	<rotation+359 @056927>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @056929>  : 73                         mul.f32
	<rotation+362 @05692a>  : 10 0f                      dup.x32 sp(15)
	<rotation+364 @05692c>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @05692e>  : 73                         mul.f32
	<rotation+367 @05692f>  : 72                         sub.f32
	<rotation+368 @056930>  : 13 1b                      set.x32 sp(27)
	lib/std/math/Matrix4f.ci:143: (43 bytes: <@056932> - <@05695d>): void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
	<rotation+370 @056932>  : 10 0a                      dup.x32 sp(10)
	<rotation+372 @056934>  : 10 09                      dup.x32 sp(9)
	<rotation+374 @056936>  : 10 05                      dup.x32 sp(5)
	<rotation+376 @056938>  : 71                         add.f32
	<rotation+377 @056939>  : 73                         mul.f32
	<rotation+378 @05693a>  : 10 0e                      dup.x32 sp(14)
	<rotation+380 @05693c>  : 10 0d                      dup.x32 sp(13)
	<rotation+382 @05693e>  : 10 11                      dup.x32 sp(17)
	<rotation+384 @056940>  : 73                         mul.f32
	<rotation+385 @056941>  : 10 0c                      dup.x32 sp(12)
	<rotation+387 @056943>  : 10 10                      dup.x32 sp(16)
	<rotation+389 @056945>  : 73                         mul.f32
	<rotation+390 @056946>  : 71                         add.f32
	<rotation+391 @056947>  : 73                         mul.f32
	<rotation+392 @056948>  : 72                         sub.f32
	<rotation+393 @056949>  : 10 01                      dup.x32 sp(1)
	<rotation+395 @05694b>  : 73                         mul.f32
	<rotation+396 @05694c>  : 10 0a                      dup.x32 sp(10)
	<rotation+398 @05694e>  : 10 10                      dup.x32 sp(16)
	<rotation+400 @056950>  : 73                         mul.f32
	<rotation+401 @056951>  : 10 0d                      dup.x32 sp(13)
	<rotation+403 @056953>  : 10 0f                      dup.x32 sp(15)
	<rotation+405 @056955>  : 73                         mul.f32
	<rotation+406 @056956>  : 72                         sub.f32
	<rotation+407 @056957>  : 10 04                      dup.x32 sp(4)
	<rotation+409 @056959>  : 73                         mul.f32
	<rotation+410 @05695a>  : 71                         add.f32
	<rotation+411 @05695b>  : 13 1c                      set.x32 sp(28)
	lib/std/math/Matrix4f.ci:145: (13 bytes: <@05695d> - <@05696a>): void(.result.zx := float32(float32(xz * k) - float32(y * s)));
	<rotation+413 @05695d>  : 10 06                      dup.x32 sp(6)
	<rotation+415 @05695f>  : 10 01                      dup.x32 sp(1)
	<rotation+417 @056961>  : 73                         mul.f32
	<rotation+418 @056962>  : 10 0e                      dup.x32 sp(14)
	<rotation+420 @056964>  : 10 04                      dup.x32 sp(4)
	<rotation+422 @056966>  : 73                         mul.f32
	<rotation+423 @056967>  : 72                         sub.f32
	<rotation+424 @056968>  : 13 1d                      set.x32 sp(29)
	lib/std/math/Matrix4f.ci:146: (13 bytes: <@05696a> - <@056977>): void(.result.zy := float32(float32(yz * k) + float32(x * s)));
	<rotation+426 @05696a>  : 10 04                      dup.x32 sp(4)
	<rotation+428 @05696c>  : 10 01                      dup.x32 sp(1)
	<rotation+430 @05696e>  : 73                         mul.f32
	<rotation+431 @05696f>  : 10 0f                      dup.x32 sp(15)
	<rotation+433 @056971>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @056973>  : 73                         mul.f32
	<rotation+436 @056974>  : 71                         add.f32
	<rotation+437 @056975>  : 13 1e                      set.x32 sp(30)
	lib/std/math/Matrix4f.ci:147: (13 bytes: <@056977> - <@056984>): void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
	<rotation+439 @056977>  : 10 03                      dup.x32 sp(3)
	<rotation+441 @056979>  : 10 09                      dup.x32 sp(9)
	<rotation+443 @05697b>  : 10 07                      dup.x32 sp(7)
	<rotation+445 @05697d>  : 71                         add.f32
	<rotation+446 @05697e>  : 10 03                      dup.x32 sp(3)
	<rotation+448 @056980>  : 73                         mul.f32
	<rotation+449 @056981>  : 71                         add.f32
	<rotation+450 @056982>  : 13 1f                      set.x32 sp(31)
	lib/std/math/Matrix4f.ci:148: (43 bytes: <@056984> - <@0569af>): void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
	<rotation+452 @056984>  : 10 09                      dup.x32 sp(9)
	<rotation+454 @056986>  : 10 09                      dup.x32 sp(9)
	<rotation+456 @056988>  : 10 07                      dup.x32 sp(7)
	<rotation+458 @05698a>  : 71                         add.f32
	<rotation+459 @05698b>  : 73                         mul.f32
	<rotation+460 @05698c>  : 10 0d                      dup.x32 sp(13)
	<rotation+462 @05698e>  : 10 0d                      dup.x32 sp(13)
	<rotation+464 @056990>  : 10 11                      dup.x32 sp(17)
	<rotation+466 @056992>  : 73                         mul.f32
	<rotation+467 @056993>  : 10 0d                      dup.x32 sp(13)
	<rotation+469 @056995>  : 10 11                      dup.x32 sp(17)
	<rotation+471 @056997>  : 73                         mul.f32
	<rotation+472 @056998>  : 71                         add.f32
	<rotation+473 @056999>  : 73                         mul.f32
	<rotation+474 @05699a>  : 72                         sub.f32
	<rotation+475 @05699b>  : 10 01                      dup.x32 sp(1)
	<rotation+477 @05699d>  : 73                         mul.f32
	<rotation+478 @05699e>  : 10 0c                      dup.x32 sp(12)
	<rotation+480 @0569a0>  : 10 0f                      dup.x32 sp(15)
	<rotation+482 @0569a2>  : 73                         mul.f32
	<rotation+483 @0569a3>  : 10 0c                      dup.x32 sp(12)
	<rotation+485 @0569a5>  : 10 11                      dup.x32 sp(17)
	<rotation+487 @0569a7>  : 73                         mul.f32
	<rotation+488 @0569a8>  : 72                         sub.f32
	<rotation+489 @0569a9>  : 10 04                      dup.x32 sp(4)
	<rotation+491 @0569ab>  : 73                         mul.f32
	<rotation+492 @0569ac>  : 71                         add.f32
	<rotation+493 @0569ad>  : 13 20                      set.x32 sp(32)
	lib/std/math/Matrix4f.ci:150: (24 bytes: <@0569af> - <@0569c7>): void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
	<rotation+495 @0569af>  : 09 10 00 00                inc.sp(+16)
	<rotation+499 @0569b3>  : 19                         load.z32
	<rotation+500 @0569b4>  : 19                         load.z32
	<rotation+501 @0569b5>  : 19                         load.z32
	<rotation+502 @0569b6>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+507 @0569bb>  : 1f b8 65 05 00             load.ref <@0565b8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+512 @0569c0>  : 02                         call
	<rotation+513 @0569c1>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+517 @0569c5>  : 15 24                      set.x128 sp(36)
	<rotation+519 @0569c7>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+523 @0569cb>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:155: referenced as `rotation`
	lib/std/math/Matrix4f.ci:106: defined as `rotation(center: vec4f, direction: vec4f, angle: float32): mat4f`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:155'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
	lib/std/math/Matrix4f.ci:155: defined as `rotation(direction: vec4f, angle: float32): mat4f`
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 88
.offset: <@0569d0>
.name: 'translation'
.file: 'lib/std/math/Matrix4f.ci:158'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.x.x := (1));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := float32(direction.x * amount));
			void(.result.y.x := (0));
			void(.result.y.y := (1));
			void(.result.y.z := (0));
			void(.result.y.w := float32(direction.y * amount));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := (1));
			void(.result.z.w := float32(direction.z * amount));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
}
.instructions: (88 bytes: <@0569d0> - <@056a28>)
	lib/std/math/Matrix4f.ci:159: (88 bytes: <@0569d0> - <@056a28>): return void(.result := {...});
	<translation @0569d0>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @0569d5>    : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:160: (3 bytes: <@0569d7> - <@0569da>): void(.result.x.y := (0));
	<translation+7 @0569d7>    : 19                         load.z32
	<translation+8 @0569d8>    : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:160: (3 bytes: <@0569da> - <@0569dd>): void(.result.x.z := (0));
	<translation+10 @0569da>   : 19                         load.z32
	<translation+11 @0569db>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:160: (8 bytes: <@0569dd> - <@0569e5>): void(.result.x.w := float32(direction.x * amount));
	<translation+13 @0569dd>   : 10 02                      dup.x32 sp(2)
	<translation+15 @0569df>   : 22                         load.i32
	<translation+16 @0569e0>   : 10 02                      dup.x32 sp(2)
	<translation+18 @0569e2>   : 73                         mul.f32
	<translation+19 @0569e3>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:161: (3 bytes: <@0569e5> - <@0569e8>): void(.result.y.x := (0));
	<translation+21 @0569e5>   : 19                         load.z32
	<translation+22 @0569e6>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:161: (7 bytes: <@0569e8> - <@0569ef>): void(.result.y.y := (1));
	<translation+24 @0569e8>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @0569ed>   : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:161: (3 bytes: <@0569ef> - <@0569f2>): void(.result.y.z := (0));
	<translation+31 @0569ef>   : 19                         load.z32
	<translation+32 @0569f0>   : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:161: (12 bytes: <@0569f2> - <@0569fe>): void(.result.y.w := float32(direction.y * amount));
	<translation+34 @0569f2>   : 10 02                      dup.x32 sp(2)
	<translation+36 @0569f4>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @0569f8>   : 22                         load.i32
	<translation+41 @0569f9>   : 10 02                      dup.x32 sp(2)
	<translation+43 @0569fb>   : 73                         mul.f32
	<translation+44 @0569fc>   : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:162: (3 bytes: <@0569fe> - <@056a01>): void(.result.z.x := (0));
	<translation+46 @0569fe>   : 19                         load.z32
	<translation+47 @0569ff>   : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:162: (3 bytes: <@056a01> - <@056a04>): void(.result.z.y := (0));
	<translation+49 @056a01>   : 19                         load.z32
	<translation+50 @056a02>   : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:162: (7 bytes: <@056a04> - <@056a0b>): void(.result.z.z := (1));
	<translation+52 @056a04>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @056a09>   : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:162: (12 bytes: <@056a0b> - <@056a17>): void(.result.z.w := float32(direction.z * amount));
	<translation+59 @056a0b>   : 10 02                      dup.x32 sp(2)
	<translation+61 @056a0d>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @056a11>   : 22                         load.i32
	<translation+66 @056a12>   : 10 02                      dup.x32 sp(2)
	<translation+68 @056a14>   : 73                         mul.f32
	<translation+69 @056a15>   : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:163: (3 bytes: <@056a17> - <@056a1a>): void(.result.w.x := (0));
	<translation+71 @056a17>   : 19                         load.z32
	<translation+72 @056a18>   : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:163: (3 bytes: <@056a1a> - <@056a1d>): void(.result.w.y := (0));
	<translation+74 @056a1a>   : 19                         load.z32
	<translation+75 @056a1b>   : 13 11                      set.x32 sp(17)
	lib/std/math/Matrix4f.ci:163: (3 bytes: <@056a1d> - <@056a20>): void(.result.w.z := (0));
	<translation+77 @056a1d>   : 19                         load.z32
	<translation+78 @056a1e>   : 13 12                      set.x32 sp(18)
	lib/std/math/Matrix4f.ci:163: (7 bytes: <@056a20> - <@056a27>): void(.result.w.w := (1));
	<translation+80 @056a20>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @056a25>   : 13 13                      set.x32 sp(19)
	<translation+87 @056a27>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:158: defined as `translation(direction: vec4f, amount: float32): mat4f`
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 217
.offset: <@056a28>
.name: 'scale'
.file: 'lib/std/math/Matrix4f.ci:168'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.x.x := rcp(float32(direction.x * amount)));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := (0));
			void(.result.y.x := (0));
			void(.result.y.y := rcp(float32(direction.y * amount)));
			void(.result.y.z := (0));
			void(.result.y.w := (0));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := rcp(float32(direction.z * amount)));
			void(.result.z.w := (0));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
}
.instructions: (217 bytes: <@056a28> - <@056b01>)
	lib/std/math/Matrix4f.ci:170: (217 bytes: <@056a28> - <@056b01>): return void(.result := {...});
	<scale @056a28>      : 10 02                      dup.x32 sp(2)
	<scale+2 @056a2a>    : 22                         load.i32
	<scale+3 @056a2b>    : 10 02                      dup.x32 sp(2)
	<scale+5 @056a2d>    : 73                         mul.f32
	<scale+6 @056a2e>    : 10 00                      dup.x32 sp(0)
	<scale+8 @056a30>    : 19                         load.z32
	<scale+9 @056a31>    : 78                         clt.f32
	<scale+10 @056a32>   : 06 0b 00 00                jz <scale+21 @056a3d>
	<scale+14 @056a36>   : 10 00                      dup.x32 sp(0)
	<scale+16 @056a38>   : 70                         neg.f32
	<scale+17 @056a39>   : 04 06 00 00                jmp <scale+23 @056a3f>
	<scale+21 @056a3d>   : 10 00                      dup.x32 sp(0)
	<scale+23 @056a3f>   : 7d                         f32.2f64
	<scale+24 @056a40>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @056a49>   : 88                         clt.f64
	<scale+34 @056a4a>   : 06 09 00 00                jz <scale+43 @056a53>
	<scale+38 @056a4e>   : 19                         load.z32
	<scale+39 @056a4f>   : 04 0c 00 00                jmp <scale+51 @056a5b>
	<scale+43 @056a53>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @056a58>   : 10 01                      dup.x32 sp(1)
	<scale+50 @056a5a>   : 74                         div.f32
	<scale+51 @056a5b>   : 13 01                      set.x32 sp(1)
	<scale+53 @056a5d>   : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:171: (3 bytes: <@056a5f> - <@056a62>): void(.result.x.y := (0));
	<scale+55 @056a5f>   : 19                         load.z32
	<scale+56 @056a60>   : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:171: (3 bytes: <@056a62> - <@056a65>): void(.result.x.z := (0));
	<scale+58 @056a62>   : 19                         load.z32
	<scale+59 @056a63>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:171: (3 bytes: <@056a65> - <@056a68>): void(.result.x.w := (0));
	<scale+61 @056a65>   : 19                         load.z32
	<scale+62 @056a66>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:172: (3 bytes: <@056a68> - <@056a6b>): void(.result.y.x := (0));
	<scale+64 @056a68>   : 19                         load.z32
	<scale+65 @056a69>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:172: (59 bytes: <@056a6b> - <@056aa6>): void(.result.y.y := rcp(float32(direction.y * amount)));
	<scale+67 @056a6b>   : 10 02                      dup.x32 sp(2)
	<scale+69 @056a6d>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @056a71>   : 22                         load.i32
	<scale+74 @056a72>   : 10 02                      dup.x32 sp(2)
	<scale+76 @056a74>   : 73                         mul.f32
	<scale+77 @056a75>   : 10 00                      dup.x32 sp(0)
	<scale+79 @056a77>   : 19                         load.z32
	<scale+80 @056a78>   : 78                         clt.f32
	<scale+81 @056a79>   : 06 0b 00 00                jz <scale+92 @056a84>
	<scale+85 @056a7d>   : 10 00                      dup.x32 sp(0)
	<scale+87 @056a7f>   : 70                         neg.f32
	<scale+88 @056a80>   : 04 06 00 00                jmp <scale+94 @056a86>
	<scale+92 @056a84>   : 10 00                      dup.x32 sp(0)
	<scale+94 @056a86>   : 7d                         f32.2f64
	<scale+95 @056a87>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @056a90>  : 88                         clt.f64
	<scale+105 @056a91>  : 06 09 00 00                jz <scale+114 @056a9a>
	<scale+109 @056a95>  : 19                         load.z32
	<scale+110 @056a96>  : 04 0c 00 00                jmp <scale+122 @056aa2>
	<scale+114 @056a9a>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @056a9f>  : 10 01                      dup.x32 sp(1)
	<scale+121 @056aa1>  : 74                         div.f32
	<scale+122 @056aa2>  : 13 01                      set.x32 sp(1)
	<scale+124 @056aa4>  : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:172: (3 bytes: <@056aa6> - <@056aa9>): void(.result.y.z := (0));
	<scale+126 @056aa6>  : 19                         load.z32
	<scale+127 @056aa7>  : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:172: (3 bytes: <@056aa9> - <@056aac>): void(.result.y.w := (0));
	<scale+129 @056aa9>  : 19                         load.z32
	<scale+130 @056aaa>  : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:173: (3 bytes: <@056aac> - <@056aaf>): void(.result.z.x := (0));
	<scale+132 @056aac>  : 19                         load.z32
	<scale+133 @056aad>  : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:173: (3 bytes: <@056aaf> - <@056ab2>): void(.result.z.y := (0));
	<scale+135 @056aaf>  : 19                         load.z32
	<scale+136 @056ab0>  : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:173: (59 bytes: <@056ab2> - <@056aed>): void(.result.z.z := rcp(float32(direction.z * amount)));
	<scale+138 @056ab2>  : 10 02                      dup.x32 sp(2)
	<scale+140 @056ab4>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @056ab8>  : 22                         load.i32
	<scale+145 @056ab9>  : 10 02                      dup.x32 sp(2)
	<scale+147 @056abb>  : 73                         mul.f32
	<scale+148 @056abc>  : 10 00                      dup.x32 sp(0)
	<scale+150 @056abe>  : 19                         load.z32
	<scale+151 @056abf>  : 78                         clt.f32
	<scale+152 @056ac0>  : 06 0b 00 00                jz <scale+163 @056acb>
	<scale+156 @056ac4>  : 10 00                      dup.x32 sp(0)
	<scale+158 @056ac6>  : 70                         neg.f32
	<scale+159 @056ac7>  : 04 06 00 00                jmp <scale+165 @056acd>
	<scale+163 @056acb>  : 10 00                      dup.x32 sp(0)
	<scale+165 @056acd>  : 7d                         f32.2f64
	<scale+166 @056ace>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @056ad7>  : 88                         clt.f64
	<scale+176 @056ad8>  : 06 09 00 00                jz <scale+185 @056ae1>
	<scale+180 @056adc>  : 19                         load.z32
	<scale+181 @056add>  : 04 0c 00 00                jmp <scale+193 @056ae9>
	<scale+185 @056ae1>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @056ae6>  : 10 01                      dup.x32 sp(1)
	<scale+192 @056ae8>  : 74                         div.f32
	<scale+193 @056ae9>  : 13 01                      set.x32 sp(1)
	<scale+195 @056aeb>  : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:173: (3 bytes: <@056aed> - <@056af0>): void(.result.z.w := (0));
	<scale+197 @056aed>  : 19                         load.z32
	<scale+198 @056aee>  : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:174: (3 bytes: <@056af0> - <@056af3>): void(.result.w.x := (0));
	<scale+200 @056af0>  : 19                         load.z32
	<scale+201 @056af1>  : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:174: (3 bytes: <@056af3> - <@056af6>): void(.result.w.y := (0));
	<scale+203 @056af3>  : 19                         load.z32
	<scale+204 @056af4>  : 13 11                      set.x32 sp(17)
	lib/std/math/Matrix4f.ci:174: (3 bytes: <@056af6> - <@056af9>): void(.result.w.z := (0));
	<scale+206 @056af6>  : 19                         load.z32
	<scale+207 @056af7>  : 13 12                      set.x32 sp(18)
	lib/std/math/Matrix4f.ci:174: (7 bytes: <@056af9> - <@056b00>): void(.result.w.w := (1));
	<scale+209 @056af9>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @056afe>  : 13 13                      set.x32 sp(19)
	<scale+216 @056b00>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:168: defined as `scale(direction: vec4f, amount: float32): mat4f`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0281b8>
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:2'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:14: referenced as `vec2d`
	lib/std/math/Vector2d.ci:2: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Vector2d.ci:4'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/std/math/Vector2d.ci:4: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Vector2d.ci:26'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/std/math/Vector2d.ci:26: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `x`
	lib/std/math/Vector2d.ci:25: referenced as `x`
	lib/std/math/Vector2d.ci:16: referenced as `x`
	lib/std/math/Vector2d.ci:7: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `y`
	lib/std/math/Vector2d.ci:25: referenced as `y`
	lib/std/math/Vector2d.ci:17: referenced as `y`
	lib/std/math/Vector2d.ci:9: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@056b08>
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@056b08> - <@056b0f>)
	lib/std/math/Vector2d.ci:15: (7 bytes: <@056b08> - <@056b0f>): return void(.result := {...});
	<vec2d @056b08>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math/Vector2d.ci:17: (3 bytes: <@056b0b> - <@056b0e>): void(.result.y := y);
	<vec2d+3 @056b0b>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @056b0e>    : 03                         ret
.usages:
	lib/std/math/Vector2d.ci:14: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/std/math/Vector2d.ci:22: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'lib/std/math/Vector2d.ci:25'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/std/math/Vector2d.ci:25: defined as `dot(a: vec2d, b: vec2d): float64`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@056b10>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@056b10> - <@056b36>)
	lib/std/string.ci:5: (16 bytes: <@056b10> - <@056b20>): if (bool((str) == null))
	<length @056b10>      : 10 01                      dup.x32 sp(1)
	<length+2 @056b12>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @056b17>    : 57                         ceq.i32
	<length+8 @056b18>    : 06 08 00 00                jz <length+16 @056b20>
	lib/std/string.ci:6: (4 bytes: <@056b1c> - <@056b20>): return int32(.result := 0);
	<length+12 @056b1c>   : 19                         load.z32
	<length+13 @056b1d>   : 13 03                      set.x32 sp(3)
	<length+15 @056b1f>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@056b20> - <@056b21>): result: int32 := 0
	<length+16 @056b20>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@056b21> - <@056b33>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @056b21>   : 04 08 00 00                jmp <length+25 @056b29>
	lib/std/string.ci:9: (4 bytes: <@056b25> - <@056b29>): int32(result := int32(result + 1))
	<length+21 @056b25>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@056b29> - <@056b33>): str[result]
	<length+25 @056b29>   : 10 02                      dup.x32 sp(2)
	<length+27 @056b2b>   : 10 01                      dup.x32 sp(1)
	<length+29 @056b2d>   : 51                         add.i32
	<length+30 @056b2e>   : 20                         load.i8
	<length+31 @056b2f>   : 05 f6 ff ff                jnz <length+21 @056b25>
	lib/std/string.ci:11: (3 bytes: <@056b33> - <@056b36>): return int32(.result := result);
	<length+35 @056b33>   : 13 03                      set.x32 sp(3)
	<length+37 @056b35>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@056b38>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@056b38> - <@056b6a>)
	lib/std/string.ci:16: (42 bytes: <@056b38> - <@056b62>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @056b38>      : 19                         load.z32
	<indexOf+1 @056b39>    : 04 1b 00 00                jmp <indexOf+28 @056b54>
	lib/std/string.ci:17: (19 bytes: <@056b3d> - <@056b50>): if (bool(str[i] == chr))
	<indexOf+5 @056b3d>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @056b3f>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @056b41>    : 51                         add.i32
	<indexOf+10 @056b42>   : 20                         load.i8
	<indexOf+11 @056b43>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @056b47>   : 20                         load.i8
	<indexOf+16 @056b48>   : 57                         ceq.i32
	<indexOf+17 @056b49>   : 06 07 00 00                jz <indexOf+24 @056b50>
	lib/std/string.ci:18: (3 bytes: <@056b4d> - <@056b50>): return int32(.result := i);
	<indexOf+21 @056b4d>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @056b4f>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@056b50> - <@056b54>): int32(i := int32(i + 1))
	<indexOf+24 @056b50>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@056b54> - <@056b5e>): str[i]
	<indexOf+28 @056b54>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @056b56>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @056b58>   : 51                         add.i32
	<indexOf+33 @056b59>   : 20                         load.i8
	<indexOf+34 @056b5a>   : 05 e3 ff ff                jnz <indexOf+5 @056b3d>
	<indexOf+38 @056b5e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@056b62> - <@056b6a>): return int32(.result := int32(-1));
	<indexOf+42 @056b62>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @056b67>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @056b69>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@056b70>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@056b70> - <@056ba2>)
	lib/std/string.ci:26: (5 bytes: <@056b70> - <@056b75>): result: int32 := int32(-1)
	<lastIndexOf @056b70>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@056b75> - <@056b9f>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @056b75>    : 19                         load.z32
	<lastIndexOf+6 @056b76>    : 04 1b 00 00                jmp <lastIndexOf+33 @056b91>
	lib/std/string.ci:28: (19 bytes: <@056b7a> - <@056b8d>): if (bool(str[i] == chr))
	<lastIndexOf+10 @056b7a>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @056b7c>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @056b7e>   : 51                         add.i32
	<lastIndexOf+15 @056b7f>   : 20                         load.i8
	<lastIndexOf+16 @056b80>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @056b84>   : 20                         load.i8
	<lastIndexOf+21 @056b85>   : 57                         ceq.i32
	<lastIndexOf+22 @056b86>   : 06 07 00 00                jz <lastIndexOf+29 @056b8d>
	lib/std/string.ci:29: (3 bytes: <@056b8a> - <@056b8d>): int32(result := i);
	<lastIndexOf+26 @056b8a>   : 16 01 00                   mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@056b8d> - <@056b91>): int32(i := int32(i + 1))
	<lastIndexOf+29 @056b8d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@056b91> - <@056b9b>): str[i]
	<lastIndexOf+33 @056b91>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @056b93>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @056b95>   : 51                         add.i32
	<lastIndexOf+38 @056b96>   : 20                         load.i8
	<lastIndexOf+39 @056b97>   : 05 e3 ff ff                jnz <lastIndexOf+10 @056b7a>
	<lastIndexOf+43 @056b9b>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@056b9f> - <@056ba2>): return int32(.result := result);
	<lastIndexOf+47 @056b9f>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @056ba1>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@056ba8>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@056ba8> - <@056bf1>)
	lib/std/string.ci:37: (62 bytes: <@056ba8> - <@056be6>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @056ba8>      : 19                         load.z32
	<startsWith+1 @056ba9>    : 04 2d 00 00                jmp <startsWith+46 @056bd6>
	lib/std/string.ci:38: (37 bytes: <@056bad> - <@056bd2>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @056bad>    : 19                         load.z32
	<startsWith+6 @056bae>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @056bb0>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @056bb2>   : 51                         add.i32
	<startsWith+11 @056bb3>   : 20                         load.i8
	<startsWith+12 @056bb4>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @056bb6>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @056bb8>   : 51                         add.i32
	<startsWith+17 @056bb9>   : 20                         load.i8
	<startsWith+18 @056bba>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @056bbc>   : 02                         call
	<startsWith+21 @056bbd>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @056bc1>   : 19                         load.z32
	<startsWith+26 @056bc2>   : 57                         ceq.i32
	<startsWith+27 @056bc3>   : 05 0f 00 00                jnz <startsWith+42 @056bd2>
	lib/std/string.ci:39: (11 bytes: <@056bc7> - <@056bd2>): return bool(.result := false);
	<startsWith+31 @056bc7>   : 19                         load.z32
	<startsWith+32 @056bc8>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @056bcc>   : 25                         store.i8
	<startsWith+37 @056bcd>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @056bd1>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@056bd2> - <@056bd6>): int32(i := int32(i + 1))
	<startsWith+42 @056bd2>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@056bd6> - <@056be2>): bool((with[i]) != 0)
	<startsWith+46 @056bd6>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @056bd8>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @056bda>   : 51                         add.i32
	<startsWith+51 @056bdb>   : 20                         load.i8
	<startsWith+52 @056bdc>   : 19                         load.z32
	<startsWith+53 @056bdd>   : 57                         ceq.i32
	<startsWith+54 @056bde>   : 06 cf ff ff                jz <startsWith+5 @056bad>
	<startsWith+58 @056be2>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@056be6> - <@056bf1>): return bool(.result := true);
	<startsWith+62 @056be6>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @056beb>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @056bef>   : 25                         store.i8
	<startsWith+72 @056bf0>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@056bf8>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@056bf8> - <@056c76>)
	lib/std/string.ci:47: (13 bytes: <@056bf8> - <@056c05>): withLen: int32 := length(with)
	<endsWith @056bf8>      : 19                         load.z32
	<endsWith+1 @056bf9>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @056bfb>    : 1f 10 6b 05 00             load.ref <@056b10> ;length(str: char[*]): int32
	<endsWith+8 @056c00>    : 02                         call
	<endsWith+9 @056c01>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@056c05> - <@056c12>): strLen: int32 := length(str)
	<endsWith+13 @056c05>   : 19                         load.z32
	<endsWith+14 @056c06>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @056c08>   : 1f 10 6b 05 00             load.ref <@056b10> ;length(str: char[*]): int32
	<endsWith+21 @056c0d>   : 02                         call
	<endsWith+22 @056c0e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@056c12> - <@056c26>): if (bool(strLen < withLen))
	<endsWith+26 @056c12>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @056c14>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @056c16>   : 58                         clt.i32
	<endsWith+31 @056c17>   : 06 0f 00 00                jz <endsWith+46 @056c26>
	lib/std/string.ci:50: (11 bytes: <@056c1b> - <@056c26>): return bool(.result := false);
	<endsWith+35 @056c1b>   : 19                         load.z32
	<endsWith+36 @056c1c>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @056c20>   : 25                         store.i8
	<endsWith+41 @056c21>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @056c25>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@056c26> - <@056c67>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @056c26>   : 19                         load.z32
	<endsWith+47 @056c27>   : 04 33 00 00                jmp <endsWith+98 @056c5a>
	lib/std/string.ci:53: (43 bytes: <@056c2b> - <@056c56>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @056c2b>   : 19                         load.z32
	<endsWith+52 @056c2c>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @056c2e>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @056c30>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @056c32>   : 52                         sub.i32
	<endsWith+59 @056c33>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @056c35>   : 51                         add.i32
	<endsWith+62 @056c36>   : 51                         add.i32
	<endsWith+63 @056c37>   : 20                         load.i8
	<endsWith+64 @056c38>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @056c3a>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @056c3c>   : 51                         add.i32
	<endsWith+69 @056c3d>   : 20                         load.i8
	<endsWith+70 @056c3e>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @056c40>   : 02                         call
	<endsWith+73 @056c41>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @056c45>   : 19                         load.z32
	<endsWith+78 @056c46>   : 57                         ceq.i32
	<endsWith+79 @056c47>   : 05 0f 00 00                jnz <endsWith+94 @056c56>
	lib/std/string.ci:54: (11 bytes: <@056c4b> - <@056c56>): return bool(.result := false);
	<endsWith+83 @056c4b>   : 19                         load.z32
	<endsWith+84 @056c4c>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @056c50>   : 25                         store.i8
	<endsWith+89 @056c51>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @056c55>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@056c56> - <@056c5a>): int32(i := int32(i + 1))
	<endsWith+94 @056c56>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@056c5a> - <@056c63>): bool(i < withLen)
	<endsWith+98 @056c5a>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @056c5c>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @056c5e>  : 58                         clt.i32
	<endsWith+103 @056c5f>  : 05 cc ff ff                jnz <endsWith+51 @056c2b>
	<endsWith+107 @056c63>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@056c67> - <@056c76>): return bool(.result := true);
	<endsWith+111 @056c67>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @056c6c>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @056c70>  : 25                         store.i8
	<endsWith+121 @056c71>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @056c75>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@056c78>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@056c78> - <@056cb7>)
	lib/std/string.ci:62: (1 byte: <@056c78> - <@056c79>): result: int32 := 0
	<compare @056c78>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@056c79> - <@056cb4>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @056c79>    : 19                         load.z32
	<compare+2 @056c7a>    : 04 2e 00 00                jmp <compare+48 @056ca8>
	lib/std/string.ci:64: (22 bytes: <@056c7e> - <@056c94>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @056c7e>    : 19                         load.z32
	<compare+7 @056c7f>    : 10 06                      dup.x32 sp(6)
	<compare+9 @056c81>    : 10 02                      dup.x32 sp(2)
	<compare+11 @056c83>   : 51                         add.i32
	<compare+12 @056c84>   : 20                         load.i8
	<compare+13 @056c85>   : 10 06                      dup.x32 sp(6)
	<compare+15 @056c87>   : 10 03                      dup.x32 sp(3)
	<compare+17 @056c89>   : 51                         add.i32
	<compare+18 @056c8a>   : 20                         load.i8
	<compare+19 @056c8b>   : 10 06                      dup.x32 sp(6)
	<compare+21 @056c8d>   : 02                         call
	<compare+22 @056c8e>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @056c92>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes: <@056c94> - <@056ca4>): if (bool((str[i]) == 0))
	<compare+28 @056c94>   : 10 05                      dup.x32 sp(5)
	<compare+30 @056c96>   : 10 01                      dup.x32 sp(1)
	<compare+32 @056c98>   : 51                         add.i32
	<compare+33 @056c99>   : 20                         load.i8
	<compare+34 @056c9a>   : 19                         load.z32
	<compare+35 @056c9b>   : 57                         ceq.i32
	<compare+36 @056c9c>   : 06 08 00 00                jz <compare+44 @056ca4>
	lib/std/string.ci:66: (4 bytes: <@056ca0> - <@056ca4>): break;
	<compare+40 @056ca0>   : 04 10 00 00                jmp <compare+56 @056cb0>
	lib/std/string.ci:63: (4 bytes: <@056ca4> - <@056ca8>): int32(i := int32(i + 1))
	<compare+44 @056ca4>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@056ca8> - <@056cb0>): bool(result == 0)
	<compare+48 @056ca8>   : 10 01                      dup.x32 sp(1)
	<compare+50 @056caa>   : 19                         load.z32
	<compare+51 @056cab>   : 57                         ceq.i32
	<compare+52 @056cac>   : 05 d2 ff ff                jnz <compare+6 @056c7e>
	<compare+56 @056cb0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@056cb4> - <@056cb7>): return int32(.result := result);
	<compare+60 @056cb4>   : 13 05                      set.x32 sp(5)
	<compare+62 @056cb6>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@056d00>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@056d00> - <@056d24>)
	lib/std/string.ci:84: (36 bytes: <@056d00> - <@056d24>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @056d00>      : 19                         load.z32
	<ignCaseCmp+1 @056d01>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @056d05>    : 20                         load.i8
	<ignCaseCmp+6 @056d06>    : 1f b8 6c 05 00             load.ref <@056cb8> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @056d0b>   : 02                         call
	<ignCaseCmp+12 @056d0c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @056d10>   : 19                         load.z32
	<ignCaseCmp+17 @056d11>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @056d15>   : 20                         load.i8
	<ignCaseCmp+22 @056d16>   : 1f b8 6c 05 00             load.ref <@056cb8> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @056d1b>   : 02                         call
	<ignCaseCmp+28 @056d1c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @056d20>   : 52                         sub.i32
	<ignCaseCmp+33 @056d21>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @056d23>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@056d28>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@056d28> - <@056d36>)
	lib/std/string.ci:89: (14 bytes: <@056d28> - <@056d36>): return char(.result := char(chr - with));
	<caseCmp @056d28>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @056d2c>    : 20                         load.i8
	<caseCmp+5 @056d2d>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @056d31>    : 20                         load.i8
	<caseCmp+10 @056d32>   : 52                         sub.i32
	<caseCmp+11 @056d33>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @056d35>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:181: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02c688>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field showSign: bool (size: 1, offs: <+0>, cast: const variable(bool))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:262: referenced as `FormatFlags`
	lib/std/string.ci:258: referenced as `FormatFlags`
	lib/std/string.ci:240: referenced as `FormatFlags`
	lib/std/string.ci:234: referenced as `FormatFlags`
	lib/std/string.ci:233: referenced as `FormatFlags`
	lib/std/string.ci:230: referenced as `FormatFlags`
	lib/std/string.ci:228: referenced as `FormatFlags`
	lib/std/string.ci:226: referenced as `FormatFlags`
	lib/std/string.ci:224: referenced as `FormatFlags`
	lib/std/string.ci:222: referenced as `FormatFlags`
	lib/std/string.ci:220: referenced as `FormatFlags`
	lib/std/string.ci:218: referenced as `FormatFlags`
	lib/std/string.ci:216: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.offset: <+0>
.name: 'showSign'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	lib/std/string.ci:241: referenced as `showSign`
	lib/std/string.ci:235: referenced as `showSign`
	lib/std/string.ci:235: referenced as `showSign`
	lib/std/string.ci:150: referenced as `showSign`
	lib/std/string.ci:113: defined as `showSign`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	lib/std/string.ci:252: referenced as `precision`
	lib/std/string.ci:242: referenced as `precision`
	lib/std/string.ci:244: referenced as `precision`
	lib/std/string.ci:236: referenced as `precision`
	lib/std/string.ci:238: referenced as `precision`
	lib/std/string.ci:156: referenced as `precision`
	lib/std/string.ci:116: defined as `precision`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:243: referenced as `padChr`
	lib/std/string.ci:237: referenced as `padChr`
	lib/std/string.ci:237: referenced as `padChr`
	lib/std/string.ci:173: referenced as `padChr`
	lib/std/string.ci:119: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:244: referenced as `padLen`
	lib/std/string.ci:238: referenced as `padLen`
	lib/std/string.ci:238: referenced as `padLen`
	lib/std/string.ci:171: referenced as `padLen`
	lib/std/string.ci:122: defined as `padLen`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@056d38>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@056d38> - <@056d8c>)
	lib/std/string.ci:127: (56 bytes: <@056d38> - <@056d70>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @056d38>      : 19                         load.z32
	<append+1 @056d39>    : 04 29 00 00                jmp <append+42 @056d62>
	lib/std/string.ci:128: (13 bytes: <@056d3d> - <@056d4a>): if (bool(pos >= (output.length)))
	<append+5 @056d3d>    : 10 03                      dup.x32 sp(3)
	<append+7 @056d3f>    : 10 06                      dup.x32 sp(6)
	<append+9 @056d41>    : 58                         clt.i32
	<append+10 @056d42>   : 05 08 00 00                jnz <append+18 @056d4a>
	lib/std/string.ci:129: (4 bytes: <@056d46> - <@056d4a>): break;
	<append+14 @056d46>   : 04 26 00 00                jmp <append+52 @056d6c>
	lib/std/string.ci:131: (12 bytes: <@056d4a> - <@056d56>): char(output[pos] := value[i]);
	<append+18 @056d4a>   : 10 02                      dup.x32 sp(2)
	<append+20 @056d4c>   : 10 01                      dup.x32 sp(1)
	<append+22 @056d4e>   : 51                         add.i32
	<append+23 @056d4f>   : 20                         load.i8
	<append+24 @056d50>   : 10 05                      dup.x32 sp(5)
	<append+26 @056d52>   : 10 05                      dup.x32 sp(5)
	<append+28 @056d54>   : 51                         add.i32
	<append+29 @056d55>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@056d56> - <@056d5e>): int32(pos := int32(pos + 1));
	<append+30 @056d56>   : 10 03                      dup.x32 sp(3)
	<append+32 @056d58>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @056d5c>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:127: (4 bytes: <@056d5e> - <@056d62>): int32(i := int32(i + 1))
	<append+38 @056d5e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@056d62> - <@056d6c>): value[i]
	<append+42 @056d62>   : 10 02                      dup.x32 sp(2)
	<append+44 @056d64>   : 10 01                      dup.x32 sp(1)
	<append+46 @056d66>   : 51                         add.i32
	<append+47 @056d67>   : 20                         load.i8
	<append+48 @056d68>   : 05 d5 ff ff                jnz <append+5 @056d3d>
	<append+52 @056d6c>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@056d70> - <@056d81>): if (bool(pos >= (output.length)))
	<append+56 @056d70>   : 10 02                      dup.x32 sp(2)
	<append+58 @056d72>   : 10 05                      dup.x32 sp(5)
	<append+60 @056d74>   : 58                         clt.i32
	<append+61 @056d75>   : 05 0c 00 00                jnz <append+73 @056d81>
	lib/std/string.ci:136: (8 bytes: <@056d79> - <@056d81>): int32(pos := (uint32(output.length - (1))));
	<append+65 @056d79>   : 10 04                      dup.x32 sp(4)
	<append+67 @056d7b>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @056d7f>   : 13 03                      set.x32 sp(3)
	lib/std/string.ci:138: (7 bytes: <@056d81> - <@056d88>): char(output[pos] := (0));
	<append+73 @056d81>   : 19                         load.z32
	<append+74 @056d82>   : 10 04                      dup.x32 sp(4)
	<append+76 @056d84>   : 10 04                      dup.x32 sp(4)
	<append+78 @056d86>   : 51                         add.i32
	<append+79 @056d87>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@056d88> - <@056d8c>): return int32(.result := pos);
	<append+80 @056d88>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @056d8b>   : 03                         ret
.usages:
	lib/std/string.ci:251: referenced as `append`
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 707
.offset: <@056da0>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	if (format.showSign) {
		if (bool((sign) == 0)) {
			char(sign := '+');
		}
	}
	radix: int32 := format.precision;
	if (bool(radix == 0)) {
		int32(radix := 10);
	}
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (707 bytes: <@056da0> - <@057063>)
	lib/std/string.ci:147: (1 byte: <@056da0> - <@056da1>): len: int32 := 0
	<append @056da0>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@056da1> - <@056da5>): digits: char[80]
	<append+1 @056da1>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (28 bytes: <@056da5> - <@056dc1>): if (format.showSign)
	<append+5 @056da5>    : 10 16                      dup.x32 sp(22)
	<append+7 @056da7>    : 20                         load.i8
	<append+8 @056da8>    : 06 19 00 00                jz <append+33 @056dc1>
	lib/std/string.ci:151: (21 bytes: <@056dac> - <@056dc1>): if (bool((sign) == 0))
	<append+12 @056dac>   : 0a 64 00 00                load.sp(+100)
	<append+16 @056db0>   : 20                         load.i8
	<append+17 @056db1>   : 19                         load.z32
	<append+18 @056db2>   : 57                         ceq.i32
	<append+19 @056db3>   : 06 0e 00 00                jz <append+33 @056dc1>
	lib/std/string.ci:152: (10 bytes: <@056db7> - <@056dc1>): char(sign := '+');
	<append+23 @056db7>   : 1c 2b 00 00 00             load.c32 43
	<append+28 @056dbc>   : 0a 68 00 00                load.sp(+104)
	<append+32 @056dc0>   : 25                         store.i8
	lib/std/string.ci:156: (7 bytes: <@056dc1> - <@056dc8>): radix: int32 := format.precision
	<append+33 @056dc1>   : 10 16                      dup.x32 sp(22)
	<append+35 @056dc3>   : 0c 04 00 00                inc.i32(+4)
	<append+39 @056dc7>   : 22                         load.i32
	lib/std/string.ci:157: (15 bytes: <@056dc8> - <@056dd7>): if (bool(radix == 0))
	<append+40 @056dc8>   : 10 00                      dup.x32 sp(0)
	<append+42 @056dca>   : 19                         load.z32
	<append+43 @056dcb>   : 57                         ceq.i32
	<append+44 @056dcc>   : 06 0b 00 00                jz <append+55 @056dd7>
	lib/std/string.ci:158: (7 bytes: <@056dd0> - <@056dd7>): int32(radix := 10);
	<append+48 @056dd0>   : 1c 0a 00 00 00             load.c32 10
	<append+53 @056dd5>   : 13 01                      set.x32 sp(1)
	lib/std/string.ci:160: (54 bytes: <@056dd7> - <@056e0d>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+55 @056dd7>   : 10 00                      dup.x32 sp(0)
	<append+57 @056dd9>   : 1c 01 00 00 00             load.c32 1
	<append+62 @056dde>   : 59                         cgt.i32
	<append+63 @056ddf>   : 06 08 00 00                jz <append+71 @056de7>
	<append+67 @056de3>   : 04 2a 00 00                jmp <append+109 @056e0d>
	<append+71 @056de7>   : 1f 30 8e 02 00             load.ref <@028e30> ;"lib/std/string.ci"
	<append+76 @056dec>   : 1c a0 00 00 00             load.c32 160
	<append+81 @056df1>   : 1c fe ff ff ff             load.c32 -2
	<append+86 @056df6>   : 1c 80 00 00 00             load.c32 128
	<append+91 @056dfb>   : 1f c8 91 02 00             load.ref <@0291c8> ;"radix is too small"
	<append+96 @056e00>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+101 @056e05>  : 0a 18 00 00                load.sp(+24)
	<append+105 @056e09>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:161: (53 bytes: <@056e0d> - <@056e42>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+109 @056e0d>  : 10 00                      dup.x32 sp(0)
	<append+111 @056e0f>  : 2a 9c 6d 05                load.m32 <@056d9c> ;append.radixDigits+4
	<append+115 @056e13>  : 58                         clt.i32
	<append+116 @056e14>  : 06 08 00 00                jz <append+124 @056e1c>
	<append+120 @056e18>  : 04 2a 00 00                jmp <append+162 @056e42>
	<append+124 @056e1c>  : 1f 30 8e 02 00             load.ref <@028e30> ;"lib/std/string.ci"
	<append+129 @056e21>  : 1c a1 00 00 00             load.c32 161
	<append+134 @056e26>  : 1c fe ff ff ff             load.c32 -2
	<append+139 @056e2b>  : 1c 80 00 00 00             load.c32 128
	<append+144 @056e30>  : 1f db 91 02 00             load.ref <@0291db> ;"radix is too big"
	<append+149 @056e35>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+154 @056e3a>  : 0a 18 00 00                load.sp(+24)
	<append+158 @056e3e>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:164: (49 bytes: <@056e42> - <@056e73>): for ( ; bool(value > (0)); uint64(value := uint64(value / (radix))))
	<append+162 @056e42>  : 04 29 00 00                jmp <append+203 @056e6b>
	lib/std/string.ci:165: (29 bytes: <@056e46> - <@056e63>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	<append+166 @056e46>  : 2a 98 6d 05                load.m32 <@056d98> ;append.radixDigits
	<append+170 @056e4a>  : 11 19                      dup.x64 sp(25)
	<append+172 @056e4c>  : 10 03                      dup.x32 sp(3)
	<append+174 @056e4e>  : 5b                         i32.2i64
	<append+175 @056e4f>  : 45                         mod.u64
	<append+176 @056e50>  : 6a                         i64.2i32
	<append+177 @056e51>  : 51                         add.i32
	<append+178 @056e52>  : 20                         load.i8
	<append+179 @056e53>  : 0a 08 00 00                load.sp(+8)
	<append+183 @056e57>  : 10 17                      dup.x32 sp(23)
	<append+185 @056e59>  : 0c 01 00 00                inc.i32(+1)
	<append+189 @056e5d>  : 10 00                      dup.x32 sp(0)
	<append+191 @056e5f>  : 13 19                      set.x32 sp(25)
	<append+193 @056e61>  : 51                         add.i32
	<append+194 @056e62>  : 25                         store.i8
	lib/std/string.ci:164: (8 bytes: <@056e63> - <@056e6b>): uint64(value := uint64(value / (radix)))
	<append+195 @056e63>  : 11 18                      dup.x64 sp(24)
	<append+197 @056e65>  : 10 02                      dup.x32 sp(2)
	<append+199 @056e67>  : 5b                         i32.2i64
	<append+200 @056e68>  : 44                         div.u64
	<append+201 @056e69>  : 14 1a                      set.x64 sp(26)
	lib/std/string.ci:164: (8 bytes: <@056e6b> - <@056e73>): bool(value > (0))
	<append+203 @056e6b>  : 11 18                      dup.x64 sp(24)
	<append+205 @056e6d>  : 1a                         load.z64
	<append+206 @056e6e>  : 49                         cgt.u64
	<append+207 @056e6f>  : 05 d7 ff ff                jnz <append+166 @056e46>
	lib/std/string.ci:167: (29 bytes: <@056e73> - <@056e90>): if (bool(len == 0))
	<append+211 @056e73>  : 10 15                      dup.x32 sp(21)
	<append+213 @056e75>  : 19                         load.z32
	<append+214 @056e76>  : 57                         ceq.i32
	<append+215 @056e77>  : 06 19 00 00                jz <append+240 @056e90>
	lib/std/string.ci:168: (21 bytes: <@056e7b> - <@056e90>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+219 @056e7b>  : 1c 30 00 00 00             load.c32 48
	<append+224 @056e80>  : 0a 08 00 00                load.sp(+8)
	<append+228 @056e84>  : 10 17                      dup.x32 sp(23)
	<append+230 @056e86>  : 0c 01 00 00                inc.i32(+1)
	<append+234 @056e8a>  : 10 00                      dup.x32 sp(0)
	<append+236 @056e8c>  : 13 19                      set.x32 sp(25)
	<append+238 @056e8e>  : 51                         add.i32
	<append+239 @056e8f>  : 25                         store.i8
	lib/std/string.ci:171: (10 bytes: <@056e90> - <@056e9a>): maxLen: int32 := int32(format.padLen - len)
	<append+240 @056e90>  : 10 17                      dup.x32 sp(23)
	<append+242 @056e92>  : 0c 0c 00 00                inc.i32(+12)
	<append+246 @056e96>  : 22                         load.i32
	<append+247 @056e97>  : 10 16                      dup.x32 sp(22)
	<append+249 @056e99>  : 52                         sub.i32
	lib/std/string.ci:173: (7 bytes: <@056e9a> - <@056ea1>): padChr: char := format.padChr
	<append+250 @056e9a>  : 10 18                      dup.x32 sp(24)
	<append+252 @056e9c>  : 0c 08 00 00                inc.i32(+8)
	<append+256 @056ea0>  : 20                         load.i8
	lib/std/string.ci:174: (21 bytes: <@056ea1> - <@056eb6>): if (bool(padChr == ''))
	<append+257 @056ea1>  : 0a 00 00 00                load.sp(+0)
	<append+261 @056ea5>  : 20                         load.i8
	<append+262 @056ea6>  : 19                         load.z32
	<append+263 @056ea7>  : 57                         ceq.i32
	<append+264 @056ea8>  : 06 0e 00 00                jz <append+278 @056eb6>
	lib/std/string.ci:175: (10 bytes: <@056eac> - <@056eb6>): char(padChr := ' ');
	<append+268 @056eac>  : 1c 20 00 00 00             load.c32 32
	<append+273 @056eb1>  : 0a 04 00 00                load.sp(+4)
	<append+277 @056eb5>  : 25                         store.i8
	lib/std/string.ci:179: (207 bytes: <@056eb6> - <@056f85>): if (bool((sign) != 0))
	<append+278 @056eb6>  : 0a 70 00 00                load.sp(+112)
	<append+282 @056eba>  : 20                         load.i8
	<append+283 @056ebb>  : 19                         load.z32
	<append+284 @056ebc>  : 57                         ceq.i32
	<append+285 @056ebd>  : 05 c8 00 00                jnz <append+485 @056f85>
	lib/std/string.ci:180: (8 bytes: <@056ec1> - <@056ec9>): int32(maxLen := int32(maxLen - 1));
	<append+289 @056ec1>  : 10 01                      dup.x32 sp(1)
	<append+291 @056ec3>  : 0c ff ff ff                inc.i32(-1)
	<append+295 @056ec7>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:181: (117 bytes: <@056ec9> - <@056f3e>): if (contains(void(whiteSpace, padChr)))
	<append+297 @056ec9>  : 19                         load.z32
	<append+298 @056eca>  : 2a 90 6d 05                load.m32 <@056d90> ;append.whiteSpace
	<append+302 @056ece>  : 0a 08 00 00                load.sp(+8)
	<append+306 @056ed2>  : 20                         load.i8
	<append+307 @056ed3>  : 1f 38 6b 05 00             load.ref <@056b38> ;indexOf(str: char[*], chr: char): int32
	<append+312 @056ed8>  : 02                         call
	<append+313 @056ed9>  : 09 f8 ff ff                inc.sp(-8)
	<append+317 @056edd>  : 19                         load.z32
	<append+318 @056ede>  : 58                         clt.i32
	<append+319 @056edf>  : 05 5f 00 00                jnz <append+414 @056f3e>
	lib/std/string.ci:183: (91 bytes: <@056ee3> - <@056f3e>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+323 @056ee3>  : 04 53 00 00                jmp <append+406 @056f36>
	lib/std/string.ci:184: (52 bytes: <@056ee7> - <@056f1b>): assert(bool(pos < (output.length)));
	<append+327 @056ee7>  : 10 1d                      dup.x32 sp(29)
	<append+329 @056ee9>  : 10 20                      dup.x32 sp(32)
	<append+331 @056eeb>  : 58                         clt.i32
	<append+332 @056eec>  : 06 08 00 00                jz <append+340 @056ef4>
	<append+336 @056ef0>  : 04 2b 00 00                jmp <append+379 @056f1b>
	<append+340 @056ef4>  : 1f 30 8e 02 00             load.ref <@028e30> ;"lib/std/string.ci"
	<append+345 @056ef9>  : 1c b8 00 00 00             load.c32 184
	<append+350 @056efe>  : 1c fe ff ff ff             load.c32 -2
	<append+355 @056f03>  : 1c 80 00 00 00             load.c32 128
	<append+360 @056f08>  : 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<append+365 @056f0d>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+370 @056f12>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+375 @056f17>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:185: (11 bytes: <@056f1b> - <@056f26>): char(output[pos] := padChr);
	<append+379 @056f1b>  : 0a 00 00 00                load.sp(+0)
	<append+383 @056f1f>  : 20                         load.i8
	<append+384 @056f20>  : 10 1f                      dup.x32 sp(31)
	<append+386 @056f22>  : 10 1f                      dup.x32 sp(31)
	<append+388 @056f24>  : 51                         add.i32
	<append+389 @056f25>  : 25                         store.i8
	lib/std/string.ci:186: (8 bytes: <@056f26> - <@056f2e>): int32(pos := int32(pos + 1));
	<append+390 @056f26>  : 10 1d                      dup.x32 sp(29)
	<append+392 @056f28>  : 0c 01 00 00                inc.i32(+1)
	<append+396 @056f2c>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:183: (8 bytes: <@056f2e> - <@056f36>): int32(maxLen := int32(maxLen - 1))
	<append+398 @056f2e>  : 10 01                      dup.x32 sp(1)
	<append+400 @056f30>  : 0c ff ff ff                inc.i32(-1)
	<append+404 @056f34>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:183: (8 bytes: <@056f36> - <@056f3e>): bool(maxLen > 0)
	<append+406 @056f36>  : 10 01                      dup.x32 sp(1)
	<append+408 @056f38>  : 19                         load.z32
	<append+409 @056f39>  : 59                         cgt.i32
	<append+410 @056f3a>  : 05 ad ff ff                jnz <append+327 @056ee7>
	lib/std/string.ci:189: (52 bytes: <@056f3e> - <@056f72>): assert(bool(pos < (output.length)));
	<append+414 @056f3e>  : 10 1d                      dup.x32 sp(29)
	<append+416 @056f40>  : 10 20                      dup.x32 sp(32)
	<append+418 @056f42>  : 58                         clt.i32
	<append+419 @056f43>  : 06 08 00 00                jz <append+427 @056f4b>
	<append+423 @056f47>  : 04 2b 00 00                jmp <append+466 @056f72>
	<append+427 @056f4b>  : 1f 30 8e 02 00             load.ref <@028e30> ;"lib/std/string.ci"
	<append+432 @056f50>  : 1c bd 00 00 00             load.c32 189
	<append+437 @056f55>  : 1c fe ff ff ff             load.c32 -2
	<append+442 @056f5a>  : 1c 80 00 00 00             load.c32 128
	<append+447 @056f5f>  : 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<append+452 @056f64>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+457 @056f69>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+462 @056f6e>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:190: (11 bytes: <@056f72> - <@056f7d>): char(output[pos] := sign);
	<append+466 @056f72>  : 0a 70 00 00                load.sp(+112)
	<append+470 @056f76>  : 20                         load.i8
	<append+471 @056f77>  : 10 1f                      dup.x32 sp(31)
	<append+473 @056f79>  : 10 1f                      dup.x32 sp(31)
	<append+475 @056f7b>  : 51                         add.i32
	<append+476 @056f7c>  : 25                         store.i8
	lib/std/string.ci:191: (8 bytes: <@056f7d> - <@056f85>): int32(pos := int32(pos + 1));
	<append+477 @056f7d>  : 10 1d                      dup.x32 sp(29)
	<append+479 @056f7f>  : 0c 01 00 00                inc.i32(+1)
	<append+483 @056f83>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:195: (91 bytes: <@056f85> - <@056fe0>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+485 @056f85>  : 04 53 00 00                jmp <append+568 @056fd8>
	lib/std/string.ci:196: (52 bytes: <@056f89> - <@056fbd>): assert(bool(pos < (output.length)));
	<append+489 @056f89>  : 10 1d                      dup.x32 sp(29)
	<append+491 @056f8b>  : 10 20                      dup.x32 sp(32)
	<append+493 @056f8d>  : 58                         clt.i32
	<append+494 @056f8e>  : 06 08 00 00                jz <append+502 @056f96>
	<append+498 @056f92>  : 04 2b 00 00                jmp <append+541 @056fbd>
	<append+502 @056f96>  : 1f 30 8e 02 00             load.ref <@028e30> ;"lib/std/string.ci"
	<append+507 @056f9b>  : 1c c4 00 00 00             load.c32 196
	<append+512 @056fa0>  : 1c fe ff ff ff             load.c32 -2
	<append+517 @056fa5>  : 1c 80 00 00 00             load.c32 128
	<append+522 @056faa>  : 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<append+527 @056faf>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+532 @056fb4>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+537 @056fb9>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:197: (11 bytes: <@056fbd> - <@056fc8>): char(output[pos] := padChr);
	<append+541 @056fbd>  : 0a 00 00 00                load.sp(+0)
	<append+545 @056fc1>  : 20                         load.i8
	<append+546 @056fc2>  : 10 1f                      dup.x32 sp(31)
	<append+548 @056fc4>  : 10 1f                      dup.x32 sp(31)
	<append+550 @056fc6>  : 51                         add.i32
	<append+551 @056fc7>  : 25                         store.i8
	lib/std/string.ci:198: (8 bytes: <@056fc8> - <@056fd0>): int32(pos := int32(pos + 1));
	<append+552 @056fc8>  : 10 1d                      dup.x32 sp(29)
	<append+554 @056fca>  : 0c 01 00 00                inc.i32(+1)
	<append+558 @056fce>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:195: (8 bytes: <@056fd0> - <@056fd8>): int32(maxLen := int32(maxLen - 1))
	<append+560 @056fd0>  : 10 01                      dup.x32 sp(1)
	<append+562 @056fd2>  : 0c ff ff ff                inc.i32(-1)
	<append+566 @056fd6>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:195: (8 bytes: <@056fd8> - <@056fe0>): bool(maxLen > 0)
	<append+568 @056fd8>  : 10 01                      dup.x32 sp(1)
	<append+570 @056fda>  : 19                         load.z32
	<append+571 @056fdb>  : 59                         cgt.i32
	<append+572 @056fdc>  : 05 ad ff ff                jnz <append+489 @056f89>
	lib/std/string.ci:202: (99 bytes: <@056fe0> - <@057043>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+576 @056fe0>  : 19                         load.z32
	<append+577 @056fe1>  : 04 55 00 00                jmp <append+662 @057036>
	lib/std/string.ci:203: (52 bytes: <@056fe5> - <@057019>): assert(bool(i < (output.length)));
	<append+581 @056fe5>  : 10 00                      dup.x32 sp(0)
	<append+583 @056fe7>  : 10 21                      dup.x32 sp(33)
	<append+585 @056fe9>  : 58                         clt.i32
	<append+586 @056fea>  : 06 08 00 00                jz <append+594 @056ff2>
	<append+590 @056fee>  : 04 2b 00 00                jmp <append+633 @057019>
	<append+594 @056ff2>  : 1f 30 8e 02 00             load.ref <@028e30> ;"lib/std/string.ci"
	<append+599 @056ff7>  : 1c cb 00 00 00             load.c32 203
	<append+604 @056ffc>  : 1c fe ff ff ff             load.c32 -2
	<append+609 @057001>  : 1c 80 00 00 00             load.c32 128
	<append+614 @057006>  : 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<append+619 @05700b>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+624 @057010>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+629 @057015>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:204: (17 bytes: <@057019> - <@05702a>): char(output[pos] := digits[int32(len - i)]);
	<append+633 @057019>  : 0a 10 00 00                load.sp(+16)
	<append+637 @05701d>  : 10 19                      dup.x32 sp(25)
	<append+639 @05701f>  : 10 02                      dup.x32 sp(2)
	<append+641 @057021>  : 52                         sub.i32
	<append+642 @057022>  : 51                         add.i32
	<append+643 @057023>  : 20                         load.i8
	<append+644 @057024>  : 10 20                      dup.x32 sp(32)
	<append+646 @057026>  : 10 20                      dup.x32 sp(32)
	<append+648 @057028>  : 51                         add.i32
	<append+649 @057029>  : 25                         store.i8
	lib/std/string.ci:205: (8 bytes: <@05702a> - <@057032>): int32(pos := int32(pos + 1));
	<append+650 @05702a>  : 10 1e                      dup.x32 sp(30)
	<append+652 @05702c>  : 0c 01 00 00                inc.i32(+1)
	<append+656 @057030>  : 13 1f                      set.x32 sp(31)
	lib/std/string.ci:202: (4 bytes: <@057032> - <@057036>): int32(i := int32(i + 1))
	<append+658 @057032>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:202: (9 bytes: <@057036> - <@05703f>): bool(i < len)
	<append+662 @057036>  : 10 00                      dup.x32 sp(0)
	<append+664 @057038>  : 10 19                      dup.x32 sp(25)
	<append+666 @05703a>  : 58                         clt.i32
	<append+667 @05703b>  : 05 aa ff ff                jnz <append+581 @056fe5>
	<append+671 @05703f>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:208: (17 bytes: <@057043> - <@057054>): if (bool(pos >= (output.length)))
	<append+675 @057043>  : 10 1d                      dup.x32 sp(29)
	<append+677 @057045>  : 10 20                      dup.x32 sp(32)
	<append+679 @057047>  : 58                         clt.i32
	<append+680 @057048>  : 05 0c 00 00                jnz <append+692 @057054>
	lib/std/string.ci:209: (8 bytes: <@05704c> - <@057054>): int32(pos := (uint32(output.length - (1))));
	<append+684 @05704c>  : 10 1f                      dup.x32 sp(31)
	<append+686 @05704e>  : 0c ff ff ff                inc.i32(-1)
	<append+690 @057052>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:211: (7 bytes: <@057054> - <@05705b>): char(output[pos] := (0));
	<append+692 @057054>  : 19                         load.z32
	<append+693 @057055>  : 10 1f                      dup.x32 sp(31)
	<append+695 @057057>  : 10 1f                      dup.x32 sp(31)
	<append+697 @057059>  : 51                         add.i32
	<append+698 @05705a>  : 25                         store.i8
	lib/std/string.ci:212: (8 bytes: <@05705b> - <@057063>): return int32(.result := pos);
	<append+699 @05705b>  : 16 20 1d                   mov.x32 sp(32, 29)
	<append+702 @05705e>  : 09 a0 ff ff                inc.sp(-96)
	<append+706 @057062>  : 03                         ret
.usages:
	lib/std/string.ci:253: referenced as `append`
	lib/std/string.ci:249: referenced as `append`
	lib/std/string.ci:230: referenced as `append`
	lib/std/string.ci:228: referenced as `append`
	lib/std/string.ci:226: referenced as `append`
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:222: referenced as `append`
	lib/std/string.ci:220: referenced as `append`
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:216: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:216'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:216: defined as `append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:218'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:218: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:220'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:220: defined as `append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:224'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format))
.usages:
	lib/std/string.ci:224: defined as `append(output: char[], pos: int32, value: int64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:226'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format))
.usages:
	lib/std/string.ci:263: referenced as `append`
	lib/std/string.ci:226: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:228'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format))
.usages:
	lib/std/string.ci:228: defined as `append(output: char[], pos: int32, value: int16, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:230'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format))
.usages:
	lib/std/string.ci:230: defined as `append(output: char[], pos: int32, value: int8, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 227
.offset: <@057068>
.name: 'append'
.file: 'lib/std/string.ci:233'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		void(formatInt.showSign := format.showSign);
		void(formatInt.precision := 0);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(format.padLen - format.precision));
	};
	formatDec: FormatFlags := {
		void(formatDec.showSign := false);
		void(formatDec.precision := 0);
		void(formatDec.padChr := '0');
		void(formatDec.padLen := format.precision);
	};
	sign: char := bool(value < (0)) ? ('-') : 0;
	fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(void(pos, sign), uint64(value)), formatInt))));
	int32(pos := append(void(output, void(pos, "."))));
	float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	int32(pos := append(void(output, void(void(void(pos, 0), uint64(fract)), formatDec))));
	return int32(.result := pos);
}
.instructions: (227 bytes: <@057068> - <@05714b>)
	lib/std/string.ci:234: (44 bytes: <@057068> - <@057094>): formatInt: FormatFlags := {...}
	<append @057068>      : 09 10 00 00                inc.sp(+16)
	lib/std/string.ci:235: (8 bytes: <@05706c> - <@057074>): void(formatInt.showSign := format.showSign);
	<append+4 @05706c>    : 10 05                      dup.x32 sp(5)
	<append+6 @05706e>    : 20                         load.i8
	<append+7 @05706f>    : 0a 04 00 00                load.sp(+4)
	<append+11 @057073>   : 25                         store.i8
	lib/std/string.ci:236: (3 bytes: <@057074> - <@057077>): void(formatInt.precision := 0);
	<append+12 @057074>   : 19                         load.z32
	<append+13 @057075>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:237: (12 bytes: <@057077> - <@057083>): void(formatInt.padChr := format.padChr);
	<append+15 @057077>   : 10 05                      dup.x32 sp(5)
	<append+17 @057079>   : 0c 08 00 00                inc.i32(+8)
	<append+21 @05707d>   : 20                         load.i8
	<append+22 @05707e>   : 0a 0c 00 00                load.sp(+12)
	<append+26 @057082>   : 25                         store.i8
	lib/std/string.ci:238: (17 bytes: <@057083> - <@057094>): void(formatInt.padLen := int32(format.padLen - format.precision));
	<append+27 @057083>   : 10 05                      dup.x32 sp(5)
	<append+29 @057085>   : 0c 0c 00 00                inc.i32(+12)
	<append+33 @057089>   : 22                         load.i32
	<append+34 @05708a>   : 10 06                      dup.x32 sp(6)
	<append+36 @05708c>   : 0c 04 00 00                inc.i32(+4)
	<append+40 @057090>   : 22                         load.i32
	<append+41 @057091>   : 52                         sub.i32
	<append+42 @057092>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:240: (32 bytes: <@057094> - <@0570b4>): formatDec: FormatFlags := {...}
	<append+44 @057094>   : 09 10 00 00                inc.sp(+16)
	lib/std/string.ci:241: (6 bytes: <@057098> - <@05709e>): void(formatDec.showSign := false);
	<append+48 @057098>   : 19                         load.z32
	<append+49 @057099>   : 0a 04 00 00                load.sp(+4)
	<append+53 @05709d>   : 25                         store.i8
	lib/std/string.ci:242: (3 bytes: <@05709e> - <@0570a1>): void(formatDec.precision := 0);
	<append+54 @05709e>   : 19                         load.z32
	<append+55 @05709f>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:243: (10 bytes: <@0570a1> - <@0570ab>): void(formatDec.padChr := '0');
	<append+57 @0570a1>   : 1c 30 00 00 00             load.c32 48
	<append+62 @0570a6>   : 0a 0c 00 00                load.sp(+12)
	<append+66 @0570aa>   : 25                         store.i8
	lib/std/string.ci:244: (9 bytes: <@0570ab> - <@0570b4>): void(formatDec.padLen := format.precision);
	<append+67 @0570ab>   : 10 09                      dup.x32 sp(9)
	<append+69 @0570ad>   : 0c 04 00 00                inc.i32(+4)
	<append+73 @0570b1>   : 22                         load.i32
	<append+74 @0570b2>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:247: (18 bytes: <@0570b4> - <@0570c6>): sign: char := bool(value < (0)) ? ('-') : 0
	<append+76 @0570b4>   : 11 0a                      dup.x64 sp(10)
	<append+78 @0570b6>   : 1a                         load.z64
	<append+79 @0570b7>   : 88                         clt.f64
	<append+80 @0570b8>   : 06 0d 00 00                jz <append+93 @0570c5>
	<append+84 @0570bc>   : 1c 2d 00 00 00             load.c32 45
	<append+89 @0570c1>   : 04 05 00 00                jmp <append+94 @0570c6>
	<append+93 @0570c5>   : 19                         load.z32
	lib/std/string.ci:248: (27 bytes: <@0570c6> - <@0570e1>): fract: float64 := Math.modf(void(Math.abs(value), float64(&value)))
	<append+94 @0570c6>   : 1b                         load.z128
	<append+95 @0570c7>   : 11 0f                      dup.x64 sp(15)
	<append+97 @0570c9>   : 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<append+102 @0570ce>  : 02                         call
	<append+103 @0570cf>  : 09 f8 ff ff                inc.sp(-8)
	<append+107 @0570d3>  : 0a 3c 00 00                load.sp(+60)
	<append+111 @0570d7>  : 1f e0 5c 05 00             load.ref <@055ce0> ;Math.modf(x: float64, intPart: float64): float64
	<append+116 @0570dc>  : 02                         call
	<append+117 @0570dd>  : 09 f4 ff ff                inc.sp(-12)
	lib/std/string.ci:249: (29 bytes: <@0570e1> - <@0570fe>): int32(pos := append(void(output, void(void(void(pos, sign), uint64(value)), formatInt))));
	<append+121 @0570e1>  : 19                         load.z32
	<append+122 @0570e2>  : 11 11                      dup.x64 sp(17)
	<append+124 @0570e4>  : 10 12                      dup.x32 sp(18)
	<append+126 @0570e6>  : 0a 18 00 00                load.sp(+24)
	<append+130 @0570ea>  : 20                         load.i8
	<append+131 @0570eb>  : 11 12                      dup.x64 sp(18)
	<append+133 @0570ed>  : 8b                         f64.2i64
	<append+134 @0570ee>  : 0a 38 00 00                load.sp(+56)
	<append+138 @0570f2>  : 1f a0 6d 05 00             load.ref <@056da0> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+143 @0570f7>  : 02                         call
	<append+144 @0570f8>  : 09 e4 ff ff                inc.sp(-28)
	<append+148 @0570fc>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:251: (22 bytes: <@0570fe> - <@057114>): int32(pos := append(void(output, void(pos, "."))));
	<append+150 @0570fe>  : 19                         load.z32
	<append+151 @0570ff>  : 11 11                      dup.x64 sp(17)
	<append+153 @057101>  : 10 12                      dup.x32 sp(18)
	<append+155 @057103>  : 1f 41 92 02 00             load.ref <@029241> ;"."
	<append+160 @057108>  : 1f 38 6d 05 00             load.ref <@056d38> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+165 @05710d>  : 02                         call
	<append+166 @05710e>  : 09 f0 ff ff                inc.sp(-16)
	<append+170 @057112>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:252: (22 bytes: <@057114> - <@05712a>): float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	<append+172 @057114>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+181 @05711d>  : 10 0e                      dup.x32 sp(14)
	<append+183 @05711f>  : 0c 04 00 00                inc.i32(+4)
	<append+187 @057123>  : 22                         load.i32
	<append+188 @057124>  : 5d                         i32.2f64
	<append+189 @057125>  : 01 2d 00 00                nfc(45) ;float64.pow(x: float64, y: float64): float64
	<append+193 @057129>  : 83                         mul.f64
	lib/std/string.ci:253: (25 bytes: <@05712a> - <@057143>): int32(pos := append(void(output, void(void(void(pos, 0), uint64(fract)), formatDec))));
	<append+194 @05712a>  : 19                         load.z32
	<append+195 @05712b>  : 11 11                      dup.x64 sp(17)
	<append+197 @05712d>  : 10 12                      dup.x32 sp(18)
	<append+199 @05712f>  : 19                         load.z32
	<append+200 @057130>  : 11 05                      dup.x64 sp(5)
	<append+202 @057132>  : 8b                         f64.2i64
	<append+203 @057133>  : 0a 28 00 00                load.sp(+40)
	<append+207 @057137>  : 1f a0 6d 05 00             load.ref <@056da0> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+212 @05713c>  : 02                         call
	<append+213 @05713d>  : 09 e4 ff ff                inc.sp(-28)
	<append+217 @057141>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:254: (8 bytes: <@057143> - <@05714b>): return int32(.result := pos);
	<append+219 @057143>  : 16 12 0f                   mov.x32 sp(18, 15)
	<append+222 @057146>  : 09 d4 ff ff                inc.sp(-44)
	<append+226 @05714a>  : 03                         ret
.usages:
	lib/std/string.ci:258: referenced as `append`
	lib/std/string.ci:233: defined as `append(output: char[], pos: int32, value: float64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:258'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
	lib/std/string.ci:258: defined as `append(output: char[], pos: int32, value: float32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@057160>
.name: 'append'
.file: 'lib/std/string.ci:261'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.showSign := false);
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (63 bytes: <@057160> - <@05719f>)
	lib/std/string.ci:263: (63 bytes: <@057160> - <@05719f>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @057160>      : 10 01                      dup.x32 sp(1)
	<append+2 @057162>    : 19                         load.z32
	<append+3 @057163>    : 11 05                      dup.x64 sp(5)
	<append+5 @057165>    : 10 06                      dup.x32 sp(6)
	<append+7 @057167>    : 10 04                      dup.x32 sp(4)
	<append+9 @057169>    : 19                         load.z32
	<append+10 @05716a>   : 58                         clt.i32
	<append+11 @05716b>   : 06 0d 00 00                jz <append+24 @057178>
	<append+15 @05716f>   : 1c 2d 00 00 00             load.c32 45
	<append+20 @057174>   : 04 05 00 00                jmp <append+25 @057179>
	<append+24 @057178>   : 19                         load.z32
	<append+25 @057179>   : 10 05                      dup.x32 sp(5)
	<append+27 @05717b>   : 19                         load.z32
	<append+28 @05717c>   : 58                         clt.i32
	<append+29 @05717d>   : 06 0b 00 00                jz <append+40 @057188>
	<append+33 @057181>   : 10 05                      dup.x32 sp(5)
	<append+35 @057183>   : 50                         neg.i32
	<append+36 @057184>   : 04 06 00 00                jmp <append+42 @05718a>
	<append+40 @057188>   : 10 05                      dup.x32 sp(5)
	<append+42 @05718a>   : 5b                         i32.2i64
	<append+43 @05718b>   : 1f 50 71 05 00             load.ref <@057150> ;append.format
	<append+48 @057190>   : 1f a0 6d 05 00             load.ref <@056da0> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+53 @057195>   : 02                         call
	<append+54 @057196>   : 09 e4 ff ff                inc.sp(-28)
	<append+58 @05719a>   : 13 01                      set.x32 sp(1)
	<append+60 @05719c>   : 13 06                      set.x32 sp(6)
	<append+62 @05719e>   : 03                         ret
.usages:
	lib/std/string.ci:261: defined as `append(output: char[], pos: int32, value: int32): int32`
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571a0>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0571a8>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571b0>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571b8>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571c0>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571c8>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571d0>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0571d8>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571e0>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0571e8>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@0571f0>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0571f8>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057200>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057208>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057210>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057218>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057220>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057228>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057230>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057238>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057240>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057248>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057250>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057258>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057260>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057268>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057270>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057278>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057280>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057288>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057290>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057298>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572a0>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572a8>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572b0>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572b8>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572c0>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572c8>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572d0>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572d8>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572e0>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572e8>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572f0>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0572f8>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057300>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057308>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057310>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057318>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057320>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057328>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057330>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057338>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057340>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057348>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057350>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057358>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057360>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@057368>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@057370>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@057378>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@057380>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@057388>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@036a90>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@036bc0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@057390>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@057398>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0573a0>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0573a8>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0573b0>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0573b8>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0573c0>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0573c8>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0573d0>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0573d8>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0573e0>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0573e8>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0573f0>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0573f8>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@057400>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057408>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057410>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057418>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@057420>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@057428>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@057430>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057438>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057440>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057448>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057450>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057458>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057460>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057468>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057470>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057478>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057480>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057488>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057490>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057498>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574a0>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574a8>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574b0>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574b8>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574c0>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574c8>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574d0>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0574d8>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0574e0>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0574e8>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0574f0>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0574f8>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057500>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057508>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057510>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057518>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057520>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057528>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057530>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057538>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057540>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057548>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057550>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057558>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057560>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057568>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057570>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057578>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057580>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057588>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057590>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057598>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575a0>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575a8>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575b0>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575b8>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575c0>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575c8>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575d0>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575d8>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575e0>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575e8>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575f0>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0575f8>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057600>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057608>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057610>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057618>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@057620>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057628>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@057630>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@057630> - <@057631>)
	<empty @057630>      : 03                         ret
.usages:
	test/lang/function.ci:4: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@057638>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@057638> - <@057640>)
	test/lang/function.ci:8: (8 bytes: <@057638> - <@057640>): return int32(.result := int32(x + y));
	<funAdd @057638>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @05763a>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @05763c>    : 51                         add.i32
	<funAdd+5 @05763d>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @05763f>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
	test/lang/function.ci:7: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057640>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:12: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@057648>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
	test/lang/function.ci:15: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057650>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:18: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@057658>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
	test/lang/function.ci:21: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057660>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:24: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@057668>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
	test/lang/function.ci:27: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057670>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:30: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@057678>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@057678> - <@057680>)
	test/lang/function.ci:34: (8 bytes: <@057678> - <@057680>): return int32(.result := int32(x * y));
	<funMul @057678>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @05767a>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @05767c>    : 53                         mul.i32
	<funMul+5 @05767d>    : 13 04                      set.x32 sp(4)
	<funMul+7 @05767f>    : 03                         ret
.usages:
	test/lang/function.ci:33: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@057680>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@057680> - <@0576b6>)
	test/lang/function.ci:39: (16 bytes: <@057680> - <@057690>): if (bool(n <= (1)))
	<fib @057680>      : 10 01                      dup.x32 sp(1)
	<fib+2 @057682>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @057687>    : 39                         cgt.u32
	<fib+8 @057688>    : 05 08 00 00                jnz <fib+16 @057690>
	test/lang/function.ci:40: (4 bytes: <@05768c> - <@057690>): return uint32(.result := n);
	<fib+12 @05768c>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @05768f>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@057690> - <@0576b6>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @057690>   : 19                         load.z32
	<fib+17 @057691>   : 10 02                      dup.x32 sp(2)
	<fib+19 @057693>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @057697>   : 1f 80 76 05 00             load.ref <@057680> ;fib(n: uint32): uint32
	<fib+28 @05769c>   : 02                         call
	<fib+29 @05769d>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @0576a1>   : 19                         load.z32
	<fib+34 @0576a2>   : 10 03                      dup.x32 sp(3)
	<fib+36 @0576a4>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @0576a8>   : 1f 80 76 05 00             load.ref <@057680> ;fib(n: uint32): uint32
	<fib+45 @0576ad>   : 02                         call
	<fib+46 @0576ae>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @0576b2>   : 51                         add.i32
	<fib+51 @0576b3>   : 13 03                      set.x32 sp(3)
	<fib+53 @0576b5>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:38: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0576b8>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
	test/lang/function.ci:46: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576c0>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576c8>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576d0>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576d8>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576e0>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576e8>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576f0>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0576f8>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057700>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057708>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057710>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057718>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057720>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057728>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057730>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057738>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057740>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057748>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@03ca28>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006a18>, cast: static const inline)
.field as: function (size: 0, offs: <@006cb0>, cast: static const inline)
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006a18>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006cb0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@03cb58>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006a18>, cast: static const inline)
.field as: function (size: 0, offs: <@006cb0>, cast: static const inline)
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006a18>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006cb0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057750>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@057758>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057760>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057768>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@057770>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057778>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@057780>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@057788>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057790>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057798>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0577a0>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0577a8>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0577b0>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0577b8>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0577c0>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0577c8>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0577d0>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0577d8>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0577e0>
.name: 'pi64'
.file: 'test/std/number.ci:3'
.value: 3.141593
.usages:
	test/std/number.ci:44: referenced as `pi64`
	test/std/number.ci:43: referenced as `pi64`
	test/std/number.ci:43: referenced as `pi64`
	test/std/number.ci:42: referenced as `pi64`
	test/std/number.ci:42: referenced as `pi64`
	test/std/number.ci:39: referenced as `pi64`
	test/std/number.ci:38: referenced as `pi64`
	test/std/number.ci:37: referenced as `pi64`
	test/std/number.ci:6: referenced as `pi64`
	test/std/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0577e8>
.name: 'e64'
.file: 'test/std/number.ci:4'
.value: 2.718282
.usages:
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:7: referenced as `e64`
	test/std/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0577f0>
.name: 'pi32'
.file: 'test/std/number.ci:6'
.value: pi64
.usages:
	test/std/number.ci:53: referenced as `pi32`
	test/std/number.ci:52: referenced as `pi32`
	test/std/number.ci:52: referenced as `pi32`
	test/std/number.ci:51: referenced as `pi32`
	test/std/number.ci:51: referenced as `pi32`
	test/std/number.ci:48: referenced as `pi32`
	test/std/number.ci:47: referenced as `pi32`
	test/std/number.ci:46: referenced as `pi32`
	test/std/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0577f8>
.name: 'e32'
.file: 'test/std/number.ci:7'
.value: e64
.usages:
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/std/number.ci:19: referenced as `rgb888`
	test/std/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/std/number.ci:18: referenced as `rgb565`
	test/std/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057800>
.name: 'r_comp'
.file: 'test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/std/number.ci:19: referenced as `r_comp`
	test/std/number.ci:18: referenced as `r_comp`
	test/std/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057808>
.name: 'g_comp'
.file: 'test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/std/number.ci:19: referenced as `g_comp`
	test/std/number.ci:18: referenced as `g_comp`
	test/std/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057810>
.name: 'b_comp'
.file: 'test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/std/number.ci:19: referenced as `b_comp`
	test/std/number.ci:18: referenced as `b_comp`
	test/std/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057818>
.name: 'r5g6b5'
.file: 'test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/std/number.ci:66: referenced as `r5g6b5`
	test/std/number.ci:65: referenced as `r5g6b5`
	test/std/number.ci:63: referenced as `r5g6b5`
	test/std/number.ci:62: referenced as `r5g6b5`
	test/std/number.ci:60: referenced as `r5g6b5`
	test/std/number.ci:59: referenced as `r5g6b5`
	test/std/number.ci:58: referenced as `r5g6b5`
	test/std/number.ci:57: referenced as `r5g6b5`
	test/std/number.ci:56: referenced as `r5g6b5`
	test/std/number.ci:55: referenced as `r5g6b5`
	test/std/number.ci:27: referenced as `r5g6b5`
	test/std/number.ci:26: referenced as `r5g6b5`
	test/std/number.ci:25: referenced as `r5g6b5`
	test/std/number.ci:23: referenced as `r5g6b5`
	test/std/number.ci:22: referenced as `r5g6b5`
	test/std/number.ci:21: referenced as `r5g6b5`
	test/std/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057820>
.name: 'r8g8b8'
.file: 'test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/std/number.ci:35: referenced as `r8g8b8`
	test/std/number.ci:34: referenced as `r8g8b8`
	test/std/number.ci:33: referenced as `r8g8b8`
	test/std/number.ci:31: referenced as `r8g8b8`
	test/std/number.ci:30: referenced as `r8g8b8`
	test/std/number.ci:29: referenced as `r8g8b8`
	test/std/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057828>
.name: 'zxtR5'
.file: 'test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/std/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057830>
.name: 'zxtG6'
.file: 'test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/std/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057838>
.name: 'zxtB5'
.file: 'test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057840>
.name: 'sxtR5'
.file: 'test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/std/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057848>
.name: 'sxtG6'
.file: 'test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/std/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057850>
.name: 'sxtB5'
.file: 'test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057858>
.name: 'zxtR8'
.file: 'test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/std/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057860>
.name: 'zxtG8'
.file: 'test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/std/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057868>
.name: 'zxtB8'
.file: 'test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/std/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057870>
.name: 'sxtR8'
.file: 'test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/std/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057878>
.name: 'sxtG8'
.file: 'test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/std/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057880>
.name: 'sxtB8'
.file: 'test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/std/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@057888>
.name: 'testSin_f64'
.file: 'test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/std/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@057890>
.name: 'testCos_f64'
.file: 'test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/std/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@057898>
.name: 'testTan_f64'
.file: 'test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/std/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0578a0>
.name: 'testLog_f64'
.file: 'test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/std/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0578a8>
.name: 'testExp_f64'
.file: 'test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/std/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0578b0>
.name: 'testPow_f64'
.file: 'test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/std/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0578b8>
.name: 'testSqrt_f64'
.file: 'test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/std/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0578c0>
.name: 'testAtan_f64'
.file: 'test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/std/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578c8>
.name: 'testSin_f32'
.file: 'test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/std/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578d0>
.name: 'testCos_f32'
.file: 'test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/std/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578d8>
.name: 'testTan_f32'
.file: 'test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/std/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578e0>
.name: 'testLog_f32'
.file: 'test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/std/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578e8>
.name: 'testExp_f32'
.file: 'test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/std/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578f0>
.name: 'testPow_f32'
.file: 'test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/std/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0578f8>
.name: 'testSqrt_f32'
.file: 'test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/std/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@057900>
.name: 'testAtan_f32'
.file: 'test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/std/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057908>
.name: 'testPopulation_u32'
.file: 'test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/std/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@057910>
.name: 'testSwapBits_u32'
.file: 'test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/std/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057918>
.name: 'testBitScanReverse_u32'
.file: 'test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/std/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057920>
.name: 'testBitScanForward_u32'
.file: 'test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/std/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057928>
.name: 'testHighBit_u32'
.file: 'test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/std/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057930>
.name: 'testLowBit_u32'
.file: 'test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/std/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057938>
.name: 'testZeroExtend_u32'
.file: 'test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057940>
.name: 'testSignExtend_u32'
.file: 'test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057948>
.name: 'testZeroExtend_u64'
.file: 'test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057950>
.name: 'testSignExtend_u64'
.file: 'test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/std/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/std/memory.ci:10: referenced as `malloc`
	test/std/memory.ci:9: referenced as `malloc`
	test/std/memory.ci:8: referenced as `malloc`
	test/std/memory.ci:7: referenced as `malloc`
	test/std/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/std/memory.ci:20: referenced as `free`
	test/std/memory.ci:19: referenced as `free`
	test/std/memory.ci:18: referenced as `free`
	test/std/memory.ci:17: referenced as `free`
	test/std/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057958>
.name: 'p1'
.file: 'test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	test/std/memory.ci:17: referenced as `p1`
	test/std/memory.ci:14: referenced as `p1`
	test/std/memory.ci:13: referenced as `p1`
	test/std/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057960>
.name: 'p2'
.file: 'test/std/memory.ci:8'
.value: malloc(80)
.usages:
	test/std/memory.ci:18: referenced as `p2`
	test/std/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057968>
.name: 'p3'
.file: 'test/std/memory.ci:9'
.value: malloc(160)
.usages:
	test/std/memory.ci:19: referenced as `p3`
	test/std/memory.ci:14: referenced as `p3`
	test/std/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@057970>
.name: 'p4'
.file: 'test/std/memory.ci:10'
.value: malloc(820)
.usages:
	test/std/memory.ci:20: referenced as `p4`
	test/std/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@057978>
.name: 'val1'
.file: 'test/std/memory.ci:23'
.value: 42
.usages:
	test/std/memory.ci:32: referenced as `val1`
	test/std/memory.ci:30: referenced as `val1`
	test/std/memory.ci:29: referenced as `val1`
	test/std/memory.ci:26: referenced as `val1`
	test/std/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@057980>
.name: 'val2'
.file: 'test/std/memory.ci:24'
.value: 96
.usages:
	test/std/memory.ci:33: referenced as `val2`
	test/std/memory.ci:29: referenced as `val2`
	test/std/memory.ci:27: referenced as `val2`
	test/std/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@057988>
.name: 'noError'
.file: 'test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@057988> - <@057989>)
	<noError @057988>      : 03                         ret
.usages:
	test/std/tryExec.ci:46: referenced as `noError`
	test/std/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@057990>
.name: 'stackOverflow'
.file: 'test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@057990> - <@0579a8>)
	test/std/tryExec.ci:15: (4 bytes: <@057990> - <@057994>): data: uint8[8192]
	<stackOverflow @057990>      : 09 00 20 00                inc.sp(+8192)
	test/std/tryExec.ci:16: (15 bytes: <@057994> - <@0579a3>): stackOverflow(ptr);
	<stackOverflow+4 @057994>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @057998>    : 22                         load.i32
	<stackOverflow+9 @057999>    : 1f 90 79 05 00             load.ref <@057990> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @05799e>   : 02                         call
	<stackOverflow+15 @05799f>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @0579a3>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @0579a7>   : 03                         ret
.usages:
	test/std/tryExec.ci:48: referenced as `stackOverflow`
	test/std/tryExec.ci:16: referenced as `stackOverflow`
	test/std/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0579a8>
.name: 'divisionByZero'
.file: 'test/std/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@0579a8> - <@0579b4>)
	test/std/tryExec.ci:20: (7 bytes: <@0579a8> - <@0579af>): value: int32 := int32(3 / 0)
	<divisionByZero @0579a8>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @0579ad>    : 19                         load.z32
	<divisionByZero+6 @0579ae>    : 54                         div.i32
	<divisionByZero+7 @0579af>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @0579b3>   : 03                         ret
.usages:
	test/std/tryExec.ci:49: referenced as `divisionByZero`
	test/std/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@0579b8>
.name: 'abortExecution'
.file: 'test/std/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@0579b8> - <@0579fc>)
	test/std/tryExec.ci:29: (25 bytes: <@0579b8> - <@0579d1>): details: NotEquals := {...}
	<abortExecution @0579b8>      : 09 10 00 00                inc.sp(+16)
	test/std/tryExec.ci:30: (7 bytes: <@0579bc> - <@0579c3>): void(details.message := ("assertion failed"));
	<abortExecution+4 @0579bc>    : 1f b6 d7 00 00             load.ref <@00d7b6> ;"assertion failed"
	<abortExecution+9 @0579c1>    : 13 01                      set.x32 sp(1)
	test/std/tryExec.ci:31: (7 bytes: <@0579c3> - <@0579ca>): void(details.expected := 97);
	<abortExecution+11 @0579c3>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @0579c8>   : 13 02                      set.x32 sp(2)
	test/std/tryExec.ci:32: (7 bytes: <@0579ca> - <@0579d1>): void(details.returned := 77);
	<abortExecution+18 @0579ca>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @0579cf>   : 13 03                      set.x32 sp(3)
	test/std/tryExec.ci:34: (38 bytes: <@0579d1> - <@0579f7>): abort(void("fatal error", details));
	<abortExecution+25 @0579d1>   : 1f c8 07 04 00             load.ref <@0407c8> ;"test/std/tryExec.ci"
	<abortExecution+30 @0579d6>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @0579db>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @0579e0>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @0579e5>   : 1f 10 08 04 00             load.ref <@040810> ;"fatal error"
	<abortExecution+50 @0579ea>   : 1f 28 12 04 00             load.ref <@041228> ;abortExecution.NotEquals
	<abortExecution+55 @0579ef>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @0579f3>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @0579f7>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @0579fb>   : 03                         ret
.usages:
	test/std/tryExec.ci:52: referenced as `abortExecution`
	test/std/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@057a00>
.name: 'invalidMemoryAccess'
.file: 'test/std/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@057a00> - <@057a0d>)
	test/std/tryExec.ci:38: (5 bytes: <@057a00> - <@057a05>): i32Ref: int32 := null
	<invalidMemoryAccess @057a00>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/std/tryExec.ci:39: (3 bytes: <@057a05> - <@057a08>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @057a05>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @057a07>    : 22                         load.i32
	<invalidMemoryAccess+8 @057a08>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @057a0c>   : 03                         ret
.usages:
	test/std/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/std/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@057a10>
.name: 'invalidInstruction'
.file: 'test/std/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@057a10> - <@057a12>)
	test/std/tryExec.ci:43: (2 bytes: <@057a10> - <@057a12>): emit(void(load.z32, ret));
	<invalidInstruction @057a10>      : 19                         load.z32
	<invalidInstruction+1 @057a11>    : 03                         ret
.usages:
	test/std/tryExec.ci:50: referenced as `invalidInstruction`
	test/std/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a18>
.name: 'tryExecErr0'
.file: 'test/std/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/std/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a20>
.name: 'tryExecErr1'
.file: 'test/std/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/std/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a28>
.name: 'tryExecErr2'
.file: 'test/std/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/std/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a30>
.name: 'tryExecErr3'
.file: 'test/std/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/std/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a38>
.name: 'tryExecErr4'
.file: 'test/std/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/std/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a40>
.name: 'tryExecErr5'
.file: 'test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/std/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057a48>
.name: 'tryExecErr6'
.file: 'test/std/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/std/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@057a50>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@057a88>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@057a90>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@057a98>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@057aa0>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@057aa8>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@057ab0>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@057ab8>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@057ac0>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@057ac8>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@057ad0>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@057ad8>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@057ae0>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@057ae8>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: const variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@057ae8> - <@057aec>)
	test/lang/array.ci:103: (4 bytes: <@057ae8> - <@057aec>): return uint32(.result := values.length);
	<lenSlice @057ae8>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @057aeb>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@057af0>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@057af0> - <@057afc>)
	test/lang/array.ci:104: (12 bytes: <@057af0> - <@057afc>): return int64(.result := values[idx]);
	<nthFixed @057af0>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @057af2>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @057af4>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @057af8>    : 23                         load.i64
	<nthFixed+9 @057af9>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @057afb>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@057b00>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@057b00> - <@057b0c>)
	test/lang/array.ci:105: (12 bytes: <@057b00> - <@057b0c>): return int64(.result := values[idx]);
	<nthArray @057b00>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @057b02>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @057b04>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @057b08>    : 23                         load.i64
	<nthArray+9 @057b09>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @057b0b>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@057b10>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: const variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@057b10> - <@057b1c>)
	test/lang/array.ci:106: (12 bytes: <@057b10> - <@057b1c>): return int64(.result := values[idx]);
	<nthSlice @057b10>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @057b12>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @057b14>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @057b18>    : 23                         load.i64
	<nthSlice+9 @057b19>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @057b1b>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@043f70>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@044008>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@057b20>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@057b28>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@057b30>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@057b38>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@057b40>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@057b48>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@044008>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057b20>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057b28>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@057b30>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@057b38>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@057b40>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@057b48>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@057b50>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@044df8>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:4'
.field staticMethod: function (size: 39, offs: <@057b70>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@057b98>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@057ba0>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@057bc8>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/method.ci:102: referenced as `RecordMethodTest`
	test/lang/method.ci:101: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:87: referenced as `RecordMethodTest`
	test/lang/method.ci:84: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:57: referenced as `RecordMethodTest`
	test/lang/method.ci:47: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:32: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:18: referenced as `RecordMethodTest`
	test/lang/method.ci:10: referenced as `RecordMethodTest`
	test/lang/method.ci:4: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@057b70>
.name: 'staticMethod'
.file: 'test/lang/method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@057b70> - <@057b97>)
	test/lang/method.ci:11: (38 bytes: <@057b70> - <@057b96>): trace(void("staticMethod", x));
	<staticMethod @057b70>      : 1f 88 49 04 00             load.ref <@044988> ;"test/lang/method.ci"
	<staticMethod+5 @057b75>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @057b7a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @057b7f>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @057b84>   : 1f 25 4a 04 00             load.ref <@044a25> ;"staticMethod"
	<staticMethod+25 @057b89>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @057b8e>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @057b92>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @057b96>   : 03                         ret
.usages:
	test/lang/method.ci:101: referenced as `staticMethod`
	test/lang/method.ci:87: referenced as `staticMethod`
	test/lang/method.ci:78: referenced as `staticMethod`
	test/lang/method.ci:10: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@057b98>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: referenced as `forwardMethod`
	test/lang/method.ci:18: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:25: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/method.ci:103: referenced as `virtualMethod`
	test/lang/method.ci:93: referenced as `virtualMethod`
	test/lang/method.ci:79: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@057ba0>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@057ba0> - <@057bc7>)
	test/lang/method.ci:41: (38 bytes: <@057ba0> - <@057bc6>): trace(void("virtualMethod", x));
	<virtualMethod @057ba0>      : 1f 88 49 04 00             load.ref <@044988> ;"test/lang/method.ci"
	<virtualMethod+5 @057ba5>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @057baa>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @057baf>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @057bb4>   : 1f 16 4d 04 00             load.ref <@044d16> ;"virtualMethod"
	<virtualMethod+25 @057bb9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @057bbe>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @057bc2>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @057bc6>   : 03                         ret
.usages:
	test/lang/method.ci:102: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@057bc8>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@057bc8> - <@057bef>)
	test/lang/method.ci:48: (38 bytes: <@057bc8> - <@057bee>): trace(void("forwardMethod", x));
	<forwardMethod @057bc8>      : 1f 88 49 04 00             load.ref <@044988> ;"test/lang/method.ci"
	<forwardMethod+5 @057bcd>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @057bd2>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @057bd7>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @057bdc>   : 1f 9d 4a 04 00             load.ref <@044a9d> ;"forwardMethod"
	<forwardMethod+25 @057be1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @057be6>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @057bea>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @057bee>   : 03                         ret
.usages:
	test/lang/method.ci:47: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@057bf0>
.name: 'globalFunction'
.file: 'test/lang/method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@057bf0> - <@057c17>)
	test/lang/method.ci:58: (38 bytes: <@057bf0> - <@057c16>): trace(void("globalFunction", x));
	<globalFunction @057bf0>      : 1f 88 49 04 00             load.ref <@044988> ;"test/lang/method.ci"
	<globalFunction+5 @057bf5>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @057bfa>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @057bff>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @057c04>   : 1f 49 4d 04 00             load.ref <@044d49> ;"globalFunction"
	<globalFunction+25 @057c09>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @057c0e>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @057c12>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @057c16>   : 03                         ret
.usages:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:57: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@057c18>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:102: referenced as `recordMethodTest`
	test/lang/method.ci:101: referenced as `recordMethodTest`
	test/lang/method.ci:98: referenced as `recordMethodTest`
	test/lang/method.ci:97: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:78: referenced as `recordMethodTest`
	test/lang/method.ci:62: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@057c28>
.name: 'staticMethod'
.file: 'test/lang/method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@057c28> - <@057c6a>)
	test/lang/method.ci:85: (35 bytes: <@057c28> - <@057c4b>): debug("extension.staticMethod");
	<staticMethod @057c28>      : 1f 88 49 04 00             load.ref <@044988> ;"test/lang/method.ci"
	<staticMethod+5 @057c2d>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @057c32>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @057c37>   : 19                         load.z32
	<staticMethod+16 @057c38>   : 1f c5 4d 04 00             load.ref <@044dc5> ;"extension.staticMethod"
	<staticMethod+21 @057c3d>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @057c42>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @057c47>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:86: (30 bytes: <@057c4b> - <@057c69>): if (bool((this) != null))
	<staticMethod+35 @057c4b>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @057c4f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @057c54>   : 57                         ceq.i32
	<staticMethod+45 @057c55>   : 05 14 00 00                jnz <staticMethod+65 @057c69>
	test/lang/method.ci:87: (16 bytes: <@057c59> - <@057c69>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @057c59>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @057c5b>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @057c5d>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @057c5f>   : 1f 70 7b 05 00             load.ref <@057b70> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @057c64>   : 02                         call
	<staticMethod+61 @057c65>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @057c69>   : 03                         ret
.usages:
	test/lang/method.ci:97: referenced as `staticMethod`
	test/lang/method.ci:84: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@057c70>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@057c70> - <@057caf>)
	test/lang/method.ci:91: (35 bytes: <@057c70> - <@057c93>): debug("extension.virtualMethod");
	<virtualMethod @057c70>      : 1f 88 49 04 00             load.ref <@044988> ;"test/lang/method.ci"
	<virtualMethod+5 @057c75>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @057c7a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @057c7f>   : 19                         load.z32
	<virtualMethod+16 @057c80>   : 1f dc 4d 04 00             load.ref <@044ddc> ;"extension.virtualMethod"
	<virtualMethod+21 @057c85>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @057c8a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @057c8f>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:92: (27 bytes: <@057c93> - <@057cae>): if (bool((this) != null))
	<virtualMethod+35 @057c93>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @057c97>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @057c9c>   : 57                         ceq.i32
	<virtualMethod+45 @057c9d>   : 05 11 00 00                jnz <virtualMethod+62 @057cae>
	test/lang/method.ci:93: (13 bytes: <@057ca1> - <@057cae>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @057ca1>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @057ca3>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @057ca5>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @057ca7>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @057ca9>   : 02                         call
	<virtualMethod+58 @057caa>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @057cae>   : 03                         ret
.usages:
	test/lang/method.ci:98: referenced as `virtualMethod`
	test/lang/method.ci:90: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@046578>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@0467d8>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@046a38>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@046c00>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006a18>, cast: static const inline)
.field as: function (size: 0, offs: <@006cb0>, cast: static const inline)
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006a18>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006cb0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@057cb0>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@057cb8>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@057cc0>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@057cc8>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@057cd0>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0470a0>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@0474c8>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0478f0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@047d18>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@048140>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@048568>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@057cd8>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057ce0>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057ce8>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057cf0>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057cf8>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d00>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d08>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d10>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d18>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d20>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d28>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d30>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057d38>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d40>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d48>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d50>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d58>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d60>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d68>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d70>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d78>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d80>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d88>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d90>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057d98>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057da0>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057da8>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@057db0>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057db8>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057dc0>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057dc8>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057dd0>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057dd8>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057de0>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057de8>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057df0>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057df8>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e00>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e08>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e10>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e18>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e20>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e28>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e30>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e38>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e40>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e48>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e50>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e58>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@057e60>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e68>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e70>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e78>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e80>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e88>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e90>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057e98>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ea0>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ea8>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057eb0>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057eb8>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ec0>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ec8>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ed0>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ed8>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ee0>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ee8>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ef0>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057ef8>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057f00>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057f08>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@057f10>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f18>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f20>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f28>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f30>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f38>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f40>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057f48>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f50>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f58>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f60>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f68>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f70>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f78>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f80>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f88>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f90>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057f98>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057fa0>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057fa8>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057fb0>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057fb8>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@057fc0>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057fc8>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057fd0>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057fd8>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057fe0>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057fe8>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057ff0>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@057ff8>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058000>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058008>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058010>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058018>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058020>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058028>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058030>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058038>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058040>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058048>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058050>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058058>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058060>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058068>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@058070>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058078>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058080>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058088>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058090>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058098>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0580a0>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0580a8>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580b0>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580b8>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580c0>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580c8>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580d0>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580d8>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580e0>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580e8>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580f0>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0580f8>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058100>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058108>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058110>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058118>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058120>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058128>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058130>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058138>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058140>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058148>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058150>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058158>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058160>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058168>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058170>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058178>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058180>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058188>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058190>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058198>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581a0>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581a8>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581b0>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581b8>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581c0>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581c8>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0581d0>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0581d8>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0581e0>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0581e8>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0581f0>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0581f8>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058200>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058208>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058210>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058218>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058220>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058228>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058230>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058238>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058240>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058248>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058250>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058258>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058260>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058268>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058270>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058278>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058280>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058288>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058290>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058298>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0582a0>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0582a8>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0582b0>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0582b8>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582c0>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582c8>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582d0>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582d8>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582e0>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582e8>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582f0>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0582f8>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058300>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058308>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058310>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058318>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058320>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058328>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@058330>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058338>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058340>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058348>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058350>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058358>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058360>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058368>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058370>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058378>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058380>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058388>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058390>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058398>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0583a0>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0583a8>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0583b0>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583b8>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583c0>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583c8>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583d0>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583d8>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583e0>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0583e8>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0583f0>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0583f8>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058400>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058408>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058410>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058418>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058420>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058428>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058430>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058438>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058440>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058448>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058450>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058458>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058460>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058468>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058470>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058478>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058480>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058488>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058490>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058498>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584a0>
.name: 'testMathFloor_1'
.file: 'test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/std/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584a8>
.name: 'testMathFloor_2'
.file: 'test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/std/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584b0>
.name: 'testMathFloor_3'
.file: 'test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/std/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584b8>
.name: 'testMathFloor_4'
.file: 'test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/std/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584c0>
.name: 'testMathFloor_5'
.file: 'test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/std/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584c8>
.name: 'testMathFloor_6'
.file: 'test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/std/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584d0>
.name: 'testMathSign_1F'
.file: 'test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/std/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584d8>
.name: 'testMathSign_2F'
.file: 'test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/std/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584e0>
.name: 'testMathSign_3F'
.file: 'test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/std/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584e8>
.name: 'testMathSign_1f'
.file: 'test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/std/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584f0>
.name: 'testMathSign_2f'
.file: 'test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/std/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0584f8>
.name: 'testMathSign_3f'
.file: 'test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/std/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058500>
.name: 'testMathAbs_1F'
.file: 'test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/std/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058508>
.name: 'testMathAbs_2F'
.file: 'test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/std/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058510>
.name: 'testMathAbs_3F'
.file: 'test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/std/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058518>
.name: 'testMathAbs_1f'
.file: 'test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/std/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058520>
.name: 'testMathAbs_2f'
.file: 'test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/std/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058528>
.name: 'testMathAbs_3f'
.file: 'test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/std/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058530>
.name: 'testMathMin_1f'
.file: 'test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058538>
.name: 'testMathMax_2f'
.file: 'test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058540>
.name: 'testMathMin_1F'
.file: 'test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058548>
.name: 'testMathMax_2F'
.file: 'test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058550>
.name: 'testMathClamp_1f'
.file: 'test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058558>
.name: 'testMathClamp_1F'
.file: 'test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058560>
.name: 'testMathLerp_1f'
.file: 'test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/std/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058568>
.name: 'testMathLerp_1F'
.file: 'test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/std/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058570>
.name: 'testMathSmooth_1f'
.file: 'test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058578>
.name: 'testMathSmooth_1F'
.file: 'test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058580>
.name: 'testMathMin_nan'
.file: 'test/std/test.math.ci:38'
.value: Math.min()
.usages:
	test/std/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058588>
.name: 'testMathMin_1'
.file: 'test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/std/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058590>
.name: 'testMathMax_nan'
.file: 'test/std/test.math.ci:40'
.value: Math.max()
.usages:
	test/std/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058598>
.name: 'testMathMax_9'
.file: 'test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/std/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585a0>
.name: 'testMathSum_0'
.file: 'test/std/test.math.ci:43'
.value: Math.sum()
.usages:
	test/std/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585a8>
.name: 'testMathSum_1'
.file: 'test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/std/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585b0>
.name: 'testMathSum_3'
.file: 'test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/std/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585b8>
.name: 'testMathSum_55'
.file: 'test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/std/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585c0>
.name: 'testMathEval_x'
.file: 'test/std/test.math.ci:48'
.value: 10
.usages:
	test/std/test.math.ci:55: referenced as `testMathEval_x`
	test/std/test.math.ci:54: referenced as `testMathEval_x`
	test/std/test.math.ci:53: referenced as `testMathEval_x`
	test/std/test.math.ci:52: referenced as `testMathEval_x`
	test/std/test.math.ci:51: referenced as `testMathEval_x`
	test/std/test.math.ci:50: referenced as `testMathEval_x`
	test/std/test.math.ci:49: referenced as `testMathEval_x`
	test/std/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585c8>
.name: 'testMathEval_0'
.file: 'test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/std/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585d0>
.name: 'testMathEval_1'
.file: 'test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/std/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585d8>
.name: 'testMathEval_2'
.file: 'test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585e0>
.name: 'testMathEval_3'
.file: 'test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585e8>
.name: 'testMathEval_4'
.file: 'test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585f0>
.name: 'testMathEval_5'
.file: 'test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0585f8>
.name: 'testMathEval_6'
.file: 'test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058600>
.name: 'testMathSin_f64'
.file: 'test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058608>
.name: 'testMathCos_f64'
.file: 'test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058610>
.name: 'testMathTan_f64'
.file: 'test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/std/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058618>
.name: 'testMathSinh_f64'
.file: 'test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058620>
.name: 'testMathCosh_f64'
.file: 'test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058628>
.name: 'testMathAsin_f64'
.file: 'test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/std/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058630>
.name: 'testMathAcos_f64'
.file: 'test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/std/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058638>
.name: 'testMathCmp_f32'
.file: 'test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/std/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@058640>
.name: 'testMathCmp_f64'
.file: 'test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/std/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058648>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/std/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058650>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/std/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058658>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/std/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058660>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/std/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058668>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/std/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058670>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/std/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058678>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/std/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058680>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/std/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058688>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/std/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058690>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/std/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@058698>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/std/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586a0>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/std/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586a8>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/std/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586b0>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/std/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586b8>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/std/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586c0>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/std/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586c8>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/std/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586d0>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/std/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586d8>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/std/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586e0>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/std/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586e8>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/std/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0586f0>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/std/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 14634
.offset: <@0586f4>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000d38>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000dd8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005900>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@007470>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@007d50>, cast: static const inline)
.field System: typename (size: 0, offs: <@0089c0>, cast: static const typename(void))
.field true: bool (size: 1, offs: <@000000>, cast: static const val)
.field false: bool (size: 1, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 32, offs: <@0106b0>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@055c80>, cast: static const function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@011918>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01a638>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@0564a0>, cast: static const function)
.field Complex: function (size: 7, offs: <@0564a8>, cast: static const function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@0564b0>, cast: static const function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@056530>, cast: static const function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@056550>, cast: static const function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@01fc10>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@0565b8>, cast: static const function)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@023388>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@0565c8>, cast: static const function)
.field mat4f: function (size: 21, offs: <@056600>, cast: static const function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 417, offs: <@056618>, cast: static const function)
.field rotation: function (size: 524, offs: <@0567c0>, cast: static const function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@0569d0>, cast: static const function)
.field scale: function (size: 217, offs: <@056a28>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@0281b8>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@056b08>, cast: static const function)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@056b10>, cast: static const function)
.field indexOf: function (size: 50, offs: <@056b38>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@056b70>, cast: static const function)
.field startsWith: function (size: 73, offs: <@056ba8>, cast: static const function)
.field endsWith: function (size: 126, offs: <@056bf8>, cast: static const function)
.field compare: function (size: 63, offs: <@056c78>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@056d00>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@056d28>, cast: static const function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@02c688>, cast: static const typename(val))
.field append: function (size: 84, offs: <@056d38>, cast: static const function)
.field append: function (size: 707, offs: <@056da0>, cast: static const function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 227, offs: <@057068>, cast: static const function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 63, offs: <@057160>, cast: static const function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@0571a0>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@0571a8>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@0571b0>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@0571b8>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@0571c0>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@0571c8>, cast: static variable(i32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@0571d0>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@0571d8>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@0571e0>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@0571e8>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@0571f0>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@0571f8>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@057200>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@057208>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@057210>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@057218>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@057220>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@057228>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@057230>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@057238>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@057240>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@057248>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@057250>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@057258>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@057260>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@057268>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@057270>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@057278>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@057280>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@057288>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@057290>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@057298>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@0572a0>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@0572a8>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@0572b0>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@0572b8>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@0572c0>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@0572c8>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@0572d0>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@0572d8>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@0572e0>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@0572e8>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@0572f0>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@0572f8>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@057300>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@057308>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@057310>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@057318>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@057320>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@057328>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@057330>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@057338>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@057340>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@057348>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@057350>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@057358>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@057360>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@057368>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@057370>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@057378>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@057380>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@057388>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@036a90>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@036bc0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@057390>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@057398>, cast: static variable(val))
.field value: int64 (size: 8, offs: <@0573a0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@0573a8>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@0573b0>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@0573b8>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@0573c0>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@0573c8>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@0573d0>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@0573d8>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@0573e0>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@0573e8>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@0573f0>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@0573f8>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@057400>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@057408>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@057410>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@057418>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@057420>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@057428>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@057430>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@057438>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@057440>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@057448>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@057450>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@057458>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@057460>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@057468>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@057470>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@057478>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@057480>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@057488>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@057490>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@057498>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@0574a0>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@0574a8>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@0574b0>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@0574b8>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@0574c0>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@0574c8>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@0574d0>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@0574d8>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@0574e0>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@0574e8>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@0574f0>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@0574f8>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@057500>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@057508>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@057510>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@057518>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@057520>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@057528>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@057530>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@057538>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@057540>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@057548>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@057550>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@057558>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@057560>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@057568>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@057570>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@057578>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@057580>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@057588>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@057590>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@057598>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@0575a0>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@0575a8>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@0575b0>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@0575b8>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@0575c0>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@0575c8>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@0575d0>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@0575d8>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@0575e0>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@0575e8>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@0575f0>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@0575f8>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@057600>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@057608>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@057610>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@057618>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@057620>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@057628>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@057630>, cast: static const function)
.field funAdd: function (size: 8, offs: <@057638>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <@057640>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@057648>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@057650>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@057658>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@057660>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@057668>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@057670>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@057678>, cast: static const function)
.field fib: function (size: 54, offs: <@057680>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <@0576b8>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@0576c0>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@0576c8>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@0576d0>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@0576d8>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@0576e0>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@0576e8>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@0576f0>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@0576f8>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@057700>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@057708>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@057710>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@057718>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@057720>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@057728>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@057730>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@057738>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@057740>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@057748>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@03ca28>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@03cb58>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@057750>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@057758>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@057760>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@057768>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@057770>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@057778>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@057780>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@057788>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@057790>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@057798>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@0577a0>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@0577a8>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@0577b0>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@0577b8>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@0577c0>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@0577c8>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@0577d0>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@0577d8>, cast: static variable(i32))
.field pi64: float64 (size: 8, offs: <@0577e0>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@0577e8>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@0577f0>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@0577f8>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@057800>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@057808>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@057810>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@057818>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@057820>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@057828>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@057830>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@057838>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@057840>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@057848>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@057850>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@057858>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@057860>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@057868>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@057870>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@057878>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@057880>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@057888>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@057890>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@057898>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@0578a0>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@0578a8>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@0578b0>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@0578b8>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@0578c0>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@0578c8>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@0578d0>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@0578d8>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@0578e0>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@0578e8>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@0578f0>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@0578f8>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@057900>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@057908>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@057910>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@057918>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@057920>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@057928>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@057930>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@057938>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@057940>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@057948>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@057950>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@057958>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@057960>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@057968>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@057970>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@057978>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@057980>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@057988>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@057990>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@0579a8>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@0579b8>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@057a00>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@057a10>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <@057a18>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@057a20>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@057a28>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@057a30>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@057a38>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@057a40>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@057a48>, cast: static variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <@057a50>, cast: static variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <@057a88>, cast: static variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <@057a90>, cast: static variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@057a98>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@057aa0>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@057aa8>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@057ab0>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@057ab8>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@057ac0>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@057ac8>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@057ad0>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@057ad8>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@057ae0>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@057ae8>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@057af0>, cast: static const function)
.field nthArray: function (size: 12, offs: <@057b00>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@057b10>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@043f70>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@057b50>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@044df8>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@057bf0>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@057c18>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@057c28>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@057c70>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@046578>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@0467d8>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@046a38>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@046c00>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@057cb0>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@057cb8>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@057cc0>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@057cc8>, cast: static variable(val))
.field blue: color (size: 4, offs: <@057cd0>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@0470a0>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@0474c8>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0478f0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@047d18>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@048140>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@048568>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@057cd8>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@057ce0>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@057ce8>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@057cf0>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@057cf8>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@057d00>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@057d08>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@057d10>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@057d18>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@057d20>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@057d28>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@057d30>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@057d38>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@057d40>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@057d48>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@057d50>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@057d58>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@057d60>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@057d68>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@057d70>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@057d78>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@057d80>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@057d88>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@057d90>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@057d98>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@057da0>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@057da8>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@057db0>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@057db8>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@057dc0>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@057dc8>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@057dd0>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@057dd8>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@057de0>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@057de8>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@057df0>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@057df8>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@057e00>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@057e08>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@057e10>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@057e18>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@057e20>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@057e28>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@057e30>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@057e38>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@057e40>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@057e48>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@057e50>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@057e58>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@057e60>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@057e68>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@057e70>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@057e78>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@057e80>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@057e88>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@057e90>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@057e98>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@057ea0>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@057ea8>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@057eb0>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@057eb8>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@057ec0>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@057ec8>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@057ed0>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@057ed8>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@057ee0>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@057ee8>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@057ef0>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@057ef8>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@057f00>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@057f08>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@057f10>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@057f18>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@057f20>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@057f28>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@057f30>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@057f38>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@057f40>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@057f48>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@057f50>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@057f58>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@057f60>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@057f68>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@057f70>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@057f78>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@057f80>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@057f88>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@057f90>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@057f98>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@057fa0>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@057fa8>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@057fb0>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@057fb8>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@057fc0>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@057fc8>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@057fd0>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@057fd8>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@057fe0>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@057fe8>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@057ff0>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@057ff8>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@058000>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@058008>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@058010>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@058018>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@058020>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@058028>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@058030>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@058038>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@058040>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@058048>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@058050>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@058058>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@058060>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@058068>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@058070>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@058078>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@058080>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@058088>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@058090>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@058098>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@0580a0>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@0580a8>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@0580b0>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@0580b8>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@0580c0>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@0580c8>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@0580d0>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@0580d8>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@0580e0>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@0580e8>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@0580f0>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@0580f8>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@058100>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@058108>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@058110>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@058118>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@058120>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@058128>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@058130>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@058138>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@058140>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@058148>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@058150>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@058158>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@058160>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@058168>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@058170>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@058178>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@058180>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@058188>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@058190>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@058198>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@0581a0>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@0581a8>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@0581b0>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@0581b8>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@0581c0>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@0581c8>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@0581d0>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@0581d8>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@0581e0>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@0581e8>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@0581f0>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@0581f8>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@058200>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@058208>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@058210>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@058218>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@058220>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@058228>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@058230>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@058238>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@058240>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@058248>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@058250>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@058258>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@058260>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@058268>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@058270>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@058278>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@058280>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@058288>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@058290>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@058298>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@0582a0>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@0582a8>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@0582b0>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@0582b8>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@0582c0>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@0582c8>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@0582d0>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@0582d8>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@0582e0>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@0582e8>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@0582f0>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@0582f8>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@058300>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@058308>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@058310>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@058318>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@058320>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@058328>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@058330>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@058338>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@058340>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@058348>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@058350>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@058358>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@058360>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@058368>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@058370>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@058378>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@058380>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@058388>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@058390>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@058398>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@0583a0>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@0583a8>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@0583b0>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@0583b8>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@0583c0>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@0583c8>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@0583d0>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@0583d8>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@0583e0>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@0583e8>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@0583f0>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@0583f8>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@058400>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@058408>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@058410>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@058418>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@058420>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@058428>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@058430>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@058438>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@058440>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@058448>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@058450>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@058458>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@058460>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@058468>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@058470>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@058478>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@058480>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@058488>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@058490>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@058498>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@0584a0>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@0584a8>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@0584b0>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@0584b8>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@0584c0>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@0584c8>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@0584d0>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@0584d8>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@0584e0>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@0584e8>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@0584f0>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@0584f8>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@058500>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@058508>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@058510>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@058518>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@058520>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@058528>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@058530>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@058538>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@058540>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@058548>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@058550>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@058558>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@058560>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@058568>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@058570>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@058578>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@058580>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@058588>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@058590>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@058598>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@0585a0>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@0585a8>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@0585b0>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@0585b8>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@0585c0>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@0585c8>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@0585d0>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@0585d8>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@0585e0>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@0585e8>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@0585f0>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@0585f8>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@058600>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@058608>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@058610>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@058618>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@058620>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@058628>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@058630>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@058638>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@058640>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@058648>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@058650>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@058658>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@058660>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@058668>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@058670>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@058678>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@058680>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@058688>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@058690>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@058698>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@0586a0>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@0586a8>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@0586b0>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@0586b8>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@0586c0>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@0586c8>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@0586d0>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@0586d8>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@0586e0>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@0586e8>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@0586f0>, cast: static variable(f32))
.field .main: function (size: 14634, offs: <@0586f4>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		static add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			data: float32[4];
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
		};
		static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			data: float32[16];
			m: float32[4][4];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
		};
		static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := {
				void(transposed.x.x := rhs.x.x);
				void(transposed.x.y := rhs.y.x);
				void(transposed.x.z := rhs.z.x);
				void(transposed.x.w := rhs.w.x);
				void(transposed.y.x := rhs.x.y);
				void(transposed.y.y := rhs.y.y);
				void(transposed.y.z := rhs.z.y);
				void(transposed.y.w := rhs.w.y);
				void(transposed.z.x := rhs.x.z);
				void(transposed.z.y := rhs.y.z);
				void(transposed.z.z := rhs.z.z);
				void(transposed.z.w := rhs.w.z);
				void(transposed.w.x := rhs.x.w);
				void(transposed.w.y := rhs.y.w);
				void(transposed.w.z := rhs.z.w);
				void(transposed.w.w := rhs.w.w);
			};
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static const rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
		static const translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.x.x := (1));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := float32(direction.x * amount));
			void(.result.y.x := (0));
			void(.result.y.y := (1));
			void(.result.y.z := (0));
			void(.result.y.w := float32(direction.y * amount));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := (1));
			void(.result.z.w := float32(direction.z * amount));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
		};
		static const scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.x.x := rcp(float32(direction.x * amount)));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := (0));
			void(.result.y.x := (0));
			void(.result.y.y := rcp(float32(direction.y * amount)));
			void(.result.y.z := (0));
			void(.result.y.w := (0));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := rcp(float32(direction.z * amount)));
			void(.result.z.w := (0));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
		};
		static const vec2d: struct {
			data: float64[2];
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
		};
		static const vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static const length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static const append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			if (format.showSign) {
				if (bool((sign) == 0)) {
					char(sign := '+');
				}
			}
			radix: int32 := format.precision;
			if (bool(radix == 0)) {
				int32(radix := 10);
			}
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format));
		static const append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				void(formatInt.showSign := format.showSign);
				void(formatInt.precision := 0);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(format.padLen - format.precision));
			};
			formatDec: FormatFlags := {
				void(formatDec.showSign := false);
				void(formatDec.precision := 0);
				void(formatDec.padChr := '0');
				void(formatDec.padLen := format.precision);
			};
			sign: char := bool(value < (0)) ? ('-') : 0;
			fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(void(pos, sign), uint64(value)), formatInt))));
			int32(pos := append(void(output, void(pos, "."))));
			float64(fract := float64(fract * float64.pow(void(10, format.precision))));
			int32(pos := append(void(output, void(void(void(pos, 0), uint64(fract)), formatDec))));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static const append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.showSign := false);
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const as(obj: object, type: typename): pointer := nfc(8);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const as(obj: object, type: typename): pointer := nfc(8);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedNoInit: int64[7];
		static arrArrayNoInit: int64[*];
		static arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedNoInit;
		static arrSliceInitFixed: int64[] := arrFixedNoInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(const values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, const values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, const values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, const values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const as(obj: object, type: typename): pointer := nfc(8);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14634 bytes: <@0586f4> - <@05c01e>)
	lib/std/string.ci:144: (14 bytes: <@0586f4> - <@058702>): static const whiteSpace: char[] := " \t\n\r"
	<.main @0586f4>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @0586f9>    : 1f 85 91 02 00             load.ref <@029185> ;" \t\n\r"
	<.main+10 @0586fe>   : 2d 90 6d 05                store.m64 <@056d90> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@058702> - <@058710>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @058702>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @058707>   : 1f 96 91 02 00             load.ref <@029196> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @05870c>   : 2d 98 6d 05                store.m64 <@056d98> ;append.radixDigits
	lib/std/string.ci:262: (24 bytes: <@058710> - <@058728>): static const format: FormatFlags := {...}
	<.main+28 @058710>   : 19                         load.z32
	<.main+29 @058711>   : 1f 50 71 05 00             load.ref <@057150> ;append.format
	<.main+34 @058716>   : 25                         store.i8
	:: (5 bytes: <@058717> - <@05871c>): void(format.precision := 0)
	<.main+35 @058717>   : 19                         load.z32
	<.main+36 @058718>   : 2e 54 71 05                store.m32 <@057154> ;append.format+4
	:: (7 bytes: <@05871c> - <@058723>): void(format.padChr := (0))
	<.main+40 @05871c>   : 19                         load.z32
	<.main+41 @05871d>   : 1f 58 71 05 00             load.ref <@057158> ;append.format+8
	<.main+46 @058722>   : 25                         store.i8
	:: (5 bytes: <@058723> - <@058728>): void(format.padLen := 0)
	<.main+47 @058723>   : 19                         load.z32
	<.main+48 @058724>   : 2e 5c 71 05                store.m32 <@05715c> ;append.format+12
	test/lang/emit.ci:3: (5 bytes: <@058728> - <@05872d>): static emitldz32: int32 := emit(load.z32)
	<.main+52 @058728>   : 19                         load.z32
	<.main+53 @058729>   : 2e a0 71 05                store.m32 <@0571a0> ;emitldz32
	test/lang/emit.ci:4: (5 bytes: <@05872d> - <@058732>): static emitldz64: int64 := emit(load.z64)
	<.main+57 @05872d>   : 1a                         load.z64
	<.main+58 @05872e>   : 2d a8 71 05                store.m64 <@0571a8> ;emitldz64
	test/lang/emit.ci:6: (9 bytes: <@058732> - <@05873b>): static emitA: int32 := 42
	<.main+62 @058732>   : 1c 2a 00 00 00             load.c32 42
	<.main+67 @058737>   : 2e b0 71 05                store.m32 <@0571b0> ;emitA
	test/lang/emit.ci:7: (9 bytes: <@05873b> - <@058744>): static emitB: int32 := 96
	<.main+71 @05873b>   : 1c 60 00 00 00             load.c32 96
	<.main+76 @058740>   : 2e b8 71 05                store.m32 <@0571b8> ;emitB
	test/lang/emit.ci:9: (13 bytes: <@058744> - <@058751>): static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+80 @058744>   : 2a b0 71 05                load.m32 <@0571b0> ;emitA
	<.main+84 @058748>   : 2a b8 71 05                load.m32 <@0571b8> ;emitB
	<.main+88 @05874c>   : 51                         add.i32
	<.main+89 @05874d>   : 2e c0 71 05                store.m32 <@0571c0> ;emitAddI32
	test/lang/emit.ci:10: (15 bytes: <@058751> - <@058760>): static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+93 @058751>   : 1c 0a 00 00 00             load.c32 10
	<.main+98 @058756>   : 1c 05 00 00 00             load.c32 5
	<.main+103 @05875b>  : 54                         div.i32
	<.main+104 @05875c>  : 2e c8 71 05                store.m32 <@0571c8> ;emitDivI32
	test/lang/emit.ci:17: (9 bytes: <@058760> - <@058769>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+108 @058760>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+113 @058765>  : 2e d0 71 05                store.m32 <@0571d0> ;emitFloatAsInt1
	test/lang/emit.ci:18: (10 bytes: <@058769> - <@058773>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+117 @058769>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+122 @05876e>  : 5b                         i32.2i64
	<.main+123 @05876f>  : 2d d8 71 05                store.m64 <@0571d8> ;emitFloatAsInt2
	test/lang/emit.ci:19: (14 bytes: <@058773> - <@058781>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+127 @058773>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+136 @05877c>  : 6a                         i64.2i32
	<.main+137 @05877d>  : 2e e0 71 05                store.m32 <@0571e0> ;emitFloatAsInt3
	test/lang/emit.ci:20: (13 bytes: <@058781> - <@05878e>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+141 @058781>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+150 @05878a>  : 2d e8 71 05                store.m64 <@0571e8> ;emitFloatAsInt4
	test/lang/emit.ci:23: (14 bytes: <@05878e> - <@05879c>): static emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+154 @05878e>  : 1c 03 00 00 00             load.c32 3
	<.main+159 @058793>  : 1f cc 0c 03 00             load.ref <@030ccc> ;"string"
	<.main+164 @058798>  : 2d f0 71 05                store.m64 <@0571f0> ;emitSlice
	test/lang/inlineMacros.ci:10: (9 bytes: <@05879c> - <@0587a5>): static i3: int32 := 3
	<.main+168 @05879c>  : 1c 03 00 00 00             load.c32 3
	<.main+173 @0587a1>  : 2e f8 71 05                store.m32 <@0571f8> ;i3
	test/lang/inlineMacros.ci:11: (9 bytes: <@0587a5> - <@0587ae>): static i6: int32 := 6
	<.main+177 @0587a5>  : 1c 06 00 00 00             load.c32 6
	<.main+182 @0587aa>  : 2e 00 72 05                store.m32 <@057200> ;i6
	test/lang/inlineMacros.ci:12: (9 bytes: <@0587ae> - <@0587b7>): static i2: int32 := 2
	<.main+186 @0587ae>  : 1c 02 00 00 00             load.c32 2
	<.main+191 @0587b3>  : 2e 08 72 05                store.m32 <@057208> ;i2
	test/lang/inlineMacros.ci:13: (9 bytes: <@0587b7> - <@0587c0>): static i8: int32 := 8
	<.main+195 @0587b7>  : 1c 08 00 00 00             load.c32 8
	<.main+200 @0587bc>  : 2e 10 72 05                store.m32 <@057210> ;i8
	test/lang/inlineMacros.ci:15: (5 bytes: <@0587c0> - <@0587c5>): static zeroVal: int32 := zero(void(3, 6))
	<.main+204 @0587c0>  : 19                         load.z32
	<.main+205 @0587c1>  : 2e 18 72 05                store.m32 <@057218> ;zeroVal
	test/lang/inlineMacros.ci:16: (5 bytes: <@0587c5> - <@0587ca>): static zeroVar: int32 := zero(void(i3, i6))
	<.main+209 @0587c5>  : 19                         load.z32
	<.main+210 @0587c6>  : 2e 20 72 05                store.m32 <@057220> ;zeroVar
	test/lang/inlineMacros.ci:17: (5 bytes: <@0587ca> - <@0587cf>): static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+214 @0587ca>  : 19                         load.z32
	<.main+215 @0587cb>  : 2e 28 72 05                store.m32 <@057228> ;zeroXpr
	test/lang/inlineMacros.ci:19: (9 bytes: <@0587cf> - <@0587d8>): static lastVal: int32 := last(void(3, 6))
	<.main+219 @0587cf>  : 1c 06 00 00 00             load.c32 6
	<.main+224 @0587d4>  : 2e 30 72 05                store.m32 <@057230> ;lastVal
	test/lang/inlineMacros.ci:20: (8 bytes: <@0587d8> - <@0587e0>): static lastVar: int32 := last(void(i3, i6))
	<.main+228 @0587d8>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+232 @0587dc>  : 2e 38 72 05                store.m32 <@057238> ;lastVar
	test/lang/inlineMacros.ci:21: (16 bytes: <@0587e0> - <@0587f0>): static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+236 @0587e0>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+240 @0587e4>  : 0c 01 00 00                inc.i32(+1)
	<.main+244 @0587e8>  : 0c ff ff ff                inc.i32(-1)
	<.main+248 @0587ec>  : 2e 40 72 05                store.m32 <@057240> ;lastXpr
	test/lang/inlineMacros.ci:23: (13 bytes: <@0587f0> - <@0587fd>): static sum2Val: int32 := sum(void(3, 6))
	<.main+252 @0587f0>  : 1c 03 00 00 00             load.c32 3
	<.main+257 @0587f5>  : 0c 06 00 00                inc.i32(+6)
	<.main+261 @0587f9>  : 2e 48 72 05                store.m32 <@057248> ;sum2Val
	test/lang/inlineMacros.ci:24: (13 bytes: <@0587fd> - <@05880a>): static sum2Var: int32 := sum(void(i3, i6))
	<.main+265 @0587fd>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+269 @058801>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+273 @058805>  : 51                         add.i32
	<.main+274 @058806>  : 2e 50 72 05                store.m32 <@057250> ;sum2Var
	test/lang/inlineMacros.ci:25: (25 bytes: <@05880a> - <@058823>): static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+278 @05880a>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+282 @05880e>  : 0c 01 00 00                inc.i32(+1)
	<.main+286 @058812>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+290 @058816>  : 0c 01 00 00                inc.i32(+1)
	<.main+294 @05881a>  : 51                         add.i32
	<.main+295 @05881b>  : 0c fe ff ff                inc.i32(-2)
	<.main+299 @05881f>  : 2e 58 72 05                store.m32 <@057258> ;sum2Xpr
	test/lang/inlineMacros.ci:27: (28 bytes: <@058823> - <@05883f>): static any2Val: int32 := any(void(3, 6))
	<.main+303 @058823>  : 1c 03 00 00 00             load.c32 3
	<.main+308 @058828>  : 10 00                      dup.x32 sp(0)
	<.main+310 @05882a>  : 06 0a 00 00                jz <.main+320 @058834>
	<.main+314 @05882e>  : 10 00                      dup.x32 sp(0)
	<.main+316 @058830>  : 04 09 00 00                jmp <.main+325 @058839>
	<.main+320 @058834>  : 1c 06 00 00 00             load.c32 6
	<.main+325 @058839>  : 13 01                      set.x32 sp(1)
	<.main+327 @05883b>  : 2e 60 72 05                store.m32 <@057260> ;any2Val
	test/lang/inlineMacros.ci:28: (26 bytes: <@05883f> - <@058859>): static any2Var: int32 := any(void(i3, i6))
	<.main+331 @05883f>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+335 @058843>  : 10 00                      dup.x32 sp(0)
	<.main+337 @058845>  : 06 0a 00 00                jz <.main+347 @05884f>
	<.main+341 @058849>  : 10 00                      dup.x32 sp(0)
	<.main+343 @05884b>  : 04 08 00 00                jmp <.main+351 @058853>
	<.main+347 @05884f>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+351 @058853>  : 13 01                      set.x32 sp(1)
	<.main+353 @058855>  : 2e 68 72 05                store.m32 <@057268> ;any2Var
	test/lang/inlineMacros.ci:29: (38 bytes: <@058859> - <@05887f>): static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+357 @058859>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+361 @05885d>  : 0c 01 00 00                inc.i32(+1)
	<.main+365 @058861>  : 10 00                      dup.x32 sp(0)
	<.main+367 @058863>  : 06 0a 00 00                jz <.main+377 @05886d>
	<.main+371 @058867>  : 10 00                      dup.x32 sp(0)
	<.main+373 @058869>  : 04 0c 00 00                jmp <.main+385 @058875>
	<.main+377 @05886d>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+381 @058871>  : 0c 01 00 00                inc.i32(+1)
	<.main+385 @058875>  : 13 01                      set.x32 sp(1)
	<.main+387 @058877>  : 0c ff ff ff                inc.i32(-1)
	<.main+391 @05887b>  : 2e 70 72 05                store.m32 <@057270> ;any2Xpr
	test/lang/inlineMacros.ci:31: (37 bytes: <@05887f> - <@0588a4>): static min2Val: int32 := min(void(3, 6))
	<.main+395 @05887f>  : 1c 03 00 00 00             load.c32 3
	<.main+400 @058884>  : 1c 06 00 00 00             load.c32 6
	<.main+405 @058889>  : 10 01                      dup.x32 sp(1)
	<.main+407 @05888b>  : 10 01                      dup.x32 sp(1)
	<.main+409 @05888d>  : 58                         clt.i32
	<.main+410 @05888e>  : 06 0a 00 00                jz <.main+420 @058898>
	<.main+414 @058892>  : 10 01                      dup.x32 sp(1)
	<.main+416 @058894>  : 04 06 00 00                jmp <.main+422 @05889a>
	<.main+420 @058898>  : 10 00                      dup.x32 sp(0)
	<.main+422 @05889a>  : 13 02                      set.x32 sp(2)
	<.main+424 @05889c>  : 09 fc ff ff                inc.sp(-4)
	<.main+428 @0588a0>  : 2e 78 72 05                store.m32 <@057278> ;min2Val
	test/lang/inlineMacros.ci:32: (35 bytes: <@0588a4> - <@0588c7>): static min2Var: int32 := min(void(i3, i6))
	<.main+432 @0588a4>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+436 @0588a8>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+440 @0588ac>  : 10 01                      dup.x32 sp(1)
	<.main+442 @0588ae>  : 10 01                      dup.x32 sp(1)
	<.main+444 @0588b0>  : 58                         clt.i32
	<.main+445 @0588b1>  : 06 0a 00 00                jz <.main+455 @0588bb>
	<.main+449 @0588b5>  : 10 01                      dup.x32 sp(1)
	<.main+451 @0588b7>  : 04 06 00 00                jmp <.main+457 @0588bd>
	<.main+455 @0588bb>  : 10 00                      dup.x32 sp(0)
	<.main+457 @0588bd>  : 13 02                      set.x32 sp(2)
	<.main+459 @0588bf>  : 09 fc ff ff                inc.sp(-4)
	<.main+463 @0588c3>  : 2e 80 72 05                store.m32 <@057280> ;min2Var
	test/lang/inlineMacros.ci:33: (47 bytes: <@0588c7> - <@0588f6>): static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+467 @0588c7>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+471 @0588cb>  : 0c 01 00 00                inc.i32(+1)
	<.main+475 @0588cf>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+479 @0588d3>  : 0c 01 00 00                inc.i32(+1)
	<.main+483 @0588d7>  : 10 01                      dup.x32 sp(1)
	<.main+485 @0588d9>  : 10 01                      dup.x32 sp(1)
	<.main+487 @0588db>  : 58                         clt.i32
	<.main+488 @0588dc>  : 06 0a 00 00                jz <.main+498 @0588e6>
	<.main+492 @0588e0>  : 10 01                      dup.x32 sp(1)
	<.main+494 @0588e2>  : 04 06 00 00                jmp <.main+500 @0588e8>
	<.main+498 @0588e6>  : 10 00                      dup.x32 sp(0)
	<.main+500 @0588e8>  : 13 02                      set.x32 sp(2)
	<.main+502 @0588ea>  : 09 fc ff ff                inc.sp(-4)
	<.main+506 @0588ee>  : 0c ff ff ff                inc.i32(-1)
	<.main+510 @0588f2>  : 2e 88 72 05                store.m32 <@057288> ;min2Xpr
	test/lang/inlineMacros.ci:35: (37 bytes: <@0588f6> - <@05891b>): static max2Val: int32 := max(void(3, 6))
	<.main+514 @0588f6>  : 1c 03 00 00 00             load.c32 3
	<.main+519 @0588fb>  : 1c 06 00 00 00             load.c32 6
	<.main+524 @058900>  : 10 01                      dup.x32 sp(1)
	<.main+526 @058902>  : 10 01                      dup.x32 sp(1)
	<.main+528 @058904>  : 59                         cgt.i32
	<.main+529 @058905>  : 06 0a 00 00                jz <.main+539 @05890f>
	<.main+533 @058909>  : 10 01                      dup.x32 sp(1)
	<.main+535 @05890b>  : 04 06 00 00                jmp <.main+541 @058911>
	<.main+539 @05890f>  : 10 00                      dup.x32 sp(0)
	<.main+541 @058911>  : 13 02                      set.x32 sp(2)
	<.main+543 @058913>  : 09 fc ff ff                inc.sp(-4)
	<.main+547 @058917>  : 2e 90 72 05                store.m32 <@057290> ;max2Val
	test/lang/inlineMacros.ci:36: (35 bytes: <@05891b> - <@05893e>): static max2Var: int32 := max(void(i3, i6))
	<.main+551 @05891b>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+555 @05891f>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+559 @058923>  : 10 01                      dup.x32 sp(1)
	<.main+561 @058925>  : 10 01                      dup.x32 sp(1)
	<.main+563 @058927>  : 59                         cgt.i32
	<.main+564 @058928>  : 06 0a 00 00                jz <.main+574 @058932>
	<.main+568 @05892c>  : 10 01                      dup.x32 sp(1)
	<.main+570 @05892e>  : 04 06 00 00                jmp <.main+576 @058934>
	<.main+574 @058932>  : 10 00                      dup.x32 sp(0)
	<.main+576 @058934>  : 13 02                      set.x32 sp(2)
	<.main+578 @058936>  : 09 fc ff ff                inc.sp(-4)
	<.main+582 @05893a>  : 2e 98 72 05                store.m32 <@057298> ;max2Var
	test/lang/inlineMacros.ci:37: (47 bytes: <@05893e> - <@05896d>): static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+586 @05893e>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+590 @058942>  : 0c 01 00 00                inc.i32(+1)
	<.main+594 @058946>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+598 @05894a>  : 0c 01 00 00                inc.i32(+1)
	<.main+602 @05894e>  : 10 01                      dup.x32 sp(1)
	<.main+604 @058950>  : 10 01                      dup.x32 sp(1)
	<.main+606 @058952>  : 59                         cgt.i32
	<.main+607 @058953>  : 06 0a 00 00                jz <.main+617 @05895d>
	<.main+611 @058957>  : 10 01                      dup.x32 sp(1)
	<.main+613 @058959>  : 04 06 00 00                jmp <.main+619 @05895f>
	<.main+617 @05895d>  : 10 00                      dup.x32 sp(0)
	<.main+619 @05895f>  : 13 02                      set.x32 sp(2)
	<.main+621 @058961>  : 09 fc ff ff                inc.sp(-4)
	<.main+625 @058965>  : 0c ff ff ff                inc.i32(-1)
	<.main+629 @058969>  : 2e a0 72 05                store.m32 <@0572a0> ;max2Xpr
	test/lang/inlineMacros.ci:41: (25 bytes: <@05896d> - <@058986>): static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+633 @05896d>  : 1c 03 00 00 00             load.c32 3
	<.main+638 @058972>  : 1c 06 00 00 00             load.c32 6
	<.main+643 @058977>  : 1c 02 00 00 00             load.c32 2
	<.main+648 @05897c>  : 0c 08 00 00                inc.i32(+8)
	<.main+652 @058980>  : 51                         add.i32
	<.main+653 @058981>  : 51                         add.i32
	<.main+654 @058982>  : 2e a8 72 05                store.m32 <@0572a8> ;sumRlVal
	test/lang/inlineMacros.ci:42: (21 bytes: <@058986> - <@05899b>): static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+658 @058986>  : 1c 03 00 00 00             load.c32 3
	<.main+663 @05898b>  : 0c 06 00 00                inc.i32(+6)
	<.main+667 @05898f>  : 0c 02 00 00                inc.i32(+2)
	<.main+671 @058993>  : 0c 08 00 00                inc.i32(+8)
	<.main+675 @058997>  : 2e b0 72 05                store.m32 <@0572b0> ;sumLrVal
	test/lang/inlineMacros.ci:43: (23 bytes: <@05899b> - <@0589b2>): static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+679 @05899b>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+683 @05899f>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+687 @0589a3>  : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+691 @0589a7>  : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+695 @0589ab>  : 51                         add.i32
	<.main+696 @0589ac>  : 51                         add.i32
	<.main+697 @0589ad>  : 51                         add.i32
	<.main+698 @0589ae>  : 2e b8 72 05                store.m32 <@0572b8> ;sumRlVar
	test/lang/inlineMacros.ci:44: (23 bytes: <@0589b2> - <@0589c9>): static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+702 @0589b2>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+706 @0589b6>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+710 @0589ba>  : 51                         add.i32
	<.main+711 @0589bb>  : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+715 @0589bf>  : 51                         add.i32
	<.main+716 @0589c0>  : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+720 @0589c4>  : 51                         add.i32
	<.main+721 @0589c5>  : 2e c0 72 05                store.m32 <@0572c0> ;sumLrVar
	test/lang/inlineMacros.ci:45: (43 bytes: <@0589c9> - <@0589f4>): static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+725 @0589c9>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+729 @0589cd>  : 0c 01 00 00                inc.i32(+1)
	<.main+733 @0589d1>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+737 @0589d5>  : 0c 01 00 00                inc.i32(+1)
	<.main+741 @0589d9>  : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+745 @0589dd>  : 0c 01 00 00                inc.i32(+1)
	<.main+749 @0589e1>  : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+753 @0589e5>  : 0c 01 00 00                inc.i32(+1)
	<.main+757 @0589e9>  : 51                         add.i32
	<.main+758 @0589ea>  : 51                         add.i32
	<.main+759 @0589eb>  : 51                         add.i32
	<.main+760 @0589ec>  : 0c fc ff ff                inc.i32(-4)
	<.main+764 @0589f0>  : 2e c8 72 05                store.m32 <@0572c8> ;sumRlXpr
	test/lang/inlineMacros.ci:46: (43 bytes: <@0589f4> - <@058a1f>): static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+768 @0589f4>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+772 @0589f8>  : 0c 01 00 00                inc.i32(+1)
	<.main+776 @0589fc>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+780 @058a00>  : 0c 01 00 00                inc.i32(+1)
	<.main+784 @058a04>  : 51                         add.i32
	<.main+785 @058a05>  : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+789 @058a09>  : 0c 01 00 00                inc.i32(+1)
	<.main+793 @058a0d>  : 51                         add.i32
	<.main+794 @058a0e>  : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+798 @058a12>  : 0c 01 00 00                inc.i32(+1)
	<.main+802 @058a16>  : 51                         add.i32
	<.main+803 @058a17>  : 0c fc ff ff                inc.i32(-4)
	<.main+807 @058a1b>  : 2e d0 72 05                store.m32 <@0572d0> ;sumLrXpr
	test/lang/inlineMacros.ci:50: (66 bytes: <@058a1f> - <@058a61>): static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+811 @058a1f>  : 1c 03 00 00 00             load.c32 3
	<.main+816 @058a24>  : 10 00                      dup.x32 sp(0)
	<.main+818 @058a26>  : 06 0a 00 00                jz <.main+828 @058a30>
	<.main+822 @058a2a>  : 10 00                      dup.x32 sp(0)
	<.main+824 @058a2c>  : 04 2f 00 00                jmp <.main+871 @058a5b>
	<.main+828 @058a30>  : 1c 06 00 00 00             load.c32 6
	<.main+833 @058a35>  : 10 00                      dup.x32 sp(0)
	<.main+835 @058a37>  : 06 0a 00 00                jz <.main+845 @058a41>
	<.main+839 @058a3b>  : 10 00                      dup.x32 sp(0)
	<.main+841 @058a3d>  : 04 1c 00 00                jmp <.main+869 @058a59>
	<.main+845 @058a41>  : 1c 02 00 00 00             load.c32 2
	<.main+850 @058a46>  : 10 00                      dup.x32 sp(0)
	<.main+852 @058a48>  : 06 0a 00 00                jz <.main+862 @058a52>
	<.main+856 @058a4c>  : 10 00                      dup.x32 sp(0)
	<.main+858 @058a4e>  : 04 09 00 00                jmp <.main+867 @058a57>
	<.main+862 @058a52>  : 1c 08 00 00 00             load.c32 8
	<.main+867 @058a57>  : 13 01                      set.x32 sp(1)
	<.main+869 @058a59>  : 13 01                      set.x32 sp(1)
	<.main+871 @058a5b>  : 13 01                      set.x32 sp(1)
	<.main+873 @058a5d>  : 2e d8 72 05                store.m32 <@0572d8> ;anyRlVal
	test/lang/inlineMacros.ci:51: (66 bytes: <@058a61> - <@058aa3>): static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+877 @058a61>  : 1c 03 00 00 00             load.c32 3
	<.main+882 @058a66>  : 10 00                      dup.x32 sp(0)
	<.main+884 @058a68>  : 06 0a 00 00                jz <.main+894 @058a72>
	<.main+888 @058a6c>  : 10 00                      dup.x32 sp(0)
	<.main+890 @058a6e>  : 04 09 00 00                jmp <.main+899 @058a77>
	<.main+894 @058a72>  : 1c 06 00 00 00             load.c32 6
	<.main+899 @058a77>  : 13 01                      set.x32 sp(1)
	<.main+901 @058a79>  : 10 00                      dup.x32 sp(0)
	<.main+903 @058a7b>  : 06 0a 00 00                jz <.main+913 @058a85>
	<.main+907 @058a7f>  : 10 00                      dup.x32 sp(0)
	<.main+909 @058a81>  : 04 09 00 00                jmp <.main+918 @058a8a>
	<.main+913 @058a85>  : 1c 02 00 00 00             load.c32 2
	<.main+918 @058a8a>  : 13 01                      set.x32 sp(1)
	<.main+920 @058a8c>  : 10 00                      dup.x32 sp(0)
	<.main+922 @058a8e>  : 06 0a 00 00                jz <.main+932 @058a98>
	<.main+926 @058a92>  : 10 00                      dup.x32 sp(0)
	<.main+928 @058a94>  : 04 09 00 00                jmp <.main+937 @058a9d>
	<.main+932 @058a98>  : 1c 08 00 00 00             load.c32 8
	<.main+937 @058a9d>  : 13 01                      set.x32 sp(1)
	<.main+939 @058a9f>  : 2e e0 72 05                store.m32 <@0572e0> ;anyLrVal
	test/lang/inlineMacros.ci:52: (62 bytes: <@058aa3> - <@058ae1>): static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+943 @058aa3>  : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+947 @058aa7>  : 10 00                      dup.x32 sp(0)
	<.main+949 @058aa9>  : 06 0a 00 00                jz <.main+959 @058ab3>
	<.main+953 @058aad>  : 10 00                      dup.x32 sp(0)
	<.main+955 @058aaf>  : 04 2c 00 00                jmp <.main+999 @058adb>
	<.main+959 @058ab3>  : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+963 @058ab7>  : 10 00                      dup.x32 sp(0)
	<.main+965 @058ab9>  : 06 0a 00 00                jz <.main+975 @058ac3>
	<.main+969 @058abd>  : 10 00                      dup.x32 sp(0)
	<.main+971 @058abf>  : 04 1a 00 00                jmp <.main+997 @058ad9>
	<.main+975 @058ac3>  : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+979 @058ac7>  : 10 00                      dup.x32 sp(0)
	<.main+981 @058ac9>  : 06 0a 00 00                jz <.main+991 @058ad3>
	<.main+985 @058acd>  : 10 00                      dup.x32 sp(0)
	<.main+987 @058acf>  : 04 08 00 00                jmp <.main+995 @058ad7>
	<.main+991 @058ad3>  : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+995 @058ad7>  : 13 01                      set.x32 sp(1)
	<.main+997 @058ad9>  : 13 01                      set.x32 sp(1)
	<.main+999 @058adb>  : 13 01                      set.x32 sp(1)
	<.main+1001 @058add> : 2e e8 72 05                store.m32 <@0572e8> ;anyRlVar
	test/lang/inlineMacros.ci:53: (62 bytes: <@058ae1> - <@058b1f>): static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+1005 @058ae1> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1009 @058ae5> : 10 00                      dup.x32 sp(0)
	<.main+1011 @058ae7> : 06 0a 00 00                jz <.main+1021 @058af1>
	<.main+1015 @058aeb> : 10 00                      dup.x32 sp(0)
	<.main+1017 @058aed> : 04 08 00 00                jmp <.main+1025 @058af5>
	<.main+1021 @058af1> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1025 @058af5> : 13 01                      set.x32 sp(1)
	<.main+1027 @058af7> : 10 00                      dup.x32 sp(0)
	<.main+1029 @058af9> : 06 0a 00 00                jz <.main+1039 @058b03>
	<.main+1033 @058afd> : 10 00                      dup.x32 sp(0)
	<.main+1035 @058aff> : 04 08 00 00                jmp <.main+1043 @058b07>
	<.main+1039 @058b03> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1043 @058b07> : 13 01                      set.x32 sp(1)
	<.main+1045 @058b09> : 10 00                      dup.x32 sp(0)
	<.main+1047 @058b0b> : 06 0a 00 00                jz <.main+1057 @058b15>
	<.main+1051 @058b0f> : 10 00                      dup.x32 sp(0)
	<.main+1053 @058b11> : 04 08 00 00                jmp <.main+1061 @058b19>
	<.main+1057 @058b15> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1061 @058b19> : 13 01                      set.x32 sp(1)
	<.main+1063 @058b1b> : 2e f0 72 05                store.m32 <@0572f0> ;anyLrVar
	test/lang/inlineMacros.ci:54: (82 bytes: <@058b1f> - <@058b71>): static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1067 @058b1f> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1071 @058b23> : 0c 01 00 00                inc.i32(+1)
	<.main+1075 @058b27> : 10 00                      dup.x32 sp(0)
	<.main+1077 @058b29> : 06 0a 00 00                jz <.main+1087 @058b33>
	<.main+1081 @058b2d> : 10 00                      dup.x32 sp(0)
	<.main+1083 @058b2f> : 04 38 00 00                jmp <.main+1139 @058b67>
	<.main+1087 @058b33> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1091 @058b37> : 0c 01 00 00                inc.i32(+1)
	<.main+1095 @058b3b> : 10 00                      dup.x32 sp(0)
	<.main+1097 @058b3d> : 06 0a 00 00                jz <.main+1107 @058b47>
	<.main+1101 @058b41> : 10 00                      dup.x32 sp(0)
	<.main+1103 @058b43> : 04 22 00 00                jmp <.main+1137 @058b65>
	<.main+1107 @058b47> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1111 @058b4b> : 0c 01 00 00                inc.i32(+1)
	<.main+1115 @058b4f> : 10 00                      dup.x32 sp(0)
	<.main+1117 @058b51> : 06 0a 00 00                jz <.main+1127 @058b5b>
	<.main+1121 @058b55> : 10 00                      dup.x32 sp(0)
	<.main+1123 @058b57> : 04 0c 00 00                jmp <.main+1135 @058b63>
	<.main+1127 @058b5b> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1131 @058b5f> : 0c 01 00 00                inc.i32(+1)
	<.main+1135 @058b63> : 13 01                      set.x32 sp(1)
	<.main+1137 @058b65> : 13 01                      set.x32 sp(1)
	<.main+1139 @058b67> : 13 01                      set.x32 sp(1)
	<.main+1141 @058b69> : 0c ff ff ff                inc.i32(-1)
	<.main+1145 @058b6d> : 2e f8 72 05                store.m32 <@0572f8> ;anyRlXpr
	test/lang/inlineMacros.ci:55: (82 bytes: <@058b71> - <@058bc3>): static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1149 @058b71> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1153 @058b75> : 0c 01 00 00                inc.i32(+1)
	<.main+1157 @058b79> : 10 00                      dup.x32 sp(0)
	<.main+1159 @058b7b> : 06 0a 00 00                jz <.main+1169 @058b85>
	<.main+1163 @058b7f> : 10 00                      dup.x32 sp(0)
	<.main+1165 @058b81> : 04 0c 00 00                jmp <.main+1177 @058b8d>
	<.main+1169 @058b85> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1173 @058b89> : 0c 01 00 00                inc.i32(+1)
	<.main+1177 @058b8d> : 13 01                      set.x32 sp(1)
	<.main+1179 @058b8f> : 10 00                      dup.x32 sp(0)
	<.main+1181 @058b91> : 06 0a 00 00                jz <.main+1191 @058b9b>
	<.main+1185 @058b95> : 10 00                      dup.x32 sp(0)
	<.main+1187 @058b97> : 04 0c 00 00                jmp <.main+1199 @058ba3>
	<.main+1191 @058b9b> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1195 @058b9f> : 0c 01 00 00                inc.i32(+1)
	<.main+1199 @058ba3> : 13 01                      set.x32 sp(1)
	<.main+1201 @058ba5> : 10 00                      dup.x32 sp(0)
	<.main+1203 @058ba7> : 06 0a 00 00                jz <.main+1213 @058bb1>
	<.main+1207 @058bab> : 10 00                      dup.x32 sp(0)
	<.main+1209 @058bad> : 04 0c 00 00                jmp <.main+1221 @058bb9>
	<.main+1213 @058bb1> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1217 @058bb5> : 0c 01 00 00                inc.i32(+1)
	<.main+1221 @058bb9> : 13 01                      set.x32 sp(1)
	<.main+1223 @058bbb> : 0c ff ff ff                inc.i32(-1)
	<.main+1227 @058bbf> : 2e 00 73 05                store.m32 <@057300> ;anyLrXpr
	test/lang/inlineMacros.ci:59: (93 bytes: <@058bc3> - <@058c20>): static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1231 @058bc3> : 1c 03 00 00 00             load.c32 3
	<.main+1236 @058bc8> : 1c 06 00 00 00             load.c32 6
	<.main+1241 @058bcd> : 1c 02 00 00 00             load.c32 2
	<.main+1246 @058bd2> : 1c 08 00 00 00             load.c32 8
	<.main+1251 @058bd7> : 10 01                      dup.x32 sp(1)
	<.main+1253 @058bd9> : 10 01                      dup.x32 sp(1)
	<.main+1255 @058bdb> : 58                         clt.i32
	<.main+1256 @058bdc> : 06 0a 00 00                jz <.main+1266 @058be6>
	<.main+1260 @058be0> : 10 01                      dup.x32 sp(1)
	<.main+1262 @058be2> : 04 06 00 00                jmp <.main+1268 @058be8>
	<.main+1266 @058be6> : 10 00                      dup.x32 sp(0)
	<.main+1268 @058be8> : 13 02                      set.x32 sp(2)
	<.main+1270 @058bea> : 09 fc ff ff                inc.sp(-4)
	<.main+1274 @058bee> : 10 01                      dup.x32 sp(1)
	<.main+1276 @058bf0> : 10 01                      dup.x32 sp(1)
	<.main+1278 @058bf2> : 58                         clt.i32
	<.main+1279 @058bf3> : 06 0a 00 00                jz <.main+1289 @058bfd>
	<.main+1283 @058bf7> : 10 01                      dup.x32 sp(1)
	<.main+1285 @058bf9> : 04 06 00 00                jmp <.main+1291 @058bff>
	<.main+1289 @058bfd> : 10 00                      dup.x32 sp(0)
	<.main+1291 @058bff> : 13 02                      set.x32 sp(2)
	<.main+1293 @058c01> : 09 fc ff ff                inc.sp(-4)
	<.main+1297 @058c05> : 10 01                      dup.x32 sp(1)
	<.main+1299 @058c07> : 10 01                      dup.x32 sp(1)
	<.main+1301 @058c09> : 58                         clt.i32
	<.main+1302 @058c0a> : 06 0a 00 00                jz <.main+1312 @058c14>
	<.main+1306 @058c0e> : 10 01                      dup.x32 sp(1)
	<.main+1308 @058c10> : 04 06 00 00                jmp <.main+1314 @058c16>
	<.main+1312 @058c14> : 10 00                      dup.x32 sp(0)
	<.main+1314 @058c16> : 13 02                      set.x32 sp(2)
	<.main+1316 @058c18> : 09 fc ff ff                inc.sp(-4)
	<.main+1320 @058c1c> : 2e 08 73 05                store.m32 <@057308> ;minRlVal
	test/lang/inlineMacros.ci:60: (93 bytes: <@058c20> - <@058c7d>): static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1324 @058c20> : 1c 03 00 00 00             load.c32 3
	<.main+1329 @058c25> : 1c 06 00 00 00             load.c32 6
	<.main+1334 @058c2a> : 10 01                      dup.x32 sp(1)
	<.main+1336 @058c2c> : 10 01                      dup.x32 sp(1)
	<.main+1338 @058c2e> : 58                         clt.i32
	<.main+1339 @058c2f> : 06 0a 00 00                jz <.main+1349 @058c39>
	<.main+1343 @058c33> : 10 01                      dup.x32 sp(1)
	<.main+1345 @058c35> : 04 06 00 00                jmp <.main+1351 @058c3b>
	<.main+1349 @058c39> : 10 00                      dup.x32 sp(0)
	<.main+1351 @058c3b> : 13 02                      set.x32 sp(2)
	<.main+1353 @058c3d> : 09 fc ff ff                inc.sp(-4)
	<.main+1357 @058c41> : 1c 02 00 00 00             load.c32 2
	<.main+1362 @058c46> : 10 01                      dup.x32 sp(1)
	<.main+1364 @058c48> : 10 01                      dup.x32 sp(1)
	<.main+1366 @058c4a> : 58                         clt.i32
	<.main+1367 @058c4b> : 06 0a 00 00                jz <.main+1377 @058c55>
	<.main+1371 @058c4f> : 10 01                      dup.x32 sp(1)
	<.main+1373 @058c51> : 04 06 00 00                jmp <.main+1379 @058c57>
	<.main+1377 @058c55> : 10 00                      dup.x32 sp(0)
	<.main+1379 @058c57> : 13 02                      set.x32 sp(2)
	<.main+1381 @058c59> : 09 fc ff ff                inc.sp(-4)
	<.main+1385 @058c5d> : 1c 08 00 00 00             load.c32 8
	<.main+1390 @058c62> : 10 01                      dup.x32 sp(1)
	<.main+1392 @058c64> : 10 01                      dup.x32 sp(1)
	<.main+1394 @058c66> : 58                         clt.i32
	<.main+1395 @058c67> : 06 0a 00 00                jz <.main+1405 @058c71>
	<.main+1399 @058c6b> : 10 01                      dup.x32 sp(1)
	<.main+1401 @058c6d> : 04 06 00 00                jmp <.main+1407 @058c73>
	<.main+1405 @058c71> : 10 00                      dup.x32 sp(0)
	<.main+1407 @058c73> : 13 02                      set.x32 sp(2)
	<.main+1409 @058c75> : 09 fc ff ff                inc.sp(-4)
	<.main+1413 @058c79> : 2e 10 73 05                store.m32 <@057310> ;minLrVal
	test/lang/inlineMacros.ci:61: (89 bytes: <@058c7d> - <@058cd6>): static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1417 @058c7d> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1421 @058c81> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1425 @058c85> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1429 @058c89> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1433 @058c8d> : 10 01                      dup.x32 sp(1)
	<.main+1435 @058c8f> : 10 01                      dup.x32 sp(1)
	<.main+1437 @058c91> : 58                         clt.i32
	<.main+1438 @058c92> : 06 0a 00 00                jz <.main+1448 @058c9c>
	<.main+1442 @058c96> : 10 01                      dup.x32 sp(1)
	<.main+1444 @058c98> : 04 06 00 00                jmp <.main+1450 @058c9e>
	<.main+1448 @058c9c> : 10 00                      dup.x32 sp(0)
	<.main+1450 @058c9e> : 13 02                      set.x32 sp(2)
	<.main+1452 @058ca0> : 09 fc ff ff                inc.sp(-4)
	<.main+1456 @058ca4> : 10 01                      dup.x32 sp(1)
	<.main+1458 @058ca6> : 10 01                      dup.x32 sp(1)
	<.main+1460 @058ca8> : 58                         clt.i32
	<.main+1461 @058ca9> : 06 0a 00 00                jz <.main+1471 @058cb3>
	<.main+1465 @058cad> : 10 01                      dup.x32 sp(1)
	<.main+1467 @058caf> : 04 06 00 00                jmp <.main+1473 @058cb5>
	<.main+1471 @058cb3> : 10 00                      dup.x32 sp(0)
	<.main+1473 @058cb5> : 13 02                      set.x32 sp(2)
	<.main+1475 @058cb7> : 09 fc ff ff                inc.sp(-4)
	<.main+1479 @058cbb> : 10 01                      dup.x32 sp(1)
	<.main+1481 @058cbd> : 10 01                      dup.x32 sp(1)
	<.main+1483 @058cbf> : 58                         clt.i32
	<.main+1484 @058cc0> : 06 0a 00 00                jz <.main+1494 @058cca>
	<.main+1488 @058cc4> : 10 01                      dup.x32 sp(1)
	<.main+1490 @058cc6> : 04 06 00 00                jmp <.main+1496 @058ccc>
	<.main+1494 @058cca> : 10 00                      dup.x32 sp(0)
	<.main+1496 @058ccc> : 13 02                      set.x32 sp(2)
	<.main+1498 @058cce> : 09 fc ff ff                inc.sp(-4)
	<.main+1502 @058cd2> : 2e 18 73 05                store.m32 <@057318> ;minRlVar
	test/lang/inlineMacros.ci:62: (89 bytes: <@058cd6> - <@058d2f>): static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1506 @058cd6> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1510 @058cda> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1514 @058cde> : 10 01                      dup.x32 sp(1)
	<.main+1516 @058ce0> : 10 01                      dup.x32 sp(1)
	<.main+1518 @058ce2> : 58                         clt.i32
	<.main+1519 @058ce3> : 06 0a 00 00                jz <.main+1529 @058ced>
	<.main+1523 @058ce7> : 10 01                      dup.x32 sp(1)
	<.main+1525 @058ce9> : 04 06 00 00                jmp <.main+1531 @058cef>
	<.main+1529 @058ced> : 10 00                      dup.x32 sp(0)
	<.main+1531 @058cef> : 13 02                      set.x32 sp(2)
	<.main+1533 @058cf1> : 09 fc ff ff                inc.sp(-4)
	<.main+1537 @058cf5> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1541 @058cf9> : 10 01                      dup.x32 sp(1)
	<.main+1543 @058cfb> : 10 01                      dup.x32 sp(1)
	<.main+1545 @058cfd> : 58                         clt.i32
	<.main+1546 @058cfe> : 06 0a 00 00                jz <.main+1556 @058d08>
	<.main+1550 @058d02> : 10 01                      dup.x32 sp(1)
	<.main+1552 @058d04> : 04 06 00 00                jmp <.main+1558 @058d0a>
	<.main+1556 @058d08> : 10 00                      dup.x32 sp(0)
	<.main+1558 @058d0a> : 13 02                      set.x32 sp(2)
	<.main+1560 @058d0c> : 09 fc ff ff                inc.sp(-4)
	<.main+1564 @058d10> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1568 @058d14> : 10 01                      dup.x32 sp(1)
	<.main+1570 @058d16> : 10 01                      dup.x32 sp(1)
	<.main+1572 @058d18> : 58                         clt.i32
	<.main+1573 @058d19> : 06 0a 00 00                jz <.main+1583 @058d23>
	<.main+1577 @058d1d> : 10 01                      dup.x32 sp(1)
	<.main+1579 @058d1f> : 04 06 00 00                jmp <.main+1585 @058d25>
	<.main+1583 @058d23> : 10 00                      dup.x32 sp(0)
	<.main+1585 @058d25> : 13 02                      set.x32 sp(2)
	<.main+1587 @058d27> : 09 fc ff ff                inc.sp(-4)
	<.main+1591 @058d2b> : 2e 20 73 05                store.m32 <@057320> ;minLrVar
	test/lang/inlineMacros.ci:63: (109 bytes: <@058d2f> - <@058d9c>): static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1595 @058d2f> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1599 @058d33> : 0c 01 00 00                inc.i32(+1)
	<.main+1603 @058d37> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1607 @058d3b> : 0c 01 00 00                inc.i32(+1)
	<.main+1611 @058d3f> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1615 @058d43> : 0c 01 00 00                inc.i32(+1)
	<.main+1619 @058d47> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1623 @058d4b> : 0c 01 00 00                inc.i32(+1)
	<.main+1627 @058d4f> : 10 01                      dup.x32 sp(1)
	<.main+1629 @058d51> : 10 01                      dup.x32 sp(1)
	<.main+1631 @058d53> : 58                         clt.i32
	<.main+1632 @058d54> : 06 0a 00 00                jz <.main+1642 @058d5e>
	<.main+1636 @058d58> : 10 01                      dup.x32 sp(1)
	<.main+1638 @058d5a> : 04 06 00 00                jmp <.main+1644 @058d60>
	<.main+1642 @058d5e> : 10 00                      dup.x32 sp(0)
	<.main+1644 @058d60> : 13 02                      set.x32 sp(2)
	<.main+1646 @058d62> : 09 fc ff ff                inc.sp(-4)
	<.main+1650 @058d66> : 10 01                      dup.x32 sp(1)
	<.main+1652 @058d68> : 10 01                      dup.x32 sp(1)
	<.main+1654 @058d6a> : 58                         clt.i32
	<.main+1655 @058d6b> : 06 0a 00 00                jz <.main+1665 @058d75>
	<.main+1659 @058d6f> : 10 01                      dup.x32 sp(1)
	<.main+1661 @058d71> : 04 06 00 00                jmp <.main+1667 @058d77>
	<.main+1665 @058d75> : 10 00                      dup.x32 sp(0)
	<.main+1667 @058d77> : 13 02                      set.x32 sp(2)
	<.main+1669 @058d79> : 09 fc ff ff                inc.sp(-4)
	<.main+1673 @058d7d> : 10 01                      dup.x32 sp(1)
	<.main+1675 @058d7f> : 10 01                      dup.x32 sp(1)
	<.main+1677 @058d81> : 58                         clt.i32
	<.main+1678 @058d82> : 06 0a 00 00                jz <.main+1688 @058d8c>
	<.main+1682 @058d86> : 10 01                      dup.x32 sp(1)
	<.main+1684 @058d88> : 04 06 00 00                jmp <.main+1690 @058d8e>
	<.main+1688 @058d8c> : 10 00                      dup.x32 sp(0)
	<.main+1690 @058d8e> : 13 02                      set.x32 sp(2)
	<.main+1692 @058d90> : 09 fc ff ff                inc.sp(-4)
	<.main+1696 @058d94> : 0c ff ff ff                inc.i32(-1)
	<.main+1700 @058d98> : 2e 28 73 05                store.m32 <@057328> ;minRlXpr
	test/lang/inlineMacros.ci:64: (109 bytes: <@058d9c> - <@058e09>): static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1704 @058d9c> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+1708 @058da0> : 0c 01 00 00                inc.i32(+1)
	<.main+1712 @058da4> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+1716 @058da8> : 0c 01 00 00                inc.i32(+1)
	<.main+1720 @058dac> : 10 01                      dup.x32 sp(1)
	<.main+1722 @058dae> : 10 01                      dup.x32 sp(1)
	<.main+1724 @058db0> : 58                         clt.i32
	<.main+1725 @058db1> : 06 0a 00 00                jz <.main+1735 @058dbb>
	<.main+1729 @058db5> : 10 01                      dup.x32 sp(1)
	<.main+1731 @058db7> : 04 06 00 00                jmp <.main+1737 @058dbd>
	<.main+1735 @058dbb> : 10 00                      dup.x32 sp(0)
	<.main+1737 @058dbd> : 13 02                      set.x32 sp(2)
	<.main+1739 @058dbf> : 09 fc ff ff                inc.sp(-4)
	<.main+1743 @058dc3> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+1747 @058dc7> : 0c 01 00 00                inc.i32(+1)
	<.main+1751 @058dcb> : 10 01                      dup.x32 sp(1)
	<.main+1753 @058dcd> : 10 01                      dup.x32 sp(1)
	<.main+1755 @058dcf> : 58                         clt.i32
	<.main+1756 @058dd0> : 06 0a 00 00                jz <.main+1766 @058dda>
	<.main+1760 @058dd4> : 10 01                      dup.x32 sp(1)
	<.main+1762 @058dd6> : 04 06 00 00                jmp <.main+1768 @058ddc>
	<.main+1766 @058dda> : 10 00                      dup.x32 sp(0)
	<.main+1768 @058ddc> : 13 02                      set.x32 sp(2)
	<.main+1770 @058dde> : 09 fc ff ff                inc.sp(-4)
	<.main+1774 @058de2> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+1778 @058de6> : 0c 01 00 00                inc.i32(+1)
	<.main+1782 @058dea> : 10 01                      dup.x32 sp(1)
	<.main+1784 @058dec> : 10 01                      dup.x32 sp(1)
	<.main+1786 @058dee> : 58                         clt.i32
	<.main+1787 @058def> : 06 0a 00 00                jz <.main+1797 @058df9>
	<.main+1791 @058df3> : 10 01                      dup.x32 sp(1)
	<.main+1793 @058df5> : 04 06 00 00                jmp <.main+1799 @058dfb>
	<.main+1797 @058df9> : 10 00                      dup.x32 sp(0)
	<.main+1799 @058dfb> : 13 02                      set.x32 sp(2)
	<.main+1801 @058dfd> : 09 fc ff ff                inc.sp(-4)
	<.main+1805 @058e01> : 0c ff ff ff                inc.i32(-1)
	<.main+1809 @058e05> : 2e 30 73 05                store.m32 <@057330> ;minLrXpr
	test/lang/inlineMacros.ci:68: (93 bytes: <@058e09> - <@058e66>): static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1813 @058e09> : 1c 03 00 00 00             load.c32 3
	<.main+1818 @058e0e> : 1c 06 00 00 00             load.c32 6
	<.main+1823 @058e13> : 1c 02 00 00 00             load.c32 2
	<.main+1828 @058e18> : 1c 08 00 00 00             load.c32 8
	<.main+1833 @058e1d> : 10 01                      dup.x32 sp(1)
	<.main+1835 @058e1f> : 10 01                      dup.x32 sp(1)
	<.main+1837 @058e21> : 59                         cgt.i32
	<.main+1838 @058e22> : 06 0a 00 00                jz <.main+1848 @058e2c>
	<.main+1842 @058e26> : 10 01                      dup.x32 sp(1)
	<.main+1844 @058e28> : 04 06 00 00                jmp <.main+1850 @058e2e>
	<.main+1848 @058e2c> : 10 00                      dup.x32 sp(0)
	<.main+1850 @058e2e> : 13 02                      set.x32 sp(2)
	<.main+1852 @058e30> : 09 fc ff ff                inc.sp(-4)
	<.main+1856 @058e34> : 10 01                      dup.x32 sp(1)
	<.main+1858 @058e36> : 10 01                      dup.x32 sp(1)
	<.main+1860 @058e38> : 59                         cgt.i32
	<.main+1861 @058e39> : 06 0a 00 00                jz <.main+1871 @058e43>
	<.main+1865 @058e3d> : 10 01                      dup.x32 sp(1)
	<.main+1867 @058e3f> : 04 06 00 00                jmp <.main+1873 @058e45>
	<.main+1871 @058e43> : 10 00                      dup.x32 sp(0)
	<.main+1873 @058e45> : 13 02                      set.x32 sp(2)
	<.main+1875 @058e47> : 09 fc ff ff                inc.sp(-4)
	<.main+1879 @058e4b> : 10 01                      dup.x32 sp(1)
	<.main+1881 @058e4d> : 10 01                      dup.x32 sp(1)
	<.main+1883 @058e4f> : 59                         cgt.i32
	<.main+1884 @058e50> : 06 0a 00 00                jz <.main+1894 @058e5a>
	<.main+1888 @058e54> : 10 01                      dup.x32 sp(1)
	<.main+1890 @058e56> : 04 06 00 00                jmp <.main+1896 @058e5c>
	<.main+1894 @058e5a> : 10 00                      dup.x32 sp(0)
	<.main+1896 @058e5c> : 13 02                      set.x32 sp(2)
	<.main+1898 @058e5e> : 09 fc ff ff                inc.sp(-4)
	<.main+1902 @058e62> : 2e 38 73 05                store.m32 <@057338> ;maxRlVal
	test/lang/inlineMacros.ci:69: (93 bytes: <@058e66> - <@058ec3>): static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1906 @058e66> : 1c 03 00 00 00             load.c32 3
	<.main+1911 @058e6b> : 1c 06 00 00 00             load.c32 6
	<.main+1916 @058e70> : 10 01                      dup.x32 sp(1)
	<.main+1918 @058e72> : 10 01                      dup.x32 sp(1)
	<.main+1920 @058e74> : 59                         cgt.i32
	<.main+1921 @058e75> : 06 0a 00 00                jz <.main+1931 @058e7f>
	<.main+1925 @058e79> : 10 01                      dup.x32 sp(1)
	<.main+1927 @058e7b> : 04 06 00 00                jmp <.main+1933 @058e81>
	<.main+1931 @058e7f> : 10 00                      dup.x32 sp(0)
	<.main+1933 @058e81> : 13 02                      set.x32 sp(2)
	<.main+1935 @058e83> : 09 fc ff ff                inc.sp(-4)
	<.main+1939 @058e87> : 1c 02 00 00 00             load.c32 2
	<.main+1944 @058e8c> : 10 01                      dup.x32 sp(1)
	<.main+1946 @058e8e> : 10 01                      dup.x32 sp(1)
	<.main+1948 @058e90> : 59                         cgt.i32
	<.main+1949 @058e91> : 06 0a 00 00                jz <.main+1959 @058e9b>
	<.main+1953 @058e95> : 10 01                      dup.x32 sp(1)
	<.main+1955 @058e97> : 04 06 00 00                jmp <.main+1961 @058e9d>
	<.main+1959 @058e9b> : 10 00                      dup.x32 sp(0)
	<.main+1961 @058e9d> : 13 02                      set.x32 sp(2)
	<.main+1963 @058e9f> : 09 fc ff ff                inc.sp(-4)
	<.main+1967 @058ea3> : 1c 08 00 00 00             load.c32 8
	<.main+1972 @058ea8> : 10 01                      dup.x32 sp(1)
	<.main+1974 @058eaa> : 10 01                      dup.x32 sp(1)
	<.main+1976 @058eac> : 59                         cgt.i32
	<.main+1977 @058ead> : 06 0a 00 00                jz <.main+1987 @058eb7>
	<.main+1981 @058eb1> : 10 01                      dup.x32 sp(1)
	<.main+1983 @058eb3> : 04 06 00 00                jmp <.main+1989 @058eb9>
	<.main+1987 @058eb7> : 10 00                      dup.x32 sp(0)
	<.main+1989 @058eb9> : 13 02                      set.x32 sp(2)
	<.main+1991 @058ebb> : 09 fc ff ff                inc.sp(-4)
	<.main+1995 @058ebf> : 2e 40 73 05                store.m32 <@057340> ;maxLrVal
	test/lang/inlineMacros.ci:70: (89 bytes: <@058ec3> - <@058f1c>): static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1999 @058ec3> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+2003 @058ec7> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+2007 @058ecb> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+2011 @058ecf> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+2015 @058ed3> : 10 01                      dup.x32 sp(1)
	<.main+2017 @058ed5> : 10 01                      dup.x32 sp(1)
	<.main+2019 @058ed7> : 59                         cgt.i32
	<.main+2020 @058ed8> : 06 0a 00 00                jz <.main+2030 @058ee2>
	<.main+2024 @058edc> : 10 01                      dup.x32 sp(1)
	<.main+2026 @058ede> : 04 06 00 00                jmp <.main+2032 @058ee4>
	<.main+2030 @058ee2> : 10 00                      dup.x32 sp(0)
	<.main+2032 @058ee4> : 13 02                      set.x32 sp(2)
	<.main+2034 @058ee6> : 09 fc ff ff                inc.sp(-4)
	<.main+2038 @058eea> : 10 01                      dup.x32 sp(1)
	<.main+2040 @058eec> : 10 01                      dup.x32 sp(1)
	<.main+2042 @058eee> : 59                         cgt.i32
	<.main+2043 @058eef> : 06 0a 00 00                jz <.main+2053 @058ef9>
	<.main+2047 @058ef3> : 10 01                      dup.x32 sp(1)
	<.main+2049 @058ef5> : 04 06 00 00                jmp <.main+2055 @058efb>
	<.main+2053 @058ef9> : 10 00                      dup.x32 sp(0)
	<.main+2055 @058efb> : 13 02                      set.x32 sp(2)
	<.main+2057 @058efd> : 09 fc ff ff                inc.sp(-4)
	<.main+2061 @058f01> : 10 01                      dup.x32 sp(1)
	<.main+2063 @058f03> : 10 01                      dup.x32 sp(1)
	<.main+2065 @058f05> : 59                         cgt.i32
	<.main+2066 @058f06> : 06 0a 00 00                jz <.main+2076 @058f10>
	<.main+2070 @058f0a> : 10 01                      dup.x32 sp(1)
	<.main+2072 @058f0c> : 04 06 00 00                jmp <.main+2078 @058f12>
	<.main+2076 @058f10> : 10 00                      dup.x32 sp(0)
	<.main+2078 @058f12> : 13 02                      set.x32 sp(2)
	<.main+2080 @058f14> : 09 fc ff ff                inc.sp(-4)
	<.main+2084 @058f18> : 2e 48 73 05                store.m32 <@057348> ;maxRlVar
	test/lang/inlineMacros.ci:71: (89 bytes: <@058f1c> - <@058f75>): static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+2088 @058f1c> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+2092 @058f20> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+2096 @058f24> : 10 01                      dup.x32 sp(1)
	<.main+2098 @058f26> : 10 01                      dup.x32 sp(1)
	<.main+2100 @058f28> : 59                         cgt.i32
	<.main+2101 @058f29> : 06 0a 00 00                jz <.main+2111 @058f33>
	<.main+2105 @058f2d> : 10 01                      dup.x32 sp(1)
	<.main+2107 @058f2f> : 04 06 00 00                jmp <.main+2113 @058f35>
	<.main+2111 @058f33> : 10 00                      dup.x32 sp(0)
	<.main+2113 @058f35> : 13 02                      set.x32 sp(2)
	<.main+2115 @058f37> : 09 fc ff ff                inc.sp(-4)
	<.main+2119 @058f3b> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+2123 @058f3f> : 10 01                      dup.x32 sp(1)
	<.main+2125 @058f41> : 10 01                      dup.x32 sp(1)
	<.main+2127 @058f43> : 59                         cgt.i32
	<.main+2128 @058f44> : 06 0a 00 00                jz <.main+2138 @058f4e>
	<.main+2132 @058f48> : 10 01                      dup.x32 sp(1)
	<.main+2134 @058f4a> : 04 06 00 00                jmp <.main+2140 @058f50>
	<.main+2138 @058f4e> : 10 00                      dup.x32 sp(0)
	<.main+2140 @058f50> : 13 02                      set.x32 sp(2)
	<.main+2142 @058f52> : 09 fc ff ff                inc.sp(-4)
	<.main+2146 @058f56> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+2150 @058f5a> : 10 01                      dup.x32 sp(1)
	<.main+2152 @058f5c> : 10 01                      dup.x32 sp(1)
	<.main+2154 @058f5e> : 59                         cgt.i32
	<.main+2155 @058f5f> : 06 0a 00 00                jz <.main+2165 @058f69>
	<.main+2159 @058f63> : 10 01                      dup.x32 sp(1)
	<.main+2161 @058f65> : 04 06 00 00                jmp <.main+2167 @058f6b>
	<.main+2165 @058f69> : 10 00                      dup.x32 sp(0)
	<.main+2167 @058f6b> : 13 02                      set.x32 sp(2)
	<.main+2169 @058f6d> : 09 fc ff ff                inc.sp(-4)
	<.main+2173 @058f71> : 2e 50 73 05                store.m32 <@057350> ;maxLrVar
	test/lang/inlineMacros.ci:72: (109 bytes: <@058f75> - <@058fe2>): static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2177 @058f75> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+2181 @058f79> : 0c 01 00 00                inc.i32(+1)
	<.main+2185 @058f7d> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+2189 @058f81> : 0c 01 00 00                inc.i32(+1)
	<.main+2193 @058f85> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+2197 @058f89> : 0c 01 00 00                inc.i32(+1)
	<.main+2201 @058f8d> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+2205 @058f91> : 0c 01 00 00                inc.i32(+1)
	<.main+2209 @058f95> : 10 01                      dup.x32 sp(1)
	<.main+2211 @058f97> : 10 01                      dup.x32 sp(1)
	<.main+2213 @058f99> : 59                         cgt.i32
	<.main+2214 @058f9a> : 06 0a 00 00                jz <.main+2224 @058fa4>
	<.main+2218 @058f9e> : 10 01                      dup.x32 sp(1)
	<.main+2220 @058fa0> : 04 06 00 00                jmp <.main+2226 @058fa6>
	<.main+2224 @058fa4> : 10 00                      dup.x32 sp(0)
	<.main+2226 @058fa6> : 13 02                      set.x32 sp(2)
	<.main+2228 @058fa8> : 09 fc ff ff                inc.sp(-4)
	<.main+2232 @058fac> : 10 01                      dup.x32 sp(1)
	<.main+2234 @058fae> : 10 01                      dup.x32 sp(1)
	<.main+2236 @058fb0> : 59                         cgt.i32
	<.main+2237 @058fb1> : 06 0a 00 00                jz <.main+2247 @058fbb>
	<.main+2241 @058fb5> : 10 01                      dup.x32 sp(1)
	<.main+2243 @058fb7> : 04 06 00 00                jmp <.main+2249 @058fbd>
	<.main+2247 @058fbb> : 10 00                      dup.x32 sp(0)
	<.main+2249 @058fbd> : 13 02                      set.x32 sp(2)
	<.main+2251 @058fbf> : 09 fc ff ff                inc.sp(-4)
	<.main+2255 @058fc3> : 10 01                      dup.x32 sp(1)
	<.main+2257 @058fc5> : 10 01                      dup.x32 sp(1)
	<.main+2259 @058fc7> : 59                         cgt.i32
	<.main+2260 @058fc8> : 06 0a 00 00                jz <.main+2270 @058fd2>
	<.main+2264 @058fcc> : 10 01                      dup.x32 sp(1)
	<.main+2266 @058fce> : 04 06 00 00                jmp <.main+2272 @058fd4>
	<.main+2270 @058fd2> : 10 00                      dup.x32 sp(0)
	<.main+2272 @058fd4> : 13 02                      set.x32 sp(2)
	<.main+2274 @058fd6> : 09 fc ff ff                inc.sp(-4)
	<.main+2278 @058fda> : 0c ff ff ff                inc.i32(-1)
	<.main+2282 @058fde> : 2e 58 73 05                store.m32 <@057358> ;maxRlXpr
	test/lang/inlineMacros.ci:73: (109 bytes: <@058fe2> - <@05904f>): static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2286 @058fe2> : 2a f8 71 05                load.m32 <@0571f8> ;i3
	<.main+2290 @058fe6> : 0c 01 00 00                inc.i32(+1)
	<.main+2294 @058fea> : 2a 00 72 05                load.m32 <@057200> ;i6
	<.main+2298 @058fee> : 0c 01 00 00                inc.i32(+1)
	<.main+2302 @058ff2> : 10 01                      dup.x32 sp(1)
	<.main+2304 @058ff4> : 10 01                      dup.x32 sp(1)
	<.main+2306 @058ff6> : 59                         cgt.i32
	<.main+2307 @058ff7> : 06 0a 00 00                jz <.main+2317 @059001>
	<.main+2311 @058ffb> : 10 01                      dup.x32 sp(1)
	<.main+2313 @058ffd> : 04 06 00 00                jmp <.main+2319 @059003>
	<.main+2317 @059001> : 10 00                      dup.x32 sp(0)
	<.main+2319 @059003> : 13 02                      set.x32 sp(2)
	<.main+2321 @059005> : 09 fc ff ff                inc.sp(-4)
	<.main+2325 @059009> : 2a 08 72 05                load.m32 <@057208> ;i2
	<.main+2329 @05900d> : 0c 01 00 00                inc.i32(+1)
	<.main+2333 @059011> : 10 01                      dup.x32 sp(1)
	<.main+2335 @059013> : 10 01                      dup.x32 sp(1)
	<.main+2337 @059015> : 59                         cgt.i32
	<.main+2338 @059016> : 06 0a 00 00                jz <.main+2348 @059020>
	<.main+2342 @05901a> : 10 01                      dup.x32 sp(1)
	<.main+2344 @05901c> : 04 06 00 00                jmp <.main+2350 @059022>
	<.main+2348 @059020> : 10 00                      dup.x32 sp(0)
	<.main+2350 @059022> : 13 02                      set.x32 sp(2)
	<.main+2352 @059024> : 09 fc ff ff                inc.sp(-4)
	<.main+2356 @059028> : 2a 10 72 05                load.m32 <@057210> ;i8
	<.main+2360 @05902c> : 0c 01 00 00                inc.i32(+1)
	<.main+2364 @059030> : 10 01                      dup.x32 sp(1)
	<.main+2366 @059032> : 10 01                      dup.x32 sp(1)
	<.main+2368 @059034> : 59                         cgt.i32
	<.main+2369 @059035> : 06 0a 00 00                jz <.main+2379 @05903f>
	<.main+2373 @059039> : 10 01                      dup.x32 sp(1)
	<.main+2375 @05903b> : 04 06 00 00                jmp <.main+2381 @059041>
	<.main+2379 @05903f> : 10 00                      dup.x32 sp(0)
	<.main+2381 @059041> : 13 02                      set.x32 sp(2)
	<.main+2383 @059043> : 09 fc ff ff                inc.sp(-4)
	<.main+2387 @059047> : 0c ff ff ff                inc.i32(-1)
	<.main+2391 @05904b> : 2e 60 73 05                store.m32 <@057360> ;maxLrXpr
	test/lang/overload.inline.ci:9: (9 bytes: <@05904f> - <@059058>): static overload1: float32 := overload
	<.main+2395 @05904f> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2400 @059054> : 2e 68 73 05                store.m32 <@057368> ;overload1
	test/lang/overload.inline.ci:10: (9 bytes: <@059058> - <@059061>): static overload2: float32 := overload()
	<.main+2404 @059058> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2409 @05905d> : 2e 70 73 05                store.m32 <@057370> ;overload2
	test/lang/overload.inline.ci:11: (9 bytes: <@059061> - <@05906a>): static overload3: float32 := overload(0)
	<.main+2413 @059061> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2418 @059066> : 2e 78 73 05                store.m32 <@057378> ;overload3
	test/lang/overload.inline.ci:12: (9 bytes: <@05906a> - <@059073>): static overload4: float32 := overload(0.000000)
	<.main+2422 @05906a> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2427 @05906f> : 2e 80 73 05                store.m32 <@057380> ;overload4
	test/lang/overload.inline.ci:13: (9 bytes: <@059073> - <@05907c>): static overload5: float32 := overload(void(0, 0))
	<.main+2431 @059073> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2436 @059078> : 2e 88 73 05                store.m32 <@057388> ;overload5
	test/lang/overload.inline.ci:28: (13 bytes: <@05907c> - <@059089>): static boilC: Celsius := Celsius(100.000000)
	<.main+2440 @05907c> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2449 @059085> : 2d 90 73 05                store.m64 <@057390> ;boilC
	test/lang/overload.inline.ci:29: (28 bytes: <@059089> - <@0590a5>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2453 @059089> : 2b 90 73 05                load.m64 <@057390> ;boilC
	<.main+2457 @05908d> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2466 @059096> : 83                         mul.f64
	<.main+2467 @059097> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2476 @0590a0> : 81                         add.f64
	<.main+2477 @0590a1> : 2d 98 73 05                store.m64 <@057398> ;boilF
	test/lang/initByRef.ci:7: (13 bytes: <@0590a5> - <@0590b2>): static value: int64 := 42
	<.main+2481 @0590a5> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+2490 @0590ae> : 2d a0 73 05                store.m64 <@0573a0> ;value
	test/lang/initByRef.ci:8: (9 bytes: <@0590b2> - <@0590bb>): static valueRef: int64 := value
	<.main+2494 @0590b2> : 1f a0 73 05 00             load.ref <@0573a0> ;value
	<.main+2499 @0590b7> : 2e a8 73 05                store.m32 <@0573a8> ;valueRef
	test/lang/initByRef.ci:9: (9 bytes: <@0590bb> - <@0590c4>): static valuePtr: pointer := value
	<.main+2503 @0590bb> : 1f a0 73 05 00             load.ref <@0573a0> ;value
	<.main+2508 @0590c0> : 2e b0 73 05                store.m32 <@0573b0> ;valuePtr
	test/lang/initByRef.ci:10: (14 bytes: <@0590c4> - <@0590d2>): static valueVar: variant := value
	<.main+2512 @0590c4> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2517 @0590c9> : 1f a0 73 05 00             load.ref <@0573a0> ;value
	<.main+2522 @0590ce> : 2d b8 73 05                store.m64 <@0573b8> ;valueVar
	test/lang/initByRef.ci:12: (9 bytes: <@0590d2> - <@0590db>): static fromRef: int64 := valueRef
	<.main+2526 @0590d2> : 2a a8 73 05                load.m32 <@0573a8> ;valueRef
	<.main+2530 @0590d6> : 23                         load.i64
	<.main+2531 @0590d7> : 2d c0 73 05                store.m64 <@0573c0> ;fromRef
	test/lang/initByRef.ci:13: (8 bytes: <@0590db> - <@0590e3>): static fromPtr: int64 := valuePtr
	<.main+2535 @0590db> : 2a b0 73 05                load.m32 <@0573b0> ;valuePtr
	<.main+2539 @0590df> : 2e c8 73 05                store.m32 <@0573c8> ;fromPtr
	test/lang/initByRef.ci:14: (8 bytes: <@0590e3> - <@0590eb>): static fromVar: int64 := valueVar
	<.main+2543 @0590e3> : 2a b8 73 05                load.m32 <@0573b8> ;valueVar
	<.main+2547 @0590e7> : 2e d0 73 05                store.m32 <@0573d0> ;fromVar
	test/lang/initByRef.ci:16: (9 bytes: <@0590eb> - <@0590f4>): static nullRef: int64 := null
	<.main+2551 @0590eb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2556 @0590f0> : 2e d8 73 05                store.m32 <@0573d8> ;nullRef
	test/lang/initByRef.ci:17: (9 bytes: <@0590f4> - <@0590fd>): static nullPtr: pointer := null
	<.main+2560 @0590f4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2565 @0590f9> : 2e e0 73 05                store.m32 <@0573e0> ;nullPtr
	test/lang/initByRef.ci:18: (14 bytes: <@0590fd> - <@05910b>): static nullVar: variant := null
	<.main+2569 @0590fd> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2574 @059102> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2579 @059107> : 2d e8 73 05                store.m64 <@0573e8> ;nullVar
	test/lang/initByRef.ci:19: (9 bytes: <@05910b> - <@059114>): static nullTyp: typename := null
	<.main+2583 @05910b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2588 @059110> : 2e f0 73 05                store.m32 <@0573f0> ;nullTyp
	test/lang/initByRef.ci:20: (9 bytes: <@059114> - <@05911d>): static nullFun: function := null
	<.main+2592 @059114> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2597 @059119> : 2e f8 73 05                store.m32 <@0573f8> ;nullFun
	test/lang/initByRef.ci:21: (9 bytes: <@05911d> - <@059126>): static nullObj: object := null
	<.main+2601 @05911d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2606 @059122> : 2e 00 74 05                store.m32 <@057400> ;nullObj
	test/lang/initByRef.ci:23: (9 bytes: <@059126> - <@05912f>): static typePtr: pointer := int64
	<.main+2610 @059126> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2615 @05912b> : 2e 08 74 05                store.m32 <@057408> ;typePtr
	test/lang/initByRef.ci:24: (14 bytes: <@05912f> - <@05913d>): static typeVar: variant := int64
	<.main+2619 @05912f> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2624 @059134> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2629 @059139> : 2d 10 74 05                store.m64 <@057410> ;typeVar
	test/lang/initByRef.ci:25: (9 bytes: <@05913d> - <@059146>): static typeTyp: typename := int64
	<.main+2633 @05913d> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2638 @059142> : 2e 18 74 05                store.m32 <@057418> ;typeTyp
	test/lang/initByRef.ci:27: (8 bytes: <@059146> - <@05914e>): static local: int64 := value
	<.main+2642 @059146> : 2b a0 73 05                load.m64 <@0573a0> ;value
	<.main+2646 @05914a> : 2d 20 74 05                store.m64 <@057420> ;local
	test/lang/initByRef.ci:28: (8 bytes: <@05914e> - <@059156>): static copyVal: int64 := local
	<.main+2650 @05914e> : 2b 20 74 05                load.m64 <@057420> ;local
	<.main+2654 @059152> : 2d 28 74 05                store.m64 <@057428> ;copyVal
	test/lang/initByRef.ci:29: (8 bytes: <@059156> - <@05915e>): static copyRef: int64 := valueRef
	<.main+2658 @059156> : 2a a8 73 05                load.m32 <@0573a8> ;valueRef
	<.main+2662 @05915a> : 2e 30 74 05                store.m32 <@057430> ;copyRef
	test/lang/initByRef.ci:30: (8 bytes: <@05915e> - <@059166>): static copyPtr: pointer := valuePtr
	<.main+2666 @05915e> : 2a b0 73 05                load.m32 <@0573b0> ;valuePtr
	<.main+2670 @059162> : 2e 38 74 05                store.m32 <@057438> ;copyPtr
	test/lang/initByRef.ci:31: (8 bytes: <@059166> - <@05916e>): static copyVar: variant := valueVar
	<.main+2674 @059166> : 2b b8 73 05                load.m64 <@0573b8> ;valueVar
	<.main+2678 @05916a> : 2d 40 74 05                store.m64 <@057440> ;copyVar
	test/lang/initByRef.ci:32: (8 bytes: <@05916e> - <@059176>): static copyTyp: typename := typeTyp
	<.main+2682 @05916e> : 2a 18 74 05                load.m32 <@057418> ;typeTyp
	<.main+2686 @059172> : 2e 48 74 05                store.m32 <@057448> ;copyTyp
	test/lang/initByRef.ci:35: (9 bytes: <@059176> - <@05917f>): static ptrVoid: pointer := void
	<.main+2690 @059176> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2695 @05917b> : 2e 50 74 05                store.m32 <@057450> ;ptrVoid
	test/lang/initByRef.ci:36: (9 bytes: <@05917f> - <@059188>): static ptrBool: pointer := bool
	<.main+2699 @05917f> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2704 @059184> : 2e 58 74 05                store.m32 <@057458> ;ptrBool
	test/lang/initByRef.ci:37: (9 bytes: <@059188> - <@059191>): static ptrChar: pointer := char
	<.main+2708 @059188> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2713 @05918d> : 2e 60 74 05                store.m32 <@057460> ;ptrChar
	test/lang/initByRef.ci:38: (9 bytes: <@059191> - <@05919a>): static ptrInt8: pointer := int8
	<.main+2717 @059191> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2722 @059196> : 2e 68 74 05                store.m32 <@057468> ;ptrInt8
	test/lang/initByRef.ci:39: (9 bytes: <@05919a> - <@0591a3>): static ptrInt16: pointer := int16
	<.main+2726 @05919a> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2731 @05919f> : 2e 70 74 05                store.m32 <@057470> ;ptrInt16
	test/lang/initByRef.ci:40: (9 bytes: <@0591a3> - <@0591ac>): static ptrInt32: pointer := int32
	<.main+2735 @0591a3> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2740 @0591a8> : 2e 78 74 05                store.m32 <@057478> ;ptrInt32
	test/lang/initByRef.ci:41: (9 bytes: <@0591ac> - <@0591b5>): static ptrInt64: pointer := int64
	<.main+2744 @0591ac> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2749 @0591b1> : 2e 80 74 05                store.m32 <@057480> ;ptrInt64
	test/lang/initByRef.ci:42: (9 bytes: <@0591b5> - <@0591be>): static ptrUint8: pointer := uint8
	<.main+2753 @0591b5> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2758 @0591ba> : 2e 88 74 05                store.m32 <@057488> ;ptrUint8
	test/lang/initByRef.ci:43: (9 bytes: <@0591be> - <@0591c7>): static ptrUint16: pointer := uint16
	<.main+2762 @0591be> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2767 @0591c3> : 2e 90 74 05                store.m32 <@057490> ;ptrUint16
	test/lang/initByRef.ci:44: (9 bytes: <@0591c7> - <@0591d0>): static ptrUint32: pointer := uint32
	<.main+2771 @0591c7> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2776 @0591cc> : 2e 98 74 05                store.m32 <@057498> ;ptrUint32
	test/lang/initByRef.ci:45: (9 bytes: <@0591d0> - <@0591d9>): static ptrUint64: pointer := uint64
	<.main+2780 @0591d0> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+2785 @0591d5> : 2e a0 74 05                store.m32 <@0574a0> ;ptrUint64
	test/lang/initByRef.ci:46: (9 bytes: <@0591d9> - <@0591e2>): static ptrFloat32: pointer := float32
	<.main+2789 @0591d9> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+2794 @0591de> : 2e a8 74 05                store.m32 <@0574a8> ;ptrFloat32
	test/lang/initByRef.ci:47: (9 bytes: <@0591e2> - <@0591eb>): static ptrFloat64: pointer := float64
	<.main+2798 @0591e2> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+2803 @0591e7> : 2e b0 74 05                store.m32 <@0574b0> ;ptrFloat64
	test/lang/initByRef.ci:48: (9 bytes: <@0591eb> - <@0591f4>): static ptrTypename: pointer := typename
	<.main+2807 @0591eb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2812 @0591f0> : 2e b8 74 05                store.m32 <@0574b8> ;ptrTypename
	test/lang/initByRef.ci:49: (9 bytes: <@0591f4> - <@0591fd>): static ptrFunction: pointer := function
	<.main+2816 @0591f4> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+2821 @0591f9> : 2e c0 74 05                store.m32 <@0574c0> ;ptrFunction
	test/lang/initByRef.ci:50: (9 bytes: <@0591fd> - <@059206>): static ptrPointer: pointer := pointer
	<.main+2825 @0591fd> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2830 @059202> : 2e c8 74 05                store.m32 <@0574c8> ;ptrPointer
	test/lang/initByRef.ci:51: (9 bytes: <@059206> - <@05920f>): static ptrVariant: pointer := variant
	<.main+2834 @059206> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+2839 @05920b> : 2e d0 74 05                store.m32 <@0574d0> ;ptrVariant
	test/lang/initByRef.ci:52: (9 bytes: <@05920f> - <@059218>): static ptrObject: pointer := object
	<.main+2843 @05920f> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+2848 @059214> : 2e d8 74 05                store.m32 <@0574d8> ;ptrObject
	test/lang/initByRef.ci:55: (14 bytes: <@059218> - <@059226>): static varVoid: variant := void
	<.main+2852 @059218> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2857 @05921d> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2862 @059222> : 2d e0 74 05                store.m64 <@0574e0> ;varVoid
	test/lang/initByRef.ci:56: (14 bytes: <@059226> - <@059234>): static varBool: variant := bool
	<.main+2866 @059226> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2871 @05922b> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2876 @059230> : 2d e8 74 05                store.m64 <@0574e8> ;varBool
	test/lang/initByRef.ci:57: (14 bytes: <@059234> - <@059242>): static varChar: variant := char
	<.main+2880 @059234> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2885 @059239> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2890 @05923e> : 2d f0 74 05                store.m64 <@0574f0> ;varChar
	test/lang/initByRef.ci:58: (14 bytes: <@059242> - <@059250>): static varInt8: variant := int8
	<.main+2894 @059242> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2899 @059247> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2904 @05924c> : 2d f8 74 05                store.m64 <@0574f8> ;varInt8
	test/lang/initByRef.ci:59: (14 bytes: <@059250> - <@05925e>): static varInt16: variant := int16
	<.main+2908 @059250> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2913 @059255> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2918 @05925a> : 2d 00 75 05                store.m64 <@057500> ;varInt16
	test/lang/initByRef.ci:60: (14 bytes: <@05925e> - <@05926c>): static varInt32: variant := int32
	<.main+2922 @05925e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2927 @059263> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2932 @059268> : 2d 08 75 05                store.m64 <@057508> ;varInt32
	test/lang/initByRef.ci:61: (14 bytes: <@05926c> - <@05927a>): static varInt64: variant := int64
	<.main+2936 @05926c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2941 @059271> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2946 @059276> : 2d 10 75 05                store.m64 <@057510> ;varInt64
	test/lang/initByRef.ci:62: (14 bytes: <@05927a> - <@059288>): static varUint8: variant := uint8
	<.main+2950 @05927a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2955 @05927f> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2960 @059284> : 2d 18 75 05                store.m64 <@057518> ;varUint8
	test/lang/initByRef.ci:63: (14 bytes: <@059288> - <@059296>): static varUint16: variant := uint16
	<.main+2964 @059288> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2969 @05928d> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2974 @059292> : 2d 20 75 05                store.m64 <@057520> ;varUint16
	test/lang/initByRef.ci:64: (14 bytes: <@059296> - <@0592a4>): static varUint32: variant := uint32
	<.main+2978 @059296> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2983 @05929b> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2988 @0592a0> : 2d 28 75 05                store.m64 <@057528> ;varUint32
	test/lang/initByRef.ci:65: (14 bytes: <@0592a4> - <@0592b2>): static varUint64: variant := uint64
	<.main+2992 @0592a4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2997 @0592a9> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3002 @0592ae> : 2d 30 75 05                store.m64 <@057530> ;varUint64
	test/lang/initByRef.ci:66: (14 bytes: <@0592b2> - <@0592c0>): static varFloat32: variant := float32
	<.main+3006 @0592b2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3011 @0592b7> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3016 @0592bc> : 2d 38 75 05                store.m64 <@057538> ;varFloat32
	test/lang/initByRef.ci:67: (14 bytes: <@0592c0> - <@0592ce>): static varFloat64: variant := float64
	<.main+3020 @0592c0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3025 @0592c5> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3030 @0592ca> : 2d 40 75 05                store.m64 <@057540> ;varFloat64
	test/lang/initByRef.ci:68: (14 bytes: <@0592ce> - <@0592dc>): static varTypename: variant := typename
	<.main+3034 @0592ce> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3039 @0592d3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3044 @0592d8> : 2d 48 75 05                store.m64 <@057548> ;varTypename
	test/lang/initByRef.ci:69: (14 bytes: <@0592dc> - <@0592ea>): static varFunction: variant := function
	<.main+3048 @0592dc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3053 @0592e1> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3058 @0592e6> : 2d 50 75 05                store.m64 <@057550> ;varFunction
	test/lang/initByRef.ci:70: (14 bytes: <@0592ea> - <@0592f8>): static varPointer: variant := pointer
	<.main+3062 @0592ea> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3067 @0592ef> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3072 @0592f4> : 2d 58 75 05                store.m64 <@057558> ;varPointer
	test/lang/initByRef.ci:71: (14 bytes: <@0592f8> - <@059306>): static varVariant: variant := variant
	<.main+3076 @0592f8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3081 @0592fd> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3086 @059302> : 2d 60 75 05                store.m64 <@057560> ;varVariant
	test/lang/initByRef.ci:72: (14 bytes: <@059306> - <@059314>): static varObject: variant := object
	<.main+3090 @059306> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3095 @05930b> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3100 @059310> : 2d 68 75 05                store.m64 <@057568> ;varObject
	test/lang/initByRef.ci:75: (9 bytes: <@059314> - <@05931d>): static typVoid: typename := void
	<.main+3104 @059314> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3109 @059319> : 2e 70 75 05                store.m32 <@057570> ;typVoid
	test/lang/initByRef.ci:76: (9 bytes: <@05931d> - <@059326>): static typBool: typename := bool
	<.main+3113 @05931d> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3118 @059322> : 2e 78 75 05                store.m32 <@057578> ;typBool
	test/lang/initByRef.ci:77: (9 bytes: <@059326> - <@05932f>): static typChar: typename := char
	<.main+3122 @059326> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3127 @05932b> : 2e 80 75 05                store.m32 <@057580> ;typChar
	test/lang/initByRef.ci:78: (9 bytes: <@05932f> - <@059338>): static typInt8: typename := int8
	<.main+3131 @05932f> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+3136 @059334> : 2e 88 75 05                store.m32 <@057588> ;typInt8
	test/lang/initByRef.ci:79: (9 bytes: <@059338> - <@059341>): static typInt16: typename := int16
	<.main+3140 @059338> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+3145 @05933d> : 2e 90 75 05                store.m32 <@057590> ;typInt16
	test/lang/initByRef.ci:80: (9 bytes: <@059341> - <@05934a>): static typInt32: typename := int32
	<.main+3149 @059341> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+3154 @059346> : 2e 98 75 05                store.m32 <@057598> ;typInt32
	test/lang/initByRef.ci:81: (9 bytes: <@05934a> - <@059353>): static typInt64: typename := int64
	<.main+3158 @05934a> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3163 @05934f> : 2e a0 75 05                store.m32 <@0575a0> ;typInt64
	test/lang/initByRef.ci:82: (9 bytes: <@059353> - <@05935c>): static typUint8: typename := uint8
	<.main+3167 @059353> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+3172 @059358> : 2e a8 75 05                store.m32 <@0575a8> ;typUint8
	test/lang/initByRef.ci:83: (9 bytes: <@05935c> - <@059365>): static typUint16: typename := uint16
	<.main+3176 @05935c> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+3181 @059361> : 2e b0 75 05                store.m32 <@0575b0> ;typUint16
	test/lang/initByRef.ci:84: (9 bytes: <@059365> - <@05936e>): static typUint32: typename := uint32
	<.main+3185 @059365> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+3190 @05936a> : 2e b8 75 05                store.m32 <@0575b8> ;typUint32
	test/lang/initByRef.ci:85: (9 bytes: <@05936e> - <@059377>): static typUint64: typename := uint64
	<.main+3194 @05936e> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3199 @059373> : 2e c0 75 05                store.m32 <@0575c0> ;typUint64
	test/lang/initByRef.ci:86: (9 bytes: <@059377> - <@059380>): static typFloat32: typename := float32
	<.main+3203 @059377> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3208 @05937c> : 2e c8 75 05                store.m32 <@0575c8> ;typFloat32
	test/lang/initByRef.ci:87: (9 bytes: <@059380> - <@059389>): static typFloat64: typename := float64
	<.main+3212 @059380> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3217 @059385> : 2e d0 75 05                store.m32 <@0575d0> ;typFloat64
	test/lang/initByRef.ci:88: (9 bytes: <@059389> - <@059392>): static typTypename: typename := typename
	<.main+3221 @059389> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3226 @05938e> : 2e d8 75 05                store.m32 <@0575d8> ;typTypename
	test/lang/initByRef.ci:89: (9 bytes: <@059392> - <@05939b>): static typFunction: typename := function
	<.main+3230 @059392> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3235 @059397> : 2e e0 75 05                store.m32 <@0575e0> ;typFunction
	test/lang/initByRef.ci:90: (9 bytes: <@05939b> - <@0593a4>): static typPointer: typename := pointer
	<.main+3239 @05939b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3244 @0593a0> : 2e e8 75 05                store.m32 <@0575e8> ;typPointer
	test/lang/initByRef.ci:91: (9 bytes: <@0593a4> - <@0593ad>): static typVariant: typename := variant
	<.main+3248 @0593a4> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3253 @0593a9> : 2e f0 75 05                store.m32 <@0575f0> ;typVariant
	test/lang/initByRef.ci:92: (9 bytes: <@0593ad> - <@0593b6>): static typObject: typename := object
	<.main+3257 @0593ad> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3262 @0593b2> : 2e f8 75 05                store.m32 <@0575f8> ;typObject
	test/lang/initByRef.ci:95: (9 bytes: <@0593b6> - <@0593bf>): static valueOfPtr: pointer := pointer(value)
	<.main+3266 @0593b6> : 1f a0 73 05 00             load.ref <@0573a0> ;value
	<.main+3271 @0593bb> : 2e 00 76 05                store.m32 <@057600> ;valueOfPtr
	test/lang/initByRef.ci:96: (14 bytes: <@0593bf> - <@0593cd>): static valueOfVar: variant := variant(value)
	<.main+3275 @0593bf> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3280 @0593c4> : 1f a0 73 05 00             load.ref <@0573a0> ;value
	<.main+3285 @0593c9> : 2d 08 76 05                store.m64 <@057608> ;valueOfVar
	test/lang/initByRef.ci:97: (9 bytes: <@0593cd> - <@0593d6>): static valueOfTyp: typename := typename(value)
	<.main+3289 @0593cd> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3294 @0593d2> : 2e 10 76 05                store.m32 <@057610> ;valueOfTyp
	test/lang/initByRef.ci:99: (9 bytes: <@0593d6> - <@0593df>): static typeOfValue: typename := typename(value)
	<.main+3298 @0593d6> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3303 @0593db> : 2e 18 76 05                store.m32 <@057618> ;typeOfValue
	test/lang/initByRef.ci:105: (13 bytes: <@0593df> - <@0593ec>): static copyPtrFloat64: variant := ptrFloat64
	<.main+3307 @0593df> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3312 @0593e4> : 2a b0 74 05                load.m32 <@0574b0> ;ptrFloat64
	<.main+3316 @0593e8> : 2d 20 76 05                store.m64 <@057620> ;copyPtrFloat64
	test/lang/initByRef.ci:108: (8 bytes: <@0593ec> - <@0593f4>): static copyVarFloat64: pointer := varFloat64
	<.main+3320 @0593ec> : 2a 40 75 05                load.m32 <@057540> ;varFloat64
	<.main+3324 @0593f0> : 2e 28 76 05                store.m32 <@057628> ;copyVarFloat64
	test/lang/function.ci:12: (25 bytes: <@0593f4> - <@05940d>): static funAddResult: int32 := funAdd(void(2, 7))
	<.main+3328 @0593f4> : 19                         load.z32
	<.main+3329 @0593f5> : 1c 02 00 00 00             load.c32 2
	<.main+3334 @0593fa> : 1c 07 00 00 00             load.c32 7
	<.main+3339 @0593ff> : 1f 38 76 05 00             load.ref <@057638> ;funAdd(x: int32, y: int32): int32
	<.main+3344 @059404> : 02                         call
	<.main+3345 @059405> : 09 f8 ff ff                inc.sp(-8)
	<.main+3349 @059409> : 2e 40 76 05                store.m32 <@057640> ;funAddResult
	test/lang/function.ci:15: (9 bytes: <@05940d> - <@059416>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+3353 @05940d> : 1f 38 76 05 00             load.ref <@057638> ;funAdd(x: int32, y: int32): int32
	<.main+3358 @059412> : 2e 48 76 05                store.m32 <@057648> ;funAddRef(x: int32, y: int32): int32
	test/lang/function.ci:18: (24 bytes: <@059416> - <@05942e>): static funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+3362 @059416> : 19                         load.z32
	<.main+3363 @059417> : 1c 02 00 00 00             load.c32 2
	<.main+3368 @05941c> : 1c 08 00 00 00             load.c32 8
	<.main+3373 @059421> : 2a 48 76 05                load.m32 <@057648> ;funAddRef(x: int32, y: int32): int32
	<.main+3377 @059425> : 02                         call
	<.main+3378 @059426> : 09 f8 ff ff                inc.sp(-8)
	<.main+3382 @05942a> : 2e 50 76 05                store.m32 <@057650> ;funAddRefResult
	test/lang/function.ci:21: (9 bytes: <@05942e> - <@059437>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+3386 @05942e> : 1f 78 76 05 00             load.ref <@057678> ;funMul(x: int32, y: int32): int32
	<.main+3391 @059433> : 2e 58 76 05                store.m32 <@057658> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (24 bytes: <@059437> - <@05944f>): static funMulResult: int32 := funMul(void(2, 6))
	<.main+3395 @059437> : 19                         load.z32
	<.main+3396 @059438> : 1c 02 00 00 00             load.c32 2
	<.main+3401 @05943d> : 1c 06 00 00 00             load.c32 6
	<.main+3406 @059442> : 2a 58 76 05                load.m32 <@057658> ;funMul(x: int32, y: int32): int32
	<.main+3410 @059446> : 02                         call
	<.main+3411 @059447> : 09 f8 ff ff                inc.sp(-8)
	<.main+3415 @05944b> : 2e 60 76 05                store.m32 <@057660> ;funMulResult
	test/lang/function.ci:27: (8 bytes: <@05944f> - <@059457>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+3419 @05944f> : 2a 58 76 05                load.m32 <@057658> ;funMul(x: int32, y: int32): int32
	<.main+3423 @059453> : 2e 68 76 05                store.m32 <@057668> ;funMulRef(x: int32, y: int32): int32
	test/lang/function.ci:30: (24 bytes: <@059457> - <@05946f>): static funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+3427 @059457> : 19                         load.z32
	<.main+3428 @059458> : 1c 02 00 00 00             load.c32 2
	<.main+3433 @05945d> : 1c 07 00 00 00             load.c32 7
	<.main+3438 @059462> : 2a 68 76 05                load.m32 <@057668> ;funMulRef(x: int32, y: int32): int32
	<.main+3442 @059466> : 02                         call
	<.main+3443 @059467> : 09 f8 ff ff                inc.sp(-8)
	<.main+3447 @05946b> : 2e 70 76 05                store.m32 <@057670> ;funMulRefResult
	test/lang/function.ci:46: (20 bytes: <@05946f> - <@059483>): static fibonacci_13: uint32 := fib(13)
	<.main+3451 @05946f> : 19                         load.z32
	<.main+3452 @059470> : 1c 0d 00 00 00             load.c32 13
	<.main+3457 @059475> : 1f 80 76 05 00             load.ref <@057680> ;fib(n: uint32): uint32
	<.main+3462 @05947a> : 02                         call
	<.main+3463 @05947b> : 09 fc ff ff                inc.sp(-4)
	<.main+3467 @05947f> : 2e b8 76 05                store.m32 <@0576b8> ;fibonacci_13
	test/lang/reflect.ci:3: (8 bytes: <@059483> - <@05948b>): static sizeofVoid: int32 := sizeof(void)
	<.main+3471 @059483> : 2a d0 00 00                load.m32 <@0000d0>
	<.main+3475 @059487> : 2e c0 76 05                store.m32 <@0576c0> ;sizeofVoid
	test/lang/reflect.ci:4: (8 bytes: <@05948b> - <@059493>): static sizeofBool: int32 := sizeof(bool)
	<.main+3479 @05948b> : 2a 70 01 00                load.m32 <@000170>
	<.main+3483 @05948f> : 2e c8 76 05                store.m32 <@0576c8> ;sizeofBool
	test/lang/reflect.ci:5: (8 bytes: <@059493> - <@05949b>): static sizeofChar: int32 := sizeof(char)
	<.main+3487 @059493> : 2a 10 02 00                load.m32 <@000210>
	<.main+3491 @059497> : 2e d0 76 05                store.m32 <@0576d0> ;sizeofChar
	test/lang/reflect.ci:6: (8 bytes: <@05949b> - <@0594a3>): static sizeofInt8: int32 := sizeof(int8)
	<.main+3495 @05949b> : 2a b0 02 00                load.m32 <@0002b0>
	<.main+3499 @05949f> : 2e d8 76 05                store.m32 <@0576d8> ;sizeofInt8
	test/lang/reflect.ci:7: (8 bytes: <@0594a3> - <@0594ab>): static sizeofInt16: int32 := sizeof(int16)
	<.main+3503 @0594a3> : 2a 50 03 00                load.m32 <@000350>
	<.main+3507 @0594a7> : 2e e0 76 05                store.m32 <@0576e0> ;sizeofInt16
	test/lang/reflect.ci:8: (8 bytes: <@0594ab> - <@0594b3>): static sizeofInt32: int32 := sizeof(int32)
	<.main+3511 @0594ab> : 2a f0 03 00                load.m32 <@0003f0>
	<.main+3515 @0594af> : 2e e8 76 05                store.m32 <@0576e8> ;sizeofInt32
	test/lang/reflect.ci:9: (8 bytes: <@0594b3> - <@0594bb>): static sizeofInt64: int32 := sizeof(int64)
	<.main+3519 @0594b3> : 2a 90 04 00                load.m32 <@000490>
	<.main+3523 @0594b7> : 2e f0 76 05                store.m32 <@0576f0> ;sizeofInt64
	test/lang/reflect.ci:10: (8 bytes: <@0594bb> - <@0594c3>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+3527 @0594bb> : 2a 30 05 00                load.m32 <@000530>
	<.main+3531 @0594bf> : 2e f8 76 05                store.m32 <@0576f8> ;sizeofUint8
	test/lang/reflect.ci:11: (8 bytes: <@0594c3> - <@0594cb>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+3535 @0594c3> : 2a d0 05 00                load.m32 <@0005d0>
	<.main+3539 @0594c7> : 2e 00 77 05                store.m32 <@057700> ;sizeofUint16
	test/lang/reflect.ci:12: (8 bytes: <@0594cb> - <@0594d3>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+3543 @0594cb> : 2a 70 06 00                load.m32 <@000670>
	<.main+3547 @0594cf> : 2e 08 77 05                store.m32 <@057708> ;sizeofUint32
	test/lang/reflect.ci:13: (8 bytes: <@0594d3> - <@0594db>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+3551 @0594d3> : 2a 10 07 00                load.m32 <@000710>
	<.main+3555 @0594d7> : 2e 10 77 05                store.m32 <@057710> ;sizeofUint64
	test/lang/reflect.ci:14: (8 bytes: <@0594db> - <@0594e3>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+3559 @0594db> : 2a b0 07 00                load.m32 <@0007b0>
	<.main+3563 @0594df> : 2e 18 77 05                store.m32 <@057718> ;sizeofFloat32
	test/lang/reflect.ci:15: (8 bytes: <@0594e3> - <@0594eb>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+3567 @0594e3> : 2a 50 08 00                load.m32 <@000850>
	<.main+3571 @0594e7> : 2e 20 77 05                store.m32 <@057720> ;sizeofFloat64
	test/lang/reflect.ci:16: (8 bytes: <@0594eb> - <@0594f3>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+3575 @0594eb> : 2a f0 08 00                load.m32 <@0008f0>
	<.main+3579 @0594ef> : 2e 28 77 05                store.m32 <@057728> ;sizeofPointer
	test/lang/reflect.ci:17: (8 bytes: <@0594f3> - <@0594fb>): static sizeofVariant: int32 := sizeof(variant)
	<.main+3583 @0594f3> : 2a 90 09 00                load.m32 <@000990>
	<.main+3587 @0594f7> : 2e 30 77 05                store.m32 <@057730> ;sizeofVariant
	test/lang/reflect.ci:18: (8 bytes: <@0594fb> - <@059503>): static sizeofTypename: int32 := sizeof(typename)
	<.main+3591 @0594fb> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	<.main+3595 @0594ff> : 2e 38 77 05                store.m32 <@057738> ;sizeofTypename
	test/lang/reflect.ci:19: (8 bytes: <@059503> - <@05950b>): static sizeofFunction: int32 := sizeof(function)
	<.main+3599 @059503> : 2a 30 0a 00                load.m32 <@000a30>
	<.main+3603 @059507> : 2e 40 77 05                store.m32 <@057740> ;sizeofFunction
	test/lang/reflect.ci:20: (8 bytes: <@05950b> - <@059513>): static sizeofObject: int32 := sizeof(object)
	<.main+3607 @05950b> : 2a d8 0a 00                load.m32 <@000ad8>
	<.main+3611 @05950f> : 2e 48 77 05                store.m32 <@057748> ;sizeofObject
	test/lang/reflect.ci:30: (9 bytes: <@059513> - <@05951c>): static typeofRecord: typename := RecordSizeofExt
	<.main+3615 @059513> : 1f 58 cb 03 00             load.ref <@03cb58> ;RecordSizeofExt
	<.main+3620 @059518> : 2e 50 77 05                store.m32 <@057750> ;typeofRecord
	test/lang/reflect.ci:31: (12 bytes: <@05951c> - <@059528>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+3624 @05951c> : 2a 50 77 05                load.m32 <@057750> ;typeofRecord
	<.main+3628 @059520> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3632 @059524> : 2e 58 77 05                store.m32 <@057758> ;nameOfRecord
	test/lang/reflect.ci:32: (13 bytes: <@059528> - <@059535>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+3636 @059528> : 2a 50 77 05                load.m32 <@057750> ;typeofRecord
	<.main+3640 @05952c> : 0c 28 00 00                inc.i32(+40)
	<.main+3644 @059530> : 22                         load.i32
	<.main+3645 @059531> : 2e 60 77 05                store.m32 <@057760> ;offsetOfRecord
	test/lang/reflect.ci:33: (13 bytes: <@059535> - <@059542>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+3649 @059535> : 2a 50 77 05                load.m32 <@057750> ;typeofRecord
	<.main+3653 @059539> : 0c 20 00 00                inc.i32(+32)
	<.main+3657 @05953d> : 22                         load.i32
	<.main+3658 @05953e> : 2e 68 77 05                store.m32 <@057768> ;sizeOfRecord
	test/lang/reflect.ci:34: (12 bytes: <@059542> - <@05954e>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+3662 @059542> : 2a 50 77 05                load.m32 <@057750> ;typeofRecord
	<.main+3666 @059546> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3670 @05954a> : 2e 70 77 05                store.m32 <@057770> ;fileOfRecord
	test/lang/reflect.ci:35: (12 bytes: <@05954e> - <@05955a>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+3674 @05954e> : 2a 50 77 05                load.m32 <@057750> ;typeofRecord
	<.main+3678 @059552> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3682 @059556> : 2e 78 77 05                store.m32 <@057778> ;lineOfRecord
	test/lang/reflect.ci:37: (12 bytes: <@05955a> - <@059566>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+3686 @05955a> : 2a 50 77 05                load.m32 <@057750> ;typeofRecord
	<.main+3690 @05955e> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3694 @059562> : 2e 80 77 05                store.m32 <@057780> ;typeofBase
	test/lang/reflect.ci:38: (12 bytes: <@059566> - <@059572>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+3698 @059566> : 2a 80 77 05                load.m32 <@057780> ;typeofBase
	<.main+3702 @05956a> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3706 @05956e> : 2e 88 77 05                store.m32 <@057788> ;nameOfBase
	test/lang/reflect.ci:39: (13 bytes: <@059572> - <@05957f>): static offsetOfBase: int32 := typeofBase.offset
	<.main+3710 @059572> : 2a 80 77 05                load.m32 <@057780> ;typeofBase
	<.main+3714 @059576> : 0c 28 00 00                inc.i32(+40)
	<.main+3718 @05957a> : 22                         load.i32
	<.main+3719 @05957b> : 2e 90 77 05                store.m32 <@057790> ;offsetOfBase
	test/lang/reflect.ci:40: (13 bytes: <@05957f> - <@05958c>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+3723 @05957f> : 2a 80 77 05                load.m32 <@057780> ;typeofBase
	<.main+3727 @059583> : 0c 20 00 00                inc.i32(+32)
	<.main+3731 @059587> : 22                         load.i32
	<.main+3732 @059588> : 2e 98 77 05                store.m32 <@057798> ;sizeOfBase
	test/lang/reflect.ci:41: (12 bytes: <@05958c> - <@059598>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+3736 @05958c> : 2a 80 77 05                load.m32 <@057780> ;typeofBase
	<.main+3740 @059590> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3744 @059594> : 2e a0 77 05                store.m32 <@0577a0> ;fileOfBase
	test/lang/reflect.ci:42: (12 bytes: <@059598> - <@0595a4>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+3748 @059598> : 2a 80 77 05                load.m32 <@057780> ;typeofBase
	<.main+3752 @05959c> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3756 @0595a0> : 2e a8 77 05                store.m32 <@0577a8> ;lineOfBase
	test/lang/reflect.ci:44: (12 bytes: <@0595a4> - <@0595b0>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+3760 @0595a4> : 2a 80 77 05                load.m32 <@057780> ;typeofBase
	<.main+3764 @0595a8> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3768 @0595ac> : 2e b0 77 05                store.m32 <@0577b0> ;typeofBase1
	test/lang/reflect.ci:45: (13 bytes: <@0595b0> - <@0595bd>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+3772 @0595b0> : 2a b0 77 05                load.m32 <@0577b0> ;typeofBase1
	<.main+3776 @0595b4> : 0c 28 00 00                inc.i32(+40)
	<.main+3780 @0595b8> : 22                         load.i32
	<.main+3781 @0595b9> : 2e b8 77 05                store.m32 <@0577b8> ;offsetOfBase1
	test/lang/reflect.ci:46: (13 bytes: <@0595bd> - <@0595ca>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+3785 @0595bd> : 2a b0 77 05                load.m32 <@0577b0> ;typeofBase1
	<.main+3789 @0595c1> : 0c 20 00 00                inc.i32(+32)
	<.main+3793 @0595c5> : 22                         load.i32
	<.main+3794 @0595c6> : 2e c0 77 05                store.m32 <@0577c0> ;sizeOfBase1
	test/lang/reflect.ci:48: (12 bytes: <@0595ca> - <@0595d6>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+3798 @0595ca> : 2a b0 77 05                load.m32 <@0577b0> ;typeofBase1
	<.main+3802 @0595ce> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3806 @0595d2> : 2e c8 77 05                store.m32 <@0577c8> ;typeofBase2
	test/lang/reflect.ci:49: (13 bytes: <@0595d6> - <@0595e3>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+3810 @0595d6> : 2a c8 77 05                load.m32 <@0577c8> ;typeofBase2
	<.main+3814 @0595da> : 0c 28 00 00                inc.i32(+40)
	<.main+3818 @0595de> : 22                         load.i32
	<.main+3819 @0595df> : 2e d0 77 05                store.m32 <@0577d0> ;offsetOfBase2
	test/lang/reflect.ci:50: (13 bytes: <@0595e3> - <@0595f0>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+3823 @0595e3> : 2a c8 77 05                load.m32 <@0577c8> ;typeofBase2
	<.main+3827 @0595e7> : 0c 20 00 00                inc.i32(+32)
	<.main+3831 @0595eb> : 22                         load.i32
	<.main+3832 @0595ec> : 2e d8 77 05                store.m32 <@0577d8> ;sizeOfBase2
	test/std/number.ci:3: (13 bytes: <@0595f0> - <@0595fd>): static pi64: float64 := 3.141593
	<.main+3836 @0595f0> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+3845 @0595f9> : 2d e0 77 05                store.m64 <@0577e0> ;pi64
	test/std/number.ci:4: (13 bytes: <@0595fd> - <@05960a>): static e64: float64 := 2.718282
	<.main+3849 @0595fd> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+3858 @059606> : 2d e8 77 05                store.m64 <@0577e8> ;e64
	test/std/number.ci:6: (9 bytes: <@05960a> - <@059613>): static pi32: float32 := pi64
	<.main+3862 @05960a> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+3866 @05960e> : 8c                         f64.2f32
	<.main+3867 @05960f> : 2e f0 77 05                store.m32 <@0577f0> ;pi32
	test/std/number.ci:7: (9 bytes: <@059613> - <@05961c>): static e32: float32 := e64
	<.main+3871 @059613> : 2b e8 77 05                load.m64 <@0577e8> ;e64
	<.main+3875 @059617> : 8c                         f64.2f32
	<.main+3876 @059618> : 2e f8 77 05                store.m32 <@0577f8> ;e32
	test/std/number.ci:14: (11 bytes: <@05961c> - <@059627>): static r_comp: int32 := int32(14 << 3)
	<.main+3880 @05961c> : 1c 0e 00 00 00             load.c32 14
	<.main+3885 @059621> : 3f 43                      b32.shl 0x003
	<.main+3887 @059623> : 2e 00 78 05                store.m32 <@057800> ;r_comp
	test/std/number.ci:15: (11 bytes: <@059627> - <@059632>): static g_comp: int32 := int32(63 << 2)
	<.main+3891 @059627> : 1c 3f 00 00 00             load.c32 63
	<.main+3896 @05962c> : 3f 42                      b32.shl 0x002
	<.main+3898 @05962e> : 2e 08 78 05                store.m32 <@057808> ;g_comp
	test/std/number.ci:16: (11 bytes: <@059632> - <@05963d>): static b_comp: int32 := int32(31 << 3)
	<.main+3902 @059632> : 1c 1f 00 00 00             load.c32 31
	<.main+3907 @059637> : 3f 43                      b32.shl 0x003
	<.main+3909 @059639> : 2e 10 78 05                store.m32 <@057810> ;b_comp
	test/std/number.ci:18: (38 bytes: <@05963d> - <@059663>): static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+3913 @05963d> : 2a 00 78 05                load.m32 <@057800> ;r_comp
	<.main+3917 @059641> : 3f 48                      b32.shl 0x008
	<.main+3919 @059643> : 1c 00 f8 00 00             load.c32 63488
	<.main+3924 @059648> : 31                         and.b32
	<.main+3925 @059649> : 2a 08 78 05                load.m32 <@057808> ;g_comp
	<.main+3929 @05964d> : 3f 43                      b32.shl 0x003
	<.main+3931 @05964f> : 1c e0 07 00 00             load.c32 2016
	<.main+3936 @059654> : 31                         and.b32
	<.main+3937 @059655> : 32                         or.b32
	<.main+3938 @059656> : 2a 10 78 05                load.m32 <@057810> ;b_comp
	<.main+3942 @05965a> : 3f c3                      b32.sar 0x003
	<.main+3944 @05965c> : 3f 05                      b32.and 0x01f
	<.main+3946 @05965e> : 32                         or.b32
	<.main+3947 @05965f> : 2e 18 78 05                store.m32 <@057818> ;r5g6b5
	test/std/number.ci:19: (36 bytes: <@059663> - <@059687>): static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3951 @059663> : 2a 00 78 05                load.m32 <@057800> ;r_comp
	<.main+3955 @059667> : 3f 50                      b32.shl 0x010
	<.main+3957 @059669> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3962 @05966e> : 31                         and.b32
	<.main+3963 @05966f> : 2a 08 78 05                load.m32 <@057808> ;g_comp
	<.main+3967 @059673> : 3f 48                      b32.shl 0x008
	<.main+3969 @059675> : 1c 00 ff 00 00             load.c32 65280
	<.main+3974 @05967a> : 31                         and.b32
	<.main+3975 @05967b> : 32                         or.b32
	<.main+3976 @05967c> : 2a 10 78 05                load.m32 <@057810> ;b_comp
	<.main+3980 @059680> : 3f 08                      b32.and 0x0ff
	<.main+3982 @059682> : 32                         or.b32
	<.main+3983 @059683> : 2e 20 78 05                store.m32 <@057820> ;r8g8b8
	test/std/number.ci:21: (22 bytes: <@059687> - <@05969d>): static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3987 @059687> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+3991 @05968b> : 1c 0b 00 00 00             load.c32 11
	<.main+3996 @059690> : 1c 05 00 00 00             load.c32 5
	<.main+4001 @059695> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4005 @059699> : 2e 28 78 05                store.m32 <@057828> ;zxtR5
	test/std/number.ci:22: (22 bytes: <@05969d> - <@0596b3>): static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+4009 @05969d> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4013 @0596a1> : 1c 05 00 00 00             load.c32 5
	<.main+4018 @0596a6> : 1c 06 00 00 00             load.c32 6
	<.main+4023 @0596ab> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4027 @0596af> : 2e 30 78 05                store.m32 <@057830> ;zxtG6
	test/std/number.ci:23: (18 bytes: <@0596b3> - <@0596c5>): static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4031 @0596b3> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4035 @0596b7> : 19                         load.z32
	<.main+4036 @0596b8> : 1c 05 00 00 00             load.c32 5
	<.main+4041 @0596bd> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4045 @0596c1> : 2e 38 78 05                store.m32 <@057838> ;zxtB5
	test/std/number.ci:25: (22 bytes: <@0596c5> - <@0596db>): static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+4049 @0596c5> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4053 @0596c9> : 1c 0b 00 00 00             load.c32 11
	<.main+4058 @0596ce> : 1c 05 00 00 00             load.c32 5
	<.main+4063 @0596d3> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4067 @0596d7> : 2e 40 78 05                store.m32 <@057840> ;sxtR5
	test/std/number.ci:26: (22 bytes: <@0596db> - <@0596f1>): static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+4071 @0596db> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4075 @0596df> : 1c 05 00 00 00             load.c32 5
	<.main+4080 @0596e4> : 1c 06 00 00 00             load.c32 6
	<.main+4085 @0596e9> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4089 @0596ed> : 2e 48 78 05                store.m32 <@057848> ;sxtG6
	test/std/number.ci:27: (18 bytes: <@0596f1> - <@059703>): static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4093 @0596f1> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4097 @0596f5> : 19                         load.z32
	<.main+4098 @0596f6> : 1c 05 00 00 00             load.c32 5
	<.main+4103 @0596fb> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4107 @0596ff> : 2e 50 78 05                store.m32 <@057850> ;sxtB5
	test/std/number.ci:29: (22 bytes: <@059703> - <@059719>): static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+4111 @059703> : 2a 20 78 05                load.m32 <@057820> ;r8g8b8
	<.main+4115 @059707> : 1c 10 00 00 00             load.c32 16
	<.main+4120 @05970c> : 1c 08 00 00 00             load.c32 8
	<.main+4125 @059711> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4129 @059715> : 2e 58 78 05                store.m32 <@057858> ;zxtR8
	test/std/number.ci:30: (22 bytes: <@059719> - <@05972f>): static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+4133 @059719> : 2a 20 78 05                load.m32 <@057820> ;r8g8b8
	<.main+4137 @05971d> : 1c 08 00 00 00             load.c32 8
	<.main+4142 @059722> : 1c 08 00 00 00             load.c32 8
	<.main+4147 @059727> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4151 @05972b> : 2e 60 78 05                store.m32 <@057860> ;zxtG8
	test/std/number.ci:31: (18 bytes: <@05972f> - <@059741>): static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+4155 @05972f> : 2a 20 78 05                load.m32 <@057820> ;r8g8b8
	<.main+4159 @059733> : 19                         load.z32
	<.main+4160 @059734> : 1c 08 00 00 00             load.c32 8
	<.main+4165 @059739> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4169 @05973d> : 2e 68 78 05                store.m32 <@057868> ;zxtB8
	test/std/number.ci:33: (22 bytes: <@059741> - <@059757>): static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+4173 @059741> : 2a 20 78 05                load.m32 <@057820> ;r8g8b8
	<.main+4177 @059745> : 1c 10 00 00 00             load.c32 16
	<.main+4182 @05974a> : 1c 08 00 00 00             load.c32 8
	<.main+4187 @05974f> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4191 @059753> : 2e 70 78 05                store.m32 <@057870> ;sxtR8
	test/std/number.ci:34: (22 bytes: <@059757> - <@05976d>): static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+4195 @059757> : 2a 20 78 05                load.m32 <@057820> ;r8g8b8
	<.main+4199 @05975b> : 1c 08 00 00 00             load.c32 8
	<.main+4204 @059760> : 1c 08 00 00 00             load.c32 8
	<.main+4209 @059765> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4213 @059769> : 2e 78 78 05                store.m32 <@057878> ;sxtG8
	test/std/number.ci:35: (18 bytes: <@05976d> - <@05977f>): static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+4217 @05976d> : 2a 20 78 05                load.m32 <@057820> ;r8g8b8
	<.main+4221 @059771> : 19                         load.z32
	<.main+4222 @059772> : 1c 08 00 00 00             load.c32 8
	<.main+4227 @059777> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4231 @05977b> : 2e 80 78 05                store.m32 <@057880> ;sxtB8
	test/std/number.ci:37: (22 bytes: <@05977f> - <@059795>): static testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+4235 @05977f> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4239 @059783> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4248 @05978c> : 84                         div.f64
	<.main+4249 @05978d> : 01 28 00 00                nfc(40) ;float64.sin(x: float64): float64
	<.main+4253 @059791> : 2d 88 78 05                store.m64 <@057888> ;testSin_f64
	test/std/number.ci:38: (22 bytes: <@059795> - <@0597ab>): static testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+4257 @059795> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4261 @059799> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4270 @0597a2> : 84                         div.f64
	<.main+4271 @0597a3> : 01 29 00 00                nfc(41) ;float64.cos(x: float64): float64
	<.main+4275 @0597a7> : 2d 90 78 05                store.m64 <@057890> ;testCos_f64
	test/std/number.ci:39: (22 bytes: <@0597ab> - <@0597c1>): static testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+4279 @0597ab> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4283 @0597af> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+4292 @0597b8> : 84                         div.f64
	<.main+4293 @0597b9> : 01 2a 00 00                nfc(42) ;float64.tan(x: float64): float64
	<.main+4297 @0597bd> : 2d 98 78 05                store.m64 <@057898> ;testTan_f64
	test/std/number.ci:40: (22 bytes: <@0597c1> - <@0597d7>): static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+4301 @0597c1> : 2b e8 77 05                load.m64 <@0577e8> ;e64
	<.main+4305 @0597c5> : 2b e8 77 05                load.m64 <@0577e8> ;e64
	<.main+4309 @0597c9> : 83                         mul.f64
	<.main+4310 @0597ca> : 2b e8 77 05                load.m64 <@0577e8> ;e64
	<.main+4314 @0597ce> : 83                         mul.f64
	<.main+4315 @0597cf> : 01 2b 00 00                nfc(43) ;float64.log(x: float64): float64
	<.main+4319 @0597d3> : 2d a0 78 05                store.m64 <@0578a0> ;testLog_f64
	test/std/number.ci:41: (17 bytes: <@0597d7> - <@0597e8>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+4323 @0597d7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4332 @0597e0> : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<.main+4336 @0597e4> : 2d a8 78 05                store.m64 <@0578a8> ;testExp_f64
	test/std/number.ci:42: (26 bytes: <@0597e8> - <@059802>): static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+4340 @0597e8> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4344 @0597ec> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4348 @0597f0> : 83                         mul.f64
	<.main+4349 @0597f1> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+4358 @0597fa> : 01 2d 00 00                nfc(45) ;float64.pow(x: float64, y: float64): float64
	<.main+4362 @0597fe> : 2d b0 78 05                store.m64 <@0578b0> ;testPow_f64
	test/std/number.ci:43: (17 bytes: <@059802> - <@059813>): static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+4366 @059802> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4370 @059806> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4374 @05980a> : 83                         mul.f64
	<.main+4375 @05980b> : 01 2e 00 00                nfc(46) ;float64.sqrt(x: float64): float64
	<.main+4379 @05980f> : 2d b8 78 05                store.m64 <@0578b8> ;testSqrt_f64
	test/std/number.ci:44: (21 bytes: <@059813> - <@059828>): static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+4383 @059813> : 2b e0 77 05                load.m64 <@0577e0> ;pi64
	<.main+4387 @059817> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4396 @059820> : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<.main+4400 @059824> : 2d c0 78 05                store.m64 <@0578c0> ;testAtan_f64
	test/std/number.ci:46: (18 bytes: <@059828> - <@05983a>): static testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+4404 @059828> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4408 @05982c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4413 @059831> : 74                         div.f32
	<.main+4414 @059832> : 01 20 00 00                nfc(32) ;float32.sin(x: float32): float32
	<.main+4418 @059836> : 2e c8 78 05                store.m32 <@0578c8> ;testSin_f32
	test/std/number.ci:47: (18 bytes: <@05983a> - <@05984c>): static testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+4422 @05983a> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4426 @05983e> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4431 @059843> : 74                         div.f32
	<.main+4432 @059844> : 01 21 00 00                nfc(33) ;float32.cos(x: float32): float32
	<.main+4436 @059848> : 2e d0 78 05                store.m32 <@0578d0> ;testCos_f32
	test/std/number.ci:48: (18 bytes: <@05984c> - <@05985e>): static testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+4440 @05984c> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4444 @059850> : 7f 00 00 80 40             load.f32 4.000000
	<.main+4449 @059855> : 74                         div.f32
	<.main+4450 @059856> : 01 22 00 00                nfc(34) ;float32.tan(x: float32): float32
	<.main+4454 @05985a> : 2e d8 78 05                store.m32 <@0578d8> ;testTan_f32
	test/std/number.ci:49: (22 bytes: <@05985e> - <@059874>): static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+4458 @05985e> : 2a f8 77 05                load.m32 <@0577f8> ;e32
	<.main+4462 @059862> : 2a f8 77 05                load.m32 <@0577f8> ;e32
	<.main+4466 @059866> : 73                         mul.f32
	<.main+4467 @059867> : 2a f8 77 05                load.m32 <@0577f8> ;e32
	<.main+4471 @05986b> : 73                         mul.f32
	<.main+4472 @05986c> : 01 23 00 00                nfc(35) ;float32.log(x: float32): float32
	<.main+4476 @059870> : 2e e0 78 05                store.m32 <@0578e0> ;testLog_f32
	test/std/number.ci:50: (13 bytes: <@059874> - <@059881>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+4480 @059874> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4485 @059879> : 01 24 00 00                nfc(36) ;float32.exp(x: float32): float32
	<.main+4489 @05987d> : 2e e8 78 05                store.m32 <@0578e8> ;testExp_f32
	test/std/number.ci:51: (22 bytes: <@059881> - <@059897>): static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+4493 @059881> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4497 @059885> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4501 @059889> : 73                         mul.f32
	<.main+4502 @05988a> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+4507 @05988f> : 01 25 00 00                nfc(37) ;float32.pow(x: float32, y: float32): float32
	<.main+4511 @059893> : 2e f0 78 05                store.m32 <@0578f0> ;testPow_f32
	test/std/number.ci:52: (17 bytes: <@059897> - <@0598a8>): static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+4515 @059897> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4519 @05989b> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4523 @05989f> : 73                         mul.f32
	<.main+4524 @0598a0> : 01 26 00 00                nfc(38) ;float32.sqrt(x: float32): float32
	<.main+4528 @0598a4> : 2e f8 78 05                store.m32 <@0578f8> ;testSqrt_f32
	test/std/number.ci:53: (17 bytes: <@0598a8> - <@0598b9>): static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+4532 @0598a8> : 2a f0 77 05                load.m32 <@0577f0> ;pi32
	<.main+4536 @0598ac> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4541 @0598b1> : 01 27 00 00                nfc(39) ;float32.atan2(x: float32, y: float32): float32
	<.main+4545 @0598b5> : 2e 00 79 05                store.m32 <@057900> ;testAtan_f32
	test/std/number.ci:55: (12 bytes: <@0598b9> - <@0598c5>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+4549 @0598b9> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4553 @0598bd> : 01 18 00 00                nfc(24) ;uint32.pop(value: int32): int32
	<.main+4557 @0598c1> : 2e 08 79 05                store.m32 <@057908> ;testPopulation_u32
	test/std/number.ci:56: (12 bytes: <@0598c5> - <@0598d1>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+4561 @0598c5> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4565 @0598c9> : 01 19 00 00                nfc(25) ;uint32.swap(value: int32): int32
	<.main+4569 @0598cd> : 2e 10 79 05                store.m32 <@057910> ;testSwapBits_u32
	test/std/number.ci:57: (12 bytes: <@0598d1> - <@0598dd>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+4573 @0598d1> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4577 @0598d5> : 01 1a 00 00                nfc(26) ;uint32.bsr(value: int32): int32
	<.main+4581 @0598d9> : 2e 18 79 05                store.m32 <@057918> ;testBitScanReverse_u32
	test/std/number.ci:58: (12 bytes: <@0598dd> - <@0598e9>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+4585 @0598dd> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4589 @0598e1> : 01 1b 00 00                nfc(27) ;uint32.bsf(value: int32): int32
	<.main+4593 @0598e5> : 2e 20 79 05                store.m32 <@057920> ;testBitScanForward_u32
	test/std/number.ci:59: (12 bytes: <@0598e9> - <@0598f5>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+4597 @0598e9> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4601 @0598ed> : 01 1c 00 00                nfc(28) ;uint32.hib(value: int32): int32
	<.main+4605 @0598f1> : 2e 28 79 05                store.m32 <@057928> ;testHighBit_u32
	test/std/number.ci:60: (12 bytes: <@0598f5> - <@059901>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+4609 @0598f5> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4613 @0598f9> : 01 1d 00 00                nfc(29) ;uint32.lob(value: int32): int32
	<.main+4617 @0598fd> : 2e 30 79 05                store.m32 <@057930> ;testLowBit_u32
	test/std/number.ci:62: (18 bytes: <@059901> - <@059913>): static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4621 @059901> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4625 @059905> : 19                         load.z32
	<.main+4626 @059906> : 1c 05 00 00 00             load.c32 5
	<.main+4631 @05990b> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4635 @05990f> : 2e 38 79 05                store.m32 <@057938> ;testZeroExtend_u32
	test/std/number.ci:63: (18 bytes: <@059913> - <@059925>): static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4639 @059913> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4643 @059917> : 19                         load.z32
	<.main+4644 @059918> : 1c 05 00 00 00             load.c32 5
	<.main+4649 @05991d> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4653 @059921> : 2e 40 79 05                store.m32 <@057940> ;testSignExtend_u32
	test/std/number.ci:65: (20 bytes: <@059925> - <@059939>): static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+4657 @059925> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4661 @059929> : 5b                         i32.2i64
	<.main+4662 @05992a> : 19                         load.z32
	<.main+4663 @05992b> : 1c 05 00 00 00             load.c32 5
	<.main+4668 @059930> : 01 1e 00 00                nfc(30) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+4672 @059934> : 6a                         i64.2i32
	<.main+4673 @059935> : 2e 48 79 05                store.m32 <@057948> ;testZeroExtend_u64
	test/std/number.ci:66: (20 bytes: <@059939> - <@05994d>): static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+4677 @059939> : 2a 18 78 05                load.m32 <@057818> ;r5g6b5
	<.main+4681 @05993d> : 5b                         i32.2i64
	<.main+4682 @05993e> : 19                         load.z32
	<.main+4683 @05993f> : 1c 05 00 00 00             load.c32 5
	<.main+4688 @059944> : 01 1f 00 00                nfc(31) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+4692 @059948> : 6a                         i64.2i32
	<.main+4693 @059949> : 2e 50 79 05                store.m32 <@057950> ;testSignExtend_u64
	test/std/memory.ci:7: (18 bytes: <@05994d> - <@05995f>): static p1: pointer := malloc(1024)
	<.main+4697 @05994d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4702 @059952> : 1c 00 04 00 00             load.c32 1024
	<.main+4707 @059957> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4711 @05995b> : 2e 58 79 05                store.m32 <@057958> ;p1
	test/std/memory.ci:8: (18 bytes: <@05995f> - <@059971>): static p2: pointer := malloc(80)
	<.main+4715 @05995f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4720 @059964> : 1c 50 00 00 00             load.c32 80
	<.main+4725 @059969> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4729 @05996d> : 2e 60 79 05                store.m32 <@057960> ;p2
	test/std/memory.ci:9: (18 bytes: <@059971> - <@059983>): static p3: pointer := malloc(160)
	<.main+4733 @059971> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4738 @059976> : 1c a0 00 00 00             load.c32 160
	<.main+4743 @05997b> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4747 @05997f> : 2e 68 79 05                store.m32 <@057968> ;p3
	test/std/memory.ci:10: (18 bytes: <@059983> - <@059995>): static p4: pointer := malloc(820)
	<.main+4751 @059983> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4756 @059988> : 1c 34 03 00 00             load.c32 820
	<.main+4761 @05998d> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4765 @059991> : 2e 70 79 05                store.m32 <@057970> ;p4
	test/std/memory.ci:23: (13 bytes: <@059995> - <@0599a2>): static val1: int64 := 42
	<.main+4769 @059995> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4778 @05999e> : 2d 78 79 05                store.m64 <@057978> ;val1
	test/std/memory.ci:24: (13 bytes: <@0599a2> - <@0599af>): static val2: int64 := 96
	<.main+4782 @0599a2> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+4791 @0599ab> : 2d 80 79 05                store.m64 <@057980> ;val2
	test/std/tryExec.ci:46: (18 bytes: <@0599af> - <@0599c1>): static tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+4795 @0599af> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4800 @0599b4> : 1f 88 79 05 00             load.ref <@057988> ;noError(ptr: pointer): void
	<.main+4805 @0599b9> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4809 @0599bd> : 2e 18 7a 05                store.m32 <@057a18> ;tryExecErr0
	test/std/tryExec.ci:47: (18 bytes: <@0599c1> - <@0599d3>): static tryExecErr1: int32 := tryExec(void(null, null))
	<.main+4813 @0599c1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4818 @0599c6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4823 @0599cb> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4827 @0599cf> : 2e 20 7a 05                store.m32 <@057a20> ;tryExecErr1
	test/std/tryExec.ci:48: (18 bytes: <@0599d3> - <@0599e5>): static tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+4831 @0599d3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4836 @0599d8> : 1f 90 79 05 00             load.ref <@057990> ;stackOverflow(ptr: pointer): void
	<.main+4841 @0599dd> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4845 @0599e1> : 2e 28 7a 05                store.m32 <@057a28> ;tryExecErr2
	test/std/tryExec.ci:49: (18 bytes: <@0599e5> - <@0599f7>): static tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+4849 @0599e5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4854 @0599ea> : 1f a8 79 05 00             load.ref <@0579a8> ;divisionByZero(args: pointer): void
	<.main+4859 @0599ef> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4863 @0599f3> : 2e 30 7a 05                store.m32 <@057a30> ;tryExecErr3
	test/std/tryExec.ci:50: (18 bytes: <@0599f7> - <@059a09>): static tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+4867 @0599f7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4872 @0599fc> : 1f 10 7a 05 00             load.ref <@057a10> ;invalidInstruction(args: pointer): void
	<.main+4877 @059a01> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4881 @059a05> : 2e 38 7a 05                store.m32 <@057a38> ;tryExecErr4
	test/std/tryExec.ci:51: (18 bytes: <@059a09> - <@059a1b>): static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+4885 @059a09> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4890 @059a0e> : 1f 00 7a 05 00             load.ref <@057a00> ;invalidMemoryAccess(args: pointer): void
	<.main+4895 @059a13> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4899 @059a17> : 2e 40 7a 05                store.m32 <@057a40> ;tryExecErr5
	test/std/tryExec.ci:52: (18 bytes: <@059a1b> - <@059a2d>): static tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+4903 @059a1b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4908 @059a20> : 1f b8 79 05 00             load.ref <@0579b8> ;abortExecution(args: pointer): void
	<.main+4913 @059a25> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4917 @059a29> : 2e 48 7a 05                store.m32 <@057a48> ;tryExecErr6
	test/lang/array.ci:59: (9 bytes: <@059a2d> - <@059a36>): static arrArrayInitNull: int64[*] := null
	<.main+4921 @059a2d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4926 @059a32> : 2e 98 7a 05                store.m32 <@057a98> ;arrArrayInitNull
	test/lang/array.ci:60: (10 bytes: <@059a36> - <@059a40>): static arrSliceInitNull: int64[] := null
	<.main+4930 @059a36> : 19                         load.z32
	<.main+4931 @059a37> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4936 @059a3c> : 2d a0 7a 05                store.m64 <@057aa0> ;arrSliceInitNull
	test/lang/array.ci:63: (9 bytes: <@059a40> - <@059a49>): static arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+4940 @059a40> : 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+4945 @059a45> : 2e a8 7a 05                store.m32 <@057aa8> ;arrArrayInitFixed
	test/lang/array.ci:64: (14 bytes: <@059a49> - <@059a57>): static arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+4949 @059a49> : 1c 07 00 00 00             load.c32 7
	<.main+4954 @059a4e> : 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+4959 @059a53> : 2d b0 7a 05                store.m64 <@057ab0> ;arrSliceInitFixed
	test/lang/array.ci:67: (8 bytes: <@059a57> - <@059a5f>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+4963 @059a57> : 2a b0 7a 05                load.m32 <@057ab0> ;arrSliceInitFixed
	<.main+4967 @059a5b> : 2e b8 7a 05                store.m32 <@057ab8> ;arrArrayInitSlice
	test/lang/array.ci:68: (8 bytes: <@059a5f> - <@059a67>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+4971 @059a5f> : 2b b0 7a 05                load.m64 <@057ab0> ;arrSliceInitFixed
	<.main+4975 @059a63> : 2d c0 7a 05                store.m64 <@057ac0> ;arrSliceInitSlice
	test/lang/array.ci:71: (8 bytes: <@059a67> - <@059a6f>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+4979 @059a67> : 2a a8 7a 05                load.m32 <@057aa8> ;arrArrayInitFixed
	<.main+4983 @059a6b> : 2e c8 7a 05                store.m32 <@057ac8> ;arrArrayInitPtr
	test/lang/array.ci:86: (9 bytes: <@059a6f> - <@059a78>): static strArray: char[*] := "string"
	<.main+4987 @059a6f> : 1f cc 0c 03 00             load.ref <@030ccc> ;"string"
	<.main+4992 @059a74> : 2e d8 7a 05                store.m32 <@057ad8> ;strArray
	test/lang/array.ci:90: (14 bytes: <@059a78> - <@059a86>): static strSlice: char[] := "string"
	<.main+4996 @059a78> : 1c 06 00 00 00             load.c32 6
	<.main+5001 @059a7d> : 1f cc 0c 03 00             load.ref <@030ccc> ;"string"
	<.main+5006 @059a82> : 2d e0 7a 05                store.m64 <@057ae0> ;strSlice
	test/lang/member.ci:35: (5 bytes: <@059a86> - <@059a8b>): static global: int32
	<.main+5010 @059a86> : 19                         load.z32
	<.main+5011 @059a87> : 2e 20 7b 05                store.m32 <@057b20> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@059a8b> - <@059a94>): static globalInit: int32 := 1
	<.main+5015 @059a8b> : 1c 01 00 00 00             load.c32 1
	<.main+5020 @059a90> : 2e 28 7b 05                store.m32 <@057b28> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@059a94> - <@059a9d>): static const globalConstant: int32 := 2
	<.main+5024 @059a94> : 1c 02 00 00 00             load.c32 2
	<.main+5029 @059a99> : 2e 30 7b 05                store.m32 <@057b30> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@059a9d> - <@059aaf>): static globalRecInit: Inner := {...}
	<.main+5033 @059a9d> : 1c 04 00 00 00             load.c32 4
	<.main+5038 @059aa2> : 2e 40 7b 05                store.m32 <@057b40> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@059aa6> - <@059aaf>): void(globalRecInit.constant := 5);
	<.main+5042 @059aa6> : 1c 05 00 00 00             load.c32 5
	<.main+5047 @059aab> : 2e 44 7b 05                store.m32 <@057b44> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@059aaf> - <@059ac1>): static const globalConstantRec: Inner := {...}
	<.main+5051 @059aaf> : 1c 06 00 00 00             load.c32 6
	<.main+5056 @059ab4> : 2e 48 7b 05                store.m32 <@057b48> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@059ab8> - <@059ac1>): void(globalConstantRec.constant := 7);
	<.main+5060 @059ab8> : 1c 07 00 00 00             load.c32 7
	<.main+5065 @059abd> : 2e 4c 7b 05                store.m32 <@057b4c> ;RecordMemberTest.globalConstantRec+4
	test/lang/member.ci:53: (72 bytes: <@059ac1> - <@059b09>): static recordMemberTest: RecordMemberTest := {...}
	<.main+5069 @059ac1> : 1c 0a 00 00 00             load.c32 10
	<.main+5074 @059ac6> : 2e 50 7b 05                store.m32 <@057b50> ;recordMemberTest
	test/lang/member.ci:55: (9 bytes: <@059aca> - <@059ad3>): void(recordMemberTest.constant := 11);
	<.main+5078 @059aca> : 1c 0b 00 00 00             load.c32 11
	<.main+5083 @059acf> : 2e 54 7b 05                store.m32 <@057b54> ;recordMemberTest+4
	test/lang/member.ci:56: (9 bytes: <@059ad3> - <@059adc>): void(recordMemberTest.memberInit := 12);
	<.main+5087 @059ad3> : 1c 0c 00 00 00             load.c32 12
	<.main+5092 @059ad8> : 2e 58 7b 05                store.m32 <@057b58> ;recordMemberTest+8
	test/lang/member.ci:57: (9 bytes: <@059adc> - <@059ae5>): void(recordMemberTest.constantInit := 13);
	<.main+5096 @059adc> : 1c 0d 00 00 00             load.c32 13
	<.main+5101 @059ae1> : 2e 5c 7b 05                store.m32 <@057b5c> ;recordMemberTest+12
	test/lang/member.ci:60: (9 bytes: <@059ae5> - <@059aee>): void(recordMemberTest.memberRec.member := 14);
	<.main+5105 @059ae5> : 1c 0e 00 00 00             load.c32 14
	<.main+5110 @059aea> : 2e 60 7b 05                store.m32 <@057b60> ;recordMemberTest+16
	test/lang/member.ci:61: (9 bytes: <@059aee> - <@059af7>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5114 @059aee> : 1c 0f 00 00 00             load.c32 15
	<.main+5119 @059af3> : 2e 64 7b 05                store.m32 <@057b64> ;recordMemberTest+20
	test/lang/member.ci:65: (9 bytes: <@059af7> - <@059b00>): void(recordMemberTest.constantRec.member := 16);
	<.main+5123 @059af7> : 1c 10 00 00 00             load.c32 16
	<.main+5128 @059afc> : 2e 68 7b 05                store.m32 <@057b68> ;recordMemberTest+24
	test/lang/member.ci:66: (9 bytes: <@059b00> - <@059b09>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5132 @059b00> : 1c 11 00 00 00             load.c32 17
	<.main+5137 @059b05> : 2e 6c 7b 05                store.m32 <@057b6c> ;recordMemberTest+28
	test/lang/method.ci:18: (9 bytes: <@059b09> - <@059b12>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5141 @059b09> : 1f c8 7b 05 00             load.ref <@057bc8> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5146 @059b0e> : 2e 98 7b 05                store.m32 <@057b98> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/method.ci:62: (26 bytes: <@059b12> - <@059b2c>): static recordMethodTest: RecordMethodTest := {...}
	<.main+5150 @059b12> : 1f f0 7b 05 00             load.ref <@057bf0> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5155 @059b17> : 2e 18 7c 05                store.m32 <@057c18> ;recordMethodTest
	:: (8 bytes: <@059b1b> - <@059b23>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5159 @059b1b> : 2a 98 7b 05                load.m32 <@057b98> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5163 @059b1f> : 2e 1c 7c 05                store.m32 <@057c1c> ;recordMethodTest+4
	:: (9 bytes: <@059b23> - <@059b2c>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5167 @059b23> : 1f a0 7b 05 00             load.ref <@057ba0> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5172 @059b28> : 2e 20 7c 05                store.m32 <@057c20> ;recordMethodTest+8
	test/lang/recUnion.ci:26: (21 bytes: <@059b2c> - <@059b41>): static black: rgbU8 := {...}
	<.main+5176 @059b2c> : 19                         load.z32
	<.main+5177 @059b2d> : 1f b2 7c 05 00             load.ref <@057cb2> ;black+2
	<.main+5182 @059b32> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@059b33> - <@059b3a>): void(black.g := (0));
	<.main+5183 @059b33> : 19                         load.z32
	<.main+5184 @059b34> : 1f b1 7c 05 00             load.ref <@057cb1> ;black+1
	<.main+5189 @059b39> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@059b3a> - <@059b41>): void(black.b := (0));
	<.main+5190 @059b3a> : 19                         load.z32
	<.main+5191 @059b3b> : 1f b0 7c 05 00             load.ref <@057cb0> ;black
	<.main+5196 @059b40> : 25                         store.i8
	test/lang/recUnion.ci:27: (25 bytes: <@059b41> - <@059b5a>): static green: rgbU8 := {...}
	<.main+5197 @059b41> : 19                         load.z32
	<.main+5198 @059b42> : 1f ba 7c 05 00             load.ref <@057cba> ;green+2
	<.main+5203 @059b47> : 25                         store.i8
	test/lang/recUnion.ci:27: (11 bytes: <@059b48> - <@059b53>): void(green.g := (255));
	<.main+5204 @059b48> : 1c ff 00 00 00             load.c32 255
	<.main+5209 @059b4d> : 1f b9 7c 05 00             load.ref <@057cb9> ;green+1
	<.main+5214 @059b52> : 25                         store.i8
	test/lang/recUnion.ci:27: (7 bytes: <@059b53> - <@059b5a>): void(green.b := (0));
	<.main+5215 @059b53> : 19                         load.z32
	<.main+5216 @059b54> : 1f b8 7c 05 00             load.ref <@057cb8> ;green
	<.main+5221 @059b59> : 25                         store.i8
	test/lang/recUnion.ci:28: (33 bytes: <@059b5a> - <@059b7b>): static white: rgbU8 := {...}
	<.main+5222 @059b5a> : 1c ff 00 00 00             load.c32 255
	<.main+5227 @059b5f> : 1f c2 7c 05 00             load.ref <@057cc2> ;white+2
	<.main+5232 @059b64> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@059b65> - <@059b70>): void(white.g := (255));
	<.main+5233 @059b65> : 1c ff 00 00 00             load.c32 255
	<.main+5238 @059b6a> : 1f c1 7c 05 00             load.ref <@057cc1> ;white+1
	<.main+5243 @059b6f> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@059b70> - <@059b7b>): void(white.b := (255));
	<.main+5244 @059b70> : 1c ff 00 00 00             load.c32 255
	<.main+5249 @059b75> : 1f c0 7c 05 00             load.ref <@057cc0> ;white
	<.main+5254 @059b7a> : 25                         store.i8
	test/lang/recUnion.ci:30: (9 bytes: <@059b7b> - <@059b84>): static cyan: color := {...}
	<.main+5255 @059b7b> : 1c ff ff 00 00             load.c32 65535
	<.main+5260 @059b80> : 2e c8 7c 05                store.m32 <@057cc8> ;cyan
	test/lang/recUnion.ci:31: (25 bytes: <@059b84> - <@059b9d>): static blue: color := {...}
	<.main+5264 @059b84> : 19                         load.z32
	<.main+5265 @059b85> : 1f d2 7c 05 00             load.ref <@057cd2> ;blue+2
	<.main+5270 @059b8a> : 25                         store.i8
	test/lang/recUnion.ci:31: (7 bytes: <@059b8b> - <@059b92>): void(blue.rgb.g := (0));
	<.main+5271 @059b8b> : 19                         load.z32
	<.main+5272 @059b8c> : 1f d1 7c 05 00             load.ref <@057cd1> ;blue+1
	<.main+5277 @059b91> : 25                         store.i8
	test/lang/recUnion.ci:31: (11 bytes: <@059b92> - <@059b9d>): void(blue.rgb.b := (255));
	<.main+5278 @059b92> : 1c ff 00 00 00             load.c32 255
	<.main+5283 @059b97> : 1f d0 7c 05 00             load.ref <@057cd0> ;blue
	<.main+5288 @059b9c> : 25                         store.i8
	test/lang/useOperator.ci:5: (9 bytes: <@059b9d> - <@059ba6>): static shift: int32 := 2
	<.main+5289 @059b9d> : 1c 02 00 00 00             load.c32 2
	<.main+5294 @059ba2> : 2e d8 7c 05                store.m32 <@057cd8> ;shift
	test/lang/useOperator.ci:7: (11 bytes: <@059ba6> - <@059bb1>): static boolA: bool := true
	<.main+5298 @059ba6> : 1c 01 00 00 00             load.c32 1
	<.main+5303 @059bab> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5308 @059bb0> : 25                         store.i8
	test/lang/useOperator.ci:8: (11 bytes: <@059bb1> - <@059bbc>): static boolB: bool := bool(!false)
	<.main+5309 @059bb1> : 1c 01 00 00 00             load.c32 1
	<.main+5314 @059bb6> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5319 @059bbb> : 25                         store.i8
	test/lang/useOperator.ci:17: (19 bytes: <@059bbc> - <@059bcf>): static boolAnd: bool := bool(boolA & boolB)
	<.main+5320 @059bbc> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5325 @059bc1> : 20                         load.i8
	<.main+5326 @059bc2> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5331 @059bc7> : 20                         load.i8
	<.main+5332 @059bc8> : 31                         and.b32
	<.main+5333 @059bc9> : 1f f0 7c 05 00             load.ref <@057cf0> ;boolAnd
	<.main+5338 @059bce> : 25                         store.i8
	test/lang/useOperator.ci:18: (19 bytes: <@059bcf> - <@059be2>): static boolIor: bool := bool(boolA | boolB)
	<.main+5339 @059bcf> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5344 @059bd4> : 20                         load.i8
	<.main+5345 @059bd5> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5350 @059bda> : 20                         load.i8
	<.main+5351 @059bdb> : 32                         or.b32
	<.main+5352 @059bdc> : 1f f8 7c 05 00             load.ref <@057cf8> ;boolIor
	<.main+5357 @059be1> : 25                         store.i8
	test/lang/useOperator.ci:19: (19 bytes: <@059be2> - <@059bf5>): static boolXor: bool := bool(boolA ^ boolB)
	<.main+5358 @059be2> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5363 @059be7> : 20                         load.i8
	<.main+5364 @059be8> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5369 @059bed> : 20                         load.i8
	<.main+5370 @059bee> : 36                         xor.b32
	<.main+5371 @059bef> : 1f 00 7d 05 00             load.ref <@057d00> ;boolXor
	<.main+5376 @059bf4> : 25                         store.i8
	test/lang/useOperator.ci:22: (13 bytes: <@059bf5> - <@059c02>): static boolNot: bool := bool(!boolB)
	<.main+5377 @059bf5> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5382 @059bfa> : 20                         load.i8
	<.main+5383 @059bfb> : 0b                         not.b32
	<.main+5384 @059bfc> : 1f 08 7d 05 00             load.ref <@057d08> ;boolNot
	<.main+5389 @059c01> : 25                         store.i8
	test/lang/useOperator.ci:23: (19 bytes: <@059c02> - <@059c15>): static boolCeq: bool := bool(boolA == boolB)
	<.main+5390 @059c02> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5395 @059c07> : 20                         load.i8
	<.main+5396 @059c08> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5401 @059c0d> : 20                         load.i8
	<.main+5402 @059c0e> : 57                         ceq.i32
	<.main+5403 @059c0f> : 1f 10 7d 05 00             load.ref <@057d10> ;boolCeq
	<.main+5408 @059c14> : 25                         store.i8
	test/lang/useOperator.ci:24: (20 bytes: <@059c15> - <@059c29>): static boolCne: bool := bool(boolA != boolB)
	<.main+5409 @059c15> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5414 @059c1a> : 20                         load.i8
	<.main+5415 @059c1b> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5420 @059c20> : 20                         load.i8
	<.main+5421 @059c21> : 57                         ceq.i32
	<.main+5422 @059c22> : 0b                         not.b32
	<.main+5423 @059c23> : 1f 18 7d 05 00             load.ref <@057d18> ;boolCne
	<.main+5428 @059c28> : 25                         store.i8
	test/lang/useOperator.ci:25: (19 bytes: <@059c29> - <@059c3c>): static boolClt: bool := bool(boolA < boolB)
	<.main+5429 @059c29> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5434 @059c2e> : 20                         load.i8
	<.main+5435 @059c2f> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5440 @059c34> : 20                         load.i8
	<.main+5441 @059c35> : 58                         clt.i32
	<.main+5442 @059c36> : 1f 20 7d 05 00             load.ref <@057d20> ;boolClt
	<.main+5447 @059c3b> : 25                         store.i8
	test/lang/useOperator.ci:26: (20 bytes: <@059c3c> - <@059c50>): static boolCle: bool := bool(boolA <= boolB)
	<.main+5448 @059c3c> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5453 @059c41> : 20                         load.i8
	<.main+5454 @059c42> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5459 @059c47> : 20                         load.i8
	<.main+5460 @059c48> : 59                         cgt.i32
	<.main+5461 @059c49> : 0b                         not.b32
	<.main+5462 @059c4a> : 1f 28 7d 05 00             load.ref <@057d28> ;boolCle
	<.main+5467 @059c4f> : 25                         store.i8
	test/lang/useOperator.ci:27: (19 bytes: <@059c50> - <@059c63>): static boolCgt: bool := bool(boolA > boolB)
	<.main+5468 @059c50> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5473 @059c55> : 20                         load.i8
	<.main+5474 @059c56> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5479 @059c5b> : 20                         load.i8
	<.main+5480 @059c5c> : 59                         cgt.i32
	<.main+5481 @059c5d> : 1f 30 7d 05 00             load.ref <@057d30> ;boolCgt
	<.main+5486 @059c62> : 25                         store.i8
	test/lang/useOperator.ci:28: (20 bytes: <@059c63> - <@059c77>): static boolCge: bool := bool(boolA >= boolB)
	<.main+5487 @059c63> : 1f e0 7c 05 00             load.ref <@057ce0> ;boolA
	<.main+5492 @059c68> : 20                         load.i8
	<.main+5493 @059c69> : 1f e8 7c 05 00             load.ref <@057ce8> ;boolB
	<.main+5498 @059c6e> : 20                         load.i8
	<.main+5499 @059c6f> : 58                         clt.i32
	<.main+5500 @059c70> : 0b                         not.b32
	<.main+5501 @059c71> : 1f 38 7d 05 00             load.ref <@057d38> ;boolCge
	<.main+5506 @059c76> : 25                         store.i8
	test/lang/useOperator.ci:30: (11 bytes: <@059c77> - <@059c82>): static chrA: char := 'a'
	<.main+5507 @059c77> : 1c 61 00 00 00             load.c32 97
	<.main+5512 @059c7c> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5517 @059c81> : 25                         store.i8
	test/lang/useOperator.ci:31: (11 bytes: <@059c82> - <@059c8d>): static chrB: char := 'b'
	<.main+5518 @059c82> : 1c 62 00 00 00             load.c32 98
	<.main+5523 @059c87> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5528 @059c8c> : 25                         store.i8
	test/lang/useOperator.ci:32: (12 bytes: <@059c8d> - <@059c99>): static chrPls: char := char(+chrB)
	<.main+5529 @059c8d> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5534 @059c92> : 20                         load.i8
	<.main+5535 @059c93> : 1f 50 7d 05 00             load.ref <@057d50> ;chrPls
	<.main+5540 @059c98> : 25                         store.i8
	test/lang/useOperator.ci:33: (13 bytes: <@059c99> - <@059ca6>): static chrNeg: char := char(-chrB)
	<.main+5541 @059c99> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5546 @059c9e> : 20                         load.i8
	<.main+5547 @059c9f> : 50                         neg.i32
	<.main+5548 @059ca0> : 1f 58 7d 05 00             load.ref <@057d58> ;chrNeg
	<.main+5553 @059ca5> : 25                         store.i8
	test/lang/useOperator.ci:34: (13 bytes: <@059ca6> - <@059cb3>): static chrCmt: char := char(~chrB)
	<.main+5554 @059ca6> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5559 @059cab> : 20                         load.i8
	<.main+5560 @059cac> : 30                         cmt.b32
	<.main+5561 @059cad> : 1f 60 7d 05 00             load.ref <@057d60> ;chrCmt
	<.main+5566 @059cb2> : 25                         store.i8
	test/lang/useOperator.ci:35: (19 bytes: <@059cb3> - <@059cc6>): static chrAdd: char := char(chrA + chrB)
	<.main+5567 @059cb3> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5572 @059cb8> : 20                         load.i8
	<.main+5573 @059cb9> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5578 @059cbe> : 20                         load.i8
	<.main+5579 @059cbf> : 51                         add.i32
	<.main+5580 @059cc0> : 1f 68 7d 05 00             load.ref <@057d68> ;chrAdd
	<.main+5585 @059cc5> : 25                         store.i8
	test/lang/useOperator.ci:36: (19 bytes: <@059cc6> - <@059cd9>): static chrSub: char := char(chrA - chrB)
	<.main+5586 @059cc6> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5591 @059ccb> : 20                         load.i8
	<.main+5592 @059ccc> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5597 @059cd1> : 20                         load.i8
	<.main+5598 @059cd2> : 52                         sub.i32
	<.main+5599 @059cd3> : 1f 70 7d 05 00             load.ref <@057d70> ;chrSub
	<.main+5604 @059cd8> : 25                         store.i8
	test/lang/useOperator.ci:37: (19 bytes: <@059cd9> - <@059cec>): static chrMul: char := char(chrA * chrB)
	<.main+5605 @059cd9> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5610 @059cde> : 20                         load.i8
	<.main+5611 @059cdf> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5616 @059ce4> : 20                         load.i8
	<.main+5617 @059ce5> : 53                         mul.i32
	<.main+5618 @059ce6> : 1f 78 7d 05 00             load.ref <@057d78> ;chrMul
	<.main+5623 @059ceb> : 25                         store.i8
	test/lang/useOperator.ci:38: (19 bytes: <@059cec> - <@059cff>): static chrDiv: char := char(chrA / chrB)
	<.main+5624 @059cec> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5629 @059cf1> : 20                         load.i8
	<.main+5630 @059cf2> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5635 @059cf7> : 20                         load.i8
	<.main+5636 @059cf8> : 54                         div.i32
	<.main+5637 @059cf9> : 1f 80 7d 05 00             load.ref <@057d80> ;chrDiv
	<.main+5642 @059cfe> : 25                         store.i8
	test/lang/useOperator.ci:39: (19 bytes: <@059cff> - <@059d12>): static chrMod: char := char(chrA % chrB)
	<.main+5643 @059cff> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5648 @059d04> : 20                         load.i8
	<.main+5649 @059d05> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5654 @059d0a> : 20                         load.i8
	<.main+5655 @059d0b> : 55                         mod.i32
	<.main+5656 @059d0c> : 1f 88 7d 05 00             load.ref <@057d88> ;chrMod
	<.main+5661 @059d11> : 25                         store.i8
	test/lang/useOperator.ci:40: (19 bytes: <@059d12> - <@059d25>): static chrAnd: char := char(chrA & chrB)
	<.main+5662 @059d12> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5667 @059d17> : 20                         load.i8
	<.main+5668 @059d18> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5673 @059d1d> : 20                         load.i8
	<.main+5674 @059d1e> : 31                         and.b32
	<.main+5675 @059d1f> : 1f 90 7d 05 00             load.ref <@057d90> ;chrAnd
	<.main+5680 @059d24> : 25                         store.i8
	test/lang/useOperator.ci:41: (19 bytes: <@059d25> - <@059d38>): static chrIor: char := char(chrA | chrB)
	<.main+5681 @059d25> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5686 @059d2a> : 20                         load.i8
	<.main+5687 @059d2b> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5692 @059d30> : 20                         load.i8
	<.main+5693 @059d31> : 32                         or.b32
	<.main+5694 @059d32> : 1f 98 7d 05 00             load.ref <@057d98> ;chrIor
	<.main+5699 @059d37> : 25                         store.i8
	test/lang/useOperator.ci:42: (19 bytes: <@059d38> - <@059d4b>): static chrXor: char := char(chrA ^ chrB)
	<.main+5700 @059d38> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5705 @059d3d> : 20                         load.i8
	<.main+5706 @059d3e> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5711 @059d43> : 20                         load.i8
	<.main+5712 @059d44> : 36                         xor.b32
	<.main+5713 @059d45> : 1f a0 7d 05 00             load.ref <@057da0> ;chrXor
	<.main+5718 @059d4a> : 25                         store.i8
	test/lang/useOperator.ci:43: (17 bytes: <@059d4b> - <@059d5c>): static chrShl: char := int32((chrA) << shift)
	<.main+5719 @059d4b> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5724 @059d50> : 20                         load.i8
	<.main+5725 @059d51> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+5729 @059d55> : 3a                         shl.b32
	<.main+5730 @059d56> : 1f a8 7d 05 00             load.ref <@057da8> ;chrShl
	<.main+5735 @059d5b> : 25                         store.i8
	test/lang/useOperator.ci:44: (17 bytes: <@059d5c> - <@059d6d>): static chrShr: char := int32((chrA) >> shift)
	<.main+5736 @059d5c> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5741 @059d61> : 20                         load.i8
	<.main+5742 @059d62> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+5746 @059d66> : 3c                         sar.b32
	<.main+5747 @059d67> : 1f b0 7d 05 00             load.ref <@057db0> ;chrShr
	<.main+5752 @059d6c> : 25                         store.i8
	test/lang/useOperator.ci:45: (14 bytes: <@059d6d> - <@059d7b>): static chrNot: bool := bool(!(chrB))
	<.main+5753 @059d6d> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5758 @059d72> : 20                         load.i8
	<.main+5759 @059d73> : 5a                         i32.2bool
	<.main+5760 @059d74> : 0b                         not.b32
	<.main+5761 @059d75> : 1f b8 7d 05 00             load.ref <@057db8> ;chrNot
	<.main+5766 @059d7a> : 25                         store.i8
	test/lang/useOperator.ci:46: (19 bytes: <@059d7b> - <@059d8e>): static chrCeq: bool := bool(chrA == chrB)
	<.main+5767 @059d7b> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5772 @059d80> : 20                         load.i8
	<.main+5773 @059d81> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5778 @059d86> : 20                         load.i8
	<.main+5779 @059d87> : 57                         ceq.i32
	<.main+5780 @059d88> : 1f c0 7d 05 00             load.ref <@057dc0> ;chrCeq
	<.main+5785 @059d8d> : 25                         store.i8
	test/lang/useOperator.ci:47: (20 bytes: <@059d8e> - <@059da2>): static chrCne: bool := bool(chrA != chrB)
	<.main+5786 @059d8e> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5791 @059d93> : 20                         load.i8
	<.main+5792 @059d94> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5797 @059d99> : 20                         load.i8
	<.main+5798 @059d9a> : 57                         ceq.i32
	<.main+5799 @059d9b> : 0b                         not.b32
	<.main+5800 @059d9c> : 1f c8 7d 05 00             load.ref <@057dc8> ;chrCne
	<.main+5805 @059da1> : 25                         store.i8
	test/lang/useOperator.ci:48: (19 bytes: <@059da2> - <@059db5>): static chrClt: bool := bool(chrA < chrB)
	<.main+5806 @059da2> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5811 @059da7> : 20                         load.i8
	<.main+5812 @059da8> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5817 @059dad> : 20                         load.i8
	<.main+5818 @059dae> : 58                         clt.i32
	<.main+5819 @059daf> : 1f d0 7d 05 00             load.ref <@057dd0> ;chrClt
	<.main+5824 @059db4> : 25                         store.i8
	test/lang/useOperator.ci:49: (20 bytes: <@059db5> - <@059dc9>): static chrCle: bool := bool(chrA <= chrB)
	<.main+5825 @059db5> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5830 @059dba> : 20                         load.i8
	<.main+5831 @059dbb> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5836 @059dc0> : 20                         load.i8
	<.main+5837 @059dc1> : 59                         cgt.i32
	<.main+5838 @059dc2> : 0b                         not.b32
	<.main+5839 @059dc3> : 1f d8 7d 05 00             load.ref <@057dd8> ;chrCle
	<.main+5844 @059dc8> : 25                         store.i8
	test/lang/useOperator.ci:50: (19 bytes: <@059dc9> - <@059ddc>): static chrCgt: bool := bool(chrA > chrB)
	<.main+5845 @059dc9> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5850 @059dce> : 20                         load.i8
	<.main+5851 @059dcf> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5856 @059dd4> : 20                         load.i8
	<.main+5857 @059dd5> : 59                         cgt.i32
	<.main+5858 @059dd6> : 1f e0 7d 05 00             load.ref <@057de0> ;chrCgt
	<.main+5863 @059ddb> : 25                         store.i8
	test/lang/useOperator.ci:51: (20 bytes: <@059ddc> - <@059df0>): static chrCge: bool := bool(chrA >= chrB)
	<.main+5864 @059ddc> : 1f 40 7d 05 00             load.ref <@057d40> ;chrA
	<.main+5869 @059de1> : 20                         load.i8
	<.main+5870 @059de2> : 1f 48 7d 05 00             load.ref <@057d48> ;chrB
	<.main+5875 @059de7> : 20                         load.i8
	<.main+5876 @059de8> : 58                         clt.i32
	<.main+5877 @059de9> : 0b                         not.b32
	<.main+5878 @059dea> : 1f e8 7d 05 00             load.ref <@057de8> ;chrCge
	<.main+5883 @059def> : 25                         store.i8
	test/lang/useOperator.ci:53: (11 bytes: <@059df0> - <@059dfb>): static i8A: int8 := a
	<.main+5884 @059df0> : 1c 60 00 00 00             load.c32 96
	<.main+5889 @059df5> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+5894 @059dfa> : 25                         store.i8
	test/lang/useOperator.ci:54: (11 bytes: <@059dfb> - <@059e06>): static i8B: int8 := b
	<.main+5895 @059dfb> : 1c 2a 00 00 00             load.c32 42
	<.main+5900 @059e00> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5905 @059e05> : 25                         store.i8
	test/lang/useOperator.ci:55: (12 bytes: <@059e06> - <@059e12>): static i8Pls: int8 := int8(+i8B)
	<.main+5906 @059e06> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5911 @059e0b> : 20                         load.i8
	<.main+5912 @059e0c> : 1f 00 7e 05 00             load.ref <@057e00> ;i8Pls
	<.main+5917 @059e11> : 25                         store.i8
	test/lang/useOperator.ci:56: (13 bytes: <@059e12> - <@059e1f>): static i8Neg: int8 := int8(-i8B)
	<.main+5918 @059e12> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5923 @059e17> : 20                         load.i8
	<.main+5924 @059e18> : 50                         neg.i32
	<.main+5925 @059e19> : 1f 08 7e 05 00             load.ref <@057e08> ;i8Neg
	<.main+5930 @059e1e> : 25                         store.i8
	test/lang/useOperator.ci:57: (13 bytes: <@059e1f> - <@059e2c>): static i8Cmt: int8 := int8(~i8B)
	<.main+5931 @059e1f> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5936 @059e24> : 20                         load.i8
	<.main+5937 @059e25> : 30                         cmt.b32
	<.main+5938 @059e26> : 1f 10 7e 05 00             load.ref <@057e10> ;i8Cmt
	<.main+5943 @059e2b> : 25                         store.i8
	test/lang/useOperator.ci:58: (19 bytes: <@059e2c> - <@059e3f>): static i8Add: int8 := int8(i8A + i8B)
	<.main+5944 @059e2c> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+5949 @059e31> : 20                         load.i8
	<.main+5950 @059e32> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5955 @059e37> : 20                         load.i8
	<.main+5956 @059e38> : 51                         add.i32
	<.main+5957 @059e39> : 1f 18 7e 05 00             load.ref <@057e18> ;i8Add
	<.main+5962 @059e3e> : 25                         store.i8
	test/lang/useOperator.ci:59: (19 bytes: <@059e3f> - <@059e52>): static i8Sub: int8 := int8(i8A - i8B)
	<.main+5963 @059e3f> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+5968 @059e44> : 20                         load.i8
	<.main+5969 @059e45> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5974 @059e4a> : 20                         load.i8
	<.main+5975 @059e4b> : 52                         sub.i32
	<.main+5976 @059e4c> : 1f 20 7e 05 00             load.ref <@057e20> ;i8Sub
	<.main+5981 @059e51> : 25                         store.i8
	test/lang/useOperator.ci:60: (19 bytes: <@059e52> - <@059e65>): static i8Mul: int8 := int8(i8A * i8B)
	<.main+5982 @059e52> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+5987 @059e57> : 20                         load.i8
	<.main+5988 @059e58> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+5993 @059e5d> : 20                         load.i8
	<.main+5994 @059e5e> : 53                         mul.i32
	<.main+5995 @059e5f> : 1f 28 7e 05 00             load.ref <@057e28> ;i8Mul
	<.main+6000 @059e64> : 25                         store.i8
	test/lang/useOperator.ci:61: (19 bytes: <@059e65> - <@059e78>): static i8Div: int8 := int8(i8A / i8B)
	<.main+6001 @059e65> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6006 @059e6a> : 20                         load.i8
	<.main+6007 @059e6b> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6012 @059e70> : 20                         load.i8
	<.main+6013 @059e71> : 54                         div.i32
	<.main+6014 @059e72> : 1f 30 7e 05 00             load.ref <@057e30> ;i8Div
	<.main+6019 @059e77> : 25                         store.i8
	test/lang/useOperator.ci:62: (19 bytes: <@059e78> - <@059e8b>): static i8Mod: int8 := int8(i8A % i8B)
	<.main+6020 @059e78> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6025 @059e7d> : 20                         load.i8
	<.main+6026 @059e7e> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6031 @059e83> : 20                         load.i8
	<.main+6032 @059e84> : 55                         mod.i32
	<.main+6033 @059e85> : 1f 38 7e 05 00             load.ref <@057e38> ;i8Mod
	<.main+6038 @059e8a> : 25                         store.i8
	test/lang/useOperator.ci:63: (19 bytes: <@059e8b> - <@059e9e>): static i8And: int8 := int8(i8A & i8B)
	<.main+6039 @059e8b> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6044 @059e90> : 20                         load.i8
	<.main+6045 @059e91> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6050 @059e96> : 20                         load.i8
	<.main+6051 @059e97> : 31                         and.b32
	<.main+6052 @059e98> : 1f 40 7e 05 00             load.ref <@057e40> ;i8And
	<.main+6057 @059e9d> : 25                         store.i8
	test/lang/useOperator.ci:64: (19 bytes: <@059e9e> - <@059eb1>): static i8Ior: int8 := int8(i8A | i8B)
	<.main+6058 @059e9e> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6063 @059ea3> : 20                         load.i8
	<.main+6064 @059ea4> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6069 @059ea9> : 20                         load.i8
	<.main+6070 @059eaa> : 32                         or.b32
	<.main+6071 @059eab> : 1f 48 7e 05 00             load.ref <@057e48> ;i8Ior
	<.main+6076 @059eb0> : 25                         store.i8
	test/lang/useOperator.ci:65: (19 bytes: <@059eb1> - <@059ec4>): static i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6077 @059eb1> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6082 @059eb6> : 20                         load.i8
	<.main+6083 @059eb7> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6088 @059ebc> : 20                         load.i8
	<.main+6089 @059ebd> : 36                         xor.b32
	<.main+6090 @059ebe> : 1f 50 7e 05 00             load.ref <@057e50> ;i8Xor
	<.main+6095 @059ec3> : 25                         store.i8
	test/lang/useOperator.ci:66: (17 bytes: <@059ec4> - <@059ed5>): static i8Shl: int8 := int32((i8A) << shift)
	<.main+6096 @059ec4> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6101 @059ec9> : 20                         load.i8
	<.main+6102 @059eca> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+6106 @059ece> : 3a                         shl.b32
	<.main+6107 @059ecf> : 1f 58 7e 05 00             load.ref <@057e58> ;i8Shl
	<.main+6112 @059ed4> : 25                         store.i8
	test/lang/useOperator.ci:67: (17 bytes: <@059ed5> - <@059ee6>): static i8Shr: int8 := int32((i8A) >> shift)
	<.main+6113 @059ed5> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6118 @059eda> : 20                         load.i8
	<.main+6119 @059edb> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+6123 @059edf> : 3c                         sar.b32
	<.main+6124 @059ee0> : 1f 60 7e 05 00             load.ref <@057e60> ;i8Shr
	<.main+6129 @059ee5> : 25                         store.i8
	test/lang/useOperator.ci:68: (14 bytes: <@059ee6> - <@059ef4>): static i8Not: bool := bool(!(i8B))
	<.main+6130 @059ee6> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6135 @059eeb> : 20                         load.i8
	<.main+6136 @059eec> : 5a                         i32.2bool
	<.main+6137 @059eed> : 0b                         not.b32
	<.main+6138 @059eee> : 1f 68 7e 05 00             load.ref <@057e68> ;i8Not
	<.main+6143 @059ef3> : 25                         store.i8
	test/lang/useOperator.ci:69: (19 bytes: <@059ef4> - <@059f07>): static i8Ceq: bool := bool(i8A == i8B)
	<.main+6144 @059ef4> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6149 @059ef9> : 20                         load.i8
	<.main+6150 @059efa> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6155 @059eff> : 20                         load.i8
	<.main+6156 @059f00> : 57                         ceq.i32
	<.main+6157 @059f01> : 1f 70 7e 05 00             load.ref <@057e70> ;i8Ceq
	<.main+6162 @059f06> : 25                         store.i8
	test/lang/useOperator.ci:70: (20 bytes: <@059f07> - <@059f1b>): static i8Cne: bool := bool(i8A != i8B)
	<.main+6163 @059f07> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6168 @059f0c> : 20                         load.i8
	<.main+6169 @059f0d> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6174 @059f12> : 20                         load.i8
	<.main+6175 @059f13> : 57                         ceq.i32
	<.main+6176 @059f14> : 0b                         not.b32
	<.main+6177 @059f15> : 1f 78 7e 05 00             load.ref <@057e78> ;i8Cne
	<.main+6182 @059f1a> : 25                         store.i8
	test/lang/useOperator.ci:71: (19 bytes: <@059f1b> - <@059f2e>): static i8Clt: bool := bool(i8A < i8B)
	<.main+6183 @059f1b> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6188 @059f20> : 20                         load.i8
	<.main+6189 @059f21> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6194 @059f26> : 20                         load.i8
	<.main+6195 @059f27> : 58                         clt.i32
	<.main+6196 @059f28> : 1f 80 7e 05 00             load.ref <@057e80> ;i8Clt
	<.main+6201 @059f2d> : 25                         store.i8
	test/lang/useOperator.ci:72: (20 bytes: <@059f2e> - <@059f42>): static i8Cle: bool := bool(i8A <= i8B)
	<.main+6202 @059f2e> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6207 @059f33> : 20                         load.i8
	<.main+6208 @059f34> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6213 @059f39> : 20                         load.i8
	<.main+6214 @059f3a> : 59                         cgt.i32
	<.main+6215 @059f3b> : 0b                         not.b32
	<.main+6216 @059f3c> : 1f 88 7e 05 00             load.ref <@057e88> ;i8Cle
	<.main+6221 @059f41> : 25                         store.i8
	test/lang/useOperator.ci:73: (19 bytes: <@059f42> - <@059f55>): static i8Cgt: bool := bool(i8A > i8B)
	<.main+6222 @059f42> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6227 @059f47> : 20                         load.i8
	<.main+6228 @059f48> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6233 @059f4d> : 20                         load.i8
	<.main+6234 @059f4e> : 59                         cgt.i32
	<.main+6235 @059f4f> : 1f 90 7e 05 00             load.ref <@057e90> ;i8Cgt
	<.main+6240 @059f54> : 25                         store.i8
	test/lang/useOperator.ci:74: (20 bytes: <@059f55> - <@059f69>): static i8Cge: bool := bool(i8A >= i8B)
	<.main+6241 @059f55> : 1f f0 7d 05 00             load.ref <@057df0> ;i8A
	<.main+6246 @059f5a> : 20                         load.i8
	<.main+6247 @059f5b> : 1f f8 7d 05 00             load.ref <@057df8> ;i8B
	<.main+6252 @059f60> : 20                         load.i8
	<.main+6253 @059f61> : 58                         clt.i32
	<.main+6254 @059f62> : 0b                         not.b32
	<.main+6255 @059f63> : 1f 98 7e 05 00             load.ref <@057e98> ;i8Cge
	<.main+6260 @059f68> : 25                         store.i8
	test/lang/useOperator.ci:76: (11 bytes: <@059f69> - <@059f74>): static u8A: uint8 := a
	<.main+6261 @059f69> : 1c 60 00 00 00             load.c32 96
	<.main+6266 @059f6e> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6271 @059f73> : 25                         store.i8
	test/lang/useOperator.ci:77: (11 bytes: <@059f74> - <@059f7f>): static u8B: uint8 := b
	<.main+6272 @059f74> : 1c 2a 00 00 00             load.c32 42
	<.main+6277 @059f79> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6282 @059f7e> : 25                         store.i8
	test/lang/useOperator.ci:78: (12 bytes: <@059f7f> - <@059f8b>): static u8Pls: uint8 := uint8(+u8B)
	<.main+6283 @059f7f> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6288 @059f84> : 20                         load.i8
	<.main+6289 @059f85> : 1f b0 7e 05 00             load.ref <@057eb0> ;u8Pls
	<.main+6294 @059f8a> : 25                         store.i8
	test/lang/useOperator.ci:79: (13 bytes: <@059f8b> - <@059f98>): static u8Neg: uint8 := uint8(-u8B)
	<.main+6295 @059f8b> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6300 @059f90> : 20                         load.i8
	<.main+6301 @059f91> : 50                         neg.i32
	<.main+6302 @059f92> : 1f b8 7e 05 00             load.ref <@057eb8> ;u8Neg
	<.main+6307 @059f97> : 25                         store.i8
	test/lang/useOperator.ci:80: (13 bytes: <@059f98> - <@059fa5>): static u8Cmt: uint8 := uint8(~u8B)
	<.main+6308 @059f98> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6313 @059f9d> : 20                         load.i8
	<.main+6314 @059f9e> : 30                         cmt.b32
	<.main+6315 @059f9f> : 1f c0 7e 05 00             load.ref <@057ec0> ;u8Cmt
	<.main+6320 @059fa4> : 25                         store.i8
	test/lang/useOperator.ci:81: (19 bytes: <@059fa5> - <@059fb8>): static u8Add: uint8 := uint8(u8A + u8B)
	<.main+6321 @059fa5> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6326 @059faa> : 20                         load.i8
	<.main+6327 @059fab> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6332 @059fb0> : 20                         load.i8
	<.main+6333 @059fb1> : 51                         add.i32
	<.main+6334 @059fb2> : 1f c8 7e 05 00             load.ref <@057ec8> ;u8Add
	<.main+6339 @059fb7> : 25                         store.i8
	test/lang/useOperator.ci:82: (19 bytes: <@059fb8> - <@059fcb>): static u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6340 @059fb8> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6345 @059fbd> : 20                         load.i8
	<.main+6346 @059fbe> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6351 @059fc3> : 20                         load.i8
	<.main+6352 @059fc4> : 52                         sub.i32
	<.main+6353 @059fc5> : 1f d0 7e 05 00             load.ref <@057ed0> ;u8Sub
	<.main+6358 @059fca> : 25                         store.i8
	test/lang/useOperator.ci:83: (19 bytes: <@059fcb> - <@059fde>): static u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6359 @059fcb> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6364 @059fd0> : 20                         load.i8
	<.main+6365 @059fd1> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6370 @059fd6> : 20                         load.i8
	<.main+6371 @059fd7> : 33                         mul.u32
	<.main+6372 @059fd8> : 1f d8 7e 05 00             load.ref <@057ed8> ;u8Mul
	<.main+6377 @059fdd> : 25                         store.i8
	test/lang/useOperator.ci:84: (19 bytes: <@059fde> - <@059ff1>): static u8Div: uint8 := uint8(u8A / u8B)
	<.main+6378 @059fde> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6383 @059fe3> : 20                         load.i8
	<.main+6384 @059fe4> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6389 @059fe9> : 20                         load.i8
	<.main+6390 @059fea> : 34                         div.u32
	<.main+6391 @059feb> : 1f e0 7e 05 00             load.ref <@057ee0> ;u8Div
	<.main+6396 @059ff0> : 25                         store.i8
	test/lang/useOperator.ci:85: (19 bytes: <@059ff1> - <@05a004>): static u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6397 @059ff1> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6402 @059ff6> : 20                         load.i8
	<.main+6403 @059ff7> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6408 @059ffc> : 20                         load.i8
	<.main+6409 @059ffd> : 35                         mod.u32
	<.main+6410 @059ffe> : 1f e8 7e 05 00             load.ref <@057ee8> ;u8Mod
	<.main+6415 @05a003> : 25                         store.i8
	test/lang/useOperator.ci:86: (19 bytes: <@05a004> - <@05a017>): static u8And: uint8 := uint8(u8A & u8B)
	<.main+6416 @05a004> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6421 @05a009> : 20                         load.i8
	<.main+6422 @05a00a> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6427 @05a00f> : 20                         load.i8
	<.main+6428 @05a010> : 31                         and.b32
	<.main+6429 @05a011> : 1f f0 7e 05 00             load.ref <@057ef0> ;u8And
	<.main+6434 @05a016> : 25                         store.i8
	test/lang/useOperator.ci:87: (19 bytes: <@05a017> - <@05a02a>): static u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6435 @05a017> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6440 @05a01c> : 20                         load.i8
	<.main+6441 @05a01d> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6446 @05a022> : 20                         load.i8
	<.main+6447 @05a023> : 32                         or.b32
	<.main+6448 @05a024> : 1f f8 7e 05 00             load.ref <@057ef8> ;u8Ior
	<.main+6453 @05a029> : 25                         store.i8
	test/lang/useOperator.ci:88: (19 bytes: <@05a02a> - <@05a03d>): static u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6454 @05a02a> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6459 @05a02f> : 20                         load.i8
	<.main+6460 @05a030> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6465 @05a035> : 20                         load.i8
	<.main+6466 @05a036> : 36                         xor.b32
	<.main+6467 @05a037> : 1f 00 7f 05 00             load.ref <@057f00> ;u8Xor
	<.main+6472 @05a03c> : 25                         store.i8
	test/lang/useOperator.ci:89: (17 bytes: <@05a03d> - <@05a04e>): static u8Shl: uint8 := int32((u8A) << shift)
	<.main+6473 @05a03d> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6478 @05a042> : 20                         load.i8
	<.main+6479 @05a043> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+6483 @05a047> : 3a                         shl.b32
	<.main+6484 @05a048> : 1f 08 7f 05 00             load.ref <@057f08> ;u8Shl
	<.main+6489 @05a04d> : 25                         store.i8
	test/lang/useOperator.ci:90: (17 bytes: <@05a04e> - <@05a05f>): static u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6490 @05a04e> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6495 @05a053> : 20                         load.i8
	<.main+6496 @05a054> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+6500 @05a058> : 3c                         sar.b32
	<.main+6501 @05a059> : 1f 10 7f 05 00             load.ref <@057f10> ;u8Shr
	<.main+6506 @05a05e> : 25                         store.i8
	test/lang/useOperator.ci:91: (14 bytes: <@05a05f> - <@05a06d>): static u8Not: bool := bool(!(u8B))
	<.main+6507 @05a05f> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6512 @05a064> : 20                         load.i8
	<.main+6513 @05a065> : 5a                         i32.2bool
	<.main+6514 @05a066> : 0b                         not.b32
	<.main+6515 @05a067> : 1f 18 7f 05 00             load.ref <@057f18> ;u8Not
	<.main+6520 @05a06c> : 25                         store.i8
	test/lang/useOperator.ci:92: (19 bytes: <@05a06d> - <@05a080>): static u8Ceq: bool := bool(u8A == u8B)
	<.main+6521 @05a06d> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6526 @05a072> : 20                         load.i8
	<.main+6527 @05a073> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6532 @05a078> : 20                         load.i8
	<.main+6533 @05a079> : 57                         ceq.i32
	<.main+6534 @05a07a> : 1f 20 7f 05 00             load.ref <@057f20> ;u8Ceq
	<.main+6539 @05a07f> : 25                         store.i8
	test/lang/useOperator.ci:93: (20 bytes: <@05a080> - <@05a094>): static u8Cne: bool := bool(u8A != u8B)
	<.main+6540 @05a080> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6545 @05a085> : 20                         load.i8
	<.main+6546 @05a086> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6551 @05a08b> : 20                         load.i8
	<.main+6552 @05a08c> : 57                         ceq.i32
	<.main+6553 @05a08d> : 0b                         not.b32
	<.main+6554 @05a08e> : 1f 28 7f 05 00             load.ref <@057f28> ;u8Cne
	<.main+6559 @05a093> : 25                         store.i8
	test/lang/useOperator.ci:94: (19 bytes: <@05a094> - <@05a0a7>): static u8Clt: bool := bool(u8A < u8B)
	<.main+6560 @05a094> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6565 @05a099> : 20                         load.i8
	<.main+6566 @05a09a> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6571 @05a09f> : 20                         load.i8
	<.main+6572 @05a0a0> : 38                         clt.u32
	<.main+6573 @05a0a1> : 1f 30 7f 05 00             load.ref <@057f30> ;u8Clt
	<.main+6578 @05a0a6> : 25                         store.i8
	test/lang/useOperator.ci:95: (20 bytes: <@05a0a7> - <@05a0bb>): static u8Cle: bool := bool(u8A <= u8B)
	<.main+6579 @05a0a7> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6584 @05a0ac> : 20                         load.i8
	<.main+6585 @05a0ad> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6590 @05a0b2> : 20                         load.i8
	<.main+6591 @05a0b3> : 39                         cgt.u32
	<.main+6592 @05a0b4> : 0b                         not.b32
	<.main+6593 @05a0b5> : 1f 38 7f 05 00             load.ref <@057f38> ;u8Cle
	<.main+6598 @05a0ba> : 25                         store.i8
	test/lang/useOperator.ci:96: (19 bytes: <@05a0bb> - <@05a0ce>): static u8Cgt: bool := bool(u8A > u8B)
	<.main+6599 @05a0bb> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6604 @05a0c0> : 20                         load.i8
	<.main+6605 @05a0c1> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6610 @05a0c6> : 20                         load.i8
	<.main+6611 @05a0c7> : 39                         cgt.u32
	<.main+6612 @05a0c8> : 1f 40 7f 05 00             load.ref <@057f40> ;u8Cgt
	<.main+6617 @05a0cd> : 25                         store.i8
	test/lang/useOperator.ci:97: (20 bytes: <@05a0ce> - <@05a0e2>): static u8Cge: bool := bool(u8A >= u8B)
	<.main+6618 @05a0ce> : 1f a0 7e 05 00             load.ref <@057ea0> ;u8A
	<.main+6623 @05a0d3> : 20                         load.i8
	<.main+6624 @05a0d4> : 1f a8 7e 05 00             load.ref <@057ea8> ;u8B
	<.main+6629 @05a0d9> : 20                         load.i8
	<.main+6630 @05a0da> : 38                         clt.u32
	<.main+6631 @05a0db> : 0b                         not.b32
	<.main+6632 @05a0dc> : 1f 48 7f 05 00             load.ref <@057f48> ;u8Cge
	<.main+6637 @05a0e1> : 25                         store.i8
	test/lang/useOperator.ci:99: (11 bytes: <@05a0e2> - <@05a0ed>): static i16A: int16 := a
	<.main+6638 @05a0e2> : 1c 60 00 00 00             load.c32 96
	<.main+6643 @05a0e7> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6648 @05a0ec> : 26                         store.i16
	test/lang/useOperator.ci:100: (11 bytes: <@05a0ed> - <@05a0f8>): static i16B: int16 := b
	<.main+6649 @05a0ed> : 1c 2a 00 00 00             load.c32 42
	<.main+6654 @05a0f2> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6659 @05a0f7> : 26                         store.i16
	test/lang/useOperator.ci:101: (12 bytes: <@05a0f8> - <@05a104>): static i16Pls: int16 := int16(+i16B)
	<.main+6660 @05a0f8> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6665 @05a0fd> : 21                         load.i16
	<.main+6666 @05a0fe> : 1f 60 7f 05 00             load.ref <@057f60> ;i16Pls
	<.main+6671 @05a103> : 26                         store.i16
	test/lang/useOperator.ci:102: (13 bytes: <@05a104> - <@05a111>): static i16Neg: int16 := int16(-i16B)
	<.main+6672 @05a104> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6677 @05a109> : 21                         load.i16
	<.main+6678 @05a10a> : 50                         neg.i32
	<.main+6679 @05a10b> : 1f 68 7f 05 00             load.ref <@057f68> ;i16Neg
	<.main+6684 @05a110> : 26                         store.i16
	test/lang/useOperator.ci:103: (13 bytes: <@05a111> - <@05a11e>): static i16Cmt: int16 := int16(~i16B)
	<.main+6685 @05a111> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6690 @05a116> : 21                         load.i16
	<.main+6691 @05a117> : 30                         cmt.b32
	<.main+6692 @05a118> : 1f 70 7f 05 00             load.ref <@057f70> ;i16Cmt
	<.main+6697 @05a11d> : 26                         store.i16
	test/lang/useOperator.ci:104: (19 bytes: <@05a11e> - <@05a131>): static i16Add: int16 := int16(i16A + i16B)
	<.main+6698 @05a11e> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6703 @05a123> : 21                         load.i16
	<.main+6704 @05a124> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6709 @05a129> : 21                         load.i16
	<.main+6710 @05a12a> : 51                         add.i32
	<.main+6711 @05a12b> : 1f 78 7f 05 00             load.ref <@057f78> ;i16Add
	<.main+6716 @05a130> : 26                         store.i16
	test/lang/useOperator.ci:105: (19 bytes: <@05a131> - <@05a144>): static i16Sub: int16 := int16(i16A - i16B)
	<.main+6717 @05a131> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6722 @05a136> : 21                         load.i16
	<.main+6723 @05a137> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6728 @05a13c> : 21                         load.i16
	<.main+6729 @05a13d> : 52                         sub.i32
	<.main+6730 @05a13e> : 1f 80 7f 05 00             load.ref <@057f80> ;i16Sub
	<.main+6735 @05a143> : 26                         store.i16
	test/lang/useOperator.ci:106: (19 bytes: <@05a144> - <@05a157>): static i16Mul: int16 := int16(i16A * i16B)
	<.main+6736 @05a144> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6741 @05a149> : 21                         load.i16
	<.main+6742 @05a14a> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6747 @05a14f> : 21                         load.i16
	<.main+6748 @05a150> : 53                         mul.i32
	<.main+6749 @05a151> : 1f 88 7f 05 00             load.ref <@057f88> ;i16Mul
	<.main+6754 @05a156> : 26                         store.i16
	test/lang/useOperator.ci:107: (19 bytes: <@05a157> - <@05a16a>): static i16Div: int16 := int16(i16A / i16B)
	<.main+6755 @05a157> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6760 @05a15c> : 21                         load.i16
	<.main+6761 @05a15d> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6766 @05a162> : 21                         load.i16
	<.main+6767 @05a163> : 54                         div.i32
	<.main+6768 @05a164> : 1f 90 7f 05 00             load.ref <@057f90> ;i16Div
	<.main+6773 @05a169> : 26                         store.i16
	test/lang/useOperator.ci:108: (19 bytes: <@05a16a> - <@05a17d>): static i16Mod: int16 := int16(i16A % i16B)
	<.main+6774 @05a16a> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6779 @05a16f> : 21                         load.i16
	<.main+6780 @05a170> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6785 @05a175> : 21                         load.i16
	<.main+6786 @05a176> : 55                         mod.i32
	<.main+6787 @05a177> : 1f 98 7f 05 00             load.ref <@057f98> ;i16Mod
	<.main+6792 @05a17c> : 26                         store.i16
	test/lang/useOperator.ci:109: (19 bytes: <@05a17d> - <@05a190>): static i16And: int16 := int16(i16A & i16B)
	<.main+6793 @05a17d> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6798 @05a182> : 21                         load.i16
	<.main+6799 @05a183> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6804 @05a188> : 21                         load.i16
	<.main+6805 @05a189> : 31                         and.b32
	<.main+6806 @05a18a> : 1f a0 7f 05 00             load.ref <@057fa0> ;i16And
	<.main+6811 @05a18f> : 26                         store.i16
	test/lang/useOperator.ci:110: (19 bytes: <@05a190> - <@05a1a3>): static i16Ior: int16 := int16(i16A | i16B)
	<.main+6812 @05a190> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6817 @05a195> : 21                         load.i16
	<.main+6818 @05a196> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6823 @05a19b> : 21                         load.i16
	<.main+6824 @05a19c> : 32                         or.b32
	<.main+6825 @05a19d> : 1f a8 7f 05 00             load.ref <@057fa8> ;i16Ior
	<.main+6830 @05a1a2> : 26                         store.i16
	test/lang/useOperator.ci:111: (19 bytes: <@05a1a3> - <@05a1b6>): static i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6831 @05a1a3> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6836 @05a1a8> : 21                         load.i16
	<.main+6837 @05a1a9> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6842 @05a1ae> : 21                         load.i16
	<.main+6843 @05a1af> : 36                         xor.b32
	<.main+6844 @05a1b0> : 1f b0 7f 05 00             load.ref <@057fb0> ;i16Xor
	<.main+6849 @05a1b5> : 26                         store.i16
	test/lang/useOperator.ci:112: (17 bytes: <@05a1b6> - <@05a1c7>): static i16Shl: int16 := int32((i16A) << shift)
	<.main+6850 @05a1b6> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6855 @05a1bb> : 21                         load.i16
	<.main+6856 @05a1bc> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+6860 @05a1c0> : 3a                         shl.b32
	<.main+6861 @05a1c1> : 1f b8 7f 05 00             load.ref <@057fb8> ;i16Shl
	<.main+6866 @05a1c6> : 26                         store.i16
	test/lang/useOperator.ci:113: (17 bytes: <@05a1c7> - <@05a1d8>): static i16Shr: int16 := int32((i16A) >> shift)
	<.main+6867 @05a1c7> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6872 @05a1cc> : 21                         load.i16
	<.main+6873 @05a1cd> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+6877 @05a1d1> : 3c                         sar.b32
	<.main+6878 @05a1d2> : 1f c0 7f 05 00             load.ref <@057fc0> ;i16Shr
	<.main+6883 @05a1d7> : 26                         store.i16
	test/lang/useOperator.ci:114: (14 bytes: <@05a1d8> - <@05a1e6>): static i16Not: bool := bool(!(i16B))
	<.main+6884 @05a1d8> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6889 @05a1dd> : 21                         load.i16
	<.main+6890 @05a1de> : 5a                         i32.2bool
	<.main+6891 @05a1df> : 0b                         not.b32
	<.main+6892 @05a1e0> : 1f c8 7f 05 00             load.ref <@057fc8> ;i16Not
	<.main+6897 @05a1e5> : 25                         store.i8
	test/lang/useOperator.ci:115: (19 bytes: <@05a1e6> - <@05a1f9>): static i16Ceq: bool := bool(i16A == i16B)
	<.main+6898 @05a1e6> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6903 @05a1eb> : 21                         load.i16
	<.main+6904 @05a1ec> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6909 @05a1f1> : 21                         load.i16
	<.main+6910 @05a1f2> : 57                         ceq.i32
	<.main+6911 @05a1f3> : 1f d0 7f 05 00             load.ref <@057fd0> ;i16Ceq
	<.main+6916 @05a1f8> : 25                         store.i8
	test/lang/useOperator.ci:116: (20 bytes: <@05a1f9> - <@05a20d>): static i16Cne: bool := bool(i16A != i16B)
	<.main+6917 @05a1f9> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6922 @05a1fe> : 21                         load.i16
	<.main+6923 @05a1ff> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6928 @05a204> : 21                         load.i16
	<.main+6929 @05a205> : 57                         ceq.i32
	<.main+6930 @05a206> : 0b                         not.b32
	<.main+6931 @05a207> : 1f d8 7f 05 00             load.ref <@057fd8> ;i16Cne
	<.main+6936 @05a20c> : 25                         store.i8
	test/lang/useOperator.ci:117: (19 bytes: <@05a20d> - <@05a220>): static i16Clt: bool := bool(i16A < i16B)
	<.main+6937 @05a20d> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6942 @05a212> : 21                         load.i16
	<.main+6943 @05a213> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6948 @05a218> : 21                         load.i16
	<.main+6949 @05a219> : 58                         clt.i32
	<.main+6950 @05a21a> : 1f e0 7f 05 00             load.ref <@057fe0> ;i16Clt
	<.main+6955 @05a21f> : 25                         store.i8
	test/lang/useOperator.ci:118: (20 bytes: <@05a220> - <@05a234>): static i16Cle: bool := bool(i16A <= i16B)
	<.main+6956 @05a220> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6961 @05a225> : 21                         load.i16
	<.main+6962 @05a226> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6967 @05a22b> : 21                         load.i16
	<.main+6968 @05a22c> : 59                         cgt.i32
	<.main+6969 @05a22d> : 0b                         not.b32
	<.main+6970 @05a22e> : 1f e8 7f 05 00             load.ref <@057fe8> ;i16Cle
	<.main+6975 @05a233> : 25                         store.i8
	test/lang/useOperator.ci:119: (19 bytes: <@05a234> - <@05a247>): static i16Cgt: bool := bool(i16A > i16B)
	<.main+6976 @05a234> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+6981 @05a239> : 21                         load.i16
	<.main+6982 @05a23a> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+6987 @05a23f> : 21                         load.i16
	<.main+6988 @05a240> : 59                         cgt.i32
	<.main+6989 @05a241> : 1f f0 7f 05 00             load.ref <@057ff0> ;i16Cgt
	<.main+6994 @05a246> : 25                         store.i8
	test/lang/useOperator.ci:120: (20 bytes: <@05a247> - <@05a25b>): static i16Cge: bool := bool(i16A >= i16B)
	<.main+6995 @05a247> : 1f 50 7f 05 00             load.ref <@057f50> ;i16A
	<.main+7000 @05a24c> : 21                         load.i16
	<.main+7001 @05a24d> : 1f 58 7f 05 00             load.ref <@057f58> ;i16B
	<.main+7006 @05a252> : 21                         load.i16
	<.main+7007 @05a253> : 58                         clt.i32
	<.main+7008 @05a254> : 0b                         not.b32
	<.main+7009 @05a255> : 1f f8 7f 05 00             load.ref <@057ff8> ;i16Cge
	<.main+7014 @05a25a> : 25                         store.i8
	test/lang/useOperator.ci:122: (11 bytes: <@05a25b> - <@05a266>): static u16A: uint16 := a
	<.main+7015 @05a25b> : 1c 60 00 00 00             load.c32 96
	<.main+7020 @05a260> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7025 @05a265> : 26                         store.i16
	test/lang/useOperator.ci:123: (11 bytes: <@05a266> - <@05a271>): static u16B: uint16 := b
	<.main+7026 @05a266> : 1c 2a 00 00 00             load.c32 42
	<.main+7031 @05a26b> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7036 @05a270> : 26                         store.i16
	test/lang/useOperator.ci:124: (12 bytes: <@05a271> - <@05a27d>): static u16Pls: uint16 := uint16(+u16B)
	<.main+7037 @05a271> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7042 @05a276> : 21                         load.i16
	<.main+7043 @05a277> : 1f 10 80 05 00             load.ref <@058010> ;u16Pls
	<.main+7048 @05a27c> : 26                         store.i16
	test/lang/useOperator.ci:125: (13 bytes: <@05a27d> - <@05a28a>): static u16Neg: uint16 := uint16(-u16B)
	<.main+7049 @05a27d> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7054 @05a282> : 21                         load.i16
	<.main+7055 @05a283> : 50                         neg.i32
	<.main+7056 @05a284> : 1f 18 80 05 00             load.ref <@058018> ;u16Neg
	<.main+7061 @05a289> : 26                         store.i16
	test/lang/useOperator.ci:126: (13 bytes: <@05a28a> - <@05a297>): static u16Cmt: uint16 := uint16(~u16B)
	<.main+7062 @05a28a> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7067 @05a28f> : 21                         load.i16
	<.main+7068 @05a290> : 30                         cmt.b32
	<.main+7069 @05a291> : 1f 20 80 05 00             load.ref <@058020> ;u16Cmt
	<.main+7074 @05a296> : 26                         store.i16
	test/lang/useOperator.ci:127: (19 bytes: <@05a297> - <@05a2aa>): static u16Add: uint16 := uint16(u16A + u16B)
	<.main+7075 @05a297> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7080 @05a29c> : 21                         load.i16
	<.main+7081 @05a29d> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7086 @05a2a2> : 21                         load.i16
	<.main+7087 @05a2a3> : 51                         add.i32
	<.main+7088 @05a2a4> : 1f 28 80 05 00             load.ref <@058028> ;u16Add
	<.main+7093 @05a2a9> : 26                         store.i16
	test/lang/useOperator.ci:128: (19 bytes: <@05a2aa> - <@05a2bd>): static u16Sub: uint16 := uint16(u16A - u16B)
	<.main+7094 @05a2aa> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7099 @05a2af> : 21                         load.i16
	<.main+7100 @05a2b0> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7105 @05a2b5> : 21                         load.i16
	<.main+7106 @05a2b6> : 52                         sub.i32
	<.main+7107 @05a2b7> : 1f 30 80 05 00             load.ref <@058030> ;u16Sub
	<.main+7112 @05a2bc> : 26                         store.i16
	test/lang/useOperator.ci:129: (19 bytes: <@05a2bd> - <@05a2d0>): static u16Mul: uint16 := uint16(u16A * u16B)
	<.main+7113 @05a2bd> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7118 @05a2c2> : 21                         load.i16
	<.main+7119 @05a2c3> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7124 @05a2c8> : 21                         load.i16
	<.main+7125 @05a2c9> : 33                         mul.u32
	<.main+7126 @05a2ca> : 1f 38 80 05 00             load.ref <@058038> ;u16Mul
	<.main+7131 @05a2cf> : 26                         store.i16
	test/lang/useOperator.ci:130: (19 bytes: <@05a2d0> - <@05a2e3>): static u16Div: uint16 := uint16(u16A / u16B)
	<.main+7132 @05a2d0> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7137 @05a2d5> : 21                         load.i16
	<.main+7138 @05a2d6> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7143 @05a2db> : 21                         load.i16
	<.main+7144 @05a2dc> : 34                         div.u32
	<.main+7145 @05a2dd> : 1f 40 80 05 00             load.ref <@058040> ;u16Div
	<.main+7150 @05a2e2> : 26                         store.i16
	test/lang/useOperator.ci:131: (19 bytes: <@05a2e3> - <@05a2f6>): static u16Mod: uint16 := uint16(u16A % u16B)
	<.main+7151 @05a2e3> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7156 @05a2e8> : 21                         load.i16
	<.main+7157 @05a2e9> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7162 @05a2ee> : 21                         load.i16
	<.main+7163 @05a2ef> : 35                         mod.u32
	<.main+7164 @05a2f0> : 1f 48 80 05 00             load.ref <@058048> ;u16Mod
	<.main+7169 @05a2f5> : 26                         store.i16
	test/lang/useOperator.ci:132: (19 bytes: <@05a2f6> - <@05a309>): static u16And: uint16 := uint16(u16A & u16B)
	<.main+7170 @05a2f6> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7175 @05a2fb> : 21                         load.i16
	<.main+7176 @05a2fc> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7181 @05a301> : 21                         load.i16
	<.main+7182 @05a302> : 31                         and.b32
	<.main+7183 @05a303> : 1f 50 80 05 00             load.ref <@058050> ;u16And
	<.main+7188 @05a308> : 26                         store.i16
	test/lang/useOperator.ci:133: (19 bytes: <@05a309> - <@05a31c>): static u16Ior: uint16 := uint16(u16A | u16B)
	<.main+7189 @05a309> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7194 @05a30e> : 21                         load.i16
	<.main+7195 @05a30f> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7200 @05a314> : 21                         load.i16
	<.main+7201 @05a315> : 32                         or.b32
	<.main+7202 @05a316> : 1f 58 80 05 00             load.ref <@058058> ;u16Ior
	<.main+7207 @05a31b> : 26                         store.i16
	test/lang/useOperator.ci:134: (19 bytes: <@05a31c> - <@05a32f>): static u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+7208 @05a31c> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7213 @05a321> : 21                         load.i16
	<.main+7214 @05a322> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7219 @05a327> : 21                         load.i16
	<.main+7220 @05a328> : 36                         xor.b32
	<.main+7221 @05a329> : 1f 60 80 05 00             load.ref <@058060> ;u16Xor
	<.main+7226 @05a32e> : 26                         store.i16
	test/lang/useOperator.ci:135: (17 bytes: <@05a32f> - <@05a340>): static u16Shl: uint16 := int32((u16A) << shift)
	<.main+7227 @05a32f> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7232 @05a334> : 21                         load.i16
	<.main+7233 @05a335> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+7237 @05a339> : 3a                         shl.b32
	<.main+7238 @05a33a> : 1f 68 80 05 00             load.ref <@058068> ;u16Shl
	<.main+7243 @05a33f> : 26                         store.i16
	test/lang/useOperator.ci:136: (17 bytes: <@05a340> - <@05a351>): static u16Shr: uint16 := int32((u16A) >> shift)
	<.main+7244 @05a340> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7249 @05a345> : 21                         load.i16
	<.main+7250 @05a346> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+7254 @05a34a> : 3c                         sar.b32
	<.main+7255 @05a34b> : 1f 70 80 05 00             load.ref <@058070> ;u16Shr
	<.main+7260 @05a350> : 26                         store.i16
	test/lang/useOperator.ci:137: (14 bytes: <@05a351> - <@05a35f>): static u16Not: bool := bool(!(u16B))
	<.main+7261 @05a351> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7266 @05a356> : 21                         load.i16
	<.main+7267 @05a357> : 5a                         i32.2bool
	<.main+7268 @05a358> : 0b                         not.b32
	<.main+7269 @05a359> : 1f 78 80 05 00             load.ref <@058078> ;u16Not
	<.main+7274 @05a35e> : 25                         store.i8
	test/lang/useOperator.ci:138: (19 bytes: <@05a35f> - <@05a372>): static u16Ceq: bool := bool(u16A == u16B)
	<.main+7275 @05a35f> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7280 @05a364> : 21                         load.i16
	<.main+7281 @05a365> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7286 @05a36a> : 21                         load.i16
	<.main+7287 @05a36b> : 57                         ceq.i32
	<.main+7288 @05a36c> : 1f 80 80 05 00             load.ref <@058080> ;u16Ceq
	<.main+7293 @05a371> : 25                         store.i8
	test/lang/useOperator.ci:139: (20 bytes: <@05a372> - <@05a386>): static u16Cne: bool := bool(u16A != u16B)
	<.main+7294 @05a372> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7299 @05a377> : 21                         load.i16
	<.main+7300 @05a378> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7305 @05a37d> : 21                         load.i16
	<.main+7306 @05a37e> : 57                         ceq.i32
	<.main+7307 @05a37f> : 0b                         not.b32
	<.main+7308 @05a380> : 1f 88 80 05 00             load.ref <@058088> ;u16Cne
	<.main+7313 @05a385> : 25                         store.i8
	test/lang/useOperator.ci:140: (19 bytes: <@05a386> - <@05a399>): static u16Clt: bool := bool(u16A < u16B)
	<.main+7314 @05a386> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7319 @05a38b> : 21                         load.i16
	<.main+7320 @05a38c> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7325 @05a391> : 21                         load.i16
	<.main+7326 @05a392> : 38                         clt.u32
	<.main+7327 @05a393> : 1f 90 80 05 00             load.ref <@058090> ;u16Clt
	<.main+7332 @05a398> : 25                         store.i8
	test/lang/useOperator.ci:141: (20 bytes: <@05a399> - <@05a3ad>): static u16Cle: bool := bool(u16A <= u16B)
	<.main+7333 @05a399> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7338 @05a39e> : 21                         load.i16
	<.main+7339 @05a39f> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7344 @05a3a4> : 21                         load.i16
	<.main+7345 @05a3a5> : 39                         cgt.u32
	<.main+7346 @05a3a6> : 0b                         not.b32
	<.main+7347 @05a3a7> : 1f 98 80 05 00             load.ref <@058098> ;u16Cle
	<.main+7352 @05a3ac> : 25                         store.i8
	test/lang/useOperator.ci:142: (19 bytes: <@05a3ad> - <@05a3c0>): static u16Cgt: bool := bool(u16A > u16B)
	<.main+7353 @05a3ad> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7358 @05a3b2> : 21                         load.i16
	<.main+7359 @05a3b3> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7364 @05a3b8> : 21                         load.i16
	<.main+7365 @05a3b9> : 39                         cgt.u32
	<.main+7366 @05a3ba> : 1f a0 80 05 00             load.ref <@0580a0> ;u16Cgt
	<.main+7371 @05a3bf> : 25                         store.i8
	test/lang/useOperator.ci:143: (20 bytes: <@05a3c0> - <@05a3d4>): static u16Cge: bool := bool(u16A >= u16B)
	<.main+7372 @05a3c0> : 1f 00 80 05 00             load.ref <@058000> ;u16A
	<.main+7377 @05a3c5> : 21                         load.i16
	<.main+7378 @05a3c6> : 1f 08 80 05 00             load.ref <@058008> ;u16B
	<.main+7383 @05a3cb> : 21                         load.i16
	<.main+7384 @05a3cc> : 38                         clt.u32
	<.main+7385 @05a3cd> : 0b                         not.b32
	<.main+7386 @05a3ce> : 1f a8 80 05 00             load.ref <@0580a8> ;u16Cge
	<.main+7391 @05a3d3> : 25                         store.i8
	test/lang/useOperator.ci:145: (9 bytes: <@05a3d4> - <@05a3dd>): static i32A: int32 := a
	<.main+7392 @05a3d4> : 1c 60 00 00 00             load.c32 96
	<.main+7397 @05a3d9> : 2e b0 80 05                store.m32 <@0580b0> ;i32A
	test/lang/useOperator.ci:146: (9 bytes: <@05a3dd> - <@05a3e6>): static i32B: int32 := b
	<.main+7401 @05a3dd> : 1c 2a 00 00 00             load.c32 42
	<.main+7406 @05a3e2> : 2e b8 80 05                store.m32 <@0580b8> ;i32B
	test/lang/useOperator.ci:147: (8 bytes: <@05a3e6> - <@05a3ee>): static i32Pls: int32 := int32(+i32B)
	<.main+7410 @05a3e6> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7414 @05a3ea> : 2e c0 80 05                store.m32 <@0580c0> ;i32Pls
	test/lang/useOperator.ci:148: (9 bytes: <@05a3ee> - <@05a3f7>): static i32Neg: int32 := int32(-i32B)
	<.main+7418 @05a3ee> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7422 @05a3f2> : 50                         neg.i32
	<.main+7423 @05a3f3> : 2e c8 80 05                store.m32 <@0580c8> ;i32Neg
	test/lang/useOperator.ci:149: (9 bytes: <@05a3f7> - <@05a400>): static i32Cmt: int32 := int32(~i32B)
	<.main+7427 @05a3f7> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7431 @05a3fb> : 30                         cmt.b32
	<.main+7432 @05a3fc> : 2e d0 80 05                store.m32 <@0580d0> ;i32Cmt
	test/lang/useOperator.ci:150: (13 bytes: <@05a400> - <@05a40d>): static i32Add: int32 := int32(i32A + i32B)
	<.main+7436 @05a400> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7440 @05a404> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7444 @05a408> : 51                         add.i32
	<.main+7445 @05a409> : 2e d8 80 05                store.m32 <@0580d8> ;i32Add
	test/lang/useOperator.ci:151: (13 bytes: <@05a40d> - <@05a41a>): static i32Sub: int32 := int32(i32A - i32B)
	<.main+7449 @05a40d> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7453 @05a411> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7457 @05a415> : 52                         sub.i32
	<.main+7458 @05a416> : 2e e0 80 05                store.m32 <@0580e0> ;i32Sub
	test/lang/useOperator.ci:152: (13 bytes: <@05a41a> - <@05a427>): static i32Mul: int32 := int32(i32A * i32B)
	<.main+7462 @05a41a> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7466 @05a41e> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7470 @05a422> : 53                         mul.i32
	<.main+7471 @05a423> : 2e e8 80 05                store.m32 <@0580e8> ;i32Mul
	test/lang/useOperator.ci:153: (13 bytes: <@05a427> - <@05a434>): static i32Div: int32 := int32(i32A / i32B)
	<.main+7475 @05a427> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7479 @05a42b> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7483 @05a42f> : 54                         div.i32
	<.main+7484 @05a430> : 2e f0 80 05                store.m32 <@0580f0> ;i32Div
	test/lang/useOperator.ci:154: (13 bytes: <@05a434> - <@05a441>): static i32Mod: int32 := int32(i32A % i32B)
	<.main+7488 @05a434> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7492 @05a438> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7496 @05a43c> : 55                         mod.i32
	<.main+7497 @05a43d> : 2e f8 80 05                store.m32 <@0580f8> ;i32Mod
	test/lang/useOperator.ci:155: (13 bytes: <@05a441> - <@05a44e>): static i32And: int32 := int32(i32A & i32B)
	<.main+7501 @05a441> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7505 @05a445> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7509 @05a449> : 31                         and.b32
	<.main+7510 @05a44a> : 2e 00 81 05                store.m32 <@058100> ;i32And
	test/lang/useOperator.ci:156: (13 bytes: <@05a44e> - <@05a45b>): static i32Ior: int32 := int32(i32A | i32B)
	<.main+7514 @05a44e> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7518 @05a452> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7522 @05a456> : 32                         or.b32
	<.main+7523 @05a457> : 2e 08 81 05                store.m32 <@058108> ;i32Ior
	test/lang/useOperator.ci:157: (13 bytes: <@05a45b> - <@05a468>): static i32Xor: int32 := int32(i32A ^ i32B)
	<.main+7527 @05a45b> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7531 @05a45f> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7535 @05a463> : 36                         xor.b32
	<.main+7536 @05a464> : 2e 10 81 05                store.m32 <@058110> ;i32Xor
	test/lang/useOperator.ci:158: (13 bytes: <@05a468> - <@05a475>): static i32Shl: int32 := int32(i32A << shift)
	<.main+7540 @05a468> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7544 @05a46c> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+7548 @05a470> : 3a                         shl.b32
	<.main+7549 @05a471> : 2e 18 81 05                store.m32 <@058118> ;i32Shl
	test/lang/useOperator.ci:159: (13 bytes: <@05a475> - <@05a482>): static i32Shr: int32 := int32(i32A >> shift)
	<.main+7553 @05a475> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7557 @05a479> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+7561 @05a47d> : 3c                         sar.b32
	<.main+7562 @05a47e> : 2e 20 81 05                store.m32 <@058120> ;i32Shr
	test/lang/useOperator.ci:160: (12 bytes: <@05a482> - <@05a48e>): static i32Not: bool := bool(!(i32B))
	<.main+7566 @05a482> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7570 @05a486> : 5a                         i32.2bool
	<.main+7571 @05a487> : 0b                         not.b32
	<.main+7572 @05a488> : 1f 28 81 05 00             load.ref <@058128> ;i32Not
	<.main+7577 @05a48d> : 25                         store.i8
	test/lang/useOperator.ci:161: (15 bytes: <@05a48e> - <@05a49d>): static i32Ceq: bool := bool(i32A == i32B)
	<.main+7578 @05a48e> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7582 @05a492> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7586 @05a496> : 57                         ceq.i32
	<.main+7587 @05a497> : 1f 30 81 05 00             load.ref <@058130> ;i32Ceq
	<.main+7592 @05a49c> : 25                         store.i8
	test/lang/useOperator.ci:162: (16 bytes: <@05a49d> - <@05a4ad>): static i32Cne: bool := bool(i32A != i32B)
	<.main+7593 @05a49d> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7597 @05a4a1> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7601 @05a4a5> : 57                         ceq.i32
	<.main+7602 @05a4a6> : 0b                         not.b32
	<.main+7603 @05a4a7> : 1f 38 81 05 00             load.ref <@058138> ;i32Cne
	<.main+7608 @05a4ac> : 25                         store.i8
	test/lang/useOperator.ci:163: (15 bytes: <@05a4ad> - <@05a4bc>): static i32Clt: bool := bool(i32A < i32B)
	<.main+7609 @05a4ad> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7613 @05a4b1> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7617 @05a4b5> : 58                         clt.i32
	<.main+7618 @05a4b6> : 1f 40 81 05 00             load.ref <@058140> ;i32Clt
	<.main+7623 @05a4bb> : 25                         store.i8
	test/lang/useOperator.ci:164: (16 bytes: <@05a4bc> - <@05a4cc>): static i32Cle: bool := bool(i32A <= i32B)
	<.main+7624 @05a4bc> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7628 @05a4c0> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7632 @05a4c4> : 59                         cgt.i32
	<.main+7633 @05a4c5> : 0b                         not.b32
	<.main+7634 @05a4c6> : 1f 48 81 05 00             load.ref <@058148> ;i32Cle
	<.main+7639 @05a4cb> : 25                         store.i8
	test/lang/useOperator.ci:165: (15 bytes: <@05a4cc> - <@05a4db>): static i32Cgt: bool := bool(i32A > i32B)
	<.main+7640 @05a4cc> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7644 @05a4d0> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7648 @05a4d4> : 59                         cgt.i32
	<.main+7649 @05a4d5> : 1f 50 81 05 00             load.ref <@058150> ;i32Cgt
	<.main+7654 @05a4da> : 25                         store.i8
	test/lang/useOperator.ci:166: (16 bytes: <@05a4db> - <@05a4eb>): static i32Cge: bool := bool(i32A >= i32B)
	<.main+7655 @05a4db> : 2a b0 80 05                load.m32 <@0580b0> ;i32A
	<.main+7659 @05a4df> : 2a b8 80 05                load.m32 <@0580b8> ;i32B
	<.main+7663 @05a4e3> : 58                         clt.i32
	<.main+7664 @05a4e4> : 0b                         not.b32
	<.main+7665 @05a4e5> : 1f 58 81 05 00             load.ref <@058158> ;i32Cge
	<.main+7670 @05a4ea> : 25                         store.i8
	test/lang/useOperator.ci:168: (9 bytes: <@05a4eb> - <@05a4f4>): static u32A: uint32 := a
	<.main+7671 @05a4eb> : 1c 60 00 00 00             load.c32 96
	<.main+7676 @05a4f0> : 2e 60 81 05                store.m32 <@058160> ;u32A
	test/lang/useOperator.ci:169: (9 bytes: <@05a4f4> - <@05a4fd>): static u32B: uint32 := b
	<.main+7680 @05a4f4> : 1c 2a 00 00 00             load.c32 42
	<.main+7685 @05a4f9> : 2e 68 81 05                store.m32 <@058168> ;u32B
	test/lang/useOperator.ci:170: (8 bytes: <@05a4fd> - <@05a505>): static u32Pls: uint32 := uint32(+u32B)
	<.main+7689 @05a4fd> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7693 @05a501> : 2e 70 81 05                store.m32 <@058170> ;u32Pls
	test/lang/useOperator.ci:171: (9 bytes: <@05a505> - <@05a50e>): static u32Neg: uint32 := uint32(-u32B)
	<.main+7697 @05a505> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7701 @05a509> : 50                         neg.i32
	<.main+7702 @05a50a> : 2e 78 81 05                store.m32 <@058178> ;u32Neg
	test/lang/useOperator.ci:172: (9 bytes: <@05a50e> - <@05a517>): static u32Cmt: uint32 := uint32(~u32B)
	<.main+7706 @05a50e> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7710 @05a512> : 30                         cmt.b32
	<.main+7711 @05a513> : 2e 80 81 05                store.m32 <@058180> ;u32Cmt
	test/lang/useOperator.ci:173: (13 bytes: <@05a517> - <@05a524>): static u32Add: uint32 := uint32(u32A + u32B)
	<.main+7715 @05a517> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7719 @05a51b> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7723 @05a51f> : 51                         add.i32
	<.main+7724 @05a520> : 2e 88 81 05                store.m32 <@058188> ;u32Add
	test/lang/useOperator.ci:174: (13 bytes: <@05a524> - <@05a531>): static u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7728 @05a524> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7732 @05a528> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7736 @05a52c> : 52                         sub.i32
	<.main+7737 @05a52d> : 2e 90 81 05                store.m32 <@058190> ;u32Sub
	test/lang/useOperator.ci:175: (13 bytes: <@05a531> - <@05a53e>): static u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7741 @05a531> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7745 @05a535> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7749 @05a539> : 33                         mul.u32
	<.main+7750 @05a53a> : 2e 98 81 05                store.m32 <@058198> ;u32Mul
	test/lang/useOperator.ci:176: (13 bytes: <@05a53e> - <@05a54b>): static u32Div: uint32 := uint32(u32A / u32B)
	<.main+7754 @05a53e> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7758 @05a542> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7762 @05a546> : 34                         div.u32
	<.main+7763 @05a547> : 2e a0 81 05                store.m32 <@0581a0> ;u32Div
	test/lang/useOperator.ci:177: (13 bytes: <@05a54b> - <@05a558>): static u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7767 @05a54b> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7771 @05a54f> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7775 @05a553> : 35                         mod.u32
	<.main+7776 @05a554> : 2e a8 81 05                store.m32 <@0581a8> ;u32Mod
	test/lang/useOperator.ci:178: (13 bytes: <@05a558> - <@05a565>): static u32And: uint32 := uint32(u32A & u32B)
	<.main+7780 @05a558> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7784 @05a55c> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7788 @05a560> : 31                         and.b32
	<.main+7789 @05a561> : 2e b0 81 05                store.m32 <@0581b0> ;u32And
	test/lang/useOperator.ci:179: (13 bytes: <@05a565> - <@05a572>): static u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7793 @05a565> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7797 @05a569> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7801 @05a56d> : 32                         or.b32
	<.main+7802 @05a56e> : 2e b8 81 05                store.m32 <@0581b8> ;u32Ior
	test/lang/useOperator.ci:180: (13 bytes: <@05a572> - <@05a57f>): static u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7806 @05a572> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7810 @05a576> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7814 @05a57a> : 36                         xor.b32
	<.main+7815 @05a57b> : 2e c0 81 05                store.m32 <@0581c0> ;u32Xor
	test/lang/useOperator.ci:181: (13 bytes: <@05a57f> - <@05a58c>): static u32Shl: uint32 := uint32(u32A << shift)
	<.main+7819 @05a57f> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7823 @05a583> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+7827 @05a587> : 3a                         shl.b32
	<.main+7828 @05a588> : 2e c8 81 05                store.m32 <@0581c8> ;u32Shl
	test/lang/useOperator.ci:182: (13 bytes: <@05a58c> - <@05a599>): static u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7832 @05a58c> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7836 @05a590> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+7840 @05a594> : 3b                         shr.b32
	<.main+7841 @05a595> : 2e d0 81 05                store.m32 <@0581d0> ;u32Shr
	test/lang/useOperator.ci:183: (12 bytes: <@05a599> - <@05a5a5>): static u32Not: bool := bool(!(u32B))
	<.main+7845 @05a599> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7849 @05a59d> : 5a                         i32.2bool
	<.main+7850 @05a59e> : 0b                         not.b32
	<.main+7851 @05a59f> : 1f d8 81 05 00             load.ref <@0581d8> ;u32Not
	<.main+7856 @05a5a4> : 25                         store.i8
	test/lang/useOperator.ci:184: (15 bytes: <@05a5a5> - <@05a5b4>): static u32Ceq: bool := bool(u32A == u32B)
	<.main+7857 @05a5a5> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7861 @05a5a9> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7865 @05a5ad> : 57                         ceq.i32
	<.main+7866 @05a5ae> : 1f e0 81 05 00             load.ref <@0581e0> ;u32Ceq
	<.main+7871 @05a5b3> : 25                         store.i8
	test/lang/useOperator.ci:185: (16 bytes: <@05a5b4> - <@05a5c4>): static u32Cne: bool := bool(u32A != u32B)
	<.main+7872 @05a5b4> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7876 @05a5b8> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7880 @05a5bc> : 57                         ceq.i32
	<.main+7881 @05a5bd> : 0b                         not.b32
	<.main+7882 @05a5be> : 1f e8 81 05 00             load.ref <@0581e8> ;u32Cne
	<.main+7887 @05a5c3> : 25                         store.i8
	test/lang/useOperator.ci:186: (15 bytes: <@05a5c4> - <@05a5d3>): static u32Clt: bool := bool(u32A < u32B)
	<.main+7888 @05a5c4> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7892 @05a5c8> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7896 @05a5cc> : 38                         clt.u32
	<.main+7897 @05a5cd> : 1f f0 81 05 00             load.ref <@0581f0> ;u32Clt
	<.main+7902 @05a5d2> : 25                         store.i8
	test/lang/useOperator.ci:187: (16 bytes: <@05a5d3> - <@05a5e3>): static u32Cle: bool := bool(u32A <= u32B)
	<.main+7903 @05a5d3> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7907 @05a5d7> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7911 @05a5db> : 39                         cgt.u32
	<.main+7912 @05a5dc> : 0b                         not.b32
	<.main+7913 @05a5dd> : 1f f8 81 05 00             load.ref <@0581f8> ;u32Cle
	<.main+7918 @05a5e2> : 25                         store.i8
	test/lang/useOperator.ci:188: (15 bytes: <@05a5e3> - <@05a5f2>): static u32Cgt: bool := bool(u32A > u32B)
	<.main+7919 @05a5e3> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7923 @05a5e7> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7927 @05a5eb> : 39                         cgt.u32
	<.main+7928 @05a5ec> : 1f 00 82 05 00             load.ref <@058200> ;u32Cgt
	<.main+7933 @05a5f1> : 25                         store.i8
	test/lang/useOperator.ci:189: (16 bytes: <@05a5f2> - <@05a602>): static u32Cge: bool := bool(u32A >= u32B)
	<.main+7934 @05a5f2> : 2a 60 81 05                load.m32 <@058160> ;u32A
	<.main+7938 @05a5f6> : 2a 68 81 05                load.m32 <@058168> ;u32B
	<.main+7942 @05a5fa> : 38                         clt.u32
	<.main+7943 @05a5fb> : 0b                         not.b32
	<.main+7944 @05a5fc> : 1f 08 82 05 00             load.ref <@058208> ;u32Cge
	<.main+7949 @05a601> : 25                         store.i8
	test/lang/useOperator.ci:191: (13 bytes: <@05a602> - <@05a60f>): static i64A: int64 := a
	<.main+7950 @05a602> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+7959 @05a60b> : 2d 10 82 05                store.m64 <@058210> ;i64A
	test/lang/useOperator.ci:192: (13 bytes: <@05a60f> - <@05a61c>): static i64B: int64 := b
	<.main+7963 @05a60f> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+7972 @05a618> : 2d 18 82 05                store.m64 <@058218> ;i64B
	test/lang/useOperator.ci:193: (8 bytes: <@05a61c> - <@05a624>): static i64Pls: int64 := int64(+i64B)
	<.main+7976 @05a61c> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+7980 @05a620> : 2d 20 82 05                store.m64 <@058220> ;i64Pls
	test/lang/useOperator.ci:194: (9 bytes: <@05a624> - <@05a62d>): static i64Neg: int64 := int64(-i64B)
	<.main+7984 @05a624> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+7988 @05a628> : 60                         neg.i64
	<.main+7989 @05a629> : 2d 28 82 05                store.m64 <@058228> ;i64Neg
	test/lang/useOperator.ci:195: (9 bytes: <@05a62d> - <@05a636>): static i64Cmt: int64 := int64(~i64B)
	<.main+7993 @05a62d> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+7997 @05a631> : 40                         cmt.b64
	<.main+7998 @05a632> : 2d 30 82 05                store.m64 <@058230> ;i64Cmt
	test/lang/useOperator.ci:196: (13 bytes: <@05a636> - <@05a643>): static i64Add: int64 := int64(i64A + i64B)
	<.main+8002 @05a636> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8006 @05a63a> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8010 @05a63e> : 61                         add.i64
	<.main+8011 @05a63f> : 2d 38 82 05                store.m64 <@058238> ;i64Add
	test/lang/useOperator.ci:197: (13 bytes: <@05a643> - <@05a650>): static i64Sub: int64 := int64(i64A - i64B)
	<.main+8015 @05a643> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8019 @05a647> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8023 @05a64b> : 62                         sub.i64
	<.main+8024 @05a64c> : 2d 40 82 05                store.m64 <@058240> ;i64Sub
	test/lang/useOperator.ci:198: (13 bytes: <@05a650> - <@05a65d>): static i64Mul: int64 := int64(i64A * i64B)
	<.main+8028 @05a650> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8032 @05a654> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8036 @05a658> : 63                         mul.i64
	<.main+8037 @05a659> : 2d 48 82 05                store.m64 <@058248> ;i64Mul
	test/lang/useOperator.ci:199: (13 bytes: <@05a65d> - <@05a66a>): static i64Div: int64 := int64(i64A / i64B)
	<.main+8041 @05a65d> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8045 @05a661> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8049 @05a665> : 64                         div.i64
	<.main+8050 @05a666> : 2d 50 82 05                store.m64 <@058250> ;i64Div
	test/lang/useOperator.ci:200: (13 bytes: <@05a66a> - <@05a677>): static i64Mod: int64 := int64(i64A % i64B)
	<.main+8054 @05a66a> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8058 @05a66e> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8062 @05a672> : 65                         mod.i64
	<.main+8063 @05a673> : 2d 58 82 05                store.m64 <@058258> ;i64Mod
	test/lang/useOperator.ci:201: (13 bytes: <@05a677> - <@05a684>): static i64And: int64 := int64(i64A & i64B)
	<.main+8067 @05a677> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8071 @05a67b> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8075 @05a67f> : 41                         and.b64
	<.main+8076 @05a680> : 2d 60 82 05                store.m64 <@058260> ;i64And
	test/lang/useOperator.ci:202: (13 bytes: <@05a684> - <@05a691>): static i64Ior: int64 := int64(i64A | i64B)
	<.main+8080 @05a684> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8084 @05a688> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8088 @05a68c> : 42                         or.b64
	<.main+8089 @05a68d> : 2d 68 82 05                store.m64 <@058268> ;i64Ior
	test/lang/useOperator.ci:203: (13 bytes: <@05a691> - <@05a69e>): static i64Xor: int64 := int64(i64A ^ i64B)
	<.main+8093 @05a691> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8097 @05a695> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8101 @05a699> : 46                         xor.b64
	<.main+8102 @05a69a> : 2d 70 82 05                store.m64 <@058270> ;i64Xor
	test/lang/useOperator.ci:204: (13 bytes: <@05a69e> - <@05a6ab>): static i64Shl: int64 := int64(i64A << shift)
	<.main+8106 @05a69e> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8110 @05a6a2> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+8114 @05a6a6> : 4a                         shl.b64
	<.main+8115 @05a6a7> : 2d 78 82 05                store.m64 <@058278> ;i64Shl
	test/lang/useOperator.ci:205: (13 bytes: <@05a6ab> - <@05a6b8>): static i64Shr: int64 := int64(i64A >> shift)
	<.main+8119 @05a6ab> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8123 @05a6af> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+8127 @05a6b3> : 4c                         sar.b64
	<.main+8128 @05a6b4> : 2d 80 82 05                store.m64 <@058280> ;i64Shr
	test/lang/useOperator.ci:206: (12 bytes: <@05a6b8> - <@05a6c4>): static i64Not: bool := bool(!(i64B))
	<.main+8132 @05a6b8> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8136 @05a6bc> : 6b                         i64.2bool
	<.main+8137 @05a6bd> : 0b                         not.b32
	<.main+8138 @05a6be> : 1f 88 82 05 00             load.ref <@058288> ;i64Not
	<.main+8143 @05a6c3> : 25                         store.i8
	test/lang/useOperator.ci:207: (15 bytes: <@05a6c4> - <@05a6d3>): static i64Ceq: bool := bool(i64A == i64B)
	<.main+8144 @05a6c4> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8148 @05a6c8> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8152 @05a6cc> : 67                         ceq.i64
	<.main+8153 @05a6cd> : 1f 90 82 05 00             load.ref <@058290> ;i64Ceq
	<.main+8158 @05a6d2> : 25                         store.i8
	test/lang/useOperator.ci:208: (16 bytes: <@05a6d3> - <@05a6e3>): static i64Cne: bool := bool(i64A != i64B)
	<.main+8159 @05a6d3> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8163 @05a6d7> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8167 @05a6db> : 67                         ceq.i64
	<.main+8168 @05a6dc> : 0b                         not.b32
	<.main+8169 @05a6dd> : 1f 98 82 05 00             load.ref <@058298> ;i64Cne
	<.main+8174 @05a6e2> : 25                         store.i8
	test/lang/useOperator.ci:209: (15 bytes: <@05a6e3> - <@05a6f2>): static i64Clt: bool := bool(i64A < i64B)
	<.main+8175 @05a6e3> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8179 @05a6e7> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8183 @05a6eb> : 68                         clt.i64
	<.main+8184 @05a6ec> : 1f a0 82 05 00             load.ref <@0582a0> ;i64Clt
	<.main+8189 @05a6f1> : 25                         store.i8
	test/lang/useOperator.ci:210: (16 bytes: <@05a6f2> - <@05a702>): static i64Cle: bool := bool(i64A <= i64B)
	<.main+8190 @05a6f2> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8194 @05a6f6> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8198 @05a6fa> : 69                         cgt.i64
	<.main+8199 @05a6fb> : 0b                         not.b32
	<.main+8200 @05a6fc> : 1f a8 82 05 00             load.ref <@0582a8> ;i64Cle
	<.main+8205 @05a701> : 25                         store.i8
	test/lang/useOperator.ci:211: (15 bytes: <@05a702> - <@05a711>): static i64Cgt: bool := bool(i64A > i64B)
	<.main+8206 @05a702> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8210 @05a706> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8214 @05a70a> : 69                         cgt.i64
	<.main+8215 @05a70b> : 1f b0 82 05 00             load.ref <@0582b0> ;i64Cgt
	<.main+8220 @05a710> : 25                         store.i8
	test/lang/useOperator.ci:212: (16 bytes: <@05a711> - <@05a721>): static i64Cge: bool := bool(i64A >= i64B)
	<.main+8221 @05a711> : 2b 10 82 05                load.m64 <@058210> ;i64A
	<.main+8225 @05a715> : 2b 18 82 05                load.m64 <@058218> ;i64B
	<.main+8229 @05a719> : 68                         clt.i64
	<.main+8230 @05a71a> : 0b                         not.b32
	<.main+8231 @05a71b> : 1f b8 82 05 00             load.ref <@0582b8> ;i64Cge
	<.main+8236 @05a720> : 25                         store.i8
	test/lang/useOperator.ci:214: (13 bytes: <@05a721> - <@05a72e>): static u64A: uint64 := a
	<.main+8237 @05a721> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8246 @05a72a> : 2d c0 82 05                store.m64 <@0582c0> ;u64A
	test/lang/useOperator.ci:215: (13 bytes: <@05a72e> - <@05a73b>): static u64B: uint64 := b
	<.main+8250 @05a72e> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8259 @05a737> : 2d c8 82 05                store.m64 <@0582c8> ;u64B
	test/lang/useOperator.ci:216: (8 bytes: <@05a73b> - <@05a743>): static u64Pls: uint64 := uint64(+u64B)
	<.main+8263 @05a73b> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8267 @05a73f> : 2d d0 82 05                store.m64 <@0582d0> ;u64Pls
	test/lang/useOperator.ci:217: (9 bytes: <@05a743> - <@05a74c>): static u64Neg: uint64 := uint64(-u64B)
	<.main+8271 @05a743> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8275 @05a747> : 60                         neg.i64
	<.main+8276 @05a748> : 2d d8 82 05                store.m64 <@0582d8> ;u64Neg
	test/lang/useOperator.ci:218: (9 bytes: <@05a74c> - <@05a755>): static u64Cmt: uint64 := uint64(~u64B)
	<.main+8280 @05a74c> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8284 @05a750> : 40                         cmt.b64
	<.main+8285 @05a751> : 2d e0 82 05                store.m64 <@0582e0> ;u64Cmt
	test/lang/useOperator.ci:219: (13 bytes: <@05a755> - <@05a762>): static u64Add: uint64 := uint64(u64A + u64B)
	<.main+8289 @05a755> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8293 @05a759> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8297 @05a75d> : 61                         add.i64
	<.main+8298 @05a75e> : 2d e8 82 05                store.m64 <@0582e8> ;u64Add
	test/lang/useOperator.ci:220: (13 bytes: <@05a762> - <@05a76f>): static u64Sub: uint64 := uint64(u64A - u64B)
	<.main+8302 @05a762> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8306 @05a766> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8310 @05a76a> : 62                         sub.i64
	<.main+8311 @05a76b> : 2d f0 82 05                store.m64 <@0582f0> ;u64Sub
	test/lang/useOperator.ci:221: (13 bytes: <@05a76f> - <@05a77c>): static u64Mul: uint64 := uint64(u64A * u64B)
	<.main+8315 @05a76f> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8319 @05a773> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8323 @05a777> : 43                         mul.u64
	<.main+8324 @05a778> : 2d f8 82 05                store.m64 <@0582f8> ;u64Mul
	test/lang/useOperator.ci:222: (13 bytes: <@05a77c> - <@05a789>): static u64Div: uint64 := uint64(u64A / u64B)
	<.main+8328 @05a77c> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8332 @05a780> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8336 @05a784> : 44                         div.u64
	<.main+8337 @05a785> : 2d 00 83 05                store.m64 <@058300> ;u64Div
	test/lang/useOperator.ci:223: (13 bytes: <@05a789> - <@05a796>): static u64Mod: uint64 := uint64(u64A % u64B)
	<.main+8341 @05a789> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8345 @05a78d> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8349 @05a791> : 45                         mod.u64
	<.main+8350 @05a792> : 2d 08 83 05                store.m64 <@058308> ;u64Mod
	test/lang/useOperator.ci:224: (13 bytes: <@05a796> - <@05a7a3>): static u64And: uint64 := uint64(u64A & u64B)
	<.main+8354 @05a796> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8358 @05a79a> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8362 @05a79e> : 41                         and.b64
	<.main+8363 @05a79f> : 2d 10 83 05                store.m64 <@058310> ;u64And
	test/lang/useOperator.ci:225: (13 bytes: <@05a7a3> - <@05a7b0>): static u64Ior: uint64 := uint64(u64A | u64B)
	<.main+8367 @05a7a3> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8371 @05a7a7> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8375 @05a7ab> : 42                         or.b64
	<.main+8376 @05a7ac> : 2d 18 83 05                store.m64 <@058318> ;u64Ior
	test/lang/useOperator.ci:226: (13 bytes: <@05a7b0> - <@05a7bd>): static u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+8380 @05a7b0> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8384 @05a7b4> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8388 @05a7b8> : 46                         xor.b64
	<.main+8389 @05a7b9> : 2d 20 83 05                store.m64 <@058320> ;u64Xor
	test/lang/useOperator.ci:227: (13 bytes: <@05a7bd> - <@05a7ca>): static u64Shl: uint64 := uint64(u64A << shift)
	<.main+8393 @05a7bd> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8397 @05a7c1> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+8401 @05a7c5> : 4a                         shl.b64
	<.main+8402 @05a7c6> : 2d 28 83 05                store.m64 <@058328> ;u64Shl
	test/lang/useOperator.ci:228: (13 bytes: <@05a7ca> - <@05a7d7>): static u64Shr: uint64 := uint64(u64A >> shift)
	<.main+8406 @05a7ca> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8410 @05a7ce> : 2a d8 7c 05                load.m32 <@057cd8> ;shift
	<.main+8414 @05a7d2> : 4b                         shr.b64
	<.main+8415 @05a7d3> : 2d 30 83 05                store.m64 <@058330> ;u64Shr
	test/lang/useOperator.ci:229: (12 bytes: <@05a7d7> - <@05a7e3>): static u64Not: bool := bool(!(u64B))
	<.main+8419 @05a7d7> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8423 @05a7db> : 6b                         i64.2bool
	<.main+8424 @05a7dc> : 0b                         not.b32
	<.main+8425 @05a7dd> : 1f 38 83 05 00             load.ref <@058338> ;u64Not
	<.main+8430 @05a7e2> : 25                         store.i8
	test/lang/useOperator.ci:230: (15 bytes: <@05a7e3> - <@05a7f2>): static u64Ceq: bool := bool(u64A == u64B)
	<.main+8431 @05a7e3> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8435 @05a7e7> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8439 @05a7eb> : 67                         ceq.i64
	<.main+8440 @05a7ec> : 1f 40 83 05 00             load.ref <@058340> ;u64Ceq
	<.main+8445 @05a7f1> : 25                         store.i8
	test/lang/useOperator.ci:231: (16 bytes: <@05a7f2> - <@05a802>): static u64Cne: bool := bool(u64A != u64B)
	<.main+8446 @05a7f2> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8450 @05a7f6> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8454 @05a7fa> : 67                         ceq.i64
	<.main+8455 @05a7fb> : 0b                         not.b32
	<.main+8456 @05a7fc> : 1f 48 83 05 00             load.ref <@058348> ;u64Cne
	<.main+8461 @05a801> : 25                         store.i8
	test/lang/useOperator.ci:232: (15 bytes: <@05a802> - <@05a811>): static u64Clt: bool := bool(u64A < u64B)
	<.main+8462 @05a802> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8466 @05a806> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8470 @05a80a> : 48                         clt.u64
	<.main+8471 @05a80b> : 1f 50 83 05 00             load.ref <@058350> ;u64Clt
	<.main+8476 @05a810> : 25                         store.i8
	test/lang/useOperator.ci:233: (16 bytes: <@05a811> - <@05a821>): static u64Cle: bool := bool(u64A <= u64B)
	<.main+8477 @05a811> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8481 @05a815> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8485 @05a819> : 49                         cgt.u64
	<.main+8486 @05a81a> : 0b                         not.b32
	<.main+8487 @05a81b> : 1f 58 83 05 00             load.ref <@058358> ;u64Cle
	<.main+8492 @05a820> : 25                         store.i8
	test/lang/useOperator.ci:234: (15 bytes: <@05a821> - <@05a830>): static u64Cgt: bool := bool(u64A > u64B)
	<.main+8493 @05a821> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8497 @05a825> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8501 @05a829> : 49                         cgt.u64
	<.main+8502 @05a82a> : 1f 60 83 05 00             load.ref <@058360> ;u64Cgt
	<.main+8507 @05a82f> : 25                         store.i8
	test/lang/useOperator.ci:235: (16 bytes: <@05a830> - <@05a840>): static u64Cge: bool := bool(u64A >= u64B)
	<.main+8508 @05a830> : 2b c0 82 05                load.m64 <@0582c0> ;u64A
	<.main+8512 @05a834> : 2b c8 82 05                load.m64 <@0582c8> ;u64B
	<.main+8516 @05a838> : 48                         clt.u64
	<.main+8517 @05a839> : 0b                         not.b32
	<.main+8518 @05a83a> : 1f 68 83 05 00             load.ref <@058368> ;u64Cge
	<.main+8523 @05a83f> : 25                         store.i8
	test/lang/useOperator.ci:237: (9 bytes: <@05a840> - <@05a849>): static f32A: float32 := a
	<.main+8524 @05a840> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8529 @05a845> : 2e 70 83 05                store.m32 <@058370> ;f32A
	test/lang/useOperator.ci:238: (9 bytes: <@05a849> - <@05a852>): static f32B: float32 := b
	<.main+8533 @05a849> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8538 @05a84e> : 2e 78 83 05                store.m32 <@058378> ;f32B
	test/lang/useOperator.ci:239: (8 bytes: <@05a852> - <@05a85a>): static f32Pls: float32 := float32(+f32B)
	<.main+8542 @05a852> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8546 @05a856> : 2e 80 83 05                store.m32 <@058380> ;f32Pls
	test/lang/useOperator.ci:240: (9 bytes: <@05a85a> - <@05a863>): static f32Neg: float32 := float32(-f32B)
	<.main+8550 @05a85a> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8554 @05a85e> : 70                         neg.f32
	<.main+8555 @05a85f> : 2e 88 83 05                store.m32 <@058388> ;f32Neg
	test/lang/useOperator.ci:242: (13 bytes: <@05a863> - <@05a870>): static f32Add: float32 := float32(f32A + f32B)
	<.main+8559 @05a863> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8563 @05a867> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8567 @05a86b> : 71                         add.f32
	<.main+8568 @05a86c> : 2e 90 83 05                store.m32 <@058390> ;f32Add
	test/lang/useOperator.ci:243: (13 bytes: <@05a870> - <@05a87d>): static f32Sub: float32 := float32(f32A - f32B)
	<.main+8572 @05a870> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8576 @05a874> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8580 @05a878> : 72                         sub.f32
	<.main+8581 @05a879> : 2e 98 83 05                store.m32 <@058398> ;f32Sub
	test/lang/useOperator.ci:244: (13 bytes: <@05a87d> - <@05a88a>): static f32Mul: float32 := float32(f32A * f32B)
	<.main+8585 @05a87d> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8589 @05a881> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8593 @05a885> : 73                         mul.f32
	<.main+8594 @05a886> : 2e a0 83 05                store.m32 <@0583a0> ;f32Mul
	test/lang/useOperator.ci:245: (13 bytes: <@05a88a> - <@05a897>): static f32Div: float32 := float32(f32A / f32B)
	<.main+8598 @05a88a> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8602 @05a88e> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8606 @05a892> : 74                         div.f32
	<.main+8607 @05a893> : 2e a8 83 05                store.m32 <@0583a8> ;f32Div
	test/lang/useOperator.ci:246: (13 bytes: <@05a897> - <@05a8a4>): static f32Mod: float32 := float32(f32A % f32B)
	<.main+8611 @05a897> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8615 @05a89b> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8619 @05a89f> : 75                         mod.f32
	<.main+8620 @05a8a0> : 2e b0 83 05                store.m32 <@0583b0> ;f32Mod
	test/lang/useOperator.ci:252: (12 bytes: <@05a8a4> - <@05a8b0>): static f32Not: bool := bool(!(f32B))
	<.main+8624 @05a8a4> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8628 @05a8a8> : 7c                         f32.2bool
	<.main+8629 @05a8a9> : 0b                         not.b32
	<.main+8630 @05a8aa> : 1f b8 83 05 00             load.ref <@0583b8> ;f32Not
	<.main+8635 @05a8af> : 25                         store.i8
	test/lang/useOperator.ci:253: (15 bytes: <@05a8b0> - <@05a8bf>): static f32Ceq: bool := bool(f32A == f32B)
	<.main+8636 @05a8b0> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8640 @05a8b4> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8644 @05a8b8> : 77                         ceq.f32
	<.main+8645 @05a8b9> : 1f c0 83 05 00             load.ref <@0583c0> ;f32Ceq
	<.main+8650 @05a8be> : 25                         store.i8
	test/lang/useOperator.ci:254: (16 bytes: <@05a8bf> - <@05a8cf>): static f32Cne: bool := bool(f32A != f32B)
	<.main+8651 @05a8bf> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8655 @05a8c3> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8659 @05a8c7> : 77                         ceq.f32
	<.main+8660 @05a8c8> : 0b                         not.b32
	<.main+8661 @05a8c9> : 1f c8 83 05 00             load.ref <@0583c8> ;f32Cne
	<.main+8666 @05a8ce> : 25                         store.i8
	test/lang/useOperator.ci:255: (15 bytes: <@05a8cf> - <@05a8de>): static f32Clt: bool := bool(f32A < f32B)
	<.main+8667 @05a8cf> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8671 @05a8d3> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8675 @05a8d7> : 78                         clt.f32
	<.main+8676 @05a8d8> : 1f d0 83 05 00             load.ref <@0583d0> ;f32Clt
	<.main+8681 @05a8dd> : 25                         store.i8
	test/lang/useOperator.ci:256: (16 bytes: <@05a8de> - <@05a8ee>): static f32Cle: bool := bool(f32A <= f32B)
	<.main+8682 @05a8de> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8686 @05a8e2> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8690 @05a8e6> : 79                         cgt.f32
	<.main+8691 @05a8e7> : 0b                         not.b32
	<.main+8692 @05a8e8> : 1f d8 83 05 00             load.ref <@0583d8> ;f32Cle
	<.main+8697 @05a8ed> : 25                         store.i8
	test/lang/useOperator.ci:257: (15 bytes: <@05a8ee> - <@05a8fd>): static f32Cgt: bool := bool(f32A > f32B)
	<.main+8698 @05a8ee> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8702 @05a8f2> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8706 @05a8f6> : 79                         cgt.f32
	<.main+8707 @05a8f7> : 1f e0 83 05 00             load.ref <@0583e0> ;f32Cgt
	<.main+8712 @05a8fc> : 25                         store.i8
	test/lang/useOperator.ci:258: (16 bytes: <@05a8fd> - <@05a90d>): static f32Cge: bool := bool(f32A >= f32B)
	<.main+8713 @05a8fd> : 2a 70 83 05                load.m32 <@058370> ;f32A
	<.main+8717 @05a901> : 2a 78 83 05                load.m32 <@058378> ;f32B
	<.main+8721 @05a905> : 78                         clt.f32
	<.main+8722 @05a906> : 0b                         not.b32
	<.main+8723 @05a907> : 1f e8 83 05 00             load.ref <@0583e8> ;f32Cge
	<.main+8728 @05a90c> : 25                         store.i8
	test/lang/useOperator.ci:260: (13 bytes: <@05a90d> - <@05a91a>): static f64A: float64 := a
	<.main+8729 @05a90d> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8738 @05a916> : 2d f0 83 05                store.m64 <@0583f0> ;f64A
	test/lang/useOperator.ci:261: (13 bytes: <@05a91a> - <@05a927>): static f64B: float64 := b
	<.main+8742 @05a91a> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8751 @05a923> : 2d f8 83 05                store.m64 <@0583f8> ;f64B
	test/lang/useOperator.ci:262: (8 bytes: <@05a927> - <@05a92f>): static f64Pls: float64 := float64(+f64B)
	<.main+8755 @05a927> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8759 @05a92b> : 2d 00 84 05                store.m64 <@058400> ;f64Pls
	test/lang/useOperator.ci:263: (9 bytes: <@05a92f> - <@05a938>): static f64Neg: float64 := float64(-f64B)
	<.main+8763 @05a92f> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8767 @05a933> : 80                         neg.f64
	<.main+8768 @05a934> : 2d 08 84 05                store.m64 <@058408> ;f64Neg
	test/lang/useOperator.ci:265: (13 bytes: <@05a938> - <@05a945>): static f64Add: float64 := float64(f64A + f64B)
	<.main+8772 @05a938> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8776 @05a93c> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8780 @05a940> : 81                         add.f64
	<.main+8781 @05a941> : 2d 10 84 05                store.m64 <@058410> ;f64Add
	test/lang/useOperator.ci:266: (13 bytes: <@05a945> - <@05a952>): static f64Sub: float64 := float64(f64A - f64B)
	<.main+8785 @05a945> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8789 @05a949> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8793 @05a94d> : 82                         sub.f64
	<.main+8794 @05a94e> : 2d 18 84 05                store.m64 <@058418> ;f64Sub
	test/lang/useOperator.ci:267: (13 bytes: <@05a952> - <@05a95f>): static f64Mul: float64 := float64(f64A * f64B)
	<.main+8798 @05a952> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8802 @05a956> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8806 @05a95a> : 83                         mul.f64
	<.main+8807 @05a95b> : 2d 20 84 05                store.m64 <@058420> ;f64Mul
	test/lang/useOperator.ci:268: (13 bytes: <@05a95f> - <@05a96c>): static f64Div: float64 := float64(f64A / f64B)
	<.main+8811 @05a95f> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8815 @05a963> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8819 @05a967> : 84                         div.f64
	<.main+8820 @05a968> : 2d 28 84 05                store.m64 <@058428> ;f64Div
	test/lang/useOperator.ci:269: (13 bytes: <@05a96c> - <@05a979>): static f64Mod: float64 := float64(f64A % f64B)
	<.main+8824 @05a96c> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8828 @05a970> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8832 @05a974> : 85                         mod.f64
	<.main+8833 @05a975> : 2d 30 84 05                store.m64 <@058430> ;f64Mod
	test/lang/useOperator.ci:275: (12 bytes: <@05a979> - <@05a985>): static f64Not: bool := bool(!(f64B))
	<.main+8837 @05a979> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8841 @05a97d> : 8d                         f64.2bool
	<.main+8842 @05a97e> : 0b                         not.b32
	<.main+8843 @05a97f> : 1f 38 84 05 00             load.ref <@058438> ;f64Not
	<.main+8848 @05a984> : 25                         store.i8
	test/lang/useOperator.ci:276: (15 bytes: <@05a985> - <@05a994>): static f64Ceq: bool := bool(f64A == f64B)
	<.main+8849 @05a985> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8853 @05a989> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8857 @05a98d> : 87                         ceq.f64
	<.main+8858 @05a98e> : 1f 40 84 05 00             load.ref <@058440> ;f64Ceq
	<.main+8863 @05a993> : 25                         store.i8
	test/lang/useOperator.ci:277: (16 bytes: <@05a994> - <@05a9a4>): static f64Cne: bool := bool(f64A != f64B)
	<.main+8864 @05a994> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8868 @05a998> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8872 @05a99c> : 87                         ceq.f64
	<.main+8873 @05a99d> : 0b                         not.b32
	<.main+8874 @05a99e> : 1f 48 84 05 00             load.ref <@058448> ;f64Cne
	<.main+8879 @05a9a3> : 25                         store.i8
	test/lang/useOperator.ci:278: (15 bytes: <@05a9a4> - <@05a9b3>): static f64Clt: bool := bool(f64A < f64B)
	<.main+8880 @05a9a4> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8884 @05a9a8> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8888 @05a9ac> : 88                         clt.f64
	<.main+8889 @05a9ad> : 1f 50 84 05 00             load.ref <@058450> ;f64Clt
	<.main+8894 @05a9b2> : 25                         store.i8
	test/lang/useOperator.ci:279: (16 bytes: <@05a9b3> - <@05a9c3>): static f64Cle: bool := bool(f64A <= f64B)
	<.main+8895 @05a9b3> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8899 @05a9b7> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8903 @05a9bb> : 89                         cgt.f64
	<.main+8904 @05a9bc> : 0b                         not.b32
	<.main+8905 @05a9bd> : 1f 58 84 05 00             load.ref <@058458> ;f64Cle
	<.main+8910 @05a9c2> : 25                         store.i8
	test/lang/useOperator.ci:280: (15 bytes: <@05a9c3> - <@05a9d2>): static f64Cgt: bool := bool(f64A > f64B)
	<.main+8911 @05a9c3> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8915 @05a9c7> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8919 @05a9cb> : 89                         cgt.f64
	<.main+8920 @05a9cc> : 1f 60 84 05 00             load.ref <@058460> ;f64Cgt
	<.main+8925 @05a9d1> : 25                         store.i8
	test/lang/useOperator.ci:281: (16 bytes: <@05a9d2> - <@05a9e2>): static f64Cge: bool := bool(f64A >= f64B)
	<.main+8926 @05a9d2> : 2b f0 83 05                load.m64 <@0583f0> ;f64A
	<.main+8930 @05a9d6> : 2b f8 83 05                load.m64 <@0583f8> ;f64B
	<.main+8934 @05a9da> : 88                         clt.f64
	<.main+8935 @05a9db> : 0b                         not.b32
	<.main+8936 @05a9dc> : 1f 68 84 05 00             load.ref <@058468> ;f64Cge
	<.main+8941 @05a9e1> : 25                         store.i8
	test/lang/useOperator.ci:283: (9 bytes: <@05a9e2> - <@05a9eb>): static ptrA: pointer := null
	<.main+8942 @05a9e2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8947 @05a9e7> : 2e 70 84 05                store.m32 <@058470> ;ptrA
	test/lang/useOperator.ci:284: (9 bytes: <@05a9eb> - <@05a9f4>): static ptrB: pointer := pointer(shift)
	<.main+8951 @05a9eb> : 1f d8 7c 05 00             load.ref <@057cd8> ;shift
	<.main+8956 @05a9f0> : 2e 78 84 05                store.m32 <@058478> ;ptrB
	test/lang/useOperator.ci:299: (15 bytes: <@05a9f4> - <@05aa03>): static ptrCeq: bool := bool(ptrA == ptrB)
	<.main+8960 @05a9f4> : 2a 70 84 05                load.m32 <@058470> ;ptrA
	<.main+8964 @05a9f8> : 2a 78 84 05                load.m32 <@058478> ;ptrB
	<.main+8968 @05a9fc> : 57                         ceq.i32
	<.main+8969 @05a9fd> : 1f 80 84 05 00             load.ref <@058480> ;ptrCeq
	<.main+8974 @05aa02> : 25                         store.i8
	test/lang/useOperator.ci:300: (16 bytes: <@05aa03> - <@05aa13>): static ptrCne: bool := bool(ptrA != ptrB)
	<.main+8975 @05aa03> : 2a 70 84 05                load.m32 <@058470> ;ptrA
	<.main+8979 @05aa07> : 2a 78 84 05                load.m32 <@058478> ;ptrB
	<.main+8983 @05aa0b> : 57                         ceq.i32
	<.main+8984 @05aa0c> : 0b                         not.b32
	<.main+8985 @05aa0d> : 1f 88 84 05 00             load.ref <@058488> ;ptrCne
	<.main+8990 @05aa12> : 25                         store.i8
	test/lang/statementIf.ci:26: (5 bytes: <@05aa13> - <@05aa18>): static t: int32 := 0
	<.main+8991 @05aa13> : 19                         load.z32
	<.main+8992 @05aa14> : 2e 90 84 05                store.m32 <@058490> ;t
	test/lang/statementFor.ci:12: (5 bytes: <@05aa18> - <@05aa1d>): static forIdx: int32
	<.main+8996 @05aa18> : 19                         load.z32
	<.main+8997 @05aa19> : 2e 98 84 05                store.m32 <@058498> ;forIdx
	test/std/test.math.ci:3: (24 bytes: <@05aa1d> - <@05aa35>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9001 @05aa1d> : 1a                         load.z64
	<.main+9002 @05aa1e> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9011 @05aa27> : 1f 38 5d 05 00             load.ref <@055d38> ;Math.floor(x: float64): float64
	<.main+9016 @05aa2c> : 02                         call
	<.main+9017 @05aa2d> : 09 f8 ff ff                inc.sp(-8)
	<.main+9021 @05aa31> : 2d a0 84 05                store.m64 <@0584a0> ;testMathFloor_1
	test/std/test.math.ci:4: (24 bytes: <@05aa35> - <@05aa4d>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9025 @05aa35> : 1a                         load.z64
	<.main+9026 @05aa36> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9035 @05aa3f> : 1f 38 5d 05 00             load.ref <@055d38> ;Math.floor(x: float64): float64
	<.main+9040 @05aa44> : 02                         call
	<.main+9041 @05aa45> : 09 f8 ff ff                inc.sp(-8)
	<.main+9045 @05aa49> : 2d a8 84 05                store.m64 <@0584a8> ;testMathFloor_2
	test/std/test.math.ci:5: (24 bytes: <@05aa4d> - <@05aa65>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9049 @05aa4d> : 1a                         load.z64
	<.main+9050 @05aa4e> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9059 @05aa57> : 1f 38 5d 05 00             load.ref <@055d38> ;Math.floor(x: float64): float64
	<.main+9064 @05aa5c> : 02                         call
	<.main+9065 @05aa5d> : 09 f8 ff ff                inc.sp(-8)
	<.main+9069 @05aa61> : 2d b0 84 05                store.m64 <@0584b0> ;testMathFloor_3
	test/std/test.math.ci:6: (24 bytes: <@05aa65> - <@05aa7d>): static testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+9073 @05aa65> : 1a                         load.z64
	<.main+9074 @05aa66> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9083 @05aa6f> : 1f 38 5d 05 00             load.ref <@055d38> ;Math.floor(x: float64): float64
	<.main+9088 @05aa74> : 02                         call
	<.main+9089 @05aa75> : 09 f8 ff ff                inc.sp(-8)
	<.main+9093 @05aa79> : 2d b8 84 05                store.m64 <@0584b8> ;testMathFloor_4
	test/std/test.math.ci:7: (24 bytes: <@05aa7d> - <@05aa95>): static testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+9097 @05aa7d> : 1a                         load.z64
	<.main+9098 @05aa7e> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9107 @05aa87> : 1f 38 5d 05 00             load.ref <@055d38> ;Math.floor(x: float64): float64
	<.main+9112 @05aa8c> : 02                         call
	<.main+9113 @05aa8d> : 09 f8 ff ff                inc.sp(-8)
	<.main+9117 @05aa91> : 2d c0 84 05                store.m64 <@0584c0> ;testMathFloor_5
	test/std/test.math.ci:8: (24 bytes: <@05aa95> - <@05aaad>): static testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+9121 @05aa95> : 1a                         load.z64
	<.main+9122 @05aa96> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9131 @05aa9f> : 1f 38 5d 05 00             load.ref <@055d38> ;Math.floor(x: float64): float64
	<.main+9136 @05aaa4> : 02                         call
	<.main+9137 @05aaa5> : 09 f8 ff ff                inc.sp(-8)
	<.main+9141 @05aaa9> : 2d c8 84 05                store.m64 <@0584c8> ;testMathFloor_6
	test/std/test.math.ci:10: (29 bytes: <@05aaad> - <@05aaca>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9145 @05aaad> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9154 @05aab6> : 11 00                      dup.x64 sp(0)
	<.main+9156 @05aab8> : 1a                         load.z64
	<.main+9157 @05aab9> : 89                         cgt.f64
	<.main+9158 @05aaba> : 11 01                      dup.x64 sp(1)
	<.main+9160 @05aabc> : 1a                         load.z64
	<.main+9161 @05aabd> : 88                         clt.f64
	<.main+9162 @05aabe> : 52                         sub.i32
	<.main+9163 @05aabf> : 13 02                      set.x32 sp(2)
	<.main+9165 @05aac1> : 09 fc ff ff                inc.sp(-4)
	<.main+9169 @05aac5> : 5d                         i32.2f64
	<.main+9170 @05aac6> : 2d d0 84 05                store.m64 <@0584d0> ;testMathSign_1F
	test/std/test.math.ci:11: (21 bytes: <@05aaca> - <@05aadf>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9174 @05aaca> : 1a                         load.z64
	<.main+9175 @05aacb> : 11 00                      dup.x64 sp(0)
	<.main+9177 @05aacd> : 1a                         load.z64
	<.main+9178 @05aace> : 89                         cgt.f64
	<.main+9179 @05aacf> : 11 01                      dup.x64 sp(1)
	<.main+9181 @05aad1> : 1a                         load.z64
	<.main+9182 @05aad2> : 88                         clt.f64
	<.main+9183 @05aad3> : 52                         sub.i32
	<.main+9184 @05aad4> : 13 02                      set.x32 sp(2)
	<.main+9186 @05aad6> : 09 fc ff ff                inc.sp(-4)
	<.main+9190 @05aada> : 5d                         i32.2f64
	<.main+9191 @05aadb> : 2d d8 84 05                store.m64 <@0584d8> ;testMathSign_2F
	test/std/test.math.ci:12: (29 bytes: <@05aadf> - <@05aafc>): static testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+9195 @05aadf> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9204 @05aae8> : 11 00                      dup.x64 sp(0)
	<.main+9206 @05aaea> : 1a                         load.z64
	<.main+9207 @05aaeb> : 89                         cgt.f64
	<.main+9208 @05aaec> : 11 01                      dup.x64 sp(1)
	<.main+9210 @05aaee> : 1a                         load.z64
	<.main+9211 @05aaef> : 88                         clt.f64
	<.main+9212 @05aaf0> : 52                         sub.i32
	<.main+9213 @05aaf1> : 13 02                      set.x32 sp(2)
	<.main+9215 @05aaf3> : 09 fc ff ff                inc.sp(-4)
	<.main+9219 @05aaf7> : 5d                         i32.2f64
	<.main+9220 @05aaf8> : 2d e0 84 05                store.m64 <@0584e0> ;testMathSign_3F
	test/std/test.math.ci:13: (21 bytes: <@05aafc> - <@05ab11>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9224 @05aafc> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9229 @05ab01> : 10 00                      dup.x32 sp(0)
	<.main+9231 @05ab03> : 19                         load.z32
	<.main+9232 @05ab04> : 79                         cgt.f32
	<.main+9233 @05ab05> : 10 01                      dup.x32 sp(1)
	<.main+9235 @05ab07> : 19                         load.z32
	<.main+9236 @05ab08> : 78                         clt.f32
	<.main+9237 @05ab09> : 52                         sub.i32
	<.main+9238 @05ab0a> : 13 01                      set.x32 sp(1)
	<.main+9240 @05ab0c> : 5d                         i32.2f64
	<.main+9241 @05ab0d> : 2d e8 84 05                store.m64 <@0584e8> ;testMathSign_1f
	test/std/test.math.ci:14: (17 bytes: <@05ab11> - <@05ab22>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9245 @05ab11> : 19                         load.z32
	<.main+9246 @05ab12> : 10 00                      dup.x32 sp(0)
	<.main+9248 @05ab14> : 19                         load.z32
	<.main+9249 @05ab15> : 79                         cgt.f32
	<.main+9250 @05ab16> : 10 01                      dup.x32 sp(1)
	<.main+9252 @05ab18> : 19                         load.z32
	<.main+9253 @05ab19> : 78                         clt.f32
	<.main+9254 @05ab1a> : 52                         sub.i32
	<.main+9255 @05ab1b> : 13 01                      set.x32 sp(1)
	<.main+9257 @05ab1d> : 5d                         i32.2f64
	<.main+9258 @05ab1e> : 2d f0 84 05                store.m64 <@0584f0> ;testMathSign_2f
	test/std/test.math.ci:15: (21 bytes: <@05ab22> - <@05ab37>): static testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+9262 @05ab22> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9267 @05ab27> : 10 00                      dup.x32 sp(0)
	<.main+9269 @05ab29> : 19                         load.z32
	<.main+9270 @05ab2a> : 79                         cgt.f32
	<.main+9271 @05ab2b> : 10 01                      dup.x32 sp(1)
	<.main+9273 @05ab2d> : 19                         load.z32
	<.main+9274 @05ab2e> : 78                         clt.f32
	<.main+9275 @05ab2f> : 52                         sub.i32
	<.main+9276 @05ab30> : 13 01                      set.x32 sp(1)
	<.main+9278 @05ab32> : 5d                         i32.2f64
	<.main+9279 @05ab33> : 2d f8 84 05                store.m64 <@0584f8> ;testMathSign_3f
	test/std/test.math.ci:17: (24 bytes: <@05ab37> - <@05ab4f>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9283 @05ab37> : 1a                         load.z64
	<.main+9284 @05ab38> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9293 @05ab41> : 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<.main+9298 @05ab46> : 02                         call
	<.main+9299 @05ab47> : 09 f8 ff ff                inc.sp(-8)
	<.main+9303 @05ab4b> : 2d 00 85 05                store.m64 <@058500> ;testMathAbs_1F
	test/std/test.math.ci:18: (15 bytes: <@05ab4f> - <@05ab5e>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9307 @05ab4f> : 1b                         load.z128
	<.main+9308 @05ab50> : 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<.main+9313 @05ab55> : 02                         call
	<.main+9314 @05ab56> : 09 f8 ff ff                inc.sp(-8)
	<.main+9318 @05ab5a> : 2d 08 85 05                store.m64 <@058508> ;testMathAbs_2F
	test/std/test.math.ci:19: (24 bytes: <@05ab5e> - <@05ab76>): static testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+9322 @05ab5e> : 1a                         load.z64
	<.main+9323 @05ab5f> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9332 @05ab68> : 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<.main+9337 @05ab6d> : 02                         call
	<.main+9338 @05ab6e> : 09 f8 ff ff                inc.sp(-8)
	<.main+9342 @05ab72> : 2d 10 85 05                store.m64 <@058510> ;testMathAbs_3F
	test/std/test.math.ci:20: (21 bytes: <@05ab76> - <@05ab8b>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9346 @05ab76> : 19                         load.z32
	<.main+9347 @05ab77> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9352 @05ab7c> : 1f 50 5d 05 00             load.ref <@055d50> ;Math.abs(x: float32): float32
	<.main+9357 @05ab81> : 02                         call
	<.main+9358 @05ab82> : 09 fc ff ff                inc.sp(-4)
	<.main+9362 @05ab86> : 7d                         f32.2f64
	<.main+9363 @05ab87> : 2d 18 85 05                store.m64 <@058518> ;testMathAbs_1f
	test/std/test.math.ci:21: (17 bytes: <@05ab8b> - <@05ab9c>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9367 @05ab8b> : 19                         load.z32
	<.main+9368 @05ab8c> : 19                         load.z32
	<.main+9369 @05ab8d> : 1f 50 5d 05 00             load.ref <@055d50> ;Math.abs(x: float32): float32
	<.main+9374 @05ab92> : 02                         call
	<.main+9375 @05ab93> : 09 fc ff ff                inc.sp(-4)
	<.main+9379 @05ab97> : 7d                         f32.2f64
	<.main+9380 @05ab98> : 2d 20 85 05                store.m64 <@058520> ;testMathAbs_2f
	test/std/test.math.ci:22: (21 bytes: <@05ab9c> - <@05abb1>): static testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+9384 @05ab9c> : 19                         load.z32
	<.main+9385 @05ab9d> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9390 @05aba2> : 1f 50 5d 05 00             load.ref <@055d50> ;Math.abs(x: float32): float32
	<.main+9395 @05aba7> : 02                         call
	<.main+9396 @05aba8> : 09 fc ff ff                inc.sp(-4)
	<.main+9400 @05abac> : 7d                         f32.2f64
	<.main+9401 @05abad> : 2d 28 85 05                store.m64 <@058528> ;testMathAbs_3f
	test/std/test.math.ci:24: (26 bytes: <@05abb1> - <@05abcb>): static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9405 @05abb1> : 19                         load.z32
	<.main+9406 @05abb2> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9411 @05abb7> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9416 @05abbc> : 1f c0 5d 05 00             load.ref <@055dc0> ;Math.min(a: float32, b: float32): float32
	<.main+9421 @05abc1> : 02                         call
	<.main+9422 @05abc2> : 09 f8 ff ff                inc.sp(-8)
	<.main+9426 @05abc6> : 7d                         f32.2f64
	<.main+9427 @05abc7> : 2d 30 85 05                store.m64 <@058530> ;testMathMin_1f
	test/std/test.math.ci:25: (26 bytes: <@05abcb> - <@05abe5>): static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9431 @05abcb> : 19                         load.z32
	<.main+9432 @05abcc> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9437 @05abd1> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9442 @05abd6> : 1f f0 5d 05 00             load.ref <@055df0> ;Math.max(a: float32, b: float32): float32
	<.main+9447 @05abdb> : 02                         call
	<.main+9448 @05abdc> : 09 f8 ff ff                inc.sp(-8)
	<.main+9452 @05abe0> : 7d                         f32.2f64
	<.main+9453 @05abe1> : 2d 38 85 05                store.m64 <@058538> ;testMathMax_2f
	test/std/test.math.ci:26: (33 bytes: <@05abe5> - <@05ac06>): static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9457 @05abe5> : 1a                         load.z64
	<.main+9458 @05abe6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9467 @05abef> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9476 @05abf8> : 1f d8 5d 05 00             load.ref <@055dd8> ;Math.min(a: float64, b: float64): float64
	<.main+9481 @05abfd> : 02                         call
	<.main+9482 @05abfe> : 09 f0 ff ff                inc.sp(-16)
	<.main+9486 @05ac02> : 2d 40 85 05                store.m64 <@058540> ;testMathMin_1F
	test/std/test.math.ci:27: (33 bytes: <@05ac06> - <@05ac27>): static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9490 @05ac06> : 1a                         load.z64
	<.main+9491 @05ac07> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9500 @05ac10> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9509 @05ac19> : 1f 08 5e 05 00             load.ref <@055e08> ;Math.max(a: float64, b: float64): float64
	<.main+9514 @05ac1e> : 02                         call
	<.main+9515 @05ac1f> : 09 f0 ff ff                inc.sp(-16)
	<.main+9519 @05ac23> : 2d 48 85 05                store.m64 <@058548> ;testMathMax_2F
	test/std/test.math.ci:29: (27 bytes: <@05ac27> - <@05ac42>): static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9523 @05ac27> : 19                         load.z32
	<.main+9524 @05ac28> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9529 @05ac2d> : 19                         load.z32
	<.main+9530 @05ac2e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9535 @05ac33> : 1f 20 5e 05 00             load.ref <@055e20> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9540 @05ac38> : 02                         call
	<.main+9541 @05ac39> : 09 f4 ff ff                inc.sp(-12)
	<.main+9545 @05ac3d> : 7d                         f32.2f64
	<.main+9546 @05ac3e> : 2d 50 85 05                store.m64 <@058550> ;testMathClamp_1f
	test/std/test.math.ci:30: (34 bytes: <@05ac42> - <@05ac64>): static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9550 @05ac42> : 1a                         load.z64
	<.main+9551 @05ac43> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9560 @05ac4c> : 1a                         load.z64
	<.main+9561 @05ac4d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9570 @05ac56> : 1f 40 5e 05 00             load.ref <@055e40> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9575 @05ac5b> : 02                         call
	<.main+9576 @05ac5c> : 09 e8 ff ff                inc.sp(-24)
	<.main+9580 @05ac60> : 2d 58 85 05                store.m64 <@058558> ;testMathClamp_1F
	test/std/test.math.ci:32: (25 bytes: <@05ac64> - <@05ac7d>): static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9584 @05ac64> : 19                         load.z32
	<.main+9585 @05ac65> : 10 00                      dup.x32 sp(0)
	<.main+9587 @05ac67> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9592 @05ac6c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9597 @05ac71> : 10 03                      dup.x32 sp(3)
	<.main+9599 @05ac73> : 72                         sub.f32
	<.main+9600 @05ac74> : 73                         mul.f32
	<.main+9601 @05ac75> : 71                         add.f32
	<.main+9602 @05ac76> : 13 01                      set.x32 sp(1)
	<.main+9604 @05ac78> : 7d                         f32.2f64
	<.main+9605 @05ac79> : 2d 60 85 05                store.m64 <@058560> ;testMathLerp_1f
	test/std/test.math.ci:33: (32 bytes: <@05ac7d> - <@05ac9d>): static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9609 @05ac7d> : 1a                         load.z64
	<.main+9610 @05ac7e> : 11 00                      dup.x64 sp(0)
	<.main+9612 @05ac80> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9621 @05ac89> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9630 @05ac92> : 11 06                      dup.x64 sp(6)
	<.main+9632 @05ac94> : 82                         sub.f64
	<.main+9633 @05ac95> : 83                         mul.f64
	<.main+9634 @05ac96> : 81                         add.f64
	<.main+9635 @05ac97> : 14 02                      set.x64 sp(2)
	<.main+9637 @05ac99> : 2d 68 85 05                store.m64 <@058568> ;testMathLerp_1F
	test/std/test.math.ci:35: (64 bytes: <@05ac9d> - <@05acdd>): static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9641 @05ac9d> : 19                         load.z32
	<.main+9642 @05ac9e> : 19                         load.z32
	<.main+9643 @05ac9f> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9648 @05aca4> : 10 02                      dup.x32 sp(2)
	<.main+9650 @05aca6> : 72                         sub.f32
	<.main+9651 @05aca7> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9656 @05acac> : 10 03                      dup.x32 sp(3)
	<.main+9658 @05acae> : 72                         sub.f32
	<.main+9659 @05acaf> : 74                         div.f32
	<.main+9660 @05acb0> : 19                         load.z32
	<.main+9661 @05acb1> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9666 @05acb6> : 1f 20 5e 05 00             load.ref <@055e20> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9671 @05acbb> : 02                         call
	<.main+9672 @05acbc> : 09 f4 ff ff                inc.sp(-12)
	<.main+9676 @05acc0> : 10 00                      dup.x32 sp(0)
	<.main+9678 @05acc2> : 10 01                      dup.x32 sp(1)
	<.main+9680 @05acc4> : 73                         mul.f32
	<.main+9681 @05acc5> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9686 @05acca> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9691 @05accf> : 10 03                      dup.x32 sp(3)
	<.main+9693 @05acd1> : 73                         mul.f32
	<.main+9694 @05acd2> : 72                         sub.f32
	<.main+9695 @05acd3> : 73                         mul.f32
	<.main+9696 @05acd4> : 13 01                      set.x32 sp(1)
	<.main+9698 @05acd6> : 13 01                      set.x32 sp(1)
	<.main+9700 @05acd8> : 7d                         f32.2f64
	<.main+9701 @05acd9> : 2d 70 85 05                store.m64 <@058570> ;testMathSmooth_1f
	test/std/test.math.ci:36: (82 bytes: <@05acdd> - <@05ad2f>): static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9705 @05acdd> : 1b                         load.z128
	<.main+9706 @05acde> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9715 @05ace7> : 11 04                      dup.x64 sp(4)
	<.main+9717 @05ace9> : 82                         sub.f64
	<.main+9718 @05acea> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9727 @05acf3> : 11 06                      dup.x64 sp(6)
	<.main+9729 @05acf5> : 82                         sub.f64
	<.main+9730 @05acf6> : 84                         div.f64
	<.main+9731 @05acf7> : 1a                         load.z64
	<.main+9732 @05acf8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9741 @05ad01> : 1f 40 5e 05 00             load.ref <@055e40> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9746 @05ad06> : 02                         call
	<.main+9747 @05ad07> : 09 e8 ff ff                inc.sp(-24)
	<.main+9751 @05ad0b> : 11 00                      dup.x64 sp(0)
	<.main+9753 @05ad0d> : 11 02                      dup.x64 sp(2)
	<.main+9755 @05ad0f> : 83                         mul.f64
	<.main+9756 @05ad10> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9765 @05ad19> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9774 @05ad22> : 11 06                      dup.x64 sp(6)
	<.main+9776 @05ad24> : 83                         mul.f64
	<.main+9777 @05ad25> : 82                         sub.f64
	<.main+9778 @05ad26> : 83                         mul.f64
	<.main+9779 @05ad27> : 14 02                      set.x64 sp(2)
	<.main+9781 @05ad29> : 14 02                      set.x64 sp(2)
	<.main+9783 @05ad2b> : 2d 78 85 05                store.m64 <@058578> ;testMathSmooth_1F
	test/std/test.math.ci:38: (25 bytes: <@05ad2f> - <@05ad48>): static testMathMin_nan: float64 := Math.min()
	<.main+9787 @05ad2f> : 19                         load.z32
	<.main+9788 @05ad30> : 0a 04 00 00                load.sp(+4)
	<.main+9792 @05ad34> : 1a                         load.z64
	<.main+9793 @05ad35> : 11 02                      dup.x64 sp(2)
	<.main+9795 @05ad37> : 1f 60 5e 05 00             load.ref <@055e60> ;Math.min(data: float64[]): float64
	<.main+9800 @05ad3c> : 02                         call
	<.main+9801 @05ad3d> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9804 @05ad40> : 09 f0 ff ff                inc.sp(-16)
	<.main+9808 @05ad44> : 2d 80 85 05                store.m64 <@058580> ;testMathMin_nan
	test/std/test.math.ci:39: (110 bytes: <@05ad48> - <@05adb6>): static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9812 @05ad48> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9821 @05ad51> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9830 @05ad5a> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9839 @05ad63> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9848 @05ad6c> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9857 @05ad75> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9866 @05ad7e> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9875 @05ad87> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9884 @05ad90> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9893 @05ad99> : 1c 09 00 00 00             load.c32 9
	<.main+9898 @05ad9e> : 0a 04 00 00                load.sp(+4)
	<.main+9902 @05ada2> : 1a                         load.z64
	<.main+9903 @05ada3> : 11 02                      dup.x64 sp(2)
	<.main+9905 @05ada5> : 1f 60 5e 05 00             load.ref <@055e60> ;Math.min(data: float64[]): float64
	<.main+9910 @05adaa> : 02                         call
	<.main+9911 @05adab> : 17 16 02                   mov.x64 sp(22, 2)
	<.main+9914 @05adae> : 09 a8 ff ff                inc.sp(-88)
	<.main+9918 @05adb2> : 2d 88 85 05                store.m64 <@058588> ;testMathMin_1
	test/std/test.math.ci:40: (25 bytes: <@05adb6> - <@05adcf>): static testMathMax_nan: float64 := Math.max()
	<.main+9922 @05adb6> : 19                         load.z32
	<.main+9923 @05adb7> : 0a 04 00 00                load.sp(+4)
	<.main+9927 @05adbb> : 1a                         load.z64
	<.main+9928 @05adbc> : 11 02                      dup.x64 sp(2)
	<.main+9930 @05adbe> : 1f b0 5e 05 00             load.ref <@055eb0> ;Math.max(data: float64[]): float64
	<.main+9935 @05adc3> : 02                         call
	<.main+9936 @05adc4> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9939 @05adc7> : 09 f0 ff ff                inc.sp(-16)
	<.main+9943 @05adcb> : 2d 90 85 05                store.m64 <@058590> ;testMathMax_nan
	test/std/test.math.ci:41: (110 bytes: <@05adcf> - <@05ae3d>): static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9947 @05adcf> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9956 @05add8> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9965 @05ade1> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9974 @05adea> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9983 @05adf3> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9992 @05adfc> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10001 @05ae05>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10010 @05ae0e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10019 @05ae17>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10028 @05ae20>: 1c 09 00 00 00             load.c32 9
	<.main+10033 @05ae25>: 0a 04 00 00                load.sp(+4)
	<.main+10037 @05ae29>: 1a                         load.z64
	<.main+10038 @05ae2a>: 11 02                      dup.x64 sp(2)
	<.main+10040 @05ae2c>: 1f b0 5e 05 00             load.ref <@055eb0> ;Math.max(data: float64[]): float64
	<.main+10045 @05ae31>: 02                         call
	<.main+10046 @05ae32>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10049 @05ae35>: 09 a8 ff ff                inc.sp(-88)
	<.main+10053 @05ae39>: 2d 98 85 05                store.m64 <@058598> ;testMathMax_9
	test/std/test.math.ci:43: (25 bytes: <@05ae3d> - <@05ae56>): static testMathSum_0: float64 := Math.sum()
	<.main+10057 @05ae3d>: 19                         load.z32
	<.main+10058 @05ae3e>: 0a 04 00 00                load.sp(+4)
	<.main+10062 @05ae42>: 1a                         load.z64
	<.main+10063 @05ae43>: 11 02                      dup.x64 sp(2)
	<.main+10065 @05ae45>: 1f 00 5f 05 00             load.ref <@055f00> ;Math.sum(data: float64[]): float64
	<.main+10070 @05ae4a>: 02                         call
	<.main+10071 @05ae4b>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10074 @05ae4e>: 09 f0 ff ff                inc.sp(-16)
	<.main+10078 @05ae52>: 2d a0 85 05                store.m64 <@0585a0> ;testMathSum_0
	test/std/test.math.ci:44: (38 bytes: <@05ae56> - <@05ae7c>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10082 @05ae56>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10091 @05ae5f>: 1c 01 00 00 00             load.c32 1
	<.main+10096 @05ae64>: 0a 04 00 00                load.sp(+4)
	<.main+10100 @05ae68>: 1a                         load.z64
	<.main+10101 @05ae69>: 11 02                      dup.x64 sp(2)
	<.main+10103 @05ae6b>: 1f 00 5f 05 00             load.ref <@055f00> ;Math.sum(data: float64[]): float64
	<.main+10108 @05ae70>: 02                         call
	<.main+10109 @05ae71>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10112 @05ae74>: 09 e8 ff ff                inc.sp(-24)
	<.main+10116 @05ae78>: 2d a8 85 05                store.m64 <@0585a8> ;testMathSum_1
	test/std/test.math.ci:45: (47 bytes: <@05ae7c> - <@05aeab>): static testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+10120 @05ae7c>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10129 @05ae85>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10138 @05ae8e>: 1c 02 00 00 00             load.c32 2
	<.main+10143 @05ae93>: 0a 04 00 00                load.sp(+4)
	<.main+10147 @05ae97>: 1a                         load.z64
	<.main+10148 @05ae98>: 11 02                      dup.x64 sp(2)
	<.main+10150 @05ae9a>: 1f 00 5f 05 00             load.ref <@055f00> ;Math.sum(data: float64[]): float64
	<.main+10155 @05ae9f>: 02                         call
	<.main+10156 @05aea0>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10159 @05aea3>: 09 e0 ff ff                inc.sp(-32)
	<.main+10163 @05aea7>: 2d b0 85 05                store.m64 <@0585b0> ;testMathSum_3
	test/std/test.math.ci:46: (119 bytes: <@05aeab> - <@05af22>): static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+10167 @05aeab>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10176 @05aeb4>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10185 @05aebd>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10194 @05aec6>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10203 @05aecf>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10212 @05aed8>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10221 @05aee1>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10230 @05aeea>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10239 @05aef3>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10248 @05aefc>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10257 @05af05>: 1c 0a 00 00 00             load.c32 10
	<.main+10262 @05af0a>: 0a 04 00 00                load.sp(+4)
	<.main+10266 @05af0e>: 1a                         load.z64
	<.main+10267 @05af0f>: 11 02                      dup.x64 sp(2)
	<.main+10269 @05af11>: 1f 00 5f 05 00             load.ref <@055f00> ;Math.sum(data: float64[]): float64
	<.main+10274 @05af16>: 02                         call
	<.main+10275 @05af17>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10278 @05af1a>: 09 a0 ff ff                inc.sp(-96)
	<.main+10282 @05af1e>: 2d b8 85 05                store.m64 <@0585b8> ;testMathSum_55
	test/std/test.math.ci:48: (13 bytes: <@05af22> - <@05af2f>): static testMathEval_x: float64 := 10
	<.main+10286 @05af22>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10295 @05af2b>: 2d c0 85 05                store.m64 <@0585c0> ;testMathEval_x
	test/std/test.math.ci:49: (29 bytes: <@05af2f> - <@05af4c>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10299 @05af2f>: 19                         load.z32
	<.main+10300 @05af30>: 0a 04 00 00                load.sp(+4)
	<.main+10304 @05af34>: 1a                         load.z64
	<.main+10305 @05af35>: 2b c0 85 05                load.m64 <@0585c0> ;testMathEval_x
	<.main+10309 @05af39>: 11 04                      dup.x64 sp(4)
	<.main+10311 @05af3b>: 1f 28 5f 05 00             load.ref <@055f28> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10316 @05af40>: 02                         call
	<.main+10317 @05af41>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10320 @05af44>: 09 e8 ff ff                inc.sp(-24)
	<.main+10324 @05af48>: 2d c8 85 05                store.m64 <@0585c8> ;testMathEval_0
	test/std/test.math.ci:50: (13 bytes: <@05af4c> - <@05af59>): static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+10328 @05af4c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10337 @05af55>: 2d d0 85 05                store.m64 <@0585d0> ;testMathEval_1
	test/std/test.math.ci:51: (28 bytes: <@05af59> - <@05af75>): static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+10341 @05af59>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10350 @05af62>: 2b c0 85 05                load.m64 <@0585c0> ;testMathEval_x
	<.main+10354 @05af66>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10363 @05af6f>: 83                         mul.f64
	<.main+10364 @05af70>: 81                         add.f64
	<.main+10365 @05af71>: 2d d8 85 05                store.m64 <@0585d8> ;testMathEval_2
	test/std/test.math.ci:52: (45 bytes: <@05af75> - <@05afa2>): static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+10369 @05af75>: 2b c0 85 05                load.m64 <@0585c0> ;testMathEval_x
	<.main+10373 @05af79>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10382 @05af82>: 11 02                      dup.x64 sp(2)
	<.main+10384 @05af84>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10393 @05af8d>: 11 06                      dup.x64 sp(6)
	<.main+10395 @05af8f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10404 @05af98>: 83                         mul.f64
	<.main+10405 @05af99>: 81                         add.f64
	<.main+10406 @05af9a>: 83                         mul.f64
	<.main+10407 @05af9b>: 81                         add.f64
	<.main+10408 @05af9c>: 14 02                      set.x64 sp(2)
	<.main+10410 @05af9e>: 2d e0 85 05                store.m64 <@0585e0> ;testMathEval_3
	test/std/test.math.ci:53: (62 bytes: <@05afa2> - <@05afe0>): static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10414 @05afa2>: 2b c0 85 05                load.m64 <@0585c0> ;testMathEval_x
	<.main+10418 @05afa6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10427 @05afaf>: 11 02                      dup.x64 sp(2)
	<.main+10429 @05afb1>: 11 04                      dup.x64 sp(4)
	<.main+10431 @05afb3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10440 @05afbc>: 11 02                      dup.x64 sp(2)
	<.main+10442 @05afbe>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10451 @05afc7>: 11 06                      dup.x64 sp(6)
	<.main+10453 @05afc9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10462 @05afd2>: 83                         mul.f64
	<.main+10463 @05afd3>: 81                         add.f64
	<.main+10464 @05afd4>: 83                         mul.f64
	<.main+10465 @05afd5>: 81                         add.f64
	<.main+10466 @05afd6>: 14 02                      set.x64 sp(2)
	<.main+10468 @05afd8>: 83                         mul.f64
	<.main+10469 @05afd9>: 81                         add.f64
	<.main+10470 @05afda>: 14 02                      set.x64 sp(2)
	<.main+10472 @05afdc>: 2d e8 85 05                store.m64 <@0585e8> ;testMathEval_4
	test/std/test.math.ci:54: (78 bytes: <@05afe0> - <@05b02e>): static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10476 @05afe0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10485 @05afe9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10494 @05aff2>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10503 @05affb>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10512 @05b004>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10521 @05b00d>: 1c 05 00 00 00             load.c32 5
	<.main+10526 @05b012>: 0a 04 00 00                load.sp(+4)
	<.main+10530 @05b016>: 1a                         load.z64
	<.main+10531 @05b017>: 2b c0 85 05                load.m64 <@0585c0> ;testMathEval_x
	<.main+10535 @05b01b>: 11 04                      dup.x64 sp(4)
	<.main+10537 @05b01d>: 1f 28 5f 05 00             load.ref <@055f28> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10542 @05b022>: 02                         call
	<.main+10543 @05b023>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10546 @05b026>: 09 c0 ff ff                inc.sp(-64)
	<.main+10550 @05b02a>: 2d f0 85 05                store.m64 <@0585f0> ;testMathEval_5
	test/std/test.math.ci:55: (87 bytes: <@05b02e> - <@05b085>): static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10554 @05b02e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10563 @05b037>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10572 @05b040>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10581 @05b049>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10590 @05b052>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10599 @05b05b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10608 @05b064>: 1c 06 00 00 00             load.c32 6
	<.main+10613 @05b069>: 0a 04 00 00                load.sp(+4)
	<.main+10617 @05b06d>: 1a                         load.z64
	<.main+10618 @05b06e>: 2b c0 85 05                load.m64 <@0585c0> ;testMathEval_x
	<.main+10622 @05b072>: 11 04                      dup.x64 sp(4)
	<.main+10624 @05b074>: 1f 28 5f 05 00             load.ref <@055f28> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10629 @05b079>: 02                         call
	<.main+10630 @05b07a>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10633 @05b07d>: 09 b8 ff ff                inc.sp(-72)
	<.main+10637 @05b081>: 2d f8 85 05                store.m64 <@0585f8> ;testMathEval_6
	test/std/test.math.ci:57: (35 bytes: <@05b085> - <@05b0a8>): static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10641 @05b085>: 1a                         load.z64
	<.main+10642 @05b086>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10651 @05b08f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10660 @05b098>: 84                         div.f64
	<.main+10661 @05b099>: 19                         load.z32
	<.main+10662 @05b09a>: 1f d8 5f 05 00             load.ref <@055fd8> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10667 @05b09f>: 02                         call
	<.main+10668 @05b0a0>: 09 f4 ff ff                inc.sp(-12)
	<.main+10672 @05b0a4>: 2d 00 86 05                store.m64 <@058600> ;testMathSin_f64
	test/std/test.math.ci:58: (49 bytes: <@05b0a8> - <@05b0d9>): static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10676 @05b0a8>: 1b                         load.z128
	<.main+10677 @05b0a9>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10686 @05b0b2>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10695 @05b0bb>: 84                         div.f64
	<.main+10696 @05b0bc>: 1f 68 5d 05 00             load.ref <@055d68> ;Math.abs(x: float64): float64
	<.main+10701 @05b0c1>: 02                         call
	<.main+10702 @05b0c2>: 09 f8 ff ff                inc.sp(-8)
	<.main+10706 @05b0c6>: 1c 01 00 00 00             load.c32 1
	<.main+10711 @05b0cb>: 1f d8 5f 05 00             load.ref <@055fd8> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10716 @05b0d0>: 02                         call
	<.main+10717 @05b0d1>: 09 f4 ff ff                inc.sp(-12)
	<.main+10721 @05b0d5>: 2d 08 86 05                store.m64 <@058608> ;testMathCos_f64
	test/std/test.math.ci:59: (34 bytes: <@05b0d9> - <@05b0fb>): static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10725 @05b0d9>: 1a                         load.z64
	<.main+10726 @05b0da>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10735 @05b0e3>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10744 @05b0ec>: 84                         div.f64
	<.main+10745 @05b0ed>: 1f 28 61 05 00             load.ref <@056128> ;Math.tan(arg: float64): float64
	<.main+10750 @05b0f2>: 02                         call
	<.main+10751 @05b0f3>: 09 f8 ff ff                inc.sp(-8)
	<.main+10755 @05b0f7>: 2d 10 86 05                store.m64 <@058610> ;testMathTan_f64
	test/std/test.math.ci:60: (34 bytes: <@05b0fb> - <@05b11d>): static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10759 @05b0fb>: 1a                         load.z64
	<.main+10760 @05b0fc>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10769 @05b105>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10778 @05b10e>: 84                         div.f64
	<.main+10779 @05b10f>: 1f a8 62 05 00             load.ref <@0562a8> ;Math.sinh(x: float64): float64
	<.main+10784 @05b114>: 02                         call
	<.main+10785 @05b115>: 09 f8 ff ff                inc.sp(-8)
	<.main+10789 @05b119>: 2d 18 86 05                store.m64 <@058618> ;testMathSinh_f64
	test/std/test.math.ci:61: (34 bytes: <@05b11d> - <@05b13f>): static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10793 @05b11d>: 1a                         load.z64
	<.main+10794 @05b11e>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10803 @05b127>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10812 @05b130>: 84                         div.f64
	<.main+10813 @05b131>: 1f a0 63 05 00             load.ref <@0563a0> ;Math.cosh(x: float64): float64
	<.main+10818 @05b136>: 02                         call
	<.main+10819 @05b137>: 09 f8 ff ff                inc.sp(-8)
	<.main+10823 @05b13b>: 2d 20 86 05                store.m64 <@058620> ;testMathCosh_f64
	test/std/test.math.ci:63: (24 bytes: <@05b13f> - <@05b157>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10827 @05b13f>: 1a                         load.z64
	<.main+10828 @05b140>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10837 @05b149>: 1f f0 63 05 00             load.ref <@0563f0> ;Math.asin(x: float64): float64
	<.main+10842 @05b14e>: 02                         call
	<.main+10843 @05b14f>: 09 f8 ff ff                inc.sp(-8)
	<.main+10847 @05b153>: 2d 28 86 05                store.m64 <@058628> ;testMathAsin_f64
	test/std/test.math.ci:64: (44 bytes: <@05b157> - <@05b183>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10851 @05b157>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10860 @05b160>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10869 @05b169>: 84                         div.f64
	<.main+10870 @05b16a>: 1a                         load.z64
	<.main+10871 @05b16b>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10880 @05b174>: 1f f0 63 05 00             load.ref <@0563f0> ;Math.asin(x: float64): float64
	<.main+10885 @05b179>: 02                         call
	<.main+10886 @05b17a>: 09 f8 ff ff                inc.sp(-8)
	<.main+10890 @05b17e>: 82                         sub.f64
	<.main+10891 @05b17f>: 2d 30 86 05                store.m64 <@058630> ;testMathAcos_f64
	test/std/test.math.ci:67: (34 bytes: <@05b183> - <@05b1a5>): static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10895 @05b183>: 19                         load.z32
	<.main+10896 @05b184>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10901 @05b189>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10906 @05b18e>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10911 @05b193>: 1f 58 5f 05 00             load.ref <@055f58> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10916 @05b198>: 02                         call
	<.main+10917 @05b199>: 09 f4 ff ff                inc.sp(-12)
	<.main+10921 @05b19d>: 19                         load.z32
	<.main+10922 @05b19e>: 57                         ceq.i32
	<.main+10923 @05b19f>: 1f 38 86 05 00             load.ref <@058638> ;testMathCmp_f32
	<.main+10928 @05b1a4>: 25                         store.i8
	test/std/test.math.ci:68: (46 bytes: <@05b1a5> - <@05b1d3>): static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10929 @05b1a5>: 19                         load.z32
	<.main+10930 @05b1a6>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10939 @05b1af>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10948 @05b1b8>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10957 @05b1c1>: 1f 98 5f 05 00             load.ref <@055f98> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10962 @05b1c6>: 02                         call
	<.main+10963 @05b1c7>: 09 e8 ff ff                inc.sp(-24)
	<.main+10967 @05b1cb>: 19                         load.z32
	<.main+10968 @05b1cc>: 57                         ceq.i32
	<.main+10969 @05b1cd>: 1f 40 86 05 00             load.ref <@058640> ;testMathCmp_f64
	<.main+10974 @05b1d2>: 25                         store.i8
	test/std/test.math.ci:70: (33 bytes: <@05b1d3> - <@05b1f4>): static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10975 @05b1d3>: 1a                         load.z64
	<.main+10976 @05b1d4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10985 @05b1dd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10994 @05b1e6>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10999 @05b1eb>: 02                         call
	<.main+11000 @05b1ec>: 09 f0 ff ff                inc.sp(-16)
	<.main+11004 @05b1f0>: 2d 48 86 05                store.m64 <@058648> ;testMathAbsMod_f64_0a
	test/std/test.math.ci:71: (24 bytes: <@05b1f4> - <@05b20c>): static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+11008 @05b1f4>: 1b                         load.z128
	<.main+11009 @05b1f5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11018 @05b1fe>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11023 @05b203>: 02                         call
	<.main+11024 @05b204>: 09 f0 ff ff                inc.sp(-16)
	<.main+11028 @05b208>: 2d 50 86 05                store.m64 <@058650> ;testMathAbsMod_f64_0b
	test/std/test.math.ci:72: (33 bytes: <@05b20c> - <@05b22d>): static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+11032 @05b20c>: 1a                         load.z64
	<.main+11033 @05b20d>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11042 @05b216>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11051 @05b21f>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11056 @05b224>: 02                         call
	<.main+11057 @05b225>: 09 f0 ff ff                inc.sp(-16)
	<.main+11061 @05b229>: 2d 58 86 05                store.m64 <@058658> ;testMathAbsMod_f64_0c
	test/std/test.math.ci:74: (33 bytes: <@05b22d> - <@05b24e>): static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+11065 @05b22d>: 1a                         load.z64
	<.main+11066 @05b22e>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11075 @05b237>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11084 @05b240>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11089 @05b245>: 02                         call
	<.main+11090 @05b246>: 09 f0 ff ff                inc.sp(-16)
	<.main+11094 @05b24a>: 2d 60 86 05                store.m64 <@058660> ;testMathAbsMod_f64_9a
	test/std/test.math.ci:75: (33 bytes: <@05b24e> - <@05b26f>): static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+11098 @05b24e>: 1a                         load.z64
	<.main+11099 @05b24f>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11108 @05b258>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11117 @05b261>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11122 @05b266>: 02                         call
	<.main+11123 @05b267>: 09 f0 ff ff                inc.sp(-16)
	<.main+11127 @05b26b>: 2d 68 86 05                store.m64 <@058668> ;testMathAbsMod_f64_9b
	test/std/test.math.ci:76: (33 bytes: <@05b26f> - <@05b290>): static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+11131 @05b26f>: 1a                         load.z64
	<.main+11132 @05b270>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11141 @05b279>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11150 @05b282>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11155 @05b287>: 02                         call
	<.main+11156 @05b288>: 09 f0 ff ff                inc.sp(-16)
	<.main+11160 @05b28c>: 2d 70 86 05                store.m64 <@058670> ;testMathAbsMod_f64_9c
	test/std/test.math.ci:77: (33 bytes: <@05b290> - <@05b2b1>): static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+11164 @05b290>: 1a                         load.z64
	<.main+11165 @05b291>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11174 @05b29a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11183 @05b2a3>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11188 @05b2a8>: 02                         call
	<.main+11189 @05b2a9>: 09 f0 ff ff                inc.sp(-16)
	<.main+11193 @05b2ad>: 2d 78 86 05                store.m64 <@058678> ;testMathAbsMod_f64_9d
	test/std/test.math.ci:79: (33 bytes: <@05b2b1> - <@05b2d2>): static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+11197 @05b2b1>: 1a                         load.z64
	<.main+11198 @05b2b2>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11207 @05b2bb>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11216 @05b2c4>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11221 @05b2c9>: 02                         call
	<.main+11222 @05b2ca>: 09 f0 ff ff                inc.sp(-16)
	<.main+11226 @05b2ce>: 2d 80 86 05                store.m64 <@058680> ;testMathAbsMod_f64_8a
	test/std/test.math.ci:80: (33 bytes: <@05b2d2> - <@05b2f3>): static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+11230 @05b2d2>: 1a                         load.z64
	<.main+11231 @05b2d3>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11240 @05b2dc>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11249 @05b2e5>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11254 @05b2ea>: 02                         call
	<.main+11255 @05b2eb>: 09 f0 ff ff                inc.sp(-16)
	<.main+11259 @05b2ef>: 2d 88 86 05                store.m64 <@058688> ;testMathAbsMod_f64_8b
	test/std/test.math.ci:81: (33 bytes: <@05b2f3> - <@05b314>): static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+11263 @05b2f3>: 1a                         load.z64
	<.main+11264 @05b2f4>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11273 @05b2fd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11282 @05b306>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11287 @05b30b>: 02                         call
	<.main+11288 @05b30c>: 09 f0 ff ff                inc.sp(-16)
	<.main+11292 @05b310>: 2d 90 86 05                store.m64 <@058690> ;testMathAbsMod_f64_8c
	test/std/test.math.ci:82: (33 bytes: <@05b314> - <@05b335>): static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+11296 @05b314>: 1a                         load.z64
	<.main+11297 @05b315>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11306 @05b31e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11315 @05b327>: 1f a0 5d 05 00             load.ref <@055da0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11320 @05b32c>: 02                         call
	<.main+11321 @05b32d>: 09 f0 ff ff                inc.sp(-16)
	<.main+11325 @05b331>: 2d 98 86 05                store.m64 <@058698> ;testMathAbsMod_f64_8d
	test/std/test.math.ci:84: (25 bytes: <@05b335> - <@05b34e>): static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+11329 @05b335>: 19                         load.z32
	<.main+11330 @05b336>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11335 @05b33b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11340 @05b340>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11345 @05b345>: 02                         call
	<.main+11346 @05b346>: 09 f8 ff ff                inc.sp(-8)
	<.main+11350 @05b34a>: 2e a0 86 05                store.m32 <@0586a0> ;testMathAbsMod_f32_0a
	test/std/test.math.ci:85: (21 bytes: <@05b34e> - <@05b363>): static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+11354 @05b34e>: 19                         load.z32
	<.main+11355 @05b34f>: 19                         load.z32
	<.main+11356 @05b350>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11361 @05b355>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11366 @05b35a>: 02                         call
	<.main+11367 @05b35b>: 09 f8 ff ff                inc.sp(-8)
	<.main+11371 @05b35f>: 2e a8 86 05                store.m32 <@0586a8> ;testMathAbsMod_f32_0b
	test/std/test.math.ci:86: (25 bytes: <@05b363> - <@05b37c>): static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+11375 @05b363>: 19                         load.z32
	<.main+11376 @05b364>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11381 @05b369>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11386 @05b36e>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11391 @05b373>: 02                         call
	<.main+11392 @05b374>: 09 f8 ff ff                inc.sp(-8)
	<.main+11396 @05b378>: 2e b0 86 05                store.m32 <@0586b0> ;testMathAbsMod_f32_0c
	test/std/test.math.ci:88: (25 bytes: <@05b37c> - <@05b395>): static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+11400 @05b37c>: 19                         load.z32
	<.main+11401 @05b37d>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11406 @05b382>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11411 @05b387>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11416 @05b38c>: 02                         call
	<.main+11417 @05b38d>: 09 f8 ff ff                inc.sp(-8)
	<.main+11421 @05b391>: 2e b8 86 05                store.m32 <@0586b8> ;testMathAbsMod_f32_9a
	test/std/test.math.ci:89: (25 bytes: <@05b395> - <@05b3ae>): static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+11425 @05b395>: 19                         load.z32
	<.main+11426 @05b396>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11431 @05b39b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11436 @05b3a0>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11441 @05b3a5>: 02                         call
	<.main+11442 @05b3a6>: 09 f8 ff ff                inc.sp(-8)
	<.main+11446 @05b3aa>: 2e c0 86 05                store.m32 <@0586c0> ;testMathAbsMod_f32_9b
	test/std/test.math.ci:90: (25 bytes: <@05b3ae> - <@05b3c7>): static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+11450 @05b3ae>: 19                         load.z32
	<.main+11451 @05b3af>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11456 @05b3b4>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11461 @05b3b9>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11466 @05b3be>: 02                         call
	<.main+11467 @05b3bf>: 09 f8 ff ff                inc.sp(-8)
	<.main+11471 @05b3c3>: 2e c8 86 05                store.m32 <@0586c8> ;testMathAbsMod_f32_9c
	test/std/test.math.ci:91: (25 bytes: <@05b3c7> - <@05b3e0>): static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+11475 @05b3c7>: 19                         load.z32
	<.main+11476 @05b3c8>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11481 @05b3cd>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11486 @05b3d2>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11491 @05b3d7>: 02                         call
	<.main+11492 @05b3d8>: 09 f8 ff ff                inc.sp(-8)
	<.main+11496 @05b3dc>: 2e d0 86 05                store.m32 <@0586d0> ;testMathAbsMod_f32_9d
	test/std/test.math.ci:93: (25 bytes: <@05b3e0> - <@05b3f9>): static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+11500 @05b3e0>: 19                         load.z32
	<.main+11501 @05b3e1>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11506 @05b3e6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11511 @05b3eb>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11516 @05b3f0>: 02                         call
	<.main+11517 @05b3f1>: 09 f8 ff ff                inc.sp(-8)
	<.main+11521 @05b3f5>: 2e d8 86 05                store.m32 <@0586d8> ;testMathAbsMod_f32_8a
	test/std/test.math.ci:94: (25 bytes: <@05b3f9> - <@05b412>): static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+11525 @05b3f9>: 19                         load.z32
	<.main+11526 @05b3fa>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11531 @05b3ff>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11536 @05b404>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11541 @05b409>: 02                         call
	<.main+11542 @05b40a>: 09 f8 ff ff                inc.sp(-8)
	<.main+11546 @05b40e>: 2e e0 86 05                store.m32 <@0586e0> ;testMathAbsMod_f32_8b
	test/std/test.math.ci:95: (25 bytes: <@05b412> - <@05b42b>): static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+11550 @05b412>: 19                         load.z32
	<.main+11551 @05b413>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11556 @05b418>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11561 @05b41d>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11566 @05b422>: 02                         call
	<.main+11567 @05b423>: 09 f8 ff ff                inc.sp(-8)
	<.main+11571 @05b427>: 2e e8 86 05                store.m32 <@0586e8> ;testMathAbsMod_f32_8c
	test/std/test.math.ci:96: (25 bytes: <@05b42b> - <@05b444>): static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+11575 @05b42b>: 19                         load.z32
	<.main+11576 @05b42c>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11581 @05b431>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11586 @05b436>: 1f 80 5d 05 00             load.ref <@055d80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11591 @05b43b>: 02                         call
	<.main+11592 @05b43c>: 09 f8 ff ff                inc.sp(-8)
	<.main+11596 @05b440>: 2e f0 86 05                store.m32 <@0586f0> ;testMathAbsMod_f32_8d
	test/std/memory.ci:13: (18 bytes: <@05b444> - <@05b456>): pointer.fill(void(void(p1, 0), 1024));
	<.main+11600 @05b444>: 2a 58 79 05                load.m32 <@057958> ;p1
	<.main+11604 @05b448>: 19                         load.z32
	<.main+11605 @05b449>: 1c 00 04 00 00             load.c32 1024
	<.main+11610 @05b44e>: 01 0c 00 00                nfc(12) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11614 @05b452>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:14: (21 bytes: <@05b456> - <@05b46b>): pointer.copy(void(void(p1, p3), 160));
	<.main+11618 @05b456>: 2a 58 79 05                load.m32 <@057958> ;p1
	<.main+11622 @05b45a>: 2a 68 79 05                load.m32 <@057968> ;p3
	<.main+11626 @05b45e>: 1c a0 00 00 00             load.c32 160
	<.main+11631 @05b463>: 01 0d 00 00                nfc(13) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11635 @05b467>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:17: (13 bytes: <@05b46b> - <@05b478>): free(p1);
	<.main+11639 @05b46b>: 2a 58 79 05                load.m32 <@057958> ;p1
	<.main+11643 @05b46f>: 19                         load.z32
	<.main+11644 @05b470>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11648 @05b474>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:18: (13 bytes: <@05b478> - <@05b485>): free(p2);
	<.main+11652 @05b478>: 2a 60 79 05                load.m32 <@057960> ;p2
	<.main+11656 @05b47c>: 19                         load.z32
	<.main+11657 @05b47d>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11661 @05b481>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:19: (13 bytes: <@05b485> - <@05b492>): free(p3);
	<.main+11665 @05b485>: 2a 68 79 05                load.m32 <@057968> ;p3
	<.main+11669 @05b489>: 19                         load.z32
	<.main+11670 @05b48a>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11674 @05b48e>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:20: (13 bytes: <@05b492> - <@05b49f>): free(p4);
	<.main+11678 @05b492>: 2a 70 79 05                load.m32 <@057970> ;p4
	<.main+11682 @05b496>: 19                         load.z32
	<.main+11683 @05b497>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11687 @05b49b>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:26: (35 bytes: <@05b49f> - <@05b4c2>): debug(void("val1", val1));
	<.main+11691 @05b49f>: 1f 10 fe 03 00             load.ref <@03fe10> ;"test/std/memory.ci"
	<.main+11696 @05b4a4>: 1c 1a 00 00 00             load.c32 26
	<.main+11701 @05b4a9>: 1c 0e 00 00 00             load.c32 14
	<.main+11706 @05b4ae>: 19                         load.z32
	<.main+11707 @05b4af>: 1f 37 fe 03 00             load.ref <@03fe37> ;"val1"
	<.main+11712 @05b4b4>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11717 @05b4b9>: 1f 78 79 05 00             load.ref <@057978> ;val1
	<.main+11722 @05b4be>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:27: (35 bytes: <@05b4c2> - <@05b4e5>): debug(void("val2", val2));
	<.main+11726 @05b4c2>: 1f 10 fe 03 00             load.ref <@03fe10> ;"test/std/memory.ci"
	<.main+11731 @05b4c7>: 1c 1b 00 00 00             load.c32 27
	<.main+11736 @05b4cc>: 1c 0e 00 00 00             load.c32 14
	<.main+11741 @05b4d1>: 19                         load.z32
	<.main+11742 @05b4d2>: 1f 3c fe 03 00             load.ref <@03fe3c> ;"val2"
	<.main+11747 @05b4d7>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11752 @05b4dc>: 1f 80 79 05 00             load.ref <@057980> ;val2
	<.main+11757 @05b4e1>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:29: (22 bytes: <@05b4e5> - <@05b4fb>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+11761 @05b4e5>: 1f 80 79 05 00             load.ref <@057980> ;val2
	<.main+11766 @05b4ea>: 1f 78 79 05 00             load.ref <@057978> ;val1
	<.main+11771 @05b4ef>: 2a 90 04 00                load.m32 <@000490>
	<.main+11775 @05b4f3>: 01 0e 00 00                nfc(14) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+11779 @05b4f7>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:30: (18 bytes: <@05b4fb> - <@05b50d>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+11783 @05b4fb>: 1f 78 79 05 00             load.ref <@057978> ;val1
	<.main+11788 @05b500>: 19                         load.z32
	<.main+11789 @05b501>: 2a 90 04 00                load.m32 <@000490>
	<.main+11793 @05b505>: 01 0c 00 00                nfc(12) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11797 @05b509>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:32: (35 bytes: <@05b50d> - <@05b530>): debug(void("val1", val1));
	<.main+11801 @05b50d>: 1f 10 fe 03 00             load.ref <@03fe10> ;"test/std/memory.ci"
	<.main+11806 @05b512>: 1c 20 00 00 00             load.c32 32
	<.main+11811 @05b517>: 1c 0e 00 00 00             load.c32 14
	<.main+11816 @05b51c>: 19                         load.z32
	<.main+11817 @05b51d>: 1f 37 fe 03 00             load.ref <@03fe37> ;"val1"
	<.main+11822 @05b522>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11827 @05b527>: 1f 78 79 05 00             load.ref <@057978> ;val1
	<.main+11832 @05b52c>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:33: (35 bytes: <@05b530> - <@05b553>): debug(void("val2", val2));
	<.main+11836 @05b530>: 1f 10 fe 03 00             load.ref <@03fe10> ;"test/std/memory.ci"
	<.main+11841 @05b535>: 1c 21 00 00 00             load.c32 33
	<.main+11846 @05b53a>: 1c 0e 00 00 00             load.c32 14
	<.main+11851 @05b53f>: 19                         load.z32
	<.main+11852 @05b540>: 1f 3c fe 03 00             load.ref <@03fe3c> ;"val2"
	<.main+11857 @05b545>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11862 @05b54a>: 1f 80 79 05 00             load.ref <@057980> ;val2
	<.main+11867 @05b54f>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:54: (46 bytes: <@05b553> - <@05b581>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+11871 @05b553>: 19                         load.z32
	<.main+11872 @05b554>: 04 1d 00 00                jmp <.main+11901 @05b571>
	test/lang/array.ci:55: (21 bytes: <@05b558> - <@05b56d>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+11876 @05b558>: 1c 2a 00 00 00             load.c32 42
	<.main+11881 @05b55d>: 10 01                      dup.x32 sp(1)
	<.main+11883 @05b55f>: 51                         add.i32
	<.main+11884 @05b560>: 5b                         i32.2i64
	<.main+11885 @05b561>: 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+11890 @05b566>: 10 03                      dup.x32 sp(3)
	<.main+11892 @05b568>: 0d 08 00 00                mad.u32 8
	<.main+11896 @05b56c>: 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@05b56d> - <@05b571>): int32(i := int32(i + 1))
	<.main+11897 @05b56d>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@05b571> - <@05b57d>): bool(i < arrFixedNoInit.length)
	<.main+11901 @05b571>: 10 00                      dup.x32 sp(0)
	<.main+11903 @05b573>: 1c 07 00 00 00             load.c32 7
	<.main+11908 @05b578>: 58                         clt.i32
	<.main+11909 @05b579>: 05 df ff ff                jnz <.main+11876 @05b558>
	<.main+11913 @05b57d>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:82: (23 bytes: <@05b581> - <@05b598>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+11917 @05b581>: 1f d0 7a 05 00             load.ref <@057ad0> ;strFixed
	<.main+11922 @05b586>: 1f cc 0c 03 00             load.ref <@030ccc> ;"string"
	<.main+11927 @05b58b>: 1c 07 00 00 00             load.c32 7
	<.main+11932 @05b590>: 01 0d 00 00                nfc(13) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11936 @05b594>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (35 bytes: <@05b598> - <@05b5bb>): debug(void("string as variant", strFixed));
	<.main+11940 @05b598>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+11945 @05b59d>: 1c 53 00 00 00             load.c32 83
	<.main+11950 @05b5a2>: 1c 0e 00 00 00             load.c32 14
	<.main+11955 @05b5a7>: 19                         load.z32
	<.main+11956 @05b5a8>: 1f 63 1f 04 00             load.ref <@041f63> ;"string as variant"
	<.main+11961 @05b5ad>: 1f 70 2d 04 00             load.ref <@042d70>
	<.main+11966 @05b5b2>: 1f d0 7a 05 00             load.ref <@057ad0> ;strFixed
	<.main+11971 @05b5b7>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (35 bytes: <@05b5bb> - <@05b5de>): debug(void("string to variant", variant(strFixed)));
	<.main+11975 @05b5bb>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+11980 @05b5c0>: 1c 54 00 00 00             load.c32 84
	<.main+11985 @05b5c5>: 1c 0e 00 00 00             load.c32 14
	<.main+11990 @05b5ca>: 19                         load.z32
	<.main+11991 @05b5cb>: 1f 75 1f 04 00             load.ref <@041f75> ;"string to variant"
	<.main+11996 @05b5d0>: 1f 70 2d 04 00             load.ref <@042d70>
	<.main+12001 @05b5d5>: 1f d0 7a 05 00             load.ref <@057ad0> ;strFixed
	<.main+12006 @05b5da>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:87: (34 bytes: <@05b5de> - <@05b600>): debug(void("string as variant", strArray));
	<.main+12010 @05b5de>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12015 @05b5e3>: 1c 57 00 00 00             load.c32 87
	<.main+12020 @05b5e8>: 1c 0e 00 00 00             load.c32 14
	<.main+12025 @05b5ed>: 19                         load.z32
	<.main+12026 @05b5ee>: 1f 63 1f 04 00             load.ref <@041f63> ;"string as variant"
	<.main+12031 @05b5f3>: 1f 38 2f 04 00             load.ref <@042f38>
	<.main+12036 @05b5f8>: 2a d8 7a 05                load.m32 <@057ad8> ;strArray
	<.main+12040 @05b5fc>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (34 bytes: <@05b600> - <@05b622>): debug(void("string to variant", variant(strArray)));
	<.main+12044 @05b600>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12049 @05b605>: 1c 58 00 00 00             load.c32 88
	<.main+12054 @05b60a>: 1c 0e 00 00 00             load.c32 14
	<.main+12059 @05b60f>: 19                         load.z32
	<.main+12060 @05b610>: 1f 75 1f 04 00             load.ref <@041f75> ;"string to variant"
	<.main+12065 @05b615>: 1f 38 2f 04 00             load.ref <@042f38>
	<.main+12070 @05b61a>: 2a d8 7a 05                load.m32 <@057ad8> ;strArray
	<.main+12074 @05b61e>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:91: (34 bytes: <@05b622> - <@05b644>): debug(void("string as variant", strSlice));
	<.main+12078 @05b622>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12083 @05b627>: 1c 5b 00 00 00             load.c32 91
	<.main+12088 @05b62c>: 1c 0e 00 00 00             load.c32 14
	<.main+12093 @05b631>: 19                         load.z32
	<.main+12094 @05b632>: 1f 63 1f 04 00             load.ref <@041f63> ;"string as variant"
	<.main+12099 @05b637>: 1f 68 30 04 00             load.ref <@043068>
	<.main+12104 @05b63c>: 2a e0 7a 05                load.m32 <@057ae0> ;strSlice
	<.main+12108 @05b640>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (34 bytes: <@05b644> - <@05b666>): debug(void("string to variant", variant(strSlice)));
	<.main+12112 @05b644>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12117 @05b649>: 1c 5c 00 00 00             load.c32 92
	<.main+12122 @05b64e>: 1c 0e 00 00 00             load.c32 14
	<.main+12127 @05b653>: 19                         load.z32
	<.main+12128 @05b654>: 1f 75 1f 04 00             load.ref <@041f75> ;"string to variant"
	<.main+12133 @05b659>: 1f 68 30 04 00             load.ref <@043068>
	<.main+12138 @05b65e>: 2a e0 7a 05                load.m32 <@057ae0> ;strSlice
	<.main+12142 @05b662>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (53 bytes: <@05b666> - <@05b69b>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+12146 @05b666>: 2a 94 7a 05                load.m32 <@057a94> ;arrSliceNoInit+4
	<.main+12150 @05b66a>: 19                         load.z32
	<.main+12151 @05b66b>: 38                         clt.u32
	<.main+12152 @05b66c>: 05 08 00 00                jnz <.main+12160 @05b674>
	<.main+12156 @05b670>: 04 2b 00 00                jmp <.main+12199 @05b69b>
	<.main+12160 @05b674>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12165 @05b679>: 1c 62 00 00 00             load.c32 98
	<.main+12170 @05b67e>: 1c fe ff ff ff             load.c32 -2
	<.main+12175 @05b683>: 1c 80 00 00 00             load.c32 128
	<.main+12180 @05b688>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12185 @05b68d>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12190 @05b692>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12195 @05b697>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (53 bytes: <@05b69b> - <@05b6d0>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+12199 @05b69b>: 2a a4 7a 05                load.m32 <@057aa4> ;arrSliceInitNull+4
	<.main+12203 @05b69f>: 19                         load.z32
	<.main+12204 @05b6a0>: 57                         ceq.i32
	<.main+12205 @05b6a1>: 06 08 00 00                jz <.main+12213 @05b6a9>
	<.main+12209 @05b6a5>: 04 2b 00 00                jmp <.main+12252 @05b6d0>
	<.main+12213 @05b6a9>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12218 @05b6ae>: 1c 63 00 00 00             load.c32 99
	<.main+12223 @05b6b3>: 1c fe ff ff ff             load.c32 -2
	<.main+12228 @05b6b8>: 1c 80 00 00 00             load.c32 128
	<.main+12233 @05b6bd>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12238 @05b6c2>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12243 @05b6c7>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12248 @05b6cc>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (61 bytes: <@05b6d0> - <@05b70d>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+12252 @05b6d0>: 2b 50 7a 05                load.m64 <@057a50> ;arrFixedNoInit
	<.main+12256 @05b6d4>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12265 @05b6dd>: 67                         ceq.i64
	<.main+12266 @05b6de>: 06 08 00 00                jz <.main+12274 @05b6e6>
	<.main+12270 @05b6e2>: 04 2b 00 00                jmp <.main+12313 @05b70d>
	<.main+12274 @05b6e6>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12279 @05b6eb>: 1c 65 00 00 00             load.c32 101
	<.main+12284 @05b6f0>: 1c fe ff ff ff             load.c32 -2
	<.main+12289 @05b6f5>: 1c 80 00 00 00             load.c32 128
	<.main+12294 @05b6fa>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12299 @05b6ff>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12304 @05b704>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12309 @05b709>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@05b70d> - <@05b726>): assertEq(void(7, arrFixedNoInit.length));
	<.main+12313 @05b70d>: 1c 07 00 00 00             load.c32 7
	<.main+12318 @05b712>: 1c 07 00 00 00             load.c32 7
	<.main+12323 @05b717>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12328 @05b71c>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12333 @05b721>: 02                         call
	<.main+12334 @05b722>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (24 bytes: <@05b726> - <@05b73e>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+12338 @05b726>: 1c 07 00 00 00             load.c32 7
	<.main+12343 @05b72b>: 2a b4 7a 05                load.m32 <@057ab4> ;arrSliceInitFixed+4
	<.main+12347 @05b72f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12352 @05b734>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12357 @05b739>: 02                         call
	<.main+12358 @05b73a>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (24 bytes: <@05b73e> - <@05b756>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+12362 @05b73e>: 1c 07 00 00 00             load.c32 7
	<.main+12367 @05b743>: 2a c4 7a 05                load.m32 <@057ac4> ;arrSliceInitSlice+4
	<.main+12371 @05b747>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12376 @05b74c>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12381 @05b751>: 02                         call
	<.main+12382 @05b752>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@05b756> - <@05b776>): assertEq(void(0, lenSlice(null)));
	<.main+12386 @05b756>: 19                         load.z32
	<.main+12387 @05b757>: 1a                         load.z64
	<.main+12388 @05b758>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12393 @05b75d>: 1f e8 7a 05 00             load.ref <@057ae8> ;lenSlice(values: int64[]): int32
	<.main+12398 @05b762>: 02                         call
	<.main+12399 @05b763>: 09 f8 ff ff                inc.sp(-8)
	<.main+12403 @05b767>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12408 @05b76c>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12413 @05b771>: 02                         call
	<.main+12414 @05b772>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (31 bytes: <@05b776> - <@05b795>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+12418 @05b776>: 19                         load.z32
	<.main+12419 @05b777>: 19                         load.z32
	<.main+12420 @05b778>: 2b a0 7a 05                load.m64 <@057aa0> ;arrSliceInitNull
	<.main+12424 @05b77c>: 1f e8 7a 05 00             load.ref <@057ae8> ;lenSlice(values: int64[]): int32
	<.main+12429 @05b781>: 02                         call
	<.main+12430 @05b782>: 09 f8 ff ff                inc.sp(-8)
	<.main+12434 @05b786>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12439 @05b78b>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12444 @05b790>: 02                         call
	<.main+12445 @05b791>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (41 bytes: <@05b795> - <@05b7be>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+12449 @05b795>: 1c 07 00 00 00             load.c32 7
	<.main+12454 @05b79a>: 19                         load.z32
	<.main+12455 @05b79b>: 1c 07 00 00 00             load.c32 7
	<.main+12460 @05b7a0>: 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+12465 @05b7a5>: 1f e8 7a 05 00             load.ref <@057ae8> ;lenSlice(values: int64[]): int32
	<.main+12470 @05b7aa>: 02                         call
	<.main+12471 @05b7ab>: 09 f8 ff ff                inc.sp(-8)
	<.main+12475 @05b7af>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12480 @05b7b4>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12485 @05b7b9>: 02                         call
	<.main+12486 @05b7ba>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (35 bytes: <@05b7be> - <@05b7e1>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+12490 @05b7be>: 1c 07 00 00 00             load.c32 7
	<.main+12495 @05b7c3>: 19                         load.z32
	<.main+12496 @05b7c4>: 2b b0 7a 05                load.m64 <@057ab0> ;arrSliceInitFixed
	<.main+12500 @05b7c8>: 1f e8 7a 05 00             load.ref <@057ae8> ;lenSlice(values: int64[]): int32
	<.main+12505 @05b7cd>: 02                         call
	<.main+12506 @05b7ce>: 09 f8 ff ff                inc.sp(-8)
	<.main+12510 @05b7d2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12515 @05b7d7>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12520 @05b7dc>: 02                         call
	<.main+12521 @05b7dd>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (35 bytes: <@05b7e1> - <@05b804>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+12525 @05b7e1>: 1c 07 00 00 00             load.c32 7
	<.main+12530 @05b7e6>: 19                         load.z32
	<.main+12531 @05b7e7>: 2b c0 7a 05                load.m64 <@057ac0> ;arrSliceInitSlice
	<.main+12535 @05b7eb>: 1f e8 7a 05 00             load.ref <@057ae8> ;lenSlice(values: int64[]): int32
	<.main+12540 @05b7f0>: 02                         call
	<.main+12541 @05b7f1>: 09 f8 ff ff                inc.sp(-8)
	<.main+12545 @05b7f5>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12550 @05b7fa>: 1f 80 5c 05 00             load.ref <@055c80> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12555 @05b7ff>: 02                         call
	<.main+12556 @05b800>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (827 bytes: <@05b804> - <@05bb3f>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+12560 @05b804>: 19                         load.z32
	<.main+12561 @05b805>: 04 2a 03 00                jmp <.main+13371 @05bb2f>
	test/lang/array.ci:119: (9 bytes: <@05b809> - <@05b812>): expected: int64 := int32(42 + i)
	<.main+12565 @05b809>: 1c 2a 00 00 00             load.c32 42
	<.main+12570 @05b80e>: 10 01                      dup.x32 sp(1)
	<.main+12572 @05b810>: 51                         add.i32
	<.main+12573 @05b811>: 5b                         i32.2i64
	test/lang/array.ci:120: (62 bytes: <@05b812> - <@05b850>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+12574 @05b812>: 11 00                      dup.x64 sp(0)
	<.main+12576 @05b814>: 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+12581 @05b819>: 10 05                      dup.x32 sp(5)
	<.main+12583 @05b81b>: 0d 08 00 00                mad.u32 8
	<.main+12587 @05b81f>: 23                         load.i64
	<.main+12588 @05b820>: 67                         ceq.i64
	<.main+12589 @05b821>: 06 08 00 00                jz <.main+12597 @05b829>
	<.main+12593 @05b825>: 04 2b 00 00                jmp <.main+12636 @05b850>
	<.main+12597 @05b829>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12602 @05b82e>: 1c 78 00 00 00             load.c32 120
	<.main+12607 @05b833>: 1c fe ff ff ff             load.c32 -2
	<.main+12612 @05b838>: 1c 80 00 00 00             load.c32 128
	<.main+12617 @05b83d>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12622 @05b842>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12627 @05b847>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12632 @05b84c>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (61 bytes: <@05b850> - <@05b88d>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+12636 @05b850>: 11 00                      dup.x64 sp(0)
	<.main+12638 @05b852>: 2a a8 7a 05                load.m32 <@057aa8> ;arrArrayInitFixed
	<.main+12642 @05b856>: 10 05                      dup.x32 sp(5)
	<.main+12644 @05b858>: 0d 08 00 00                mad.u32 8
	<.main+12648 @05b85c>: 23                         load.i64
	<.main+12649 @05b85d>: 67                         ceq.i64
	<.main+12650 @05b85e>: 06 08 00 00                jz <.main+12658 @05b866>
	<.main+12654 @05b862>: 04 2b 00 00                jmp <.main+12697 @05b88d>
	<.main+12658 @05b866>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12663 @05b86b>: 1c 79 00 00 00             load.c32 121
	<.main+12668 @05b870>: 1c fe ff ff ff             load.c32 -2
	<.main+12673 @05b875>: 1c 80 00 00 00             load.c32 128
	<.main+12678 @05b87a>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12683 @05b87f>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12688 @05b884>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12693 @05b889>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (61 bytes: <@05b88d> - <@05b8ca>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+12697 @05b88d>: 11 00                      dup.x64 sp(0)
	<.main+12699 @05b88f>: 2a b0 7a 05                load.m32 <@057ab0> ;arrSliceInitFixed
	<.main+12703 @05b893>: 10 05                      dup.x32 sp(5)
	<.main+12705 @05b895>: 0d 08 00 00                mad.u32 8
	<.main+12709 @05b899>: 23                         load.i64
	<.main+12710 @05b89a>: 67                         ceq.i64
	<.main+12711 @05b89b>: 06 08 00 00                jz <.main+12719 @05b8a3>
	<.main+12715 @05b89f>: 04 2b 00 00                jmp <.main+12758 @05b8ca>
	<.main+12719 @05b8a3>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12724 @05b8a8>: 1c 7a 00 00 00             load.c32 122
	<.main+12729 @05b8ad>: 1c fe ff ff ff             load.c32 -2
	<.main+12734 @05b8b2>: 1c 80 00 00 00             load.c32 128
	<.main+12739 @05b8b7>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12744 @05b8bc>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12749 @05b8c1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12754 @05b8c6>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (68 bytes: <@05b8ca> - <@05b90e>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+12758 @05b8ca>: 11 00                      dup.x64 sp(0)
	<.main+12760 @05b8cc>: 1a                         load.z64
	<.main+12761 @05b8cd>: 10 06                      dup.x32 sp(6)
	<.main+12763 @05b8cf>: 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+12768 @05b8d4>: 1f f0 7a 05 00             load.ref <@057af0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12773 @05b8d9>: 02                         call
	<.main+12774 @05b8da>: 09 f8 ff ff                inc.sp(-8)
	<.main+12778 @05b8de>: 67                         ceq.i64
	<.main+12779 @05b8df>: 06 08 00 00                jz <.main+12787 @05b8e7>
	<.main+12783 @05b8e3>: 04 2b 00 00                jmp <.main+12826 @05b90e>
	<.main+12787 @05b8e7>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12792 @05b8ec>: 1c 7c 00 00 00             load.c32 124
	<.main+12797 @05b8f1>: 1c fe ff ff ff             load.c32 -2
	<.main+12802 @05b8f6>: 1c 80 00 00 00             load.c32 128
	<.main+12807 @05b8fb>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12812 @05b900>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12817 @05b905>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12822 @05b90a>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (67 bytes: <@05b90e> - <@05b951>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+12826 @05b90e>: 11 00                      dup.x64 sp(0)
	<.main+12828 @05b910>: 1a                         load.z64
	<.main+12829 @05b911>: 10 06                      dup.x32 sp(6)
	<.main+12831 @05b913>: 2a a8 7a 05                load.m32 <@057aa8> ;arrArrayInitFixed
	<.main+12835 @05b917>: 1f f0 7a 05 00             load.ref <@057af0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12840 @05b91c>: 02                         call
	<.main+12841 @05b91d>: 09 f8 ff ff                inc.sp(-8)
	<.main+12845 @05b921>: 67                         ceq.i64
	<.main+12846 @05b922>: 06 08 00 00                jz <.main+12854 @05b92a>
	<.main+12850 @05b926>: 04 2b 00 00                jmp <.main+12893 @05b951>
	<.main+12854 @05b92a>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12859 @05b92f>: 1c 7d 00 00 00             load.c32 125
	<.main+12864 @05b934>: 1c fe ff ff ff             load.c32 -2
	<.main+12869 @05b939>: 1c 80 00 00 00             load.c32 128
	<.main+12874 @05b93e>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12879 @05b943>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12884 @05b948>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12889 @05b94d>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (67 bytes: <@05b951> - <@05b994>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+12893 @05b951>: 11 00                      dup.x64 sp(0)
	<.main+12895 @05b953>: 1a                         load.z64
	<.main+12896 @05b954>: 10 06                      dup.x32 sp(6)
	<.main+12898 @05b956>: 2a b0 7a 05                load.m32 <@057ab0> ;arrSliceInitFixed
	<.main+12902 @05b95a>: 1f f0 7a 05 00             load.ref <@057af0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12907 @05b95f>: 02                         call
	<.main+12908 @05b960>: 09 f8 ff ff                inc.sp(-8)
	<.main+12912 @05b964>: 67                         ceq.i64
	<.main+12913 @05b965>: 06 08 00 00                jz <.main+12921 @05b96d>
	<.main+12917 @05b969>: 04 2b 00 00                jmp <.main+12960 @05b994>
	<.main+12921 @05b96d>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12926 @05b972>: 1c 7e 00 00 00             load.c32 126
	<.main+12931 @05b977>: 1c fe ff ff ff             load.c32 -2
	<.main+12936 @05b97c>: 1c 80 00 00 00             load.c32 128
	<.main+12941 @05b981>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+12946 @05b986>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12951 @05b98b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12956 @05b990>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (68 bytes: <@05b994> - <@05b9d8>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+12960 @05b994>: 11 00                      dup.x64 sp(0)
	<.main+12962 @05b996>: 1a                         load.z64
	<.main+12963 @05b997>: 10 06                      dup.x32 sp(6)
	<.main+12965 @05b999>: 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+12970 @05b99e>: 1f 00 7b 05 00             load.ref <@057b00> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+12975 @05b9a3>: 02                         call
	<.main+12976 @05b9a4>: 09 f8 ff ff                inc.sp(-8)
	<.main+12980 @05b9a8>: 67                         ceq.i64
	<.main+12981 @05b9a9>: 06 08 00 00                jz <.main+12989 @05b9b1>
	<.main+12985 @05b9ad>: 04 2b 00 00                jmp <.main+13028 @05b9d8>
	<.main+12989 @05b9b1>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+12994 @05b9b6>: 1c 80 00 00 00             load.c32 128
	<.main+12999 @05b9bb>: 1c fe ff ff ff             load.c32 -2
	<.main+13004 @05b9c0>: 1c 80 00 00 00             load.c32 128
	<.main+13009 @05b9c5>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+13014 @05b9ca>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13019 @05b9cf>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13024 @05b9d4>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (67 bytes: <@05b9d8> - <@05ba1b>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+13028 @05b9d8>: 11 00                      dup.x64 sp(0)
	<.main+13030 @05b9da>: 1a                         load.z64
	<.main+13031 @05b9db>: 10 06                      dup.x32 sp(6)
	<.main+13033 @05b9dd>: 2a a8 7a 05                load.m32 <@057aa8> ;arrArrayInitFixed
	<.main+13037 @05b9e1>: 1f 00 7b 05 00             load.ref <@057b00> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13042 @05b9e6>: 02                         call
	<.main+13043 @05b9e7>: 09 f8 ff ff                inc.sp(-8)
	<.main+13047 @05b9eb>: 67                         ceq.i64
	<.main+13048 @05b9ec>: 06 08 00 00                jz <.main+13056 @05b9f4>
	<.main+13052 @05b9f0>: 04 2b 00 00                jmp <.main+13095 @05ba1b>
	<.main+13056 @05b9f4>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+13061 @05b9f9>: 1c 81 00 00 00             load.c32 129
	<.main+13066 @05b9fe>: 1c fe ff ff ff             load.c32 -2
	<.main+13071 @05ba03>: 1c 80 00 00 00             load.c32 128
	<.main+13076 @05ba08>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+13081 @05ba0d>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13086 @05ba12>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13091 @05ba17>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (67 bytes: <@05ba1b> - <@05ba5e>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+13095 @05ba1b>: 11 00                      dup.x64 sp(0)
	<.main+13097 @05ba1d>: 1a                         load.z64
	<.main+13098 @05ba1e>: 10 06                      dup.x32 sp(6)
	<.main+13100 @05ba20>: 2a b0 7a 05                load.m32 <@057ab0> ;arrSliceInitFixed
	<.main+13104 @05ba24>: 1f 00 7b 05 00             load.ref <@057b00> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13109 @05ba29>: 02                         call
	<.main+13110 @05ba2a>: 09 f8 ff ff                inc.sp(-8)
	<.main+13114 @05ba2e>: 67                         ceq.i64
	<.main+13115 @05ba2f>: 06 08 00 00                jz <.main+13123 @05ba37>
	<.main+13119 @05ba33>: 04 2b 00 00                jmp <.main+13162 @05ba5e>
	<.main+13123 @05ba37>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+13128 @05ba3c>: 1c 82 00 00 00             load.c32 130
	<.main+13133 @05ba41>: 1c fe ff ff ff             load.c32 -2
	<.main+13138 @05ba46>: 1c 80 00 00 00             load.c32 128
	<.main+13143 @05ba4b>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+13148 @05ba50>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13153 @05ba55>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13158 @05ba5a>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (73 bytes: <@05ba5e> - <@05baa7>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+13162 @05ba5e>: 11 00                      dup.x64 sp(0)
	<.main+13164 @05ba60>: 1a                         load.z64
	<.main+13165 @05ba61>: 10 06                      dup.x32 sp(6)
	<.main+13167 @05ba63>: 1c 07 00 00 00             load.c32 7
	<.main+13172 @05ba68>: 1f 50 7a 05 00             load.ref <@057a50> ;arrFixedNoInit
	<.main+13177 @05ba6d>: 1f 10 7b 05 00             load.ref <@057b10> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13182 @05ba72>: 02                         call
	<.main+13183 @05ba73>: 09 f4 ff ff                inc.sp(-12)
	<.main+13187 @05ba77>: 67                         ceq.i64
	<.main+13188 @05ba78>: 06 08 00 00                jz <.main+13196 @05ba80>
	<.main+13192 @05ba7c>: 04 2b 00 00                jmp <.main+13235 @05baa7>
	<.main+13196 @05ba80>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+13201 @05ba85>: 1c 84 00 00 00             load.c32 132
	<.main+13206 @05ba8a>: 1c fe ff ff ff             load.c32 -2
	<.main+13211 @05ba8f>: 1c 80 00 00 00             load.c32 128
	<.main+13216 @05ba94>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+13221 @05ba99>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13226 @05ba9e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13231 @05baa3>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (67 bytes: <@05baa7> - <@05baea>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+13235 @05baa7>: 11 00                      dup.x64 sp(0)
	<.main+13237 @05baa9>: 1a                         load.z64
	<.main+13238 @05baaa>: 10 06                      dup.x32 sp(6)
	<.main+13240 @05baac>: 2b b0 7a 05                load.m64 <@057ab0> ;arrSliceInitFixed
	<.main+13244 @05bab0>: 1f 10 7b 05 00             load.ref <@057b10> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13249 @05bab5>: 02                         call
	<.main+13250 @05bab6>: 09 f4 ff ff                inc.sp(-12)
	<.main+13254 @05baba>: 67                         ceq.i64
	<.main+13255 @05babb>: 06 08 00 00                jz <.main+13263 @05bac3>
	<.main+13259 @05babf>: 04 2b 00 00                jmp <.main+13302 @05baea>
	<.main+13263 @05bac3>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+13268 @05bac8>: 1c 86 00 00 00             load.c32 134
	<.main+13273 @05bacd>: 1c fe ff ff ff             load.c32 -2
	<.main+13278 @05bad2>: 1c 80 00 00 00             load.c32 128
	<.main+13283 @05bad7>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+13288 @05badc>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13293 @05bae1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13298 @05bae6>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (61 bytes: <@05baea> - <@05bb27>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+13302 @05baea>: 11 00                      dup.x64 sp(0)
	<.main+13304 @05baec>: 2a c0 7a 05                load.m32 <@057ac0> ;arrSliceInitSlice
	<.main+13308 @05baf0>: 10 05                      dup.x32 sp(5)
	<.main+13310 @05baf2>: 0d 08 00 00                mad.u32 8
	<.main+13314 @05baf6>: 23                         load.i64
	<.main+13315 @05baf7>: 67                         ceq.i64
	<.main+13316 @05baf8>: 06 08 00 00                jz <.main+13324 @05bb00>
	<.main+13320 @05bafc>: 04 2b 00 00                jmp <.main+13363 @05bb27>
	<.main+13324 @05bb00>: 1f a0 1e 04 00             load.ref <@041ea0> ;"test/lang/array.ci"
	<.main+13329 @05bb05>: 1c 88 00 00 00             load.c32 136
	<.main+13334 @05bb0a>: 1c fe ff ff ff             load.c32 -2
	<.main+13339 @05bb0f>: 1c 80 00 00 00             load.c32 128
	<.main+13344 @05bb14>: 1f 94 d6 00 00             load.ref <@00d694> ;"assertion failed!"
	<.main+13349 @05bb19>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13354 @05bb1e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13359 @05bb23>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13363 @05bb27>: 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@05bb2b> - <@05bb2f>): int32(i := int32(i + 1))
	<.main+13367 @05bb2b>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@05bb2f> - <@05bb3b>): bool(i < arrFixedNoInit.length)
	<.main+13371 @05bb2f>: 10 00                      dup.x32 sp(0)
	<.main+13373 @05bb31>: 1c 07 00 00 00             load.c32 7
	<.main+13378 @05bb36>: 58                         clt.i32
	<.main+13379 @05bb37>: 05 d2 fc ff                jnz <.main+12565 @05b809>
	<.main+13383 @05bb3b>: 09 fc ff ff                inc.sp(-4)
	test/lang/method.ci:78: (21 bytes: <@05bb3f> - <@05bb54>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+13387 @05bb3f>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13391 @05bb43>: 1c 01 00 00 00             load.c32 1
	<.main+13396 @05bb48>: 13 04                      set.x32 sp(4)
	<.main+13398 @05bb4a>: 1f 70 7b 05 00             load.ref <@057b70> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13403 @05bb4f>: 02                         call
	<.main+13404 @05bb50>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:79: (20 bytes: <@05bb54> - <@05bb68>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+13408 @05bb54>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13412 @05bb58>: 1c 01 00 00 00             load.c32 1
	<.main+13417 @05bb5d>: 13 04                      set.x32 sp(4)
	<.main+13419 @05bb5f>: 2a 20 7c 05                load.m32 <@057c20> ;recordMethodTest+8
	<.main+13423 @05bb63>: 02                         call
	<.main+13424 @05bb64>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:97: (19 bytes: <@05bb68> - <@05bb7b>): staticMethod(void(recordMethodTest, 2));
	<.main+13428 @05bb68>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13432 @05bb6c>: 1c 02 00 00 00             load.c32 2
	<.main+13437 @05bb71>: 1f 28 7c 05 00             load.ref <@057c28> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13442 @05bb76>: 02                         call
	<.main+13443 @05bb77>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:98: (19 bytes: <@05bb7b> - <@05bb8e>): virtualMethod(void(recordMethodTest, 2));
	<.main+13447 @05bb7b>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13451 @05bb7f>: 1c 02 00 00 00             load.c32 2
	<.main+13456 @05bb84>: 1f 70 7c 05 00             load.ref <@057c70> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13461 @05bb89>: 02                         call
	<.main+13462 @05bb8a>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:101: (21 bytes: <@05bb8e> - <@05bba3>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+13466 @05bb8e>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13470 @05bb92>: 1c 03 00 00 00             load.c32 3
	<.main+13475 @05bb97>: 13 04                      set.x32 sp(4)
	<.main+13477 @05bb99>: 1f 70 7b 05 00             load.ref <@057b70> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13482 @05bb9e>: 02                         call
	<.main+13483 @05bb9f>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:102: (21 bytes: <@05bba3> - <@05bbb8>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13487 @05bba3>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13491 @05bba7>: 1c 03 00 00 00             load.c32 3
	<.main+13496 @05bbac>: 13 04                      set.x32 sp(4)
	<.main+13498 @05bbae>: 1f a0 7b 05 00             load.ref <@057ba0> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13503 @05bbb3>: 02                         call
	<.main+13504 @05bbb4>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:103: (20 bytes: <@05bbb8> - <@05bbcc>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13508 @05bbb8>: 2c 18 7c 05                load.m128 <@057c18> ;recordMethodTest
	<.main+13512 @05bbbc>: 1c 03 00 00 00             load.c32 3
	<.main+13517 @05bbc1>: 13 04                      set.x32 sp(4)
	<.main+13519 @05bbc3>: 2a 20 7c 05                load.m32 <@057c20> ;recordMethodTest+8
	<.main+13523 @05bbc7>: 02                         call
	<.main+13524 @05bbc8>: 09 f0 ff ff                inc.sp(-16)
	test/lang/statementIf.ci:4: (39 bytes: <@05bbcc> - <@05bbf3>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+13528 @05bbcc>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13533 @05bbd1>: 1c 04 00 00 00             load.c32 4
	<.main+13538 @05bbd6>: 1c 0e 00 00 00             load.c32 14
	<.main+13543 @05bbdb>: 1c 01 00 00 00             load.c32 1
	<.main+13548 @05bbe0>: 1f 09 24 05 00             load.ref <@052409> ;"0 == 0"
	<.main+13553 @05bbe5>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13558 @05bbea>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13563 @05bbef>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@05bbf3> - <@05bc1a>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+13567 @05bbf3>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13572 @05bbf8>: 1c 0c 00 00 00             load.c32 12
	<.main+13577 @05bbfd>: 1c 0e 00 00 00             load.c32 14
	<.main+13582 @05bc02>: 1c 03 00 00 00             load.c32 3
	<.main+13587 @05bc07>: 1f 09 24 05 00             load.ref <@052409> ;"0 == 0"
	<.main+13592 @05bc0c>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13597 @05bc11>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13602 @05bc16>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@05bc1a> - <@05bc41>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+13606 @05bc1a>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13611 @05bc1f>: 1c 16 00 00 00             load.c32 22
	<.main+13616 @05bc24>: 1c 0e 00 00 00             load.c32 14
	<.main+13621 @05bc29>: 1c 06 00 00 00             load.c32 6
	<.main+13626 @05bc2e>: 1f 09 24 05 00             load.ref <@052409> ;"0 == 0"
	<.main+13631 @05bc33>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13636 @05bc38>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13641 @05bc3d>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:28: (49 bytes: <@05bc41> - <@05bc72>): if (bool(t == 0))
	<.main+13645 @05bc41>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+13649 @05bc45>: 19                         load.z32
	<.main+13650 @05bc46>: 57                         ceq.i32
	<.main+13651 @05bc47>: 06 2b 00 00                jz <.main+13694 @05bc72>
	test/lang/statementIf.ci:29: (39 bytes: <@05bc4b> - <@05bc72>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+13655 @05bc4b>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13660 @05bc50>: 1c 1d 00 00 00             load.c32 29
	<.main+13665 @05bc55>: 1c 0e 00 00 00             load.c32 14
	<.main+13670 @05bc5a>: 1c 07 00 00 00             load.c32 7
	<.main+13675 @05bc5f>: 1f 17 24 05 00             load.ref <@052417> ;"t == 0"
	<.main+13680 @05bc64>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13685 @05bc69>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13690 @05bc6e>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (49 bytes: <@05bc72> - <@05bca3>): if (bool(t != 0))
	<.main+13694 @05bc72>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+13698 @05bc76>: 19                         load.z32
	<.main+13699 @05bc77>: 57                         ceq.i32
	<.main+13700 @05bc78>: 05 2b 00 00                jnz <.main+13743 @05bca3>
	test/lang/statementIf.ci:33: (39 bytes: <@05bc7c> - <@05bca3>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+13704 @05bc7c>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13709 @05bc81>: 1c 21 00 00 00             load.c32 33
	<.main+13714 @05bc86>: 1c 0e 00 00 00             load.c32 14
	<.main+13719 @05bc8b>: 1c 08 00 00 00             load.c32 8
	<.main+13724 @05bc90>: 1f 1e 24 05 00             load.ref <@05241e> ;"t != 0"
	<.main+13729 @05bc95>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13734 @05bc9a>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13739 @05bc9f>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (92 bytes: <@05bca3> - <@05bcff>): if (bool(t == 0))
	<.main+13743 @05bca3>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+13747 @05bca7>: 19                         load.z32
	<.main+13748 @05bca8>: 57                         ceq.i32
	<.main+13749 @05bca9>: 06 2f 00 00                jz <.main+13796 @05bcd8>
	test/lang/statementIf.ci:37: (39 bytes: <@05bcad> - <@05bcd4>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13753 @05bcad>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13758 @05bcb2>: 1c 25 00 00 00             load.c32 37
	<.main+13763 @05bcb7>: 1c 0e 00 00 00             load.c32 14
	<.main+13768 @05bcbc>: 1c 09 00 00 00             load.c32 9
	<.main+13773 @05bcc1>: 1f 17 24 05 00             load.ref <@052417> ;"t == 0"
	<.main+13778 @05bcc6>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13783 @05bccb>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13788 @05bcd0>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13792 @05bcd4>: 04 2b 00 00                jmp <.main+13835 @05bcff>
	test/lang/statementIf.ci:40: (39 bytes: <@05bcd8> - <@05bcff>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+13796 @05bcd8>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13801 @05bcdd>: 1c 28 00 00 00             load.c32 40
	<.main+13806 @05bce2>: 1c 0e 00 00 00             load.c32 14
	<.main+13811 @05bce7>: 1c 0a 00 00 00             load.c32 10
	<.main+13816 @05bcec>: 1f 1e 24 05 00             load.ref <@05241e> ;"t != 0"
	<.main+13821 @05bcf1>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13826 @05bcf6>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13831 @05bcfb>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (92 bytes: <@05bcff> - <@05bd5b>): if (bool(t != 0))
	<.main+13835 @05bcff>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+13839 @05bd03>: 19                         load.z32
	<.main+13840 @05bd04>: 57                         ceq.i32
	<.main+13841 @05bd05>: 05 2f 00 00                jnz <.main+13888 @05bd34>
	test/lang/statementIf.ci:44: (39 bytes: <@05bd09> - <@05bd30>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+13845 @05bd09>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13850 @05bd0e>: 1c 2c 00 00 00             load.c32 44
	<.main+13855 @05bd13>: 1c 0e 00 00 00             load.c32 14
	<.main+13860 @05bd18>: 1c 0b 00 00 00             load.c32 11
	<.main+13865 @05bd1d>: 1f 1e 24 05 00             load.ref <@05241e> ;"t != 0"
	<.main+13870 @05bd22>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13875 @05bd27>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13880 @05bd2c>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13884 @05bd30>: 04 2b 00 00                jmp <.main+13927 @05bd5b>
	test/lang/statementIf.ci:47: (39 bytes: <@05bd34> - <@05bd5b>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+13888 @05bd34>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13893 @05bd39>: 1c 2f 00 00 00             load.c32 47
	<.main+13898 @05bd3e>: 1c 0e 00 00 00             load.c32 14
	<.main+13903 @05bd43>: 1c 0c 00 00 00             load.c32 12
	<.main+13908 @05bd48>: 1f 17 24 05 00             load.ref <@052417> ;"t == 0"
	<.main+13913 @05bd4d>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13918 @05bd52>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13923 @05bd57>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (377 bytes: <@05bd5b> - <@05bed4>): if (bool(t == 0))
	<.main+13927 @05bd5b>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+13931 @05bd5f>: 19                         load.z32
	<.main+13932 @05bd60>: 57                         ceq.i32
	<.main+13933 @05bd61>: 06 2f 00 00                jz <.main+13980 @05bd90>
	test/lang/statementIf.ci:51: (39 bytes: <@05bd65> - <@05bd8c>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13937 @05bd65>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13942 @05bd6a>: 1c 33 00 00 00             load.c32 51
	<.main+13947 @05bd6f>: 1c 0e 00 00 00             load.c32 14
	<.main+13952 @05bd74>: 1c 09 00 00 00             load.c32 9
	<.main+13957 @05bd79>: 1f 17 24 05 00             load.ref <@052417> ;"t == 0"
	<.main+13962 @05bd7e>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13967 @05bd83>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+13972 @05bd88>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13976 @05bd8c>: 04 48 01 00                jmp <.main+14304 @05bed4>
	test/lang/statementIf.ci:53: (324 bytes: <@05bd90> - <@05bed4>): if (bool(t == 1))
	<.main+13980 @05bd90>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+13984 @05bd94>: 1c 01 00 00 00             load.c32 1
	<.main+13989 @05bd99>: 57                         ceq.i32
	<.main+13990 @05bd9a>: 06 2f 00 00                jz <.main+14037 @05bdc9>
	test/lang/statementIf.ci:54: (39 bytes: <@05bd9e> - <@05bdc5>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+13994 @05bd9e>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+13999 @05bda3>: 1c 36 00 00 00             load.c32 54
	<.main+14004 @05bda8>: 1c 0e 00 00 00             load.c32 14
	<.main+14009 @05bdad>: 1c 0a 00 00 00             load.c32 10
	<.main+14014 @05bdb2>: 1f 25 24 05 00             load.ref <@052425> ;"t == 1"
	<.main+14019 @05bdb7>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14024 @05bdbc>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+14029 @05bdc1>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14033 @05bdc5>: 04 0f 01 00                jmp <.main+14304 @05bed4>
	test/lang/statementIf.ci:56: (267 bytes: <@05bdc9> - <@05bed4>): if (bool(t == 2))
	<.main+14037 @05bdc9>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+14041 @05bdcd>: 1c 02 00 00 00             load.c32 2
	<.main+14046 @05bdd2>: 57                         ceq.i32
	<.main+14047 @05bdd3>: 06 2f 00 00                jz <.main+14094 @05be02>
	test/lang/statementIf.ci:57: (39 bytes: <@05bdd7> - <@05bdfe>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+14051 @05bdd7>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+14056 @05bddc>: 1c 39 00 00 00             load.c32 57
	<.main+14061 @05bde1>: 1c 0e 00 00 00             load.c32 14
	<.main+14066 @05bde6>: 1c 0a 00 00 00             load.c32 10
	<.main+14071 @05bdeb>: 1f 2c 24 05 00             load.ref <@05242c> ;"t == 2"
	<.main+14076 @05bdf0>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14081 @05bdf5>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+14086 @05bdfa>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14090 @05bdfe>: 04 d6 00 00                jmp <.main+14304 @05bed4>
	test/lang/statementIf.ci:59: (210 bytes: <@05be02> - <@05bed4>): if (bool(t == 3))
	<.main+14094 @05be02>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+14098 @05be06>: 1c 03 00 00 00             load.c32 3
	<.main+14103 @05be0b>: 57                         ceq.i32
	<.main+14104 @05be0c>: 06 2f 00 00                jz <.main+14151 @05be3b>
	test/lang/statementIf.ci:60: (39 bytes: <@05be10> - <@05be37>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+14108 @05be10>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+14113 @05be15>: 1c 3c 00 00 00             load.c32 60
	<.main+14118 @05be1a>: 1c 0e 00 00 00             load.c32 14
	<.main+14123 @05be1f>: 1c 0a 00 00 00             load.c32 10
	<.main+14128 @05be24>: 1f 33 24 05 00             load.ref <@052433> ;"t == 3"
	<.main+14133 @05be29>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14138 @05be2e>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+14143 @05be33>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14147 @05be37>: 04 9d 00 00                jmp <.main+14304 @05bed4>
	test/lang/statementIf.ci:62: (153 bytes: <@05be3b> - <@05bed4>): if (bool(t == 4))
	<.main+14151 @05be3b>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+14155 @05be3f>: 1c 04 00 00 00             load.c32 4
	<.main+14160 @05be44>: 57                         ceq.i32
	<.main+14161 @05be45>: 06 2f 00 00                jz <.main+14208 @05be74>
	test/lang/statementIf.ci:63: (39 bytes: <@05be49> - <@05be70>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+14165 @05be49>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+14170 @05be4e>: 1c 3f 00 00 00             load.c32 63
	<.main+14175 @05be53>: 1c 0e 00 00 00             load.c32 14
	<.main+14180 @05be58>: 1c 0a 00 00 00             load.c32 10
	<.main+14185 @05be5d>: 1f 3a 24 05 00             load.ref <@05243a> ;"t == 4"
	<.main+14190 @05be62>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14195 @05be67>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+14200 @05be6c>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14204 @05be70>: 04 64 00 00                jmp <.main+14304 @05bed4>
	test/lang/statementIf.ci:65: (96 bytes: <@05be74> - <@05bed4>): if (bool(t == 5))
	<.main+14208 @05be74>: 2a 90 84 05                load.m32 <@058490> ;t
	<.main+14212 @05be78>: 1c 05 00 00 00             load.c32 5
	<.main+14217 @05be7d>: 57                         ceq.i32
	<.main+14218 @05be7e>: 06 2f 00 00                jz <.main+14265 @05bead>
	test/lang/statementIf.ci:66: (39 bytes: <@05be82> - <@05bea9>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+14222 @05be82>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+14227 @05be87>: 1c 42 00 00 00             load.c32 66
	<.main+14232 @05be8c>: 1c 0e 00 00 00             load.c32 14
	<.main+14237 @05be91>: 1c 0a 00 00 00             load.c32 10
	<.main+14242 @05be96>: 1f 41 24 05 00             load.ref <@052441> ;"t == 5"
	<.main+14247 @05be9b>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14252 @05bea0>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+14257 @05bea5>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14261 @05bea9>: 04 2b 00 00                jmp <.main+14304 @05bed4>
	test/lang/statementIf.ci:69: (39 bytes: <@05bead> - <@05bed4>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+14265 @05bead>: 1f f0 23 05 00             load.ref <@0523f0> ;"test/lang/statementIf.ci"
	<.main+14270 @05beb2>: 1c 45 00 00 00             load.c32 69
	<.main+14275 @05beb7>: 1c 0e 00 00 00             load.c32 14
	<.main+14280 @05bebc>: 1c 0a 00 00 00             load.c32 10
	<.main+14285 @05bec1>: 1f 48 24 05 00             load.ref <@052448> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14290 @05bec6>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14295 @05becb>: 1f 90 84 05 00             load.ref <@058490> ;t
	<.main+14300 @05bed0>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@05bed4> - <@05bf03>): for ( ; ; )
	<.main+14304 @05bed4>: 04 2b 00 00                jmp <.main+14347 @05beff>
	test/lang/statementFor.ci:4: (35 bytes: <@05bed8> - <@05befb>): debug("for ( ; ; )");
	<.main+14308 @05bed8>: 1f 30 25 05 00             load.ref <@052530> ;"test/lang/statementFor.ci"
	<.main+14313 @05bedd>: 1c 04 00 00 00             load.c32 4
	<.main+14318 @05bee2>: 1c 0e 00 00 00             load.c32 14
	<.main+14323 @05bee7>: 19                         load.z32
	<.main+14324 @05bee8>: 1f 4a 25 05 00             load.ref <@05254a> ;"for ( ; ; )"
	<.main+14329 @05beed>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+14334 @05bef2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14339 @05bef7>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@05befb> - <@05beff>): break;
	<.main+14343 @05befb>: 04 08 00 00                jmp <.main+14351 @05bf03>
	:: (4 bytes: <@05beff> - <@05bf03>)
	<.main+14347 @05beff>: 04 d9 ff ff                jmp <.main+14308 @05bed8>
	test/lang/statementFor.ci:8: (59 bytes: <@05bf03> - <@05bf3e>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+14351 @05bf03>: 19                         load.z32
	<.main+14352 @05bf04>: 04 2a 00 00                jmp <.main+14394 @05bf2e>
	test/lang/statementFor.ci:9: (34 bytes: <@05bf08> - <@05bf2a>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+14356 @05bf08>: 1f 30 25 05 00             load.ref <@052530> ;"test/lang/statementFor.ci"
	<.main+14361 @05bf0d>: 1c 09 00 00 00             load.c32 9
	<.main+14366 @05bf12>: 1c 0e 00 00 00             load.c32 14
	<.main+14371 @05bf17>: 19                         load.z32
	<.main+14372 @05bf18>: 1f 56 25 05 00             load.ref <@052556> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14377 @05bf1d>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14382 @05bf22>: 0a 18 00 00                load.sp(+24)
	<.main+14386 @05bf26>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@05bf2a> - <@05bf2e>): int32(i := int32(i + 1))
	<.main+14390 @05bf2a>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@05bf2e> - <@05bf3a>): bool(i < 2)
	<.main+14394 @05bf2e>: 10 00                      dup.x32 sp(0)
	<.main+14396 @05bf30>: 1c 02 00 00 00             load.c32 2
	<.main+14401 @05bf35>: 58                         clt.i32
	<.main+14402 @05bf36>: 05 d2 ff ff                jnz <.main+14356 @05bf08>
	<.main+14406 @05bf3a>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:13: (70 bytes: <@05bf3e> - <@05bf84>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+14410 @05bf3e>: 19                         load.z32
	<.main+14411 @05bf3f>: 2e 98 84 05                store.m32 <@058498> ;forIdx
	<.main+14415 @05bf43>: 04 33 00 00                jmp <.main+14466 @05bf76>
	test/lang/statementFor.ci:14: (35 bytes: <@05bf47> - <@05bf6a>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+14419 @05bf47>: 1f 30 25 05 00             load.ref <@052530> ;"test/lang/statementFor.ci"
	<.main+14424 @05bf4c>: 1c 0e 00 00 00             load.c32 14
	<.main+14429 @05bf51>: 1c 0e 00 00 00             load.c32 14
	<.main+14434 @05bf56>: 19                         load.z32
	<.main+14435 @05bf57>: 1f 7c 25 05 00             load.ref <@05257c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14440 @05bf5c>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14445 @05bf61>: 1f 98 84 05 00             load.ref <@058498> ;forIdx
	<.main+14450 @05bf66>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (12 bytes: <@05bf6a> - <@05bf76>): int32(forIdx := int32(forIdx + 1))
	<.main+14454 @05bf6a>: 2a 98 84 05                load.m32 <@058498> ;forIdx
	<.main+14458 @05bf6e>: 0c 01 00 00                inc.i32(+1)
	<.main+14462 @05bf72>: 2e 98 84 05                store.m32 <@058498> ;forIdx
	test/lang/statementFor.ci:13: (14 bytes: <@05bf76> - <@05bf84>): bool(forIdx < 2)
	<.main+14466 @05bf76>: 2a 98 84 05                load.m32 <@058498> ;forIdx
	<.main+14470 @05bf7a>: 1c 02 00 00 00             load.c32 2
	<.main+14475 @05bf7f>: 58                         clt.i32
	<.main+14476 @05bf80>: 05 c7 ff ff                jnz <.main+14419 @05bf47>
	test/lang/statementFor.ci:17: (75 bytes: <@05bf84> - <@05bfcf>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14480 @05bf84>: 19                         load.z32
	<.main+14481 @05bf85>: 04 3a 00 00                jmp <.main+14539 @05bfbf>
	test/lang/statementFor.ci:18: (16 bytes: <@05bf89> - <@05bf99>): if (bool(i < 2))
	<.main+14485 @05bf89>: 10 00                      dup.x32 sp(0)
	<.main+14487 @05bf8b>: 1c 02 00 00 00             load.c32 2
	<.main+14492 @05bf90>: 58                         clt.i32
	<.main+14493 @05bf91>: 06 08 00 00                jz <.main+14501 @05bf99>
	test/lang/statementFor.ci:19: (4 bytes: <@05bf95> - <@05bf99>): continue;
	<.main+14497 @05bf95>: 04 26 00 00                jmp <.main+14535 @05bfbb>
	test/lang/statementFor.ci:21: (34 bytes: <@05bf99> - <@05bfbb>): debug(void("for with continue", i));
	<.main+14501 @05bf99>: 1f 30 25 05 00             load.ref <@052530> ;"test/lang/statementFor.ci"
	<.main+14506 @05bf9e>: 1c 15 00 00 00             load.c32 21
	<.main+14511 @05bfa3>: 1c 0e 00 00 00             load.c32 14
	<.main+14516 @05bfa8>: 19                         load.z32
	<.main+14517 @05bfa9>: 1f a6 25 05 00             load.ref <@0525a6> ;"for with continue"
	<.main+14522 @05bfae>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14527 @05bfb3>: 0a 18 00 00                load.sp(+24)
	<.main+14531 @05bfb7>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@05bfbb> - <@05bfbf>): int32(i := int32(i + 1))
	<.main+14535 @05bfbb>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@05bfbf> - <@05bfcb>): bool(i < 7)
	<.main+14539 @05bfbf>: 10 00                      dup.x32 sp(0)
	<.main+14541 @05bfc1>: 1c 07 00 00 00             load.c32 7
	<.main+14546 @05bfc6>: 58                         clt.i32
	<.main+14547 @05bfc7>: 05 c2 ff ff                jnz <.main+14485 @05bf89>
	<.main+14551 @05bfcb>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@05bfcf> - <@05c01a>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14555 @05bfcf>: 19                         load.z32
	<.main+14556 @05bfd0>: 04 3a 00 00                jmp <.main+14614 @05c00a>
	test/lang/statementFor.ci:25: (16 bytes: <@05bfd4> - <@05bfe4>): if (bool(i > 2))
	<.main+14560 @05bfd4>: 10 00                      dup.x32 sp(0)
	<.main+14562 @05bfd6>: 1c 02 00 00 00             load.c32 2
	<.main+14567 @05bfdb>: 59                         cgt.i32
	<.main+14568 @05bfdc>: 06 08 00 00                jz <.main+14576 @05bfe4>
	test/lang/statementFor.ci:26: (4 bytes: <@05bfe0> - <@05bfe4>): break;
	<.main+14572 @05bfe0>: 04 36 00 00                jmp <.main+14626 @05c016>
	test/lang/statementFor.ci:28: (34 bytes: <@05bfe4> - <@05c006>): debug(void("for with break", i));
	<.main+14576 @05bfe4>: 1f 30 25 05 00             load.ref <@052530> ;"test/lang/statementFor.ci"
	<.main+14581 @05bfe9>: 1c 1c 00 00 00             load.c32 28
	<.main+14586 @05bfee>: 1c 0e 00 00 00             load.c32 14
	<.main+14591 @05bff3>: 19                         load.z32
	<.main+14592 @05bff4>: 1f b8 25 05 00             load.ref <@0525b8> ;"for with break"
	<.main+14597 @05bff9>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14602 @05bffe>: 0a 18 00 00                load.sp(+24)
	<.main+14606 @05c002>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@05c006> - <@05c00a>): int32(i := int32(i + 1))
	<.main+14610 @05c006>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@05c00a> - <@05c016>): bool(i < 7)
	<.main+14614 @05c00a>: 10 00                      dup.x32 sp(0)
	<.main+14616 @05c00c>: 1c 07 00 00 00             load.c32 7
	<.main+14621 @05c011>: 58                         clt.i32
	<.main+14622 @05c012>: 05 c2 ff ff                jnz <.main+14560 @05bfd4>
	<.main+14626 @05c016>: 09 fc ff ff                inc.sp(-4)
	<.main+14630 @05c01a>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 446.77] > .main
[ 447.62]  > funAdd(x: int32, y: int32): int32
[ 447.67]  < return
[ 447.69]  > funAdd(x: int32, y: int32): int32
[ 447.71]  < return
[ 447.74]  > funMul(x: int32, y: int32): int32
[ 447.76]  < return
[ 447.78]  > funMul(x: int32, y: int32): int32
[ 447.80]  < return
[ 447.82]  > fib(n: uint32): uint32
[ 447.86]   > fib(n: uint32): uint32
[ 447.88]    > fib(n: uint32): uint32
[ 447.90]     > fib(n: uint32): uint32
[ 447.96]      > fib(n: uint32): uint32
[ 447.98]       > fib(n: uint32): uint32
[ 448.00]        > fib(n: uint32): uint32
[ 448.02]         > fib(n: uint32): uint32
[ 448.05]          > fib(n: uint32): uint32
[ 448.07]           > fib(n: uint32): uint32
[ 448.10]            > fib(n: uint32): uint32
[ 448.13]             > fib(n: uint32): uint32
[ 448.17]              > fib(n: uint32): uint32
[ 448.20]              < return
[ 448.21]              > fib(n: uint32): uint32
[ 448.23]              < return
[ 448.24]             < return
[ 448.25]             > fib(n: uint32): uint32
[ 448.27]             < return
[ 448.29]            < return
[ 448.29]            > fib(n: uint32): uint32
[ 448.33]             > fib(n: uint32): uint32
[ 448.35]             < return
[ 448.37]             > fib(n: uint32): uint32
[ 448.40]             < return
[ 448.42]            < return
[ 448.43]           < return
[ 448.45]           > fib(n: uint32): uint32
[ 448.48]            > fib(n: uint32): uint32
[ 448.50]             > fib(n: uint32): uint32
[ 448.52]             < return
[ 448.54]             > fib(n: uint32): uint32
[ 448.56]             < return
[ 448.57]            < return
[ 448.59]            > fib(n: uint32): uint32
[ 448.61]            < return
[ 448.63]           < return
[ 448.66]          < return
[ 448.67]          > fib(n: uint32): uint32
[ 448.69]           > fib(n: uint32): uint32
[ 448.71]            > fib(n: uint32): uint32
[ 448.73]             > fib(n: uint32): uint32
[ 448.75]             < return
[ 448.76]             > fib(n: uint32): uint32
[ 448.78]             < return
[ 448.79]            < return
[ 448.80]            > fib(n: uint32): uint32
[ 448.81]            < return
[ 448.84]           < return
[ 448.85]           > fib(n: uint32): uint32
[ 448.88]            > fib(n: uint32): uint32
[ 448.89]            < return
[ 448.90]            > fib(n: uint32): uint32
[ 448.92]            < return
[ 448.93]           < return
[ 448.94]          < return
[ 448.95]         < return
[ 448.96]         > fib(n: uint32): uint32
[ 448.97]          > fib(n: uint32): uint32
[ 448.99]           > fib(n: uint32): uint32
[ 449.01]            > fib(n: uint32): uint32
[ 449.05]             > fib(n: uint32): uint32
[ 449.08]             < return
[ 449.10]             > fib(n: uint32): uint32
[ 449.12]             < return
[ 449.15]            < return
[ 449.16]            > fib(n: uint32): uint32
[ 449.19]            < return
[ 449.20]           < return
[ 449.21]           > fib(n: uint32): uint32
[ 449.22]            > fib(n: uint32): uint32
[ 449.24]            < return
[ 449.25]            > fib(n: uint32): uint32
[ 449.26]            < return
[ 449.27]           < return
[ 449.28]          < return
[ 449.29]          > fib(n: uint32): uint32
[ 449.31]           > fib(n: uint32): uint32
[ 449.32]            > fib(n: uint32): uint32
[ 449.34]            < return
[ 449.35]            > fib(n: uint32): uint32
[ 449.37]            < return
[ 449.39]           < return
[ 449.40]           > fib(n: uint32): uint32
[ 449.42]           < return
[ 449.43]          < return
[ 449.44]         < return
[ 449.44]        < return
[ 449.47]        > fib(n: uint32): uint32
[ 449.49]         > fib(n: uint32): uint32
[ 449.52]          > fib(n: uint32): uint32
[ 449.53]           > fib(n: uint32): uint32
[ 449.56]            > fib(n: uint32): uint32
[ 449.58]             > fib(n: uint32): uint32
[ 449.59]             < return
[ 449.60]             > fib(n: uint32): uint32
[ 449.62]             < return
[ 449.62]            < return
[ 449.63]            > fib(n: uint32): uint32
[ 449.65]            < return
[ 449.66]           < return
[ 449.67]           > fib(n: uint32): uint32
[ 449.69]            > fib(n: uint32): uint32
[ 449.70]            < return
[ 449.71]            > fib(n: uint32): uint32
[ 449.73]            < return
[ 449.74]           < return
[ 449.74]          < return
[ 449.75]          > fib(n: uint32): uint32
[ 449.77]           > fib(n: uint32): uint32
[ 449.79]            > fib(n: uint32): uint32
[ 449.80]            < return
[ 449.81]            > fib(n: uint32): uint32
[ 449.83]            < return
[ 449.84]           < return
[ 449.85]           > fib(n: uint32): uint32
[ 449.86]           < return
[ 449.87]          < return
[ 449.88]         < return
[ 449.89]         > fib(n: uint32): uint32
[ 449.90]          > fib(n: uint32): uint32
[ 449.92]           > fib(n: uint32): uint32
[ 449.94]            > fib(n: uint32): uint32
[ 449.95]            < return
[ 449.96]            > fib(n: uint32): uint32
[ 450.00]            < return
[ 450.01]           < return
[ 450.02]           > fib(n: uint32): uint32
[ 450.05]           < return
[ 450.06]          < return
[ 450.07]          > fib(n: uint32): uint32
[ 450.08]           > fib(n: uint32): uint32
[ 450.10]           < return
[ 450.11]           > fib(n: uint32): uint32
[ 450.14]           < return
[ 450.15]          < return
[ 450.16]         < return
[ 450.17]        < return
[ 450.19]       < return
[ 450.20]       > fib(n: uint32): uint32
[ 450.24]        > fib(n: uint32): uint32
[ 450.25]         > fib(n: uint32): uint32
[ 450.28]          > fib(n: uint32): uint32
[ 450.30]           > fib(n: uint32): uint32
[ 450.32]            > fib(n: uint32): uint32
[ 450.33]             > fib(n: uint32): uint32
[ 450.35]             < return
[ 450.36]             > fib(n: uint32): uint32
[ 450.38]             < return
[ 450.39]            < return
[ 450.40]            > fib(n: uint32): uint32
[ 450.41]            < return
[ 450.43]           < return
[ 450.44]           > fib(n: uint32): uint32
[ 450.46]            > fib(n: uint32): uint32
[ 450.49]            < return
[ 450.50]            > fib(n: uint32): uint32
[ 450.52]            < return
[ 450.53]           < return
[ 450.54]          < return
[ 450.55]          > fib(n: uint32): uint32
[ 450.56]           > fib(n: uint32): uint32
[ 450.58]            > fib(n: uint32): uint32
[ 450.60]            < return
[ 450.61]            > fib(n: uint32): uint32
[ 450.62]            < return
[ 450.63]           < return
[ 450.64]           > fib(n: uint32): uint32
[ 450.66]           < return
[ 450.67]          < return
[ 450.68]         < return
[ 450.70]         > fib(n: uint32): uint32
[ 450.72]          > fib(n: uint32): uint32
[ 450.74]           > fib(n: uint32): uint32
[ 450.76]            > fib(n: uint32): uint32
[ 450.78]            < return
[ 450.80]            > fib(n: uint32): uint32
[ 450.82]            < return
[ 450.83]           < return
[ 450.85]           > fib(n: uint32): uint32
[ 450.87]           < return
[ 450.88]          < return
[ 450.89]          > fib(n: uint32): uint32
[ 450.93]           > fib(n: uint32): uint32
[ 450.96]           < return
[ 450.97]           > fib(n: uint32): uint32
[ 450.99]           < return
[ 451.01]          < return
[ 451.03]         < return
[ 451.04]        < return
[ 451.07]        > fib(n: uint32): uint32
[ 451.11]         > fib(n: uint32): uint32
[ 451.15]          > fib(n: uint32): uint32
[ 451.18]           > fib(n: uint32): uint32
[ 451.20]            > fib(n: uint32): uint32
[ 451.23]            < return
[ 451.24]            > fib(n: uint32): uint32
[ 451.26]            < return
[ 451.27]           < return
[ 451.28]           > fib(n: uint32): uint32
[ 451.29]           < return
[ 451.30]          < return
[ 451.31]          > fib(n: uint32): uint32
[ 451.36]           > fib(n: uint32): uint32
[ 451.38]           < return
[ 451.40]           > fib(n: uint32): uint32
[ 451.42]           < return
[ 451.43]          < return
[ 451.44]         < return
[ 451.44]         > fib(n: uint32): uint32
[ 451.48]          > fib(n: uint32): uint32
[ 451.49]           > fib(n: uint32): uint32
[ 451.52]           < return
[ 451.53]           > fib(n: uint32): uint32
[ 451.55]           < return
[ 451.57]          < return
[ 451.58]          > fib(n: uint32): uint32
[ 451.60]          < return
[ 451.61]         < return
[ 451.62]        < return
[ 451.62]       < return
[ 451.63]      < return
[ 451.64]      > fib(n: uint32): uint32
[ 451.66]       > fib(n: uint32): uint32
[ 451.68]        > fib(n: uint32): uint32
[ 451.69]         > fib(n: uint32): uint32
[ 451.71]          > fib(n: uint32): uint32
[ 451.73]           > fib(n: uint32): uint32
[ 451.75]            > fib(n: uint32): uint32
[ 451.77]             > fib(n: uint32): uint32
[ 451.78]             < return
[ 451.79]             > fib(n: uint32): uint32
[ 451.81]             < return
[ 451.82]            < return
[ 451.85]            > fib(n: uint32): uint32
[ 451.87]            < return
[ 451.88]           < return
[ 451.89]           > fib(n: uint32): uint32
[ 451.91]            > fib(n: uint32): uint32
[ 451.93]            < return
[ 451.94]            > fib(n: uint32): uint32
[ 451.95]            < return
[ 451.96]           < return
[ 451.97]          < return
[ 451.99]          > fib(n: uint32): uint32
[ 452.01]           > fib(n: uint32): uint32
[ 452.04]            > fib(n: uint32): uint32
[ 452.06]            < return
[ 452.08]            > fib(n: uint32): uint32
[ 452.10]            < return
[ 452.11]           < return
[ 452.13]           > fib(n: uint32): uint32
[ 452.15]           < return
[ 452.16]          < return
[ 452.17]         < return
[ 452.19]         > fib(n: uint32): uint32
[ 452.21]          > fib(n: uint32): uint32
[ 452.23]           > fib(n: uint32): uint32
[ 452.25]            > fib(n: uint32): uint32
[ 452.29]            < return
[ 452.30]            > fib(n: uint32): uint32
[ 452.31]            < return
[ 452.32]           < return
[ 452.33]           > fib(n: uint32): uint32
[ 452.36]           < return
[ 452.38]          < return
[ 452.39]          > fib(n: uint32): uint32
[ 452.40]           > fib(n: uint32): uint32
[ 452.42]           < return
[ 452.43]           > fib(n: uint32): uint32
[ 452.44]           < return
[ 452.45]          < return
[ 452.46]         < return
[ 452.47]        < return
[ 452.48]        > fib(n: uint32): uint32
[ 452.50]         > fib(n: uint32): uint32
[ 452.55]          > fib(n: uint32): uint32
[ 452.56]           > fib(n: uint32): uint32
[ 452.58]            > fib(n: uint32): uint32
[ 452.59]            < return
[ 452.61]            > fib(n: uint32): uint32
[ 452.62]            < return
[ 452.63]           < return
[ 452.67]           > fib(n: uint32): uint32
[ 452.68]           < return
[ 452.70]          < return
[ 452.71]          > fib(n: uint32): uint32
[ 452.73]           > fib(n: uint32): uint32
[ 452.75]           < return
[ 452.76]           > fib(n: uint32): uint32
[ 452.77]           < return
[ 452.78]          < return
[ 452.79]         < return
[ 452.80]         > fib(n: uint32): uint32
[ 452.82]          > fib(n: uint32): uint32
[ 452.84]           > fib(n: uint32): uint32
[ 452.86]           < return
[ 452.89]           > fib(n: uint32): uint32
[ 452.92]           < return
[ 452.94]          < return
[ 452.95]          > fib(n: uint32): uint32
[ 452.97]          < return
[ 452.99]         < return
[ 453.00]        < return
[ 453.01]       < return
[ 453.03]       > fib(n: uint32): uint32
[ 453.05]        > fib(n: uint32): uint32
[ 453.07]         > fib(n: uint32): uint32
[ 453.10]          > fib(n: uint32): uint32
[ 453.12]           > fib(n: uint32): uint32
[ 453.14]            > fib(n: uint32): uint32
[ 453.16]            < return
[ 453.17]            > fib(n: uint32): uint32
[ 453.19]            < return
[ 453.19]           < return
[ 453.21]           > fib(n: uint32): uint32
[ 453.23]           < return
[ 453.24]          < return
[ 453.25]          > fib(n: uint32): uint32
[ 453.26]           > fib(n: uint32): uint32
[ 453.28]           < return
[ 453.29]           > fib(n: uint32): uint32
[ 453.30]           < return
[ 453.31]          < return
[ 453.35]         < return
[ 453.36]         > fib(n: uint32): uint32
[ 453.38]          > fib(n: uint32): uint32
[ 453.40]           > fib(n: uint32): uint32
[ 453.42]           < return
[ 453.43]           > fib(n: uint32): uint32
[ 453.44]           < return
[ 453.45]          < return
[ 453.46]          > fib(n: uint32): uint32
[ 453.48]          < return
[ 453.49]         < return
[ 453.50]        < return
[ 453.51]        > fib(n: uint32): uint32
[ 453.53]         > fib(n: uint32): uint32
[ 453.55]          > fib(n: uint32): uint32
[ 453.57]           > fib(n: uint32): uint32
[ 453.59]           < return
[ 453.60]           > fib(n: uint32): uint32
[ 453.62]           < return
[ 453.65]          < return
[ 453.68]          > fib(n: uint32): uint32
[ 453.69]          < return
[ 453.70]         < return
[ 453.71]         > fib(n: uint32): uint32
[ 453.73]          > fib(n: uint32): uint32
[ 453.74]          < return
[ 453.75]          > fib(n: uint32): uint32
[ 453.76]          < return
[ 453.77]         < return
[ 453.78]        < return
[ 453.79]       < return
[ 453.80]      < return
[ 453.83]     < return
[ 453.86]     > fib(n: uint32): uint32
[ 453.89]      > fib(n: uint32): uint32
[ 453.92]       > fib(n: uint32): uint32
[ 453.94]        > fib(n: uint32): uint32
[ 453.95]         > fib(n: uint32): uint32
[ 453.97]          > fib(n: uint32): uint32
[ 453.99]           > fib(n: uint32): uint32
[ 454.00]            > fib(n: uint32): uint32
[ 454.02]             > fib(n: uint32): uint32
[ 454.03]             < return
[ 454.04]             > fib(n: uint32): uint32
[ 454.06]             < return
[ 454.07]            < return
[ 454.09]            > fib(n: uint32): uint32
[ 454.11]            < return
[ 454.12]           < return
[ 454.13]           > fib(n: uint32): uint32
[ 454.16]            > fib(n: uint32): uint32
[ 454.17]            < return
[ 454.20]            > fib(n: uint32): uint32
[ 454.23]            < return
[ 454.24]           < return
[ 454.25]          < return
[ 454.26]          > fib(n: uint32): uint32
[ 454.27]           > fib(n: uint32): uint32
[ 454.29]            > fib(n: uint32): uint32
[ 454.32]            < return
[ 454.35]            > fib(n: uint32): uint32
[ 454.38]            < return
[ 454.39]           < return
[ 454.40]           > fib(n: uint32): uint32
[ 454.41]           < return
[ 454.42]          < return
[ 454.43]         < return
[ 454.44]         > fib(n: uint32): uint32
[ 454.47]          > fib(n: uint32): uint32
[ 454.49]           > fib(n: uint32): uint32
[ 454.51]            > fib(n: uint32): uint32
[ 454.52]            < return
[ 454.54]            > fib(n: uint32): uint32
[ 454.55]            < return
[ 454.56]           < return
[ 454.57]           > fib(n: uint32): uint32
[ 454.61]           < return
[ 454.62]          < return
[ 454.63]          > fib(n: uint32): uint32
[ 454.66]           > fib(n: uint32): uint32
[ 454.68]           < return
[ 454.69]           > fib(n: uint32): uint32
[ 454.73]           < return
[ 454.74]          < return
[ 454.75]         < return
[ 454.76]        < return
[ 454.77]        > fib(n: uint32): uint32
[ 454.79]         > fib(n: uint32): uint32
[ 454.82]          > fib(n: uint32): uint32
[ 454.86]           > fib(n: uint32): uint32
[ 454.88]            > fib(n: uint32): uint32
[ 454.90]            < return
[ 454.92]            > fib(n: uint32): uint32
[ 454.94]            < return
[ 454.95]           < return
[ 454.96]           > fib(n: uint32): uint32
[ 454.99]           < return
[ 455.00]          < return
[ 455.01]          > fib(n: uint32): uint32
[ 455.04]           > fib(n: uint32): uint32
[ 455.06]           < return
[ 455.07]           > fib(n: uint32): uint32
[ 455.09]           < return
[ 455.10]          < return
[ 455.11]         < return
[ 455.12]         > fib(n: uint32): uint32
[ 455.14]          > fib(n: uint32): uint32
[ 455.15]           > fib(n: uint32): uint32
[ 455.17]           < return
[ 455.18]           > fib(n: uint32): uint32
[ 455.19]           < return
[ 455.21]          < return
[ 455.22]          > fib(n: uint32): uint32
[ 455.23]          < return
[ 455.24]         < return
[ 455.25]        < return
[ 455.26]       < return
[ 455.27]       > fib(n: uint32): uint32
[ 455.28]        > fib(n: uint32): uint32
[ 455.30]         > fib(n: uint32): uint32
[ 455.33]          > fib(n: uint32): uint32
[ 455.38]           > fib(n: uint32): uint32
[ 455.41]            > fib(n: uint32): uint32
[ 455.44]            < return
[ 455.45]            > fib(n: uint32): uint32
[ 455.47]            < return
[ 455.48]           < return
[ 455.50]           > fib(n: uint32): uint32
[ 455.53]           < return
[ 455.54]          < return
[ 455.55]          > fib(n: uint32): uint32
[ 455.58]           > fib(n: uint32): uint32
[ 455.62]           < return
[ 455.64]           > fib(n: uint32): uint32
[ 455.65]           < return
[ 455.67]          < return
[ 455.67]         < return
[ 455.68]         > fib(n: uint32): uint32
[ 455.70]          > fib(n: uint32): uint32
[ 455.72]           > fib(n: uint32): uint32
[ 455.73]           < return
[ 455.76]           > fib(n: uint32): uint32
[ 455.78]           < return
[ 455.79]          < return
[ 455.80]          > fib(n: uint32): uint32
[ 455.81]          < return
[ 455.82]         < return
[ 455.84]        < return
[ 455.87]        > fib(n: uint32): uint32
[ 455.89]         > fib(n: uint32): uint32
[ 455.91]          > fib(n: uint32): uint32
[ 455.94]           > fib(n: uint32): uint32
[ 455.96]           < return
[ 455.97]           > fib(n: uint32): uint32
[ 455.99]           < return
[ 456.01]          < return
[ 456.02]          > fib(n: uint32): uint32
[ 456.04]          < return
[ 456.06]         < return
[ 456.07]         > fib(n: uint32): uint32
[ 456.12]          > fib(n: uint32): uint32
[ 456.14]          < return
[ 456.15]          > fib(n: uint32): uint32
[ 456.20]          < return
[ 456.22]         < return
[ 456.23]        < return
[ 456.26]       < return
[ 456.28]      < return
[ 456.31]      > fib(n: uint32): uint32
[ 456.33]       > fib(n: uint32): uint32
[ 456.35]        > fib(n: uint32): uint32
[ 456.37]         > fib(n: uint32): uint32
[ 456.38]          > fib(n: uint32): uint32
[ 456.43]           > fib(n: uint32): uint32
[ 456.46]            > fib(n: uint32): uint32
[ 456.48]            < return
[ 456.49]            > fib(n: uint32): uint32
[ 456.50]            < return
[ 456.51]           < return
[ 456.52]           > fib(n: uint32): uint32
[ 456.55]           < return
[ 456.56]          < return
[ 456.57]          > fib(n: uint32): uint32
[ 456.59]           > fib(n: uint32): uint32
[ 456.60]           < return
[ 456.61]           > fib(n: uint32): uint32
[ 456.65]           < return
[ 456.67]          < return
[ 456.68]         < return
[ 456.69]         > fib(n: uint32): uint32
[ 456.71]          > fib(n: uint32): uint32
[ 456.73]           > fib(n: uint32): uint32
[ 456.77]           < return
[ 456.80]           > fib(n: uint32): uint32
[ 456.81]           < return
[ 456.83]          < return
[ 456.84]          > fib(n: uint32): uint32
[ 456.86]          < return
[ 456.87]         < return
[ 456.88]        < return
[ 456.90]        > fib(n: uint32): uint32
[ 456.92]         > fib(n: uint32): uint32
[ 456.94]          > fib(n: uint32): uint32
[ 456.96]           > fib(n: uint32): uint32
[ 456.98]           < return
[ 456.99]           > fib(n: uint32): uint32
[ 457.01]           < return
[ 457.02]          < return
[ 457.03]          > fib(n: uint32): uint32
[ 457.05]          < return
[ 457.06]         < return
[ 457.07]         > fib(n: uint32): uint32
[ 457.08]          > fib(n: uint32): uint32
[ 457.10]          < return
[ 457.11]          > fib(n: uint32): uint32
[ 457.12]          < return
[ 457.13]         < return
[ 457.14]        < return
[ 457.16]       < return
[ 457.17]       > fib(n: uint32): uint32
[ 457.19]        > fib(n: uint32): uint32
[ 457.20]         > fib(n: uint32): uint32
[ 457.22]          > fib(n: uint32): uint32
[ 457.24]           > fib(n: uint32): uint32
[ 457.25]           < return
[ 457.26]           > fib(n: uint32): uint32
[ 457.28]           < return
[ 457.29]          < return
[ 457.30]          > fib(n: uint32): uint32
[ 457.31]          < return
[ 457.32]         < return
[ 457.33]         > fib(n: uint32): uint32
[ 457.35]          > fib(n: uint32): uint32
[ 457.37]          < return
[ 457.38]          > fib(n: uint32): uint32
[ 457.39]          < return
[ 457.40]         < return
[ 457.43]        < return
[ 457.44]        > fib(n: uint32): uint32
[ 457.48]         > fib(n: uint32): uint32
[ 457.50]          > fib(n: uint32): uint32
[ 457.55]          < return
[ 457.56]          > fib(n: uint32): uint32
[ 457.57]          < return
[ 457.58]         < return
[ 457.59]         > fib(n: uint32): uint32
[ 457.61]         < return
[ 457.62]        < return
[ 457.64]       < return
[ 457.65]      < return
[ 457.66]     < return
[ 457.67]    < return
[ 457.69]    > fib(n: uint32): uint32
[ 457.71]     > fib(n: uint32): uint32
[ 457.73]      > fib(n: uint32): uint32
[ 457.76]       > fib(n: uint32): uint32
[ 457.78]        > fib(n: uint32): uint32
[ 457.80]         > fib(n: uint32): uint32
[ 457.82]          > fib(n: uint32): uint32
[ 457.85]           > fib(n: uint32): uint32
[ 457.89]            > fib(n: uint32): uint32
[ 457.93]             > fib(n: uint32): uint32
[ 457.94]             < return
[ 457.96]             > fib(n: uint32): uint32
[ 457.97]             < return
[ 457.98]            < return
[ 457.99]            > fib(n: uint32): uint32
[ 458.02]            < return
[ 458.03]           < return
[ 458.04]           > fib(n: uint32): uint32
[ 458.06]            > fib(n: uint32): uint32
[ 458.07]            < return
[ 458.08]            > fib(n: uint32): uint32
[ 458.11]            < return
[ 458.14]           < return
[ 458.14]          < return
[ 458.15]          > fib(n: uint32): uint32
[ 458.20]           > fib(n: uint32): uint32
[ 458.22]            > fib(n: uint32): uint32
[ 458.25]            < return
[ 458.26]            > fib(n: uint32): uint32
[ 458.27]            < return
[ 458.28]           < return
[ 458.29]           > fib(n: uint32): uint32
[ 458.32]           < return
[ 458.35]          < return
[ 458.35]         < return
[ 458.38]         > fib(n: uint32): uint32
[ 458.39]          > fib(n: uint32): uint32
[ 458.43]           > fib(n: uint32): uint32
[ 458.46]            > fib(n: uint32): uint32
[ 458.47]            < return
[ 458.48]            > fib(n: uint32): uint32
[ 458.50]            < return
[ 458.52]           < return
[ 458.55]           > fib(n: uint32): uint32
[ 458.58]           < return
[ 458.60]          < return
[ 458.61]          > fib(n: uint32): uint32
[ 458.64]           > fib(n: uint32): uint32
[ 458.67]           < return
[ 458.70]           > fib(n: uint32): uint32
[ 458.71]           < return
[ 458.72]          < return
[ 458.73]         < return
[ 458.74]        < return
[ 458.75]        > fib(n: uint32): uint32
[ 458.77]         > fib(n: uint32): uint32
[ 458.79]          > fib(n: uint32): uint32
[ 458.80]           > fib(n: uint32): uint32
[ 458.82]            > fib(n: uint32): uint32
[ 458.84]            < return
[ 458.85]            > fib(n: uint32): uint32
[ 458.86]            < return
[ 458.87]           < return
[ 458.90]           > fib(n: uint32): uint32
[ 458.91]           < return
[ 458.94]          < return
[ 458.96]          > fib(n: uint32): uint32
[ 458.98]           > fib(n: uint32): uint32
[ 459.00]           < return
[ 459.01]           > fib(n: uint32): uint32
[ 459.04]           < return
[ 459.05]          < return
[ 459.06]         < return
[ 459.08]         > fib(n: uint32): uint32
[ 459.10]          > fib(n: uint32): uint32
[ 459.12]           > fib(n: uint32): uint32
[ 459.13]           < return
[ 459.14]           > fib(n: uint32): uint32
[ 459.16]           < return
[ 459.17]          < return
[ 459.18]          > fib(n: uint32): uint32
[ 459.20]          < return
[ 459.21]         < return
[ 459.21]        < return
[ 459.22]       < return
[ 459.23]       > fib(n: uint32): uint32
[ 459.27]        > fib(n: uint32): uint32
[ 459.33]         > fib(n: uint32): uint32
[ 459.34]          > fib(n: uint32): uint32
[ 459.36]           > fib(n: uint32): uint32
[ 459.38]            > fib(n: uint32): uint32
[ 459.40]            < return
[ 459.41]            > fib(n: uint32): uint32
[ 459.42]            < return
[ 459.43]           < return
[ 459.44]           > fib(n: uint32): uint32
[ 459.46]           < return
[ 459.47]          < return
[ 459.48]          > fib(n: uint32): uint32
[ 459.51]           > fib(n: uint32): uint32
[ 459.52]           < return
[ 459.53]           > fib(n: uint32): uint32
[ 459.55]           < return
[ 459.56]          < return
[ 459.57]         < return
[ 459.58]         > fib(n: uint32): uint32
[ 459.60]          > fib(n: uint32): uint32
[ 459.61]           > fib(n: uint32): uint32
[ 459.63]           < return
[ 459.65]           > fib(n: uint32): uint32
[ 459.67]           < return
[ 459.69]          < return
[ 459.72]          > fib(n: uint32): uint32
[ 459.75]          < return
[ 459.76]         < return
[ 459.76]        < return
[ 459.77]        > fib(n: uint32): uint32
[ 459.79]         > fib(n: uint32): uint32
[ 459.81]          > fib(n: uint32): uint32
[ 459.84]           > fib(n: uint32): uint32
[ 459.86]           < return
[ 459.88]           > fib(n: uint32): uint32
[ 459.90]           < return
[ 459.91]          < return
[ 459.93]          > fib(n: uint32): uint32
[ 459.96]          < return
[ 459.97]         < return
[ 459.99]         > fib(n: uint32): uint32
[ 460.01]          > fib(n: uint32): uint32
[ 460.03]          < return
[ 460.05]          > fib(n: uint32): uint32
[ 460.07]          < return
[ 460.08]         < return
[ 460.09]        < return
[ 460.10]       < return
[ 460.13]      < return
[ 460.14]      > fib(n: uint32): uint32
[ 460.18]       > fib(n: uint32): uint32
[ 460.20]        > fib(n: uint32): uint32
[ 460.22]         > fib(n: uint32): uint32
[ 460.24]          > fib(n: uint32): uint32
[ 460.28]           > fib(n: uint32): uint32
[ 460.30]            > fib(n: uint32): uint32
[ 460.31]            < return
[ 460.33]            > fib(n: uint32): uint32
[ 460.34]            < return
[ 460.36]           < return
[ 460.37]           > fib(n: uint32): uint32
[ 460.39]           < return
[ 460.40]          < return
[ 460.41]          > fib(n: uint32): uint32
[ 460.42]           > fib(n: uint32): uint32
[ 460.44]           < return
[ 460.45]           > fib(n: uint32): uint32
[ 460.48]           < return
[ 460.49]          < return
[ 460.50]         < return
[ 460.52]         > fib(n: uint32): uint32
[ 460.56]          > fib(n: uint32): uint32
[ 460.57]           > fib(n: uint32): uint32
[ 460.62]           < return
[ 460.63]           > fib(n: uint32): uint32
[ 460.64]           < return
[ 460.65]          < return
[ 460.66]          > fib(n: uint32): uint32
[ 460.68]          < return
[ 460.69]         < return
[ 460.70]        < return
[ 460.71]        > fib(n: uint32): uint32
[ 460.73]         > fib(n: uint32): uint32
[ 460.75]          > fib(n: uint32): uint32
[ 460.77]           > fib(n: uint32): uint32
[ 460.78]           < return
[ 460.79]           > fib(n: uint32): uint32
[ 460.82]           < return
[ 460.83]          < return
[ 460.84]          > fib(n: uint32): uint32
[ 460.86]          < return
[ 460.86]         < return
[ 460.87]         > fib(n: uint32): uint32
[ 460.89]          > fib(n: uint32): uint32
[ 460.91]          < return
[ 460.92]          > fib(n: uint32): uint32
[ 460.93]          < return
[ 460.94]         < return
[ 460.95]        < return
[ 460.96]       < return
[ 460.97]       > fib(n: uint32): uint32
[ 460.99]        > fib(n: uint32): uint32
[ 461.02]         > fib(n: uint32): uint32
[ 461.03]          > fib(n: uint32): uint32
[ 461.06]           > fib(n: uint32): uint32
[ 461.08]           < return
[ 461.10]           > fib(n: uint32): uint32
[ 461.11]           < return
[ 461.12]          < return
[ 461.13]          > fib(n: uint32): uint32
[ 461.15]          < return
[ 461.16]         < return
[ 461.17]         > fib(n: uint32): uint32
[ 461.19]          > fib(n: uint32): uint32
[ 461.20]          < return
[ 461.23]          > fib(n: uint32): uint32
[ 461.24]          < return
[ 461.25]         < return
[ 461.28]        < return
[ 461.29]        > fib(n: uint32): uint32
[ 461.31]         > fib(n: uint32): uint32
[ 461.32]          > fib(n: uint32): uint32
[ 461.34]          < return
[ 461.37]          > fib(n: uint32): uint32
[ 461.38]          < return
[ 461.41]         < return
[ 461.42]         > fib(n: uint32): uint32
[ 461.43]         < return
[ 461.44]        < return
[ 461.45]       < return
[ 461.46]      < return
[ 461.47]     < return
[ 461.48]     > fib(n: uint32): uint32
[ 461.49]      > fib(n: uint32): uint32
[ 461.51]       > fib(n: uint32): uint32
[ 461.53]        > fib(n: uint32): uint32
[ 461.55]         > fib(n: uint32): uint32
[ 461.58]          > fib(n: uint32): uint32
[ 461.60]           > fib(n: uint32): uint32
[ 461.62]            > fib(n: uint32): uint32
[ 461.64]            < return
[ 461.66]            > fib(n: uint32): uint32
[ 461.68]            < return
[ 461.69]           < return
[ 461.70]           > fib(n: uint32): uint32
[ 461.73]           < return
[ 461.74]          < return
[ 461.75]          > fib(n: uint32): uint32
[ 461.77]           > fib(n: uint32): uint32
[ 461.80]           < return
[ 461.81]           > fib(n: uint32): uint32
[ 461.83]           < return
[ 461.84]          < return
[ 461.85]         < return
[ 461.86]         > fib(n: uint32): uint32
[ 461.88]          > fib(n: uint32): uint32
[ 461.90]           > fib(n: uint32): uint32
[ 461.91]           < return
[ 461.92]           > fib(n: uint32): uint32
[ 461.94]           < return
[ 461.95]          < return
[ 461.96]          > fib(n: uint32): uint32
[ 461.99]          < return
[ 462.00]         < return
[ 462.03]        < return
[ 462.04]        > fib(n: uint32): uint32
[ 462.05]         > fib(n: uint32): uint32
[ 462.07]          > fib(n: uint32): uint32
[ 462.09]           > fib(n: uint32): uint32
[ 462.11]           < return
[ 462.12]           > fib(n: uint32): uint32
[ 462.15]           < return
[ 462.16]          < return
[ 462.18]          > fib(n: uint32): uint32
[ 462.23]          < return
[ 462.24]         < return
[ 462.25]         > fib(n: uint32): uint32
[ 462.26]          > fib(n: uint32): uint32
[ 462.28]          < return
[ 462.29]          > fib(n: uint32): uint32
[ 462.30]          < return
[ 462.31]         < return
[ 462.32]        < return
[ 462.33]       < return
[ 462.34]       > fib(n: uint32): uint32
[ 462.36]        > fib(n: uint32): uint32
[ 462.38]         > fib(n: uint32): uint32
[ 462.39]          > fib(n: uint32): uint32
[ 462.41]           > fib(n: uint32): uint32
[ 462.45]           < return
[ 462.46]           > fib(n: uint32): uint32
[ 462.49]           < return
[ 462.50]          < return
[ 462.51]          > fib(n: uint32): uint32
[ 462.52]          < return
[ 462.53]         < return
[ 462.54]         > fib(n: uint32): uint32
[ 462.56]          > fib(n: uint32): uint32
[ 462.57]          < return
[ 462.59]          > fib(n: uint32): uint32
[ 462.60]          < return
[ 462.62]         < return
[ 462.63]        < return
[ 462.66]        > fib(n: uint32): uint32
[ 462.69]         > fib(n: uint32): uint32
[ 462.71]          > fib(n: uint32): uint32
[ 462.73]          < return
[ 462.74]          > fib(n: uint32): uint32
[ 462.75]          < return
[ 462.76]         < return
[ 462.77]         > fib(n: uint32): uint32
[ 462.79]         < return
[ 462.80]        < return
[ 462.81]       < return
[ 462.82]      < return
[ 462.83]      > fib(n: uint32): uint32
[ 462.85]       > fib(n: uint32): uint32
[ 462.88]        > fib(n: uint32): uint32
[ 462.90]         > fib(n: uint32): uint32
[ 462.92]          > fib(n: uint32): uint32
[ 462.95]           > fib(n: uint32): uint32
[ 462.98]           < return
[ 462.99]           > fib(n: uint32): uint32
[ 463.00]           < return
[ 463.03]          < return
[ 463.05]          > fib(n: uint32): uint32
[ 463.06]          < return
[ 463.07]         < return
[ 463.08]         > fib(n: uint32): uint32
[ 463.10]          > fib(n: uint32): uint32
[ 463.12]          < return
[ 463.13]          > fib(n: uint32): uint32
[ 463.15]          < return
[ 463.16]         < return
[ 463.18]        < return
[ 463.19]        > fib(n: uint32): uint32
[ 463.21]         > fib(n: uint32): uint32
[ 463.24]          > fib(n: uint32): uint32
[ 463.26]          < return
[ 463.27]          > fib(n: uint32): uint32
[ 463.29]          < return
[ 463.31]         < return
[ 463.32]         > fib(n: uint32): uint32
[ 463.34]         < return
[ 463.35]        < return
[ 463.37]       < return
[ 463.38]       > fib(n: uint32): uint32
[ 463.40]        > fib(n: uint32): uint32
[ 463.45]         > fib(n: uint32): uint32
[ 463.49]          > fib(n: uint32): uint32
[ 463.50]          < return
[ 463.51]          > fib(n: uint32): uint32
[ 463.53]          < return
[ 463.54]         < return
[ 463.56]         > fib(n: uint32): uint32
[ 463.57]         < return
[ 463.58]        < return
[ 463.59]        > fib(n: uint32): uint32
[ 463.61]         > fib(n: uint32): uint32
[ 463.63]         < return
[ 463.64]         > fib(n: uint32): uint32
[ 463.65]         < return
[ 463.66]        < return
[ 463.67]       < return
[ 463.68]      < return
[ 463.69]     < return
[ 463.70]    < return
[ 463.71]   < return
[ 463.72]   > fib(n: uint32): uint32
[ 463.74]    > fib(n: uint32): uint32
[ 463.75]     > fib(n: uint32): uint32
[ 463.77]      > fib(n: uint32): uint32
[ 463.79]       > fib(n: uint32): uint32
[ 463.81]        > fib(n: uint32): uint32
[ 463.82]         > fib(n: uint32): uint32
[ 463.85]          > fib(n: uint32): uint32
[ 463.87]           > fib(n: uint32): uint32
[ 463.90]            > fib(n: uint32): uint32
[ 463.92]             > fib(n: uint32): uint32
[ 463.93]             < return
[ 463.94]             > fib(n: uint32): uint32
[ 463.96]             < return
[ 463.97]            < return
[ 463.98]            > fib(n: uint32): uint32
[ 464.02]            < return
[ 464.03]           < return
[ 464.04]           > fib(n: uint32): uint32
[ 464.08]            > fib(n: uint32): uint32
[ 464.09]            < return
[ 464.11]            > fib(n: uint32): uint32
[ 464.13]            < return
[ 464.14]           < return
[ 464.15]          < return
[ 464.17]          > fib(n: uint32): uint32
[ 464.19]           > fib(n: uint32): uint32
[ 464.21]            > fib(n: uint32): uint32
[ 464.23]            < return
[ 464.24]            > fib(n: uint32): uint32
[ 464.26]            < return
[ 464.27]           < return
[ 464.28]           > fib(n: uint32): uint32
[ 464.30]           < return
[ 464.33]          < return
[ 464.36]         < return
[ 464.37]         > fib(n: uint32): uint32
[ 464.39]          > fib(n: uint32): uint32
[ 464.43]           > fib(n: uint32): uint32
[ 464.46]            > fib(n: uint32): uint32
[ 464.48]            < return
[ 464.49]            > fib(n: uint32): uint32
[ 464.51]            < return
[ 464.52]           < return
[ 464.54]           > fib(n: uint32): uint32
[ 464.55]           < return
[ 464.57]          < return
[ 464.58]          > fib(n: uint32): uint32
[ 464.60]           > fib(n: uint32): uint32
[ 464.62]           < return
[ 464.63]           > fib(n: uint32): uint32
[ 464.67]           < return
[ 464.68]          < return
[ 464.70]         < return
[ 464.72]        < return
[ 464.73]        > fib(n: uint32): uint32
[ 464.75]         > fib(n: uint32): uint32
[ 464.79]          > fib(n: uint32): uint32
[ 464.82]           > fib(n: uint32): uint32
[ 464.84]            > fib(n: uint32): uint32
[ 464.86]            < return
[ 464.87]            > fib(n: uint32): uint32
[ 464.89]            < return
[ 464.90]           < return
[ 464.92]           > fib(n: uint32): uint32
[ 464.96]           < return
[ 464.97]          < return
[ 464.98]          > fib(n: uint32): uint32
[ 465.02]           > fib(n: uint32): uint32
[ 465.05]           < return
[ 465.06]           > fib(n: uint32): uint32
[ 465.08]           < return
[ 465.09]          < return
[ 465.10]         < return
[ 465.11]         > fib(n: uint32): uint32
[ 465.13]          > fib(n: uint32): uint32
[ 465.18]           > fib(n: uint32): uint32
[ 465.21]           < return
[ 465.22]           > fib(n: uint32): uint32
[ 465.24]           < return
[ 465.25]          < return
[ 465.26]          > fib(n: uint32): uint32
[ 465.28]          < return
[ 465.29]         < return
[ 465.31]        < return
[ 465.32]       < return
[ 465.33]       > fib(n: uint32): uint32
[ 465.35]        > fib(n: uint32): uint32
[ 465.39]         > fib(n: uint32): uint32
[ 465.41]          > fib(n: uint32): uint32
[ 465.43]           > fib(n: uint32): uint32
[ 465.49]            > fib(n: uint32): uint32
[ 465.50]            < return
[ 465.52]            > fib(n: uint32): uint32
[ 465.54]            < return
[ 465.56]           < return
[ 465.58]           > fib(n: uint32): uint32
[ 465.60]           < return
[ 465.61]          < return
[ 465.62]          > fib(n: uint32): uint32
[ 465.64]           > fib(n: uint32): uint32
[ 465.66]           < return
[ 465.67]           > fib(n: uint32): uint32
[ 465.70]           < return
[ 465.72]          < return
[ 465.74]         < return
[ 465.77]         > fib(n: uint32): uint32
[ 465.80]          > fib(n: uint32): uint32
[ 465.84]           > fib(n: uint32): uint32
[ 465.86]           < return
[ 465.87]           > fib(n: uint32): uint32
[ 465.89]           < return
[ 465.92]          < return
[ 465.93]          > fib(n: uint32): uint32
[ 465.95]          < return
[ 465.96]         < return
[ 465.99]        < return
[ 466.00]        > fib(n: uint32): uint32
[ 466.02]         > fib(n: uint32): uint32
[ 466.04]          > fib(n: uint32): uint32
[ 466.06]           > fib(n: uint32): uint32
[ 466.08]           < return
[ 466.10]           > fib(n: uint32): uint32
[ 466.12]           < return
[ 466.13]          < return
[ 466.14]          > fib(n: uint32): uint32
[ 466.16]          < return
[ 466.17]         < return
[ 466.19]         > fib(n: uint32): uint32
[ 466.21]          > fib(n: uint32): uint32
[ 466.23]          < return
[ 466.24]          > fib(n: uint32): uint32
[ 466.26]          < return
[ 466.27]         < return
[ 466.28]        < return
[ 466.30]       < return
[ 466.31]      < return
[ 466.32]      > fib(n: uint32): uint32
[ 466.34]       > fib(n: uint32): uint32
[ 466.36]        > fib(n: uint32): uint32
[ 466.38]         > fib(n: uint32): uint32
[ 466.40]          > fib(n: uint32): uint32
[ 466.44]           > fib(n: uint32): uint32
[ 466.46]            > fib(n: uint32): uint32
[ 466.48]            < return
[ 466.50]            > fib(n: uint32): uint32
[ 466.53]            < return
[ 466.54]           < return
[ 466.55]           > fib(n: uint32): uint32
[ 466.57]           < return
[ 466.58]          < return
[ 466.60]          > fib(n: uint32): uint32
[ 466.62]           > fib(n: uint32): uint32
[ 466.64]           < return
[ 466.65]           > fib(n: uint32): uint32
[ 466.67]           < return
[ 466.68]          < return
[ 466.70]         < return
[ 466.71]         > fib(n: uint32): uint32
[ 466.73]          > fib(n: uint32): uint32
[ 466.75]           > fib(n: uint32): uint32
[ 466.77]           < return
[ 466.79]           > fib(n: uint32): uint32
[ 466.81]           < return
[ 466.82]          < return
[ 466.83]          > fib(n: uint32): uint32
[ 466.85]          < return
[ 466.87]         < return
[ 466.89]        < return
[ 466.90]        > fib(n: uint32): uint32
[ 466.92]         > fib(n: uint32): uint32
[ 466.94]          > fib(n: uint32): uint32
[ 466.96]           > fib(n: uint32): uint32
[ 466.98]           < return
[ 467.00]           > fib(n: uint32): uint32
[ 467.03]           < return
[ 467.05]          < return
[ 467.07]          > fib(n: uint32): uint32
[ 467.09]          < return
[ 467.10]         < return
[ 467.12]         > fib(n: uint32): uint32
[ 467.14]          > fib(n: uint32): uint32
[ 467.16]          < return
[ 467.17]          > fib(n: uint32): uint32
[ 467.22]          < return
[ 467.25]         < return
[ 467.26]        < return
[ 467.27]       < return
[ 467.28]       > fib(n: uint32): uint32
[ 467.30]        > fib(n: uint32): uint32
[ 467.32]         > fib(n: uint32): uint32
[ 467.37]          > fib(n: uint32): uint32
[ 467.40]           > fib(n: uint32): uint32
[ 467.42]           < return
[ 467.43]           > fib(n: uint32): uint32
[ 467.45]           < return
[ 467.46]          < return
[ 467.47]          > fib(n: uint32): uint32
[ 467.49]          < return
[ 467.50]         < return
[ 467.54]         > fib(n: uint32): uint32
[ 467.56]          > fib(n: uint32): uint32
[ 467.58]          < return
[ 467.59]          > fib(n: uint32): uint32
[ 467.61]          < return
[ 467.62]         < return
[ 467.64]        < return
[ 467.65]        > fib(n: uint32): uint32
[ 467.67]         > fib(n: uint32): uint32
[ 467.69]          > fib(n: uint32): uint32
[ 467.71]          < return
[ 467.73]          > fib(n: uint32): uint32
[ 467.74]          < return
[ 467.76]         < return
[ 467.77]         > fib(n: uint32): uint32
[ 467.79]         < return
[ 467.80]        < return
[ 467.81]       < return
[ 467.82]      < return
[ 467.85]     < return
[ 467.86]     > fib(n: uint32): uint32
[ 467.92]      > fib(n: uint32): uint32
[ 467.94]       > fib(n: uint32): uint32
[ 467.97]        > fib(n: uint32): uint32
[ 467.99]         > fib(n: uint32): uint32
[ 468.01]          > fib(n: uint32): uint32
[ 468.03]           > fib(n: uint32): uint32
[ 468.05]            > fib(n: uint32): uint32
[ 468.07]            < return
[ 468.10]            > fib(n: uint32): uint32
[ 468.12]            < return
[ 468.15]           < return
[ 468.16]           > fib(n: uint32): uint32
[ 468.18]           < return
[ 468.19]          < return
[ 468.20]          > fib(n: uint32): uint32
[ 468.23]           > fib(n: uint32): uint32
[ 468.25]           < return
[ 468.26]           > fib(n: uint32): uint32
[ 468.28]           < return
[ 468.31]          < return
[ 468.34]         < return
[ 468.35]         > fib(n: uint32): uint32
[ 468.39]          > fib(n: uint32): uint32
[ 468.41]           > fib(n: uint32): uint32
[ 468.44]           < return
[ 468.45]           > fib(n: uint32): uint32
[ 468.47]           < return
[ 468.48]          < return
[ 468.51]          > fib(n: uint32): uint32
[ 468.55]          < return
[ 468.56]         < return
[ 468.57]        < return
[ 468.58]        > fib(n: uint32): uint32
[ 468.60]         > fib(n: uint32): uint32
[ 468.64]          > fib(n: uint32): uint32
[ 468.66]           > fib(n: uint32): uint32
[ 468.70]           < return
[ 468.72]           > fib(n: uint32): uint32
[ 468.76]           < return
[ 468.78]          < return
[ 468.79]          > fib(n: uint32): uint32
[ 468.82]          < return
[ 468.83]         < return
[ 468.85]         > fib(n: uint32): uint32
[ 468.87]          > fib(n: uint32): uint32
[ 468.88]          < return
[ 468.91]          > fib(n: uint32): uint32
[ 468.94]          < return
[ 468.96]         < return
[ 468.97]        < return
[ 468.98]       < return
[ 468.99]       > fib(n: uint32): uint32
[ 469.01]        > fib(n: uint32): uint32
[ 469.03]         > fib(n: uint32): uint32
[ 469.05]          > fib(n: uint32): uint32
[ 469.07]           > fib(n: uint32): uint32
[ 469.09]           < return
[ 469.12]           > fib(n: uint32): uint32
[ 469.14]           < return
[ 469.15]          < return
[ 469.17]          > fib(n: uint32): uint32
[ 469.18]          < return
[ 469.21]         < return
[ 469.22]         > fib(n: uint32): uint32
[ 469.24]          > fib(n: uint32): uint32
[ 469.26]          < return
[ 469.27]          > fib(n: uint32): uint32
[ 469.29]          < return
[ 469.31]         < return
[ 469.32]        < return
[ 469.33]        > fib(n: uint32): uint32
[ 469.35]         > fib(n: uint32): uint32
[ 469.37]          > fib(n: uint32): uint32
[ 469.39]          < return
[ 469.40]          > fib(n: uint32): uint32
[ 469.42]          < return
[ 469.45]         < return
[ 469.46]         > fib(n: uint32): uint32
[ 469.49]         < return
[ 469.50]        < return
[ 469.51]       < return
[ 469.52]      < return
[ 469.55]      > fib(n: uint32): uint32
[ 469.58]       > fib(n: uint32): uint32
[ 469.60]        > fib(n: uint32): uint32
[ 469.62]         > fib(n: uint32): uint32
[ 469.64]          > fib(n: uint32): uint32
[ 469.67]           > fib(n: uint32): uint32
[ 469.68]           < return
[ 469.70]           > fib(n: uint32): uint32
[ 469.72]           < return
[ 469.73]          < return
[ 469.74]          > fib(n: uint32): uint32
[ 469.76]          < return
[ 469.77]         < return
[ 469.79]         > fib(n: uint32): uint32
[ 469.81]          > fib(n: uint32): uint32
[ 469.83]          < return
[ 469.84]          > fib(n: uint32): uint32
[ 469.86]          < return
[ 469.87]         < return
[ 469.88]        < return
[ 469.90]        > fib(n: uint32): uint32
[ 469.92]         > fib(n: uint32): uint32
[ 469.94]          > fib(n: uint32): uint32
[ 469.96]          < return
[ 469.97]          > fib(n: uint32): uint32
[ 469.99]          < return
[ 470.00]         < return
[ 470.02]         > fib(n: uint32): uint32
[ 470.05]         < return
[ 470.08]        < return
[ 470.09]       < return
[ 470.11]       > fib(n: uint32): uint32
[ 470.13]        > fib(n: uint32): uint32
[ 470.15]         > fib(n: uint32): uint32
[ 470.19]          > fib(n: uint32): uint32
[ 470.22]          < return
[ 470.24]          > fib(n: uint32): uint32
[ 470.26]          < return
[ 470.27]         < return
[ 470.30]         > fib(n: uint32): uint32
[ 470.31]         < return
[ 470.33]        < return
[ 470.34]        > fib(n: uint32): uint32
[ 470.36]         > fib(n: uint32): uint32
[ 470.38]         < return
[ 470.40]         > fib(n: uint32): uint32
[ 470.41]         < return
[ 470.43]        < return
[ 470.44]       < return
[ 470.45]      < return
[ 470.46]     < return
[ 470.48]    < return
[ 470.49]    > fib(n: uint32): uint32
[ 470.51]     > fib(n: uint32): uint32
[ 470.53]      > fib(n: uint32): uint32
[ 470.57]       > fib(n: uint32): uint32
[ 470.59]        > fib(n: uint32): uint32
[ 470.62]         > fib(n: uint32): uint32
[ 470.64]          > fib(n: uint32): uint32
[ 470.67]           > fib(n: uint32): uint32
[ 470.69]            > fib(n: uint32): uint32
[ 470.71]            < return
[ 470.72]            > fib(n: uint32): uint32
[ 470.74]            < return
[ 470.75]           < return
[ 470.76]           > fib(n: uint32): uint32
[ 470.78]           < return
[ 470.80]          < return
[ 470.81]          > fib(n: uint32): uint32
[ 470.83]           > fib(n: uint32): uint32
[ 470.85]           < return
[ 470.87]           > fib(n: uint32): uint32
[ 470.90]           < return
[ 470.91]          < return
[ 470.92]         < return
[ 470.93]         > fib(n: uint32): uint32
[ 470.95]          > fib(n: uint32): uint32
[ 470.97]           > fib(n: uint32): uint32
[ 471.00]           < return
[ 471.02]           > fib(n: uint32): uint32
[ 471.05]           < return
[ 471.07]          < return
[ 471.10]          > fib(n: uint32): uint32
[ 471.12]          < return
[ 471.13]         < return
[ 471.14]        < return
[ 471.17]        > fib(n: uint32): uint32
[ 471.20]         > fib(n: uint32): uint32
[ 471.24]          > fib(n: uint32): uint32
[ 471.27]           > fib(n: uint32): uint32
[ 471.31]           < return
[ 471.33]           > fib(n: uint32): uint32
[ 471.35]           < return
[ 471.38]          < return
[ 471.39]          > fib(n: uint32): uint32
[ 471.41]          < return
[ 471.42]         < return
[ 471.44]         > fib(n: uint32): uint32
[ 471.46]          > fib(n: uint32): uint32
[ 471.47]          < return
[ 471.49]          > fib(n: uint32): uint32
[ 471.51]          < return
[ 471.52]         < return
[ 471.52]        < return
[ 471.56]       < return
[ 471.57]       > fib(n: uint32): uint32
[ 471.61]        > fib(n: uint32): uint32
[ 471.63]         > fib(n: uint32): uint32
[ 471.65]          > fib(n: uint32): uint32
[ 471.67]           > fib(n: uint32): uint32
[ 471.69]           < return
[ 471.70]           > fib(n: uint32): uint32
[ 471.73]           < return
[ 471.75]          < return
[ 471.76]          > fib(n: uint32): uint32
[ 471.78]          < return
[ 471.81]         < return
[ 471.82]         > fib(n: uint32): uint32
[ 471.86]          > fib(n: uint32): uint32
[ 471.89]          < return
[ 471.91]          > fib(n: uint32): uint32
[ 471.93]          < return
[ 471.94]         < return
[ 471.97]        < return
[ 471.99]        > fib(n: uint32): uint32
[ 472.01]         > fib(n: uint32): uint32
[ 472.05]          > fib(n: uint32): uint32
[ 472.07]          < return
[ 472.08]          > fib(n: uint32): uint32
[ 472.10]          < return
[ 472.11]         < return
[ 472.12]         > fib(n: uint32): uint32
[ 472.13]         < return
[ 472.14]        < return
[ 472.15]       < return
[ 472.16]      < return
[ 472.17]      > fib(n: uint32): uint32
[ 472.20]       > fib(n: uint32): uint32
[ 472.22]        > fib(n: uint32): uint32
[ 472.24]         > fib(n: uint32): uint32
[ 472.25]          > fib(n: uint32): uint32
[ 472.27]           > fib(n: uint32): uint32
[ 472.30]           < return
[ 472.31]           > fib(n: uint32): uint32
[ 472.34]           < return
[ 472.36]          < return
[ 472.37]          > fib(n: uint32): uint32
[ 472.39]          < return
[ 472.40]         < return
[ 472.42]         > fib(n: uint32): uint32
[ 472.44]          > fib(n: uint32): uint32
[ 472.46]          < return
[ 472.48]          > fib(n: uint32): uint32
[ 472.50]          < return
[ 472.51]         < return
[ 472.52]        < return
[ 472.54]        > fib(n: uint32): uint32
[ 472.56]         > fib(n: uint32): uint32
[ 472.58]          > fib(n: uint32): uint32
[ 472.60]          < return
[ 472.61]          > fib(n: uint32): uint32
[ 472.63]          < return
[ 472.65]         < return
[ 472.66]         > fib(n: uint32): uint32
[ 472.68]         < return
[ 472.69]        < return
[ 472.71]       < return
[ 472.72]       > fib(n: uint32): uint32
[ 472.74]        > fib(n: uint32): uint32
[ 472.75]         > fib(n: uint32): uint32
[ 472.77]          > fib(n: uint32): uint32
[ 472.79]          < return
[ 472.80]          > fib(n: uint32): uint32
[ 472.81]          < return
[ 472.82]         < return
[ 472.83]         > fib(n: uint32): uint32
[ 472.86]         < return
[ 472.87]        < return
[ 472.89]        > fib(n: uint32): uint32
[ 472.92]         > fib(n: uint32): uint32
[ 472.94]         < return
[ 472.95]         > fib(n: uint32): uint32
[ 472.97]         < return
[ 472.98]        < return
[ 473.00]       < return
[ 473.02]      < return
[ 473.03]     < return
[ 473.04]     > fib(n: uint32): uint32
[ 473.06]      > fib(n: uint32): uint32
[ 473.08]       > fib(n: uint32): uint32
[ 473.11]        > fib(n: uint32): uint32
[ 473.12]         > fib(n: uint32): uint32
[ 473.15]          > fib(n: uint32): uint32
[ 473.17]           > fib(n: uint32): uint32
[ 473.20]           < return
[ 473.21]           > fib(n: uint32): uint32
[ 473.24]           < return
[ 473.25]          < return
[ 473.29]          > fib(n: uint32): uint32
[ 473.31]          < return
[ 473.33]         < return
[ 473.36]         > fib(n: uint32): uint32
[ 473.40]          > fib(n: uint32): uint32
[ 473.42]          < return
[ 473.43]          > fib(n: uint32): uint32
[ 473.45]          < return
[ 473.48]         < return
[ 473.49]        < return
[ 473.50]        > fib(n: uint32): uint32
[ 473.56]         > fib(n: uint32): uint32
[ 473.57]          > fib(n: uint32): uint32
[ 473.61]          < return
[ 473.62]          > fib(n: uint32): uint32
[ 473.63]          < return
[ 473.64]         < return
[ 473.65]         > fib(n: uint32): uint32
[ 473.68]         < return
[ 473.69]        < return
[ 473.70]       < return
[ 473.71]       > fib(n: uint32): uint32
[ 473.74]        > fib(n: uint32): uint32
[ 473.76]         > fib(n: uint32): uint32
[ 473.78]          > fib(n: uint32): uint32
[ 473.79]          < return
[ 473.82]          > fib(n: uint32): uint32
[ 473.83]          < return
[ 473.84]         < return
[ 473.86]         > fib(n: uint32): uint32
[ 473.88]         < return
[ 473.89]        < return
[ 473.90]        > fib(n: uint32): uint32
[ 473.92]         > fib(n: uint32): uint32
[ 473.93]         < return
[ 473.94]         > fib(n: uint32): uint32
[ 473.96]         < return
[ 473.97]        < return
[ 473.98]       < return
[ 473.99]      < return
[ 474.00]      > fib(n: uint32): uint32
[ 474.01]       > fib(n: uint32): uint32
[ 474.03]        > fib(n: uint32): uint32
[ 474.05]         > fib(n: uint32): uint32
[ 474.06]          > fib(n: uint32): uint32
[ 474.08]          < return
[ 474.09]          > fib(n: uint32): uint32
[ 474.12]          < return
[ 474.13]         < return
[ 474.15]         > fib(n: uint32): uint32
[ 474.17]         < return
[ 474.18]        < return
[ 474.20]        > fib(n: uint32): uint32
[ 474.22]         > fib(n: uint32): uint32
[ 474.24]         < return
[ 474.25]         > fib(n: uint32): uint32
[ 474.27]         < return
[ 474.28]        < return
[ 474.30]       < return
[ 474.31]       > fib(n: uint32): uint32
[ 474.34]        > fib(n: uint32): uint32
[ 474.36]         > fib(n: uint32): uint32
[ 474.37]         < return
[ 474.38]         > fib(n: uint32): uint32
[ 474.40]         < return
[ 474.41]        < return
[ 474.42]        > fib(n: uint32): uint32
[ 474.43]        < return
[ 474.44]       < return
[ 474.45]      < return
[ 474.46]     < return
[ 474.47]    < return
[ 474.48]   < return
[ 474.50]  < return
[ 474.56]  > typename.name(type: typename): .cstr
[ 474.60]  < return
[ 474.61]  > typename.file(type: typename): .cstr
[ 474.65]  < return
[ 474.66]  > typename.line(type: typename): int32
[ 474.68]  < return
[ 474.69]  > typename.base(type: typename): typename
[ 474.71]  < return
[ 474.72]  > typename.name(type: typename): .cstr
[ 474.74]  < return
[ 474.76]  > typename.file(type: typename): .cstr
[ 474.78]  < return
[ 474.79]  > typename.line(type: typename): int32
[ 474.81]  < return
[ 474.82]  > typename.base(type: typename): typename
[ 474.83]  < return
[ 474.86]  > typename.base(type: typename): typename
[ 474.88]  < return
[ 474.96]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 474.99]  < return
[ 475.01]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 475.03]  < return
[ 475.06]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 475.08]  < return
[ 475.10]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 475.11]  < return
[ 475.12]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 475.14]  < return
[ 475.15]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 475.18]  < return
[ 475.19]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 475.24]  < return
[ 475.25]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 475.26]  < return
[ 475.28]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 475.29]  < return
[ 475.31]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 475.32]  < return
[ 475.33]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 475.35]  < return
[ 475.37]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 475.40]  < return
[ 475.42]  > float64.sin(x: float64): float64
[ 475.46]  < return
[ 475.49]  > float64.cos(x: float64): float64
[ 475.51]  < return
[ 475.53]  > float64.tan(x: float64): float64
[ 475.55]  < return
[ 475.56]  > float64.log(x: float64): float64
[ 475.58]  < return
[ 475.61]  > float64.exp(x: float64): float64
[ 475.62]  < return
[ 475.64]  > float64.pow(x: float64, y: float64): float64
[ 475.65]  < return
[ 475.67]  > float64.sqrt(x: float64): float64
[ 475.68]  < return
[ 475.69]  > float64.atan2(x: float64, y: float64): float64
[ 475.71]  < return
[ 475.73]  > float32.sin(x: float32): float32
[ 475.74]  < return
[ 475.76]  > float32.cos(x: float32): float32
[ 475.77]  < return
[ 475.79]  > float32.tan(x: float32): float32
[ 475.80]  < return
[ 475.82]  > float32.log(x: float32): float32
[ 475.85]  < return
[ 475.87]  > float32.exp(x: float32): float32
[ 475.90]  < return
[ 475.92]  > float32.pow(x: float32, y: float32): float32
[ 475.93]  < return
[ 475.94]  > float32.sqrt(x: float32): float32
[ 475.98]  < return
[ 476.01]  > float32.atan2(x: float32, y: float32): float32
[ 476.03]  < return
[ 476.05]  > uint32.pop(value: int32): int32
[ 476.06]  < return
[ 476.07]  > uint32.swap(value: int32): int32
[ 476.09]  < return
[ 476.10]  > uint32.bsr(value: int32): int32
[ 476.12]  < return
[ 476.13]  > uint32.bsf(value: int32): int32
[ 476.15]  < return
[ 476.19]  > uint32.hib(value: int32): int32
[ 476.22]  < return
[ 476.24]  > uint32.lob(value: int32): int32
[ 476.27]  < return
[ 476.28]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 476.31]  < return
[ 476.32]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 476.34]  < return
[ 476.35]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 476.37]  < return
[ 476.38]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 476.43]  < return
[ 476.45]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 476.48]  < return
[ 476.49]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 476.55]  < return
[ 476.56]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 476.58]  < return
[ 476.59]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 476.60]  < return
[ 476.62]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 476.64]   > noError(ptr: pointer): void
[ 476.66]   < return
[ 476.67]   > halt(): void
[ 476.68]   < return
[ 476.68]  < return
[ 476.69]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 476.71]  < return
[ 476.73]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 476.74]   > stackOverflow(ptr: pointer): void
[ 476.76]    > stackOverflow(ptr: pointer): void
[ 476.78]     > stackOverflow(ptr: pointer): void
[ 476.79]      > stackOverflow(ptr: pointer): void
[ 476.81]       > stackOverflow(ptr: pointer): void
[ 476.82]        > stackOverflow(ptr: pointer): void
[ 476.84]         > stackOverflow(ptr: pointer): void
[ 476.85]          > stackOverflow(ptr: pointer): void
[ 476.87]           > stackOverflow(ptr: pointer): void
[ 476.88]            > stackOverflow(ptr: pointer): void
[ 476.90]             > stackOverflow(ptr: pointer): void
[ 476.92]              > stackOverflow(ptr: pointer): void
[ 476.93]               > stackOverflow(ptr: pointer): void
[ 476.95]                > stackOverflow(ptr: pointer): void
[ 476.98]                 > stackOverflow(ptr: pointer): void
[ 477.01]                  > stackOverflow(ptr: pointer): void
[ 477.06]                   > stackOverflow(ptr: pointer): void
[ 477.08]                    > stackOverflow(ptr: pointer): void
[ 477.10]                     > stackOverflow(ptr: pointer): void
[ 477.11]                      > stackOverflow(ptr: pointer): void
[ 477.13]                       > stackOverflow(ptr: pointer): void
[ 477.15]                        > stackOverflow(ptr: pointer): void
[ 477.16]                         > stackOverflow(ptr: pointer): void
[ 477.18]                          > stackOverflow(ptr: pointer): void
[ 477.19]                           > stackOverflow(ptr: pointer): void
[ 477.21]                            > stackOverflow(ptr: pointer): void
[ 477.22]                             > stackOverflow(ptr: pointer): void
[ 477.24]                              > stackOverflow(ptr: pointer): void
[ 477.27]                               > stackOverflow(ptr: pointer): void
[ 477.31]                                > stackOverflow(ptr: pointer): void
[ 477.33]                                 > stackOverflow(ptr: pointer): void
[ 477.35]                                  > stackOverflow(ptr: pointer): void
[ 477.37]                                   > stackOverflow(ptr: pointer): void
[ 477.38]                                    > stackOverflow(ptr: pointer): void
[ 477.40]                                     > stackOverflow(ptr: pointer): void
[ 477.41]                                      > stackOverflow(ptr: pointer): void
[ 477.43]                                       > stackOverflow(ptr: pointer): void
[ 477.45]                                        > stackOverflow(ptr: pointer): void
[ 477.47]                                         > stackOverflow(ptr: pointer): void
[ 477.48]                                          > stackOverflow(ptr: pointer): void
[ 477.50]                                           > stackOverflow(ptr: pointer): void
[ 477.52]                                            > stackOverflow(ptr: pointer): void
[ 477.53]                                             > stackOverflow(ptr: pointer): void
[ 477.55]                                              > stackOverflow(ptr: pointer): void
[ 477.56]                                               > stackOverflow(ptr: pointer): void
[ 477.58]                                                > stackOverflow(ptr: pointer): void
[ 477.62]                                                 > stackOverflow(ptr: pointer): void
[ 477.64]                                                  > stackOverflow(ptr: pointer): void
[ 477.66]                                                   > stackOverflow(ptr: pointer): void
[ 477.67]                                                    > stackOverflow(ptr: pointer): void
[ 477.69]                                                     > stackOverflow(ptr: pointer): void
[ 477.70]                                                      > stackOverflow(ptr: pointer): void
[ 477.72]                                                       > stackOverflow(ptr: pointer): void
[ 477.74]                                                        > stackOverflow(ptr: pointer): void
[ 477.75]                                                         > stackOverflow(ptr: pointer): void
[ 477.77]                                                          > stackOverflow(ptr: pointer): void
[ 477.79]                                                           > stackOverflow(ptr: pointer): void
[ 477.81]                                                            > stackOverflow(ptr: pointer): void
[ 477.82]                                                             > stackOverflow(ptr: pointer): void
[ 477.84]                                                              > stackOverflow(ptr: pointer): void
[ 477.86]                                                               > stackOverflow(ptr: pointer): void
[ 477.87]                                                                > stackOverflow(ptr: pointer): void
[ 477.89]                                                                 > stackOverflow(ptr: pointer): void
[ 477.91]                                                                  > stackOverflow(ptr: pointer): void
[ 477.93]                                                                   > stackOverflow(ptr: pointer): void
[ 477.94]                                                                    > stackOverflow(ptr: pointer): void
[ 477.96]                                                                     > stackOverflow(ptr: pointer): void
[ 477.98]                                                                      > stackOverflow(ptr: pointer): void
[ 477.99]                                                                       > stackOverflow(ptr: pointer): void
[ 478.01]                                                                        > stackOverflow(ptr: pointer): void
[ 478.02]                                                                         > stackOverflow(ptr: pointer): void
[ 478.04]                                                                          > stackOverflow(ptr: pointer): void
[ 478.06]                                                                           > stackOverflow(ptr: pointer): void
[ 478.07]                                                                            > stackOverflow(ptr: pointer): void
[ 478.09]                                                                             > stackOverflow(ptr: pointer): void
[ 478.10]                                                                              > stackOverflow(ptr: pointer): void
[ 478.12]                                                                               > stackOverflow(ptr: pointer): void
[ 478.14]                                                                                > stackOverflow(ptr: pointer): void
[ 478.15]                                                                                 > stackOverflow(ptr: pointer): void
[ 478.17]                                                                                  > stackOverflow(ptr: pointer): void
[ 478.19]                                                                                   > stackOverflow(ptr: pointer): void
[ 478.20]                                                                                    > stackOverflow(ptr: pointer): void
[ 478.22]                                                                                     > stackOverflow(ptr: pointer): void
[ 478.23]                                                                                      > stackOverflow(ptr: pointer): void
[ 478.25]                                                                                       > stackOverflow(ptr: pointer): void
[ 478.27]                                                                                        > stackOverflow(ptr: pointer): void
[ 478.28]                                                                                         > stackOverflow(ptr: pointer): void
[ 478.30]                                                                                          > stackOverflow(ptr: pointer): void
[ 478.31]                                                                                           > stackOverflow(ptr: pointer): void
[ 478.33]                                                                                            > stackOverflow(ptr: pointer): void
[ 478.35]                                                                                             > stackOverflow(ptr: pointer): void
[ 478.36]                                                                                              > stackOverflow(ptr: pointer): void
[ 478.38]                                                                                               > stackOverflow(ptr: pointer): void
[ 478.39]                                                                                                > stackOverflow(ptr: pointer): void
[ 478.41]                                                                                                 > stackOverflow(ptr: pointer): void
[ 478.44]                                                                                                  > stackOverflow(ptr: pointer): void
[ 478.46]                                                                                                   > stackOverflow(ptr: pointer): void
[ 478.47]                                                                                                    > stackOverflow(ptr: pointer): void
[ 478.49]                                                                                                     > stackOverflow(ptr: pointer): void
[ 478.52]                                                                                                      > stackOverflow(ptr: pointer): void
[ 478.56]                                                                                                       > stackOverflow(ptr: pointer): void
[ 478.58]                                                                                                        > stackOverflow(ptr: pointer): void
[ 478.60]                                                                                                         > stackOverflow(ptr: pointer): void
[ 478.62]                                                                                                          > stackOverflow(ptr: pointer): void
[ 478.63]                                                                                                           > stackOverflow(ptr: pointer): void
[ 478.65]                                                                                                            > stackOverflow(ptr: pointer): void
[ 478.67]                                                                                                             > stackOverflow(ptr: pointer): void
[ 478.68]                                                                                                              > stackOverflow(ptr: pointer): void
[ 478.70]                                                                                                               > stackOverflow(ptr: pointer): void
[ 478.73]                                                                                                                > stackOverflow(ptr: pointer): void
[ 478.75]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 478.76]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 478.78]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 478.80]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 478.81]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 478.83]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 478.84]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 478.86]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 478.88]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 478.90]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 478.92]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 478.93]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 478.95]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 478.96]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 478.98]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 479.02]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 479.04]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 479.07]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 479.10]                                                                                                                                  < return
[ 479.11]                                                                                                                                 < return
[ 479.11]                                                                                                                                < return
[ 479.13]                                                                                                                               < return
[ 479.13]                                                                                                                              < return
[ 479.14]                                                                                                                             < return
[ 479.15]                                                                                                                            < return
[ 479.16]                                                                                                                           < return
[ 479.17]                                                                                                                          < return
[ 479.18]                                                                                                                         < return
[ 479.18]                                                                                                                        < return
[ 479.19]                                                                                                                       < return
[ 479.20]                                                                                                                      < return
[ 479.21]                                                                                                                     < return
[ 479.23]                                                                                                                    < return
[ 479.23]                                                                                                                   < return
[ 479.24]                                                                                                                  < return
[ 479.25]                                                                                                                 < return
[ 479.26]                                                                                                                < return
[ 479.27]                                                                                                               < return
[ 479.28]                                                                                                              < return
[ 479.29]                                                                                                             < return
[ 479.30]                                                                                                            < return
[ 479.31]                                                                                                           < return
[ 479.32]                                                                                                          < return
[ 479.32]                                                                                                         < return
[ 479.33]                                                                                                        < return
[ 479.34]                                                                                                       < return
[ 479.35]                                                                                                      < return
[ 479.36]                                                                                                     < return
[ 479.37]                                                                                                    < return
[ 479.38]                                                                                                   < return
[ 479.38]                                                                                                  < return
[ 479.39]                                                                                                 < return
[ 479.40]                                                                                                < return
[ 479.41]                                                                                               < return
[ 479.42]                                                                                              < return
[ 479.43]                                                                                             < return
[ 479.44]                                                                                            < return
[ 479.44]                                                                                           < return
[ 479.45]                                                                                          < return
[ 479.46]                                                                                         < return
[ 479.47]                                                                                        < return
[ 479.48]                                                                                       < return
[ 479.49]                                                                                      < return
[ 479.50]                                                                                     < return
[ 479.50]                                                                                    < return
[ 479.51]                                                                                   < return
[ 479.53]                                                                                  < return
[ 479.54]                                                                                 < return
[ 479.55]                                                                                < return
[ 479.56]                                                                               < return
[ 479.57]                                                                              < return
[ 479.57]                                                                             < return
[ 479.58]                                                                            < return
[ 479.59]                                                                           < return
[ 479.60]                                                                          < return
[ 479.61]                                                                         < return
[ 479.62]                                                                        < return
[ 479.62]                                                                       < return
[ 479.63]                                                                      < return
[ 479.64]                                                                     < return
[ 479.65]                                                                    < return
[ 479.66]                                                                   < return
[ 479.67]                                                                  < return
[ 479.68]                                                                 < return
[ 479.68]                                                                < return
[ 479.69]                                                               < return
[ 479.72]                                                              < return
[ 479.73]                                                             < return
[ 479.74]                                                            < return
[ 479.75]                                                           < return
[ 479.75]                                                          < return
[ 479.76]                                                         < return
[ 479.77]                                                        < return
[ 479.79]                                                       < return
[ 479.80]                                                      < return
[ 479.81]                                                     < return
[ 479.82]                                                    < return
[ 479.83]                                                   < return
[ 479.85]                                                  < return
[ 479.86]                                                 < return
[ 479.88]                                                < return
[ 479.89]                                               < return
[ 479.90]                                              < return
[ 479.91]                                             < return
[ 479.91]                                            < return
[ 479.92]                                           < return
[ 479.93]                                          < return
[ 479.94]                                         < return
[ 479.95]                                        < return
[ 479.95]                                       < return
[ 479.96]                                      < return
[ 480.00]                                     < return
[ 480.00]                                    < return
[ 480.01]                                   < return
[ 480.04]                                  < return
[ 480.04]                                 < return
[ 480.05]                                < return
[ 480.06]                               < return
[ 480.07]                              < return
[ 480.07]                             < return
[ 480.08]                            < return
[ 480.09]                           < return
[ 480.10]                          < return
[ 480.11]                         < return
[ 480.11]                        < return
[ 480.12]                       < return
[ 480.13]                      < return
[ 480.14]                     < return
[ 480.15]                    < return
[ 480.17]                   < return
[ 480.18]                  < return
[ 480.19]                 < return
[ 480.19]                < return
[ 480.20]               < return
[ 480.22]              < return
[ 480.25]             < return
[ 480.27]            < return
[ 480.29]           < return
[ 480.30]          < return
[ 480.31]         < return
[ 480.31]        < return
[ 480.32]       < return
[ 480.33]      < return
[ 480.34]     < return
[ 480.36]    < return
[ 480.37]   < return
[ 480.38]  < return
[ 480.39]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 480.41]   > divisionByZero(args: pointer): void
[ 480.43]   < return
[ 480.45]  < return
[ 480.48]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 480.50]   > invalidInstruction(args: pointer): void
[ 480.51]   < return
[ 480.52]  < return
[ 480.53]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 480.55]   > invalidMemoryAccess(args: pointer): void
[ 480.56]   < return
[ 480.57]  < return
[ 480.58]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 480.60]   > abortExecution(args: pointer): void
[ 480.62]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/tryExec.ci:34: fatal: fatal error: NotEquals(<?>)
	native.code:: abortExecution(args: null)
	test/std/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 480.73]    < return
[ 480.74]   < return
[ 480.74]  < return
[ 482.76]  > Math.floor(x: float64): float64
[ 482.80]   > Math.modf(x: float64, intPart: float64): float64
[ 482.82]   < return
[ 482.83]  < return
[ 482.85]  > Math.floor(x: float64): float64
[ 482.86]   > Math.modf(x: float64, intPart: float64): float64
[ 482.88]   < return
[ 482.89]  < return
[ 482.93]  > Math.floor(x: float64): float64
[ 482.94]   > Math.modf(x: float64, intPart: float64): float64
[ 482.96]   < return
[ 482.97]  < return
[ 483.00]  > Math.floor(x: float64): float64
[ 483.01]   > Math.modf(x: float64, intPart: float64): float64
[ 483.02]    > Math.modf(x: float64, intPart: float64): float64
[ 483.04]    < return
[ 483.05]   < return
[ 483.06]  < return
[ 483.09]  > Math.floor(x: float64): float64
[ 483.10]   > Math.modf(x: float64, intPart: float64): float64
[ 483.13]    > Math.modf(x: float64, intPart: float64): float64
[ 483.15]    < return
[ 483.17]   < return
[ 483.18]  < return
[ 483.23]  > Math.floor(x: float64): float64
[ 483.24]   > Math.modf(x: float64, intPart: float64): float64
[ 483.26]    > Math.modf(x: float64, intPart: float64): float64
[ 483.27]    < return
[ 483.29]   < return
[ 483.30]  < return
[ 483.43]  > Math.abs(x: float64): float64
[ 483.45]  < return
[ 483.47]  > Math.abs(x: float64): float64
[ 483.48]  < return
[ 483.51]  > Math.abs(x: float64): float64
[ 483.52]  < return
[ 483.54]  > Math.abs(x: float32): float32
[ 483.55]  < return
[ 483.58]  > Math.abs(x: float32): float32
[ 483.59]  < return
[ 483.61]  > Math.abs(x: float32): float32
[ 483.62]  < return
[ 483.63]  > Math.min(a: float32, b: float32): float32
[ 483.64]  < return
[ 483.66]  > Math.max(a: float32, b: float32): float32
[ 483.67]  < return
[ 483.70]  > Math.min(a: float64, b: float64): float64
[ 483.71]  < return
[ 483.74]  > Math.max(a: float64, b: float64): float64
[ 483.75]  < return
[ 483.77]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 483.80]  < return
[ 483.82]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 483.84]  < return
[ 483.89]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 483.91]  < return
[ 483.95]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 483.96]  < return
[ 484.00]  > Math.min(data: float64[]): float64
[ 484.01]  < return
[ 484.07]  > Math.min(data: float64[]): float64
[ 484.14]  < return
[ 484.17]  > Math.max(data: float64[]): float64
[ 484.19]  < return
[ 484.24]  > Math.max(data: float64[]): float64
[ 484.35]  < return
[ 484.37]  > Math.sum(data: float64[]): float64
[ 484.42]  < return
[ 484.46]  > Math.sum(data: float64[]): float64
[ 484.52]  < return
[ 484.56]  > Math.sum(data: float64[]): float64
[ 484.61]  < return
[ 484.65]  > Math.sum(data: float64[]): float64
[ 484.73]  < return
[ 484.77]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 484.79]  < return
[ 484.90]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 484.98]  < return
[ 485.00]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 485.05]  < return
[ 485.07]  > Math.sinCos(arg: float64, quad: int32): float64
[ 485.13]  < return
[ 485.15]  > Math.abs(x: float64): float64
[ 485.16]  < return
[ 485.18]  > Math.sinCos(arg: float64, quad: int32): float64
[ 485.23]  < return
[ 485.26]  > Math.tan(arg: float64): float64
[ 485.29]   > Math.modf(x: float64, intPart: float64): float64
[ 485.30]   < return
[ 485.34]  < return
[ 485.37]  > Math.sinh(x: float64): float64
[ 485.39]   > float64.exp(x: float64): float64
[ 485.43]   < return
[ 485.44]   > float64.exp(x: float64): float64
[ 485.46]   < return
[ 485.48]  < return
[ 485.51]  > Math.cosh(x: float64): float64
[ 485.53]   > float64.exp(x: float64): float64
[ 485.58]   < return
[ 485.59]   > float64.exp(x: float64): float64
[ 485.61]   < return
[ 485.62]  < return
[ 485.67]  > Math.asin(x: float64): float64
[ 485.71]   > float64.sqrt(x: float64): float64
[ 485.73]   < return
[ 485.75]   > float64.atan2(x: float64, y: float64): float64
[ 485.77]   < return
[ 485.78]  < return
[ 485.81]  > Math.asin(x: float64): float64
[ 485.83]   > float64.sqrt(x: float64): float64
[ 485.85]   < return
[ 485.86]   > float64.atan2(x: float64, y: float64): float64
[ 485.88]   < return
[ 485.89]  < return
[ 485.93]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 485.94]  < return
[ 485.96]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 485.98]  < return
[ 486.00]  > Math.absMod(val: float64, mod: float64): float64
[ 486.01]  < return
[ 486.03]  > Math.absMod(val: float64, mod: float64): float64
[ 486.04]  < return
[ 486.08]  > Math.absMod(val: float64, mod: float64): float64
[ 486.09]  < return
[ 486.12]  > Math.absMod(val: float64, mod: float64): float64
[ 486.14]  < return
[ 486.17]  > Math.absMod(val: float64, mod: float64): float64
[ 486.19]  < return
[ 486.21]  > Math.absMod(val: float64, mod: float64): float64
[ 486.22]  < return
[ 486.24]  > Math.absMod(val: float64, mod: float64): float64
[ 486.25]  < return
[ 486.27]  > Math.absMod(val: float64, mod: float64): float64
[ 486.29]  < return
[ 486.30]  > Math.absMod(val: float64, mod: float64): float64
[ 486.31]  < return
[ 486.33]  > Math.absMod(val: float64, mod: float64): float64
[ 486.35]  < return
[ 486.37]  > Math.absMod(val: float64, mod: float64): float64
[ 486.39]  < return
[ 486.41]  > Math.absMod(val: float32, mod: float32): float32
[ 486.42]  < return
[ 486.44]  > Math.absMod(val: float32, mod: float32): float32
[ 486.45]  < return
[ 486.47]  > Math.absMod(val: float32, mod: float32): float32
[ 486.48]  < return
[ 486.50]  > Math.absMod(val: float32, mod: float32): float32
[ 486.52]  < return
[ 486.54]  > Math.absMod(val: float32, mod: float32): float32
[ 486.55]  < return
[ 486.58]  > Math.absMod(val: float32, mod: float32): float32
[ 486.60]  < return
[ 486.61]  > Math.absMod(val: float32, mod: float32): float32
[ 486.62]  < return
[ 486.64]  > Math.absMod(val: float32, mod: float32): float32
[ 486.65]  < return
[ 486.67]  > Math.absMod(val: float32, mod: float32): float32
[ 486.68]  < return
[ 486.70]  > Math.absMod(val: float32, mod: float32): float32
[ 486.71]  < return
[ 486.73]  > Math.absMod(val: float32, mod: float32): float32
[ 486.74]  < return
[ 486.76]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 486.79]  < return
[ 486.82]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 486.85]  < return
[ 486.86]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 486.88]  < return
[ 486.91]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 486.95]  < return
[ 486.98]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 486.99]  < return
[ 487.01]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 487.04]  < return
[ 487.06]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:26: debug: val1: int64(42)
[ 487.09]  < return
[ 487.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:27: debug: val2: int64(96)
[ 487.13]  < return
[ 487.15]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 487.18]  < return
[ 487.20]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 487.22]  < return
[ 487.25]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:32: debug: val1: int64(0)
[ 487.27]  < return
[ 487.29]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:33: debug: val2: int64(42)
[ 487.32]  < return
[ 487.49]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 487.51]  < return
[ 487.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7](...)
[ 487.56]  < return
[ 487.58]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7](...)
[ 487.61]  < return
[ 487.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 487.66]  < return
[ 487.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 487.74]  < return
[ 487.76]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[](...)
[ 487.80]  < return
[ 487.82]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[](...)
[ 487.86]  < return
[ 487.92]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 487.93]  < return
[ 487.95]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 487.96]  < return
[ 487.98]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 487.99]  < return
[ 488.01]  > lenSlice(values: int64[]): int32
[ 488.03]  < return
[ 488.04]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 488.05]  < return
[ 488.07]  > lenSlice(values: int64[]): int32
[ 488.11]  < return
[ 488.12]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 488.14]  < return
[ 488.18]  > lenSlice(values: int64[]): int32
[ 488.20]  < return
[ 488.23]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 488.24]  < return
[ 488.27]  > lenSlice(values: int64[]): int32
[ 488.32]  < return
[ 488.35]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 488.37]  < return
[ 488.40]  > lenSlice(values: int64[]): int32
[ 488.44]  < return
[ 488.45]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 488.46]  < return
[ 488.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 488.56]  < return
[ 488.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 488.60]  < return
[ 488.62]  > nthFixed(idx: int32, values: int64[7]): int64
[ 488.64]  < return
[ 488.67]  > nthArray(idx: int32, values: int64[*]): int64
[ 488.69]  < return
[ 488.71]  > nthArray(idx: int32, values: int64[*]): int64
[ 488.73]  < return
[ 488.77]  > nthArray(idx: int32, values: int64[*]): int64
[ 488.82]  < return
[ 488.85]  > nthSlice(idx: int32, values: int64[]): int64
[ 488.87]  < return
[ 488.89]  > nthSlice(idx: int32, values: int64[]): int64
[ 488.91]  < return
[ 489.01]  > nthFixed(idx: int32, values: int64[7]): int64
[ 489.05]  < return
[ 489.07]  > nthFixed(idx: int32, values: int64[7]): int64
[ 489.09]  < return
[ 489.11]  > nthFixed(idx: int32, values: int64[7]): int64
[ 489.13]  < return
[ 489.15]  > nthArray(idx: int32, values: int64[*]): int64
[ 489.17]  < return
[ 489.19]  > nthArray(idx: int32, values: int64[*]): int64
[ 489.21]  < return
[ 489.23]  > nthArray(idx: int32, values: int64[*]): int64
[ 489.25]  < return
[ 489.27]  > nthSlice(idx: int32, values: int64[]): int64
[ 489.29]  < return
[ 489.32]  > nthSlice(idx: int32, values: int64[]): int64
[ 489.33]  < return
[ 489.46]  > nthFixed(idx: int32, values: int64[7]): int64
[ 489.48]  < return
[ 489.52]  > nthFixed(idx: int32, values: int64[7]): int64
[ 489.55]  < return
[ 489.59]  > nthFixed(idx: int32, values: int64[7]): int64
[ 489.61]  < return
[ 489.63]  > nthArray(idx: int32, values: int64[*]): int64
[ 489.67]  < return
[ 489.70]  > nthArray(idx: int32, values: int64[*]): int64
[ 489.72]  < return
[ 489.75]  > nthArray(idx: int32, values: int64[*]): int64
[ 489.76]  < return
[ 489.79]  > nthSlice(idx: int32, values: int64[]): int64
[ 489.82]  < return
[ 489.88]  > nthSlice(idx: int32, values: int64[]): int64
[ 489.90]  < return
[ 490.01]  > nthFixed(idx: int32, values: int64[7]): int64
[ 490.06]  < return
[ 490.08]  > nthFixed(idx: int32, values: int64[7]): int64
[ 490.12]  < return
[ 490.17]  > nthFixed(idx: int32, values: int64[7]): int64
[ 490.19]  < return
[ 490.21]  > nthArray(idx: int32, values: int64[*]): int64
[ 490.23]  < return
[ 490.27]  > nthArray(idx: int32, values: int64[*]): int64
[ 490.29]  < return
[ 490.33]  > nthArray(idx: int32, values: int64[*]): int64
[ 490.35]  < return
[ 490.37]  > nthSlice(idx: int32, values: int64[]): int64
[ 490.39]  < return
[ 490.42]  > nthSlice(idx: int32, values: int64[]): int64
[ 490.44]  < return
[ 490.57]  > nthFixed(idx: int32, values: int64[7]): int64
[ 490.59]  < return
[ 490.62]  > nthFixed(idx: int32, values: int64[7]): int64
[ 490.65]  < return
[ 490.67]  > nthFixed(idx: int32, values: int64[7]): int64
[ 490.71]  < return
[ 490.73]  > nthArray(idx: int32, values: int64[*]): int64
[ 490.75]  < return
[ 490.79]  > nthArray(idx: int32, values: int64[*]): int64
[ 490.81]  < return
[ 490.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 490.85]  < return
[ 490.87]  > nthSlice(idx: int32, values: int64[]): int64
[ 490.92]  < return
[ 490.96]  > nthSlice(idx: int32, values: int64[]): int64
[ 490.99]  < return
[ 491.09]  > nthFixed(idx: int32, values: int64[7]): int64
[ 491.10]  < return
[ 491.13]  > nthFixed(idx: int32, values: int64[7]): int64
[ 491.14]  < return
[ 491.17]  > nthFixed(idx: int32, values: int64[7]): int64
[ 491.19]  < return
[ 491.21]  > nthArray(idx: int32, values: int64[*]): int64
[ 491.23]  < return
[ 491.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 491.27]  < return
[ 491.30]  > nthArray(idx: int32, values: int64[*]): int64
[ 491.31]  < return
[ 491.34]  > nthSlice(idx: int32, values: int64[]): int64
[ 491.38]  < return
[ 491.41]  > nthSlice(idx: int32, values: int64[]): int64
[ 491.45]  < return
[ 491.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 491.60]  < return
[ 491.64]  > nthFixed(idx: int32, values: int64[7]): int64
[ 491.66]  < return
[ 491.68]  > nthFixed(idx: int32, values: int64[7]): int64
[ 491.70]  < return
[ 491.73]  > nthArray(idx: int32, values: int64[*]): int64
[ 491.74]  < return
[ 491.77]  > nthArray(idx: int32, values: int64[*]): int64
[ 491.80]  < return
[ 491.82]  > nthArray(idx: int32, values: int64[*]): int64
[ 491.85]  < return
[ 491.89]  > nthSlice(idx: int32, values: int64[]): int64
[ 491.91]  < return
[ 491.94]  > nthSlice(idx: int32, values: int64[]): int64
[ 491.97]  < return
[ 492.03]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 492.05]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(1)
	test/lang/method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 492.20]   < return
[ 492.21]  < return
[ 492.24]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 492.26]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(1)
	test/lang/method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 492.37]   < return
[ 492.38]  < return
[ 492.39]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 492.41]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:85: debug: extension.staticMethod
[ 492.46]   < return
[ 492.48]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 492.50]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(2)
	test/lang/method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 492.66]    < return
[ 492.67]   < return
[ 492.68]  < return
[ 492.70]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 492.72]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:91: debug: extension.virtualMethod
[ 492.74]   < return
[ 492.75]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 492.77]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(2)
	test/lang/method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 492.90]    < return
[ 492.95]   < return
[ 492.96]  < return
[ 492.98]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 493.01]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(3)
	test/lang/method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 493.16]   < return
[ 493.17]  < return
[ 493.22]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 493.23]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 493.39]   < return
[ 493.40]  < return
[ 493.42]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 493.46]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 493.60]   < return
[ 493.61]  < return
[ 493.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 493.66]  < return
[ 493.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 493.72]  < return
[ 493.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 493.77]  < return
[ 493.80]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 493.83]  < return
[ 493.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 493.91]  < return
[ 493.96]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 494.02]  < return
[ 494.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 494.09]  < return
[ 494.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 494.14]  < return
[ 494.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 494.20]  < return
[ 494.23]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 494.26]  < return
[ 494.31]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 494.33]  < return
[ 494.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 494.39]  < return
[ 494.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 494.51]  < return
[ 494.55]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 494.58]  < return
[ 494.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 494.65]  < return
[ 494.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 494.74]  < return
[ 494.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 494.81]  < return
[ 494.86]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 494.88]  < return
[ 494.92]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 494.96]  < return
[ 495.01]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 495.04]  < return
[ 495.08]  > halt(): void
[ 495.10]  < return
[ 495.11] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/std/debug.ci:48: NotEquals: typename(<NotEquals>)
lib/std/debug.ci:64: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math/Complex.ci:2: Complex: typename(<Complex>)
lib/std/math/Complex.ci:24: Complex: function(<Complex>)
lib/std/math/Complex.ci:31: Complex: function(<Complex>)
lib/std/math/Complex.ci:83: div: function(<div>)
lib/std/math/Complex.ci:114: inv: function(<inv>)
lib/std/math/Complex.ci:132: pow: function(<pow>)
lib/std/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
lib/std/math/Vector4f.ci:26: vec4f: function(<vec4f>)
lib/std/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
lib/std/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:87: mul: function(<mul>)
lib/std/math/Matrix4f.ci:106: rotation: function(<rotation>)
lib/std/math/Matrix4f.ci:158: translation: function(<translation>)
lib/std/math/Matrix4f.ci:168: scale: function(<scale>)
lib/std/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
lib/std/math/Vector2d.ci:14: vec2d: function(<vec2d>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:233: append: function(<append>)
lib/std/string.ci:261: append: function(<append>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[](...)
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius(<boilC>)
test/lang/overload.inline.ci:29: boilF: Fahrenheit(<boilF>)
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(...)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(...)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(...)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(...)
test/lang/initByRef.ci:56: varBool: variant(...)
test/lang/initByRef.ci:57: varChar: variant(...)
test/lang/initByRef.ci:58: varInt8: variant(...)
test/lang/initByRef.ci:59: varInt16: variant(...)
test/lang/initByRef.ci:60: varInt32: variant(...)
test/lang/initByRef.ci:61: varInt64: variant(...)
test/lang/initByRef.ci:62: varUint8: variant(...)
test/lang/initByRef.ci:63: varUint16: variant(...)
test/lang/initByRef.ci:64: varUint32: variant(...)
test/lang/initByRef.ci:65: varUint64: variant(...)
test/lang/initByRef.ci:66: varFloat32: variant(...)
test/lang/initByRef.ci:67: varFloat64: variant(...)
test/lang/initByRef.ci:68: varTypename: variant(...)
test/lang/initByRef.ci:69: varFunction: variant(...)
test/lang/initByRef.ci:70: varPointer: variant(...)
test/lang/initByRef.ci:71: varVariant: variant(...)
test/lang/initByRef.ci:72: varObject: variant(...)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(...)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(...)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(248664)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(248360)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/std/number.ci:3: pi64: float64(3.141593)
test/std/number.ci:4: e64: float64(2.718282)
test/std/number.ci:6: pi32: float32(3.141593)
test/std/number.ci:7: e32: float32(2.718282)
test/std/number.ci:14: r_comp: int32(112)
test/std/number.ci:15: g_comp: int32(252)
test/std/number.ci:16: b_comp: int32(248)
test/std/number.ci:18: r5g6b5: int32(30719)
test/std/number.ci:19: r8g8b8: int32(7404792)
test/std/number.ci:21: zxtR5: int32(14)
test/std/number.ci:22: zxtG6: int32(63)
test/std/number.ci:23: zxtB5: int32(31)
test/std/number.ci:25: sxtR5: int32(14)
test/std/number.ci:26: sxtG6: int32(-1)
test/std/number.ci:27: sxtB5: int32(-1)
test/std/number.ci:29: zxtR8: int32(112)
test/std/number.ci:30: zxtG8: int32(252)
test/std/number.ci:31: zxtB8: int32(248)
test/std/number.ci:33: sxtR8: int32(112)
test/std/number.ci:34: sxtG8: int32(-4)
test/std/number.ci:35: sxtB8: int32(-8)
test/std/number.ci:37: testSin_f64: float64(1.000000)
test/std/number.ci:38: testCos_f64: float64(0.000000)
test/std/number.ci:39: testTan_f64: float64(1.000000)
test/std/number.ci:40: testLog_f64: float64(3.000000)
test/std/number.ci:41: testExp_f64: float64(2.718282)
test/std/number.ci:42: testPow_f64: float64(3.141593)
test/std/number.ci:43: testSqrt_f64: float64(3.141593)
test/std/number.ci:44: testAtan_f64: float64(1.262627)
test/std/number.ci:46: testSin_f32: float32(1.000000)
test/std/number.ci:47: testCos_f32: float32(-0.000000)
test/std/number.ci:48: testTan_f32: float32(1.000000)
test/std/number.ci:49: testLog_f32: float32(3.000000)
test/std/number.ci:50: testExp_f32: float32(2.718282)
test/std/number.ci:51: testPow_f32: float32(3.141593)
test/std/number.ci:52: testSqrt_f32: float32(3.141593)
test/std/number.ci:53: testAtan_f32: float32(1.262627)
test/std/number.ci:55: testPopulation_u32: int32(14)
test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/std/number.ci:57: testBitScanReverse_u32: int32(14)
test/std/number.ci:58: testBitScanForward_u32: int32(0)
test/std/number.ci:59: testHighBit_u32: int32(16384)
test/std/number.ci:60: testLowBit_u32: int32(1)
test/std/number.ci:62: testZeroExtend_u32: int32(31)
test/std/number.ci:63: testSignExtend_u32: int32(-1)
test/std/number.ci:65: testZeroExtend_u64: int32(31)
test/std/number.ci:66: testSignExtend_u64: int32(-1)
test/std/memory.ci:7: p1: pointer(<?>)
test/std/memory.ci:8: p2: pointer(<?>)
test/std/memory.ci:9: p3: pointer(<?>)
test/std/memory.ci:10: p4: pointer(<?>)
test/std/memory.ci:23: val1: int64(0)
test/std/memory.ci:24: val2: int64(42)
test/std/tryExec.ci:11: noError: function(<noError>)
test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/std/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/std/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/std/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/std/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/std/tryExec.ci:46: tryExecErr0: int32(0)
test/std/tryExec.ci:47: tryExecErr1: int32(1)
test/std/tryExec.ci:48: tryExecErr2: int32(2)
test/std/tryExec.ci:49: tryExecErr3: int32(3)
test/std/tryExec.ci:50: tryExecErr4: int32(4)
test/std/tryExec.ci:51: tryExecErr5: int32(5)
test/std/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7](...)
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*](...)
test/lang/array.ci:64: arrSliceInitFixed: int64[](...)
test/lang/array.ci:67: arrArrayInitSlice: int64[*](...)
test/lang/array.ci:68: arrSliceInitSlice: int64[](...)
test/lang/array.ci:71: arrArrayInitPtr: int64[*](...)
test/lang/array.ci:81: strFixed: char[7](...)
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[](...)
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner(<RecordMemberTest.globalRec>)
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner(<RecordMemberTest.globalRecInit>)
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner(<RecordMemberTest.globalConstantRec>)
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest(<recordMemberTest>)
test/lang/method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:57: globalFunction: function(<globalFunction>)
test/lang/method.ci:62: recordMethodTest: RecordMethodTest(<recordMethodTest>)
test/lang/method.ci:84: staticMethod: function(<staticMethod>)
test/lang/method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8(<black>)
test/lang/recUnion.ci:27: green: rgbU8(<green>)
test/lang/recUnion.ci:28: white: rgbU8(<white>)
test/lang/recUnion.ci:30: cyan: color(<cyan>)
test/lang/recUnion.ci:31: blue: color(<blue>)
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/std/test.math.ci:67: testMathCmp_f32: bool(1)
test/std/test.math.ci:68: testMathCmp_f64: bool(1)
test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194024(4.0 Mb)
memory[used] @000000; size: 376862(368.0 Kb)
memory[heap] @05c01e; size: 2768608(2.6 Mb)
memory[stack] @1fff44; size: 1048506(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 351360(343.1 Kb)
memory[code] @000000; size: 20339(19.9 Kb)
memory[data] @000000; size: 2674(2.6 Kb)

---------- heap memory:
memory[free] @05c038; size: 2768560(2.6 Mb)

---------- Profile functions: 79/119, coverage: 66.39%
::[.005900, .005900): exec(2), time(0.021 ms): halt(): void
::[.005ba0, .005ba0): exec(0), time(0.000 ms): variant.is(var: variant, type: typename): bool
::[.005e38, .005e38): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006178, .006178): exec(3), time(0.056 ms): typename.base(type: typename): typename
::[.006378, .006378): exec(2), time(0.052 ms): typename.file(type: typename): .cstr
::[.006578, .006578): exec(2), time(0.035 ms): typename.line(type: typename): int32
::[.006778, .006778): exec(2), time(0.046 ms): typename.name(type: typename): .cstr
::[.006a18, .006a18): exec(0), time(0.000 ms): object.create(type: typename): pointer
::[.006cb0, .006cb0): exec(0), time(0.000 ms): object.as(obj: object, type: typename): pointer
::[.007470, .007470): exec(40), time(2.110 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.007d50, .007d50): exec(7), time(4.030 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007ff0, .007ff0): exec(8), time(0.197 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.008328, .008328): exec(2), time(0.059 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.008660, .008660): exec(2), time(0.047 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008990, .008990): exec(1), time(0.023 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.008c38, .008c38): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.008e40, .008e40): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008fa8, .008fa8): exec(0), time(0.000 ms): System.rand(): int32
::[.009110, .009110): exec(0), time(0.000 ms): System.time(): int32
::[.009278, .009278): exec(0), time(0.000 ms): System.clock(): int32
::[.0093e0, .0093e0): exec(0), time(0.000 ms): System.millis(): int64
::[.0095e0, .0095e0): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.009918, .009918): exec(7), time(0.175 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.009c48, .009c48): exec(7), time(0.136 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.009e48, .009e48): exec(1), time(0.016 ms): uint32.pop(value: int32): int32
::[.00a048, .00a048): exec(1), time(0.014 ms): uint32.swap(value: int32): int32
::[.00a248, .00a248): exec(1), time(0.015 ms): uint32.bsr(value: int32): int32
::[.00a448, .00a448): exec(1), time(0.015 ms): uint32.bsf(value: int32): int32
::[.00a648, .00a648): exec(1), time(0.031 ms): uint32.hib(value: int32): int32
::[.00a848, .00a848): exec(1), time(0.029 ms): uint32.lob(value: int32): int32
::[.00ab70, .00ab70): exec(1), time(0.015 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00ae98, .00ae98): exec(1), time(0.043 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00b098, .00b098): exec(1), time(0.017 ms): float32.sin(x: float32): float32
::[.00b298, .00b298): exec(1), time(0.015 ms): float32.cos(x: float32): float32
::[.00b498, .00b498): exec(1), time(0.016 ms): float32.tan(x: float32): float32
::[.00b698, .00b698): exec(1), time(0.029 ms): float32.log(x: float32): float32
::[.00b898, .00b898): exec(1), time(0.029 ms): float32.exp(x: float32): float32
::[.00bb30, .00bb30): exec(1), time(0.016 ms): float32.pow(x: float32, y: float32): float32
::[.00bd30, .00bd30): exec(1), time(0.034 ms): float32.sqrt(x: float32): float32
::[.00bfc8, .00bfc8): exec(1), time(0.024 ms): float32.atan2(x: float32, y: float32): float32
::[.00c1c0, .00c1c0): exec(1), time(0.037 ms): float64.sin(x: float64): float64
::[.00c3b8, .00c3b8): exec(1), time(0.020 ms): float64.cos(x: float64): float64
::[.00c5b0, .00c5b0): exec(1), time(0.015 ms): float64.tan(x: float64): float64
::[.00c7a8, .00c7a8): exec(1), time(0.018 ms): float64.log(x: float64): float64
::[.00c9a0, .00c9a0): exec(5), time(0.143 ms): float64.exp(x: float64): float64
::[.00cc30, .00cc30): exec(1), time(0.018 ms): float64.pow(x: float64, y: float64): float64
::[.00ce28, .00ce28): exec(3), time(0.055 ms): float64.sqrt(x: float64): float64
::[.00d0b8, .00d0b8): exec(3), time(0.053 ms): float64.atan2(x: float64, y: float64): float64
lib/std/debug.ci:64:[.055c80, .055cde): exec(8), time(0.135 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.055ce0, .055d36): exec(10), time(0.216 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.055d38, .055d50): exec(6), time(0.397-0.198 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.055d50, .055d62): exec(3), time(0.033 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.055d68, .055d7a): exec(4), time(0.058 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.055d80, .055d9b): exec(11), time(0.154 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.055da0, .055dbb): exec(11), time(0.174 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.055dc0, .055dd1): exec(1), time(0.011 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.055dd8, .055de9): exec(1), time(0.015 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.055df0, .055e01): exec(1), time(0.012 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.055e08, .055e19): exec(1), time(0.016 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.055e20, .055e3e): exec(2), time(0.042 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.055e40, .055e5e): exec(2), time(0.036 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.055e60, .055eaf): exec(2), time(0.094 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.055eb0, .055eff): exec(2), time(0.121 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.055f00, .055f28): exec(4), time(0.221 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.055f28, .055f57): exec(3), time(0.148 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.055f58, .055f91): exec(1), time(0.015 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.055f98, .055fd1): exec(1), time(0.014 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.055fd8, .056127): exec(2), time(0.118 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.056128, .0562a2): exec(1), time(0.097-0.018 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.0562a8, .056399): exec(1), time(0.109-0.057 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.0563a0, .0563eb): exec(1), time(0.109-0.070 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.0563f0, .05649d): exec(2), time(0.197-0.076 ms): Math.asin(x: float64): float64
lib/std/math/Complex.ci:24:[.0564a0, .0564a7): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math/Complex.ci:31:[.0564a8, .0564af): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math/Complex.ci:83:[.0564b0, .05652b): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math/Complex.ci:114:[.056530, .05654f): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math/Complex.ci:132:[.056550, .0565b4): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/math/Vector4f.ci:26:[.0565b8, .0565c5): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/std/math/Matrix4f.ci:62:[.0565c8, .0565f9): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/std/math/Matrix4f.ci:75:[.056600, .056615): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/std/math/Matrix4f.ci:87:[.056618, .0567b9): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
lib/std/math/Matrix4f.ci:106:[.0567c0, .0569cc): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
lib/std/math/Matrix4f.ci:158:[.0569d0, .056a28): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
lib/std/math/Matrix4f.ci:168:[.056a28, .056b01): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
lib/std/math/Vector2d.ci:14:[.056b08, .056b0f): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/std/string.ci:4:[.056b10, .056b36): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.056b38, .056b6a): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.056b70, .056ba2): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.056ba8, .056bf1): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.056bf8, .056c76): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.056c78, .056cb7): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.056cb8, .056cff): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.056d00, .056d24): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.056d28, .056d36): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.056d38, .056d8c): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.056da0, .057063): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
lib/std/string.ci:233:[.057068, .05714b): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
lib/std/string.ci:261:[.057160, .05719f): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
test/lang/function.ci:4:[.057630, .057631): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.057638, .057640): exec(2), time(0.067 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.057678, .057680): exec(2), time(0.041 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.057680, .0576b6): exec(753), time(26.680 ms): fib(n: uint32): uint32
test/std/tryExec.ci:11:[.057988, .057989): exec(1), time(0.019 ms): noError(ptr: pointer): void
test/std/tryExec.ci:14:[.057990, .0579a8): exec(128-128), time(3.631 ms): stackOverflow(ptr: pointer): void
test/std/tryExec.ci:19:[.0579a8, .0579b4): exec(1-1), time(0.018 ms): divisionByZero(args: pointer): void
test/std/tryExec.ci:23:[.0579b8, .0579fc): exec(1-1), time(0.139-0.104 ms): abortExecution(args: pointer): void
test/std/tryExec.ci:37:[.057a00, .057a0d): exec(1-1), time(0.018 ms): invalidMemoryAccess(args: pointer): void
test/std/tryExec.ci:42:[.057a10, .057a12): exec(1-1), time(0.016 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.057ae8, .057aec): exec(5), time(0.136 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.057af0, .057afc): exec(21), time(0.514 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.057b00, .057b0c): exec(21), time(0.479 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.057b10, .057b1c): exec(14), time(0.397 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:10:[.057b70, .057b97): exec(3), time(0.567-0.467 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.057ba0, .057bc7): exec(4), time(0.688-0.528 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:47:[.057bc8, .057bef): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:57:[.057bf0, .057c17): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:84:[.057c28, .057c6a): exec(1), time(0.290-0.247 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:90:[.057c70, .057caf): exec(1), time(0.262-0.199 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.0586f4, .05c01e): exec(1), time(48.348-38.403 ms): .main

---------- Profile statements: 875/1208, coverage: 72.43%
lib/std/debug.ci:66:[.055c89, .055c8a) exec(8), time(0.069-0.069 ms): <assertEq+9>
lib/std/debug.ci:65:[.055c80, .055c8a) exec(8-8), time(0.000 ms): <assertEq+0>
lib/std/debug.ci:69:[.055c8e, .055c99) exec(0), time(0.000 ms): <assertEq+14>
lib/std/debug.ci:70:[.055c99, .055ca4) exec(0), time(0.000 ms): <assertEq+25>
lib/std/debug.ci:71:[.055ca4, .055ca7) exec(0), time(0.000 ms): <assertEq+36>
::[.055ca7, .055cb3) exec(0), time(0.000 ms): <assertEq+39>
lib/std/debug.ci:68:[.055c8a, .055cb3) exec(0), time(0.000 ms): <assertEq+10>
lib/std/debug.ci:73:[.055cb3, .055cd9) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.055cf8, .055d09) exec(3), time(0.091-0.091 ms): <modf+24>
lib/std/math.ci:26:[.055d09, .055d10) exec(3), time(0.004-0.004 ms): <modf+41>
lib/std/math.ci:27:[.055d10, .055d13) exec(3), time(0.030-0.030 ms): <modf+48>
lib/std/math.ci:24:[.055cf0, .055d17) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.055d17, .055d1b) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.055d1b, .055d1f) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.055ce0, .055d1f) exec(10-3), time(0.008-0.008 ms): <modf+0>
lib/std/math.ci:32:[.055d1f, .055d2b) exec(7), time(0.006-0.006 ms): <modf+63>
lib/std/math.ci:33:[.055d2b, .055d33) exec(7), time(0.008-0.008 ms): <modf+75>
lib/std/math.ci:34:[.055d33, .055d36) exec(7), time(0.074-0.074 ms): <modf+83>
lib/std/math.ci:48:[.055d38, .055d39) exec(6), time(0.006-0.006 ms): <floor+0>
lib/std/math.ci:49:[.055d39, .055d4d) exec(6), time(0.264-0.264 ms): <floor+1>
lib/std/math.ci:50:[.055d4d, .055d50) exec(6), time(0.059-0.059 ms): <floor+21>
lib/std/math.ci:79:[.055d58, .055d5e) exec(1), time(0.007-0.007 ms): <abs+8>
lib/std/math.ci:78:[.055d50, .055d5e) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.055d5e, .055d62) exec(2), time(0.028-0.028 ms): <abs+14>
lib/std/math.ci:87:[.055d70, .055d76) exec(1), time(0.007-0.007 ms): <abs+8>
lib/std/math.ci:86:[.055d68, .055d76) exec(4-1), time(0.003-0.003 ms): <abs+0>
lib/std/math.ci:89:[.055d76, .055d7a) exec(3), time(0.023-0.023 ms): <abs+14>
lib/std/math.ci:95:[.055d8f, .055d97) exec(4), time(0.029-0.029 ms): <absMod+15>
lib/std/math.ci:94:[.055d80, .055d97) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:97:[.055d97, .055d9b) exec(7), time(0.052-0.052 ms): <absMod+23>
lib/std/math.ci:103:[.055daf, .055db7) exec(4), time(0.034-0.034 ms): <absMod+15>
lib/std/math.ci:102:[.055da0, .055db7) exec(11-4), time(0.009-0.009 ms): <absMod+0>
lib/std/math.ci:105:[.055db7, .055dbb) exec(7), time(0.069-0.069 ms): <absMod+23>
lib/std/math.ci:117:[.055dc9, .055dcd) exec(1), time(0.007-0.007 ms): <min+9>
lib/std/math.ci:116:[.055dc0, .055dcd) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.055dcd, .055dd1) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.055de1, .055de5) exec(1), time(0.010-0.010 ms): <min+9>
lib/std/math.ci:124:[.055dd8, .055de5) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.055de5, .055de9) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.055df9, .055dfd) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.055df0, .055dfd) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.055dfd, .055e01) exec(1), time(0.008-0.008 ms): <max+13>
lib/std/math.ci:147:[.055e11, .055e15) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.055e08, .055e15) exec(1), time(0.002-0.002 ms): <max+0>
lib/std/math.ci:149:[.055e15, .055e19) exec(1), time(0.010-0.010 ms): <max+13>
lib/std/math.ci:161:[.055e29, .055e2d) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.055e20, .055e2d) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:164:[.055e36, .055e3a) exec(1), time(0.007-0.007 ms): <clamp+22>
lib/std/math.ci:163:[.055e2d, .055e3a) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:166:[.055e3a, .055e3e) exec(1), time(0.008-0.008 ms): <clamp+26>
lib/std/math.ci:172:[.055e49, .055e4d) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.055e40, .055e4d) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:175:[.055e56, .055e5a) exec(1), time(0.011-0.011 ms): <clamp+22>
lib/std/math.ci:174:[.055e4d, .055e5a) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:177:[.055e5a, .055e5e) exec(1), time(0.010-0.010 ms): <clamp+26>
lib/std/math.ci:203:[.055e68, .055e74) exec(1), time(0.010-0.010 ms): <min+8>
lib/std/math.ci:202:[.055e60, .055e74) exec(2-1), time(0.002-0.002 ms): <min+0>
lib/std/math.ci:205:[.055e74, .055e77) exec(1), time(0.001-0.001 ms): <min+20>
lib/std/math.ci:208:[.055e90, .055e9b) exec(2), time(0.003-0.003 ms): <min+48>
lib/std/math.ci:207:[.055e80, .055e9b) exec(8-2), time(0.009-0.009 ms): <min+32>
lib/std/math.ci:206:[.055e9b, .055e9f) exec(8), time(0.005-0.005 ms): <min+59>
lib/std/math.ci:206:[.055e9f, .055ea8) exec(9), time(0.010-0.010 ms): <min+63>
lib/std/math.ci:206:[.055e77, .055eac) exec(1), time(0.002-0.002 ms): <min+23>
lib/std/math.ci:211:[.055eac, .055eaf) exec(1), time(0.012-0.012 ms): <min+76>
lib/std/math.ci:217:[.055eb8, .055ec4) exec(1), time(0.010-0.010 ms): <max+8>
lib/std/math.ci:216:[.055eb0, .055ec4) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.055ec4, .055ec7) exec(1), time(0.001-0.001 ms): <max+20>
lib/std/math.ci:222:[.055ee0, .055eeb) exec(2), time(0.002-0.002 ms): <max+48>
lib/std/math.ci:221:[.055ed0, .055eeb) exec(8-2), time(0.006-0.006 ms): <max+32>
lib/std/math.ci:220:[.055eeb, .055eef) exec(8), time(0.007-0.007 ms): <max+59>
lib/std/math.ci:220:[.055eef, .055ef8) exec(9), time(0.029-0.029 ms): <max+63>
lib/std/math.ci:220:[.055ec7, .055efc) exec(1), time(0.002-0.002 ms): <max+23>
lib/std/math.ci:225:[.055efc, .055eff) exec(1), time(0.011-0.011 ms): <max+76>
lib/std/math.ci:230:[.055f00, .055f01) exec(4), time(0.022-0.022 ms): <sum+0>
lib/std/math.ci:232:[.055f06, .055f14) exec(13), time(0.019-0.019 ms): <sum+6>
lib/std/math.ci:231:[.055f14, .055f18) exec(13), time(0.006-0.006 ms): <sum+20>
lib/std/math.ci:231:[.055f18, .055f21) exec(17), time(0.020-0.020 ms): <sum+24>
lib/std/math.ci:231:[.055f01, .055f25) exec(4), time(0.009-0.009 ms): <sum+1>
lib/std/math.ci:234:[.055f25, .055f28) exec(4), time(0.086-0.086 ms): <sum+37>
lib/std/math.ci:257:[.055f28, .055f29) exec(3), time(0.002-0.002 ms): <eval+0>
lib/std/math.ci:259:[.055f33, .055f44) exec(11), time(0.028-0.028 ms): <eval+11>
lib/std/math.ci:258:[.055f44, .055f48) exec(11), time(0.009-0.009 ms): <eval+28>
lib/std/math.ci:258:[.055f48, .055f50) exec(14), time(0.014-0.014 ms): <eval+32>
lib/std/math.ci:258:[.055f29, .055f54) exec(3), time(0.006-0.006 ms): <eval+1>
lib/std/math.ci:261:[.055f54, .055f57) exec(3), time(0.039-0.039 ms): <eval+44>
lib/std/math.ci:268:[.055f6d, .055f75) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.055f61, .055f75) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:273:[.055f85, .055f8d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.055f79, .055f8d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.055f58, .055f8d) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:276:[.055f8d, .055f91) exec(1), time(0.008-0.008 ms): <cmp+53>
lib/std/math.ci:283:[.055fad, .055fb5) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.055fa1, .055fb5) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:288:[.055fc5, .055fcd) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.055fb9, .055fcd) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.055f98, .055fcd) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:291:[.055fcd, .055fd1) exec(1), time(0.008-0.008 ms): <cmp+53>
lib/std/math.ci:309:[.055fd8, .055fda) exec(2), time(0.002-0.002 ms): <sinCos+0>
lib/std/math.ci:311:[.055fe2, .055fe3) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.055fe3, .055feb) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.055fda, .055feb) exec(2), time(0.003-0.003 ms): <sinCos+2>
lib/std/math.ci:315:[.055feb, .055fec) exec(2), time(0.002-0.002 ms): <sinCos+19>
lib/std/math.ci:316:[.055fec, .056004) exec(2), time(0.003-0.003 ms): <sinCos+20>
lib/std/math.ci:318:[.056014, .056015) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.056015, .056027) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.056027, .05602b) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.05602b, .05602c) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.05602c, .05604a) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.05604a, .05605c) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.056064, .056067) exec(2), time(0.002-0.002 ms): <sinCos+140>
lib/std/math.ci:328:[.056067, .05606f) exec(2), time(0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:329:[.05606f, .056076) exec(2), time(0.001-0.001 ms): <sinCos+151>
lib/std/math.ci:330:[.056076, .05607c) exec(2), time(0.002-0.002 ms): <sinCos+158>
lib/std/math.ci:317:[.056004, .056080) exec(2), time(0.018-0.018 ms): <sinCos+44>
lib/std/math.ci:333:[.056088, .056096) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:332:[.056080, .056096) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:336:[.0560a2, .0560a3) exec(1), time(0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:335:[.056096, .0560a3) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:339:[.0560a3, .0560a8) exec(2), time(0.002-0.002 ms): <sinCos+203>
lib/std/math.ci:340:[.0560a8, .0560e8) exec(2), time(0.006-0.006 ms): <sinCos+208>
lib/std/math.ci:341:[.0560e8, .05611b) exec(2), time(0.005-0.005 ms): <sinCos+272>
lib/std/math.ci:342:[.05611b, .056127) exec(2), time(0.016-0.016 ms): <sinCos+323>
lib/std/math.ci:365:[.056128, .056129) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:366:[.056129, .05612a) exec(1), time(0.001-0.001 ms): <tan+1>
lib/std/math.ci:369:[.056132, .056137) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.056137, .056141) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.05612a, .056141) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:372:[.056141, .056159) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:374:[.056159, .05615a) exec(1), time(0.001-0.001 ms): <tan+49>
lib/std/math.ci:375:[.05615a, .05616a) exec(1), time(0.029-0.029 ms): <tan+50>
lib/std/math.ci:376:[.05616a, .056173) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:380:[.056187, .056195) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:381:[.056195, .05619f) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:384:[.0561af, .0561ba) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.0561ba, .0561c4) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.0561d4, .0561e2) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.0561e2, .0561ed) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.0561c8, .0561ed) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.0561a3, .0561ed) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.05617b, .0561ed) exec(1), time(0.002-0.002 ms): <tan+83>
lib/std/math.ci:378:[.056173, .0561ed) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.0561ed, .0561f2) exec(1), time(0.002-0.002 ms): <tan+197>
lib/std/math.ci:393:[.0561f2, .056232) exec(1), time(0.003-0.003 ms): <tan+202>
lib/std/math.ci:394:[.056232, .056259) exec(1), time(0.003-0.003 ms): <tan+266>
lib/std/math.ci:398:[.05626a, .05627a) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.056262, .05627a) exec(1), time(0.002-0.002 ms): <tan+314>
lib/std/math.ci:400:[.05627a, .056288) exec(1), time(0.002-0.002 ms): <tan+338>
lib/std/math.ci:396:[.056259, .056288) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.056291, .05629b) exec(0), time(0.000 ms): <tan+361>
lib/std/math.ci:402:[.056288, .05629b) exec(1), time(0.001-0.001 ms): <tan+352>
lib/std/math.ci:405:[.05629b, .0562a2) exec(1), time(0.011-0.011 ms): <tan+371>
lib/std/math.ci:421:[.0562a8, .0562a9) exec(1), time(0.001-0.001 ms): <sinh+0>
lib/std/math.ci:423:[.0562b1, .0562b6) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.0562b6, .0562c0) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.0562a9, .0562c0) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:428:[.0562d0, .0562e7) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.0562c0, .0562e7) exec(1), time(0.002-0.002 ms): <sinh+24>
lib/std/math.ci:431:[.0562e7, .0562e8) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:433:[.0562f8, .056312) exec(1), time(0.080-0.080 ms): <sinh+80>
lib/std/math.ci:436:[.056316, .05631b) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.05631b, .056350) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.056350, .05637b) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.0562e8, .05637f) exec(1), time(0.081-0.081 ms): <sinh+64>
lib/std/math.ci:442:[.056388, .056392) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.05637f, .056392) exec(1), time(0.002-0.002 ms): <sinh+215>
lib/std/math.ci:444:[.056392, .056399) exec(1), time(0.011-0.011 ms): <sinh+234>
lib/std/math.ci:450:[.0563a8, .0563ad) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.0563a0, .0563ad) exec(1), time(0.002-0.002 ms): <cosh+0>
lib/std/math.ci:453:[.0563bd, .0563d0) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.0563ad, .0563d0) exec(1), time(0.002-0.002 ms): <cosh+13>
lib/std/math.ci:455:[.0563d0, .0563eb) exec(1), time(0.098-0.098 ms): <cosh+48>
lib/std/math.ci:466:[.0563f8, .0563fc) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.0563f0, .0563fc) exec(2), time(0.004-0.004 ms): <asin+0>
lib/std/math.ci:469:[.0563fc, .0563fd) exec(2), time(0.001-0.001 ms): <asin+12>
lib/std/math.ci:471:[.056405, .05640f) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.05640f, .056414) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.0563fd, .056414) exec(2), time(0.002-0.002 ms): <asin+13>
lib/std/math.ci:477:[.056424, .056434) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.056414, .056434) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:480:[.056434, .056447) exec(2), time(0.061-0.061 ms): <asin+68>
lib/std/math.ci:482:[.056457, .056475) exec(0), time(0.000 ms): <asin+103>
lib/std/math.ci:485:[.056479, .056483) exec(2), time(0.056-0.056 ms): <asin+137>
lib/std/math.ci:481:[.056447, .056483) exec(2-2), time(0.000 ms): <asin+87>
lib/std/math.ci:489:[.05648c, .056496) exec(0), time(0.000 ms): <asin+156>
lib/std/math.ci:488:[.056483, .056496) exec(2), time(0.003-0.003 ms): <asin+147>
lib/std/math.ci:491:[.056496, .05649d) exec(2), time(0.032-0.032 ms): <asin+166>
::[.0564a3, .0564a6) exec(0), time(0.000 ms): <Complex+3>
lib/std/math/Complex.ci:25:[.0564a0, .0564a7) exec(0), time(0.000 ms): <Complex+0>
lib/std/math/Complex.ci:34:[.0564ab, .0564ae) exec(0), time(0.000 ms): <Complex+3>
lib/std/math/Complex.ci:32:[.0564a8, .0564af) exec(0), time(0.000 ms): <Complex+0>
lib/std/math/Complex.ci:88:[.0564cf, .0564d4) exec(0), time(0.000 ms): <div+31>
lib/std/math/Complex.ci:89:[.0564d4, .0564dc) exec(0), time(0.000 ms): <div+36>
lib/std/math/Complex.ci:92:[.0564e9, .0564f6) exec(0), time(0.000 ms): <div+57>
lib/std/math/Complex.ci:90:[.0564dc, .0564fb) exec(0), time(0.000 ms): <div+44>
lib/std/math/Complex.ci:87:[.0564b0, .0564ff) exec(0), time(0.000 ms): <div+0>
lib/std/math/Complex.ci:95:[.0564ff, .056504) exec(0), time(0.000 ms): <div+79>
lib/std/math/Complex.ci:96:[.056504, .05650c) exec(0), time(0.000 ms): <div+84>
lib/std/math/Complex.ci:99:[.056519, .056526) exec(0), time(0.000 ms): <div+105>
lib/std/math/Complex.ci:97:[.05650c, .05652b) exec(0), time(0.000 ms): <div+92>
lib/std/math/Complex.ci:115:[.056530, .05653b) exec(0), time(0.000 ms): <inv+0>
lib/std/math/Complex.ci:118:[.056542, .05654a) exec(0), time(0.000 ms): <inv+18>
lib/std/math/Complex.ci:116:[.05653b, .05654f) exec(0), time(0.000 ms): <inv+11>
lib/std/math/Complex.ci:133:[.056550, .056567) exec(0), time(0.000 ms): <pow+0>
lib/std/math/Complex.ci:134:[.056567, .056577) exec(0), time(0.000 ms): <pow+23>
lib/std/math/Complex.ci:135:[.056577, .056586) exec(0), time(0.000 ms): <pow+39>
lib/std/math/Complex.ci:136:[.056586, .056599) exec(0), time(0.000 ms): <pow+54>
lib/std/math/Complex.ci:139:[.0565a4, .0565af) exec(0), time(0.000 ms): <pow+84>
lib/std/math/Complex.ci:137:[.056599, .0565b4) exec(0), time(0.000 ms): <pow+73>
lib/std/math/Vector4f.ci:27:[.0565bb, .0565be) exec(0), time(0.000 ms): <vec4f+3>
lib/std/math/Vector4f.ci:27:[.0565be, .0565c1) exec(0), time(0.000 ms): <vec4f+6>
lib/std/math/Vector4f.ci:27:[.0565c1, .0565c4) exec(0), time(0.000 ms): <vec4f+9>
lib/std/math/Vector4f.ci:27:[.0565b8, .0565c5) exec(0), time(0.000 ms): <vec4f+0>
lib/std/math/Matrix4f.ci:67:[.0565cb, .0565ce) exec(0), time(0.000 ms): <mat4f+3>
lib/std/math/Matrix4f.ci:67:[.0565ce, .0565d1) exec(0), time(0.000 ms): <mat4f+6>
lib/std/math/Matrix4f.ci:67:[.0565d1, .0565d4) exec(0), time(0.000 ms): <mat4f+9>
lib/std/math/Matrix4f.ci:68:[.0565d4, .0565d7) exec(0), time(0.000 ms): <mat4f+12>
lib/std/math/Matrix4f.ci:68:[.0565d7, .0565da) exec(0), time(0.000 ms): <mat4f+15>
lib/std/math/Matrix4f.ci:68:[.0565da, .0565dd) exec(0), time(0.000 ms): <mat4f+18>
lib/std/math/Matrix4f.ci:68:[.0565dd, .0565e0) exec(0), time(0.000 ms): <mat4f+21>
lib/std/math/Matrix4f.ci:69:[.0565e0, .0565e3) exec(0), time(0.000 ms): <mat4f+24>
lib/std/math/Matrix4f.ci:69:[.0565e3, .0565e6) exec(0), time(0.000 ms): <mat4f+27>
lib/std/math/Matrix4f.ci:69:[.0565e6, .0565e9) exec(0), time(0.000 ms): <mat4f+30>
lib/std/math/Matrix4f.ci:69:[.0565e9, .0565ec) exec(0), time(0.000 ms): <mat4f+33>
lib/std/math/Matrix4f.ci:70:[.0565ec, .0565ef) exec(0), time(0.000 ms): <mat4f+36>
lib/std/math/Matrix4f.ci:70:[.0565ef, .0565f2) exec(0), time(0.000 ms): <mat4f+39>
lib/std/math/Matrix4f.ci:70:[.0565f2, .0565f5) exec(0), time(0.000 ms): <mat4f+42>
lib/std/math/Matrix4f.ci:70:[.0565f5, .0565f8) exec(0), time(0.000 ms): <mat4f+45>
lib/std/math/Matrix4f.ci:66:[.0565c8, .0565f9) exec(0), time(0.000 ms): <mat4f+0>
lib/std/math/Matrix4f.ci:76:[.056605, .05660a) exec(0), time(0.000 ms): <mat4f+5>
lib/std/math/Matrix4f.ci:76:[.05660a, .05660f) exec(0), time(0.000 ms): <mat4f+10>
lib/std/math/Matrix4f.ci:76:[.05660f, .056614) exec(0), time(0.000 ms): <mat4f+15>
lib/std/math/Matrix4f.ci:76:[.056600, .056615) exec(0), time(0.000 ms): <mat4f+0>
lib/std/math/Matrix4f.ci:89:[.05661c, .056621) exec(0), time(0.000 ms): <mul+4>
lib/std/math/Matrix4f.ci:89:[.056621, .05662a) exec(0), time(0.000 ms): <mul+9>
lib/std/math/Matrix4f.ci:89:[.05662a, .056633) exec(0), time(0.000 ms): <mul+18>
lib/std/math/Matrix4f.ci:89:[.056633, .05663c) exec(0), time(0.000 ms): <mul+27>
lib/std/math/Matrix4f.ci:90:[.05663c, .056645) exec(0), time(0.000 ms): <mul+36>
lib/std/math/Matrix4f.ci:90:[.056645, .05664e) exec(0), time(0.000 ms): <mul+45>
lib/std/math/Matrix4f.ci:90:[.05664e, .056657) exec(0), time(0.000 ms): <mul+54>
lib/std/math/Matrix4f.ci:90:[.056657, .056660) exec(0), time(0.000 ms): <mul+63>
lib/std/math/Matrix4f.ci:91:[.056660, .056669) exec(0), time(0.000 ms): <mul+72>
lib/std/math/Matrix4f.ci:91:[.056669, .056672) exec(0), time(0.000 ms): <mul+81>
lib/std/math/Matrix4f.ci:91:[.056672, .05667b) exec(0), time(0.000 ms): <mul+90>
lib/std/math/Matrix4f.ci:91:[.05667b, .056684) exec(0), time(0.000 ms): <mul+99>
lib/std/math/Matrix4f.ci:92:[.056684, .05668d) exec(0), time(0.000 ms): <mul+108>
lib/std/math/Matrix4f.ci:92:[.05668d, .056696) exec(0), time(0.000 ms): <mul+117>
lib/std/math/Matrix4f.ci:92:[.056696, .05669f) exec(0), time(0.000 ms): <mul+126>
lib/std/math/Matrix4f.ci:92:[.05669f, .0566a8) exec(0), time(0.000 ms): <mul+135>
lib/std/math/Matrix4f.ci:88:[.056618, .0566a8) exec(0), time(0.000 ms): <mul+0>
lib/std/math/Matrix4f.ci:96:[.0566e8, .05672c) exec(0), time(0.000 ms): <mul+208>
lib/std/math/Matrix4f.ci:97:[.05672c, .056770) exec(0), time(0.000 ms): <mul+276>
lib/std/math/Matrix4f.ci:98:[.056770, .0567b4) exec(0), time(0.000 ms): <mul+344>
lib/std/math/Matrix4f.ci:94:[.0566a8, .0567b9) exec(0), time(0.000 ms): <mul+144>
lib/std/math/Matrix4f.ci:107:[.0567c0, .0567d2) exec(0), time(0.000 ms): <rotation+0>
lib/std/math/Matrix4f.ci:109:[.0567e3, .056807) exec(0), time(0.000 ms): <rotation+35>
lib/std/math/Matrix4f.ci:112:[.05681b, .05682f) exec(0), time(0.000 ms): <rotation+91>
lib/std/math/Matrix4f.ci:113:[.05682f, .056843) exec(0), time(0.000 ms): <rotation+111>
lib/std/math/Matrix4f.ci:114:[.056843, .056857) exec(0), time(0.000 ms): <rotation+131>
lib/std/math/Matrix4f.ci:110:[.056807, .05685c) exec(0), time(0.000 ms): <rotation+71>
lib/std/math/Matrix4f.ci:108:[.0567d2, .05685c) exec(0), time(0.000 ms): <rotation+18>
lib/std/math/Matrix4f.ci:117:[.05685c, .056862) exec(0), time(0.000 ms): <rotation+156>
lib/std/math/Matrix4f.ci:118:[.056862, .05686c) exec(0), time(0.000 ms): <rotation+162>
lib/std/math/Matrix4f.ci:119:[.05686c, .056876) exec(0), time(0.000 ms): <rotation+172>
lib/std/math/Matrix4f.ci:120:[.056876, .056879) exec(0), time(0.000 ms): <rotation+182>
lib/std/math/Matrix4f.ci:121:[.056879, .056880) exec(0), time(0.000 ms): <rotation+185>
lib/std/math/Matrix4f.ci:122:[.056880, .056887) exec(0), time(0.000 ms): <rotation+192>
lib/std/math/Matrix4f.ci:123:[.056887, .05688c) exec(0), time(0.000 ms): <rotation+199>
lib/std/math/Matrix4f.ci:124:[.05688c, .056891) exec(0), time(0.000 ms): <rotation+204>
lib/std/math/Matrix4f.ci:125:[.056891, .056896) exec(0), time(0.000 ms): <rotation+209>
lib/std/math/Matrix4f.ci:126:[.056896, .05689b) exec(0), time(0.000 ms): <rotation+214>
lib/std/math/Matrix4f.ci:127:[.05689b, .0568a0) exec(0), time(0.000 ms): <rotation+219>
lib/std/math/Matrix4f.ci:128:[.0568a0, .0568a5) exec(0), time(0.000 ms): <rotation+224>
lib/std/math/Matrix4f.ci:130:[.0568a5, .0568ab) exec(0), time(0.000 ms): <rotation+229>
lib/std/math/Matrix4f.ci:131:[.0568ab, .0568b1) exec(0), time(0.000 ms): <rotation+235>
lib/std/math/Matrix4f.ci:132:[.0568b1, .0568b9) exec(0), time(0.000 ms): <rotation+241>
lib/std/math/Matrix4f.ci:136:[.0568c6, .0568d3) exec(0), time(0.000 ms): <rotation+262>
lib/std/math/Matrix4f.ci:137:[.0568d3, .0568e0) exec(0), time(0.000 ms): <rotation+275>
lib/std/math/Matrix4f.ci:138:[.0568e0, .05690b) exec(0), time(0.000 ms): <rotation+288>
lib/std/math/Matrix4f.ci:140:[.05690b, .056918) exec(0), time(0.000 ms): <rotation+331>
lib/std/math/Matrix4f.ci:141:[.056918, .056925) exec(0), time(0.000 ms): <rotation+344>
lib/std/math/Matrix4f.ci:142:[.056925, .056932) exec(0), time(0.000 ms): <rotation+357>
lib/std/math/Matrix4f.ci:143:[.056932, .05695d) exec(0), time(0.000 ms): <rotation+370>
lib/std/math/Matrix4f.ci:145:[.05695d, .05696a) exec(0), time(0.000 ms): <rotation+413>
lib/std/math/Matrix4f.ci:146:[.05696a, .056977) exec(0), time(0.000 ms): <rotation+426>
lib/std/math/Matrix4f.ci:147:[.056977, .056984) exec(0), time(0.000 ms): <rotation+439>
lib/std/math/Matrix4f.ci:148:[.056984, .0569af) exec(0), time(0.000 ms): <rotation+452>
lib/std/math/Matrix4f.ci:150:[.0569af, .0569c7) exec(0), time(0.000 ms): <rotation+495>
lib/std/math/Matrix4f.ci:134:[.0568b9, .0569cc) exec(0), time(0.000 ms): <rotation+249>
lib/std/math/Matrix4f.ci:160:[.0569d7, .0569da) exec(0), time(0.000 ms): <translation+7>
lib/std/math/Matrix4f.ci:160:[.0569da, .0569dd) exec(0), time(0.000 ms): <translation+10>
lib/std/math/Matrix4f.ci:160:[.0569dd, .0569e5) exec(0), time(0.000 ms): <translation+13>
lib/std/math/Matrix4f.ci:161:[.0569e5, .0569e8) exec(0), time(0.000 ms): <translation+21>
lib/std/math/Matrix4f.ci:161:[.0569e8, .0569ef) exec(0), time(0.000 ms): <translation+24>
lib/std/math/Matrix4f.ci:161:[.0569ef, .0569f2) exec(0), time(0.000 ms): <translation+31>
lib/std/math/Matrix4f.ci:161:[.0569f2, .0569fe) exec(0), time(0.000 ms): <translation+34>
lib/std/math/Matrix4f.ci:162:[.0569fe, .056a01) exec(0), time(0.000 ms): <translation+46>
lib/std/math/Matrix4f.ci:162:[.056a01, .056a04) exec(0), time(0.000 ms): <translation+49>
lib/std/math/Matrix4f.ci:162:[.056a04, .056a0b) exec(0), time(0.000 ms): <translation+52>
lib/std/math/Matrix4f.ci:162:[.056a0b, .056a17) exec(0), time(0.000 ms): <translation+59>
lib/std/math/Matrix4f.ci:163:[.056a17, .056a1a) exec(0), time(0.000 ms): <translation+71>
lib/std/math/Matrix4f.ci:163:[.056a1a, .056a1d) exec(0), time(0.000 ms): <translation+74>
lib/std/math/Matrix4f.ci:163:[.056a1d, .056a20) exec(0), time(0.000 ms): <translation+77>
lib/std/math/Matrix4f.ci:163:[.056a20, .056a27) exec(0), time(0.000 ms): <translation+80>
lib/std/math/Matrix4f.ci:159:[.0569d0, .056a28) exec(0), time(0.000 ms): <translation+0>
lib/std/math/Matrix4f.ci:171:[.056a5f, .056a62) exec(0), time(0.000 ms): <scale+55>
lib/std/math/Matrix4f.ci:171:[.056a62, .056a65) exec(0), time(0.000 ms): <scale+58>
lib/std/math/Matrix4f.ci:171:[.056a65, .056a68) exec(0), time(0.000 ms): <scale+61>
lib/std/math/Matrix4f.ci:172:[.056a68, .056a6b) exec(0), time(0.000 ms): <scale+64>
lib/std/math/Matrix4f.ci:172:[.056a6b, .056aa6) exec(0), time(0.000 ms): <scale+67>
lib/std/math/Matrix4f.ci:172:[.056aa6, .056aa9) exec(0), time(0.000 ms): <scale+126>
lib/std/math/Matrix4f.ci:172:[.056aa9, .056aac) exec(0), time(0.000 ms): <scale+129>
lib/std/math/Matrix4f.ci:173:[.056aac, .056aaf) exec(0), time(0.000 ms): <scale+132>
lib/std/math/Matrix4f.ci:173:[.056aaf, .056ab2) exec(0), time(0.000 ms): <scale+135>
lib/std/math/Matrix4f.ci:173:[.056ab2, .056aed) exec(0), time(0.000 ms): <scale+138>
lib/std/math/Matrix4f.ci:173:[.056aed, .056af0) exec(0), time(0.000 ms): <scale+197>
lib/std/math/Matrix4f.ci:174:[.056af0, .056af3) exec(0), time(0.000 ms): <scale+200>
lib/std/math/Matrix4f.ci:174:[.056af3, .056af6) exec(0), time(0.000 ms): <scale+203>
lib/std/math/Matrix4f.ci:174:[.056af6, .056af9) exec(0), time(0.000 ms): <scale+206>
lib/std/math/Matrix4f.ci:174:[.056af9, .056b00) exec(0), time(0.000 ms): <scale+209>
lib/std/math/Matrix4f.ci:170:[.056a28, .056b01) exec(0), time(0.000 ms): <scale+0>
lib/std/math/Vector2d.ci:17:[.056b0b, .056b0e) exec(0), time(0.000 ms): <vec2d+3>
lib/std/math/Vector2d.ci:15:[.056b08, .056b0f) exec(0), time(0.000 ms): <vec2d+0>
lib/std/string.ci:6:[.056b1c, .056b20) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.056b10, .056b20) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.056b20, .056b21) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.056b25, .056b29) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.056b29, .056b33) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.056b21, .056b33) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.056b33, .056b36) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.056b4d, .056b50) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.056b3d, .056b50) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.056b50, .056b54) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.056b54, .056b5e) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.056b38, .056b62) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.056b62, .056b6a) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.056b70, .056b75) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.056b8a, .056b8d) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.056b7a, .056b8d) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.056b8d, .056b91) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.056b91, .056b9b) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.056b75, .056b9f) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.056b9f, .056ba2) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.056bc7, .056bd2) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.056bad, .056bd2) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.056bd2, .056bd6) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.056bd6, .056be2) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.056ba8, .056be6) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.056be6, .056bf1) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.056bf8, .056c05) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.056c05, .056c12) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.056c1b, .056c26) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.056c12, .056c26) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.056c4b, .056c56) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.056c2b, .056c56) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.056c56, .056c5a) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.056c5a, .056c63) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.056c26, .056c67) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.056c67, .056c76) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.056c78, .056c79) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.056c7e, .056c94) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.056ca0, .056ca4) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.056c94, .056ca4) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.056ca4, .056ca8) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.056ca8, .056cb0) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.056c79, .056cb4) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.056cb4, .056cb7) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.056cc7, .056cd2) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.056cb8, .056cd2) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.056ce1, .056cec) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.056cd2, .056cec) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.056cec, .056cff) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.056d00, .056d24) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.056d28, .056d36) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.056d46, .056d4a) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.056d3d, .056d4a) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.056d4a, .056d56) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.056d56, .056d5e) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.056d5e, .056d62) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.056d62, .056d6c) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.056d38, .056d70) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.056d79, .056d81) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.056d70, .056d81) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.056d81, .056d88) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.056d88, .056d8c) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.056da0, .056da1) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.056da1, .056da5) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:152:[.056db7, .056dc1) exec(0), time(0.000 ms): <append+23>
lib/std/string.ci:151:[.056dac, .056dc1) exec(0), time(0.000 ms): <append+12>
lib/std/string.ci:150:[.056da5, .056dc1) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:156:[.056dc1, .056dc8) exec(0), time(0.000 ms): <append+33>
lib/std/string.ci:158:[.056dd0, .056dd7) exec(0), time(0.000 ms): <append+48>
lib/std/string.ci:157:[.056dc8, .056dd7) exec(0), time(0.000 ms): <append+40>
lib/std/string.ci:160:[.056dd7, .056e0d) exec(0), time(0.000 ms): <append+55>
lib/std/string.ci:161:[.056e0d, .056e42) exec(0), time(0.000 ms): <append+109>
lib/std/string.ci:165:[.056e46, .056e63) exec(0), time(0.000 ms): <append+166>
lib/std/string.ci:164:[.056e63, .056e6b) exec(0), time(0.000 ms): <append+195>
lib/std/string.ci:164:[.056e6b, .056e73) exec(0), time(0.000 ms): <append+203>
lib/std/string.ci:164:[.056e42, .056e73) exec(0), time(0.000 ms): <append+162>
lib/std/string.ci:168:[.056e7b, .056e90) exec(0), time(0.000 ms): <append+219>
lib/std/string.ci:167:[.056e73, .056e90) exec(0), time(0.000 ms): <append+211>
lib/std/string.ci:171:[.056e90, .056e9a) exec(0), time(0.000 ms): <append+240>
lib/std/string.ci:173:[.056e9a, .056ea1) exec(0), time(0.000 ms): <append+250>
lib/std/string.ci:175:[.056eac, .056eb6) exec(0), time(0.000 ms): <append+268>
lib/std/string.ci:174:[.056ea1, .056eb6) exec(0), time(0.000 ms): <append+257>
lib/std/string.ci:180:[.056ec1, .056ec9) exec(0), time(0.000 ms): <append+289>
lib/std/string.ci:184:[.056ee7, .056f1b) exec(0), time(0.000 ms): <append+327>
lib/std/string.ci:185:[.056f1b, .056f26) exec(0), time(0.000 ms): <append+379>
lib/std/string.ci:186:[.056f26, .056f2e) exec(0), time(0.000 ms): <append+390>
lib/std/string.ci:183:[.056f2e, .056f36) exec(0), time(0.000 ms): <append+398>
lib/std/string.ci:183:[.056f36, .056f3e) exec(0), time(0.000 ms): <append+406>
lib/std/string.ci:183:[.056ee3, .056f3e) exec(0), time(0.000 ms): <append+323>
lib/std/string.ci:181:[.056ec9, .056f3e) exec(0), time(0.000 ms): <append+297>
lib/std/string.ci:189:[.056f3e, .056f72) exec(0), time(0.000 ms): <append+414>
lib/std/string.ci:190:[.056f72, .056f7d) exec(0), time(0.000 ms): <append+466>
lib/std/string.ci:191:[.056f7d, .056f85) exec(0), time(0.000 ms): <append+477>
lib/std/string.ci:179:[.056eb6, .056f85) exec(0), time(0.000 ms): <append+278>
lib/std/string.ci:196:[.056f89, .056fbd) exec(0), time(0.000 ms): <append+489>
lib/std/string.ci:197:[.056fbd, .056fc8) exec(0), time(0.000 ms): <append+541>
lib/std/string.ci:198:[.056fc8, .056fd0) exec(0), time(0.000 ms): <append+552>
lib/std/string.ci:195:[.056fd0, .056fd8) exec(0), time(0.000 ms): <append+560>
lib/std/string.ci:195:[.056fd8, .056fe0) exec(0), time(0.000 ms): <append+568>
lib/std/string.ci:195:[.056f85, .056fe0) exec(0), time(0.000 ms): <append+485>
lib/std/string.ci:203:[.056fe5, .057019) exec(0), time(0.000 ms): <append+581>
lib/std/string.ci:204:[.057019, .05702a) exec(0), time(0.000 ms): <append+633>
lib/std/string.ci:205:[.05702a, .057032) exec(0), time(0.000 ms): <append+650>
lib/std/string.ci:202:[.057032, .057036) exec(0), time(0.000 ms): <append+658>
lib/std/string.ci:202:[.057036, .05703f) exec(0), time(0.000 ms): <append+662>
lib/std/string.ci:202:[.056fe0, .057043) exec(0), time(0.000 ms): <append+576>
lib/std/string.ci:209:[.05704c, .057054) exec(0), time(0.000 ms): <append+684>
lib/std/string.ci:208:[.057043, .057054) exec(0), time(0.000 ms): <append+675>
lib/std/string.ci:211:[.057054, .05705b) exec(0), time(0.000 ms): <append+692>
lib/std/string.ci:212:[.05705b, .057063) exec(0), time(0.000 ms): <append+699>
lib/std/string.ci:235:[.05706c, .057074) exec(0), time(0.000 ms): <append+4>
lib/std/string.ci:236:[.057074, .057077) exec(0), time(0.000 ms): <append+12>
lib/std/string.ci:237:[.057077, .057083) exec(0), time(0.000 ms): <append+15>
lib/std/string.ci:238:[.057083, .057094) exec(0), time(0.000 ms): <append+27>
lib/std/string.ci:234:[.057068, .057094) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:241:[.057098, .05709e) exec(0), time(0.000 ms): <append+48>
lib/std/string.ci:242:[.05709e, .0570a1) exec(0), time(0.000 ms): <append+54>
lib/std/string.ci:243:[.0570a1, .0570ab) exec(0), time(0.000 ms): <append+57>
lib/std/string.ci:244:[.0570ab, .0570b4) exec(0), time(0.000 ms): <append+67>
lib/std/string.ci:240:[.057094, .0570b4) exec(0), time(0.000 ms): <append+44>
lib/std/string.ci:247:[.0570b4, .0570c6) exec(0), time(0.000 ms): <append+76>
lib/std/string.ci:248:[.0570c6, .0570e1) exec(0), time(0.000 ms): <append+94>
lib/std/string.ci:249:[.0570e1, .0570fe) exec(0), time(0.000 ms): <append+121>
lib/std/string.ci:251:[.0570fe, .057114) exec(0), time(0.000 ms): <append+150>
lib/std/string.ci:252:[.057114, .05712a) exec(0), time(0.000 ms): <append+172>
lib/std/string.ci:253:[.05712a, .057143) exec(0), time(0.000 ms): <append+194>
lib/std/string.ci:254:[.057143, .05714b) exec(0), time(0.000 ms): <append+219>
lib/std/string.ci:263:[.057160, .05719f) exec(0), time(0.000 ms): <append+0>
test/lang/function.ci:8:[.057638, .057640) exec(2), time(0.029-0.029 ms): <funAdd+0>
test/lang/function.ci:34:[.057678, .057680) exec(2), time(0.028-0.028 ms): <funMul+0>
test/lang/function.ci:40:[.05768c, .057690) exec(377), time(4.283-4.283 ms): <fib+12>
test/lang/function.ci:39:[.057680, .057690) exec(753-377), time(1.185-1.185 ms): <fib+0>
test/lang/function.ci:42:[.057690, .0576b6) exec(376-375), time(26.655-26.655 ms): <fib+16>
test/std/tryExec.ci:15:[.057990, .057994) exec(128-1), time(0.136-0.136 ms): <stackOverflow+0>
test/std/tryExec.ci:16:[.057994, .0579a3) exec(127-127), time(0.000 ms): <stackOverflow+4>
test/std/tryExec.ci:20:[.0579a8, .0579af) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/std/tryExec.ci:30:[.0579bc, .0579c3) exec(1), time(0.002-0.002 ms): <abortExecution+4>
test/std/tryExec.ci:31:[.0579c3, .0579ca) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/std/tryExec.ci:32:[.0579ca, .0579d1) exec(1), time(0.002-0.002 ms): <abortExecution+18>
test/std/tryExec.ci:29:[.0579b8, .0579d1) exec(1-1), time(0.000 ms): <abortExecution+0>
test/std/tryExec.ci:34:[.0579d1, .0579f7) exec(1-1), time(0.000 ms): <abortExecution+25>
test/std/tryExec.ci:38:[.057a00, .057a05) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/std/tryExec.ci:39:[.057a05, .057a08) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/std/tryExec.ci:43:[.057a10, .057a12) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.057ae8, .057aec) exec(5), time(0.070-0.070 ms): <lenSlice+0>
test/lang/array.ci:104:[.057af0, .057afc) exec(21), time(0.280-0.280 ms): <nthFixed+0>
test/lang/array.ci:105:[.057b00, .057b0c) exec(21), time(0.256-0.256 ms): <nthArray+0>
test/lang/array.ci:106:[.057b10, .057b1c) exec(14), time(0.171-0.171 ms): <nthSlice+0>
test/lang/method.ci:11:[.057b70, .057b96) exec(3), time(0.508-0.508 ms): <staticMethod+0>
test/lang/method.ci:41:[.057ba0, .057bc6) exec(4), time(0.595-0.595 ms): <virtualMethod+0>
test/lang/method.ci:48:[.057bc8, .057bee) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:58:[.057bf0, .057c16) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:85:[.057c28, .057c4b) exec(1), time(0.063-0.063 ms): <staticMethod+0>
test/lang/method.ci:87:[.057c59, .057c69) exec(1), time(0.207-0.207 ms): <staticMethod+49>
test/lang/method.ci:86:[.057c4b, .057c69) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:91:[.057c70, .057c93) exec(1), time(0.031-0.031 ms): <virtualMethod+0>
test/lang/method.ci:93:[.057ca1, .057cae) exec(1), time(0.211-0.211 ms): <virtualMethod+49>
test/lang/method.ci:92:[.057c93, .057cae) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.0586f4, .058702) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.058702, .058710) exec(1), time(0.002-0.002 ms): <.main+14>
::[.058717, .05871c) exec(1), time(0.001-0.001 ms): <.main+35>
::[.05871c, .058723) exec(1), time(0.002-0.002 ms): <.main+40>
::[.058723, .058728) exec(1), time(0.002-0.002 ms): <.main+47>
lib/std/string.ci:262:[.058710, .058728) exec(1-1), time(0.000 ms): <.main+28>
test/lang/emit.ci:3:[.058728, .05872d) exec(1), time(0.001-0.001 ms): <.main+52>
test/lang/emit.ci:4:[.05872d, .058732) exec(1), time(0.002-0.002 ms): <.main+57>
test/lang/emit.ci:6:[.058732, .05873b) exec(1), time(0.001-0.001 ms): <.main+62>
test/lang/emit.ci:7:[.05873b, .058744) exec(1), time(0.002-0.002 ms): <.main+71>
test/lang/emit.ci:9:[.058744, .058751) exec(1), time(0.002-0.002 ms): <.main+80>
test/lang/emit.ci:10:[.058751, .058760) exec(1), time(0.002-0.002 ms): <.main+93>
test/lang/emit.ci:17:[.058760, .058769) exec(1), time(0.001-0.001 ms): <.main+108>
test/lang/emit.ci:18:[.058769, .058773) exec(1), time(0.002-0.002 ms): <.main+117>
test/lang/emit.ci:19:[.058773, .058781) exec(1), time(0.002-0.002 ms): <.main+127>
test/lang/emit.ci:20:[.058781, .05878e) exec(1), time(0.001-0.001 ms): <.main+141>
test/lang/emit.ci:23:[.05878e, .05879c) exec(1), time(0.002-0.002 ms): <.main+154>
test/lang/inlineMacros.ci:10:[.05879c, .0587a5) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/inlineMacros.ci:11:[.0587a5, .0587ae) exec(1), time(0.001-0.001 ms): <.main+177>
test/lang/inlineMacros.ci:12:[.0587ae, .0587b7) exec(1), time(0.001-0.001 ms): <.main+186>
test/lang/inlineMacros.ci:13:[.0587b7, .0587c0) exec(1), time(0.001-0.001 ms): <.main+195>
test/lang/inlineMacros.ci:15:[.0587c0, .0587c5) exec(1), time(0.001-0.001 ms): <.main+204>
test/lang/inlineMacros.ci:16:[.0587c5, .0587ca) exec(1), time(0.015-0.015 ms): <.main+209>
test/lang/inlineMacros.ci:17:[.0587ca, .0587cf) exec(1), time(0.002-0.002 ms): <.main+214>
test/lang/inlineMacros.ci:19:[.0587cf, .0587d8) exec(1), time(0.001-0.001 ms): <.main+219>
test/lang/inlineMacros.ci:20:[.0587d8, .0587e0) exec(1), time(0.002-0.002 ms): <.main+228>
test/lang/inlineMacros.ci:21:[.0587e0, .0587f0) exec(1), time(0.002-0.002 ms): <.main+236>
test/lang/inlineMacros.ci:23:[.0587f0, .0587fd) exec(1), time(0.002-0.002 ms): <.main+252>
test/lang/inlineMacros.ci:24:[.0587fd, .05880a) exec(1), time(0.002-0.002 ms): <.main+265>
test/lang/inlineMacros.ci:25:[.05880a, .058823) exec(1), time(0.004-0.004 ms): <.main+278>
test/lang/inlineMacros.ci:27:[.058823, .05883f) exec(1), time(0.004-0.004 ms): <.main+303>
test/lang/inlineMacros.ci:28:[.05883f, .058859) exec(1), time(0.004-0.004 ms): <.main+331>
test/lang/inlineMacros.ci:29:[.058859, .05887f) exec(1), time(0.005-0.005 ms): <.main+357>
test/lang/inlineMacros.ci:31:[.05887f, .0588a4) exec(1), time(0.007-0.007 ms): <.main+395>
test/lang/inlineMacros.ci:32:[.0588a4, .0588c7) exec(1), time(0.007-0.007 ms): <.main+432>
test/lang/inlineMacros.ci:33:[.0588c7, .0588f6) exec(1), time(0.023-0.023 ms): <.main+467>
test/lang/inlineMacros.ci:35:[.0588f6, .05891b) exec(1), time(0.007-0.007 ms): <.main+514>
test/lang/inlineMacros.ci:36:[.05891b, .05893e) exec(1), time(0.006-0.006 ms): <.main+551>
test/lang/inlineMacros.ci:37:[.05893e, .05896d) exec(1), time(0.009-0.009 ms): <.main+586>
test/lang/inlineMacros.ci:41:[.05896d, .058986) exec(1), time(0.005-0.005 ms): <.main+633>
test/lang/inlineMacros.ci:42:[.058986, .05899b) exec(1), time(0.004-0.004 ms): <.main+658>
test/lang/inlineMacros.ci:43:[.05899b, .0589b2) exec(1), time(0.006-0.006 ms): <.main+679>
test/lang/inlineMacros.ci:44:[.0589b2, .0589c9) exec(1), time(0.006-0.006 ms): <.main+702>
test/lang/inlineMacros.ci:45:[.0589c9, .0589f4) exec(1), time(0.010-0.010 ms): <.main+725>
test/lang/inlineMacros.ci:46:[.0589f4, .058a1f) exec(1), time(0.009-0.009 ms): <.main+768>
test/lang/inlineMacros.ci:50:[.058a1f, .058a61) exec(1), time(0.005-0.005 ms): <.main+811>
test/lang/inlineMacros.ci:51:[.058a61, .058aa3) exec(1), time(0.013-0.013 ms): <.main+877>
test/lang/inlineMacros.ci:52:[.058aa3, .058ae1) exec(1), time(0.006-0.006 ms): <.main+943>
test/lang/inlineMacros.ci:53:[.058ae1, .058b1f) exec(1), time(0.013-0.013 ms): <.main+1005>
test/lang/inlineMacros.ci:54:[.058b1f, .058b71) exec(1), time(0.007-0.007 ms): <.main+1067>
test/lang/inlineMacros.ci:55:[.058b71, .058bc3) exec(1), time(0.014-0.014 ms): <.main+1149>
test/lang/inlineMacros.ci:59:[.058bc3, .058c20) exec(1), time(0.019-0.019 ms): <.main+1231>
test/lang/inlineMacros.ci:60:[.058c20, .058c7d) exec(1), time(0.020-0.020 ms): <.main+1324>
test/lang/inlineMacros.ci:61:[.058c7d, .058cd6) exec(1), time(0.020-0.020 ms): <.main+1417>
test/lang/inlineMacros.ci:62:[.058cd6, .058d2f) exec(1), time(0.021-0.021 ms): <.main+1506>
test/lang/inlineMacros.ci:63:[.058d2f, .058d9c) exec(1), time(0.022-0.022 ms): <.main+1595>
test/lang/inlineMacros.ci:64:[.058d9c, .058e09) exec(1), time(0.023-0.023 ms): <.main+1704>
test/lang/inlineMacros.ci:68:[.058e09, .058e66) exec(1), time(0.016-0.016 ms): <.main+1813>
test/lang/inlineMacros.ci:69:[.058e66, .058ec3) exec(1), time(0.013-0.013 ms): <.main+1906>
test/lang/inlineMacros.ci:70:[.058ec3, .058f1c) exec(1), time(0.012-0.012 ms): <.main+1999>
test/lang/inlineMacros.ci:71:[.058f1c, .058f75) exec(1), time(0.012-0.012 ms): <.main+2088>
test/lang/inlineMacros.ci:72:[.058f75, .058fe2) exec(1), time(0.015-0.015 ms): <.main+2177>
test/lang/inlineMacros.ci:73:[.058fe2, .05904f) exec(1), time(0.016-0.016 ms): <.main+2286>
test/lang/overload.inline.ci:9:[.05904f, .059058) exec(1), time(0.001-0.001 ms): <.main+2395>
test/lang/overload.inline.ci:10:[.059058, .059061) exec(1), time(0.001-0.001 ms): <.main+2404>
test/lang/overload.inline.ci:11:[.059061, .05906a) exec(1), time(0.001-0.001 ms): <.main+2413>
test/lang/overload.inline.ci:12:[.05906a, .059073) exec(1), time(0.001-0.001 ms): <.main+2422>
test/lang/overload.inline.ci:13:[.059073, .05907c) exec(1), time(0.002-0.002 ms): <.main+2431>
test/lang/overload.inline.ci:28:[.05907c, .059089) exec(1), time(0.001-0.001 ms): <.main+2440>
test/lang/overload.inline.ci:29:[.059089, .0590a5) exec(1), time(0.003-0.003 ms): <.main+2453>
test/lang/initByRef.ci:7:[.0590a5, .0590b2) exec(1), time(0.001-0.001 ms): <.main+2481>
test/lang/initByRef.ci:8:[.0590b2, .0590bb) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:9:[.0590bb, .0590c4) exec(1), time(0.001-0.001 ms): <.main+2503>
test/lang/initByRef.ci:10:[.0590c4, .0590d2) exec(1), time(0.002-0.002 ms): <.main+2512>
test/lang/initByRef.ci:12:[.0590d2, .0590db) exec(1), time(0.002-0.002 ms): <.main+2526>
test/lang/initByRef.ci:13:[.0590db, .0590e3) exec(1), time(0.001-0.001 ms): <.main+2535>
test/lang/initByRef.ci:14:[.0590e3, .0590eb) exec(1), time(0.002-0.002 ms): <.main+2543>
test/lang/initByRef.ci:16:[.0590eb, .0590f4) exec(1), time(0.001-0.001 ms): <.main+2551>
test/lang/initByRef.ci:17:[.0590f4, .0590fd) exec(1), time(0.002-0.002 ms): <.main+2560>
test/lang/initByRef.ci:18:[.0590fd, .05910b) exec(1), time(0.002-0.002 ms): <.main+2569>
test/lang/initByRef.ci:19:[.05910b, .059114) exec(1), time(0.001-0.001 ms): <.main+2583>
test/lang/initByRef.ci:20:[.059114, .05911d) exec(1), time(0.001-0.001 ms): <.main+2592>
test/lang/initByRef.ci:21:[.05911d, .059126) exec(1), time(0.001-0.001 ms): <.main+2601>
test/lang/initByRef.ci:23:[.059126, .05912f) exec(1), time(0.001-0.001 ms): <.main+2610>
test/lang/initByRef.ci:24:[.05912f, .05913d) exec(1), time(0.002-0.002 ms): <.main+2619>
test/lang/initByRef.ci:25:[.05913d, .059146) exec(1), time(0.002-0.002 ms): <.main+2633>
test/lang/initByRef.ci:27:[.059146, .05914e) exec(1), time(0.001-0.001 ms): <.main+2642>
test/lang/initByRef.ci:28:[.05914e, .059156) exec(1), time(0.002-0.002 ms): <.main+2650>
test/lang/initByRef.ci:29:[.059156, .05915e) exec(1), time(0.001-0.001 ms): <.main+2658>
test/lang/initByRef.ci:30:[.05915e, .059166) exec(1), time(0.001-0.001 ms): <.main+2666>
test/lang/initByRef.ci:31:[.059166, .05916e) exec(1), time(0.001-0.001 ms): <.main+2674>
test/lang/initByRef.ci:32:[.05916e, .059176) exec(1), time(0.001-0.001 ms): <.main+2682>
test/lang/initByRef.ci:35:[.059176, .05917f) exec(1), time(0.001-0.001 ms): <.main+2690>
test/lang/initByRef.ci:36:[.05917f, .059188) exec(1), time(0.001-0.001 ms): <.main+2699>
test/lang/initByRef.ci:37:[.059188, .059191) exec(1), time(0.001-0.001 ms): <.main+2708>
test/lang/initByRef.ci:38:[.059191, .05919a) exec(1), time(0.001-0.001 ms): <.main+2717>
test/lang/initByRef.ci:39:[.05919a, .0591a3) exec(1), time(0.002-0.002 ms): <.main+2726>
test/lang/initByRef.ci:40:[.0591a3, .0591ac) exec(1), time(0.001-0.001 ms): <.main+2735>
test/lang/initByRef.ci:41:[.0591ac, .0591b5) exec(1), time(0.002-0.002 ms): <.main+2744>
test/lang/initByRef.ci:42:[.0591b5, .0591be) exec(1), time(0.001-0.001 ms): <.main+2753>
test/lang/initByRef.ci:43:[.0591be, .0591c7) exec(1), time(0.002-0.002 ms): <.main+2762>
test/lang/initByRef.ci:44:[.0591c7, .0591d0) exec(1), time(0.001-0.001 ms): <.main+2771>
test/lang/initByRef.ci:45:[.0591d0, .0591d9) exec(1), time(0.002-0.002 ms): <.main+2780>
test/lang/initByRef.ci:46:[.0591d9, .0591e2) exec(1), time(0.001-0.001 ms): <.main+2789>
test/lang/initByRef.ci:47:[.0591e2, .0591eb) exec(1), time(0.002-0.002 ms): <.main+2798>
test/lang/initByRef.ci:48:[.0591eb, .0591f4) exec(1), time(0.001-0.001 ms): <.main+2807>
test/lang/initByRef.ci:49:[.0591f4, .0591fd) exec(1), time(0.002-0.002 ms): <.main+2816>
test/lang/initByRef.ci:50:[.0591fd, .059206) exec(1), time(0.001-0.001 ms): <.main+2825>
test/lang/initByRef.ci:51:[.059206, .05920f) exec(1), time(0.002-0.002 ms): <.main+2834>
test/lang/initByRef.ci:52:[.05920f, .059218) exec(1), time(0.001-0.001 ms): <.main+2843>
test/lang/initByRef.ci:55:[.059218, .059226) exec(1), time(0.001-0.001 ms): <.main+2852>
test/lang/initByRef.ci:56:[.059226, .059234) exec(1), time(0.002-0.002 ms): <.main+2866>
test/lang/initByRef.ci:57:[.059234, .059242) exec(1), time(0.003-0.003 ms): <.main+2880>
test/lang/initByRef.ci:58:[.059242, .059250) exec(1), time(0.003-0.003 ms): <.main+2894>
test/lang/initByRef.ci:59:[.059250, .05925e) exec(1), time(0.003-0.003 ms): <.main+2908>
test/lang/initByRef.ci:60:[.05925e, .05926c) exec(1), time(0.003-0.003 ms): <.main+2922>
test/lang/initByRef.ci:61:[.05926c, .05927a) exec(1), time(0.002-0.002 ms): <.main+2936>
test/lang/initByRef.ci:62:[.05927a, .059288) exec(1), time(0.002-0.002 ms): <.main+2950>
test/lang/initByRef.ci:63:[.059288, .059296) exec(1), time(0.003-0.003 ms): <.main+2964>
test/lang/initByRef.ci:64:[.059296, .0592a4) exec(1), time(0.008-0.008 ms): <.main+2978>
test/lang/initByRef.ci:65:[.0592a4, .0592b2) exec(1), time(0.003-0.003 ms): <.main+2992>
test/lang/initByRef.ci:66:[.0592b2, .0592c0) exec(1), time(0.004-0.004 ms): <.main+3006>
test/lang/initByRef.ci:67:[.0592c0, .0592ce) exec(1), time(0.003-0.003 ms): <.main+3020>
test/lang/initByRef.ci:68:[.0592ce, .0592dc) exec(1), time(0.002-0.002 ms): <.main+3034>
test/lang/initByRef.ci:69:[.0592dc, .0592ea) exec(1), time(0.002-0.002 ms): <.main+3048>
test/lang/initByRef.ci:70:[.0592ea, .0592f8) exec(1), time(0.003-0.003 ms): <.main+3062>
test/lang/initByRef.ci:71:[.0592f8, .059306) exec(1), time(0.003-0.003 ms): <.main+3076>
test/lang/initByRef.ci:72:[.059306, .059314) exec(1), time(0.002-0.002 ms): <.main+3090>
test/lang/initByRef.ci:75:[.059314, .05931d) exec(1), time(0.016-0.016 ms): <.main+3104>
test/lang/initByRef.ci:76:[.05931d, .059326) exec(1), time(0.002-0.002 ms): <.main+3113>
test/lang/initByRef.ci:77:[.059326, .05932f) exec(1), time(0.002-0.002 ms): <.main+3122>
test/lang/initByRef.ci:78:[.05932f, .059338) exec(1), time(0.002-0.002 ms): <.main+3131>
test/lang/initByRef.ci:79:[.059338, .059341) exec(1), time(0.001-0.001 ms): <.main+3140>
test/lang/initByRef.ci:80:[.059341, .05934a) exec(1), time(0.001-0.001 ms): <.main+3149>
test/lang/initByRef.ci:81:[.05934a, .059353) exec(1), time(0.002-0.002 ms): <.main+3158>
test/lang/initByRef.ci:82:[.059353, .05935c) exec(1), time(0.002-0.002 ms): <.main+3167>
test/lang/initByRef.ci:83:[.05935c, .059365) exec(1), time(0.002-0.002 ms): <.main+3176>
test/lang/initByRef.ci:84:[.059365, .05936e) exec(1), time(0.002-0.002 ms): <.main+3185>
test/lang/initByRef.ci:85:[.05936e, .059377) exec(1), time(0.002-0.002 ms): <.main+3194>
test/lang/initByRef.ci:86:[.059377, .059380) exec(1), time(0.002-0.002 ms): <.main+3203>
test/lang/initByRef.ci:87:[.059380, .059389) exec(1), time(0.001-0.001 ms): <.main+3212>
test/lang/initByRef.ci:88:[.059389, .059392) exec(1), time(0.001-0.001 ms): <.main+3221>
test/lang/initByRef.ci:89:[.059392, .05939b) exec(1), time(0.002-0.002 ms): <.main+3230>
test/lang/initByRef.ci:90:[.05939b, .0593a4) exec(1), time(0.002-0.002 ms): <.main+3239>
test/lang/initByRef.ci:91:[.0593a4, .0593ad) exec(1), time(0.001-0.001 ms): <.main+3248>
test/lang/initByRef.ci:92:[.0593ad, .0593b6) exec(1), time(0.002-0.002 ms): <.main+3257>
test/lang/initByRef.ci:95:[.0593b6, .0593bf) exec(1), time(0.001-0.001 ms): <.main+3266>
test/lang/initByRef.ci:96:[.0593bf, .0593cd) exec(1), time(0.001-0.001 ms): <.main+3275>
test/lang/initByRef.ci:97:[.0593cd, .0593d6) exec(1), time(0.001-0.001 ms): <.main+3289>
test/lang/initByRef.ci:99:[.0593d6, .0593df) exec(1), time(0.002-0.002 ms): <.main+3298>
test/lang/initByRef.ci:105:[.0593df, .0593ec) exec(1), time(0.002-0.002 ms): <.main+3307>
test/lang/initByRef.ci:108:[.0593ec, .0593f4) exec(1), time(0.002-0.002 ms): <.main+3320>
test/lang/function.ci:12:[.0593f4, .05940d) exec(1), time(0.063-0.063 ms): <.main+3328>
test/lang/function.ci:15:[.05940d, .059416) exec(1), time(0.002-0.002 ms): <.main+3353>
test/lang/function.ci:18:[.059416, .05942e) exec(1), time(0.039-0.039 ms): <.main+3362>
test/lang/function.ci:21:[.05942e, .059437) exec(1), time(0.002-0.002 ms): <.main+3386>
test/lang/function.ci:24:[.059437, .05944f) exec(1), time(0.039-0.039 ms): <.main+3395>
test/lang/function.ci:27:[.05944f, .059457) exec(1), time(0.002-0.002 ms): <.main+3419>
test/lang/function.ci:30:[.059457, .05946f) exec(1), time(0.038-0.038 ms): <.main+3427>
test/lang/function.ci:46:[.05946f, .059483) exec(1), time(26.693-26.693 ms): <.main+3451>
test/lang/reflect.ci:3:[.059483, .05948b) exec(1), time(0.001-0.001 ms): <.main+3471>
test/lang/reflect.ci:4:[.05948b, .059493) exec(1), time(0.001-0.001 ms): <.main+3479>
test/lang/reflect.ci:5:[.059493, .05949b) exec(1), time(0.002-0.002 ms): <.main+3487>
test/lang/reflect.ci:6:[.05949b, .0594a3) exec(1), time(0.001-0.001 ms): <.main+3495>
test/lang/reflect.ci:7:[.0594a3, .0594ab) exec(1), time(0.001-0.001 ms): <.main+3503>
test/lang/reflect.ci:8:[.0594ab, .0594b3) exec(1), time(0.002-0.002 ms): <.main+3511>
test/lang/reflect.ci:9:[.0594b3, .0594bb) exec(1), time(0.001-0.001 ms): <.main+3519>
test/lang/reflect.ci:10:[.0594bb, .0594c3) exec(1), time(0.001-0.001 ms): <.main+3527>
test/lang/reflect.ci:11:[.0594c3, .0594cb) exec(1), time(0.002-0.002 ms): <.main+3535>
test/lang/reflect.ci:12:[.0594cb, .0594d3) exec(1), time(0.001-0.001 ms): <.main+3543>
test/lang/reflect.ci:13:[.0594d3, .0594db) exec(1), time(0.002-0.002 ms): <.main+3551>
test/lang/reflect.ci:14:[.0594db, .0594e3) exec(1), time(0.001-0.001 ms): <.main+3559>
test/lang/reflect.ci:15:[.0594e3, .0594eb) exec(1), time(0.001-0.001 ms): <.main+3567>
test/lang/reflect.ci:16:[.0594eb, .0594f3) exec(1), time(0.002-0.002 ms): <.main+3575>
test/lang/reflect.ci:17:[.0594f3, .0594fb) exec(1), time(0.001-0.001 ms): <.main+3583>
test/lang/reflect.ci:18:[.0594fb, .059503) exec(1), time(0.001-0.001 ms): <.main+3591>
test/lang/reflect.ci:19:[.059503, .05950b) exec(1), time(0.002-0.002 ms): <.main+3599>
test/lang/reflect.ci:20:[.05950b, .059513) exec(1), time(0.001-0.001 ms): <.main+3607>
test/lang/reflect.ci:30:[.059513, .05951c) exec(1), time(0.001-0.001 ms): <.main+3615>
test/lang/reflect.ci:31:[.05951c, .059528) exec(1), time(0.040-0.040 ms): <.main+3624>
test/lang/reflect.ci:32:[.059528, .059535) exec(1), time(0.003-0.003 ms): <.main+3636>
test/lang/reflect.ci:33:[.059535, .059542) exec(1), time(0.003-0.003 ms): <.main+3649>
test/lang/reflect.ci:34:[.059542, .05954e) exec(1), time(0.045-0.045 ms): <.main+3662>
test/lang/reflect.ci:35:[.05954e, .05955a) exec(1), time(0.029-0.029 ms): <.main+3674>
test/lang/reflect.ci:37:[.05955a, .059566) exec(1), time(0.028-0.028 ms): <.main+3686>
test/lang/reflect.ci:38:[.059566, .059572) exec(1), time(0.028-0.028 ms): <.main+3698>
test/lang/reflect.ci:39:[.059572, .05957f) exec(1), time(0.003-0.003 ms): <.main+3710>
test/lang/reflect.ci:40:[.05957f, .05958c) exec(1), time(0.002-0.002 ms): <.main+3723>
test/lang/reflect.ci:41:[.05958c, .059598) exec(1), time(0.028-0.028 ms): <.main+3736>
test/lang/reflect.ci:42:[.059598, .0595a4) exec(1), time(0.028-0.028 ms): <.main+3748>
test/lang/reflect.ci:44:[.0595a4, .0595b0) exec(1), time(0.028-0.028 ms): <.main+3760>
test/lang/reflect.ci:45:[.0595b0, .0595bd) exec(1), time(0.004-0.004 ms): <.main+3772>
test/lang/reflect.ci:46:[.0595bd, .0595ca) exec(1), time(0.004-0.004 ms): <.main+3785>
test/lang/reflect.ci:48:[.0595ca, .0595d6) exec(1), time(0.032-0.032 ms): <.main+3798>
test/lang/reflect.ci:49:[.0595d6, .0595e3) exec(1), time(0.003-0.003 ms): <.main+3810>
test/lang/reflect.ci:50:[.0595e3, .0595f0) exec(1), time(0.003-0.003 ms): <.main+3823>
test/std/number.ci:3:[.0595f0, .0595fd) exec(1), time(0.001-0.001 ms): <.main+3836>
test/std/number.ci:4:[.0595fd, .05960a) exec(1), time(0.001-0.001 ms): <.main+3849>
test/std/number.ci:6:[.05960a, .059613) exec(1), time(0.002-0.002 ms): <.main+3862>
test/std/number.ci:7:[.059613, .05961c) exec(1), time(0.002-0.002 ms): <.main+3871>
test/std/number.ci:14:[.05961c, .059627) exec(1), time(0.002-0.002 ms): <.main+3880>
test/std/number.ci:15:[.059627, .059632) exec(1), time(0.002-0.002 ms): <.main+3891>
test/std/number.ci:16:[.059632, .05963d) exec(1), time(0.002-0.002 ms): <.main+3902>
test/std/number.ci:18:[.05963d, .059663) exec(1), time(0.009-0.009 ms): <.main+3913>
test/std/number.ci:19:[.059663, .059687) exec(1), time(0.008-0.008 ms): <.main+3951>
test/std/number.ci:21:[.059687, .05969d) exec(1), time(0.043-0.043 ms): <.main+3987>
test/std/number.ci:22:[.05969d, .0596b3) exec(1), time(0.054-0.054 ms): <.main+4009>
test/std/number.ci:23:[.0596b3, .0596c5) exec(1), time(0.040-0.040 ms): <.main+4031>
test/std/number.ci:25:[.0596c5, .0596db) exec(1), time(0.026-0.026 ms): <.main+4049>
test/std/number.ci:26:[.0596db, .0596f1) exec(1), time(0.026-0.026 ms): <.main+4071>
test/std/number.ci:27:[.0596f1, .059703) exec(1), time(0.040-0.040 ms): <.main+4093>
test/std/number.ci:29:[.059703, .059719) exec(1), time(0.054-0.054 ms): <.main+4111>
test/std/number.ci:30:[.059719, .05972f) exec(1), time(0.027-0.027 ms): <.main+4133>
test/std/number.ci:31:[.05972f, .059741) exec(1), time(0.027-0.027 ms): <.main+4155>
test/std/number.ci:33:[.059741, .059757) exec(1), time(0.027-0.027 ms): <.main+4173>
test/std/number.ci:34:[.059757, .05976d) exec(1), time(0.033-0.033 ms): <.main+4195>
test/std/number.ci:35:[.05976d, .05977f) exec(1), time(0.049-0.049 ms): <.main+4217>
test/std/number.ci:37:[.05977f, .059795) exec(1), time(0.051-0.051 ms): <.main+4235>
test/std/number.ci:38:[.059795, .0597ab) exec(1), time(0.059-0.059 ms): <.main+4257>
test/std/number.ci:39:[.0597ab, .0597c1) exec(1), time(0.027-0.027 ms): <.main+4279>
test/std/number.ci:40:[.0597c1, .0597d7) exec(1), time(0.045-0.045 ms): <.main+4301>
test/std/number.ci:41:[.0597d7, .0597e8) exec(1), time(0.026-0.026 ms): <.main+4323>
test/std/number.ci:42:[.0597e8, .059802) exec(1), time(0.031-0.031 ms): <.main+4340>
test/std/number.ci:43:[.059802, .059813) exec(1), time(0.027-0.027 ms): <.main+4366>
test/std/number.ci:44:[.059813, .059828) exec(1), time(0.030-0.030 ms): <.main+4383>
test/std/number.ci:46:[.059828, .05983a) exec(1), time(0.029-0.029 ms): <.main+4404>
test/std/number.ci:47:[.05983a, .05984c) exec(1), time(0.028-0.028 ms): <.main+4422>
test/std/number.ci:48:[.05984c, .05985e) exec(1), time(0.032-0.032 ms): <.main+4440>
test/std/number.ci:49:[.05985e, .059874) exec(1), time(0.045-0.045 ms): <.main+4458>
test/std/number.ci:50:[.059874, .059881) exec(1), time(0.046-0.046 ms): <.main+4480>
test/std/number.ci:51:[.059881, .059897) exec(1), time(0.028-0.028 ms): <.main+4493>
test/std/number.ci:52:[.059897, .0598a8) exec(1), time(0.063-0.063 ms): <.main+4515>
test/std/number.ci:53:[.0598a8, .0598b9) exec(1), time(0.037-0.037 ms): <.main+4532>
test/std/number.ci:55:[.0598b9, .0598c5) exec(1), time(0.027-0.027 ms): <.main+4549>
test/std/number.ci:56:[.0598c5, .0598d1) exec(1), time(0.025-0.025 ms): <.main+4561>
test/std/number.ci:57:[.0598d1, .0598dd) exec(1), time(0.025-0.025 ms): <.main+4573>
test/std/number.ci:58:[.0598dd, .0598e9) exec(1), time(0.038-0.038 ms): <.main+4585>
test/std/number.ci:59:[.0598e9, .0598f5) exec(1), time(0.073-0.073 ms): <.main+4597>
test/std/number.ci:60:[.0598f5, .059901) exec(1), time(0.039-0.039 ms): <.main+4609>
test/std/number.ci:62:[.059901, .059913) exec(1), time(0.041-0.041 ms): <.main+4621>
test/std/number.ci:63:[.059913, .059925) exec(1), time(0.026-0.026 ms): <.main+4639>
test/std/number.ci:65:[.059925, .059939) exec(1), time(0.027-0.027 ms): <.main+4657>
test/std/number.ci:66:[.059939, .05994d) exec(1), time(0.070-0.070 ms): <.main+4677>
test/std/memory.ci:7:[.05994d, .05995f) exec(1), time(0.038-0.038 ms): <.main+4697>
test/std/memory.ci:8:[.05995f, .059971) exec(1), time(0.067-0.067 ms): <.main+4715>
test/std/memory.ci:9:[.059971, .059983) exec(1), time(0.026-0.026 ms): <.main+4733>
test/std/memory.ci:10:[.059983, .059995) exec(1), time(0.026-0.026 ms): <.main+4751>
test/std/memory.ci:23:[.059995, .0599a2) exec(1), time(0.001-0.001 ms): <.main+4769>
test/std/memory.ci:24:[.0599a2, .0599af) exec(1), time(0.001-0.001 ms): <.main+4782>
test/std/tryExec.ci:46:[.0599af, .0599c1) exec(1), time(0.073-0.073 ms): <.main+4795>
test/std/tryExec.ci:47:[.0599c1, .0599d3) exec(1), time(0.029-0.029 ms): <.main+4813>
test/std/tryExec.ci:48:[.0599d3, .0599e5) exec(1), time(3.663-3.663 ms): <.main+4831>
test/std/tryExec.ci:49:[.0599e5, .0599f7) exec(1), time(0.091-0.091 ms): <.main+4849>
test/std/tryExec.ci:50:[.0599f7, .059a09) exec(1), time(0.048-0.048 ms): <.main+4867>
test/std/tryExec.ci:51:[.059a09, .059a1b) exec(1), time(0.050-0.050 ms): <.main+4885>
test/std/tryExec.ci:52:[.059a1b, .059a2d) exec(1), time(0.169-0.169 ms): <.main+4903>
test/lang/array.ci:59:[.059a2d, .059a36) exec(1), time(0.001-0.001 ms): <.main+4921>
test/lang/array.ci:60:[.059a36, .059a40) exec(1), time(0.002-0.002 ms): <.main+4930>
test/lang/array.ci:63:[.059a40, .059a49) exec(1), time(0.002-0.002 ms): <.main+4940>
test/lang/array.ci:64:[.059a49, .059a57) exec(1), time(0.002-0.002 ms): <.main+4949>
test/lang/array.ci:67:[.059a57, .059a5f) exec(1), time(0.002-0.002 ms): <.main+4963>
test/lang/array.ci:68:[.059a5f, .059a67) exec(1), time(0.002-0.002 ms): <.main+4971>
test/lang/array.ci:71:[.059a67, .059a6f) exec(1), time(0.002-0.002 ms): <.main+4979>
test/lang/array.ci:86:[.059a6f, .059a78) exec(1), time(0.001-0.001 ms): <.main+4987>
test/lang/array.ci:90:[.059a78, .059a86) exec(1), time(0.002-0.002 ms): <.main+4996>
test/lang/member.ci:35:[.059a86, .059a8b) exec(1), time(0.002-0.002 ms): <.main+5010>
test/lang/member.ci:38:[.059a8b, .059a94) exec(1), time(0.001-0.001 ms): <.main+5015>
test/lang/member.ci:41:[.059a94, .059a9d) exec(1), time(0.001-0.001 ms): <.main+5024>
test/lang/member.ci:47:[.059aa6, .059aaf) exec(1), time(0.001-0.001 ms): <.main+5042>
test/lang/member.ci:47:[.059a9d, .059aaf) exec(1-1), time(0.000 ms): <.main+5033>
test/lang/member.ci:50:[.059ab8, .059ac1) exec(1), time(0.001-0.001 ms): <.main+5060>
test/lang/member.ci:50:[.059aaf, .059ac1) exec(1-1), time(0.000 ms): <.main+5051>
test/lang/member.ci:55:[.059aca, .059ad3) exec(1), time(0.001-0.001 ms): <.main+5078>
test/lang/member.ci:56:[.059ad3, .059adc) exec(1), time(0.001-0.001 ms): <.main+5087>
test/lang/member.ci:57:[.059adc, .059ae5) exec(1), time(0.002-0.002 ms): <.main+5096>
test/lang/member.ci:60:[.059ae5, .059aee) exec(1), time(0.002-0.002 ms): <.main+5105>
test/lang/member.ci:61:[.059aee, .059af7) exec(1), time(0.001-0.001 ms): <.main+5114>
test/lang/member.ci:65:[.059af7, .059b00) exec(1), time(0.001-0.001 ms): <.main+5123>
test/lang/member.ci:66:[.059b00, .059b09) exec(1), time(0.001-0.001 ms): <.main+5132>
test/lang/member.ci:53:[.059ac1, .059b09) exec(1-1), time(0.000 ms): <.main+5069>
test/lang/method.ci:18:[.059b09, .059b12) exec(1), time(0.001-0.001 ms): <.main+5141>
::[.059b1b, .059b23) exec(1), time(0.001-0.001 ms): <.main+5159>
::[.059b23, .059b2c) exec(1), time(0.002-0.002 ms): <.main+5167>
test/lang/method.ci:62:[.059b12, .059b2c) exec(1-1), time(0.000 ms): <.main+5150>
test/lang/recUnion.ci:26:[.059b33, .059b3a) exec(1), time(0.002-0.002 ms): <.main+5183>
test/lang/recUnion.ci:26:[.059b3a, .059b41) exec(1), time(0.002-0.002 ms): <.main+5190>
test/lang/recUnion.ci:26:[.059b2c, .059b41) exec(1-1), time(0.000 ms): <.main+5176>
test/lang/recUnion.ci:27:[.059b48, .059b53) exec(1), time(0.002-0.002 ms): <.main+5204>
test/lang/recUnion.ci:27:[.059b53, .059b5a) exec(1), time(0.003-0.003 ms): <.main+5215>
test/lang/recUnion.ci:27:[.059b41, .059b5a) exec(1-1), time(0.000 ms): <.main+5197>
test/lang/recUnion.ci:28:[.059b65, .059b70) exec(1), time(0.002-0.002 ms): <.main+5233>
test/lang/recUnion.ci:28:[.059b70, .059b7b) exec(1), time(0.002-0.002 ms): <.main+5244>
test/lang/recUnion.ci:28:[.059b5a, .059b7b) exec(1-1), time(0.000 ms): <.main+5222>
test/lang/recUnion.ci:30:[.059b7b, .059b84) exec(1), time(0.002-0.002 ms): <.main+5255>
test/lang/recUnion.ci:31:[.059b8b, .059b92) exec(1), time(0.002-0.002 ms): <.main+5271>
test/lang/recUnion.ci:31:[.059b92, .059b9d) exec(1), time(0.002-0.002 ms): <.main+5278>
test/lang/recUnion.ci:31:[.059b84, .059b9d) exec(1-1), time(0.000 ms): <.main+5264>
test/lang/useOperator.ci:5:[.059b9d, .059ba6) exec(1), time(0.002-0.002 ms): <.main+5289>
test/lang/useOperator.ci:7:[.059ba6, .059bb1) exec(1), time(0.003-0.003 ms): <.main+5298>
test/lang/useOperator.ci:8:[.059bb1, .059bbc) exec(1), time(0.002-0.002 ms): <.main+5309>
test/lang/useOperator.ci:17:[.059bbc, .059bcf) exec(1), time(0.005-0.005 ms): <.main+5320>
test/lang/useOperator.ci:18:[.059bcf, .059be2) exec(1), time(0.006-0.006 ms): <.main+5339>
test/lang/useOperator.ci:19:[.059be2, .059bf5) exec(1), time(0.006-0.006 ms): <.main+5358>
test/lang/useOperator.ci:22:[.059bf5, .059c02) exec(1), time(0.004-0.004 ms): <.main+5377>
test/lang/useOperator.ci:23:[.059c02, .059c15) exec(1), time(0.005-0.005 ms): <.main+5390>
test/lang/useOperator.ci:24:[.059c15, .059c29) exec(1), time(0.006-0.006 ms): <.main+5409>
test/lang/useOperator.ci:25:[.059c29, .059c3c) exec(1), time(0.005-0.005 ms): <.main+5429>
test/lang/useOperator.ci:26:[.059c3c, .059c50) exec(1), time(0.006-0.006 ms): <.main+5448>
test/lang/useOperator.ci:27:[.059c50, .059c63) exec(1), time(0.006-0.006 ms): <.main+5468>
test/lang/useOperator.ci:28:[.059c63, .059c77) exec(1), time(0.007-0.007 ms): <.main+5487>
test/lang/useOperator.ci:30:[.059c77, .059c82) exec(1), time(0.003-0.003 ms): <.main+5507>
test/lang/useOperator.ci:31:[.059c82, .059c8d) exec(1), time(0.002-0.002 ms): <.main+5518>
test/lang/useOperator.ci:32:[.059c8d, .059c99) exec(1), time(0.003-0.003 ms): <.main+5529>
test/lang/useOperator.ci:33:[.059c99, .059ca6) exec(1), time(0.004-0.004 ms): <.main+5541>
test/lang/useOperator.ci:34:[.059ca6, .059cb3) exec(1), time(0.004-0.004 ms): <.main+5554>
test/lang/useOperator.ci:35:[.059cb3, .059cc6) exec(1), time(0.019-0.019 ms): <.main+5567>
test/lang/useOperator.ci:36:[.059cc6, .059cd9) exec(1), time(0.005-0.005 ms): <.main+5586>
test/lang/useOperator.ci:37:[.059cd9, .059cec) exec(1), time(0.005-0.005 ms): <.main+5605>
test/lang/useOperator.ci:38:[.059cec, .059cff) exec(1), time(0.005-0.005 ms): <.main+5624>
test/lang/useOperator.ci:39:[.059cff, .059d12) exec(1), time(0.005-0.005 ms): <.main+5643>
test/lang/useOperator.ci:40:[.059d12, .059d25) exec(1), time(0.005-0.005 ms): <.main+5662>
test/lang/useOperator.ci:41:[.059d25, .059d38) exec(1), time(0.005-0.005 ms): <.main+5681>
test/lang/useOperator.ci:42:[.059d38, .059d4b) exec(1), time(0.005-0.005 ms): <.main+5700>
test/lang/useOperator.ci:43:[.059d4b, .059d5c) exec(1), time(0.005-0.005 ms): <.main+5719>
test/lang/useOperator.ci:44:[.059d5c, .059d6d) exec(1), time(0.005-0.005 ms): <.main+5736>
test/lang/useOperator.ci:45:[.059d6d, .059d7b) exec(1), time(0.004-0.004 ms): <.main+5753>
test/lang/useOperator.ci:46:[.059d7b, .059d8e) exec(1), time(0.005-0.005 ms): <.main+5767>
test/lang/useOperator.ci:47:[.059d8e, .059da2) exec(1), time(0.006-0.006 ms): <.main+5786>
test/lang/useOperator.ci:48:[.059da2, .059db5) exec(1), time(0.006-0.006 ms): <.main+5806>
test/lang/useOperator.ci:49:[.059db5, .059dc9) exec(1), time(0.006-0.006 ms): <.main+5825>
test/lang/useOperator.ci:50:[.059dc9, .059ddc) exec(1), time(0.005-0.005 ms): <.main+5845>
test/lang/useOperator.ci:51:[.059ddc, .059df0) exec(1), time(0.006-0.006 ms): <.main+5864>
test/lang/useOperator.ci:53:[.059df0, .059dfb) exec(1), time(0.003-0.003 ms): <.main+5884>
test/lang/useOperator.ci:54:[.059dfb, .059e06) exec(1), time(0.003-0.003 ms): <.main+5895>
test/lang/useOperator.ci:55:[.059e06, .059e12) exec(1), time(0.004-0.004 ms): <.main+5906>
test/lang/useOperator.ci:56:[.059e12, .059e1f) exec(1), time(0.005-0.005 ms): <.main+5918>
test/lang/useOperator.ci:57:[.059e1f, .059e2c) exec(1), time(0.004-0.004 ms): <.main+5931>
test/lang/useOperator.ci:58:[.059e2c, .059e3f) exec(1), time(0.006-0.006 ms): <.main+5944>
test/lang/useOperator.ci:59:[.059e3f, .059e52) exec(1), time(0.019-0.019 ms): <.main+5963>
test/lang/useOperator.ci:60:[.059e52, .059e65) exec(1), time(0.006-0.006 ms): <.main+5982>
test/lang/useOperator.ci:61:[.059e65, .059e78) exec(1), time(0.006-0.006 ms): <.main+6001>
test/lang/useOperator.ci:62:[.059e78, .059e8b) exec(1), time(0.005-0.005 ms): <.main+6020>
test/lang/useOperator.ci:63:[.059e8b, .059e9e) exec(1), time(0.006-0.006 ms): <.main+6039>
test/lang/useOperator.ci:64:[.059e9e, .059eb1) exec(1), time(0.006-0.006 ms): <.main+6058>
test/lang/useOperator.ci:65:[.059eb1, .059ec4) exec(1), time(0.006-0.006 ms): <.main+6077>
test/lang/useOperator.ci:66:[.059ec4, .059ed5) exec(1), time(0.005-0.005 ms): <.main+6096>
test/lang/useOperator.ci:67:[.059ed5, .059ee6) exec(1), time(0.005-0.005 ms): <.main+6113>
test/lang/useOperator.ci:68:[.059ee6, .059ef4) exec(1), time(0.005-0.005 ms): <.main+6130>
test/lang/useOperator.ci:69:[.059ef4, .059f07) exec(1), time(0.006-0.006 ms): <.main+6144>
test/lang/useOperator.ci:70:[.059f07, .059f1b) exec(1), time(0.008-0.008 ms): <.main+6163>
test/lang/useOperator.ci:71:[.059f1b, .059f2e) exec(1), time(0.007-0.007 ms): <.main+6183>
test/lang/useOperator.ci:72:[.059f2e, .059f42) exec(1), time(0.011-0.011 ms): <.main+6202>
test/lang/useOperator.ci:73:[.059f42, .059f55) exec(1), time(0.008-0.008 ms): <.main+6222>
test/lang/useOperator.ci:74:[.059f55, .059f69) exec(1), time(0.007-0.007 ms): <.main+6241>
test/lang/useOperator.ci:76:[.059f69, .059f74) exec(1), time(0.017-0.017 ms): <.main+6261>
test/lang/useOperator.ci:77:[.059f74, .059f7f) exec(1), time(0.003-0.003 ms): <.main+6272>
test/lang/useOperator.ci:78:[.059f7f, .059f8b) exec(1), time(0.003-0.003 ms): <.main+6283>
test/lang/useOperator.ci:79:[.059f8b, .059f98) exec(1), time(0.004-0.004 ms): <.main+6295>
test/lang/useOperator.ci:80:[.059f98, .059fa5) exec(1), time(0.004-0.004 ms): <.main+6308>
test/lang/useOperator.ci:81:[.059fa5, .059fb8) exec(1), time(0.007-0.007 ms): <.main+6321>
test/lang/useOperator.ci:82:[.059fb8, .059fcb) exec(1), time(0.006-0.006 ms): <.main+6340>
test/lang/useOperator.ci:83:[.059fcb, .059fde) exec(1), time(0.006-0.006 ms): <.main+6359>
test/lang/useOperator.ci:84:[.059fde, .059ff1) exec(1), time(0.006-0.006 ms): <.main+6378>
test/lang/useOperator.ci:85:[.059ff1, .05a004) exec(1), time(0.019-0.019 ms): <.main+6397>
test/lang/useOperator.ci:86:[.05a004, .05a017) exec(1), time(0.005-0.005 ms): <.main+6416>
test/lang/useOperator.ci:87:[.05a017, .05a02a) exec(1), time(0.006-0.006 ms): <.main+6435>
test/lang/useOperator.ci:88:[.05a02a, .05a03d) exec(1), time(0.006-0.006 ms): <.main+6454>
test/lang/useOperator.ci:89:[.05a03d, .05a04e) exec(1), time(0.005-0.005 ms): <.main+6473>
test/lang/useOperator.ci:90:[.05a04e, .05a05f) exec(1), time(0.005-0.005 ms): <.main+6490>
test/lang/useOperator.ci:91:[.05a05f, .05a06d) exec(1), time(0.004-0.004 ms): <.main+6507>
test/lang/useOperator.ci:92:[.05a06d, .05a080) exec(1), time(0.006-0.006 ms): <.main+6521>
test/lang/useOperator.ci:93:[.05a080, .05a094) exec(1), time(0.007-0.007 ms): <.main+6540>
test/lang/useOperator.ci:94:[.05a094, .05a0a7) exec(1), time(0.006-0.006 ms): <.main+6560>
test/lang/useOperator.ci:95:[.05a0a7, .05a0bb) exec(1), time(0.006-0.006 ms): <.main+6579>
test/lang/useOperator.ci:96:[.05a0bb, .05a0ce) exec(1), time(0.006-0.006 ms): <.main+6599>
test/lang/useOperator.ci:97:[.05a0ce, .05a0e2) exec(1), time(0.007-0.007 ms): <.main+6618>
test/lang/useOperator.ci:99:[.05a0e2, .05a0ed) exec(1), time(0.002-0.002 ms): <.main+6638>
test/lang/useOperator.ci:100:[.05a0ed, .05a0f8) exec(1), time(0.002-0.002 ms): <.main+6649>
test/lang/useOperator.ci:101:[.05a0f8, .05a104) exec(1), time(0.003-0.003 ms): <.main+6660>
test/lang/useOperator.ci:102:[.05a104, .05a111) exec(1), time(0.004-0.004 ms): <.main+6672>
test/lang/useOperator.ci:103:[.05a111, .05a11e) exec(1), time(0.004-0.004 ms): <.main+6685>
test/lang/useOperator.ci:104:[.05a11e, .05a131) exec(1), time(0.006-0.006 ms): <.main+6698>
test/lang/useOperator.ci:105:[.05a131, .05a144) exec(1), time(0.006-0.006 ms): <.main+6717>
test/lang/useOperator.ci:106:[.05a144, .05a157) exec(1), time(0.006-0.006 ms): <.main+6736>
test/lang/useOperator.ci:107:[.05a157, .05a16a) exec(1), time(0.006-0.006 ms): <.main+6755>
test/lang/useOperator.ci:108:[.05a16a, .05a17d) exec(1), time(0.006-0.006 ms): <.main+6774>
test/lang/useOperator.ci:109:[.05a17d, .05a190) exec(1), time(0.020-0.020 ms): <.main+6793>
test/lang/useOperator.ci:110:[.05a190, .05a1a3) exec(1), time(0.006-0.006 ms): <.main+6812>
test/lang/useOperator.ci:111:[.05a1a3, .05a1b6) exec(1), time(0.007-0.007 ms): <.main+6831>
test/lang/useOperator.ci:112:[.05a1b6, .05a1c7) exec(1), time(0.005-0.005 ms): <.main+6850>
test/lang/useOperator.ci:113:[.05a1c7, .05a1d8) exec(1), time(0.005-0.005 ms): <.main+6867>
test/lang/useOperator.ci:114:[.05a1d8, .05a1e6) exec(1), time(0.005-0.005 ms): <.main+6884>
test/lang/useOperator.ci:115:[.05a1e6, .05a1f9) exec(1), time(0.006-0.006 ms): <.main+6898>
test/lang/useOperator.ci:116:[.05a1f9, .05a20d) exec(1), time(0.008-0.008 ms): <.main+6917>
test/lang/useOperator.ci:117:[.05a20d, .05a220) exec(1), time(0.006-0.006 ms): <.main+6937>
test/lang/useOperator.ci:118:[.05a220, .05a234) exec(1), time(0.011-0.011 ms): <.main+6956>
test/lang/useOperator.ci:119:[.05a234, .05a247) exec(1), time(0.007-0.007 ms): <.main+6976>
test/lang/useOperator.ci:120:[.05a247, .05a25b) exec(1), time(0.009-0.009 ms): <.main+6995>
test/lang/useOperator.ci:122:[.05a25b, .05a266) exec(1), time(0.003-0.003 ms): <.main+7015>
test/lang/useOperator.ci:123:[.05a266, .05a271) exec(1), time(0.002-0.002 ms): <.main+7026>
test/lang/useOperator.ci:124:[.05a271, .05a27d) exec(1), time(0.004-0.004 ms): <.main+7037>
test/lang/useOperator.ci:125:[.05a27d, .05a28a) exec(1), time(0.005-0.005 ms): <.main+7049>
test/lang/useOperator.ci:126:[.05a28a, .05a297) exec(1), time(0.004-0.004 ms): <.main+7062>
test/lang/useOperator.ci:127:[.05a297, .05a2aa) exec(1), time(0.007-0.007 ms): <.main+7075>
test/lang/useOperator.ci:128:[.05a2aa, .05a2bd) exec(1), time(0.007-0.007 ms): <.main+7094>
test/lang/useOperator.ci:129:[.05a2bd, .05a2d0) exec(1), time(0.008-0.008 ms): <.main+7113>
test/lang/useOperator.ci:130:[.05a2d0, .05a2e3) exec(1), time(0.008-0.008 ms): <.main+7132>
test/lang/useOperator.ci:131:[.05a2e3, .05a2f6) exec(1), time(0.006-0.006 ms): <.main+7151>
test/lang/useOperator.ci:132:[.05a2f6, .05a309) exec(1), time(0.007-0.007 ms): <.main+7170>
test/lang/useOperator.ci:133:[.05a309, .05a31c) exec(1), time(0.006-0.006 ms): <.main+7189>
test/lang/useOperator.ci:134:[.05a31c, .05a32f) exec(1), time(0.007-0.007 ms): <.main+7208>
test/lang/useOperator.ci:135:[.05a32f, .05a340) exec(1), time(0.006-0.006 ms): <.main+7227>
test/lang/useOperator.ci:136:[.05a340, .05a351) exec(1), time(0.006-0.006 ms): <.main+7244>
test/lang/useOperator.ci:137:[.05a351, .05a35f) exec(1), time(0.006-0.006 ms): <.main+7261>
test/lang/useOperator.ci:138:[.05a35f, .05a372) exec(1), time(0.007-0.007 ms): <.main+7275>
test/lang/useOperator.ci:139:[.05a372, .05a386) exec(1), time(0.022-0.022 ms): <.main+7294>
test/lang/useOperator.ci:140:[.05a386, .05a399) exec(1), time(0.007-0.007 ms): <.main+7314>
test/lang/useOperator.ci:141:[.05a399, .05a3ad) exec(1), time(0.008-0.008 ms): <.main+7333>
test/lang/useOperator.ci:142:[.05a3ad, .05a3c0) exec(1), time(0.020-0.020 ms): <.main+7353>
test/lang/useOperator.ci:143:[.05a3c0, .05a3d4) exec(1), time(0.007-0.007 ms): <.main+7372>
test/lang/useOperator.ci:145:[.05a3d4, .05a3dd) exec(1), time(0.002-0.002 ms): <.main+7392>
test/lang/useOperator.ci:146:[.05a3dd, .05a3e6) exec(1), time(0.002-0.002 ms): <.main+7401>
test/lang/useOperator.ci:147:[.05a3e6, .05a3ee) exec(1), time(0.002-0.002 ms): <.main+7410>
test/lang/useOperator.ci:148:[.05a3ee, .05a3f7) exec(1), time(0.003-0.003 ms): <.main+7418>
test/lang/useOperator.ci:149:[.05a3f7, .05a400) exec(1), time(0.017-0.017 ms): <.main+7427>
test/lang/useOperator.ci:150:[.05a400, .05a40d) exec(1), time(0.003-0.003 ms): <.main+7436>
test/lang/useOperator.ci:151:[.05a40d, .05a41a) exec(1), time(0.004-0.004 ms): <.main+7449>
test/lang/useOperator.ci:152:[.05a41a, .05a427) exec(1), time(0.004-0.004 ms): <.main+7462>
test/lang/useOperator.ci:153:[.05a427, .05a434) exec(1), time(0.004-0.004 ms): <.main+7475>
test/lang/useOperator.ci:154:[.05a434, .05a441) exec(1), time(0.017-0.017 ms): <.main+7488>
test/lang/useOperator.ci:155:[.05a441, .05a44e) exec(1), time(0.003-0.003 ms): <.main+7501>
test/lang/useOperator.ci:156:[.05a44e, .05a45b) exec(1), time(0.004-0.004 ms): <.main+7514>
test/lang/useOperator.ci:157:[.05a45b, .05a468) exec(1), time(0.004-0.004 ms): <.main+7527>
test/lang/useOperator.ci:158:[.05a468, .05a475) exec(1), time(0.003-0.003 ms): <.main+7540>
test/lang/useOperator.ci:159:[.05a475, .05a482) exec(1), time(0.004-0.004 ms): <.main+7553>
test/lang/useOperator.ci:160:[.05a482, .05a48e) exec(1), time(0.005-0.005 ms): <.main+7566>
test/lang/useOperator.ci:161:[.05a48e, .05a49d) exec(1), time(0.005-0.005 ms): <.main+7578>
test/lang/useOperator.ci:162:[.05a49d, .05a4ad) exec(1), time(0.005-0.005 ms): <.main+7593>
test/lang/useOperator.ci:163:[.05a4ad, .05a4bc) exec(1), time(0.005-0.005 ms): <.main+7609>
test/lang/useOperator.ci:164:[.05a4bc, .05a4cc) exec(1), time(0.006-0.006 ms): <.main+7624>
test/lang/useOperator.ci:165:[.05a4cc, .05a4db) exec(1), time(0.005-0.005 ms): <.main+7640>
test/lang/useOperator.ci:166:[.05a4db, .05a4eb) exec(1), time(0.020-0.020 ms): <.main+7655>
test/lang/useOperator.ci:168:[.05a4eb, .05a4f4) exec(1), time(0.002-0.002 ms): <.main+7671>
test/lang/useOperator.ci:169:[.05a4f4, .05a4fd) exec(1), time(0.002-0.002 ms): <.main+7680>
test/lang/useOperator.ci:170:[.05a4fd, .05a505) exec(1), time(0.002-0.002 ms): <.main+7689>
test/lang/useOperator.ci:171:[.05a505, .05a50e) exec(1), time(0.002-0.002 ms): <.main+7697>
test/lang/useOperator.ci:172:[.05a50e, .05a517) exec(1), time(0.003-0.003 ms): <.main+7706>
test/lang/useOperator.ci:173:[.05a517, .05a524) exec(1), time(0.003-0.003 ms): <.main+7715>
test/lang/useOperator.ci:174:[.05a524, .05a531) exec(1), time(0.004-0.004 ms): <.main+7728>
test/lang/useOperator.ci:175:[.05a531, .05a53e) exec(1), time(0.004-0.004 ms): <.main+7741>
test/lang/useOperator.ci:176:[.05a53e, .05a54b) exec(1), time(0.004-0.004 ms): <.main+7754>
test/lang/useOperator.ci:177:[.05a54b, .05a558) exec(1), time(0.004-0.004 ms): <.main+7767>
test/lang/useOperator.ci:178:[.05a558, .05a565) exec(1), time(0.004-0.004 ms): <.main+7780>
test/lang/useOperator.ci:179:[.05a565, .05a572) exec(1), time(0.004-0.004 ms): <.main+7793>
test/lang/useOperator.ci:180:[.05a572, .05a57f) exec(1), time(0.005-0.005 ms): <.main+7806>
test/lang/useOperator.ci:181:[.05a57f, .05a58c) exec(1), time(0.004-0.004 ms): <.main+7819>
test/lang/useOperator.ci:182:[.05a58c, .05a599) exec(1), time(0.004-0.004 ms): <.main+7832>
test/lang/useOperator.ci:183:[.05a599, .05a5a5) exec(1), time(0.006-0.006 ms): <.main+7845>
test/lang/useOperator.ci:184:[.05a5a5, .05a5b4) exec(1), time(0.019-0.019 ms): <.main+7857>
test/lang/useOperator.ci:185:[.05a5b4, .05a5c4) exec(1), time(0.006-0.006 ms): <.main+7872>
test/lang/useOperator.ci:186:[.05a5c4, .05a5d3) exec(1), time(0.005-0.005 ms): <.main+7888>
test/lang/useOperator.ci:187:[.05a5d3, .05a5e3) exec(1), time(0.006-0.006 ms): <.main+7903>
test/lang/useOperator.ci:188:[.05a5e3, .05a5f2) exec(1), time(0.005-0.005 ms): <.main+7919>
test/lang/useOperator.ci:189:[.05a5f2, .05a602) exec(1), time(0.006-0.006 ms): <.main+7934>
test/lang/useOperator.ci:191:[.05a602, .05a60f) exec(1), time(0.002-0.002 ms): <.main+7950>
test/lang/useOperator.ci:192:[.05a60f, .05a61c) exec(1), time(0.002-0.002 ms): <.main+7963>
test/lang/useOperator.ci:193:[.05a61c, .05a624) exec(1), time(0.002-0.002 ms): <.main+7976>
test/lang/useOperator.ci:194:[.05a624, .05a62d) exec(1), time(0.003-0.003 ms): <.main+7984>
test/lang/useOperator.ci:195:[.05a62d, .05a636) exec(1), time(0.003-0.003 ms): <.main+7993>
test/lang/useOperator.ci:196:[.05a636, .05a643) exec(1), time(0.004-0.004 ms): <.main+8002>
test/lang/useOperator.ci:197:[.05a643, .05a650) exec(1), time(0.018-0.018 ms): <.main+8015>
test/lang/useOperator.ci:198:[.05a650, .05a65d) exec(1), time(0.004-0.004 ms): <.main+8028>
test/lang/useOperator.ci:199:[.05a65d, .05a66a) exec(1), time(0.003-0.003 ms): <.main+8041>
test/lang/useOperator.ci:200:[.05a66a, .05a677) exec(1), time(0.004-0.004 ms): <.main+8054>
test/lang/useOperator.ci:201:[.05a677, .05a684) exec(1), time(0.004-0.004 ms): <.main+8067>
test/lang/useOperator.ci:202:[.05a684, .05a691) exec(1), time(0.003-0.003 ms): <.main+8080>
test/lang/useOperator.ci:203:[.05a691, .05a69e) exec(1), time(0.004-0.004 ms): <.main+8093>
test/lang/useOperator.ci:204:[.05a69e, .05a6ab) exec(1), time(0.004-0.004 ms): <.main+8106>
test/lang/useOperator.ci:205:[.05a6ab, .05a6b8) exec(1), time(0.004-0.004 ms): <.main+8119>
test/lang/useOperator.ci:206:[.05a6b8, .05a6c4) exec(1), time(0.005-0.005 ms): <.main+8132>
test/lang/useOperator.ci:207:[.05a6c4, .05a6d3) exec(1), time(0.005-0.005 ms): <.main+8144>
test/lang/useOperator.ci:208:[.05a6d3, .05a6e3) exec(1), time(0.006-0.006 ms): <.main+8159>
test/lang/useOperator.ci:209:[.05a6e3, .05a6f2) exec(1), time(0.005-0.005 ms): <.main+8175>
test/lang/useOperator.ci:210:[.05a6f2, .05a702) exec(1), time(0.006-0.006 ms): <.main+8190>
test/lang/useOperator.ci:211:[.05a702, .05a711) exec(1), time(0.005-0.005 ms): <.main+8206>
test/lang/useOperator.ci:212:[.05a711, .05a721) exec(1), time(0.006-0.006 ms): <.main+8221>
test/lang/useOperator.ci:214:[.05a721, .05a72e) exec(1), time(0.002-0.002 ms): <.main+8237>
test/lang/useOperator.ci:215:[.05a72e, .05a73b) exec(1), time(0.002-0.002 ms): <.main+8250>
test/lang/useOperator.ci:216:[.05a73b, .05a743) exec(1), time(0.001-0.001 ms): <.main+8263>
test/lang/useOperator.ci:217:[.05a743, .05a74c) exec(1), time(0.003-0.003 ms): <.main+8271>
test/lang/useOperator.ci:218:[.05a74c, .05a755) exec(1), time(0.003-0.003 ms): <.main+8280>
test/lang/useOperator.ci:219:[.05a755, .05a762) exec(1), time(0.003-0.003 ms): <.main+8289>
test/lang/useOperator.ci:220:[.05a762, .05a76f) exec(1), time(0.005-0.005 ms): <.main+8302>
test/lang/useOperator.ci:221:[.05a76f, .05a77c) exec(1), time(0.004-0.004 ms): <.main+8315>
test/lang/useOperator.ci:222:[.05a77c, .05a789) exec(1), time(0.004-0.004 ms): <.main+8328>
test/lang/useOperator.ci:223:[.05a789, .05a796) exec(1), time(0.004-0.004 ms): <.main+8341>
test/lang/useOperator.ci:224:[.05a796, .05a7a3) exec(1), time(0.004-0.004 ms): <.main+8354>
test/lang/useOperator.ci:225:[.05a7a3, .05a7b0) exec(1), time(0.004-0.004 ms): <.main+8367>
test/lang/useOperator.ci:226:[.05a7b0, .05a7bd) exec(1), time(0.004-0.004 ms): <.main+8380>
test/lang/useOperator.ci:227:[.05a7bd, .05a7ca) exec(1), time(0.004-0.004 ms): <.main+8393>
test/lang/useOperator.ci:228:[.05a7ca, .05a7d7) exec(1), time(0.004-0.004 ms): <.main+8406>
test/lang/useOperator.ci:229:[.05a7d7, .05a7e3) exec(1), time(0.005-0.005 ms): <.main+8419>
test/lang/useOperator.ci:230:[.05a7e3, .05a7f2) exec(1), time(0.005-0.005 ms): <.main+8431>
test/lang/useOperator.ci:231:[.05a7f2, .05a802) exec(1), time(0.006-0.006 ms): <.main+8446>
test/lang/useOperator.ci:232:[.05a802, .05a811) exec(1), time(0.005-0.005 ms): <.main+8462>
test/lang/useOperator.ci:233:[.05a811, .05a821) exec(1), time(0.006-0.006 ms): <.main+8477>
test/lang/useOperator.ci:234:[.05a821, .05a830) exec(1), time(0.005-0.005 ms): <.main+8493>
test/lang/useOperator.ci:235:[.05a830, .05a840) exec(1), time(0.006-0.006 ms): <.main+8508>
test/lang/useOperator.ci:237:[.05a840, .05a849) exec(1), time(0.002-0.002 ms): <.main+8524>
test/lang/useOperator.ci:238:[.05a849, .05a852) exec(1), time(0.002-0.002 ms): <.main+8533>
test/lang/useOperator.ci:239:[.05a852, .05a85a) exec(1), time(0.002-0.002 ms): <.main+8542>
test/lang/useOperator.ci:240:[.05a85a, .05a863) exec(1), time(0.003-0.003 ms): <.main+8550>
test/lang/useOperator.ci:242:[.05a863, .05a870) exec(1), time(0.004-0.004 ms): <.main+8559>
test/lang/useOperator.ci:243:[.05a870, .05a87d) exec(1), time(0.004-0.004 ms): <.main+8572>
test/lang/useOperator.ci:244:[.05a87d, .05a88a) exec(1), time(0.004-0.004 ms): <.main+8585>
test/lang/useOperator.ci:245:[.05a88a, .05a897) exec(1), time(0.005-0.005 ms): <.main+8598>
test/lang/useOperator.ci:246:[.05a897, .05a8a4) exec(1), time(0.007-0.007 ms): <.main+8611>
test/lang/useOperator.ci:252:[.05a8a4, .05a8b0) exec(1), time(0.008-0.008 ms): <.main+8624>
test/lang/useOperator.ci:253:[.05a8b0, .05a8bf) exec(1), time(0.005-0.005 ms): <.main+8636>
test/lang/useOperator.ci:254:[.05a8bf, .05a8cf) exec(1), time(0.006-0.006 ms): <.main+8651>
test/lang/useOperator.ci:255:[.05a8cf, .05a8de) exec(1), time(0.005-0.005 ms): <.main+8667>
test/lang/useOperator.ci:256:[.05a8de, .05a8ee) exec(1), time(0.006-0.006 ms): <.main+8682>
test/lang/useOperator.ci:257:[.05a8ee, .05a8fd) exec(1), time(0.006-0.006 ms): <.main+8698>
test/lang/useOperator.ci:258:[.05a8fd, .05a90d) exec(1), time(0.007-0.007 ms): <.main+8713>
test/lang/useOperator.ci:260:[.05a90d, .05a91a) exec(1), time(0.002-0.002 ms): <.main+8729>
test/lang/useOperator.ci:261:[.05a91a, .05a927) exec(1), time(0.002-0.002 ms): <.main+8742>
test/lang/useOperator.ci:262:[.05a927, .05a92f) exec(1), time(0.002-0.002 ms): <.main+8755>
test/lang/useOperator.ci:263:[.05a92f, .05a938) exec(1), time(0.003-0.003 ms): <.main+8763>
test/lang/useOperator.ci:265:[.05a938, .05a945) exec(1), time(0.004-0.004 ms): <.main+8772>
test/lang/useOperator.ci:266:[.05a945, .05a952) exec(1), time(0.005-0.005 ms): <.main+8785>
test/lang/useOperator.ci:267:[.05a952, .05a95f) exec(1), time(0.004-0.004 ms): <.main+8798>
test/lang/useOperator.ci:268:[.05a95f, .05a96c) exec(1), time(0.004-0.004 ms): <.main+8811>
test/lang/useOperator.ci:269:[.05a96c, .05a979) exec(1), time(0.005-0.005 ms): <.main+8824>
test/lang/useOperator.ci:275:[.05a979, .05a985) exec(1), time(0.006-0.006 ms): <.main+8837>
test/lang/useOperator.ci:276:[.05a985, .05a994) exec(1), time(0.004-0.004 ms): <.main+8849>
test/lang/useOperator.ci:277:[.05a994, .05a9a4) exec(1), time(0.006-0.006 ms): <.main+8864>
test/lang/useOperator.ci:278:[.05a9a4, .05a9b3) exec(1), time(0.005-0.005 ms): <.main+8880>
test/lang/useOperator.ci:279:[.05a9b3, .05a9c3) exec(1), time(0.006-0.006 ms): <.main+8895>
test/lang/useOperator.ci:280:[.05a9c3, .05a9d2) exec(1), time(0.005-0.005 ms): <.main+8911>
test/lang/useOperator.ci:281:[.05a9d2, .05a9e2) exec(1), time(0.006-0.006 ms): <.main+8926>
test/lang/useOperator.ci:283:[.05a9e2, .05a9eb) exec(1), time(0.002-0.002 ms): <.main+8942>
test/lang/useOperator.ci:284:[.05a9eb, .05a9f4) exec(1), time(0.002-0.002 ms): <.main+8951>
test/lang/useOperator.ci:299:[.05a9f4, .05aa03) exec(1), time(0.005-0.005 ms): <.main+8960>
test/lang/useOperator.ci:300:[.05aa03, .05aa13) exec(1), time(0.006-0.006 ms): <.main+8975>
test/lang/statementIf.ci:26:[.05aa13, .05aa18) exec(1), time(0.002-0.002 ms): <.main+8991>
test/lang/statementFor.ci:12:[.05aa18, .05aa1d) exec(1), time(0.002-0.002 ms): <.main+8996>
test/std/test.math.ci:3:[.05aa1d, .05aa35) exec(1), time(0.080-0.080 ms): <.main+9001>
test/std/test.math.ci:4:[.05aa35, .05aa4d) exec(1), time(0.065-0.065 ms): <.main+9025>
test/std/test.math.ci:5:[.05aa4d, .05aa65) exec(1), time(0.076-0.076 ms): <.main+9049>
test/std/test.math.ci:6:[.05aa65, .05aa7d) exec(1), time(0.089-0.089 ms): <.main+9073>
test/std/test.math.ci:7:[.05aa7d, .05aa95) exec(1), time(0.127-0.127 ms): <.main+9097>
test/std/test.math.ci:8:[.05aa95, .05aaad) exec(1), time(0.100-0.100 ms): <.main+9121>
test/std/test.math.ci:10:[.05aaad, .05aaca) exec(1), time(0.017-0.017 ms): <.main+9145>
test/std/test.math.ci:11:[.05aaca, .05aadf) exec(1), time(0.017-0.017 ms): <.main+9174>
test/std/test.math.ci:12:[.05aadf, .05aafc) exec(1), time(0.016-0.016 ms): <.main+9195>
test/std/test.math.ci:13:[.05aafc, .05ab11) exec(1), time(0.029-0.029 ms): <.main+9224>
test/std/test.math.ci:14:[.05ab11, .05ab22) exec(1), time(0.011-0.011 ms): <.main+9245>
test/std/test.math.ci:15:[.05ab22, .05ab37) exec(1), time(0.011-0.011 ms): <.main+9262>
test/std/test.math.ci:17:[.05ab37, .05ab4f) exec(1), time(0.038-0.038 ms): <.main+9283>
test/std/test.math.ci:18:[.05ab4f, .05ab5e) exec(1), time(0.024-0.024 ms): <.main+9307>
test/std/test.math.ci:19:[.05ab5e, .05ab76) exec(1), time(0.038-0.038 ms): <.main+9322>
test/std/test.math.ci:20:[.05ab76, .05ab8b) exec(1), time(0.040-0.040 ms): <.main+9346>
test/std/test.math.ci:21:[.05ab8b, .05ab9c) exec(1), time(0.026-0.026 ms): <.main+9367>
test/std/test.math.ci:22:[.05ab9c, .05abb1) exec(1), time(0.026-0.026 ms): <.main+9384>
test/std/test.math.ci:24:[.05abb1, .05abcb) exec(1), time(0.027-0.027 ms): <.main+9405>
test/std/test.math.ci:25:[.05abcb, .05abe5) exec(1), time(0.029-0.029 ms): <.main+9431>
test/std/test.math.ci:26:[.05abe5, .05ac06) exec(1), time(0.036-0.036 ms): <.main+9457>
test/std/test.math.ci:27:[.05ac06, .05ac27) exec(1), time(0.037-0.037 ms): <.main+9490>
test/std/test.math.ci:29:[.05ac27, .05ac42) exec(1), time(0.046-0.046 ms): <.main+9523>
test/std/test.math.ci:30:[.05ac42, .05ac64) exec(1), time(0.041-0.041 ms): <.main+9550>
test/std/test.math.ci:32:[.05ac64, .05ac7d) exec(1), time(0.011-0.011 ms): <.main+9584>
test/std/test.math.ci:33:[.05ac7d, .05ac9d) exec(1), time(0.009-0.009 ms): <.main+9609>
test/std/test.math.ci:35:[.05ac9d, .05acdd) exec(1), time(0.050-0.050 ms): <.main+9641>
test/std/test.math.ci:36:[.05acdd, .05ad2f) exec(1), time(0.052-0.052 ms): <.main+9705>
test/std/test.math.ci:38:[.05ad2f, .05ad48) exec(1), time(0.040-0.040 ms): <.main+9787>
test/std/test.math.ci:39:[.05ad48, .05adb6) exec(1), time(0.128-0.128 ms): <.main+9812>
test/std/test.math.ci:40:[.05adb6, .05adcf) exec(1), time(0.057-0.057 ms): <.main+9922>
test/std/test.math.ci:41:[.05adcf, .05ae3d) exec(1), time(0.140-0.140 ms): <.main+9947>
test/std/test.math.ci:43:[.05ae3d, .05ae56) exec(1), time(0.080-0.080 ms): <.main+10057>
test/std/test.math.ci:44:[.05ae56, .05ae7c) exec(1), time(0.104-0.104 ms): <.main+10082>
test/std/test.math.ci:45:[.05ae7c, .05aeab) exec(1), time(0.076-0.076 ms): <.main+10120>
test/std/test.math.ci:46:[.05aeab, .05af22) exec(1), time(0.121-0.121 ms): <.main+10167>
test/std/test.math.ci:48:[.05af22, .05af2f) exec(1), time(0.002-0.002 ms): <.main+10286>
test/std/test.math.ci:49:[.05af2f, .05af4c) exec(1), time(0.050-0.050 ms): <.main+10299>
test/std/test.math.ci:50:[.05af4c, .05af59) exec(1), time(0.003-0.003 ms): <.main+10328>
test/std/test.math.ci:51:[.05af59, .05af75) exec(1), time(0.009-0.009 ms): <.main+10341>
test/std/test.math.ci:52:[.05af75, .05afa2) exec(1), time(0.018-0.018 ms): <.main+10369>
test/std/test.math.ci:53:[.05afa2, .05afe0) exec(1), time(0.028-0.028 ms): <.main+10414>
test/std/test.math.ci:54:[.05afe0, .05b02e) exec(1), time(0.110-0.110 ms): <.main+10476>
test/std/test.math.ci:55:[.05b02e, .05b085) exec(1), time(0.068-0.068 ms): <.main+10554>
test/std/test.math.ci:57:[.05b085, .05b0a8) exec(1), time(0.083-0.083 ms): <.main+10641>
test/std/test.math.ci:58:[.05b0a8, .05b0d9) exec(1), time(0.091-0.091 ms): <.main+10676>
test/std/test.math.ci:59:[.05b0d9, .05b0fb) exec(1), time(0.121-0.121 ms): <.main+10725>
test/std/test.math.ci:60:[.05b0fb, .05b11d) exec(1), time(0.132-0.132 ms): <.main+10759>
test/std/test.math.ci:61:[.05b11d, .05b13f) exec(1), time(0.146-0.146 ms): <.main+10793>
test/std/test.math.ci:63:[.05b13f, .05b157) exec(1), time(0.151-0.151 ms): <.main+10827>
test/std/test.math.ci:64:[.05b157, .05b183) exec(1), time(0.118-0.118 ms): <.main+10851>
test/std/test.math.ci:67:[.05b183, .05b1a5) exec(1), time(0.035-0.035 ms): <.main+10895>
test/std/test.math.ci:68:[.05b1a5, .05b1d3) exec(1), time(0.035-0.035 ms): <.main+10929>
test/std/test.math.ci:70:[.05b1d3, .05b1f4) exec(1), time(0.028-0.028 ms): <.main+10975>
test/std/test.math.ci:71:[.05b1f4, .05b20c) exec(1), time(0.043-0.043 ms): <.main+11008>
test/std/test.math.ci:72:[.05b20c, .05b22d) exec(1), time(0.042-0.042 ms): <.main+11032>
test/std/test.math.ci:74:[.05b22d, .05b24e) exec(1), time(0.042-0.042 ms): <.main+11065>
test/std/test.math.ci:75:[.05b24e, .05b26f) exec(1), time(0.049-0.049 ms): <.main+11098>
test/std/test.math.ci:76:[.05b26f, .05b290) exec(1), time(0.026-0.026 ms): <.main+11131>
test/std/test.math.ci:77:[.05b290, .05b2b1) exec(1), time(0.026-0.026 ms): <.main+11164>
test/std/test.math.ci:79:[.05b2b1, .05b2d2) exec(1), time(0.034-0.034 ms): <.main+11197>
test/std/test.math.ci:80:[.05b2d2, .05b2f3) exec(1), time(0.027-0.027 ms): <.main+11230>
test/std/test.math.ci:81:[.05b2f3, .05b314) exec(1), time(0.035-0.035 ms): <.main+11263>
test/std/test.math.ci:82:[.05b314, .05b335) exec(1), time(0.038-0.038 ms): <.main+11296>
test/std/test.math.ci:84:[.05b335, .05b34e) exec(1), time(0.028-0.028 ms): <.main+11329>
test/std/test.math.ci:85:[.05b34e, .05b363) exec(1), time(0.026-0.026 ms): <.main+11354>
test/std/test.math.ci:86:[.05b363, .05b37c) exec(1), time(0.027-0.027 ms): <.main+11375>
test/std/test.math.ci:88:[.05b37c, .05b395) exec(1), time(0.042-0.042 ms): <.main+11400>
test/std/test.math.ci:89:[.05b395, .05b3ae) exec(1), time(0.028-0.028 ms): <.main+11425>
test/std/test.math.ci:90:[.05b3ae, .05b3c7) exec(1), time(0.040-0.040 ms): <.main+11450>
test/std/test.math.ci:91:[.05b3c7, .05b3e0) exec(1), time(0.026-0.026 ms): <.main+11475>
test/std/test.math.ci:93:[.05b3e0, .05b3f9) exec(1), time(0.027-0.027 ms): <.main+11500>
test/std/test.math.ci:94:[.05b3f9, .05b412) exec(1), time(0.027-0.027 ms): <.main+11525>
test/std/test.math.ci:95:[.05b412, .05b42b) exec(1), time(0.027-0.027 ms): <.main+11550>
test/std/test.math.ci:96:[.05b42b, .05b444) exec(1), time(0.027-0.027 ms): <.main+11575>
test/std/memory.ci:13:[.05b444, .05b456) exec(1), time(0.057-0.057 ms): <.main+11600>
test/std/memory.ci:14:[.05b456, .05b46b) exec(1), time(0.047-0.047 ms): <.main+11618>
test/std/memory.ci:17:[.05b46b, .05b478) exec(1), time(0.031-0.031 ms): <.main+11639>
test/std/memory.ci:18:[.05b478, .05b485) exec(1), time(0.063-0.063 ms): <.main+11652>
test/std/memory.ci:19:[.05b485, .05b492) exec(1), time(0.030-0.030 ms): <.main+11665>
test/std/memory.ci:20:[.05b492, .05b49f) exec(1), time(0.044-0.044 ms): <.main+11678>
test/std/memory.ci:26:[.05b49f, .05b4c2) exec(1), time(0.047-0.047 ms): <.main+11691>
test/std/memory.ci:27:[.05b4c2, .05b4e5) exec(1), time(0.044-0.044 ms): <.main+11726>
test/std/memory.ci:29:[.05b4e5, .05b4fb) exec(1), time(0.043-0.043 ms): <.main+11761>
test/std/memory.ci:30:[.05b4fb, .05b50d) exec(1), time(0.044-0.044 ms): <.main+11783>
test/std/memory.ci:32:[.05b50d, .05b530) exec(1), time(0.044-0.044 ms): <.main+11801>
test/std/memory.ci:33:[.05b530, .05b553) exec(1), time(0.044-0.044 ms): <.main+11836>
test/lang/array.ci:55:[.05b558, .05b56d) exec(7), time(0.059-0.059 ms): <.main+11876>
test/lang/array.ci:54:[.05b56d, .05b571) exec(7), time(0.004-0.004 ms): <.main+11897>
test/lang/array.ci:54:[.05b571, .05b57d) exec(8), time(0.033-0.033 ms): <.main+11901>
test/lang/array.ci:54:[.05b553, .05b581) exec(1), time(0.006-0.006 ms): <.main+11871>
test/lang/array.ci:82:[.05b581, .05b598) exec(1), time(0.032-0.032 ms): <.main+11917>
test/lang/array.ci:83:[.05b598, .05b5bb) exec(1), time(0.045-0.045 ms): <.main+11940>
test/lang/array.ci:84:[.05b5bb, .05b5de) exec(1), time(0.045-0.045 ms): <.main+11975>
test/lang/array.ci:87:[.05b5de, .05b600) exec(1), time(0.049-0.049 ms): <.main+12010>
test/lang/array.ci:88:[.05b600, .05b622) exec(1), time(0.078-0.078 ms): <.main+12044>
test/lang/array.ci:91:[.05b622, .05b644) exec(1), time(0.060-0.060 ms): <.main+12078>
test/lang/array.ci:92:[.05b644, .05b666) exec(1), time(0.061-0.061 ms): <.main+12112>
test/lang/array.ci:98:[.05b666, .05b69b) exec(1), time(0.006-0.006 ms): <.main+12146>
test/lang/array.ci:99:[.05b69b, .05b6d0) exec(1), time(0.005-0.005 ms): <.main+12199>
test/lang/array.ci:101:[.05b6d0, .05b70d) exec(1), time(0.005-0.005 ms): <.main+12252>
test/lang/array.ci:108:[.05b70d, .05b726) exec(1), time(0.027-0.027 ms): <.main+12313>
test/lang/array.ci:109:[.05b726, .05b73e) exec(1), time(0.034-0.034 ms): <.main+12338>
test/lang/array.ci:110:[.05b73e, .05b756) exec(1), time(0.026-0.026 ms): <.main+12362>
test/lang/array.ci:112:[.05b756, .05b776) exec(1), time(0.058-0.058 ms): <.main+12386>
test/lang/array.ci:113:[.05b776, .05b795) exec(1), time(0.108-0.108 ms): <.main+12418>
test/lang/array.ci:114:[.05b795, .05b7be) exec(1), time(0.086-0.086 ms): <.main+12449>
test/lang/array.ci:115:[.05b7be, .05b7e1) exec(1), time(0.133-0.133 ms): <.main+12490>
test/lang/array.ci:116:[.05b7e1, .05b804) exec(1), time(0.072-0.072 ms): <.main+12525>
test/lang/array.ci:119:[.05b809, .05b812) exec(7), time(0.048-0.048 ms): <.main+12565>
test/lang/array.ci:120:[.05b812, .05b850) exec(7), time(0.096-0.096 ms): <.main+12574>
test/lang/array.ci:121:[.05b850, .05b88d) exec(7), time(0.096-0.096 ms): <.main+12636>
test/lang/array.ci:122:[.05b88d, .05b8ca) exec(7), time(0.069-0.069 ms): <.main+12697>
test/lang/array.ci:124:[.05b8ca, .05b90e) exec(7), time(0.365-0.365 ms): <.main+12758>
test/lang/array.ci:125:[.05b90e, .05b951) exec(7), time(0.371-0.371 ms): <.main+12826>
test/lang/array.ci:126:[.05b951, .05b994) exec(7), time(0.328-0.328 ms): <.main+12893>
test/lang/array.ci:128:[.05b994, .05b9d8) exec(7), time(0.317-0.317 ms): <.main+12960>
test/lang/array.ci:129:[.05b9d8, .05ba1b) exec(7), time(0.341-0.341 ms): <.main+13028>
test/lang/array.ci:130:[.05ba1b, .05ba5e) exec(7), time(0.336-0.336 ms): <.main+13095>
test/lang/array.ci:132:[.05ba5e, .05baa7) exec(7), time(0.402-0.402 ms): <.main+13162>
test/lang/array.ci:134:[.05baa7, .05baea) exec(7), time(0.361-0.361 ms): <.main+13235>
test/lang/array.ci:136:[.05baea, .05bb27) exec(7), time(0.081-0.081 ms): <.main+13302>
test/lang/array.ci:118:[.05bb2b, .05bb2f) exec(7), time(0.006-0.006 ms): <.main+13367>
test/lang/array.ci:118:[.05bb2f, .05bb3b) exec(8), time(0.067-0.067 ms): <.main+13371>
test/lang/array.ci:118:[.05b804, .05bb3f) exec(1), time(0.007-0.007 ms): <.main+12560>
test/lang/method.ci:78:[.05bb3f, .05bb54) exec(1), time(0.198-0.198 ms): <.main+13387>
test/lang/method.ci:79:[.05bb54, .05bb68) exec(1), time(0.163-0.163 ms): <.main+13408>
test/lang/method.ci:97:[.05bb68, .05bb7b) exec(1), time(0.305-0.305 ms): <.main+13428>
test/lang/method.ci:98:[.05bb7b, .05bb8e) exec(1), time(0.279-0.279 ms): <.main+13447>
test/lang/method.ci:101:[.05bb8e, .05bba3) exec(1), time(0.219-0.219 ms): <.main+13466>
test/lang/method.ci:102:[.05bba3, .05bbb8) exec(1), time(0.211-0.211 ms): <.main+13487>
test/lang/method.ci:103:[.05bbb8, .05bbcc) exec(1), time(0.209-0.209 ms): <.main+13508>
test/lang/statementIf.ci:4:[.05bbcc, .05bbf3) exec(1), time(0.050-0.050 ms): <.main+13528>
test/lang/statementIf.ci:12:[.05bbf3, .05bc1a) exec(1), time(0.058-0.058 ms): <.main+13567>
test/lang/statementIf.ci:22:[.05bc1a, .05bc41) exec(1), time(0.044-0.044 ms): <.main+13606>
test/lang/statementIf.ci:29:[.05bc4b, .05bc72) exec(1), time(0.049-0.049 ms): <.main+13655>
test/lang/statementIf.ci:28:[.05bc41, .05bc72) exec(1-1), time(0.000 ms): <.main+13645>
test/lang/statementIf.ci:33:[.05bc7c, .05bca3) exec(0), time(0.000 ms): <.main+13704>
test/lang/statementIf.ci:32:[.05bc72, .05bca3) exec(1), time(0.005-0.005 ms): <.main+13694>
test/lang/statementIf.ci:37:[.05bcad, .05bcd4) exec(1), time(0.050-0.050 ms): <.main+13753>
test/lang/statementIf.ci:40:[.05bcd8, .05bcff) exec(0), time(0.000 ms): <.main+13796>
test/lang/statementIf.ci:36:[.05bca3, .05bcff) exec(1), time(0.052-0.052 ms): <.main+13743>
test/lang/statementIf.ci:44:[.05bd09, .05bd30) exec(0), time(0.000 ms): <.main+13845>
test/lang/statementIf.ci:47:[.05bd34, .05bd5b) exec(1), time(0.101-0.101 ms): <.main+13888>
test/lang/statementIf.ci:43:[.05bcff, .05bd5b) exec(1-1), time(0.000 ms): <.main+13835>
test/lang/statementIf.ci:51:[.05bd65, .05bd8c) exec(1), time(0.065-0.065 ms): <.main+13937>
test/lang/statementIf.ci:54:[.05bd9e, .05bdc5) exec(0), time(0.000 ms): <.main+13994>
test/lang/statementIf.ci:57:[.05bdd7, .05bdfe) exec(0), time(0.000 ms): <.main+14051>
test/lang/statementIf.ci:60:[.05be10, .05be37) exec(0), time(0.000 ms): <.main+14108>
test/lang/statementIf.ci:63:[.05be49, .05be70) exec(0), time(0.000 ms): <.main+14165>
test/lang/statementIf.ci:66:[.05be82, .05bea9) exec(0), time(0.000 ms): <.main+14222>
test/lang/statementIf.ci:69:[.05bead, .05bed4) exec(0), time(0.000 ms): <.main+14265>
test/lang/statementIf.ci:65:[.05be74, .05bed4) exec(0), time(0.000 ms): <.main+14208>
test/lang/statementIf.ci:62:[.05be3b, .05bed4) exec(0), time(0.000 ms): <.main+14151>
test/lang/statementIf.ci:59:[.05be02, .05bed4) exec(0), time(0.000 ms): <.main+14094>
test/lang/statementIf.ci:56:[.05bdc9, .05bed4) exec(0), time(0.000 ms): <.main+14037>
test/lang/statementIf.ci:53:[.05bd90, .05bed4) exec(0), time(0.000 ms): <.main+13980>
test/lang/statementIf.ci:50:[.05bd5b, .05bed4) exec(1), time(0.067-0.067 ms): <.main+13927>
test/lang/statementFor.ci:4:[.05bed8, .05befb) exec(1), time(0.039-0.039 ms): <.main+14308>
test/lang/statementFor.ci:5:[.05befb, .05beff) exec(1), time(0.001-0.001 ms): <.main+14343>
::[.05beff, .05bf03) exec(1), time(0.001-0.001 ms): <.main+14347>
test/lang/statementFor.ci:3:[.05bed4, .05bf03) exec(1-1), time(0.000 ms): <.main+14304>
test/lang/statementFor.ci:9:[.05bf08, .05bf2a) exec(2), time(0.089-0.089 ms): <.main+14356>
test/lang/statementFor.ci:8:[.05bf2a, .05bf2e) exec(2), time(0.002-0.002 ms): <.main+14390>
test/lang/statementFor.ci:8:[.05bf2e, .05bf3a) exec(3), time(0.015-0.015 ms): <.main+14394>
test/lang/statementFor.ci:8:[.05bf03, .05bf3e) exec(1), time(0.007-0.007 ms): <.main+14351>
test/lang/statementFor.ci:14:[.05bf47, .05bf6a) exec(2), time(0.091-0.091 ms): <.main+14419>
test/lang/statementFor.ci:13:[.05bf6a, .05bf76) exec(2), time(0.007-0.007 ms): <.main+14454>
test/lang/statementFor.ci:13:[.05bf76, .05bf84) exec(3), time(0.015-0.015 ms): <.main+14466>
test/lang/statementFor.ci:13:[.05bf3e, .05bf84) exec(1-1), time(0.000 ms): <.main+14410>
test/lang/statementFor.ci:19:[.05bf95, .05bf99) exec(2), time(0.002-0.002 ms): <.main+14497>
test/lang/statementFor.ci:18:[.05bf89, .05bf99) exec(7-2), time(0.024-0.024 ms): <.main+14485>
test/lang/statementFor.ci:21:[.05bf99, .05bfbb) exec(5), time(0.252-0.252 ms): <.main+14501>
test/lang/statementFor.ci:17:[.05bfbb, .05bfbf) exec(7), time(0.005-0.005 ms): <.main+14535>
test/lang/statementFor.ci:17:[.05bfbf, .05bfcb) exec(8), time(0.039-0.039 ms): <.main+14539>
test/lang/statementFor.ci:17:[.05bf84, .05bfcf) exec(1), time(0.007-0.007 ms): <.main+14480>
test/lang/statementFor.ci:26:[.05bfe0, .05bfe4) exec(1), time(0.001-0.001 ms): <.main+14572>
test/lang/statementFor.ci:25:[.05bfd4, .05bfe4) exec(4-1), time(0.015-0.015 ms): <.main+14560>
test/lang/statementFor.ci:28:[.05bfe4, .05c006) exec(3), time(0.150-0.150 ms): <.main+14576>
test/lang/statementFor.ci:24:[.05c006, .05c00a) exec(3), time(0.003-0.003 ms): <.main+14610>
test/lang/statementFor.ci:24:[.05c00a, .05c016) exec(4), time(0.022-0.022 ms): <.main+14614>
test/lang/statementFor.ci:24:[.05bfcf, .05c01a) exec(1), time(0.003-0.003 ms): <.main+14555>

---------- Exitcode: 0, time: 48.359 ms
