
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (20 -> 24)
lib/stdlib.ci:43: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:44: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:45: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:55: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:72: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:75: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:81: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:84: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:91: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:97: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:157: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:157: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:161: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:161: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:184: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:184: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:185: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:185: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:281: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:287: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:288: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:291: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:295: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:295: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:299: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:304: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:339: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:343: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:351: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:359: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:358: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:354: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:350: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:371: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:393: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:398: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:399: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:404: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:420: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:423: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:424: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:426: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:436: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:442: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:447: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:493: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:494: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:498: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:20: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:56: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:109: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:115: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:122: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:123: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:123: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:125: warn: adding implicit cast char(0: int32)
lib/std/string.ci:138: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:141: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:141: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:142: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:161: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:166: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:173: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:186: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:186: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:188: warn: adding implicit cast char(0: int32)
lib/std/string.ci:199: warn: adding implicit cast int32('-': char)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:108: warn: adding implicit cast char(0: int32)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.precision := 0

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/lang/emit.ci:11: warn: adding implicit cast float64(2: int32)
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:53: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/lang/method.ci:53: debug: using default field initializer: RecordMethodTest.print(this: RecordMethodTest): void := print
test/lang/method.ci:63: debug: using default field initializer: RecordMethodTest.delegateMethod(x: int32, y: int32): int32 := forwardMethod
test/lang/method.ci:63: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`

---------- Generate: byte-code
lib/std/math.ci:60: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:286: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:289: warn: using default type initializer: e := 0
lib/std/math.ci:293: warn: using default type initializer: f := 0
lib/std/math.ci:345: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:402: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:134: warn: uninitialized variable `append.digits`
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/lang/method.ci:73: warn: accessing static member using instance variable `RecordMethodTest.printStatic(this: RecordMethodTest): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+24>, cast: const variable)
.field offset: int32 (size: 4, offs: <+32>, cast: const variable)
.field base: function (size: 0, offs: <@0055a8>, cast: static const inline)
.field file: function (size: 0, offs: <@005778>, cast: static const inline)
.field line: function (size: 0, offs: <@005948>, cast: static const inline)
.field name: function (size: 0, offs: <@005b18>, cast: static const inline)
.references:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/stdlib.ci:53: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal references: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+24>
.name: 'size'
.owner: typename
.references:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:53: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'offset'
.print: '@%06x'
.owner: typename
.references:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0055a8>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.references:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal references: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005778>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.references:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal references: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005948>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.references:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal references: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005b18>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.references:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal references: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000a0>
.name: 'void'
.references:
	test/lang/method.ci:79: referenced as `void`
	test/lang/method.ci:75: referenced as `void`
	test/lang/method.ci:59: referenced as `void`
	test/lang/method.ci:44: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:38: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	internal references: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000130>
.name: 'bool'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:44: referenced as `bool`
	lib/std/string.ci:35: referenced as `bool`
	lib/std/math.ci:441: referenced as `bool`
	lib/std/math.ci:392: referenced as `bool`
	lib/std/math.ci:337: referenced as `bool`
	lib/std/math.ci:336: referenced as `bool`
	lib/stdlib.ci:29: referenced as `bool`
	lib/stdlib.ci:28: referenced as `bool`
	lib/stdlib.ci:27: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001c0>
.name: 'char'
.print: '%c'
.value: 0
.references:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:205: referenced as `char`
	lib/std/string.ci:196: referenced as `char`
	lib/std/string.ci:192: referenced as `char`
	lib/std/string.ci:150: referenced as `char`
	lib/std/string.ci:134: referenced as `char`
	lib/std/string.ci:131: referenced as `char`
	lib/std/string.ci:130: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:108: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:3: referenced as `char`
	lib/stdlib.ci:38: referenced as `char`
	lib/stdlib.ci:34: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:24: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	lib/stdlib.ci:14: referenced as `char`
	lib/stdlib.ci:12: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:9: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	lib/stdlib.ci:5: referenced as `char`
	internal references: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000250>
.name: 'int8'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@0002e0>
.name: 'int16'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000370>
.name: 'int32'
.print: '%d'
.value: 0
.references:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:197: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:179: referenced as `int32`
	lib/std/string.ci:148: referenced as `int32`
	lib/std/string.ci:136: referenced as `int32`
	lib/std/string.ci:133: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:114: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:110: referenced as `int32`
	lib/std/string.ci:109: referenced as `int32`
	lib/std/string.ci:107: referenced as `int32`
	lib/std/string.ci:84: referenced as `int32`
	lib/std/string.ci:70: referenced as `int32`
	lib/std/string.ci:60: referenced as `int32`
	lib/std/string.ci:59: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:50: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:45: referenced as `int32`
	lib/std/string.ci:44: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:35: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:24: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:14: referenced as `int32`
	lib/std/string.ci:7: referenced as `int32`
	lib/std/string.ci:3: referenced as `int32`
	lib/std/math.ci:347: referenced as `int32`
	lib/std/math.ci:347: referenced as `int32`
	lib/std/math.ci:298: referenced as `int32`
	lib/std/math.ci:266: referenced as `int32`
	lib/std/math.ci:252: referenced as `int32`
	lib/std/math.ci:239: referenced as `int32`
	lib/std/math.ci:80: referenced as `int32`
	lib/std/math.ci:71: referenced as `int32`
	lib/stdlib.ci:53: referenced as `int32`
	lib/stdlib.ci:49: referenced as `int32`
	lib/stdlib.ci:49: referenced as `int32`
	lib/stdlib.ci:38: referenced as `int32`
	lib/stdlib.ci:38: referenced as `int32`
	internal references: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000400>
.name: 'int64'
.print: '%D'
.value: 0
.references:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal references: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000490>
.name: 'uint8'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@000520>
.name: 'uint16'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0005b0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@008328>, cast: static const inline)
.field sxt: function (size: 0, offs: <@008608>, cast: static const inline)
.field pop: function (size: 0, offs: <@0087d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0089a8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@008b78>, cast: static const inline)
.field bsf: function (size: 0, offs: <@008d48>, cast: static const inline)
.field hib: function (size: 0, offs: <@008f18>, cast: static const inline)
.field lob: function (size: 0, offs: <@0090e8>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:205: referenced as `uint32`
	lib/std/string.ci:192: referenced as `uint32`
	lib/std/string.ci:129: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008328>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.references:
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal references: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008608>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.references:
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal references: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0087d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.references:
	internal references: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.references:
	internal references: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b78>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.references:
	internal references: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d48>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.references:
	internal references: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f18>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.references:
	internal references: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0090e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.references:
	internal references: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000640>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@0093c0>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009698>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093c0>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.references:
	internal references: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009698>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.references:
	internal references: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0006d0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@009870>, cast: static const inline)
.field cos: function (size: 0, offs: <@009a40>, cast: static const inline)
.field tan: function (size: 0, offs: <@009c10>, cast: static const inline)
.field log: function (size: 0, offs: <@009de0>, cast: static const inline)
.field exp: function (size: 0, offs: <@009fb0>, cast: static const inline)
.field pow: function (size: 0, offs: <@00a210>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00a3e0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00a638>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:11: referenced as `float32`
	test/lang/emit.ci:11: referenced as `float32`
	test/lang/emit.ci:11: referenced as `float32`
	lib/std/math.ci:239: referenced as `float32`
	lib/std/math.ci:239: referenced as `float32`
	lib/std/math.ci:239: referenced as `float32`
	lib/std/math.ci:184: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:116: referenced as `float32`
	lib/std/math.ci:116: referenced as `float32`
	lib/std/math.ci:116: referenced as `float32`
	lib/std/math.ci:103: referenced as `float32`
	lib/std/math.ci:103: referenced as `float32`
	lib/std/math.ci:103: referenced as `float32`
	lib/std/math.ci:90: referenced as `float32`
	lib/std/math.ci:90: referenced as `float32`
	lib/std/math.ci:71: referenced as `float32`
	internal references: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009870>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.references:
	test/stdc/number.ci:46: referenced as `sin`
	test/lang/emit.ci:11: referenced as `sin`
	internal references: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009a40>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.references:
	test/stdc/number.ci:47: referenced as `cos`
	internal references: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009c10>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.references:
	test/stdc/number.ci:48: referenced as `tan`
	internal references: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009de0>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.references:
	test/stdc/number.ci:49: referenced as `log`
	internal references: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009fb0>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.references:
	test/stdc/number.ci:50: referenced as `exp`
	internal references: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a210>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.references:
	test/stdc/number.ci:51: referenced as `pow`
	internal references: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a3e0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.references:
	test/stdc/number.ci:52: referenced as `sqrt`
	internal references: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a638>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.references:
	test/stdc/number.ci:53: referenced as `atan2`
	internal references: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000760>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00a800>, cast: static const inline)
.field cos: function (size: 0, offs: <@00a9c8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ab90>, cast: static const inline)
.field log: function (size: 0, offs: <@00ad58>, cast: static const inline)
.field exp: function (size: 0, offs: <@00af20>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b170>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b338>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b588>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:117: referenced as `float64`
	lib/std/math.Complex.ci:114: referenced as `float64`
	lib/std/math.Complex.ci:113: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:108: referenced as `float64`
	lib/std/math.Complex.ci:105: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:94: referenced as `float64`
	lib/std/math.Complex.ci:90: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:87: referenced as `float64`
	lib/std/math.Complex.ci:86: referenced as `float64`
	lib/std/math.Complex.ci:79: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:72: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:63: referenced as `float64`
	lib/std/math.Complex.ci:60: referenced as `float64`
	lib/std/math.Complex.ci:59: referenced as `float64`
	lib/std/math.Complex.ci:56: referenced as `float64`
	lib/std/math.Complex.ci:55: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:20: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.Complex.ci:4: referenced as `float64`
	lib/std/math.ci:494: referenced as `float64`
	lib/std/math.ci:494: referenced as `float64`
	lib/std/math.ci:493: referenced as `float64`
	lib/std/math.ci:493: referenced as `float64`
	lib/std/math.ci:470: referenced as `float64`
	lib/std/math.ci:457: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:452: referenced as `float64`
	lib/std/math.ci:452: referenced as `float64`
	lib/std/math.ci:435: referenced as `float64`
	lib/std/math.ci:435: referenced as `float64`
	lib/std/math.ci:426: referenced as `float64`
	lib/std/math.ci:426: referenced as `float64`
	lib/std/math.ci:424: referenced as `float64`
	lib/std/math.ci:419: referenced as `float64`
	lib/std/math.ci:419: referenced as `float64`
	lib/std/math.ci:407: referenced as `float64`
	lib/std/math.ci:404: referenced as `float64`
	lib/std/math.ci:404: referenced as `float64`
	lib/std/math.ci:402: referenced as `float64`
	lib/std/math.ci:399: referenced as `float64`
	lib/std/math.ci:382: referenced as `float64`
	lib/std/math.ci:380: referenced as `float64`
	lib/std/math.ci:380: referenced as `float64`
	lib/std/math.ci:364: referenced as `float64`
	lib/std/math.ci:363: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:345: referenced as `float64`
	lib/std/math.ci:324: referenced as `float64`
	lib/std/math.ci:323: referenced as `float64`
	lib/std/math.ci:323: referenced as `float64`
	lib/std/math.ci:320: referenced as `float64`
	lib/std/math.ci:317: referenced as `float64`
	lib/std/math.ci:312: referenced as `float64`
	lib/std/math.ci:311: referenced as `float64`
	lib/std/math.ci:310: referenced as `float64`
	lib/std/math.ci:293: referenced as `float64`
	lib/std/math.ci:289: referenced as `float64`
	lib/std/math.ci:286: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:267: referenced as `float64`
	lib/std/math.ci:266: referenced as `float64`
	lib/std/math.ci:266: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:185: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:122: referenced as `float64`
	lib/std/math.ci:122: referenced as `float64`
	lib/std/math.ci:122: referenced as `float64`
	lib/std/math.ci:109: referenced as `float64`
	lib/std/math.ci:109: referenced as `float64`
	lib/std/math.ci:109: referenced as `float64`
	lib/std/math.ci:96: referenced as `float64`
	lib/std/math.ci:96: referenced as `float64`
	lib/std/math.ci:80: referenced as `float64`
	lib/std/math.ci:65: referenced as `float64`
	lib/std/math.ci:64: referenced as `float64`
	lib/std/math.ci:60: referenced as `float64`
	lib/std/math.ci:59: referenced as `float64`
	lib/std/math.ci:59: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:6: referenced as `float64`
	internal references: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a800>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.references:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:145: referenced as `sin`
	lib/std/math.Complex.ci:120: referenced as `sin`
	lib/std/math.Complex.ci:119: referenced as `sin`
	lib/std/math.Complex.ci:114: referenced as `sin`
	lib/std/math.Complex.ci:103: referenced as `sin`
	internal references: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a9c8>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.references:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:145: referenced as `cos`
	lib/std/math.Complex.ci:120: referenced as `cos`
	lib/std/math.Complex.ci:119: referenced as `cos`
	lib/std/math.Complex.ci:113: referenced as `cos`
	lib/std/math.Complex.ci:103: referenced as `cos`
	internal references: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab90>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.references:
	test/stdc/number.ci:39: referenced as `tan`
	internal references: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad58>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.references:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:110: referenced as `log`
	lib/std/math.Complex.ci:105: referenced as `log`
	internal references: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af20>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.references:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:111: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.ci:426: referenced as `exp`
	lib/std/math.ci:426: referenced as `exp`
	lib/std/math.ci:424: referenced as `exp`
	lib/std/math.ci:404: referenced as `exp`
	lib/std/math.ci:404: referenced as `exp`
	lib/std/math.ci:399: referenced as `exp`
	internal references: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b170>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.references:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:111: referenced as `pow`
	internal references: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.references:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:89: referenced as `sqrt`
	lib/std/math.ci:452: referenced as `sqrt`
	internal references: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b588>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.references:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:90: referenced as `atan2`
	lib/std/math.ci:457: referenced as `atan2`
	lib/std/math.ci:454: referenced as `atan2`
	internal references: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@006c50>, cast: static const inline)
.field fill: function (size: 0, offs: <@006f40>, cast: static const inline)
.field copy: function (size: 0, offs: <@007228>, cast: static const inline)
.field move: function (size: 0, offs: <@007508>, cast: static const inline)
.references:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal references: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006c50>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.references:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal references: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006f40>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.references:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal references: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007228>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.references:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal references: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007508>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.references:
	test/stdc/memory.ci:29: referenced as `move`
	internal references: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000880>
.name: 'variant'
.references:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:33: referenced as `variant`
	lib/stdlib.ci:32: referenced as `variant`
	lib/stdlib.ci:27: referenced as `variant`
	lib/stdlib.ci:23: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:17: referenced as `variant`
	lib/stdlib.ci:14: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:8: referenced as `variant`
	lib/stdlib.ci:5: referenced as `variant`
	internal references: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000910>
.name: 'function'
.references:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0009a8>
.name: 'object'
.references:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.references:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/std/string.ci:4: referenced as `null`
	lib/stdlib.ci:49: referenced as `null`
	lib/stdlib.ci:25: referenced as `null`
	lib/stdlib.ci:24: referenced as `null`
	lib/stdlib.ci:21: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:15: referenced as `null`
	lib/stdlib.ci:12: referenced as `null`
	lib/stdlib.ci:9: referenced as `null`
	lib/stdlib.ci:6: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.references:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:55: referenced as `true`
	lib/std/string.ci:41: referenced as `true`
	lib/std/math.ci:443: referenced as `true`
	lib/std/math.ci:395: referenced as `true`
	lib/std/math.ci:356: referenced as `true`
	lib/std/math.ci:352: referenced as `true`
	lib/std/math.ci:341: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.references:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:52: referenced as `false`
	lib/std/string.ci:48: referenced as `false`
	lib/std/string.ci:38: referenced as `false`
	lib/std/math.ci:441: referenced as `false`
	lib/std/math.ci:392: referenced as `false`
	lib/std/math.ci:337: referenced as `false`
	lib/std/math.ci:336: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.references:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.references:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.references:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.references:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000eb8>
.name: '.cstr'
.print: '%s'
.references:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000f48>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0012a8>, cast: static const typename(val))
.field dup: void (size: 0, offs: <@001338>, cast: static const typename(void))
.field load: void (size: 0, offs: <@001578>, cast: static const typename(void))
.field store: void (size: 0, offs: <@001a88>, cast: static const typename(void))
.field cmt: void (size: 0, offs: <@001dc0>, cast: static const typename(void))
.field and: void (size: 0, offs: <@001f70>, cast: static const typename(void))
.field or: void (size: 0, offs: <@002110>, cast: static const typename(void))
.field xor: void (size: 0, offs: <@0022b0>, cast: static const typename(void))
.field shl: void (size: 0, offs: <@002450>, cast: static const typename(void))
.field shr: void (size: 0, offs: <@0025f0>, cast: static const typename(void))
.field neg: void (size: 0, offs: <@0028a0>, cast: static const typename(void))
.field add: void (size: 0, offs: <@002c80>, cast: static const typename(void))
.field sub: void (size: 0, offs: <@003040>, cast: static const typename(void))
.field mul: void (size: 0, offs: <@003400>, cast: static const typename(void))
.field div: void (size: 0, offs: <@0038d0>, cast: static const typename(void))
.field mod: void (size: 0, offs: <@003da0>, cast: static const typename(void))
.field ceq: void (size: 0, offs: <@004160>, cast: static const typename(void))
.field clt: void (size: 0, offs: <@004520>, cast: static const typename(void))
.field cgt: void (size: 0, offs: <@0048e0>, cast: static const typename(void))
.field min: void (size: 0, offs: <@004ca0>, cast: static const typename(void))
.field max: void (size: 0, offs: <@004e40>, cast: static const typename(void))
.references:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:11: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.references:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.references:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.references:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.references:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.references:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0012a8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.references:
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.references:
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.references:
}
emit.dup: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001338>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.references:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.references:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.references:
}
emit.load: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001578>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.references:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.references:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.references:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.references:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.references:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.references:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.references:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.references:
}
emit.store: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001a88>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.references:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.references:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.references:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.references:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.references:
}
emit.cmt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001dc0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.references:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.references:
}
emit.and: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001f70>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.references:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.references:
}
emit.or: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@002110>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.references:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.references:
}
emit.xor: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0022b0>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.references:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.references:
}
emit.shl: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@002450>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.references:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.references:
}
emit.shr: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0025f0>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.references:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.references:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.references:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.references:
}
emit.neg: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0028a0>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.references:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.references:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.references:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.references:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.references:
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.references:
}
emit.add: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@002c80>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:9: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.references:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.references:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.references:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.references:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.references:
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.references:
}
emit.sub: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@003040>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.references:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.references:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.references:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.references:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.references:
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.references:
}
emit.mul: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@003400>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.references:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.references:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.references:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.references:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.references:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.references:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.references:
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.references:
}
emit.div: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0038d0>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:10: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.references:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.references:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.references:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.references:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.references:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.references:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.references:
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.references:
}
emit.mod: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@003da0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.references:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.references:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.references:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.references:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.references:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.references:
}
emit.ceq: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004160>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.references:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.references:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.references:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.references:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.references:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.references:
}
emit.clt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004520>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.references:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.references:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.references:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.references:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.references:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.references:
}
emit.cgt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0048e0>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.references:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.references:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.references:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.references:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.references:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.references:
}
emit.min: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004ca0>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.references:
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.references:
}
emit.max: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004e40>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.references:
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.references:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0052b0>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.references:
	internal references: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.references:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.references:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0061f0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.value: nfc(5)
.references:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal references: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.references:
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:25: referenced as `abort`
	lib/stdlib.ci:24: referenced as `abort`
	lib/stdlib.ci:23: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.references:
	lib/stdlib.ci:21: referenced as `error`
	lib/stdlib.ci:20: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.references:
	lib/stdlib.ci:18: referenced as `warn`
	lib/stdlib.ci:17: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.references:
	lib/stdlib.ci:15: referenced as `info`
	lib/stdlib.ci:14: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.references:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:12: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
	lib/stdlib.ci:9: referenced as `debug`
	lib/stdlib.ci:8: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.references:
	lib/stdlib.ci:6: referenced as `verbose`
	lib/stdlib.ci:5: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.references:
	lib/stdlib.ci:18: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
	lib/stdlib.ci:14: referenced as `noTrace`
	lib/stdlib.ci:12: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
	lib/stdlib.ci:5: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.references:
	lib/stdlib.ci:47: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
	lib/stdlib.ci:24: referenced as `defTrace`
	lib/stdlib.ci:23: referenced as `defTrace`
	lib/stdlib.ci:21: referenced as `defTrace`
	lib/stdlib.ci:20: referenced as `defTrace`
	lib/stdlib.ci:9: referenced as `defTrace`
	lib/stdlib.ci:8: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0069f0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.references:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal references: 1
}
System: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@007538>
.name: 'System'
.field exit: function (size: 0, offs: <@007770>, cast: static const inline)
.field srand: function (size: 0, offs: <@007948>, cast: static const inline)
.field rand: function (size: 0, offs: <@007a90>, cast: static const inline)
.field time: function (size: 0, offs: <@007bd8>, cast: static const inline)
.field clock: function (size: 0, offs: <@007d20>, cast: static const inline)
.field millis: function (size: 0, offs: <@007e68>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008038>, cast: static const inline)
.references:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007770>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.references:
	internal references: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007948>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.references:
	internal references: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007a90>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.references:
	internal references: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bd8>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.references:
	internal references: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007d20>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.references:
	internal references: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e68>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.references:
	internal references: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008038>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.references:
	internal references: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:5: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:6: defined as `verbose(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:8: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.references:
	test/lang/method.ci:80: referenced as `trace`
	test/lang/method.ci:76: referenced as `trace`
	test/lang/method.ci:60: referenced as `trace`
	test/lang/method.ci:45: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	lib/stdlib.ci:9: defined as `trace(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.references:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.references:
	test/lang/statementFor.ci:4: referenced as `debug`
	lib/stdlib.ci:12: defined as `debug(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:14: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:15: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:17: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:18: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:20: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.references:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:21: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.references:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:27: referenced as `abort`
	lib/stdlib.ci:23: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:29: referenced as `abort`
	lib/stdlib.ci:28: referenced as `abort`
	lib/stdlib.ci:24: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.references:
	lib/stdlib.ci:25: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.value: void(condition ? void(0) : abort(void(message, inspect)))
.references:
	lib/std/string.ci:138: referenced as `assert`
	lib/std/string.ci:137: referenced as `assert`
	lib/stdlib.ci:27: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.value: void(condition ? void(0) : abort(message))
.references:
	lib/stdlib.ci:28: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
.references:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:173: referenced as `assert`
	lib/std/string.ci:166: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
	lib/stdlib.ci:29: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@00e058>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+16>, cast: const variable(ref))
.references:
	lib/stdlib.ci:42: referenced as `NotEquals`
	lib/stdlib.ci:31: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
.references:
	lib/stdlib.ci:43: referenced as `expected`
	lib/stdlib.ci:32: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
.references:
	lib/stdlib.ci:44: referenced as `returned`
	lib/stdlib.ci:33: defined as `returned`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+16>
.name: 'message'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
.references:
	lib/stdlib.ci:45: referenced as `message`
	lib/stdlib.ci:34: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 82
.offset: <@03c6d8>
.name: 'assertEq'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (82 bytes: <@03c6d8> - <@03c72a>)
	lib/stdlib.ci:39: (10 bytes: <@03c6d8> - <@03c6e2>): if (bool(returned == expected))
	<assertEq @03c6d8>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @03c6da>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @03c6dc>    : 57                         ceq.i32
	<assertEq+5 @03c6dd>    : 06 05 00 00                jz <assertEq+10 @03c6e2>
	lib/stdlib.ci:40: (1 byte: <@03c6e1> - <@03c6e2>): return;
	<assertEq+9 @03c6e1>    : 03                         ret
	lib/stdlib.ci:42: (29 bytes: <@03c6e2> - <@03c6ff>): details: NotEquals := {...}
	<assertEq+10 @03c6e2>   : 09 18 00 00                inc.sp(+24)
	lib/stdlib.ci:43: (11 bytes: <@03c6e6> - <@03c6f1>): void(details.expected := (expected));
	<assertEq+14 @03c6e6>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+19 @03c6eb>   : 0a 28 00 00                load.sp(+40)
	<assertEq+23 @03c6ef>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:44: (11 bytes: <@03c6f1> - <@03c6fc>): void(details.returned := (returned));
	<assertEq+25 @03c6f1>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+30 @03c6f6>   : 0a 24 00 00                load.sp(+36)
	<assertEq+34 @03c6fa>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:45: (3 bytes: <@03c6fc> - <@03c6ff>): void(details.message := (message));
	<assertEq+36 @03c6fc>   : 16 04 07                   mov.x1 sp(4, 7)
	lib/stdlib.ci:47: (38 bytes: <@03c6ff> - <@03c725>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+39 @03c6ff>   : 1f b8 b5 00 00             load.ref <@00b5b8> ;"lib/stdlib.ci"
	<assertEq+44 @03c704>   : 1c 2f 00 00 00             load.c32 47
	<assertEq+49 @03c709>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+54 @03c70e>   : 1c 80 00 00 00             load.c32 128
	<assertEq+59 @03c713>   : 1f 29 b6 00 00             load.ref <@00b629> ;"assertion failed"
	<assertEq+64 @03c718>   : 1f 58 e0 00 00             load.ref <@00e058> ;NotEquals
	<assertEq+69 @03c71d>   : 0a 18 00 00                load.sp(+24)
	<assertEq+73 @03c721>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+77 @03c725>   : 09 e8 ff ff                inc.sp(-24)
	<assertEq+81 @03c729>   : 03                         ret
.references:
	lib/stdlib.ci:49: referenced as `assertEq`
	lib/stdlib.ci:38: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.value: assertEq(void(void(expected, returned), null))
.references:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:49: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:53'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.value: int32(type.size)
.references:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:53: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(val)
.base: `typename`
.size: 0
.offset: <@00ebc0>
.name: 'Math'
.file: 'lib/std/math.ci:3'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 91, offs: <@03c730>, cast: static const function)
.field floor: function (size: 29, offs: <@03c790>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 36, offs: <@03c7b0>, cast: static const function)
.field sign: function (size: 36, offs: <@03c7d8>, cast: static const function)
.field abs: function (size: 18, offs: <@03c800>, cast: static const function)
.field abs: function (size: 18, offs: <@03c818>, cast: static const function)
.field min: function (size: 17, offs: <@03c830>, cast: static const function)
.field min: function (size: 17, offs: <@03c848>, cast: static const function)
.field max: function (size: 17, offs: <@03c860>, cast: static const function)
.field max: function (size: 17, offs: <@03c878>, cast: static const function)
.field clamp: function (size: 30, offs: <@03c890>, cast: static const function)
.field clamp: function (size: 30, offs: <@03c8b0>, cast: static const function)
.field lerp: function (size: 14, offs: <@03c8d0>, cast: static const function)
.field lerp: function (size: 14, offs: <@03c8e0>, cast: static const function)
.field smooth: function (size: 53, offs: <@03c8f0>, cast: static const function)
.field smooth: function (size: 65, offs: <@03c928>, cast: static const function)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field cmp: function (size: 57, offs: <@03c970>, cast: static const function)
.field cmp: function (size: 57, offs: <@03c9b0>, cast: static const function)
.field sinCos: function (size: 340, offs: <@03c9f0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 376, offs: <@03cb48>, cast: static const function)
.field sinh: function (size: 246, offs: <@03ccc0>, cast: static const function)
.field cosh: function (size: 75, offs: <@03cdb8>, cast: static const function)
.field asin: function (size: 171, offs: <@03ce08>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field deg2rad: function (size: 0, offs: <@000000>, cast: static inline)
.field rad2deg: function (size: 0, offs: <@000000>, cast: static inline)
.references:
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.ci:3: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:7'
.owner: Math
.value: 3.141593
.references:
	lib/std/math.ci:494: referenced as `pi`
	lib/std/math.ci:493: referenced as `pi`
	lib/std/math.ci:470: referenced as `pi`
	lib/std/math.ci:454: referenced as `pi`
	lib/std/math.ci:7: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:8'
.owner: Math
.value: 2.718282
.references:
	lib/std/math.ci:8: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:9'
.owner: Math
.value: 0.693147
.references:
	lib/std/math.ci:10: referenced as `ln2`
	lib/std/math.ci:9: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:10'
.owner: Math
.value: float64(1.000000 / ln2)
.references:
	lib/std/math.ci:10: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:11'
.owner: Math
.value: 2.302585
.references:
	lib/std/math.ci:12: referenced as `ln10`
	lib/std/math.ci:11: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:12'
.owner: Math
.value: float64(1.000000 / ln10)
.references:
	lib/std/math.ci:12: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:13'
.owner: Math
.value: 1.618034
.references:
	lib/std/math.ci:13: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:14'
.owner: Math
.value: 1.414214
.references:
	lib/std/math.ci:14: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:15'
.owner: Math
.value: 1.648721
.references:
	lib/std/math.ci:15: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:16'
.owner: Math
.value: 1.772454
.references:
	lib/std/math.ci:16: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:17'
.owner: Math
.value: 1.272020
.references:
	lib/std/math.ci:17: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:18'
.owner: Math
.value: float64((0) / 0.000000)
.references:
	lib/std/math.ci:449: referenced as `nan`
	lib/std/math.ci:369: referenced as `nan`
	lib/std/math.ci:18: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:19'
.owner: Math
.value: float64((1) / 0.000000)
.references:
	lib/std/math.ci:19: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 91
.offset: <@03c730>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (91 bytes: <@03c730> - <@03c78b>)
	lib/std/math.ci:23: (63 bytes: <@03c730> - <@03c76f>): if (bool(x < (1)))
	<modf @03c730>      : 11 02                      dup.x2 sp(2)
	<modf+2 @03c732>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @03c73b>   : 88                         clt.f64
	<modf+12 @03c73c>   : 06 33 00 00                jz <modf+63 @03c76f>
	lib/std/math.ci:24: (39 bytes: <@03c740> - <@03c767>): if (bool(x < (0)))
	<modf+16 @03c740>   : 11 02                      dup.x2 sp(2)
	<modf+18 @03c742>   : 1a                         load.z64
	<modf+19 @03c743>   : 88                         clt.f64
	<modf+20 @03c744>   : 06 23 00 00                jz <modf+55 @03c767>
	lib/std/math.ci:25: (17 bytes: <@03c748> - <@03c759>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @03c748>   : 1a                         load.z64
	<modf+25 @03c749>   : 11 04                      dup.x2 sp(4)
	<modf+27 @03c74b>   : 80                         neg.f64
	<modf+28 @03c74c>   : 10 05                      dup.x1 sp(5)
	<modf+30 @03c74e>   : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @03c753>   : 02                         call
	<modf+36 @03c754>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @03c758>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@03c759> - <@03c760>): float64(intPart := float64(-intPart));
	<modf+41 @03c759>   : 10 03                      dup.x1 sp(3)
	<modf+43 @03c75b>   : 23                         load.i64
	<modf+44 @03c75c>   : 80                         neg.f64
	<modf+45 @03c75d>   : 10 05                      dup.x1 sp(5)
	<modf+47 @03c75f>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@03c760> - <@03c763>): return float64(.result := result);
	<modf+48 @03c760>   : 14 06                      set.x2 sp(6)
	<modf+50 @03c762>   : 03                         ret
	<modf+51 @03c763>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@03c767> - <@03c76b>): float64(intPart := (0));
	<modf+55 @03c767>   : 1a                         load.z64
	<modf+56 @03c768>   : 10 03                      dup.x1 sp(3)
	<modf+58 @03c76a>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@03c76b> - <@03c76f>): return float64(.result := x);
	<modf+59 @03c76b>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @03c76e>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@03c76f> - <@03c77b>): result: float64 := float64(x % (1))
	<modf+63 @03c76f>   : 11 02                      dup.x2 sp(2)
	<modf+65 @03c771>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @03c77a>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@03c77b> - <@03c783>): float64(intPart := float64(x - result));
	<modf+75 @03c77b>   : 11 04                      dup.x2 sp(4)
	<modf+77 @03c77d>   : 11 02                      dup.x2 sp(2)
	<modf+79 @03c77f>   : 82                         sub.f64
	<modf+80 @03c780>   : 10 05                      dup.x1 sp(5)
	<modf+82 @03c782>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@03c783> - <@03c786>): return float64(.result := result);
	<modf+83 @03c783>   : 14 06                      set.x2 sp(6)
	<modf+85 @03c785>   : 03                         ret
	<modf+86 @03c786>   : 09 f8 ff ff                inc.sp(-8)
	<modf+90 @03c78a>   : 03                         ret
.references:
	lib/std/math.ci:346: referenced as `modf`
	lib/std/math.ci:294: referenced as `modf`
	lib/std/math.ci:290: referenced as `modf`
	lib/std/math.ci:61: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 29
.offset: <@03c790>
.name: 'floor'
.file: 'lib/std/math.ci:59'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (29 bytes: <@03c790> - <@03c7ad>)
	lib/std/math.ci:60: (1 byte: <@03c790> - <@03c791>): result: float64
	<floor @03c790>      : 1b                         load.z128
	lib/std/math.ci:61: (20 bytes: <@03c791> - <@03c7a5>): modf(void(x, result));
	<floor+1 @03c791>    : 11 05                      dup.x2 sp(5)
	<floor+3 @03c793>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @03c797>    : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @03c79c>   : 02                         call
	<floor+13 @03c79d>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @03c7a1>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:62: (3 bytes: <@03c7a5> - <@03c7a8>): return float64(.result := result);
	<floor+21 @03c7a5>   : 14 05                      set.x2 sp(5)
	<floor+23 @03c7a7>   : 03                         ret
	<floor+24 @03c7a8>   : 09 f8 ff ff                inc.sp(-8)
	<floor+28 @03c7ac>   : 03                         ret
.references:
	lib/std/math.ci:65: referenced as `floor`
	lib/std/math.ci:64: referenced as `floor`
	lib/std/math.ci:59: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(-floor(float64(-x)))
.references:
	lib/std/math.ci:64: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:65'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: floor(float64(x + 0.500000))
.references:
	lib/std/math.ci:65: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03c7b0>
.name: 'sign'
.file: 'lib/std/math.ci:71'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@03c7b0> - <@03c7d4>)
	lib/std/math.ci:72: (12 bytes: <@03c7b0> - <@03c7bc>): if (bool(x == (0)))
	<sign @03c7b0>      : 10 01                      dup.x1 sp(1)
	<sign+2 @03c7b2>    : 19                         load.z32
	<sign+3 @03c7b3>    : 77                         ceq.f32
	<sign+4 @03c7b4>    : 06 08 00 00                jz <sign+12 @03c7bc>
	lib/std/math.ci:73: (4 bytes: <@03c7b8> - <@03c7bc>): return int32(.result := 0);
	<sign+8 @03c7b8>    : 19                         load.z32
	<sign+9 @03c7b9>    : 13 03                      set.x1 sp(3)
	<sign+11 @03c7bb>   : 03                         ret
	lib/std/math.ci:75: (16 bytes: <@03c7bc> - <@03c7cc>): if (bool(x < (0)))
	<sign+12 @03c7bc>   : 10 01                      dup.x1 sp(1)
	<sign+14 @03c7be>   : 19                         load.z32
	<sign+15 @03c7bf>   : 78                         clt.f32
	<sign+16 @03c7c0>   : 06 0c 00 00                jz <sign+28 @03c7cc>
	lib/std/math.ci:76: (8 bytes: <@03c7c4> - <@03c7cc>): return int32(.result := int32(-1));
	<sign+20 @03c7c4>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @03c7c9>   : 13 03                      set.x1 sp(3)
	<sign+27 @03c7cb>   : 03                         ret
	lib/std/math.ci:78: (8 bytes: <@03c7cc> - <@03c7d4>): return int32(.result := 1);
	<sign+28 @03c7cc>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @03c7d1>   : 13 03                      set.x1 sp(3)
	<sign+35 @03c7d3>   : 03                         ret
.references:
	lib/std/math.ci:71: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03c7d8>
.name: 'sign'
.file: 'lib/std/math.ci:80'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float64 (size: 8, offs: <+12>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@03c7d8> - <@03c7fc>)
	lib/std/math.ci:81: (12 bytes: <@03c7d8> - <@03c7e4>): if (bool(x == (0)))
	<sign @03c7d8>      : 11 01                      dup.x2 sp(1)
	<sign+2 @03c7da>    : 1a                         load.z64
	<sign+3 @03c7db>    : 87                         ceq.f64
	<sign+4 @03c7dc>    : 06 08 00 00                jz <sign+12 @03c7e4>
	lib/std/math.ci:82: (4 bytes: <@03c7e0> - <@03c7e4>): return int32(.result := 0);
	<sign+8 @03c7e0>    : 19                         load.z32
	<sign+9 @03c7e1>    : 13 04                      set.x1 sp(4)
	<sign+11 @03c7e3>   : 03                         ret
	lib/std/math.ci:84: (16 bytes: <@03c7e4> - <@03c7f4>): if (bool(x < (0)))
	<sign+12 @03c7e4>   : 11 01                      dup.x2 sp(1)
	<sign+14 @03c7e6>   : 1a                         load.z64
	<sign+15 @03c7e7>   : 88                         clt.f64
	<sign+16 @03c7e8>   : 06 0c 00 00                jz <sign+28 @03c7f4>
	lib/std/math.ci:85: (8 bytes: <@03c7ec> - <@03c7f4>): return int32(.result := int32(-1));
	<sign+20 @03c7ec>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @03c7f1>   : 13 04                      set.x1 sp(4)
	<sign+27 @03c7f3>   : 03                         ret
	lib/std/math.ci:87: (8 bytes: <@03c7f4> - <@03c7fc>): return int32(.result := 1);
	<sign+28 @03c7f4>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @03c7f9>   : 13 04                      set.x1 sp(4)
	<sign+35 @03c7fb>   : 03                         ret
.references:
	lib/std/math.ci:80: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@03c800>
.name: 'abs'
.file: 'lib/std/math.ci:90'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@03c800> - <@03c812>)
	lib/std/math.ci:91: (14 bytes: <@03c800> - <@03c80e>): if (bool(x < (0)))
	<abs @03c800>      : 10 01                      dup.x1 sp(1)
	<abs+2 @03c802>    : 19                         load.z32
	<abs+3 @03c803>    : 78                         clt.f32
	<abs+4 @03c804>    : 06 0a 00 00                jz <abs+14 @03c80e>
	lib/std/math.ci:92: (6 bytes: <@03c808> - <@03c80e>): return float32(.result := float32(-x));
	<abs+8 @03c808>    : 10 01                      dup.x1 sp(1)
	<abs+10 @03c80a>   : 70                         neg.f32
	<abs+11 @03c80b>   : 13 03                      set.x1 sp(3)
	<abs+13 @03c80d>   : 03                         ret
	lib/std/math.ci:94: (4 bytes: <@03c80e> - <@03c812>): return float32(.result := x);
	<abs+14 @03c80e>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @03c811>   : 03                         ret
.references:
	lib/std/math.ci:90: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@03c818>
.name: 'abs'
.file: 'lib/std/math.ci:96'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@03c818> - <@03c82a>)
	lib/std/math.ci:97: (14 bytes: <@03c818> - <@03c826>): if (bool(x < (0)))
	<abs @03c818>      : 11 01                      dup.x2 sp(1)
	<abs+2 @03c81a>    : 1a                         load.z64
	<abs+3 @03c81b>    : 88                         clt.f64
	<abs+4 @03c81c>    : 06 0a 00 00                jz <abs+14 @03c826>
	lib/std/math.ci:98: (6 bytes: <@03c820> - <@03c826>): return float64(.result := float64(-x));
	<abs+8 @03c820>    : 11 01                      dup.x2 sp(1)
	<abs+10 @03c822>   : 80                         neg.f64
	<abs+11 @03c823>   : 14 05                      set.x2 sp(5)
	<abs+13 @03c825>   : 03                         ret
	lib/std/math.ci:100: (4 bytes: <@03c826> - <@03c82a>): return float64(.result := x);
	<abs+14 @03c826>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @03c829>   : 03                         ret
.references:
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.ci:320: referenced as `abs`
	lib/std/math.ci:96: defined as `abs(x: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@03c830>
.name: 'min'
.file: 'lib/std/math.ci:103'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@03c830> - <@03c841>)
	lib/std/math.ci:104: (13 bytes: <@03c830> - <@03c83d>): if (bool(a < b))
	<min @03c830>      : 10 02                      dup.x1 sp(2)
	<min+2 @03c832>    : 10 02                      dup.x1 sp(2)
	<min+4 @03c834>    : 78                         clt.f32
	<min+5 @03c835>    : 06 08 00 00                jz <min+13 @03c83d>
	lib/std/math.ci:105: (4 bytes: <@03c839> - <@03c83d>): return float32(.result := a);
	<min+9 @03c839>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @03c83c>   : 03                         ret
	lib/std/math.ci:107: (4 bytes: <@03c83d> - <@03c841>): return float32(.result := b);
	<min+13 @03c83d>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @03c840>   : 03                         ret
.references:
	lib/std/math.ci:103: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@03c848>
.name: 'min'
.file: 'lib/std/math.ci:109'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@03c848> - <@03c859>)
	lib/std/math.ci:110: (13 bytes: <@03c848> - <@03c855>): if (bool(a < b))
	<min @03c848>      : 11 03                      dup.x2 sp(3)
	<min+2 @03c84a>    : 11 03                      dup.x2 sp(3)
	<min+4 @03c84c>    : 88                         clt.f64
	<min+5 @03c84d>    : 06 08 00 00                jz <min+13 @03c855>
	lib/std/math.ci:111: (4 bytes: <@03c851> - <@03c855>): return float64(.result := a);
	<min+9 @03c851>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @03c854>   : 03                         ret
	lib/std/math.ci:113: (4 bytes: <@03c855> - <@03c859>): return float64(.result := b);
	<min+13 @03c855>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @03c858>   : 03                         ret
.references:
	lib/std/math.ci:109: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@03c860>
.name: 'max'
.file: 'lib/std/math.ci:116'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@03c860> - <@03c871>)
	lib/std/math.ci:117: (13 bytes: <@03c860> - <@03c86d>): if (bool(a > b))
	<max @03c860>      : 10 02                      dup.x1 sp(2)
	<max+2 @03c862>    : 10 02                      dup.x1 sp(2)
	<max+4 @03c864>    : 79                         cgt.f32
	<max+5 @03c865>    : 06 08 00 00                jz <max+13 @03c86d>
	lib/std/math.ci:118: (4 bytes: <@03c869> - <@03c86d>): return float32(.result := a);
	<max+9 @03c869>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @03c86c>   : 03                         ret
	lib/std/math.ci:120: (4 bytes: <@03c86d> - <@03c871>): return float32(.result := b);
	<max+13 @03c86d>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @03c870>   : 03                         ret
.references:
	lib/std/math.ci:116: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@03c878>
.name: 'max'
.file: 'lib/std/math.ci:122'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@03c878> - <@03c889>)
	lib/std/math.ci:123: (13 bytes: <@03c878> - <@03c885>): if (bool(a > b))
	<max @03c878>      : 11 03                      dup.x2 sp(3)
	<max+2 @03c87a>    : 11 03                      dup.x2 sp(3)
	<max+4 @03c87c>    : 89                         cgt.f64
	<max+5 @03c87d>    : 06 08 00 00                jz <max+13 @03c885>
	lib/std/math.ci:124: (4 bytes: <@03c881> - <@03c885>): return float64(.result := a);
	<max+9 @03c881>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @03c884>   : 03                         ret
	lib/std/math.ci:126: (4 bytes: <@03c885> - <@03c889>): return float64(.result := b);
	<max+13 @03c885>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @03c888>   : 03                         ret
.references:
	lib/std/math.ci:122: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@03c890>
.name: 'clamp'
.file: 'lib/std/math.ci:129'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@03c890> - <@03c8ae>)
	lib/std/math.ci:130: (13 bytes: <@03c890> - <@03c89d>): if (bool(t < a))
	<clamp @03c890>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @03c892>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @03c894>    : 78                         clt.f32
	<clamp+5 @03c895>    : 06 08 00 00                jz <clamp+13 @03c89d>
	lib/std/math.ci:131: (4 bytes: <@03c899> - <@03c89d>): return float32(.result := a);
	<clamp+9 @03c899>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @03c89c>   : 03                         ret
	lib/std/math.ci:133: (13 bytes: <@03c89d> - <@03c8aa>): if (bool(t > b))
	<clamp+13 @03c89d>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @03c89f>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @03c8a1>   : 79                         cgt.f32
	<clamp+18 @03c8a2>   : 06 08 00 00                jz <clamp+26 @03c8aa>
	lib/std/math.ci:134: (4 bytes: <@03c8a6> - <@03c8aa>): return float32(.result := b);
	<clamp+22 @03c8a6>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @03c8a9>   : 03                         ret
	lib/std/math.ci:136: (4 bytes: <@03c8aa> - <@03c8ae>): return float32(.result := t);
	<clamp+26 @03c8aa>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @03c8ad>   : 03                         ret
.references:
	lib/std/math.ci:156: referenced as `clamp`
	lib/std/math.ci:129: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@03c8b0>
.name: 'clamp'
.file: 'lib/std/math.ci:138'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@03c8b0> - <@03c8ce>)
	lib/std/math.ci:139: (13 bytes: <@03c8b0> - <@03c8bd>): if (bool(t < a))
	<clamp @03c8b0>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @03c8b2>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @03c8b4>    : 88                         clt.f64
	<clamp+5 @03c8b5>    : 06 08 00 00                jz <clamp+13 @03c8bd>
	lib/std/math.ci:140: (4 bytes: <@03c8b9> - <@03c8bd>): return float64(.result := a);
	<clamp+9 @03c8b9>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @03c8bc>   : 03                         ret
	lib/std/math.ci:142: (13 bytes: <@03c8bd> - <@03c8ca>): if (bool(t > b))
	<clamp+13 @03c8bd>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @03c8bf>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @03c8c1>   : 89                         cgt.f64
	<clamp+18 @03c8c2>   : 06 08 00 00                jz <clamp+26 @03c8ca>
	lib/std/math.ci:143: (4 bytes: <@03c8c6> - <@03c8ca>): return float64(.result := b);
	<clamp+22 @03c8c6>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @03c8c9>   : 03                         ret
	lib/std/math.ci:145: (4 bytes: <@03c8ca> - <@03c8ce>): return float64(.result := t);
	<clamp+26 @03c8ca>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @03c8cd>   : 03                         ret
.references:
	lib/std/math.ci:160: referenced as `clamp`
	lib/std/math.ci:138: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@03c8d0>
.name: 'lerp'
.file: 'lib/std/math.ci:148'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	return float32(.result := float32(a + float32(t * (float32(b - a)))));
}
.instructions: (14 bytes: <@03c8d0> - <@03c8de>)
	lib/std/math.ci:149: (14 bytes: <@03c8d0> - <@03c8de>): return float32(.result := float32(a + float32(t * (float32(b - a)))));
	<lerp @03c8d0>      : 10 02                      dup.x1 sp(2)
	<lerp+2 @03c8d2>    : 10 04                      dup.x1 sp(4)
	<lerp+4 @03c8d4>    : 10 03                      dup.x1 sp(3)
	<lerp+6 @03c8d6>    : 10 05                      dup.x1 sp(5)
	<lerp+8 @03c8d8>    : 72                         sub.f32
	<lerp+9 @03c8d9>    : 73                         mul.f32
	<lerp+10 @03c8da>   : 71                         add.f32
	<lerp+11 @03c8db>   : 13 05                      set.x1 sp(5)
	<lerp+13 @03c8dd>   : 03                         ret
.references:
	lib/std/math.ci:148: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@03c8e0>
.name: 'lerp'
.file: 'lib/std/math.ci:151'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return float64(.result := float64(a + float64(t * (float64(b - a)))));
}
.instructions: (14 bytes: <@03c8e0> - <@03c8ee>)
	lib/std/math.ci:152: (14 bytes: <@03c8e0> - <@03c8ee>): return float64(.result := float64(a + float64(t * (float64(b - a)))));
	<lerp @03c8e0>      : 11 03                      dup.x2 sp(3)
	<lerp+2 @03c8e2>    : 11 07                      dup.x2 sp(7)
	<lerp+4 @03c8e4>    : 11 05                      dup.x2 sp(5)
	<lerp+6 @03c8e6>    : 11 09                      dup.x2 sp(9)
	<lerp+8 @03c8e8>    : 82                         sub.f64
	<lerp+9 @03c8e9>    : 83                         mul.f64
	<lerp+10 @03c8ea>   : 81                         add.f64
	<lerp+11 @03c8eb>   : 14 09                      set.x2 sp(9)
	<lerp+13 @03c8ed>   : 03                         ret
.references:
	lib/std/math.ci:151: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 53
.offset: <@03c8f0>
.name: 'smooth'
.file: 'lib/std/math.ci:155'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	float32(t := clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
	return float32(.result := float32(float32(t * t) * (float32((3) - float32((2) * t)))));
}
.instructions: (53 bytes: <@03c8f0> - <@03c925>)
	lib/std/math.ci:156: (30 bytes: <@03c8f0> - <@03c90e>): float32(t := clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
	<smooth @03c8f0>      : 19                         load.z32
	<smooth+1 @03c8f1>    : 10 04                      dup.x1 sp(4)
	<smooth+3 @03c8f3>    : 10 04                      dup.x1 sp(4)
	<smooth+5 @03c8f5>    : 72                         sub.f32
	<smooth+6 @03c8f6>    : 10 03                      dup.x1 sp(3)
	<smooth+8 @03c8f8>    : 10 05                      dup.x1 sp(5)
	<smooth+10 @03c8fa>   : 72                         sub.f32
	<smooth+11 @03c8fb>   : 74                         div.f32
	<smooth+12 @03c8fc>   : 19                         load.z32
	<smooth+13 @03c8fd>   : 7f 00 00 80 3f             load.f32 1.000000
	<smooth+18 @03c902>   : 1f 90 c8 03 00             load.ref <@03c890> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<smooth+23 @03c907>   : 02                         call
	<smooth+24 @03c908>   : 09 f4 ff ff                inc.sp(-12)
	<smooth+28 @03c90c>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:157: (23 bytes: <@03c90e> - <@03c925>): return float32(.result := float32(float32(t * t) * (float32((3) - float32((2) * t)))));
	<smooth+30 @03c90e>   : 10 03                      dup.x1 sp(3)
	<smooth+32 @03c910>   : 10 04                      dup.x1 sp(4)
	<smooth+34 @03c912>   : 73                         mul.f32
	<smooth+35 @03c913>   : 7f 00 00 40 40             load.f32 3.000000
	<smooth+40 @03c918>   : 7f 00 00 00 40             load.f32 2.000000
	<smooth+45 @03c91d>   : 10 06                      dup.x1 sp(6)
	<smooth+47 @03c91f>   : 73                         mul.f32
	<smooth+48 @03c920>   : 72                         sub.f32
	<smooth+49 @03c921>   : 73                         mul.f32
	<smooth+50 @03c922>   : 13 05                      set.x1 sp(5)
	<smooth+52 @03c924>   : 03                         ret
.references:
	lib/std/math.ci:155: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 65
.offset: <@03c928>
.name: 'smooth'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	float64(t := clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
	return float64(.result := float64(float64(t * t) * (float64((3) - float64((2) * t)))));
}
.instructions: (65 bytes: <@03c928> - <@03c969>)
	lib/std/math.ci:160: (34 bytes: <@03c928> - <@03c94a>): float64(t := clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
	<smooth @03c928>      : 1a                         load.z64
	<smooth+1 @03c929>    : 11 07                      dup.x2 sp(7)
	<smooth+3 @03c92b>    : 11 07                      dup.x2 sp(7)
	<smooth+5 @03c92d>    : 82                         sub.f64
	<smooth+6 @03c92e>    : 11 05                      dup.x2 sp(5)
	<smooth+8 @03c930>    : 11 09                      dup.x2 sp(9)
	<smooth+10 @03c932>   : 82                         sub.f64
	<smooth+11 @03c933>   : 84                         div.f64
	<smooth+12 @03c934>   : 1a                         load.z64
	<smooth+13 @03c935>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<smooth+22 @03c93e>   : 1f b0 c8 03 00             load.ref <@03c8b0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<smooth+27 @03c943>   : 02                         call
	<smooth+28 @03c944>   : 09 e8 ff ff                inc.sp(-24)
	<smooth+32 @03c948>   : 14 07                      set.x2 sp(7)
	lib/std/math.ci:161: (31 bytes: <@03c94a> - <@03c969>): return float64(.result := float64(float64(t * t) * (float64((3) - float64((2) * t)))));
	<smooth+34 @03c94a>   : 11 05                      dup.x2 sp(5)
	<smooth+36 @03c94c>   : 11 07                      dup.x2 sp(7)
	<smooth+38 @03c94e>   : 83                         mul.f64
	<smooth+39 @03c94f>   : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<smooth+48 @03c958>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<smooth+57 @03c961>   : 11 0b                      dup.x2 sp(11)
	<smooth+59 @03c963>   : 83                         mul.f64
	<smooth+60 @03c964>   : 82                         sub.f64
	<smooth+61 @03c965>   : 83                         mul.f64
	<smooth+62 @03c966>   : 14 09                      set.x2 sp(9)
	<smooth+64 @03c968>   : 03                         ret
.references:
	lib/std/math.ci:159: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:184'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.references:
	lib/std/math.ci:184: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:185'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.references:
	lib/std/math.ci:185: defined as `smooth(t: float64): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@03c970>
.name: 'cmp'
.file: 'lib/std/math.ci:239'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@03c970> - <@03c9a9>)
	lib/std/math.ci:240: (53 bytes: <@03c970> - <@03c9a5>): if (bool(a < b))
	<cmp @03c970>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @03c972>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @03c974>    : 78                         clt.f32
	<cmp+5 @03c975>    : 06 1c 00 00                jz <cmp+33 @03c991>
	lib/std/math.ci:241: (20 bytes: <@03c979> - <@03c98d>): if (bool(eps < (float32(b - a))))
	<cmp+9 @03c979>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @03c97b>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @03c97d>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @03c97f>   : 72                         sub.f32
	<cmp+16 @03c980>   : 78                         clt.f32
	<cmp+17 @03c981>   : 06 0c 00 00                jz <cmp+29 @03c98d>
	lib/std/math.ci:242: (8 bytes: <@03c985> - <@03c98d>): return int32(.result := int32(-1));
	<cmp+21 @03c985>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @03c98a>   : 13 05                      set.x1 sp(5)
	<cmp+28 @03c98c>   : 03                         ret
	<cmp+29 @03c98d>   : 04 18 00 00                jmp <cmp+53 @03c9a5>
	lib/std/math.ci:246: (20 bytes: <@03c991> - <@03c9a5>): if (bool(eps < (float32(a - b))))
	<cmp+33 @03c991>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @03c993>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @03c995>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @03c997>   : 72                         sub.f32
	<cmp+40 @03c998>   : 78                         clt.f32
	<cmp+41 @03c999>   : 06 0c 00 00                jz <cmp+53 @03c9a5>
	lib/std/math.ci:247: (8 bytes: <@03c99d> - <@03c9a5>): return int32(.result := int32(+1));
	<cmp+45 @03c99d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @03c9a2>   : 13 05                      set.x1 sp(5)
	<cmp+52 @03c9a4>   : 03                         ret
	lib/std/math.ci:250: (4 bytes: <@03c9a5> - <@03c9a9>): return int32(.result := 0);
	<cmp+53 @03c9a5>   : 19                         load.z32
	<cmp+54 @03c9a6>   : 13 05                      set.x1 sp(5)
	<cmp+56 @03c9a8>   : 03                         ret
.references:
	lib/std/math.ci:239: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@03c9b0>
.name: 'cmp'
.file: 'lib/std/math.ci:252'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@03c9b0> - <@03c9e9>)
	lib/std/math.ci:253: (53 bytes: <@03c9b0> - <@03c9e5>): if (bool(a < b))
	<cmp @03c9b0>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @03c9b2>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @03c9b4>    : 88                         clt.f64
	<cmp+5 @03c9b5>    : 06 1c 00 00                jz <cmp+33 @03c9d1>
	lib/std/math.ci:254: (20 bytes: <@03c9b9> - <@03c9cd>): if (bool(eps < (float64(b - a))))
	<cmp+9 @03c9b9>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @03c9bb>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @03c9bd>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @03c9bf>   : 82                         sub.f64
	<cmp+16 @03c9c0>   : 88                         clt.f64
	<cmp+17 @03c9c1>   : 06 0c 00 00                jz <cmp+29 @03c9cd>
	lib/std/math.ci:255: (8 bytes: <@03c9c5> - <@03c9cd>): return int32(.result := int32(-1));
	<cmp+21 @03c9c5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @03c9ca>   : 13 08                      set.x1 sp(8)
	<cmp+28 @03c9cc>   : 03                         ret
	<cmp+29 @03c9cd>   : 04 18 00 00                jmp <cmp+53 @03c9e5>
	lib/std/math.ci:259: (20 bytes: <@03c9d1> - <@03c9e5>): if (bool(eps < (float64(a - b))))
	<cmp+33 @03c9d1>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @03c9d3>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @03c9d5>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @03c9d7>   : 82                         sub.f64
	<cmp+40 @03c9d8>   : 88                         clt.f64
	<cmp+41 @03c9d9>   : 06 0c 00 00                jz <cmp+53 @03c9e5>
	lib/std/math.ci:260: (8 bytes: <@03c9dd> - <@03c9e5>): return int32(.result := int32(+1));
	<cmp+45 @03c9dd>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @03c9e2>   : 13 08                      set.x1 sp(8)
	<cmp+52 @03c9e4>   : 03                         ret
	lib/std/math.ci:263: (4 bytes: <@03c9e5> - <@03c9e9>): return int32(.result := 0);
	<cmp+53 @03c9e5>   : 19                         load.z32
	<cmp+54 @03c9e6>   : 13 08                      set.x1 sp(8)
	<cmp+56 @03c9e8>   : 03                         ret
.references:
	lib/std/math.ci:252: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 340
.offset: <@03c9f0>
.name: 'sinCos'
.file: 'lib/std/math.ci:266'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (340 bytes: <@03c9f0> - <@03cb44>)
	lib/std/math.ci:280: (2 bytes: <@03c9f0> - <@03c9f2>): x: float64 := arg
	<sinCos @03c9f0>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:281: (17 bytes: <@03c9f2> - <@03ca03>): if (bool(x < (0)))
	<sinCos+2 @03c9f2>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @03c9f4>    : 1a                         load.z64
	<sinCos+5 @03c9f5>    : 88                         clt.f64
	<sinCos+6 @03c9f6>    : 06 0d 00 00                jz <sinCos+19 @03ca03>
	lib/std/math.ci:282: (1 byte: <@03c9fa> - <@03c9fb>): float64(x := float64(-x));
	<sinCos+10 @03c9fa>   : 80                         neg.f64
	lib/std/math.ci:283: (8 bytes: <@03c9fb> - <@03ca03>): int32(quad := int32(quad + 2));
	<sinCos+11 @03c9fb>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @03c9fd>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @03ca01>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:286: (1 byte: <@03ca03> - <@03ca04>): y: float64
	<sinCos+19 @03ca03>   : 1a                         load.z64
	lib/std/math.ci:287: (24 bytes: <@03ca04> - <@03ca1c>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @03ca04>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @03ca06>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @03ca0f>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @03ca18>   : 84                         div.f64
	<sinCos+41 @03ca19>   : 83                         mul.f64
	<sinCos+42 @03ca1a>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:288: (124 bytes: <@03ca1c> - <@03ca98>): if (bool(x > (32764)))
	<sinCos+44 @03ca1c>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @03ca1e>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @03ca27>   : 89                         cgt.f64
	<sinCos+56 @03ca28>   : 06 54 00 00                jz <sinCos+140 @03ca7c>
	lib/std/math.ci:289: (1 byte: <@03ca2c> - <@03ca2d>): e: float64
	<sinCos+60 @03ca2c>   : 1b                         load.z128
	lib/std/math.ci:290: (18 bytes: <@03ca2d> - <@03ca3f>): float64(y := modf(void(x, e)));
	<sinCos+61 @03ca2d>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @03ca2f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @03ca33>   : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @03ca38>   : 02                         call
	<sinCos+73 @03ca39>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @03ca3d>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:291: (4 bytes: <@03ca3f> - <@03ca43>): float64(e := float64(e + (quad)));
	<sinCos+79 @03ca3f>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @03ca41>   : 5d                         i32.2f64
	<sinCos+82 @03ca42>   : 81                         add.f64
	lib/std/math.ci:293: (1 byte: <@03ca43> - <@03ca44>): f: float64
	<sinCos+83 @03ca43>   : 1b                         load.z128
	lib/std/math.ci:294: (30 bytes: <@03ca44> - <@03ca62>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @03ca44>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @03ca4d>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @03ca4f>   : 83                         mul.f64
	<sinCos+96 @03ca50>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @03ca54>  : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @03ca59>  : 02                         call
	<sinCos+106 @03ca5a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @03ca5e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:295: (18 bytes: <@03ca62> - <@03ca74>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @03ca62>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @03ca64>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @03ca6d>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @03ca6f>  : 83                         mul.f64
	<sinCos+128 @03ca70>  : 82                         sub.f64
	<sinCos+129 @03ca71>  : 8a                         f64.2i32
	<sinCos+130 @03ca72>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @03ca74>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @03ca78>  : 04 20 00 00                jmp <sinCos+168 @03ca98>
	lib/std/math.ci:298: (3 bytes: <@03ca7c> - <@03ca7f>): k: int32 := x
	<sinCos+140 @03ca7c>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @03ca7e>  : 8a                         f64.2i32
	lib/std/math.ci:299: (8 bytes: <@03ca7f> - <@03ca87>): float64(y := float64(x - (k)));
	<sinCos+143 @03ca7f>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @03ca81>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @03ca83>  : 5d                         i32.2f64
	<sinCos+148 @03ca84>  : 82                         sub.f64
	<sinCos+149 @03ca85>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:300: (7 bytes: <@03ca87> - <@03ca8e>): int32(quad := int32(quad + k));
	<sinCos+151 @03ca87>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @03ca89>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @03ca8b>  : 51                         add.i32
	<sinCos+156 @03ca8c>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:301: (6 bytes: <@03ca8e> - <@03ca94>): int32(quad := int32(quad & 3));
	<sinCos+158 @03ca8e>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @03ca90>  : 3f 02                      b32.and 0x003
	<sinCos+162 @03ca92>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @03ca94>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:303: (22 bytes: <@03ca98> - <@03caae>): if (int32(quad & 1))
	<sinCos+168 @03ca98>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @03ca9a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @03ca9c>  : 06 12 00 00                jz <sinCos+190 @03caae>
	lib/std/math.ci:304: (14 bytes: <@03caa0> - <@03caae>): float64(y := float64((1) - y));
	<sinCos+176 @03caa0>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @03caa9>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @03caab>  : 82                         sub.f64
	<sinCos+188 @03caac>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:306: (13 bytes: <@03caae> - <@03cabb>): if (bool(quad > 1))
	<sinCos+190 @03caae>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @03cab0>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @03cab5>  : 59                         cgt.i32
	<sinCos+198 @03cab6>  : 06 05 00 00                jz <sinCos+203 @03cabb>
	lib/std/math.ci:307: (1 byte: <@03caba> - <@03cabb>): float64(y := float64(-y));
	<sinCos+202 @03caba>  : 80                         neg.f64
	lib/std/math.ci:310: (5 bytes: <@03cabb> - <@03cac0>): ysq: float64 := float64(y * y)
	<sinCos+203 @03cabb>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @03cabd>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @03cabf>  : 83                         mul.f64
	lib/std/math.ci:311: (64 bytes: <@03cac0> - <@03cb00>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @03cac0>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @03cac9>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @03cacb>  : 83                         mul.f64
	<sinCos+220 @03cacc>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @03cad5>  : 81                         add.f64
	<sinCos+230 @03cad6>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @03cad8>  : 83                         mul.f64
	<sinCos+233 @03cad9>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @03cae2>  : 81                         add.f64
	<sinCos+243 @03cae3>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @03cae5>  : 83                         mul.f64
	<sinCos+246 @03cae6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @03caef>  : 81                         add.f64
	<sinCos+256 @03caf0>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @03caf2>  : 83                         mul.f64
	<sinCos+259 @03caf3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @03cafc>  : 81                         add.f64
	<sinCos+269 @03cafd>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @03caff>  : 83                         mul.f64
	lib/std/math.ci:312: (51 bytes: <@03cb00> - <@03cb33>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @03cb00>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @03cb02>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @03cb0b>  : 81                         add.f64
	<sinCos+284 @03cb0c>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @03cb0e>  : 83                         mul.f64
	<sinCos+287 @03cb0f>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @03cb18>  : 81                         add.f64
	<sinCos+297 @03cb19>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @03cb1b>  : 83                         mul.f64
	<sinCos+300 @03cb1c>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @03cb25>  : 81                         add.f64
	<sinCos+310 @03cb26>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @03cb28>  : 83                         mul.f64
	<sinCos+313 @03cb29>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @03cb32>  : 81                         add.f64
	lib/std/math.ci:313: (12 bytes: <@03cb33> - <@03cb3f>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @03cb33>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @03cb35>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @03cb37>  : 84                         div.f64
	<sinCos+328 @03cb38>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @03cb3a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @03cb3e>  : 03                         ret
	<sinCos+335 @03cb3f>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+339 @03cb43>  : 03                         ret
.references:
	lib/std/math.ci:320: referenced as `sinCos`
	lib/std/math.ci:317: referenced as `sinCos`
	lib/std/math.ci:266: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:317'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(arg, 0))
.references:
	lib/std/math.ci:317: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:320'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(abs(arg), 1))
.references:
	lib/std/math.ci:320: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 376
.offset: <@03cb48>
.name: 'tan'
.file: 'lib/std/math.ci:323'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (376 bytes: <@03cb48> - <@03ccc0>)
	lib/std/math.ci:336: (1 byte: <@03cb48> - <@03cb49>): complement: bool := false
	<tan @03cb48>      : 19                         load.z32
	lib/std/math.ci:337: (1 byte: <@03cb49> - <@03cb4a>): negate: bool := false
	<tan+1 @03cb49>    : 19                         load.z32
	lib/std/math.ci:339: (23 bytes: <@03cb4a> - <@03cb61>): if (bool(arg < (0)))
	<tan+2 @03cb4a>    : 11 03                      dup.x2 sp(3)
	<tan+4 @03cb4c>    : 1a                         load.z64
	<tan+5 @03cb4d>    : 88                         clt.f64
	<tan+6 @03cb4e>    : 06 13 00 00                jz <tan+25 @03cb61>
	lib/std/math.ci:340: (5 bytes: <@03cb52> - <@03cb57>): float64(arg := float64(-arg));
	<tan+10 @03cb52>   : 11 03                      dup.x2 sp(3)
	<tan+12 @03cb54>   : 80                         neg.f64
	<tan+13 @03cb55>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:341: (10 bytes: <@03cb57> - <@03cb61>): bool(negate := true);
	<tan+15 @03cb57>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @03cb5c>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @03cb60>   : 25                         store.i8
	lib/std/math.ci:343: (24 bytes: <@03cb61> - <@03cb79>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @03cb61>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @03cb6a>   : 11 05                      dup.x2 sp(5)
	<tan+36 @03cb6c>   : 83                         mul.f64
	<tan+37 @03cb6d>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @03cb76>   : 84                         div.f64
	<tan+47 @03cb77>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:345: (1 byte: <@03cb79> - <@03cb7a>): e: float64
	<tan+49 @03cb79>   : 1b                         load.z128
	lib/std/math.ci:346: (16 bytes: <@03cb7a> - <@03cb8a>): x: float64 := modf(void(arg, e))
	<tan+50 @03cb7a>   : 11 07                      dup.x2 sp(7)
	<tan+52 @03cb7c>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @03cb80>   : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @03cb85>   : 02                         call
	<tan+62 @03cb86>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:347: (9 bytes: <@03cb8a> - <@03cb93>): i: int32 := int32(int32(e) % 4)
	<tan+66 @03cb8a>   : 11 02                      dup.x2 sp(2)
	<tan+68 @03cb8c>   : 8a                         f64.2i32
	<tan+69 @03cb8d>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @03cb92>   : 55                         mod.i32
	lib/std/math.ci:349: (122 bytes: <@03cb93> - <@03cc0d>): if (bool(i == 0))
	<tan+75 @03cb93>   : 10 00                      dup.x1 sp(0)
	<tan+77 @03cb95>   : 19                         load.z32
	<tan+78 @03cb96>   : 57                         ceq.i32
	<tan+79 @03cb97>   : 05 76 00 00                jnz <tan+197 @03cc0d>
	lib/std/math.ci:350: (114 bytes: <@03cb9b> - <@03cc0d>): if (bool(i == 1))
	<tan+83 @03cb9b>   : 10 00                      dup.x1 sp(0)
	<tan+85 @03cb9d>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @03cba2>   : 57                         ceq.i32
	<tan+91 @03cba3>   : 06 20 00 00                jz <tan+123 @03cbc3>
	lib/std/math.ci:351: (14 bytes: <@03cba7> - <@03cbb5>): float64(x := float64((1) - x));
	<tan+95 @03cba7>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @03cbb0>  : 11 03                      dup.x2 sp(3)
	<tan+106 @03cbb2>  : 82                         sub.f64
	<tan+107 @03cbb3>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:352: (10 bytes: <@03cbb5> - <@03cbbf>): bool(complement := true);
	<tan+109 @03cbb5>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @03cbba>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @03cbbe>  : 25                         store.i8
	<tan+119 @03cbbf>  : 04 4e 00 00                jmp <tan+197 @03cc0d>
	lib/std/math.ci:354: (74 bytes: <@03cbc3> - <@03cc0d>): if (bool(i == 2))
	<tan+123 @03cbc3>  : 10 00                      dup.x1 sp(0)
	<tan+125 @03cbc5>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @03cbca>  : 57                         ceq.i32
	<tan+131 @03cbcb>  : 06 1d 00 00                jz <tan+160 @03cbe8>
	lib/std/math.ci:355: (11 bytes: <@03cbcf> - <@03cbda>): bool(negate := bool(!negate));
	<tan+135 @03cbcf>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @03cbd3>  : 20                         load.i8
	<tan+140 @03cbd4>  : 0b                         not.b32
	<tan+141 @03cbd5>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @03cbd9>  : 25                         store.i8
	lib/std/math.ci:356: (10 bytes: <@03cbda> - <@03cbe4>): bool(complement := true);
	<tan+146 @03cbda>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @03cbdf>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @03cbe3>  : 25                         store.i8
	<tan+156 @03cbe4>  : 04 29 00 00                jmp <tan+197 @03cc0d>
	lib/std/math.ci:358: (37 bytes: <@03cbe8> - <@03cc0d>): if (bool(i == 3))
	<tan+160 @03cbe8>  : 10 00                      dup.x1 sp(0)
	<tan+162 @03cbea>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @03cbef>  : 57                         ceq.i32
	<tan+168 @03cbf0>  : 06 1d 00 00                jz <tan+197 @03cc0d>
	lib/std/math.ci:359: (14 bytes: <@03cbf4> - <@03cc02>): float64(x := float64((1) - x));
	<tan+172 @03cbf4>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @03cbfd>  : 11 03                      dup.x2 sp(3)
	<tan+183 @03cbff>  : 82                         sub.f64
	<tan+184 @03cc00>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:360: (11 bytes: <@03cc02> - <@03cc0d>): bool(negate := bool(!negate));
	<tan+186 @03cc02>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @03cc06>  : 20                         load.i8
	<tan+191 @03cc07>  : 0b                         not.b32
	<tan+192 @03cc08>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @03cc0c>  : 25                         store.i8
	lib/std/math.ci:363: (5 bytes: <@03cc0d> - <@03cc12>): xsq: float64 := float64(x * x)
	<tan+197 @03cc0d>  : 11 01                      dup.x2 sp(1)
	<tan+199 @03cc0f>  : 11 03                      dup.x2 sp(3)
	<tan+201 @03cc11>  : 83                         mul.f64
	lib/std/math.ci:364: (64 bytes: <@03cc12> - <@03cc52>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @03cc12>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @03cc1b>  : 11 02                      dup.x2 sp(2)
	<tan+213 @03cc1d>  : 83                         mul.f64
	<tan+214 @03cc1e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @03cc27>  : 81                         add.f64
	<tan+224 @03cc28>  : 11 02                      dup.x2 sp(2)
	<tan+226 @03cc2a>  : 83                         mul.f64
	<tan+227 @03cc2b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @03cc34>  : 81                         add.f64
	<tan+237 @03cc35>  : 11 02                      dup.x2 sp(2)
	<tan+239 @03cc37>  : 83                         mul.f64
	<tan+240 @03cc38>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @03cc41>  : 81                         add.f64
	<tan+250 @03cc42>  : 11 02                      dup.x2 sp(2)
	<tan+252 @03cc44>  : 83                         mul.f64
	<tan+253 @03cc45>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @03cc4e>  : 81                         add.f64
	<tan+263 @03cc4f>  : 11 05                      dup.x2 sp(5)
	<tan+265 @03cc51>  : 83                         mul.f64
	lib/std/math.ci:365: (39 bytes: <@03cc52> - <@03cc79>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @03cc52>  : 11 02                      dup.x2 sp(2)
	<tan+268 @03cc54>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @03cc5d>  : 81                         add.f64
	<tan+278 @03cc5e>  : 11 04                      dup.x2 sp(4)
	<tan+280 @03cc60>  : 83                         mul.f64
	<tan+281 @03cc61>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @03cc6a>  : 81                         add.f64
	<tan+291 @03cc6b>  : 11 04                      dup.x2 sp(4)
	<tan+293 @03cc6d>  : 83                         mul.f64
	<tan+294 @03cc6e>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @03cc77>  : 81                         add.f64
	<tan+304 @03cc78>  : 84                         div.f64
	lib/std/math.ci:367: (40 bytes: <@03cc79> - <@03cca1>): if (complement)
	<tan+305 @03cc79>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @03cc7d>  : 20                         load.i8
	<tan+310 @03cc7e>  : 06 23 00 00                jz <tan+345 @03cca1>
	lib/std/math.ci:368: (17 bytes: <@03cc82> - <@03cc93>): if (bool(result == (0)))
	<tan+314 @03cc82>  : 11 00                      dup.x2 sp(0)
	<tan+316 @03cc84>  : 1a                         load.z64
	<tan+317 @03cc85>  : 87                         ceq.f64
	<tan+318 @03cc86>  : 06 0d 00 00                jz <tan+331 @03cc93>
	lib/std/math.ci:369: (9 bytes: <@03cc8a> - <@03cc93>): return float64(.result := nan);
	<tan+322 @03cc8a>  : 1b                         load.z128
	<tan+323 @03cc8b>  : 84                         div.f64
	<tan+324 @03cc8c>  : 14 10                      set.x2 sp(16)
	<tan+326 @03cc8e>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @03cc92>  : 03                         ret
	lib/std/math.ci:371: (14 bytes: <@03cc93> - <@03cca1>): float64(result := float64((1) / result));
	<tan+331 @03cc93>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @03cc9c>  : 11 02                      dup.x2 sp(2)
	<tan+342 @03cc9e>  : 84                         div.f64
	<tan+343 @03cc9f>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:373: (19 bytes: <@03cca1> - <@03ccb4>): if (negate)
	<tan+345 @03cca1>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @03cca5>  : 20                         load.i8
	<tan+350 @03cca6>  : 06 0e 00 00                jz <tan+364 @03ccb4>
	lib/std/math.ci:374: (10 bytes: <@03ccaa> - <@03ccb4>): return float64(.result := float64(-result));
	<tan+354 @03ccaa>  : 11 00                      dup.x2 sp(0)
	<tan+356 @03ccac>  : 80                         neg.f64
	<tan+357 @03ccad>  : 14 10                      set.x2 sp(16)
	<tan+359 @03ccaf>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @03ccb3>  : 03                         ret
	lib/std/math.ci:376: (7 bytes: <@03ccb4> - <@03ccbb>): return float64(.result := result);
	<tan+364 @03ccb4>  : 14 0e                      set.x2 sp(14)
	<tan+366 @03ccb6>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @03ccba>  : 03                         ret
	<tan+371 @03ccbb>  : 09 d4 ff ff                inc.sp(-44)
	<tan+375 @03ccbf>  : 03                         ret
.references:
	lib/std/math.ci:323: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 246
.offset: <@03ccc0>
.name: 'sinh'
.file: 'lib/std/math.ci:380'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (246 bytes: <@03ccc0> - <@03cdb6>)
	lib/std/math.ci:392: (1 byte: <@03ccc0> - <@03ccc1>): negate: bool := false
	<sinh @03ccc0>      : 19                         load.z32
	lib/std/math.ci:393: (23 bytes: <@03ccc1> - <@03ccd8>): if (bool(x < (0)))
	<sinh+1 @03ccc1>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @03ccc3>    : 1a                         load.z64
	<sinh+4 @03ccc4>    : 88                         clt.f64
	<sinh+5 @03ccc5>    : 06 13 00 00                jz <sinh+24 @03ccd8>
	lib/std/math.ci:394: (5 bytes: <@03ccc9> - <@03ccce>): float64(x := float64(-x));
	<sinh+9 @03ccc9>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @03cccb>   : 80                         neg.f64
	<sinh+12 @03cccc>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:395: (10 bytes: <@03ccce> - <@03ccd8>): bool(negate := true);
	<sinh+14 @03ccce>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @03ccd3>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @03ccd7>   : 25                         store.i8
	lib/std/math.ci:398: (39 bytes: <@03ccd8> - <@03ccff>): if (bool(x > (21)))
	<sinh+24 @03ccd8>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @03ccda>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @03cce3>   : 89                         cgt.f64
	<sinh+36 @03cce4>   : 06 1b 00 00                jz <sinh+63 @03ccff>
	lib/std/math.ci:399: (23 bytes: <@03cce8> - <@03ccff>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @03cce8>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @03ccea>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @03ccee>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @03ccf7>   : 84                         div.f64
	<sinh+56 @03ccf8>   : 14 06                      set.x2 sp(6)
	<sinh+58 @03ccfa>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @03ccfe>   : 03                         ret
	lib/std/math.ci:402: (1 byte: <@03ccff> - <@03cd00>): result: float64
	<sinh+63 @03ccff>   : 1a                         load.z64
	lib/std/math.ci:403: (151 bytes: <@03cd00> - <@03cd97>): if (bool(x > 0.500000))
	<sinh+64 @03cd00>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @03cd02>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @03cd0b>   : 89                         cgt.f64
	<sinh+76 @03cd0c>   : 06 22 00 00                jz <sinh+110 @03cd2e>
	lib/std/math.ci:404: (26 bytes: <@03cd10> - <@03cd2a>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @03cd10>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @03cd12>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @03cd16>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @03cd18>   : 80                         neg.f64
	<sinh+89 @03cd19>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @03cd1d>   : 82                         sub.f64
	<sinh+94 @03cd1e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @03cd27>  : 84                         div.f64
	<sinh+104 @03cd28>  : 14 02                      set.x2 sp(2)
	<sinh+106 @03cd2a>  : 04 6d 00 00                jmp <sinh+215 @03cd97>
	lib/std/math.ci:407: (5 bytes: <@03cd2e> - <@03cd33>): sq: float64 := float64(x * x)
	<sinh+110 @03cd2e>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @03cd30>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @03cd32>  : 83                         mul.f64
	lib/std/math.ci:408: (53 bytes: <@03cd33> - <@03cd68>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @03cd33>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @03cd3c>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @03cd3e>  : 83                         mul.f64
	<sinh+127 @03cd3f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @03cd48>  : 81                         add.f64
	<sinh+137 @03cd49>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @03cd4b>  : 83                         mul.f64
	<sinh+140 @03cd4c>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @03cd55>  : 81                         add.f64
	<sinh+150 @03cd56>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @03cd58>  : 83                         mul.f64
	<sinh+153 @03cd59>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @03cd62>  : 81                         add.f64
	<sinh+163 @03cd63>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @03cd65>  : 83                         mul.f64
	<sinh+166 @03cd66>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:409: (43 bytes: <@03cd68> - <@03cd93>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @03cd68>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @03cd6a>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @03cd6c>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @03cd75>  : 81                         add.f64
	<sinh+182 @03cd76>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @03cd78>  : 83                         mul.f64
	<sinh+185 @03cd79>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @03cd82>  : 81                         add.f64
	<sinh+195 @03cd83>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @03cd85>  : 83                         mul.f64
	<sinh+198 @03cd86>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @03cd8f>  : 81                         add.f64
	<sinh+208 @03cd90>  : 84                         div.f64
	<sinh+209 @03cd91>  : 14 04                      set.x2 sp(4)
	<sinh+211 @03cd93>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:412: (19 bytes: <@03cd97> - <@03cdaa>): if (negate)
	<sinh+215 @03cd97>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @03cd9b>  : 20                         load.i8
	<sinh+220 @03cd9c>  : 06 0e 00 00                jz <sinh+234 @03cdaa>
	lib/std/math.ci:413: (10 bytes: <@03cda0> - <@03cdaa>): return float64(.result := float64(-result));
	<sinh+224 @03cda0>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @03cda2>  : 80                         neg.f64
	<sinh+227 @03cda3>  : 14 08                      set.x2 sp(8)
	<sinh+229 @03cda5>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @03cda9>  : 03                         ret
	lib/std/math.ci:415: (7 bytes: <@03cdaa> - <@03cdb1>): return float64(.result := result);
	<sinh+234 @03cdaa>  : 14 06                      set.x2 sp(6)
	<sinh+236 @03cdac>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @03cdb0>  : 03                         ret
	<sinh+241 @03cdb1>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+245 @03cdb5>  : 03                         ret
.references:
	lib/std/math.Complex.ci:120: referenced as `sinh`
	lib/std/math.Complex.ci:119: referenced as `sinh`
	lib/std/math.ci:380: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@03cdb8>
.name: 'cosh'
.file: 'lib/std/math.ci:419'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@03cdb8> - <@03ce03>)
	lib/std/math.ci:420: (13 bytes: <@03cdb8> - <@03cdc5>): if (bool(x < (0)))
	<cosh @03cdb8>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @03cdba>    : 1a                         load.z64
	<cosh+3 @03cdbb>    : 88                         clt.f64
	<cosh+4 @03cdbc>    : 06 09 00 00                jz <cosh+13 @03cdc5>
	lib/std/math.ci:421: (5 bytes: <@03cdc0> - <@03cdc5>): float64(x := float64(-x));
	<cosh+8 @03cdc0>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @03cdc2>   : 80                         neg.f64
	<cosh+11 @03cdc3>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:423: (35 bytes: <@03cdc5> - <@03cde8>): if (bool(x > (21)))
	<cosh+13 @03cdc5>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @03cdc7>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @03cdd0>   : 89                         cgt.f64
	<cosh+25 @03cdd1>   : 06 17 00 00                jz <cosh+48 @03cde8>
	lib/std/math.ci:424: (19 bytes: <@03cdd5> - <@03cde8>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @03cdd5>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @03cdd7>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @03cddb>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @03cde4>   : 84                         div.f64
	<cosh+45 @03cde5>   : 14 05                      set.x2 sp(5)
	<cosh+47 @03cde7>   : 03                         ret
	lib/std/math.ci:426: (27 bytes: <@03cde8> - <@03ce03>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @03cde8>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @03cdea>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @03cdee>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @03cdf0>   : 80                         neg.f64
	<cosh+57 @03cdf1>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @03cdf5>   : 81                         add.f64
	<cosh+62 @03cdf6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @03cdff>   : 84                         div.f64
	<cosh+72 @03ce00>   : 14 05                      set.x2 sp(5)
	<cosh+74 @03ce02>   : 03                         ret
.references:
	lib/std/math.Complex.ci:120: referenced as `cosh`
	lib/std/math.Complex.ci:119: referenced as `cosh`
	lib/std/math.ci:419: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 171
.offset: <@03ce08>
.name: 'asin'
.file: 'lib/std/math.ci:435'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (171 bytes: <@03ce08> - <@03ceb3>)
	lib/std/math.ci:436: (12 bytes: <@03ce08> - <@03ce14>): if (bool(x == (0)))
	<asin @03ce08>      : 11 01                      dup.x2 sp(1)
	<asin+2 @03ce0a>    : 1a                         load.z64
	<asin+3 @03ce0b>    : 87                         ceq.f64
	<asin+4 @03ce0c>    : 06 08 00 00                jz <asin+12 @03ce14>
	lib/std/math.ci:438: (4 bytes: <@03ce10> - <@03ce14>): return float64(.result := x);
	<asin+8 @03ce10>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @03ce13>   : 03                         ret
	lib/std/math.ci:441: (1 byte: <@03ce14> - <@03ce15>): negate: bool := false
	<asin+12 @03ce14>   : 19                         load.z32
	lib/std/math.ci:442: (23 bytes: <@03ce15> - <@03ce2c>): if (bool(x < (0)))
	<asin+13 @03ce15>   : 11 02                      dup.x2 sp(2)
	<asin+15 @03ce17>   : 1a                         load.z64
	<asin+16 @03ce18>   : 88                         clt.f64
	<asin+17 @03ce19>   : 06 13 00 00                jz <asin+36 @03ce2c>
	lib/std/math.ci:443: (10 bytes: <@03ce1d> - <@03ce27>): bool(negate := true);
	<asin+21 @03ce1d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @03ce22>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @03ce26>   : 25                         store.i8
	lib/std/math.ci:444: (5 bytes: <@03ce27> - <@03ce2c>): float64(x := float64(-x));
	<asin+31 @03ce27>   : 11 02                      dup.x2 sp(2)
	<asin+33 @03ce29>   : 80                         neg.f64
	<asin+34 @03ce2a>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:447: (25 bytes: <@03ce2c> - <@03ce45>): if (bool(x > (1)))
	<asin+36 @03ce2c>   : 11 02                      dup.x2 sp(2)
	<asin+38 @03ce2e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @03ce37>   : 89                         cgt.f64
	<asin+48 @03ce38>   : 06 0d 00 00                jz <asin+61 @03ce45>
	lib/std/math.ci:449: (9 bytes: <@03ce3c> - <@03ce45>): return float64(.result := nan);
	<asin+52 @03ce3c>   : 1b                         load.z128
	<asin+53 @03ce3d>   : 84                         div.f64
	<asin+54 @03ce3e>   : 14 06                      set.x2 sp(6)
	<asin+56 @03ce40>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @03ce44>   : 03                         ret
	lib/std/math.ci:452: (19 bytes: <@03ce45> - <@03ce58>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @03ce45>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @03ce4e>   : 11 04                      dup.x2 sp(4)
	<asin+72 @03ce50>   : 11 06                      dup.x2 sp(6)
	<asin+74 @03ce52>   : 83                         mul.f64
	<asin+75 @03ce53>   : 82                         sub.f64
	<asin+76 @03ce54>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:453: (60 bytes: <@03ce58> - <@03ce94>): if (bool(x > 0.700000))
	<asin+80 @03ce58>   : 11 04                      dup.x2 sp(4)
	<asin+82 @03ce5a>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @03ce63>   : 89                         cgt.f64
	<asin+92 @03ce64>   : 06 26 00 00                jz <asin+130 @03ce8a>
	lib/std/math.ci:454: (30 bytes: <@03ce68> - <@03ce86>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @03ce68>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @03ce71>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @03ce7a>  : 84                         div.f64
	<asin+115 @03ce7b>  : 11 02                      dup.x2 sp(2)
	<asin+117 @03ce7d>  : 11 08                      dup.x2 sp(8)
	<asin+119 @03ce7f>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @03ce83>  : 82                         sub.f64
	<asin+124 @03ce84>  : 14 02                      set.x2 sp(2)
	<asin+126 @03ce86>  : 04 0e 00 00                jmp <asin+140 @03ce94>
	lib/std/math.ci:457: (10 bytes: <@03ce8a> - <@03ce94>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @03ce8a>  : 11 04                      dup.x2 sp(4)
	<asin+132 @03ce8c>  : 11 02                      dup.x2 sp(2)
	<asin+134 @03ce8e>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @03ce92>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:460: (19 bytes: <@03ce94> - <@03cea7>): if (negate)
	<asin+140 @03ce94>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @03ce98>  : 20                         load.i8
	<asin+145 @03ce99>  : 06 0e 00 00                jz <asin+159 @03cea7>
	lib/std/math.ci:461: (10 bytes: <@03ce9d> - <@03cea7>): return float64(.result := float64(-result));
	<asin+149 @03ce9d>  : 11 00                      dup.x2 sp(0)
	<asin+151 @03ce9f>  : 80                         neg.f64
	<asin+152 @03cea0>  : 14 08                      set.x2 sp(8)
	<asin+154 @03cea2>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @03cea6>  : 03                         ret
	lib/std/math.ci:463: (7 bytes: <@03cea7> - <@03ceae>): return float64(.result := result);
	<asin+159 @03cea7>  : 14 06                      set.x2 sp(6)
	<asin+161 @03cea9>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @03cead>  : 03                         ret
	<asin+166 @03ceae>  : 09 f4 ff ff                inc.sp(-12)
	<asin+170 @03ceb2>  : 03                         ret
.references:
	lib/std/math.ci:470: referenced as `asin`
	lib/std/math.ci:435: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:470'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: (float64(float64(pi / (2)) - asin(x)))
.references:
	lib/std/math.ci:470: defined as `acos(x: float64): float64`
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'deg2rad'
.file: 'lib/std/math.ci:493'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * pi) / (180)))
.references:
	lib/std/math.ci:493: defined as `deg2rad(x: float64): float64`
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rad2deg'
.file: 'lib/std/math.ci:494'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * (180)) / pi))
.references:
	lib/std/math.ci:494: defined as `rad2deg(x: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@014c58>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:3'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:142: referenced as `Complex`
	lib/std/math.Complex.ci:141: referenced as `Complex`
	lib/std/math.Complex.ci:140: referenced as `Complex`
	lib/std/math.Complex.ci:138: referenced as `Complex`
	lib/std/math.Complex.ci:137: referenced as `Complex`
	lib/std/math.Complex.ci:136: referenced as `Complex`
	lib/std/math.Complex.ci:135: referenced as `Complex`
	lib/std/math.Complex.ci:133: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:90: referenced as `Complex`
	lib/std/math.Complex.ci:89: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: referenced as `Complex`
	lib/std/math.Complex.ci:20: referenced as `Complex`
	lib/std/math.Complex.ci:3: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:4'
.owner: Complex
.references:
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:113: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:110: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:101: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:90: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:82: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:79: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:75: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:72: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:70: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:63: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:60: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:56: referenced as `re`
	lib/std/math.Complex.ci:55: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:52: referenced as `re`
	lib/std/math.Complex.ci:27: referenced as `re`
	lib/std/math.Complex.ci:22: referenced as `re`
	lib/std/math.Complex.ci:4: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.value: 0
.references:
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:114: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:110: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:101: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:90: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:81: referenced as `im`
	lib/std/math.Complex.ci:79: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:74: referenced as `im`
	lib/std/math.Complex.ci:72: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:70: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:63: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:60: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:56: referenced as `im`
	lib/std/math.Complex.ci:55: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:52: referenced as `im`
	lib/std/math.Complex.ci:28: referenced as `im`
	lib/std/math.Complex.ci:5: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@03ceb8>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:20'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@03ceb8> - <@03cebf>)
	lib/std/math.Complex.ci:21: (7 bytes: <@03ceb8> - <@03cebf>): return void(.result := {...});
	<Complex @03ceb8>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@03cebb> - <@03cebe>): void(.result.im := (0))
	<Complex+3 @03cebb>    : 1a                         load.z64
	<Complex+4 @03cebc>    : 14 07                      set.x2 sp(7)
	<Complex+6 @03cebe>    : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:20: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@03cec0>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:25'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@03cec0> - <@03cec7>)
	lib/std/math.Complex.ci:26: (7 bytes: <@03cec0> - <@03cec7>): return void(.result := {...});
	<Complex @03cec0>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:28: (3 bytes: <@03cec3> - <@03cec6>): void(.result.im := im);
	<Complex+3 @03cec3>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @03cec6>    : 03                         ret
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:52'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(-a.re), float64(-a.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `neg`
	lib/std/math.Complex.ci:135: referenced as `neg`
	lib/std/math.Complex.ci:52: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:54'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `add`
	lib/std/math.Complex.ci:54: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:55'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re + b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `add`
	lib/std/math.Complex.ci:137: referenced as `add`
	lib/std/math.Complex.ci:55: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:56'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a + b.re), b.im))
.references:
	lib/std/math.Complex.ci:56: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:58'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.references:
	lib/std/math.Complex.ci:135: referenced as `sub`
	lib/std/math.Complex.ci:58: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re - b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `sub`
	lib/std/math.Complex.ci:137: referenced as `sub`
	lib/std/math.Complex.ci:59: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:60'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a - b.re), b.im))
.references:
	lib/std/math.Complex.ci:60: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.references:
	lib/std/math.Complex.ci:62: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:63'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.references:
	lib/std/math.Complex.ci:63: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.references:
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:64: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 128
.offset: <@03cec8>
.name: 'div'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (128 bytes: <@03cec8> - <@03cf48>)
	lib/std/math.Complex.ci:70: (79 bytes: <@03cec8> - <@03cf17>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @03cec8>      : 1a                         load.z64
	<div+1 @03cec9>    : 11 03                      dup.x2 sp(3)
	<div+3 @03cecb>    : 1f 18 c8 03 00             load.ref <@03c818> ;Math.abs(x: float64): float64
	<div+8 @03ced0>    : 02                         call
	<div+9 @03ced1>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @03ced5>   : 1a                         load.z64
	<div+14 @03ced6>   : 11 07                      dup.x2 sp(7)
	<div+16 @03ced8>   : 1f 18 c8 03 00             load.ref <@03c818> ;Math.abs(x: float64): float64
	<div+21 @03cedd>   : 02                         call
	<div+22 @03cede>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @03cee2>   : 88                         clt.f64
	<div+27 @03cee3>   : 05 34 00 00                jnz <div+79 @03cf17>
	lib/std/math.Complex.ci:71: (5 bytes: <@03cee7> - <@03ceec>): r: float64 := float64(b.im / b.re)
	<div+31 @03cee7>   : 11 03                      dup.x2 sp(3)
	<div+33 @03cee9>   : 11 03                      dup.x2 sp(3)
	<div+35 @03ceeb>   : 84                         div.f64
	lib/std/math.Complex.ci:72: (8 bytes: <@03ceec> - <@03cef4>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @03ceec>   : 11 03                      dup.x2 sp(3)
	<div+38 @03ceee>   : 11 02                      dup.x2 sp(2)
	<div+40 @03cef0>   : 11 09                      dup.x2 sp(9)
	<div+42 @03cef2>   : 83                         mul.f64
	<div+43 @03cef3>   : 81                         add.f64
	lib/std/math.Complex.ci:73: (31 bytes: <@03cef4> - <@03cf13>): return void(.result := {...});
	<div+44 @03cef4>   : 11 09                      dup.x2 sp(9)
	<div+46 @03cef6>   : 11 04                      dup.x2 sp(4)
	<div+48 @03cef8>   : 11 0f                      dup.x2 sp(15)
	<div+50 @03cefa>   : 83                         mul.f64
	<div+51 @03cefb>   : 81                         add.f64
	<div+52 @03cefc>   : 11 02                      dup.x2 sp(2)
	<div+54 @03cefe>   : 84                         div.f64
	<div+55 @03ceff>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:75: (13 bytes: <@03cf01> - <@03cf0e>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @03cf01>   : 11 0b                      dup.x2 sp(11)
	<div+59 @03cf03>   : 11 04                      dup.x2 sp(4)
	<div+61 @03cf05>   : 11 0d                      dup.x2 sp(13)
	<div+63 @03cf07>   : 83                         mul.f64
	<div+64 @03cf08>   : 82                         sub.f64
	<div+65 @03cf09>   : 11 02                      dup.x2 sp(2)
	<div+67 @03cf0b>   : 84                         div.f64
	<div+68 @03cf0c>   : 14 11                      set.x2 sp(17)
	<div+70 @03cf0e>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @03cf12>   : 03                         ret
	<div+75 @03cf13>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:78: (5 bytes: <@03cf17> - <@03cf1c>): r: float64 := float64(b.re / b.im)
	<div+79 @03cf17>   : 11 01                      dup.x2 sp(1)
	<div+81 @03cf19>   : 11 05                      dup.x2 sp(5)
	<div+83 @03cf1b>   : 84                         div.f64
	lib/std/math.Complex.ci:79: (8 bytes: <@03cf1c> - <@03cf24>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @03cf1c>   : 11 05                      dup.x2 sp(5)
	<div+86 @03cf1e>   : 11 02                      dup.x2 sp(2)
	<div+88 @03cf20>   : 11 07                      dup.x2 sp(7)
	<div+90 @03cf22>   : 83                         mul.f64
	<div+91 @03cf23>   : 81                         add.f64
	lib/std/math.Complex.ci:80: (31 bytes: <@03cf24> - <@03cf43>): return void(.result := {...});
	<div+92 @03cf24>   : 11 09                      dup.x2 sp(9)
	<div+94 @03cf26>   : 11 04                      dup.x2 sp(4)
	<div+96 @03cf28>   : 83                         mul.f64
	<div+97 @03cf29>   : 11 0d                      dup.x2 sp(13)
	<div+99 @03cf2b>   : 81                         add.f64
	<div+100 @03cf2c>  : 11 02                      dup.x2 sp(2)
	<div+102 @03cf2e>  : 84                         div.f64
	<div+103 @03cf2f>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:82: (13 bytes: <@03cf31> - <@03cf3e>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @03cf31>  : 11 0b                      dup.x2 sp(11)
	<div+107 @03cf33>  : 11 04                      dup.x2 sp(4)
	<div+109 @03cf35>  : 83                         mul.f64
	<div+110 @03cf36>  : 11 0b                      dup.x2 sp(11)
	<div+112 @03cf38>  : 82                         sub.f64
	<div+113 @03cf39>  : 11 02                      dup.x2 sp(2)
	<div+115 @03cf3b>  : 84                         div.f64
	<div+116 @03cf3c>  : 14 11                      set.x2 sp(17)
	<div+118 @03cf3e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @03cf42>  : 03                         ret
	<div+123 @03cf43>  : 09 f0 ff ff                inc.sp(-16)
	<div+127 @03cf47>  : 03                         ret
.references:
	lib/std/math.Complex.ci:138: referenced as `div`
	lib/std/math.Complex.ci:137: referenced as `div`
	lib/std/math.Complex.ci:133: referenced as `div`
	lib/std/math.Complex.ci:132: referenced as `div`
	lib/std/math.Complex.ci:87: referenced as `div`
	lib/std/math.Complex.ci:86: referenced as `div`
	lib/std/math.Complex.ci:66: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:86'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: div(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:136: referenced as `div`
	lib/std/math.Complex.ci:135: referenced as `div`
	lib/std/math.Complex.ci:86: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:87'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.value: div(void(Complex(a), b))
.references:
	lib/std/math.Complex.ci:87: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:89'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.references:
	lib/std/math.Complex.ci:146: referenced as `abs`
	lib/std/math.Complex.ci:108: referenced as `abs`
	lib/std/math.Complex.ci:105: referenced as `abs`
	lib/std/math.Complex.ci:89: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:90'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.atan2(void(a.re, a.im))
.references:
	lib/std/math.Complex.ci:146: referenced as `arg`
	lib/std/math.Complex.ci:109: referenced as `arg`
	lib/std/math.Complex.ci:105: referenced as `arg`
	lib/std/math.Complex.ci:90: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03cf48>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:93'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (36 bytes: <@03cf48> - <@03cf6c>)
	lib/std/math.Complex.ci:94: (11 bytes: <@03cf48> - <@03cf53>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @03cf48>      : 11 01                      dup.x2 sp(1)
	<inv+2 @03cf4a>    : 11 03                      dup.x2 sp(3)
	<inv+4 @03cf4c>    : 83                         mul.f64
	<inv+5 @03cf4d>    : 11 05                      dup.x2 sp(5)
	<inv+7 @03cf4f>    : 11 07                      dup.x2 sp(7)
	<inv+9 @03cf51>    : 83                         mul.f64
	<inv+10 @03cf52>   : 81                         add.f64
	lib/std/math.Complex.ci:95: (20 bytes: <@03cf53> - <@03cf67>): return void(.result := {...});
	<inv+11 @03cf53>   : 11 03                      dup.x2 sp(3)
	<inv+13 @03cf55>   : 11 02                      dup.x2 sp(2)
	<inv+15 @03cf57>   : 84                         div.f64
	<inv+16 @03cf58>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:97: (8 bytes: <@03cf5a> - <@03cf62>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @03cf5a>   : 11 05                      dup.x2 sp(5)
	<inv+20 @03cf5c>   : 80                         neg.f64
	<inv+21 @03cf5d>   : 11 02                      dup.x2 sp(2)
	<inv+23 @03cf5f>   : 84                         div.f64
	<inv+24 @03cf60>   : 14 0b                      set.x2 sp(11)
	<inv+26 @03cf62>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @03cf66>   : 03                         ret
	<inv+31 @03cf67>   : 09 f8 ff ff                inc.sp(-8)
	<inv+35 @03cf6b>   : 03                         ret
.references:
	lib/std/math.Complex.ci:143: referenced as `inv`
	lib/std/math.Complex.ci:142: referenced as `inv`
	lib/std/math.Complex.ci:141: referenced as `inv`
	lib/std/math.Complex.ci:140: referenced as `inv`
	lib/std/math.Complex.ci:93: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:101'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(a.re, float64(-a.im)))
.references:
	lib/std/math.Complex.ci:101: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:103'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.references:
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:103: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:105'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64.log(abs(a)), arg(a)))
.references:
	lib/std/math.Complex.ci:105: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 105
.offset: <@03cf70>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:107'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (105 bytes: <@03cf70> - <@03cfd9>)
	lib/std/math.Complex.ci:108: (23 bytes: <@03cf70> - <@03cf87>): r: float64 := abs(a)
	<pow @03cf70>      : 12 05                      dup.x4 sp(5)
	<pow+2 @03cf72>    : 11 00                      dup.x2 sp(0)
	<pow+4 @03cf74>    : 11 02                      dup.x2 sp(2)
	<pow+6 @03cf76>    : 83                         mul.f64
	<pow+7 @03cf77>    : 11 04                      dup.x2 sp(4)
	<pow+9 @03cf79>    : 11 06                      dup.x2 sp(6)
	<pow+11 @03cf7b>   : 83                         mul.f64
	<pow+12 @03cf7c>   : 81                         add.f64
	<pow+13 @03cf7d>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @03cf81>   : 14 04                      set.x2 sp(4)
	<pow+19 @03cf83>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:109: (16 bytes: <@03cf87> - <@03cf97>): t: float64 := arg(a)
	<pow+23 @03cf87>   : 12 07                      dup.x4 sp(7)
	<pow+25 @03cf89>   : 11 00                      dup.x2 sp(0)
	<pow+27 @03cf8b>   : 11 04                      dup.x2 sp(4)
	<pow+29 @03cf8d>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @03cf91>   : 14 04                      set.x2 sp(4)
	<pow+35 @03cf93>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:110: (15 bytes: <@03cf97> - <@03cfa6>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @03cf97>   : 11 05                      dup.x2 sp(5)
	<pow+41 @03cf99>   : 11 02                      dup.x2 sp(2)
	<pow+43 @03cf9b>   : 83                         mul.f64
	<pow+44 @03cf9c>   : 11 09                      dup.x2 sp(9)
	<pow+46 @03cf9e>   : 11 06                      dup.x2 sp(6)
	<pow+48 @03cfa0>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @03cfa4>   : 83                         mul.f64
	<pow+53 @03cfa5>   : 81                         add.f64
	lib/std/math.Complex.ci:111: (19 bytes: <@03cfa6> - <@03cfb9>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @03cfa6>   : 11 04                      dup.x2 sp(4)
	<pow+56 @03cfa8>   : 11 09                      dup.x2 sp(9)
	<pow+58 @03cfaa>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @03cfae>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @03cfb0>   : 80                         neg.f64
	<pow+65 @03cfb1>   : 11 06                      dup.x2 sp(6)
	<pow+67 @03cfb3>   : 83                         mul.f64
	<pow+68 @03cfb4>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @03cfb8>   : 83                         mul.f64
	lib/std/math.Complex.ci:112: (27 bytes: <@03cfb9> - <@03cfd4>): return void(.result := {...});
	<pow+73 @03cfb9>   : 11 00                      dup.x2 sp(0)
	<pow+75 @03cfbb>   : 11 04                      dup.x2 sp(4)
	<pow+77 @03cfbd>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @03cfc1>   : 83                         mul.f64
	<pow+82 @03cfc2>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:114: (11 bytes: <@03cfc4> - <@03cfcf>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @03cfc4>   : 11 00                      dup.x2 sp(0)
	<pow+86 @03cfc6>   : 11 04                      dup.x2 sp(4)
	<pow+88 @03cfc8>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @03cfcc>   : 83                         mul.f64
	<pow+93 @03cfcd>   : 14 15                      set.x2 sp(21)
	<pow+95 @03cfcf>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @03cfd3>   : 03                         ret
	<pow+100 @03cfd4>  : 09 e0 ff ff                inc.sp(-32)
	<pow+104 @03cfd8>  : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `pow`
	lib/std/math.Complex.ci:107: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:117'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: pow(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:117: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:119'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:141: referenced as `sin`
	lib/std/math.Complex.ci:133: referenced as `sin`
	lib/std/math.Complex.ci:132: referenced as `sin`
	lib/std/math.Complex.ci:119: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:120'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:140: referenced as `cos`
	lib/std/math.Complex.ci:133: referenced as `cos`
	lib/std/math.Complex.ci:132: referenced as `cos`
	lib/std/math.Complex.ci:120: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sin(a), cos(a)))
.references:
	lib/std/math.Complex.ci:132: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:133'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(cos(a), sin(a)))
.references:
	lib/std/math.Complex.ci:133: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:135'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:143: referenced as `sinh`
	lib/std/math.Complex.ci:135: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:136'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:142: referenced as `cosh`
	lib/std/math.Complex.ci:136: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:137'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:137: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:138'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:138: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:140'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cos(a))
.references:
	lib/std/math.Complex.ci:140: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:141'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sin(a))
.references:
	lib/std/math.Complex.ci:141: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:142'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cosh(a))
.references:
	lib/std/math.Complex.ci:142: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sinh(a))
.references:
	lib/std/math.Complex.ci:143: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:145'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.references:
	lib/std/math.Complex.ci:145: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(abs(x), arg(x)))
.references:
	lib/std/math.Complex.ci:146: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 43
.offset: <@03cfe0>
.name: 'length'
.file: 'lib/std/string.ci:3'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (43 bytes: <@03cfe0> - <@03d00b>)
	lib/std/string.ci:4: (16 bytes: <@03cfe0> - <@03cff0>): if (bool((str) == null))
	<length @03cfe0>      : 10 01                      dup.x1 sp(1)
	<length+2 @03cfe2>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @03cfe7>    : 57                         ceq.i32
	<length+8 @03cfe8>    : 06 08 00 00                jz <length+16 @03cff0>
	lib/std/string.ci:5: (4 bytes: <@03cfec> - <@03cff0>): return int32(.result := 0);
	<length+12 @03cfec>   : 19                         load.z32
	<length+13 @03cfed>   : 13 03                      set.x1 sp(3)
	<length+15 @03cfef>   : 03                         ret
	lib/std/string.ci:7: (1 byte: <@03cff0> - <@03cff1>): result: int32 := 0
	<length+16 @03cff0>   : 19                         load.z32
	lib/std/string.ci:8: (18 bytes: <@03cff1> - <@03d003>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @03cff1>   : 04 08 00 00                jmp <length+25 @03cff9>
	lib/std/string.ci:8: (4 bytes: <@03cff5> - <@03cff9>): int32(result := int32(result + 1))
	<length+21 @03cff5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:8: (10 bytes: <@03cff9> - <@03d003>): str[result]
	<length+25 @03cff9>   : 10 02                      dup.x1 sp(2)
	<length+27 @03cffb>   : 10 01                      dup.x1 sp(1)
	<length+29 @03cffd>   : 51                         add.i32
	<length+30 @03cffe>   : 20                         load.i8
	<length+31 @03cfff>   : 05 f6 ff ff                jnz <length+21 @03cff5>
	lib/std/string.ci:10: (3 bytes: <@03d003> - <@03d006>): return int32(.result := result);
	<length+35 @03d003>   : 13 03                      set.x1 sp(3)
	<length+37 @03d005>   : 03                         ret
	<length+38 @03d006>   : 09 fc ff ff                inc.sp(-4)
	<length+42 @03d00a>   : 03                         ret
.references:
	lib/std/string.ci:46: referenced as `length`
	lib/std/string.ci:45: referenced as `length`
	lib/std/string.ci:3: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@03d010>
.name: 'indexOf'
.file: 'lib/std/string.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@03d010> - <@03d042>)
	lib/std/string.ci:15: (42 bytes: <@03d010> - <@03d03a>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @03d010>      : 19                         load.z32
	<indexOf+1 @03d011>    : 04 1b 00 00                jmp <indexOf+28 @03d02c>
	lib/std/string.ci:16: (19 bytes: <@03d015> - <@03d028>): if (bool(str[i] == chr))
	<indexOf+5 @03d015>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @03d017>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @03d019>    : 51                         add.i32
	<indexOf+10 @03d01a>   : 20                         load.i8
	<indexOf+11 @03d01b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @03d01f>   : 20                         load.i8
	<indexOf+16 @03d020>   : 57                         ceq.i32
	<indexOf+17 @03d021>   : 06 07 00 00                jz <indexOf+24 @03d028>
	lib/std/string.ci:17: (3 bytes: <@03d025> - <@03d028>): return int32(.result := i);
	<indexOf+21 @03d025>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @03d027>   : 03                         ret
	lib/std/string.ci:15: (4 bytes: <@03d028> - <@03d02c>): int32(i := int32(i + 1))
	<indexOf+24 @03d028>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:15: (10 bytes: <@03d02c> - <@03d036>): str[i]
	<indexOf+28 @03d02c>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @03d02e>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @03d030>   : 51                         add.i32
	<indexOf+33 @03d031>   : 20                         load.i8
	<indexOf+34 @03d032>   : 05 e3 ff ff                jnz <indexOf+5 @03d015>
	<indexOf+38 @03d036>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:20: (8 bytes: <@03d03a> - <@03d042>): return int32(.result := int32(-1));
	<indexOf+42 @03d03a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @03d03f>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @03d041>   : 03                         ret
.references:
	lib/std/string.ci:92: referenced as `indexOf`
	lib/std/string.ci:14: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 55
.offset: <@03d048>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:24'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (55 bytes: <@03d048> - <@03d07f>)
	lib/std/string.ci:25: (5 bytes: <@03d048> - <@03d04d>): result: int32 := int32(-1)
	<lastIndexOf @03d048>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:26: (42 bytes: <@03d04d> - <@03d077>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @03d04d>    : 19                         load.z32
	<lastIndexOf+6 @03d04e>    : 04 1b 00 00                jmp <lastIndexOf+33 @03d069>
	lib/std/string.ci:27: (19 bytes: <@03d052> - <@03d065>): if (bool(str[i] == chr))
	<lastIndexOf+10 @03d052>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @03d054>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @03d056>   : 51                         add.i32
	<lastIndexOf+15 @03d057>   : 20                         load.i8
	<lastIndexOf+16 @03d058>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @03d05c>   : 20                         load.i8
	<lastIndexOf+21 @03d05d>   : 57                         ceq.i32
	<lastIndexOf+22 @03d05e>   : 06 07 00 00                jz <lastIndexOf+29 @03d065>
	lib/std/string.ci:28: (3 bytes: <@03d062> - <@03d065>): int32(result := i);
	<lastIndexOf+26 @03d062>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:26: (4 bytes: <@03d065> - <@03d069>): int32(i := int32(i + 1))
	<lastIndexOf+29 @03d065>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:26: (10 bytes: <@03d069> - <@03d073>): str[i]
	<lastIndexOf+33 @03d069>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @03d06b>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @03d06d>   : 51                         add.i32
	<lastIndexOf+38 @03d06e>   : 20                         load.i8
	<lastIndexOf+39 @03d06f>   : 05 e3 ff ff                jnz <lastIndexOf+10 @03d052>
	<lastIndexOf+43 @03d073>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:31: (3 bytes: <@03d077> - <@03d07a>): return int32(.result := result);
	<lastIndexOf+47 @03d077>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @03d079>   : 03                         ret
	<lastIndexOf+50 @03d07a>   : 09 fc ff ff                inc.sp(-4)
	<lastIndexOf+54 @03d07e>   : 03                         ret
.references:
	lib/std/string.ci:24: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@03d080>
.name: 'startsWith'
.file: 'lib/std/string.ci:35'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@03d080> - <@03d0c9>)
	lib/std/string.ci:36: (62 bytes: <@03d080> - <@03d0be>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @03d080>      : 19                         load.z32
	<startsWith+1 @03d081>    : 04 2d 00 00                jmp <startsWith+46 @03d0ae>
	lib/std/string.ci:37: (37 bytes: <@03d085> - <@03d0aa>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @03d085>    : 19                         load.z32
	<startsWith+6 @03d086>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @03d088>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @03d08a>   : 51                         add.i32
	<startsWith+11 @03d08b>   : 20                         load.i8
	<startsWith+12 @03d08c>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @03d08e>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @03d090>   : 51                         add.i32
	<startsWith+17 @03d091>   : 20                         load.i8
	<startsWith+18 @03d092>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @03d094>   : 02                         call
	<startsWith+21 @03d095>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @03d099>   : 19                         load.z32
	<startsWith+26 @03d09a>   : 57                         ceq.i32
	<startsWith+27 @03d09b>   : 05 0f 00 00                jnz <startsWith+42 @03d0aa>
	lib/std/string.ci:38: (11 bytes: <@03d09f> - <@03d0aa>): return bool(.result := false);
	<startsWith+31 @03d09f>   : 19                         load.z32
	<startsWith+32 @03d0a0>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @03d0a4>   : 25                         store.i8
	<startsWith+37 @03d0a5>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @03d0a9>   : 03                         ret
	lib/std/string.ci:36: (4 bytes: <@03d0aa> - <@03d0ae>): int32(i := int32(i + 1))
	<startsWith+42 @03d0aa>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:36: (12 bytes: <@03d0ae> - <@03d0ba>): bool((with[i]) != 0)
	<startsWith+46 @03d0ae>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @03d0b0>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @03d0b2>   : 51                         add.i32
	<startsWith+51 @03d0b3>   : 20                         load.i8
	<startsWith+52 @03d0b4>   : 19                         load.z32
	<startsWith+53 @03d0b5>   : 57                         ceq.i32
	<startsWith+54 @03d0b6>   : 06 cf ff ff                jz <startsWith+5 @03d085>
	<startsWith+58 @03d0ba>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:41: (11 bytes: <@03d0be> - <@03d0c9>): return bool(.result := true);
	<startsWith+62 @03d0be>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @03d0c3>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @03d0c7>   : 25                         store.i8
	<startsWith+72 @03d0c8>   : 03                         ret
.references:
	lib/std/string.ci:88: referenced as `startsWith`
	lib/std/string.ci:35: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 131
.offset: <@03d0d0>
.name: 'endsWith'
.file: 'lib/std/string.ci:44'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (131 bytes: <@03d0d0> - <@03d153>)
	lib/std/string.ci:45: (13 bytes: <@03d0d0> - <@03d0dd>): withLen: int32 := length(with)
	<endsWith @03d0d0>      : 19                         load.z32
	<endsWith+1 @03d0d1>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @03d0d3>    : 1f e0 cf 03 00             load.ref <@03cfe0> ;length(str: char[*]): int32
	<endsWith+8 @03d0d8>    : 02                         call
	<endsWith+9 @03d0d9>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:46: (13 bytes: <@03d0dd> - <@03d0ea>): strLen: int32 := length(str)
	<endsWith+13 @03d0dd>   : 19                         load.z32
	<endsWith+14 @03d0de>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @03d0e0>   : 1f e0 cf 03 00             load.ref <@03cfe0> ;length(str: char[*]): int32
	<endsWith+21 @03d0e5>   : 02                         call
	<endsWith+22 @03d0e6>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:47: (20 bytes: <@03d0ea> - <@03d0fe>): if (bool(strLen < withLen))
	<endsWith+26 @03d0ea>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @03d0ec>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @03d0ee>   : 58                         clt.i32
	<endsWith+31 @03d0ef>   : 06 0f 00 00                jz <endsWith+46 @03d0fe>
	lib/std/string.ci:48: (11 bytes: <@03d0f3> - <@03d0fe>): return bool(.result := false);
	<endsWith+35 @03d0f3>   : 19                         load.z32
	<endsWith+36 @03d0f4>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @03d0f8>   : 25                         store.i8
	<endsWith+41 @03d0f9>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @03d0fd>   : 03                         ret
	lib/std/string.ci:50: (65 bytes: <@03d0fe> - <@03d13f>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @03d0fe>   : 19                         load.z32
	<endsWith+47 @03d0ff>   : 04 33 00 00                jmp <endsWith+98 @03d132>
	lib/std/string.ci:51: (43 bytes: <@03d103> - <@03d12e>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @03d103>   : 19                         load.z32
	<endsWith+52 @03d104>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @03d106>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @03d108>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @03d10a>   : 52                         sub.i32
	<endsWith+59 @03d10b>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @03d10d>   : 51                         add.i32
	<endsWith+62 @03d10e>   : 51                         add.i32
	<endsWith+63 @03d10f>   : 20                         load.i8
	<endsWith+64 @03d110>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @03d112>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @03d114>   : 51                         add.i32
	<endsWith+69 @03d115>   : 20                         load.i8
	<endsWith+70 @03d116>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @03d118>   : 02                         call
	<endsWith+73 @03d119>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @03d11d>   : 19                         load.z32
	<endsWith+78 @03d11e>   : 57                         ceq.i32
	<endsWith+79 @03d11f>   : 05 0f 00 00                jnz <endsWith+94 @03d12e>
	lib/std/string.ci:52: (11 bytes: <@03d123> - <@03d12e>): return bool(.result := false);
	<endsWith+83 @03d123>   : 19                         load.z32
	<endsWith+84 @03d124>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @03d128>   : 25                         store.i8
	<endsWith+89 @03d129>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @03d12d>   : 03                         ret
	lib/std/string.ci:50: (4 bytes: <@03d12e> - <@03d132>): int32(i := int32(i + 1))
	<endsWith+94 @03d12e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:50: (9 bytes: <@03d132> - <@03d13b>): bool(i < withLen)
	<endsWith+98 @03d132>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @03d134>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @03d136>  : 58                         clt.i32
	<endsWith+103 @03d137>  : 05 cc ff ff                jnz <endsWith+51 @03d103>
	<endsWith+107 @03d13b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:55: (15 bytes: <@03d13f> - <@03d14e>): return bool(.result := true);
	<endsWith+111 @03d13f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @03d144>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @03d148>  : 25                         store.i8
	<endsWith+121 @03d149>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @03d14d>  : 03                         ret
	<endsWith+126 @03d14e>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+130 @03d152>  : 03                         ret
.references:
	lib/std/string.ci:89: referenced as `endsWith`
	lib/std/string.ci:44: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@03d158>
.name: 'compare'
.file: 'lib/std/string.ci:58'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (68 bytes: <@03d158> - <@03d19c>)
	lib/std/string.ci:59: (1 byte: <@03d158> - <@03d159>): result: int32 := 0
	<compare @03d158>      : 19                         load.z32
	lib/std/string.ci:60: (59 bytes: <@03d159> - <@03d194>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @03d159>    : 19                         load.z32
	<compare+2 @03d15a>    : 04 2e 00 00                jmp <compare+48 @03d188>
	lib/std/string.ci:61: (22 bytes: <@03d15e> - <@03d174>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @03d15e>    : 19                         load.z32
	<compare+7 @03d15f>    : 10 06                      dup.x1 sp(6)
	<compare+9 @03d161>    : 10 02                      dup.x1 sp(2)
	<compare+11 @03d163>   : 51                         add.i32
	<compare+12 @03d164>   : 20                         load.i8
	<compare+13 @03d165>   : 10 06                      dup.x1 sp(6)
	<compare+15 @03d167>   : 10 03                      dup.x1 sp(3)
	<compare+17 @03d169>   : 51                         add.i32
	<compare+18 @03d16a>   : 20                         load.i8
	<compare+19 @03d16b>   : 10 06                      dup.x1 sp(6)
	<compare+21 @03d16d>   : 02                         call
	<compare+22 @03d16e>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @03d172>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:62: (16 bytes: <@03d174> - <@03d184>): if (bool((str[i]) == 0))
	<compare+28 @03d174>   : 10 05                      dup.x1 sp(5)
	<compare+30 @03d176>   : 10 01                      dup.x1 sp(1)
	<compare+32 @03d178>   : 51                         add.i32
	<compare+33 @03d179>   : 20                         load.i8
	<compare+34 @03d17a>   : 19                         load.z32
	<compare+35 @03d17b>   : 57                         ceq.i32
	<compare+36 @03d17c>   : 06 08 00 00                jz <compare+44 @03d184>
	lib/std/string.ci:63: (4 bytes: <@03d180> - <@03d184>): break;
	<compare+40 @03d180>   : 04 10 00 00                jmp <compare+56 @03d190>
	lib/std/string.ci:60: (4 bytes: <@03d184> - <@03d188>): int32(i := int32(i + 1))
	<compare+44 @03d184>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:60: (8 bytes: <@03d188> - <@03d190>): bool(result == 0)
	<compare+48 @03d188>   : 10 01                      dup.x1 sp(1)
	<compare+50 @03d18a>   : 19                         load.z32
	<compare+51 @03d18b>   : 57                         ceq.i32
	<compare+52 @03d18c>   : 05 d2 ff ff                jnz <compare+6 @03d15e>
	<compare+56 @03d190>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:66: (3 bytes: <@03d194> - <@03d197>): return int32(.result := result);
	<compare+60 @03d194>   : 13 05                      set.x1 sp(5)
	<compare+62 @03d196>   : 03                         ret
	<compare+63 @03d197>   : 09 fc ff ff                inc.sp(-4)
	<compare+67 @03d19b>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `compare`
	lib/std/string.ci:58: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03d1e8>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:70'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@03d1e8> - <@03d20c>)
	lib/std/string.ci:81: (36 bytes: <@03d1e8> - <@03d20c>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @03d1e8>      : 19                         load.z32
	<ignCaseCmp+1 @03d1e9>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @03d1ed>    : 20                         load.i8
	<ignCaseCmp+6 @03d1ee>    : 1f a0 d1 03 00             load.ref <@03d1a0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @03d1f3>   : 02                         call
	<ignCaseCmp+12 @03d1f4>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @03d1f8>   : 19                         load.z32
	<ignCaseCmp+17 @03d1f9>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @03d1fd>   : 20                         load.i8
	<ignCaseCmp+22 @03d1fe>   : 1f a0 d1 03 00             load.ref <@03d1a0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @03d203>   : 02                         call
	<ignCaseCmp+28 @03d204>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @03d208>   : 52                         sub.i32
	<ignCaseCmp+33 @03d209>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @03d20b>   : 03                         ret
.references:
	lib/std/string.ci:70: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@03d210>
.name: 'caseCmp'
.file: 'lib/std/string.ci:84'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@03d210> - <@03d21e>)
	lib/std/string.ci:85: (14 bytes: <@03d210> - <@03d21e>): return char(.result := char(chr - with));
	<caseCmp @03d210>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @03d214>    : 20                         load.i8
	<caseCmp+5 @03d215>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @03d219>    : 20                         load.i8
	<caseCmp+10 @03d21a>   : 52                         sub.i32
	<caseCmp+11 @03d21b>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @03d21d>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `caseCmp`
	lib/std/string.ci:89: referenced as `caseCmp`
	lib/std/string.ci:88: referenced as `caseCmp`
	lib/std/string.ci:84: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:88'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:88: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:89'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:89: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:90'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:90: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.value: bool(indexOf(void(str, chr)) >= 0)
.references:
	lib/std/string.ci:158: referenced as `contains`
	lib/std/string.ci:92: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01c5a8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:106'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.references:
	lib/std/string.ci:206: referenced as `FormatFlags`
	lib/std/string.ci:196: referenced as `FormatFlags`
	lib/std/string.ci:192: referenced as `FormatFlags`
	lib/std/string.ci:129: referenced as `FormatFlags`
	lib/std/string.ci:106: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:107'
.owner: FormatFlags
.value: 10
.references:
	lib/std/string.ci:136: referenced as `radix`
	lib/std/string.ci:107: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:108'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:150: referenced as `padChr`
	lib/std/string.ci:108: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:109'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:148: referenced as `padLen`
	lib/std/string.ci:109: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:110'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:110: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@03d220>
.name: 'append'
.file: 'lib/std/string.ci:113'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@03d220> - <@03d274>)
	lib/std/string.ci:114: (56 bytes: <@03d220> - <@03d258>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @03d220>      : 19                         load.z32
	<append+1 @03d221>    : 04 29 00 00                jmp <append+42 @03d24a>
	lib/std/string.ci:115: (13 bytes: <@03d225> - <@03d232>): if (bool(pos >= (output.length)))
	<append+5 @03d225>    : 10 03                      dup.x1 sp(3)
	<append+7 @03d227>    : 10 06                      dup.x1 sp(6)
	<append+9 @03d229>    : 58                         clt.i32
	<append+10 @03d22a>   : 05 08 00 00                jnz <append+18 @03d232>
	lib/std/string.ci:116: (4 bytes: <@03d22e> - <@03d232>): break;
	<append+14 @03d22e>   : 04 26 00 00                jmp <append+52 @03d254>
	lib/std/string.ci:118: (12 bytes: <@03d232> - <@03d23e>): char(output[pos] := value[i]);
	<append+18 @03d232>   : 10 02                      dup.x1 sp(2)
	<append+20 @03d234>   : 10 01                      dup.x1 sp(1)
	<append+22 @03d236>   : 51                         add.i32
	<append+23 @03d237>   : 20                         load.i8
	<append+24 @03d238>   : 10 05                      dup.x1 sp(5)
	<append+26 @03d23a>   : 10 05                      dup.x1 sp(5)
	<append+28 @03d23c>   : 51                         add.i32
	<append+29 @03d23d>   : 25                         store.i8
	lib/std/string.ci:119: (8 bytes: <@03d23e> - <@03d246>): int32(pos := int32(pos + 1));
	<append+30 @03d23e>   : 10 03                      dup.x1 sp(3)
	<append+32 @03d240>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @03d244>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:114: (4 bytes: <@03d246> - <@03d24a>): int32(i := int32(i + 1))
	<append+38 @03d246>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:114: (10 bytes: <@03d24a> - <@03d254>): value[i]
	<append+42 @03d24a>   : 10 02                      dup.x1 sp(2)
	<append+44 @03d24c>   : 10 01                      dup.x1 sp(1)
	<append+46 @03d24e>   : 51                         add.i32
	<append+47 @03d24f>   : 20                         load.i8
	<append+48 @03d250>   : 05 d5 ff ff                jnz <append+5 @03d225>
	<append+52 @03d254>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:122: (17 bytes: <@03d258> - <@03d269>): if (bool(pos >= (output.length)))
	<append+56 @03d258>   : 10 02                      dup.x1 sp(2)
	<append+58 @03d25a>   : 10 05                      dup.x1 sp(5)
	<append+60 @03d25c>   : 58                         clt.i32
	<append+61 @03d25d>   : 05 0c 00 00                jnz <append+73 @03d269>
	lib/std/string.ci:123: (8 bytes: <@03d261> - <@03d269>): int32(pos := (uint32(output.length - (1))));
	<append+65 @03d261>   : 10 04                      dup.x1 sp(4)
	<append+67 @03d263>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @03d267>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:125: (7 bytes: <@03d269> - <@03d270>): char(output[pos] := (0));
	<append+73 @03d269>   : 19                         load.z32
	<append+74 @03d26a>   : 10 04                      dup.x1 sp(4)
	<append+76 @03d26c>   : 10 04                      dup.x1 sp(4)
	<append+78 @03d26e>   : 51                         add.i32
	<append+79 @03d26f>   : 25                         store.i8
	lib/std/string.ci:126: (4 bytes: <@03d270> - <@03d274>): return int32(.result := pos);
	<append+80 @03d270>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @03d273>   : 03                         ret
.references:
	lib/std/string.ci:113: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 662
.offset: <@03d288>
.name: 'append'
.file: 'lib/std/string.ci:129'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (662 bytes: <@03d288> - <@03d51e>)
	lib/std/string.ci:133: (1 byte: <@03d288> - <@03d289>): len: int32 := 0
	<append @03d288>      : 19                         load.z32
	lib/std/string.ci:134: (4 bytes: <@03d289> - <@03d28d>): digits: char[80]
	<append+1 @03d289>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:136: (3 bytes: <@03d28d> - <@03d290>): radix: int32 := format.radix
	<append+5 @03d28d>    : 10 16                      dup.x1 sp(22)
	<append+7 @03d28f>    : 22                         load.i32
	lib/std/string.ci:137: (54 bytes: <@03d290> - <@03d2c6>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @03d290>    : 10 00                      dup.x1 sp(0)
	<append+10 @03d292>   : 1c 01 00 00 00             load.c32 1
	<append+15 @03d297>   : 59                         cgt.i32
	<append+16 @03d298>   : 06 08 00 00                jz <append+24 @03d2a0>
	<append+20 @03d29c>   : 04 2a 00 00                jmp <append+62 @03d2c6>
	<append+24 @03d2a0>   : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+29 @03d2a5>   : 1c 89 00 00 00             load.c32 137
	<append+34 @03d2aa>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @03d2af>   : 1c 80 00 00 00             load.c32 128
	<append+44 @03d2b4>   : 1f b9 96 01 00             load.ref <@0196b9> ;"radix is too small"
	<append+49 @03d2b9>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+54 @03d2be>   : 0a 18 00 00                load.sp(+24)
	<append+58 @03d2c2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:138: (53 bytes: <@03d2c6> - <@03d2fb>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @03d2c6>   : 10 00                      dup.x1 sp(0)
	<append+64 @03d2c8>   : 2a 84 d2 03                load.m32 <@03d284> ;append.radixDigits+4
	<append+68 @03d2cc>   : 58                         clt.i32
	<append+69 @03d2cd>   : 06 08 00 00                jz <append+77 @03d2d5>
	<append+73 @03d2d1>   : 04 2a 00 00                jmp <append+115 @03d2fb>
	<append+77 @03d2d5>   : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+82 @03d2da>   : 1c 8a 00 00 00             load.c32 138
	<append+87 @03d2df>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @03d2e4>   : 1c 80 00 00 00             load.c32 128
	<append+97 @03d2e9>   : 1f cc 96 01 00             load.ref <@0196cc> ;"radix is too big"
	<append+102 @03d2ee>  : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+107 @03d2f3>  : 0a 18 00 00                load.sp(+24)
	<append+111 @03d2f7>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:141: (46 bytes: <@03d2fb> - <@03d329>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @03d2fb>  : 04 26 00 00                jmp <append+153 @03d321>
	lib/std/string.ci:142: (27 bytes: <@03d2ff> - <@03d31a>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @03d2ff>  : 2a 80 d2 03                load.m32 <@03d280> ;append.radixDigits
	<append+123 @03d303>  : 10 19                      dup.x1 sp(25)
	<append+125 @03d305>  : 10 02                      dup.x1 sp(2)
	<append+127 @03d307>  : 35                         mod.u32
	<append+128 @03d308>  : 51                         add.i32
	<append+129 @03d309>  : 20                         load.i8
	<append+130 @03d30a>  : 0a 08 00 00                load.sp(+8)
	<append+134 @03d30e>  : 10 17                      dup.x1 sp(23)
	<append+136 @03d310>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @03d314>  : 10 00                      dup.x1 sp(0)
	<append+142 @03d316>  : 13 19                      set.x1 sp(25)
	<append+144 @03d318>  : 51                         add.i32
	<append+145 @03d319>  : 25                         store.i8
	lib/std/string.ci:141: (7 bytes: <@03d31a> - <@03d321>): uint32(value := uint32(value / (radix)))
	<append+146 @03d31a>  : 10 18                      dup.x1 sp(24)
	<append+148 @03d31c>  : 10 01                      dup.x1 sp(1)
	<append+150 @03d31e>  : 34                         div.u32
	<append+151 @03d31f>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:141: (8 bytes: <@03d321> - <@03d329>): bool(value > (0))
	<append+153 @03d321>  : 10 18                      dup.x1 sp(24)
	<append+155 @03d323>  : 19                         load.z32
	<append+156 @03d324>  : 39                         cgt.u32
	<append+157 @03d325>  : 05 da ff ff                jnz <append+119 @03d2ff>
	lib/std/string.ci:144: (29 bytes: <@03d329> - <@03d346>): if (bool(len == 0))
	<append+161 @03d329>  : 10 15                      dup.x1 sp(21)
	<append+163 @03d32b>  : 19                         load.z32
	<append+164 @03d32c>  : 57                         ceq.i32
	<append+165 @03d32d>  : 06 19 00 00                jz <append+190 @03d346>
	lib/std/string.ci:145: (21 bytes: <@03d331> - <@03d346>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @03d331>  : 1c 30 00 00 00             load.c32 48
	<append+174 @03d336>  : 0a 08 00 00                load.sp(+8)
	<append+178 @03d33a>  : 10 17                      dup.x1 sp(23)
	<append+180 @03d33c>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @03d340>  : 10 00                      dup.x1 sp(0)
	<append+186 @03d342>  : 13 19                      set.x1 sp(25)
	<append+188 @03d344>  : 51                         add.i32
	<append+189 @03d345>  : 25                         store.i8
	lib/std/string.ci:148: (10 bytes: <@03d346> - <@03d350>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @03d346>  : 10 17                      dup.x1 sp(23)
	<append+192 @03d348>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @03d34c>  : 22                         load.i32
	<append+197 @03d34d>  : 10 16                      dup.x1 sp(22)
	<append+199 @03d34f>  : 52                         sub.i32
	lib/std/string.ci:150: (7 bytes: <@03d350> - <@03d357>): padChr: char := format.padChr
	<append+200 @03d350>  : 10 18                      dup.x1 sp(24)
	<append+202 @03d352>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @03d356>  : 20                         load.i8
	lib/std/string.ci:151: (21 bytes: <@03d357> - <@03d36c>): if (bool(padChr == ''))
	<append+207 @03d357>  : 0a 00 00 00                load.sp(+0)
	<append+211 @03d35b>  : 20                         load.i8
	<append+212 @03d35c>  : 19                         load.z32
	<append+213 @03d35d>  : 57                         ceq.i32
	<append+214 @03d35e>  : 06 0e 00 00                jz <append+228 @03d36c>
	lib/std/string.ci:152: (10 bytes: <@03d362> - <@03d36c>): char(padChr := ' ');
	<append+218 @03d362>  : 1c 20 00 00 00             load.c32 32
	<append+223 @03d367>  : 0a 04 00 00                load.sp(+4)
	<append+227 @03d36b>  : 25                         store.i8
	lib/std/string.ci:156: (207 bytes: <@03d36c> - <@03d43b>): if (bool((sign) != 0))
	<append+228 @03d36c>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @03d370>  : 20                         load.i8
	<append+233 @03d371>  : 19                         load.z32
	<append+234 @03d372>  : 57                         ceq.i32
	<append+235 @03d373>  : 05 c8 00 00                jnz <append+435 @03d43b>
	lib/std/string.ci:157: (8 bytes: <@03d377> - <@03d37f>): int32(maxLen := int32(maxLen - 1));
	<append+239 @03d377>  : 10 01                      dup.x1 sp(1)
	<append+241 @03d379>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @03d37d>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:158: (117 bytes: <@03d37f> - <@03d3f4>): if (contains(void(whiteSpace, padChr)))
	<append+247 @03d37f>  : 19                         load.z32
	<append+248 @03d380>  : 2a 78 d2 03                load.m32 <@03d278> ;append.whiteSpace
	<append+252 @03d384>  : 0a 08 00 00                load.sp(+8)
	<append+256 @03d388>  : 20                         load.i8
	<append+257 @03d389>  : 1f 10 d0 03 00             load.ref <@03d010> ;indexOf(str: char[*], chr: char): int32
	<append+262 @03d38e>  : 02                         call
	<append+263 @03d38f>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @03d393>  : 19                         load.z32
	<append+268 @03d394>  : 58                         clt.i32
	<append+269 @03d395>  : 05 5f 00 00                jnz <append+364 @03d3f4>
	lib/std/string.ci:160: (91 bytes: <@03d399> - <@03d3f4>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @03d399>  : 04 53 00 00                jmp <append+356 @03d3ec>
	lib/std/string.ci:161: (52 bytes: <@03d39d> - <@03d3d1>): assert(bool(pos < (output.length)));
	<append+277 @03d39d>  : 10 1c                      dup.x1 sp(28)
	<append+279 @03d39f>  : 10 1f                      dup.x1 sp(31)
	<append+281 @03d3a1>  : 58                         clt.i32
	<append+282 @03d3a2>  : 06 08 00 00                jz <append+290 @03d3aa>
	<append+286 @03d3a6>  : 04 2b 00 00                jmp <append+329 @03d3d1>
	<append+290 @03d3aa>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+295 @03d3af>  : 1c a1 00 00 00             load.c32 161
	<append+300 @03d3b4>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @03d3b9>  : 1c 80 00 00 00             load.c32 128
	<append+310 @03d3be>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+315 @03d3c3>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+320 @03d3c8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @03d3cd>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (11 bytes: <@03d3d1> - <@03d3dc>): char(output[pos] := padChr);
	<append+329 @03d3d1>  : 0a 00 00 00                load.sp(+0)
	<append+333 @03d3d5>  : 20                         load.i8
	<append+334 @03d3d6>  : 10 1e                      dup.x1 sp(30)
	<append+336 @03d3d8>  : 10 1e                      dup.x1 sp(30)
	<append+338 @03d3da>  : 51                         add.i32
	<append+339 @03d3db>  : 25                         store.i8
	lib/std/string.ci:163: (8 bytes: <@03d3dc> - <@03d3e4>): int32(pos := int32(pos + 1));
	<append+340 @03d3dc>  : 10 1c                      dup.x1 sp(28)
	<append+342 @03d3de>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @03d3e2>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:160: (8 bytes: <@03d3e4> - <@03d3ec>): int32(maxLen := int32(maxLen - 1))
	<append+348 @03d3e4>  : 10 01                      dup.x1 sp(1)
	<append+350 @03d3e6>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @03d3ea>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:160: (8 bytes: <@03d3ec> - <@03d3f4>): bool(maxLen > 0)
	<append+356 @03d3ec>  : 10 01                      dup.x1 sp(1)
	<append+358 @03d3ee>  : 19                         load.z32
	<append+359 @03d3ef>  : 59                         cgt.i32
	<append+360 @03d3f0>  : 05 ad ff ff                jnz <append+277 @03d39d>
	lib/std/string.ci:166: (52 bytes: <@03d3f4> - <@03d428>): assert(bool(pos < (output.length)));
	<append+364 @03d3f4>  : 10 1c                      dup.x1 sp(28)
	<append+366 @03d3f6>  : 10 1f                      dup.x1 sp(31)
	<append+368 @03d3f8>  : 58                         clt.i32
	<append+369 @03d3f9>  : 06 08 00 00                jz <append+377 @03d401>
	<append+373 @03d3fd>  : 04 2b 00 00                jmp <append+416 @03d428>
	<append+377 @03d401>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+382 @03d406>  : 1c a6 00 00 00             load.c32 166
	<append+387 @03d40b>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @03d410>  : 1c 80 00 00 00             load.c32 128
	<append+397 @03d415>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+402 @03d41a>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+407 @03d41f>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @03d424>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:167: (11 bytes: <@03d428> - <@03d433>): char(output[pos] := sign);
	<append+416 @03d428>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @03d42c>  : 20                         load.i8
	<append+421 @03d42d>  : 10 1e                      dup.x1 sp(30)
	<append+423 @03d42f>  : 10 1e                      dup.x1 sp(30)
	<append+425 @03d431>  : 51                         add.i32
	<append+426 @03d432>  : 25                         store.i8
	lib/std/string.ci:168: (8 bytes: <@03d433> - <@03d43b>): int32(pos := int32(pos + 1));
	<append+427 @03d433>  : 10 1c                      dup.x1 sp(28)
	<append+429 @03d435>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @03d439>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (91 bytes: <@03d43b> - <@03d496>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @03d43b>  : 04 53 00 00                jmp <append+518 @03d48e>
	lib/std/string.ci:173: (52 bytes: <@03d43f> - <@03d473>): assert(bool(pos < (output.length)));
	<append+439 @03d43f>  : 10 1c                      dup.x1 sp(28)
	<append+441 @03d441>  : 10 1f                      dup.x1 sp(31)
	<append+443 @03d443>  : 58                         clt.i32
	<append+444 @03d444>  : 06 08 00 00                jz <append+452 @03d44c>
	<append+448 @03d448>  : 04 2b 00 00                jmp <append+491 @03d473>
	<append+452 @03d44c>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+457 @03d451>  : 1c ad 00 00 00             load.c32 173
	<append+462 @03d456>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @03d45b>  : 1c 80 00 00 00             load.c32 128
	<append+472 @03d460>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+477 @03d465>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+482 @03d46a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @03d46f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:174: (11 bytes: <@03d473> - <@03d47e>): char(output[pos] := padChr);
	<append+491 @03d473>  : 0a 00 00 00                load.sp(+0)
	<append+495 @03d477>  : 20                         load.i8
	<append+496 @03d478>  : 10 1e                      dup.x1 sp(30)
	<append+498 @03d47a>  : 10 1e                      dup.x1 sp(30)
	<append+500 @03d47c>  : 51                         add.i32
	<append+501 @03d47d>  : 25                         store.i8
	lib/std/string.ci:175: (8 bytes: <@03d47e> - <@03d486>): int32(pos := int32(pos + 1));
	<append+502 @03d47e>  : 10 1c                      dup.x1 sp(28)
	<append+504 @03d480>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @03d484>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (8 bytes: <@03d486> - <@03d48e>): int32(maxLen := int32(maxLen - 1))
	<append+510 @03d486>  : 10 01                      dup.x1 sp(1)
	<append+512 @03d488>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @03d48c>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (8 bytes: <@03d48e> - <@03d496>): bool(maxLen > 0)
	<append+518 @03d48e>  : 10 01                      dup.x1 sp(1)
	<append+520 @03d490>  : 19                         load.z32
	<append+521 @03d491>  : 59                         cgt.i32
	<append+522 @03d492>  : 05 ad ff ff                jnz <append+439 @03d43f>
	lib/std/string.ci:179: (99 bytes: <@03d496> - <@03d4f9>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @03d496>  : 19                         load.z32
	<append+527 @03d497>  : 04 55 00 00                jmp <append+612 @03d4ec>
	lib/std/string.ci:180: (52 bytes: <@03d49b> - <@03d4cf>): assert(bool(i < (output.length)));
	<append+531 @03d49b>  : 10 00                      dup.x1 sp(0)
	<append+533 @03d49d>  : 10 20                      dup.x1 sp(32)
	<append+535 @03d49f>  : 58                         clt.i32
	<append+536 @03d4a0>  : 06 08 00 00                jz <append+544 @03d4a8>
	<append+540 @03d4a4>  : 04 2b 00 00                jmp <append+583 @03d4cf>
	<append+544 @03d4a8>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+549 @03d4ad>  : 1c b4 00 00 00             load.c32 180
	<append+554 @03d4b2>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @03d4b7>  : 1c 80 00 00 00             load.c32 128
	<append+564 @03d4bc>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+569 @03d4c1>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+574 @03d4c6>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @03d4cb>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (17 bytes: <@03d4cf> - <@03d4e0>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @03d4cf>  : 0a 10 00 00                load.sp(+16)
	<append+587 @03d4d3>  : 10 19                      dup.x1 sp(25)
	<append+589 @03d4d5>  : 10 02                      dup.x1 sp(2)
	<append+591 @03d4d7>  : 52                         sub.i32
	<append+592 @03d4d8>  : 51                         add.i32
	<append+593 @03d4d9>  : 20                         load.i8
	<append+594 @03d4da>  : 10 1f                      dup.x1 sp(31)
	<append+596 @03d4dc>  : 10 1f                      dup.x1 sp(31)
	<append+598 @03d4de>  : 51                         add.i32
	<append+599 @03d4df>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@03d4e0> - <@03d4e8>): int32(pos := int32(pos + 1));
	<append+600 @03d4e0>  : 10 1d                      dup.x1 sp(29)
	<append+602 @03d4e2>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @03d4e6>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:179: (4 bytes: <@03d4e8> - <@03d4ec>): int32(i := int32(i + 1))
	<append+608 @03d4e8>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:179: (9 bytes: <@03d4ec> - <@03d4f5>): bool(i < len)
	<append+612 @03d4ec>  : 10 00                      dup.x1 sp(0)
	<append+614 @03d4ee>  : 10 19                      dup.x1 sp(25)
	<append+616 @03d4f0>  : 58                         clt.i32
	<append+617 @03d4f1>  : 05 aa ff ff                jnz <append+531 @03d49b>
	<append+621 @03d4f5>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:185: (17 bytes: <@03d4f9> - <@03d50a>): if (bool(pos >= (output.length)))
	<append+625 @03d4f9>  : 10 1c                      dup.x1 sp(28)
	<append+627 @03d4fb>  : 10 1f                      dup.x1 sp(31)
	<append+629 @03d4fd>  : 58                         clt.i32
	<append+630 @03d4fe>  : 05 0c 00 00                jnz <append+642 @03d50a>
	lib/std/string.ci:186: (8 bytes: <@03d502> - <@03d50a>): int32(pos := (uint32(output.length - (1))));
	<append+634 @03d502>  : 10 1e                      dup.x1 sp(30)
	<append+636 @03d504>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @03d508>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:188: (7 bytes: <@03d50a> - <@03d511>): char(output[pos] := (0));
	<append+642 @03d50a>  : 19                         load.z32
	<append+643 @03d50b>  : 10 1e                      dup.x1 sp(30)
	<append+645 @03d50d>  : 10 1e                      dup.x1 sp(30)
	<append+647 @03d50f>  : 51                         add.i32
	<append+648 @03d510>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@03d511> - <@03d519>): return int32(.result := pos);
	<append+649 @03d511>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @03d514>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @03d518>  : 03                         ret
	<append+657 @03d519>  : 09 a0 ff ff                inc.sp(-96)
	<append+661 @03d51d>  : 03                         ret
.references:
	lib/std/string.ci:202: referenced as `append`
	lib/std/string.ci:193: referenced as `append`
	lib/std/string.ci:129: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@03d520>
.name: 'append'
.file: 'lib/std/string.ci:192'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@03d520> - <@03d537>)
	lib/std/string.ci:193: (23 bytes: <@03d520> - <@03d537>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @03d520>      : 19                         load.z32
	<append+1 @03d521>    : 11 05                      dup.x2 sp(5)
	<append+3 @03d523>    : 10 06                      dup.x1 sp(6)
	<append+5 @03d525>    : 19                         load.z32
	<append+6 @03d526>    : 10 07                      dup.x1 sp(7)
	<append+8 @03d528>    : 10 07                      dup.x1 sp(7)
	<append+10 @03d52a>   : 1f 88 d2 03 00             load.ref <@03d288> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @03d52f>   : 02                         call
	<append+16 @03d530>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @03d534>   : 13 07                      set.x1 sp(7)
	<append+22 @03d536>   : 03                         ret
.references:
	lib/std/string.ci:207: referenced as `append`
	lib/std/string.ci:192: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@03d538>
.name: 'append'
.file: 'lib/std/string.ci:196'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (54 bytes: <@03d538> - <@03d56e>)
	lib/std/string.ci:197: (1 byte: <@03d538> - <@03d539>): sign: int32 := 0
	<append @03d538>      : 19                         load.z32
	lib/std/string.ci:198: (20 bytes: <@03d539> - <@03d54d>): if (bool(value < 0))
	<append+1 @03d539>    : 10 03                      dup.x1 sp(3)
	<append+3 @03d53b>    : 19                         load.z32
	<append+4 @03d53c>    : 58                         clt.i32
	<append+5 @03d53d>    : 06 10 00 00                jz <append+21 @03d54d>
	lib/std/string.ci:199: (7 bytes: <@03d541> - <@03d548>): int32(sign := ('-'));
	<append+9 @03d541>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @03d546>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:200: (5 bytes: <@03d548> - <@03d54d>): int32(value := int32(-value));
	<append+16 @03d548>   : 10 03                      dup.x1 sp(3)
	<append+18 @03d54a>   : 50                         neg.i32
	<append+19 @03d54b>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:202: (28 bytes: <@03d54d> - <@03d569>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @03d54d>   : 19                         load.z32
	<append+22 @03d54e>   : 11 06                      dup.x2 sp(6)
	<append+24 @03d550>   : 10 07                      dup.x1 sp(7)
	<append+26 @03d552>   : 10 04                      dup.x1 sp(4)
	<append+28 @03d554>   : 10 08                      dup.x1 sp(8)
	<append+30 @03d556>   : 10 08                      dup.x1 sp(8)
	<append+32 @03d558>   : 1f 88 d2 03 00             load.ref <@03d288> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @03d55d>   : 02                         call
	<append+38 @03d55e>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @03d562>   : 13 08                      set.x1 sp(8)
	<append+44 @03d564>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @03d568>   : 03                         ret
	<append+49 @03d569>   : 09 fc ff ff                inc.sp(-4)
	<append+53 @03d56d>   : 03                         ret
.references:
	lib/std/string.ci:196: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@03d580>
.name: 'append'
.file: 'lib/std/string.ci:205'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@03d580> - <@03d599>)
	lib/std/string.ci:207: (25 bytes: <@03d580> - <@03d599>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @03d580>      : 19                         load.z32
	<append+1 @03d581>    : 11 04                      dup.x2 sp(4)
	<append+3 @03d583>    : 10 05                      dup.x1 sp(5)
	<append+5 @03d585>    : 10 05                      dup.x1 sp(5)
	<append+7 @03d587>    : 1f 70 d5 03 00             load.ref <@03d570> ;append.format
	<append+12 @03d58c>   : 1f 20 d5 03 00             load.ref <@03d520> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @03d591>   : 02                         call
	<append+18 @03d592>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @03d596>   : 13 06                      set.x1 sp(6)
	<append+24 @03d598>   : 03                         ret
.references:
	lib/std/string.ci:205: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.references:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.references:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.references:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.references:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.references:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.references:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.references:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
emitNfcF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'emitNfcF32'
.file: 'test/lang/emit.ci:11'
.value: emit(void(float32(float64(3.140000 / (2))), float32.sin))
.references:
	test/lang/emit.ci:11: defined as `emitNfcF32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.references:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.references:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+36>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+44>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+48>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+56>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+64>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.references:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.references:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.references:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.references:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.references:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.references:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.references:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.references:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.references:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.references:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.references:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.references:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.references:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.references:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.references:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.references:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.references:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.references:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.references:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+248>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.references:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.references:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.references:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.references:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.references:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.references:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.references:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.references:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.references:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+268>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.references:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@023a10>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.references:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@023b20>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.references:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.references:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+276>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.references:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+284>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.references:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@03d5a0>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.references:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+288>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.references:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+292>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.references:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+300>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.references:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+308>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.references:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.references:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.references:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+320>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.references:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+324>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.references:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+332>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.references:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+336>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.references:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+340>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.references:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+344>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.references:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+348>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.references:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+356>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.references:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+360>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.references:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+368>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.references:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+376>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.references:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+380>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.references:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+384>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.references:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+392>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.references:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+396>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.references:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.references:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.references:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.references:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.references:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.references:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.references:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.references:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.references:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.references:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.references:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.references:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.references:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.references:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.references:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.references:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.references:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.references:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+468>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.references:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+476>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.references:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+484>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.references:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+492>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.references:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+500>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.references:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+508>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.references:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+516>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.references:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+524>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.references:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+532>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.references:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+540>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.references:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+548>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.references:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+556>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.references:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+564>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.references:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+572>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.references:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+580>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.references:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+588>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.references:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+596>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.references:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+604>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.references:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+612>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.references:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.references:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.references:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.references:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.references:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.references:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.references:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.references:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.references:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.references:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.references:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.references:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.references:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.references:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.references:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.references:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.references:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.references:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+684>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.references:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+688>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.references:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+696>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.references:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.references:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+704>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.references:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+712>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.references:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+716>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.references:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@03d5a8>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@03d5a8> - <@03d5a9>)
	<empty @03d5a8>      : 03                         ret
.references:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d5b0>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@03d5b0> - <@03d5b8>)
	test/lang/function.ci:7: (8 bytes: <@03d5b0> - <@03d5b8>): return int32(.result := int32(x + y));
	<funAdd @03d5b0>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @03d5b2>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @03d5b4>    : 51                         add.i32
	<funAdd+5 @03d5b5>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @03d5b7>    : 03                         ret
.references:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+720>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.references:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+724>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.references:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+728>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.references:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+732>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+736>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.references:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+740>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+744>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.references:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d5b8>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d5b8> - <@03d5c0>)
	test/lang/function.ci:33: (8 bytes: <@03d5b8> - <@03d5c0>): return int32(.result := int32(x * y));
	<funMul @03d5b8>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @03d5ba>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @03d5bc>    : 53                         mul.i32
	<funMul+5 @03d5bd>    : 13 04                      set.x1 sp(4)
	<funMul+7 @03d5bf>    : 03                         ret
.references:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@03d5c0>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@03d5c0> - <@03d5f6>)
	test/lang/function.ci:38: (16 bytes: <@03d5c0> - <@03d5d0>): if (bool(n <= (1)))
	<fib @03d5c0>      : 10 01                      dup.x1 sp(1)
	<fib+2 @03d5c2>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @03d5c7>    : 39                         cgt.u32
	<fib+8 @03d5c8>    : 05 08 00 00                jnz <fib+16 @03d5d0>
	test/lang/function.ci:39: (4 bytes: <@03d5cc> - <@03d5d0>): return uint32(.result := n);
	<fib+12 @03d5cc>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @03d5cf>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@03d5d0> - <@03d5f6>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @03d5d0>   : 19                         load.z32
	<fib+17 @03d5d1>   : 10 02                      dup.x1 sp(2)
	<fib+19 @03d5d3>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @03d5d7>   : 1f c0 d5 03 00             load.ref <@03d5c0> ;fib(n: uint32): uint32
	<fib+28 @03d5dc>   : 02                         call
	<fib+29 @03d5dd>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @03d5e1>   : 19                         load.z32
	<fib+34 @03d5e2>   : 10 03                      dup.x1 sp(3)
	<fib+36 @03d5e4>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @03d5e8>   : 1f c0 d5 03 00             load.ref <@03d5c0> ;fib(n: uint32): uint32
	<fib+45 @03d5ed>   : 02                         call
	<fib+46 @03d5ee>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @03d5f2>   : 51                         add.i32
	<fib+51 @03d5f3>   : 13 03                      set.x1 sp(3)
	<fib+53 @03d5f5>   : 03                         ret
.references:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+748>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.references:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.references:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.references:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.references:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.references:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.references:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.references:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.references:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.references:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.references:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.references:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.references:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.references:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.references:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.references:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.references:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.references:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.references:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+820>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.references:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@028ee0>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.references:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.references:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@028ff0>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.references:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+824>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.references:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+828>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.references:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.references:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+836>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.references:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+840>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.references:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+844>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.references:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+848>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.references:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+852>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.references:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.references:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+860>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.references:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+864>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.references:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+868>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.references:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+872>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.references:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.references:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+880>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.references:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+884>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.references:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.references:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+892>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.references:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+900>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.references:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+908>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.references:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.references:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+916>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.references:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.references:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.references:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.references:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.references:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.references:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+984>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:35: defined as `sxtB8`
}
sinF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+992>
.name: 'sinF64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:37: defined as `sinF64`
}
cosF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1000>
.name: 'cosF64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:38: defined as `cosF64`
}
tanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1008>
.name: 'tanF64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.references:
	test/stdc/number.ci:39: defined as `tanF64`
}
logF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1016>
.name: 'logF64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.references:
	test/stdc/number.ci:40: defined as `logF64`
}
expF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1024>
.name: 'expF64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.references:
	test/stdc/number.ci:41: defined as `expF64`
}
powF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1032>
.name: 'powF64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.references:
	test/stdc/number.ci:42: defined as `powF64`
}
sqrtF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1040>
.name: 'sqrtF64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.references:
	test/stdc/number.ci:43: defined as `sqrtF64`
}
atanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1048>
.name: 'atanF64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.references:
	test/stdc/number.ci:44: defined as `atanF64`
}
sinF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'sinF32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:46: defined as `sinF32`
}
cosF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'cosF32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:47: defined as `cosF32`
}
tanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'tanF32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.references:
	test/stdc/number.ci:48: defined as `tanF32`
}
logF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'logF32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.references:
	test/stdc/number.ci:49: defined as `logF32`
}
expF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'expF32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.references:
	test/stdc/number.ci:50: defined as `expF32`
}
powF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'powF32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.references:
	test/stdc/number.ci:51: defined as `powF32`
}
sqrtF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'sqrtF32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.references:
	test/stdc/number.ci:52: defined as `sqrtF32`
}
atanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1080>
.name: 'atanF32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.references:
	test/stdc/number.ci:53: defined as `atanF32`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.references:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.references:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.references:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1084>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.references:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1088>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.references:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1092>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.references:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1096>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.references:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1104>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.references:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1112>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.references:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@03d5f8>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@03d5f8> - <@03d5f9>)
	<noError @03d5f8>      : 03                         ret
.references:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@03d600>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@03d600> - <@03d618>)
	test/stdc/tryExec.ci:15: (4 bytes: <@03d600> - <@03d604>): data: uint8[8192]
	<stackOverflow @03d600>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@03d604> - <@03d613>): stackOverflow(ptr);
	<stackOverflow+4 @03d604>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @03d608>    : 22                         load.i32
	<stackOverflow+9 @03d609>    : 1f 00 d6 03 00             load.ref <@03d600> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @03d60e>   : 02                         call
	<stackOverflow+15 @03d60f>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @03d613>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @03d617>   : 03                         ret
.references:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d618>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@03d618> - <@03d624>)
	test/stdc/tryExec.ci:20: (7 bytes: <@03d618> - <@03d61f>): value: int32 := int32(3 / 0)
	<divisionByZero @03d618>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @03d61d>    : 19                         load.z32
	<divisionByZero+6 @03d61e>    : 54                         div.i32
	<divisionByZero+7 @03d61f>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @03d623>   : 03                         ret
.references:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@03d628>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@03d628> - <@03d66c>)
	test/stdc/tryExec.ci:29: (25 bytes: <@03d628> - <@03d641>): details: NotEquals := {...}
	<abortExecution @03d628>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@03d62c> - <@03d633>): void(details.message := ("assertion failed"));
	<abortExecution+4 @03d62c>    : 1f 29 b6 00 00             load.ref <@00b629> ;"assertion failed"
	<abortExecution+9 @03d631>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@03d633> - <@03d63a>): void(details.expected := 97);
	<abortExecution+11 @03d633>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @03d638>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@03d63a> - <@03d641>): void(details.returned := 77);
	<abortExecution+18 @03d63a>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @03d63f>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@03d641> - <@03d667>): abort(void("fatal error", details));
	<abortExecution+25 @03d641>   : 1f 78 bf 02 00             load.ref <@02bf78> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @03d646>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @03d64b>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @03d650>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @03d655>   : 1f c1 bf 02 00             load.ref <@02bfc1> ;"fatal error"
	<abortExecution+50 @03d65a>   : 1f d8 c8 02 00             load.ref <@02c8d8> ;abortExecution.NotEquals
	<abortExecution+55 @03d65f>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @03d663>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @03d667>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @03d66b>   : 03                         ret
.references:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@03d670>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@03d670> - <@03d67d>)
	test/stdc/tryExec.ci:38: (5 bytes: <@03d670> - <@03d675>): i32Ref: int32 := null
	<invalidMemoryAccess @03d670>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@03d675> - <@03d678>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @03d675>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @03d677>    : 22                         load.i32
	<invalidMemoryAccess+8 @03d678>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @03d67c>   : 03                         ret
.references:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@03d680>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@03d680> - <@03d682>)
	test/stdc/tryExec.ci:43: (2 bytes: <@03d680> - <@03d682>): emit(void(load.z32, ret));
	<invalidInstruction @03d680>      : 19                         load.z32
	<invalidInstruction+1 @03d681>    : 03                         ret
.references:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.references:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1120>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.references:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1124>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.references:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1128>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.references:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1132>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.references:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1136>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.references:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1140>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.references:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1196>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.references:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1200>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.references:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1208>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.references:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1212>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.references:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1220>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.references:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1224>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1232>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.references:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1256>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.references:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1260>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.references:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1268>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.references:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@03d688>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@03d688> - <@03d68c>)
	test/lang/array.ci:103: (4 bytes: <@03d688> - <@03d68c>): return uint32(.result := values.length);
	<lenSlice @03d688>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @03d68b>    : 03                         ret
.references:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d690>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@03d690> - <@03d69c>)
	test/lang/array.ci:104: (12 bytes: <@03d690> - <@03d69c>): return int64(.result := values[idx]);
	<nthFixed @03d690>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @03d692>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @03d694>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @03d698>    : 23                         load.i64
	<nthFixed+9 @03d699>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @03d69b>   : 03                         ret
.references:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d6a0>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@03d6a0> - <@03d6ac>)
	test/lang/array.ci:105: (12 bytes: <@03d6a0> - <@03d6ac>): return int64(.result := values[idx]);
	<nthArray @03d6a0>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @03d6a2>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @03d6a4>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @03d6a8>    : 23                         load.i64
	<nthArray+9 @03d6a9>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @03d6ab>   : 03                         ret
.references:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d6b0>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@03d6b0> - <@03d6bc>)
	test/lang/array.ci:106: (12 bytes: <@03d6b0> - <@03d6bc>): return int64(.result := values[idx]);
	<nthSlice @03d6b0>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @03d6b2>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @03d6b4>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @03d6b8>    : 23                         load.i64
	<nthSlice+9 @03d6b9>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @03d6bb>   : 03                         ret
.references:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@02f190>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@02f218>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@03d6c0>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@03d6c8>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@03d6d0>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@03d6d8>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@03d6e0>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@03d6e8>, cast: static const variable(val))
.references:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02f218>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.references:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.references:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@03d6c0>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@03d6c8>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 5
.references:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@03d6d0>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 6
.references:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@03d6d8>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@03d6e0>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 51);
	void(globalRecInit.constant := 52);
}
.references:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@03d6e8>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 61);
	void(globalConstantRec.constant := 62);
}
.references:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1300>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 6);
	void(recordMemberTest.constant := 7);
	void(recordMemberTest.memberInit := 8);
	void(recordMemberTest.constantInit := 9);
	void(recordMemberTest.memberRec.member := 61);
	void(recordMemberTest.memberRec.constant := 62);
	void(recordMemberTest.constantRec.member := 71);
	void(recordMemberTest.constantRec.constant := 72);
}
.references:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02fb88>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 8, offs: <@03d6f0>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@03d6f8>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 8, offs: <@03d700>, cast: static const function)
.field forwardMethod: function (size: 8, offs: <@03d708>, cast: static const function)
.field print: function (size: 4, offs: <+12>, cast: const variable(ref))
.field print: function (size: 40, offs: <@03d710>, cast: static const function)
.field printStatic: function (size: 40, offs: <@03d738>, cast: static const function)
.references:
	test/lang/method.ci:91: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:89: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:75: referenced as `RecordMethodTest`
	test/lang/method.ci:63: referenced as `RecordMethodTest`
	test/lang/method.ci:59: referenced as `RecordMethodTest`
	test/lang/method.ci:55: referenced as `RecordMethodTest`
	test/lang/method.ci:53: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d6f0>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@03d6f0> - <@03d6f8>)
	test/lang/method.ci:7: (8 bytes: <@03d6f0> - <@03d6f8>): return int32(.result := int32(x + y));
	<staticMethod @03d6f0>      : 10 02                      dup.x1 sp(2)
	<staticMethod+2 @03d6f2>    : 10 02                      dup.x1 sp(2)
	<staticMethod+4 @03d6f4>    : 51                         add.i32
	<staticMethod+5 @03d6f5>    : 13 04                      set.x1 sp(4)
	<staticMethod+7 @03d6f7>    : 03                         ret
.references:
	test/lang/method.ci:55: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(x: int32, y: int32): int32`
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@03d6f8>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:12'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:20: referenced as `forwardMethod`
	test/lang/method.ci:12: defined as `forwardMethod(x: int32, y: int32): int32`
}
RecordMethodTest.abstractMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:16'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:55: referenced as `abstractMethod`
	test/lang/method.ci:16: defined as `abstractMethod(x: int32, y: int32): int32`
}
RecordMethodTest.delegateMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:20'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:54: referenced as `delegateMethod`
	test/lang/method.ci:20: defined as `delegateMethod(x: int32, y: int32): int32`
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: virtualMethod
.references:
	test/lang/method.ci:26: defined as `virtualMethod(x: int32, y: int32): int32`
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d700>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d700> - <@03d708>)
	test/lang/method.ci:27: (8 bytes: <@03d700> - <@03d708>): return int32(.result := int32(x * y));
	<virtualMethod @03d700>      : 10 02                      dup.x1 sp(2)
	<virtualMethod+2 @03d702>    : 10 02                      dup.x1 sp(2)
	<virtualMethod+4 @03d704>    : 53                         mul.i32
	<virtualMethod+5 @03d705>    : 13 04                      set.x1 sp(4)
	<virtualMethod+7 @03d707>    : 03                         ret
.references:
	test/lang/method.ci:26: defined as `virtualMethod(x: int32, y: int32): int32`
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d708>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:31'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d708> - <@03d710>)
	test/lang/method.ci:32: (8 bytes: <@03d708> - <@03d710>): return int32(.result := int32(x * y));
	<forwardMethod @03d708>      : 10 02                      dup.x1 sp(2)
	<forwardMethod+2 @03d70a>    : 10 02                      dup.x1 sp(2)
	<forwardMethod+4 @03d70c>    : 53                         mul.i32
	<forwardMethod+5 @03d70d>    : 13 04                      set.x1 sp(4)
	<forwardMethod+7 @03d70f>    : 03                         ret
.references:
	test/lang/method.ci:31: defined as `forwardMethod(x: int32, y: int32): int32`
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+12>
.name: 'print'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: print
.references:
	test/lang/method.ci:70: referenced as `print`
	test/lang/method.ci:69: referenced as `print`
	test/lang/method.ci:65: referenced as `print`
	test/lang/method.ci:40: defined as `print(this: RecordMethodTest): void`
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d710>
.name: 'print'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("virtual");
}
.instructions: (40 bytes: <@03d710> - <@03d738>)
	test/lang/method.ci:41: (39 bytes: <@03d710> - <@03d737>): trace("virtual");
	<print @03d710>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<print+5 @03d715>    : 1c 29 00 00 00             load.c32 41
	<print+10 @03d71a>   : 1c 0e 00 00 00             load.c32 14
	<print+15 @03d71f>   : 1c 80 00 00 00             load.c32 128
	<print+20 @03d724>   : 1f 0f fb 02 00             load.ref <@02fb0f> ;"virtual"
	<print+25 @03d729>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<print+30 @03d72e>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<print+35 @03d733>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+39 @03d737>   : 03                         ret
.references:
	test/lang/method.ci:91: referenced as `print`
	test/lang/method.ci:89: referenced as `print`
	test/lang/method.ci:40: defined as `print(this: RecordMethodTest): void`
}
RecordMethodTest.printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d738>
.name: 'printStatic'
.file: 'test/lang/method.ci:44'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("static");
}
.instructions: (40 bytes: <@03d738> - <@03d760>)
	test/lang/method.ci:45: (39 bytes: <@03d738> - <@03d75f>): trace("static");
	<printStatic @03d738>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<printStatic+5 @03d73d>    : 1c 2d 00 00 00             load.c32 45
	<printStatic+10 @03d742>   : 1c 0e 00 00 00             load.c32 14
	<printStatic+15 @03d747>   : 1c 80 00 00 00             load.c32 128
	<printStatic+20 @03d74c>   : 1f 23 fb 02 00             load.ref <@02fb23> ;"static"
	<printStatic+25 @03d751>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<printStatic+30 @03d756>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<printStatic+35 @03d75b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+39 @03d75f>   : 03                         ret
.references:
	test/lang/method.ci:90: referenced as `printStatic`
	test/lang/method.ci:73: referenced as `printStatic`
	test/lang/method.ci:44: defined as `printStatic(this: RecordMethodTest): void`
}
globalFunction(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d760>
.name: 'globalFunction'
.file: 'test/lang/method.ci:49'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d760> - <@03d768>)
	test/lang/method.ci:50: (8 bytes: <@03d760> - <@03d768>): return int32(.result := int32(x * y));
	<globalFunction @03d760>      : 10 02                      dup.x1 sp(2)
	<globalFunction+2 @03d762>    : 10 02                      dup.x1 sp(2)
	<globalFunction+4 @03d764>    : 53                         mul.i32
	<globalFunction+5 @03d765>    : 13 04                      set.x1 sp(4)
	<globalFunction+7 @03d767>    : 03                         ret
.references:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:54: referenced as `globalFunction`
	test/lang/method.ci:49: defined as `globalFunction(x: int32, y: int32): int32`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1316>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:53'
.value: {
	void(recordMethodTest.delegateMethod := globalFunction);
	void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
	void(recordMethodTest.print := print);
}
.references:
	test/lang/method.ci:90: referenced as `recordMethodTest`
	test/lang/method.ci:89: referenced as `recordMethodTest`
	test/lang/method.ci:85: referenced as `recordMethodTest`
	test/lang/method.ci:84: referenced as `recordMethodTest`
	test/lang/method.ci:73: referenced as `recordMethodTest`
	test/lang/method.ci:69: referenced as `recordMethodTest`
	test/lang/method.ci:53: defined as `recordMethodTest`
}
customPrint(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d768>
.name: 'customPrint'
.file: 'test/lang/method.ci:59'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("override");
}
.instructions: (40 bytes: <@03d768> - <@03d790>)
	test/lang/method.ci:60: (39 bytes: <@03d768> - <@03d78f>): trace("override");
	<customPrint @03d768>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<customPrint+5 @03d76d>    : 1c 3c 00 00 00             load.c32 60
	<customPrint+10 @03d772>   : 1c 0e 00 00 00             load.c32 14
	<customPrint+15 @03d777>   : 1c 80 00 00 00             load.c32 128
	<customPrint+20 @03d77c>   : 1f 56 fb 02 00             load.ref <@02fb56> ;"override"
	<customPrint+25 @03d781>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<customPrint+30 @03d786>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<customPrint+35 @03d78b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<customPrint+39 @03d78f>   : 03                         ret
.references:
	test/lang/method.ci:65: referenced as `customPrint`
	test/lang/method.ci:59: defined as `customPrint(this: RecordMethodTest): void`
}
recordMethodTestCustomPrint: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1332>
.name: 'recordMethodTestCustomPrint'
.file: 'test/lang/method.ci:63'
.value: {
	void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
	void(recordMethodTestCustomPrint.print := customPrint);
	void(recordMethodTestCustomPrint.delegateMethod := forwardMethod);
	void(recordMethodTestCustomPrint.virtualMethod := virtualMethod);
}
.references:
	test/lang/method.ci:91: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:86: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:70: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:63: defined as `recordMethodTestCustomPrint`
}
print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d790>
.name: 'print'
.file: 'test/lang/method.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes: <@03d790> - <@03d7b8>)
	test/lang/method.ci:76: (39 bytes: <@03d790> - <@03d7b7>): trace("extension");
	<print @03d790>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<print+5 @03d795>    : 1c 4c 00 00 00             load.c32 76
	<print+10 @03d79a>   : 1c 0e 00 00 00             load.c32 14
	<print+15 @03d79f>   : 1c 80 00 00 00             load.c32 128
	<print+20 @03d7a4>   : 1f 7b fb 02 00             load.ref <@02fb7b> ;"extension"
	<print+25 @03d7a9>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<print+30 @03d7ae>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<print+35 @03d7b3>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+39 @03d7b7>   : 03                         ret
.references:
	test/lang/method.ci:86: referenced as `print`
	test/lang/method.ci:84: referenced as `print`
	test/lang/method.ci:75: defined as `print(this: RecordMethodTest): void`
}
printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d7b8>
.name: 'printStatic'
.file: 'test/lang/method.ci:79'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes: <@03d7b8> - <@03d7e0>)
	test/lang/method.ci:80: (39 bytes: <@03d7b8> - <@03d7df>): trace("extension");
	<printStatic @03d7b8>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<printStatic+5 @03d7bd>    : 1c 50 00 00 00             load.c32 80
	<printStatic+10 @03d7c2>   : 1c 0e 00 00 00             load.c32 14
	<printStatic+15 @03d7c7>   : 1c 80 00 00 00             load.c32 128
	<printStatic+20 @03d7cc>   : 1f 7b fb 02 00             load.ref <@02fb7b> ;"extension"
	<printStatic+25 @03d7d1>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<printStatic+30 @03d7d6>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<printStatic+35 @03d7db>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+39 @03d7df>   : 03                         ret
.references:
	test/lang/method.ci:85: referenced as `printStatic`
	test/lang/method.ci:79: defined as `printStatic(this: RecordMethodTest): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@031560>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.references:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@031780>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.references:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@0319a0>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.references:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.references:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.references:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@031b38>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.references:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.references:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1336>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.references:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1340>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.references:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1344>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.references:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1348>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.references:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1352>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.references:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031f68>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@032320>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0326d8>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@032a90>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@032e48>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@033200>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.references:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.references:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1356>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.references:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1360>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.references:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1364>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.references:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1368>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.references:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1372>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.references:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1376>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.references:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.references:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.references:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.references:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.references:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.references:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.references:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.references:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1408>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.references:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1412>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.references:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1416>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.references:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1420>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.references:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1424>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.references:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.references:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.references:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.references:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.references:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.references:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.references:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.references:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.references:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.references:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.references:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1468>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.references:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1472>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.references:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1476>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.references:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1480>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.references:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1484>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.references:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.references:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.references:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1496>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.references:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1500>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.references:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1504>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.references:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1508>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.references:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1512>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.references:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.references:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.references:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.references:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.references:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.references:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.references:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.references:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.references:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.references:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.references:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1556>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.references:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1560>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.references:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1564>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.references:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1568>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.references:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1572>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.references:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.references:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.references:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1584>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.references:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1588>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.references:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1592>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.references:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1596>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.references:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1600>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.references:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.references:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.references:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.references:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.references:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.references:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.references:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.references:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.references:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.references:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.references:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1644>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.references:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1648>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.references:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1652>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.references:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1656>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.references:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1660>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.references:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.references:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.references:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1672>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.references:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1676>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.references:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1680>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.references:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1684>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.references:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1688>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.references:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.references:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.references:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.references:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.references:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.references:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.references:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.references:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.references:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.references:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.references:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1732>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.references:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1736>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.references:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1740>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.references:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1744>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.references:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1748>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.references:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.references:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.references:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1760>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.references:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1764>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.references:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1768>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.references:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1772>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.references:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1776>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.references:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.references:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.references:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.references:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.references:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.references:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.references:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.references:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.references:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.references:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.references:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1820>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.references:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1824>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.references:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1828>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.references:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1832>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.references:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1836>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.references:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.references:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.references:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1848>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.references:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1852>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.references:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1856>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.references:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1860>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.references:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1864>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.references:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.references:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.references:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.references:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.references:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.references:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.references:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.references:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.references:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.references:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.references:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1908>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.references:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1912>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.references:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1916>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.references:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1920>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.references:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1924>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.references:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.references:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.references:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1936>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.references:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1940>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.references:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1944>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.references:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1948>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.references:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1952>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.references:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.references:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.references:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.references:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.references:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.references:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.references:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.references:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.references:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.references:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.references:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1996>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.references:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2000>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.references:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2004>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.references:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2008>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.references:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2012>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.references:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.references:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.references:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2028>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.references:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2036>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.references:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2044>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.references:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2052>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.references:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2060>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.references:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2068>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.references:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2076>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.references:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2084>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.references:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2092>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.references:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2100>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.references:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2108>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.references:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2116>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.references:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2124>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.references:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2132>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.references:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2140>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.references:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2144>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.references:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2148>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.references:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2152>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.references:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2156>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.references:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2160>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.references:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.references:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.references:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2176>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.references:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2184>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.references:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2192>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.references:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2200>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.references:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2208>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.references:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2216>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.references:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2224>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.references:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2232>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.references:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2240>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.references:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2248>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.references:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2256>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.references:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2264>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.references:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2272>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.references:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2280>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.references:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2288>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.references:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2292>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.references:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2296>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.references:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2300>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.references:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2304>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.references:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2308>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.references:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.references:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.references:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2320>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.references:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2324>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.references:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2328>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.references:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2332>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.references:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2336>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.references:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.references:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.references:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.references:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.references:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2356>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.references:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2360>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.references:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2364>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.references:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2368>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.references:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2372>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.references:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.references:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.references:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2388>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.references:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2396>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.references:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2404>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.references:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2412>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.references:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2420>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.references:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2428>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.references:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2436>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.references:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2444>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.references:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2452>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.references:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2456>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.references:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2460>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.references:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2464>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.references:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2468>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.references:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2472>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.references:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.references:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.references:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2484>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.references:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2488>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.references:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.references:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.references:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2500>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.references:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2504>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.references:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
.main: function {
.kind: static function
.base: `function`
.size: 8555
.offset: <@03d7e0>
.name: '.main'
.print: '.main'
.field typename: typename (size: 136, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000a0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000130>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001c0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000250>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@0002e0>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000370>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000400>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000490>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@000520>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0005b0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000640>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0006d0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000760>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0007f0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000880>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000910>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@0009a8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000eb8>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000f48>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@0052b0>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0061f0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0069f0>, cast: static const inline)
.field System: void (size: 0, offs: <@007538>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 24, offs: <@00e058>, cast: static const typename(val))
.field assertEq: function (size: 82, offs: <@03c6d8>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@00ebc0>, cast: static const typename(val))
.field Complex: typename (size: 16, offs: <@014c58>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@03ceb8>, cast: static const function)
.field Complex: function (size: 7, offs: <@03cec0>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 128, offs: <@03cec8>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 36, offs: <@03cf48>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 105, offs: <@03cf70>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 43, offs: <@03cfe0>, cast: static const function)
.field indexOf: function (size: 50, offs: <@03d010>, cast: static const function)
.field lastIndexOf: function (size: 55, offs: <@03d048>, cast: static const function)
.field startsWith: function (size: 73, offs: <@03d080>, cast: static const function)
.field endsWith: function (size: 131, offs: <@03d0d0>, cast: static const function)
.field compare: function (size: 68, offs: <@03d158>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@03d1e8>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@03d210>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@01c5a8>, cast: static const typename(val))
.field append: function (size: 84, offs: <@03d220>, cast: static const function)
.field append: function (size: 662, offs: <@03d288>, cast: static const function)
.field append: function (size: 23, offs: <@03d520>, cast: static const function)
.field append: function (size: 54, offs: <@03d538>, cast: static const function)
.field append: function (size: 25, offs: <@03d580>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+36>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+44>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+48>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+56>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+64>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+248>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+268>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@023a10>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@023b20>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+276>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+284>, cast: variable(val))
.field value: int64 (size: 8, offs: <@03d5a0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+288>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+292>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+300>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+308>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+320>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+324>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+332>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+336>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+340>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+344>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+348>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+356>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+360>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+368>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+376>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+380>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+384>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+392>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+396>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+468>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+476>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+484>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+492>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+500>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+508>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+516>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+524>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+532>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+540>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+548>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+556>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+564>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+572>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+580>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+588>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+596>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+604>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+612>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+680>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+688>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+696>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+700>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+704>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+712>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+716>, cast: variable(ref))
.field empty: function (size: 1, offs: <@03d5a8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@03d5b0>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+720>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+724>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+728>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+732>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+736>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+740>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+744>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@03d5b8>, cast: static const function)
.field fib: function (size: 54, offs: <@03d5c0>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+748>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+820>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@028ee0>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@028ff0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+824>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+828>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+836>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+840>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+844>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+848>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+852>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+860>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+864>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+868>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+872>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+880>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+884>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+892>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+900>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+908>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+916>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+984>, cast: variable(i32))
.field sinF64: float64 (size: 8, offs: <+992>, cast: variable(f64))
.field cosF64: float64 (size: 8, offs: <+1000>, cast: variable(f64))
.field tanF64: float64 (size: 8, offs: <+1008>, cast: variable(f64))
.field logF64: float64 (size: 8, offs: <+1016>, cast: variable(f64))
.field expF64: float64 (size: 8, offs: <+1024>, cast: variable(f64))
.field powF64: float64 (size: 8, offs: <+1032>, cast: variable(f64))
.field sqrtF64: float64 (size: 8, offs: <+1040>, cast: variable(f64))
.field atanF64: float64 (size: 8, offs: <+1048>, cast: variable(f64))
.field sinF32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field cosF32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field tanF32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field logF32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field expF32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field powF32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field sqrtF32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field atanF32: float32 (size: 4, offs: <+1080>, cast: variable(f32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1084>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1088>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1092>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1096>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1104>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1112>, cast: variable(i64))
.field noError: function (size: 1, offs: <@03d5f8>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@03d600>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@03d618>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@03d628>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@03d670>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@03d680>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1120>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1124>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1128>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1132>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1136>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1140>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1196>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1200>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1208>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1212>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1220>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1224>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1232>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1256>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1268>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@03d688>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@03d690>, cast: static const function)
.field nthArray: function (size: 12, offs: <@03d6a0>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@03d6b0>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@02f190>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1300>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@02fb88>, cast: static const typename(val))
.field globalFunction: function (size: 8, offs: <@03d760>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1316>, cast: variable(val))
.field customPrint: function (size: 40, offs: <@03d768>, cast: static const function)
.field recordMethodTestCustomPrint: RecordMethodTest (size: 16, offs: <+1332>, cast: variable(val))
.field print: function (size: 40, offs: <@03d790>, cast: static const function)
.field printStatic: function (size: 40, offs: <@03d7b8>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@031560>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@031780>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@0319a0>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@031b38>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1336>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1340>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1344>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1348>, cast: variable(val))
.field blue: color (size: 4, offs: <+1352>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@031f68>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@032320>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0326d8>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@032a90>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@032e48>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@033200>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1356>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1360>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1364>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1368>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1372>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1376>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1408>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1412>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1416>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1420>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1424>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1468>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1472>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1476>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1480>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1484>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1496>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1500>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1504>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1508>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1512>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1556>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1560>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1564>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1568>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1572>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1584>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1588>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1592>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1596>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1600>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1644>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1648>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1652>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1656>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1660>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1672>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1676>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1680>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1684>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1688>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1732>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1736>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1740>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1744>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1748>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1760>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1764>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1768>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1772>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1776>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1820>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1824>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1828>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1832>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1836>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1848>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1852>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1856>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1860>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1864>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1908>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1912>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1916>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1920>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1924>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1936>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1940>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1944>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1948>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1952>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+1996>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2000>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2004>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2008>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2012>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2028>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2036>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2044>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2052>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2060>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2068>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2076>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2084>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2092>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2100>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2108>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2116>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2124>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2132>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2140>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2144>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2148>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2152>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2156>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2160>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2176>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2184>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2192>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2200>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2208>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2216>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2224>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2232>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2240>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2248>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2256>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2264>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2272>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2280>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2288>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2292>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2296>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2300>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2304>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2308>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2320>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2324>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2328>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2332>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2336>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2356>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2360>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2364>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2368>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2372>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2388>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2396>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2404>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2412>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2420>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2428>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2436>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2444>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2452>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2456>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2460>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2464>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2468>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2472>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2484>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2488>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2500>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2504>, cast: variable(i32))
.field .main: function (size: 8555, offs: <@03d7e0>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const message: char[*];
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static const sign(x: float32): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const sign(x: float64): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static const lerp(t: float32, a: float32, b: float32): float32 := {
				return float32(.result := float32(a + float32(t * (float32(b - a)))));
			};
			static const lerp(t: float64, a: float64, b: float64): float64 := {
				return float64(.result := float64(a + float64(t * (float64(b - a)))));
			};
			static const smooth(t: float32, a: float32, b: float32): float32 := {
				float32(t := clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
				return float32(.result := float32(float32(t * t) * (float32((3) - float32((2) * t)))));
			};
			static const smooth(t: float64, a: float64, b: float64): float64 := {
				float64(t := clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
				return float64(.result := float64(float64(t * t) * (float64((3) - float64((2) * t)))));
			};
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static deg2rad(x: float64): float64 := float64(float64(float64(x * pi) / (180)));
			static rad2deg(x: float64): float64 := float64(float64(float64(x * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		emitNfcF32: float32 := emit(void(float32(float64(3.140000 / (2))), float32.sin));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		sinF64: float64 := float64.sin(float64(pi64 / (2)));
		cosF64: float64 := float64.cos(float64(pi64 / (2)));
		tanF64: float64 := float64.tan(float64(pi64 / (4)));
		logF64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		expF64: float64 := float64.exp(1.000000);
		powF64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		sqrtF64: float64 := float64.sqrt(float64(pi64 * pi64));
		atanF64: float64 := float64.atan2(void(pi64, 1.000000));
		sinF32: float32 := float32.sin(float32(pi32 / (2)));
		cosF32: float32 := float32.cos(float32(pi32 / (2)));
		tanF32: float32 := float32.tan(float32(pi32 / (4)));
		logF32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		expF32: float32 := float32.exp(1.000000);
		powF32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		sqrtF32: float32 := float32.sqrt(float32(pi32 * pi32));
		atanF32: float32 := float32.atan2(void(pi32, 1.000000));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 5;
			static const globalConstant: int32 := 6;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 51);
				void(globalRecInit.constant := 52);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 61);
				void(globalConstantRec.constant := 62);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 6);
			void(recordMemberTest.constant := 7);
			void(recordMemberTest.memberInit := 8);
			void(recordMemberTest.constantInit := 9);
			void(recordMemberTest.memberRec.member := 61);
			void(recordMemberTest.memberRec.constant := 62);
			void(recordMemberTest.constantRec.member := 71);
			void(recordMemberTest.constantRec.constant := 72);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x + y));
			};
			static forwardMethod(x: int32, y: int32): int32 := forwardMethod;
			abstractMethod(x: int32, y: int32): int32;
			delegateMethod(x: int32, y: int32): int32 := forwardMethod;
			const virtualMethod(x: int32, y: int32): int32 := virtualMethod;
			static const virtualMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x * y));
			};
			static const forwardMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x * y));
			};
			const print(this: RecordMethodTest): void := print;
			static const print(this: RecordMethodTest): void := {
				trace("virtual");
			};
			static const printStatic(this: RecordMethodTest): void := {
				trace("static");
			};
		};
		static const globalFunction(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.delegateMethod := globalFunction);
			void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
			void(recordMethodTest.print := print);
		};
		static const customPrint(this: RecordMethodTest): void := {
			trace("override");
		};
		recordMethodTestCustomPrint: RecordMethodTest := {
			void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
			void(recordMethodTestCustomPrint.print := customPrint);
			void(recordMethodTestCustomPrint.delegateMethod := forwardMethod);
			void(recordMethodTestCustomPrint.virtualMethod := virtualMethod);
		};
		recordMethodTest.print(recordMethodTest);
		recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
		recordMethodTest.printStatic(recordMethodTest);
		static const print(this: RecordMethodTest): void := {
			trace("extension");
		};
		static const printStatic(this: RecordMethodTest): void := {
			trace("extension");
		};
		print(recordMethodTest);
		printStatic(recordMethodTest);
		print(recordMethodTestCustomPrint);
		RecordMethodTest.print(recordMethodTest);
		RecordMethodTest.printStatic(recordMethodTest);
		RecordMethodTest.print(recordMethodTestCustomPrint);
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
	}
}
.instructions: (8555 bytes: <@03d7e0> - <@03f94b>)
	lib/std/string.ci:130: (14 bytes: <@03d7e0> - <@03d7ee>): static const whiteSpace: char[] := " \t\n\r"
	<.main @03d7e0>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @03d7e5>    : 1f 78 96 01 00             load.ref <@019678> ;" \t\n\r"
	<.main+10 @03d7ea>   : 2d 78 d2 03                store.m64 <@03d278> ;append.whiteSpace
	lib/std/string.ci:131: (14 bytes: <@03d7ee> - <@03d7fc>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @03d7ee>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @03d7f3>   : 1f 89 96 01 00             load.ref <@019689> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @03d7f8>   : 2d 80 d2 03                store.m64 <@03d280> ;append.radixDigits
	lib/std/string.ci:206: (26 bytes: <@03d7fc> - <@03d816>): static const format: FormatFlags := {...}
	<.main+28 @03d7fc>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @03d801>   : 2e 70 d5 03                store.m32 <@03d570> ;append.format
	:: (7 bytes: <@03d805> - <@03d80c>): void(format.padChr := (0))
	<.main+37 @03d805>   : 19                         load.z32
	<.main+38 @03d806>   : 1f 74 d5 03 00             load.ref <@03d574> ;append.format+4
	<.main+43 @03d80b>   : 25                         store.i8
	:: (5 bytes: <@03d80c> - <@03d811>): void(format.padLen := 0)
	<.main+44 @03d80c>   : 19                         load.z32
	<.main+45 @03d80d>   : 2e 78 d5 03                store.m32 <@03d578> ;append.format+8
	:: (5 bytes: <@03d811> - <@03d816>): void(format.precision := 0)
	<.main+49 @03d811>   : 19                         load.z32
	<.main+50 @03d812>   : 2e 7c d5 03                store.m32 <@03d57c> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@03d816> - <@03d823>): static value: int64 := 42
	<.main+54 @03d816>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @03d81f>   : 2d a0 d5 03                store.m64 <@03d5a0> ;value
	test/lang/member.ci:35: (5 bytes: <@03d823> - <@03d828>): static global: int32
	<.main+67 @03d823>   : 19                         load.z32
	<.main+68 @03d824>   : 2e c0 d6 03                store.m32 <@03d6c0> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@03d828> - <@03d831>): static globalInit: int32 := 5
	<.main+72 @03d828>   : 1c 05 00 00 00             load.c32 5
	<.main+77 @03d82d>   : 2e c8 d6 03                store.m32 <@03d6c8> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@03d831> - <@03d83a>): static const globalConstant: int32 := 6
	<.main+81 @03d831>   : 1c 06 00 00 00             load.c32 6
	<.main+86 @03d836>   : 2e d0 d6 03                store.m32 <@03d6d0> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@03d83a> - <@03d84c>): static globalRecInit: Inner := {...}
	<.main+90 @03d83a>   : 1c 33 00 00 00             load.c32 51
	<.main+95 @03d83f>   : 2e e0 d6 03                store.m32 <@03d6e0> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@03d843> - <@03d84c>): void(globalRecInit.constant := 52);
	<.main+99 @03d843>   : 1c 34 00 00 00             load.c32 52
	<.main+104 @03d848>  : 2e e4 d6 03                store.m32 <@03d6e4> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@03d84c> - <@03d85e>): static const globalConstantRec: Inner := {...}
	<.main+108 @03d84c>  : 1c 3d 00 00 00             load.c32 61
	<.main+113 @03d851>  : 2e e8 d6 03                store.m32 <@03d6e8> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@03d855> - <@03d85e>): void(globalConstantRec.constant := 62);
	<.main+117 @03d855>  : 1c 3e 00 00 00             load.c32 62
	<.main+122 @03d85a>  : 2e ec d6 03                store.m32 <@03d6ec> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:12: (9 bytes: <@03d85e> - <@03d867>): static forwardMethod(x: int32, y: int32): int32 := forwardMethod
	<.main+126 @03d85e>  : 1f 08 d7 03 00             load.ref <@03d708> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+131 @03d863>  : 2e f8 d6 03                store.m32 <@03d6f8> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	test/lang/emit.ci:3: (1 byte: <@03d867> - <@03d868>): emitldz32: int32 := emit(load.z32)
	<.main+135 @03d867>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@03d868> - <@03d869>): emitldz64: int64 := emit(load.z64)
	<.main+136 @03d868>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@03d869> - <@03d86e>): emitA: int32 := 42
	<.main+137 @03d869>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@03d86e> - <@03d873>): emitB: int32 := 96
	<.main+142 @03d86e>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@03d873> - <@03d878>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @03d873>  : 10 01                      dup.x1 sp(1)
	<.main+149 @03d875>  : 10 01                      dup.x1 sp(1)
	<.main+151 @03d877>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@03d878> - <@03d883>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @03d878>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @03d87d>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @03d882>  : 54                         div.i32
	test/lang/emit.ci:11: (24 bytes: <@03d883> - <@03d89b>): emitNfcF32: float32 := emit(void(float32(float64(3.140000 / (2))), float32.sin))
	<.main+163 @03d883>  : 8f 1f 85 eb 51 b8 1e 09 40 load.f64 3.140000
	<.main+172 @03d88c>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+181 @03d895>  : 84                         div.f64
	<.main+182 @03d896>  : 8b                         f64.2f32
	<.main+183 @03d897>  : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/lang/emit.ci:17: (5 bytes: <@03d89b> - <@03d8a0>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+187 @03d89b>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@03d8a0> - <@03d8a6>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+192 @03d8a0>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+197 @03d8a5>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@03d8a6> - <@03d8b0>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+198 @03d8a6>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+207 @03d8af>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@03d8b0> - <@03d8b9>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+208 @03d8b0>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@03d8b9> - <@03d8c3>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+217 @03d8b9>  : 1c 03 00 00 00             load.c32 3
	<.main+222 @03d8be>  : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@03d8c3> - <@03d8c8>): i3: int32 := 3
	<.main+227 @03d8c3>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@03d8c8> - <@03d8cd>): i6: int32 := 6
	<.main+232 @03d8c8>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@03d8cd> - <@03d8d2>): i2: int32 := 2
	<.main+237 @03d8cd>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@03d8d2> - <@03d8d7>): i8: int32 := 8
	<.main+242 @03d8d2>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@03d8d7> - <@03d8d8>): zeroVal: int32 := zero(void(3, 6))
	<.main+247 @03d8d7>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@03d8d8> - <@03d8d9>): zeroVar: int32 := zero(void(i3, i6))
	<.main+248 @03d8d8>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@03d8d9> - <@03d8da>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+249 @03d8d9>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@03d8da> - <@03d8df>): lastVal: int32 := last(void(3, 6))
	<.main+250 @03d8da>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@03d8df> - <@03d8e1>): lastVar: int32 := last(void(i3, i6))
	<.main+255 @03d8df>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@03d8e1> - <@03d8eb>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+257 @03d8e1>  : 10 07                      dup.x1 sp(7)
	<.main+259 @03d8e3>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @03d8e7>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@03d8eb> - <@03d8f4>): sum2Val: int32 := sum(void(3, 6))
	<.main+267 @03d8eb>  : 1c 03 00 00 00             load.c32 3
	<.main+272 @03d8f0>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@03d8f4> - <@03d8f9>): sum2Var: int32 := sum(void(i3, i6))
	<.main+276 @03d8f4>  : 10 0a                      dup.x1 sp(10)
	<.main+278 @03d8f6>  : 10 0a                      dup.x1 sp(10)
	<.main+280 @03d8f8>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@03d8f9> - <@03d90a>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+281 @03d8f9>  : 10 0b                      dup.x1 sp(11)
	<.main+283 @03d8fb>  : 0c 01 00 00                inc.i32(+1)
	<.main+287 @03d8ff>  : 10 0b                      dup.x1 sp(11)
	<.main+289 @03d901>  : 0c 01 00 00                inc.i32(+1)
	<.main+293 @03d905>  : 51                         add.i32
	<.main+294 @03d906>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@03d90a> - <@03d922>): any2Val: int32 := any(void(3, 6))
	<.main+298 @03d90a>  : 1c 03 00 00 00             load.c32 3
	<.main+303 @03d90f>  : 10 00                      dup.x1 sp(0)
	<.main+305 @03d911>  : 06 0a 00 00                jz <.main+315 @03d91b>
	<.main+309 @03d915>  : 10 00                      dup.x1 sp(0)
	<.main+311 @03d917>  : 04 09 00 00                jmp <.main+320 @03d920>
	<.main+315 @03d91b>  : 1c 06 00 00 00             load.c32 6
	<.main+320 @03d920>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@03d922> - <@03d934>): any2Var: int32 := any(void(i3, i6))
	<.main+322 @03d922>  : 10 0d                      dup.x1 sp(13)
	<.main+324 @03d924>  : 10 00                      dup.x1 sp(0)
	<.main+326 @03d926>  : 06 0a 00 00                jz <.main+336 @03d930>
	<.main+330 @03d92a>  : 10 00                      dup.x1 sp(0)
	<.main+332 @03d92c>  : 04 06 00 00                jmp <.main+338 @03d932>
	<.main+336 @03d930>  : 10 0d                      dup.x1 sp(13)
	<.main+338 @03d932>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@03d934> - <@03d952>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+340 @03d934>  : 10 0e                      dup.x1 sp(14)
	<.main+342 @03d936>  : 0c 01 00 00                inc.i32(+1)
	<.main+346 @03d93a>  : 10 00                      dup.x1 sp(0)
	<.main+348 @03d93c>  : 06 0a 00 00                jz <.main+358 @03d946>
	<.main+352 @03d940>  : 10 00                      dup.x1 sp(0)
	<.main+354 @03d942>  : 04 0a 00 00                jmp <.main+364 @03d94c>
	<.main+358 @03d946>  : 10 0e                      dup.x1 sp(14)
	<.main+360 @03d948>  : 0c 01 00 00                inc.i32(+1)
	<.main+364 @03d94c>  : 13 01                      set.x1 sp(1)
	<.main+366 @03d94e>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@03d952> - <@03d973>): min2Val: int32 := min(void(3, 6))
	<.main+370 @03d952>  : 1c 03 00 00 00             load.c32 3
	<.main+375 @03d957>  : 1c 06 00 00 00             load.c32 6
	<.main+380 @03d95c>  : 10 01                      dup.x1 sp(1)
	<.main+382 @03d95e>  : 10 01                      dup.x1 sp(1)
	<.main+384 @03d960>  : 58                         clt.i32
	<.main+385 @03d961>  : 06 0a 00 00                jz <.main+395 @03d96b>
	<.main+389 @03d965>  : 10 01                      dup.x1 sp(1)
	<.main+391 @03d967>  : 04 06 00 00                jmp <.main+397 @03d96d>
	<.main+395 @03d96b>  : 10 00                      dup.x1 sp(0)
	<.main+397 @03d96d>  : 13 02                      set.x1 sp(2)
	<.main+399 @03d96f>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@03d973> - <@03d98e>): min2Var: int32 := min(void(i3, i6))
	<.main+403 @03d973>  : 10 10                      dup.x1 sp(16)
	<.main+405 @03d975>  : 10 10                      dup.x1 sp(16)
	<.main+407 @03d977>  : 10 01                      dup.x1 sp(1)
	<.main+409 @03d979>  : 10 01                      dup.x1 sp(1)
	<.main+411 @03d97b>  : 58                         clt.i32
	<.main+412 @03d97c>  : 06 0a 00 00                jz <.main+422 @03d986>
	<.main+416 @03d980>  : 10 01                      dup.x1 sp(1)
	<.main+418 @03d982>  : 04 06 00 00                jmp <.main+424 @03d988>
	<.main+422 @03d986>  : 10 00                      dup.x1 sp(0)
	<.main+424 @03d988>  : 13 02                      set.x1 sp(2)
	<.main+426 @03d98a>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@03d98e> - <@03d9b5>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+430 @03d98e>  : 10 11                      dup.x1 sp(17)
	<.main+432 @03d990>  : 0c 01 00 00                inc.i32(+1)
	<.main+436 @03d994>  : 10 11                      dup.x1 sp(17)
	<.main+438 @03d996>  : 0c 01 00 00                inc.i32(+1)
	<.main+442 @03d99a>  : 10 01                      dup.x1 sp(1)
	<.main+444 @03d99c>  : 10 01                      dup.x1 sp(1)
	<.main+446 @03d99e>  : 58                         clt.i32
	<.main+447 @03d99f>  : 06 0a 00 00                jz <.main+457 @03d9a9>
	<.main+451 @03d9a3>  : 10 01                      dup.x1 sp(1)
	<.main+453 @03d9a5>  : 04 06 00 00                jmp <.main+459 @03d9ab>
	<.main+457 @03d9a9>  : 10 00                      dup.x1 sp(0)
	<.main+459 @03d9ab>  : 13 02                      set.x1 sp(2)
	<.main+461 @03d9ad>  : 09 fc ff ff                inc.sp(-4)
	<.main+465 @03d9b1>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@03d9b5> - <@03d9d6>): max2Val: int32 := max(void(3, 6))
	<.main+469 @03d9b5>  : 1c 03 00 00 00             load.c32 3
	<.main+474 @03d9ba>  : 1c 06 00 00 00             load.c32 6
	<.main+479 @03d9bf>  : 10 01                      dup.x1 sp(1)
	<.main+481 @03d9c1>  : 10 01                      dup.x1 sp(1)
	<.main+483 @03d9c3>  : 59                         cgt.i32
	<.main+484 @03d9c4>  : 06 0a 00 00                jz <.main+494 @03d9ce>
	<.main+488 @03d9c8>  : 10 01                      dup.x1 sp(1)
	<.main+490 @03d9ca>  : 04 06 00 00                jmp <.main+496 @03d9d0>
	<.main+494 @03d9ce>  : 10 00                      dup.x1 sp(0)
	<.main+496 @03d9d0>  : 13 02                      set.x1 sp(2)
	<.main+498 @03d9d2>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@03d9d6> - <@03d9f1>): max2Var: int32 := max(void(i3, i6))
	<.main+502 @03d9d6>  : 10 13                      dup.x1 sp(19)
	<.main+504 @03d9d8>  : 10 13                      dup.x1 sp(19)
	<.main+506 @03d9da>  : 10 01                      dup.x1 sp(1)
	<.main+508 @03d9dc>  : 10 01                      dup.x1 sp(1)
	<.main+510 @03d9de>  : 59                         cgt.i32
	<.main+511 @03d9df>  : 06 0a 00 00                jz <.main+521 @03d9e9>
	<.main+515 @03d9e3>  : 10 01                      dup.x1 sp(1)
	<.main+517 @03d9e5>  : 04 06 00 00                jmp <.main+523 @03d9eb>
	<.main+521 @03d9e9>  : 10 00                      dup.x1 sp(0)
	<.main+523 @03d9eb>  : 13 02                      set.x1 sp(2)
	<.main+525 @03d9ed>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@03d9f1> - <@03da18>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+529 @03d9f1>  : 10 14                      dup.x1 sp(20)
	<.main+531 @03d9f3>  : 0c 01 00 00                inc.i32(+1)
	<.main+535 @03d9f7>  : 10 14                      dup.x1 sp(20)
	<.main+537 @03d9f9>  : 0c 01 00 00                inc.i32(+1)
	<.main+541 @03d9fd>  : 10 01                      dup.x1 sp(1)
	<.main+543 @03d9ff>  : 10 01                      dup.x1 sp(1)
	<.main+545 @03da01>  : 59                         cgt.i32
	<.main+546 @03da02>  : 06 0a 00 00                jz <.main+556 @03da0c>
	<.main+550 @03da06>  : 10 01                      dup.x1 sp(1)
	<.main+552 @03da08>  : 04 06 00 00                jmp <.main+558 @03da0e>
	<.main+556 @03da0c>  : 10 00                      dup.x1 sp(0)
	<.main+558 @03da0e>  : 13 02                      set.x1 sp(2)
	<.main+560 @03da10>  : 09 fc ff ff                inc.sp(-4)
	<.main+564 @03da14>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@03da18> - <@03da2d>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+568 @03da18>  : 1c 03 00 00 00             load.c32 3
	<.main+573 @03da1d>  : 1c 06 00 00 00             load.c32 6
	<.main+578 @03da22>  : 1c 02 00 00 00             load.c32 2
	<.main+583 @03da27>  : 0c 08 00 00                inc.i32(+8)
	<.main+587 @03da2b>  : 51                         add.i32
	<.main+588 @03da2c>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@03da2d> - <@03da3e>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+589 @03da2d>  : 1c 03 00 00 00             load.c32 3
	<.main+594 @03da32>  : 0c 06 00 00                inc.i32(+6)
	<.main+598 @03da36>  : 0c 02 00 00                inc.i32(+2)
	<.main+602 @03da3a>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@03da3e> - <@03da49>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+606 @03da3e>  : 10 17                      dup.x1 sp(23)
	<.main+608 @03da40>  : 10 17                      dup.x1 sp(23)
	<.main+610 @03da42>  : 10 17                      dup.x1 sp(23)
	<.main+612 @03da44>  : 10 17                      dup.x1 sp(23)
	<.main+614 @03da46>  : 51                         add.i32
	<.main+615 @03da47>  : 51                         add.i32
	<.main+616 @03da48>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@03da49> - <@03da54>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+617 @03da49>  : 10 18                      dup.x1 sp(24)
	<.main+619 @03da4b>  : 10 18                      dup.x1 sp(24)
	<.main+621 @03da4d>  : 51                         add.i32
	<.main+622 @03da4e>  : 10 17                      dup.x1 sp(23)
	<.main+624 @03da50>  : 51                         add.i32
	<.main+625 @03da51>  : 10 16                      dup.x1 sp(22)
	<.main+627 @03da53>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@03da54> - <@03da73>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+628 @03da54>  : 10 19                      dup.x1 sp(25)
	<.main+630 @03da56>  : 0c 01 00 00                inc.i32(+1)
	<.main+634 @03da5a>  : 10 19                      dup.x1 sp(25)
	<.main+636 @03da5c>  : 0c 01 00 00                inc.i32(+1)
	<.main+640 @03da60>  : 10 19                      dup.x1 sp(25)
	<.main+642 @03da62>  : 0c 01 00 00                inc.i32(+1)
	<.main+646 @03da66>  : 10 19                      dup.x1 sp(25)
	<.main+648 @03da68>  : 0c 01 00 00                inc.i32(+1)
	<.main+652 @03da6c>  : 51                         add.i32
	<.main+653 @03da6d>  : 51                         add.i32
	<.main+654 @03da6e>  : 51                         add.i32
	<.main+655 @03da6f>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@03da73> - <@03da92>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+659 @03da73>  : 10 1a                      dup.x1 sp(26)
	<.main+661 @03da75>  : 0c 01 00 00                inc.i32(+1)
	<.main+665 @03da79>  : 10 1a                      dup.x1 sp(26)
	<.main+667 @03da7b>  : 0c 01 00 00                inc.i32(+1)
	<.main+671 @03da7f>  : 51                         add.i32
	<.main+672 @03da80>  : 10 19                      dup.x1 sp(25)
	<.main+674 @03da82>  : 0c 01 00 00                inc.i32(+1)
	<.main+678 @03da86>  : 51                         add.i32
	<.main+679 @03da87>  : 10 18                      dup.x1 sp(24)
	<.main+681 @03da89>  : 0c 01 00 00                inc.i32(+1)
	<.main+685 @03da8d>  : 51                         add.i32
	<.main+686 @03da8e>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@03da92> - <@03dad0>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+690 @03da92>  : 1c 03 00 00 00             load.c32 3
	<.main+695 @03da97>  : 10 00                      dup.x1 sp(0)
	<.main+697 @03da99>  : 06 0a 00 00                jz <.main+707 @03daa3>
	<.main+701 @03da9d>  : 10 00                      dup.x1 sp(0)
	<.main+703 @03da9f>  : 04 2f 00 00                jmp <.main+750 @03dace>
	<.main+707 @03daa3>  : 1c 06 00 00 00             load.c32 6
	<.main+712 @03daa8>  : 10 00                      dup.x1 sp(0)
	<.main+714 @03daaa>  : 06 0a 00 00                jz <.main+724 @03dab4>
	<.main+718 @03daae>  : 10 00                      dup.x1 sp(0)
	<.main+720 @03dab0>  : 04 1c 00 00                jmp <.main+748 @03dacc>
	<.main+724 @03dab4>  : 1c 02 00 00 00             load.c32 2
	<.main+729 @03dab9>  : 10 00                      dup.x1 sp(0)
	<.main+731 @03dabb>  : 06 0a 00 00                jz <.main+741 @03dac5>
	<.main+735 @03dabf>  : 10 00                      dup.x1 sp(0)
	<.main+737 @03dac1>  : 04 09 00 00                jmp <.main+746 @03daca>
	<.main+741 @03dac5>  : 1c 08 00 00 00             load.c32 8
	<.main+746 @03daca>  : 13 01                      set.x1 sp(1)
	<.main+748 @03dacc>  : 13 01                      set.x1 sp(1)
	<.main+750 @03dace>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@03dad0> - <@03db0e>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+752 @03dad0>  : 1c 03 00 00 00             load.c32 3
	<.main+757 @03dad5>  : 10 00                      dup.x1 sp(0)
	<.main+759 @03dad7>  : 06 0a 00 00                jz <.main+769 @03dae1>
	<.main+763 @03dadb>  : 10 00                      dup.x1 sp(0)
	<.main+765 @03dadd>  : 04 09 00 00                jmp <.main+774 @03dae6>
	<.main+769 @03dae1>  : 1c 06 00 00 00             load.c32 6
	<.main+774 @03dae6>  : 13 01                      set.x1 sp(1)
	<.main+776 @03dae8>  : 10 00                      dup.x1 sp(0)
	<.main+778 @03daea>  : 06 0a 00 00                jz <.main+788 @03daf4>
	<.main+782 @03daee>  : 10 00                      dup.x1 sp(0)
	<.main+784 @03daf0>  : 04 09 00 00                jmp <.main+793 @03daf9>
	<.main+788 @03daf4>  : 1c 02 00 00 00             load.c32 2
	<.main+793 @03daf9>  : 13 01                      set.x1 sp(1)
	<.main+795 @03dafb>  : 10 00                      dup.x1 sp(0)
	<.main+797 @03dafd>  : 06 0a 00 00                jz <.main+807 @03db07>
	<.main+801 @03db01>  : 10 00                      dup.x1 sp(0)
	<.main+803 @03db03>  : 04 09 00 00                jmp <.main+812 @03db0c>
	<.main+807 @03db07>  : 1c 08 00 00 00             load.c32 8
	<.main+812 @03db0c>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@03db0e> - <@03db40>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+814 @03db0e>  : 10 1d                      dup.x1 sp(29)
	<.main+816 @03db10>  : 10 00                      dup.x1 sp(0)
	<.main+818 @03db12>  : 06 0a 00 00                jz <.main+828 @03db1c>
	<.main+822 @03db16>  : 10 00                      dup.x1 sp(0)
	<.main+824 @03db18>  : 04 26 00 00                jmp <.main+862 @03db3e>
	<.main+828 @03db1c>  : 10 1d                      dup.x1 sp(29)
	<.main+830 @03db1e>  : 10 00                      dup.x1 sp(0)
	<.main+832 @03db20>  : 06 0a 00 00                jz <.main+842 @03db2a>
	<.main+836 @03db24>  : 10 00                      dup.x1 sp(0)
	<.main+838 @03db26>  : 04 16 00 00                jmp <.main+860 @03db3c>
	<.main+842 @03db2a>  : 10 1d                      dup.x1 sp(29)
	<.main+844 @03db2c>  : 10 00                      dup.x1 sp(0)
	<.main+846 @03db2e>  : 06 0a 00 00                jz <.main+856 @03db38>
	<.main+850 @03db32>  : 10 00                      dup.x1 sp(0)
	<.main+852 @03db34>  : 04 06 00 00                jmp <.main+858 @03db3a>
	<.main+856 @03db38>  : 10 1d                      dup.x1 sp(29)
	<.main+858 @03db3a>  : 13 01                      set.x1 sp(1)
	<.main+860 @03db3c>  : 13 01                      set.x1 sp(1)
	<.main+862 @03db3e>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@03db40> - <@03db72>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+864 @03db40>  : 10 1e                      dup.x1 sp(30)
	<.main+866 @03db42>  : 10 00                      dup.x1 sp(0)
	<.main+868 @03db44>  : 06 0a 00 00                jz <.main+878 @03db4e>
	<.main+872 @03db48>  : 10 00                      dup.x1 sp(0)
	<.main+874 @03db4a>  : 04 06 00 00                jmp <.main+880 @03db50>
	<.main+878 @03db4e>  : 10 1e                      dup.x1 sp(30)
	<.main+880 @03db50>  : 13 01                      set.x1 sp(1)
	<.main+882 @03db52>  : 10 00                      dup.x1 sp(0)
	<.main+884 @03db54>  : 06 0a 00 00                jz <.main+894 @03db5e>
	<.main+888 @03db58>  : 10 00                      dup.x1 sp(0)
	<.main+890 @03db5a>  : 04 06 00 00                jmp <.main+896 @03db60>
	<.main+894 @03db5e>  : 10 1d                      dup.x1 sp(29)
	<.main+896 @03db60>  : 13 01                      set.x1 sp(1)
	<.main+898 @03db62>  : 10 00                      dup.x1 sp(0)
	<.main+900 @03db64>  : 06 0a 00 00                jz <.main+910 @03db6e>
	<.main+904 @03db68>  : 10 00                      dup.x1 sp(0)
	<.main+906 @03db6a>  : 04 06 00 00                jmp <.main+912 @03db70>
	<.main+910 @03db6e>  : 10 1c                      dup.x1 sp(28)
	<.main+912 @03db70>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@03db72> - <@03dbb8>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+914 @03db72>  : 10 1f                      dup.x1 sp(31)
	<.main+916 @03db74>  : 0c 01 00 00                inc.i32(+1)
	<.main+920 @03db78>  : 10 00                      dup.x1 sp(0)
	<.main+922 @03db7a>  : 06 0a 00 00                jz <.main+932 @03db84>
	<.main+926 @03db7e>  : 10 00                      dup.x1 sp(0)
	<.main+928 @03db80>  : 04 32 00 00                jmp <.main+978 @03dbb2>
	<.main+932 @03db84>  : 10 1f                      dup.x1 sp(31)
	<.main+934 @03db86>  : 0c 01 00 00                inc.i32(+1)
	<.main+938 @03db8a>  : 10 00                      dup.x1 sp(0)
	<.main+940 @03db8c>  : 06 0a 00 00                jz <.main+950 @03db96>
	<.main+944 @03db90>  : 10 00                      dup.x1 sp(0)
	<.main+946 @03db92>  : 04 1e 00 00                jmp <.main+976 @03dbb0>
	<.main+950 @03db96>  : 10 1f                      dup.x1 sp(31)
	<.main+952 @03db98>  : 0c 01 00 00                inc.i32(+1)
	<.main+956 @03db9c>  : 10 00                      dup.x1 sp(0)
	<.main+958 @03db9e>  : 06 0a 00 00                jz <.main+968 @03dba8>
	<.main+962 @03dba2>  : 10 00                      dup.x1 sp(0)
	<.main+964 @03dba4>  : 04 0a 00 00                jmp <.main+974 @03dbae>
	<.main+968 @03dba8>  : 10 1f                      dup.x1 sp(31)
	<.main+970 @03dbaa>  : 0c 01 00 00                inc.i32(+1)
	<.main+974 @03dbae>  : 13 01                      set.x1 sp(1)
	<.main+976 @03dbb0>  : 13 01                      set.x1 sp(1)
	<.main+978 @03dbb2>  : 13 01                      set.x1 sp(1)
	<.main+980 @03dbb4>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@03dbb8> - <@03dbfe>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+984 @03dbb8>  : 10 20                      dup.x1 sp(32)
	<.main+986 @03dbba>  : 0c 01 00 00                inc.i32(+1)
	<.main+990 @03dbbe>  : 10 00                      dup.x1 sp(0)
	<.main+992 @03dbc0>  : 06 0a 00 00                jz <.main+1002 @03dbca>
	<.main+996 @03dbc4>  : 10 00                      dup.x1 sp(0)
	<.main+998 @03dbc6>  : 04 0a 00 00                jmp <.main+1008 @03dbd0>
	<.main+1002 @03dbca> : 10 20                      dup.x1 sp(32)
	<.main+1004 @03dbcc> : 0c 01 00 00                inc.i32(+1)
	<.main+1008 @03dbd0> : 13 01                      set.x1 sp(1)
	<.main+1010 @03dbd2> : 10 00                      dup.x1 sp(0)
	<.main+1012 @03dbd4> : 06 0a 00 00                jz <.main+1022 @03dbde>
	<.main+1016 @03dbd8> : 10 00                      dup.x1 sp(0)
	<.main+1018 @03dbda> : 04 0a 00 00                jmp <.main+1028 @03dbe4>
	<.main+1022 @03dbde> : 10 1f                      dup.x1 sp(31)
	<.main+1024 @03dbe0> : 0c 01 00 00                inc.i32(+1)
	<.main+1028 @03dbe4> : 13 01                      set.x1 sp(1)
	<.main+1030 @03dbe6> : 10 00                      dup.x1 sp(0)
	<.main+1032 @03dbe8> : 06 0a 00 00                jz <.main+1042 @03dbf2>
	<.main+1036 @03dbec> : 10 00                      dup.x1 sp(0)
	<.main+1038 @03dbee> : 04 0a 00 00                jmp <.main+1048 @03dbf8>
	<.main+1042 @03dbf2> : 10 1e                      dup.x1 sp(30)
	<.main+1044 @03dbf4> : 0c 01 00 00                inc.i32(+1)
	<.main+1048 @03dbf8> : 13 01                      set.x1 sp(1)
	<.main+1050 @03dbfa> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@03dbfe> - <@03dc57>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1054 @03dbfe> : 1c 03 00 00 00             load.c32 3
	<.main+1059 @03dc03> : 1c 06 00 00 00             load.c32 6
	<.main+1064 @03dc08> : 1c 02 00 00 00             load.c32 2
	<.main+1069 @03dc0d> : 1c 08 00 00 00             load.c32 8
	<.main+1074 @03dc12> : 10 01                      dup.x1 sp(1)
	<.main+1076 @03dc14> : 10 01                      dup.x1 sp(1)
	<.main+1078 @03dc16> : 58                         clt.i32
	<.main+1079 @03dc17> : 06 0a 00 00                jz <.main+1089 @03dc21>
	<.main+1083 @03dc1b> : 10 01                      dup.x1 sp(1)
	<.main+1085 @03dc1d> : 04 06 00 00                jmp <.main+1091 @03dc23>
	<.main+1089 @03dc21> : 10 00                      dup.x1 sp(0)
	<.main+1091 @03dc23> : 13 02                      set.x1 sp(2)
	<.main+1093 @03dc25> : 09 fc ff ff                inc.sp(-4)
	<.main+1097 @03dc29> : 10 01                      dup.x1 sp(1)
	<.main+1099 @03dc2b> : 10 01                      dup.x1 sp(1)
	<.main+1101 @03dc2d> : 58                         clt.i32
	<.main+1102 @03dc2e> : 06 0a 00 00                jz <.main+1112 @03dc38>
	<.main+1106 @03dc32> : 10 01                      dup.x1 sp(1)
	<.main+1108 @03dc34> : 04 06 00 00                jmp <.main+1114 @03dc3a>
	<.main+1112 @03dc38> : 10 00                      dup.x1 sp(0)
	<.main+1114 @03dc3a> : 13 02                      set.x1 sp(2)
	<.main+1116 @03dc3c> : 09 fc ff ff                inc.sp(-4)
	<.main+1120 @03dc40> : 10 01                      dup.x1 sp(1)
	<.main+1122 @03dc42> : 10 01                      dup.x1 sp(1)
	<.main+1124 @03dc44> : 58                         clt.i32
	<.main+1125 @03dc45> : 06 0a 00 00                jz <.main+1135 @03dc4f>
	<.main+1129 @03dc49> : 10 01                      dup.x1 sp(1)
	<.main+1131 @03dc4b> : 04 06 00 00                jmp <.main+1137 @03dc51>
	<.main+1135 @03dc4f> : 10 00                      dup.x1 sp(0)
	<.main+1137 @03dc51> : 13 02                      set.x1 sp(2)
	<.main+1139 @03dc53> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@03dc57> - <@03dcb0>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1143 @03dc57> : 1c 03 00 00 00             load.c32 3
	<.main+1148 @03dc5c> : 1c 06 00 00 00             load.c32 6
	<.main+1153 @03dc61> : 10 01                      dup.x1 sp(1)
	<.main+1155 @03dc63> : 10 01                      dup.x1 sp(1)
	<.main+1157 @03dc65> : 58                         clt.i32
	<.main+1158 @03dc66> : 06 0a 00 00                jz <.main+1168 @03dc70>
	<.main+1162 @03dc6a> : 10 01                      dup.x1 sp(1)
	<.main+1164 @03dc6c> : 04 06 00 00                jmp <.main+1170 @03dc72>
	<.main+1168 @03dc70> : 10 00                      dup.x1 sp(0)
	<.main+1170 @03dc72> : 13 02                      set.x1 sp(2)
	<.main+1172 @03dc74> : 09 fc ff ff                inc.sp(-4)
	<.main+1176 @03dc78> : 1c 02 00 00 00             load.c32 2
	<.main+1181 @03dc7d> : 10 01                      dup.x1 sp(1)
	<.main+1183 @03dc7f> : 10 01                      dup.x1 sp(1)
	<.main+1185 @03dc81> : 58                         clt.i32
	<.main+1186 @03dc82> : 06 0a 00 00                jz <.main+1196 @03dc8c>
	<.main+1190 @03dc86> : 10 01                      dup.x1 sp(1)
	<.main+1192 @03dc88> : 04 06 00 00                jmp <.main+1198 @03dc8e>
	<.main+1196 @03dc8c> : 10 00                      dup.x1 sp(0)
	<.main+1198 @03dc8e> : 13 02                      set.x1 sp(2)
	<.main+1200 @03dc90> : 09 fc ff ff                inc.sp(-4)
	<.main+1204 @03dc94> : 1c 08 00 00 00             load.c32 8
	<.main+1209 @03dc99> : 10 01                      dup.x1 sp(1)
	<.main+1211 @03dc9b> : 10 01                      dup.x1 sp(1)
	<.main+1213 @03dc9d> : 58                         clt.i32
	<.main+1214 @03dc9e> : 06 0a 00 00                jz <.main+1224 @03dca8>
	<.main+1218 @03dca2> : 10 01                      dup.x1 sp(1)
	<.main+1220 @03dca4> : 04 06 00 00                jmp <.main+1226 @03dcaa>
	<.main+1224 @03dca8> : 10 00                      dup.x1 sp(0)
	<.main+1226 @03dcaa> : 13 02                      set.x1 sp(2)
	<.main+1228 @03dcac> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@03dcb0> - <@03dcfd>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1232 @03dcb0> : 10 23                      dup.x1 sp(35)
	<.main+1234 @03dcb2> : 10 23                      dup.x1 sp(35)
	<.main+1236 @03dcb4> : 10 23                      dup.x1 sp(35)
	<.main+1238 @03dcb6> : 10 23                      dup.x1 sp(35)
	<.main+1240 @03dcb8> : 10 01                      dup.x1 sp(1)
	<.main+1242 @03dcba> : 10 01                      dup.x1 sp(1)
	<.main+1244 @03dcbc> : 58                         clt.i32
	<.main+1245 @03dcbd> : 06 0a 00 00                jz <.main+1255 @03dcc7>
	<.main+1249 @03dcc1> : 10 01                      dup.x1 sp(1)
	<.main+1251 @03dcc3> : 04 06 00 00                jmp <.main+1257 @03dcc9>
	<.main+1255 @03dcc7> : 10 00                      dup.x1 sp(0)
	<.main+1257 @03dcc9> : 13 02                      set.x1 sp(2)
	<.main+1259 @03dccb> : 09 fc ff ff                inc.sp(-4)
	<.main+1263 @03dccf> : 10 01                      dup.x1 sp(1)
	<.main+1265 @03dcd1> : 10 01                      dup.x1 sp(1)
	<.main+1267 @03dcd3> : 58                         clt.i32
	<.main+1268 @03dcd4> : 06 0a 00 00                jz <.main+1278 @03dcde>
	<.main+1272 @03dcd8> : 10 01                      dup.x1 sp(1)
	<.main+1274 @03dcda> : 04 06 00 00                jmp <.main+1280 @03dce0>
	<.main+1278 @03dcde> : 10 00                      dup.x1 sp(0)
	<.main+1280 @03dce0> : 13 02                      set.x1 sp(2)
	<.main+1282 @03dce2> : 09 fc ff ff                inc.sp(-4)
	<.main+1286 @03dce6> : 10 01                      dup.x1 sp(1)
	<.main+1288 @03dce8> : 10 01                      dup.x1 sp(1)
	<.main+1290 @03dcea> : 58                         clt.i32
	<.main+1291 @03dceb> : 06 0a 00 00                jz <.main+1301 @03dcf5>
	<.main+1295 @03dcef> : 10 01                      dup.x1 sp(1)
	<.main+1297 @03dcf1> : 04 06 00 00                jmp <.main+1303 @03dcf7>
	<.main+1301 @03dcf5> : 10 00                      dup.x1 sp(0)
	<.main+1303 @03dcf7> : 13 02                      set.x1 sp(2)
	<.main+1305 @03dcf9> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@03dcfd> - <@03dd4a>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1309 @03dcfd> : 10 24                      dup.x1 sp(36)
	<.main+1311 @03dcff> : 10 24                      dup.x1 sp(36)
	<.main+1313 @03dd01> : 10 01                      dup.x1 sp(1)
	<.main+1315 @03dd03> : 10 01                      dup.x1 sp(1)
	<.main+1317 @03dd05> : 58                         clt.i32
	<.main+1318 @03dd06> : 06 0a 00 00                jz <.main+1328 @03dd10>
	<.main+1322 @03dd0a> : 10 01                      dup.x1 sp(1)
	<.main+1324 @03dd0c> : 04 06 00 00                jmp <.main+1330 @03dd12>
	<.main+1328 @03dd10> : 10 00                      dup.x1 sp(0)
	<.main+1330 @03dd12> : 13 02                      set.x1 sp(2)
	<.main+1332 @03dd14> : 09 fc ff ff                inc.sp(-4)
	<.main+1336 @03dd18> : 10 23                      dup.x1 sp(35)
	<.main+1338 @03dd1a> : 10 01                      dup.x1 sp(1)
	<.main+1340 @03dd1c> : 10 01                      dup.x1 sp(1)
	<.main+1342 @03dd1e> : 58                         clt.i32
	<.main+1343 @03dd1f> : 06 0a 00 00                jz <.main+1353 @03dd29>
	<.main+1347 @03dd23> : 10 01                      dup.x1 sp(1)
	<.main+1349 @03dd25> : 04 06 00 00                jmp <.main+1355 @03dd2b>
	<.main+1353 @03dd29> : 10 00                      dup.x1 sp(0)
	<.main+1355 @03dd2b> : 13 02                      set.x1 sp(2)
	<.main+1357 @03dd2d> : 09 fc ff ff                inc.sp(-4)
	<.main+1361 @03dd31> : 10 22                      dup.x1 sp(34)
	<.main+1363 @03dd33> : 10 01                      dup.x1 sp(1)
	<.main+1365 @03dd35> : 10 01                      dup.x1 sp(1)
	<.main+1367 @03dd37> : 58                         clt.i32
	<.main+1368 @03dd38> : 06 0a 00 00                jz <.main+1378 @03dd42>
	<.main+1372 @03dd3c> : 10 01                      dup.x1 sp(1)
	<.main+1374 @03dd3e> : 04 06 00 00                jmp <.main+1380 @03dd44>
	<.main+1378 @03dd42> : 10 00                      dup.x1 sp(0)
	<.main+1380 @03dd44> : 13 02                      set.x1 sp(2)
	<.main+1382 @03dd46> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@03dd4a> - <@03ddab>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1386 @03dd4a> : 10 25                      dup.x1 sp(37)
	<.main+1388 @03dd4c> : 0c 01 00 00                inc.i32(+1)
	<.main+1392 @03dd50> : 10 25                      dup.x1 sp(37)
	<.main+1394 @03dd52> : 0c 01 00 00                inc.i32(+1)
	<.main+1398 @03dd56> : 10 25                      dup.x1 sp(37)
	<.main+1400 @03dd58> : 0c 01 00 00                inc.i32(+1)
	<.main+1404 @03dd5c> : 10 25                      dup.x1 sp(37)
	<.main+1406 @03dd5e> : 0c 01 00 00                inc.i32(+1)
	<.main+1410 @03dd62> : 10 01                      dup.x1 sp(1)
	<.main+1412 @03dd64> : 10 01                      dup.x1 sp(1)
	<.main+1414 @03dd66> : 58                         clt.i32
	<.main+1415 @03dd67> : 06 0a 00 00                jz <.main+1425 @03dd71>
	<.main+1419 @03dd6b> : 10 01                      dup.x1 sp(1)
	<.main+1421 @03dd6d> : 04 06 00 00                jmp <.main+1427 @03dd73>
	<.main+1425 @03dd71> : 10 00                      dup.x1 sp(0)
	<.main+1427 @03dd73> : 13 02                      set.x1 sp(2)
	<.main+1429 @03dd75> : 09 fc ff ff                inc.sp(-4)
	<.main+1433 @03dd79> : 10 01                      dup.x1 sp(1)
	<.main+1435 @03dd7b> : 10 01                      dup.x1 sp(1)
	<.main+1437 @03dd7d> : 58                         clt.i32
	<.main+1438 @03dd7e> : 06 0a 00 00                jz <.main+1448 @03dd88>
	<.main+1442 @03dd82> : 10 01                      dup.x1 sp(1)
	<.main+1444 @03dd84> : 04 06 00 00                jmp <.main+1450 @03dd8a>
	<.main+1448 @03dd88> : 10 00                      dup.x1 sp(0)
	<.main+1450 @03dd8a> : 13 02                      set.x1 sp(2)
	<.main+1452 @03dd8c> : 09 fc ff ff                inc.sp(-4)
	<.main+1456 @03dd90> : 10 01                      dup.x1 sp(1)
	<.main+1458 @03dd92> : 10 01                      dup.x1 sp(1)
	<.main+1460 @03dd94> : 58                         clt.i32
	<.main+1461 @03dd95> : 06 0a 00 00                jz <.main+1471 @03dd9f>
	<.main+1465 @03dd99> : 10 01                      dup.x1 sp(1)
	<.main+1467 @03dd9b> : 04 06 00 00                jmp <.main+1473 @03dda1>
	<.main+1471 @03dd9f> : 10 00                      dup.x1 sp(0)
	<.main+1473 @03dda1> : 13 02                      set.x1 sp(2)
	<.main+1475 @03dda3> : 09 fc ff ff                inc.sp(-4)
	<.main+1479 @03dda7> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@03ddab> - <@03de0c>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1483 @03ddab> : 10 26                      dup.x1 sp(38)
	<.main+1485 @03ddad> : 0c 01 00 00                inc.i32(+1)
	<.main+1489 @03ddb1> : 10 26                      dup.x1 sp(38)
	<.main+1491 @03ddb3> : 0c 01 00 00                inc.i32(+1)
	<.main+1495 @03ddb7> : 10 01                      dup.x1 sp(1)
	<.main+1497 @03ddb9> : 10 01                      dup.x1 sp(1)
	<.main+1499 @03ddbb> : 58                         clt.i32
	<.main+1500 @03ddbc> : 06 0a 00 00                jz <.main+1510 @03ddc6>
	<.main+1504 @03ddc0> : 10 01                      dup.x1 sp(1)
	<.main+1506 @03ddc2> : 04 06 00 00                jmp <.main+1512 @03ddc8>
	<.main+1510 @03ddc6> : 10 00                      dup.x1 sp(0)
	<.main+1512 @03ddc8> : 13 02                      set.x1 sp(2)
	<.main+1514 @03ddca> : 09 fc ff ff                inc.sp(-4)
	<.main+1518 @03ddce> : 10 25                      dup.x1 sp(37)
	<.main+1520 @03ddd0> : 0c 01 00 00                inc.i32(+1)
	<.main+1524 @03ddd4> : 10 01                      dup.x1 sp(1)
	<.main+1526 @03ddd6> : 10 01                      dup.x1 sp(1)
	<.main+1528 @03ddd8> : 58                         clt.i32
	<.main+1529 @03ddd9> : 06 0a 00 00                jz <.main+1539 @03dde3>
	<.main+1533 @03dddd> : 10 01                      dup.x1 sp(1)
	<.main+1535 @03dddf> : 04 06 00 00                jmp <.main+1541 @03dde5>
	<.main+1539 @03dde3> : 10 00                      dup.x1 sp(0)
	<.main+1541 @03dde5> : 13 02                      set.x1 sp(2)
	<.main+1543 @03dde7> : 09 fc ff ff                inc.sp(-4)
	<.main+1547 @03ddeb> : 10 24                      dup.x1 sp(36)
	<.main+1549 @03dded> : 0c 01 00 00                inc.i32(+1)
	<.main+1553 @03ddf1> : 10 01                      dup.x1 sp(1)
	<.main+1555 @03ddf3> : 10 01                      dup.x1 sp(1)
	<.main+1557 @03ddf5> : 58                         clt.i32
	<.main+1558 @03ddf6> : 06 0a 00 00                jz <.main+1568 @03de00>
	<.main+1562 @03ddfa> : 10 01                      dup.x1 sp(1)
	<.main+1564 @03ddfc> : 04 06 00 00                jmp <.main+1570 @03de02>
	<.main+1568 @03de00> : 10 00                      dup.x1 sp(0)
	<.main+1570 @03de02> : 13 02                      set.x1 sp(2)
	<.main+1572 @03de04> : 09 fc ff ff                inc.sp(-4)
	<.main+1576 @03de08> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@03de0c> - <@03de65>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1580 @03de0c> : 1c 03 00 00 00             load.c32 3
	<.main+1585 @03de11> : 1c 06 00 00 00             load.c32 6
	<.main+1590 @03de16> : 1c 02 00 00 00             load.c32 2
	<.main+1595 @03de1b> : 1c 08 00 00 00             load.c32 8
	<.main+1600 @03de20> : 10 01                      dup.x1 sp(1)
	<.main+1602 @03de22> : 10 01                      dup.x1 sp(1)
	<.main+1604 @03de24> : 59                         cgt.i32
	<.main+1605 @03de25> : 06 0a 00 00                jz <.main+1615 @03de2f>
	<.main+1609 @03de29> : 10 01                      dup.x1 sp(1)
	<.main+1611 @03de2b> : 04 06 00 00                jmp <.main+1617 @03de31>
	<.main+1615 @03de2f> : 10 00                      dup.x1 sp(0)
	<.main+1617 @03de31> : 13 02                      set.x1 sp(2)
	<.main+1619 @03de33> : 09 fc ff ff                inc.sp(-4)
	<.main+1623 @03de37> : 10 01                      dup.x1 sp(1)
	<.main+1625 @03de39> : 10 01                      dup.x1 sp(1)
	<.main+1627 @03de3b> : 59                         cgt.i32
	<.main+1628 @03de3c> : 06 0a 00 00                jz <.main+1638 @03de46>
	<.main+1632 @03de40> : 10 01                      dup.x1 sp(1)
	<.main+1634 @03de42> : 04 06 00 00                jmp <.main+1640 @03de48>
	<.main+1638 @03de46> : 10 00                      dup.x1 sp(0)
	<.main+1640 @03de48> : 13 02                      set.x1 sp(2)
	<.main+1642 @03de4a> : 09 fc ff ff                inc.sp(-4)
	<.main+1646 @03de4e> : 10 01                      dup.x1 sp(1)
	<.main+1648 @03de50> : 10 01                      dup.x1 sp(1)
	<.main+1650 @03de52> : 59                         cgt.i32
	<.main+1651 @03de53> : 06 0a 00 00                jz <.main+1661 @03de5d>
	<.main+1655 @03de57> : 10 01                      dup.x1 sp(1)
	<.main+1657 @03de59> : 04 06 00 00                jmp <.main+1663 @03de5f>
	<.main+1661 @03de5d> : 10 00                      dup.x1 sp(0)
	<.main+1663 @03de5f> : 13 02                      set.x1 sp(2)
	<.main+1665 @03de61> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@03de65> - <@03debe>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1669 @03de65> : 1c 03 00 00 00             load.c32 3
	<.main+1674 @03de6a> : 1c 06 00 00 00             load.c32 6
	<.main+1679 @03de6f> : 10 01                      dup.x1 sp(1)
	<.main+1681 @03de71> : 10 01                      dup.x1 sp(1)
	<.main+1683 @03de73> : 59                         cgt.i32
	<.main+1684 @03de74> : 06 0a 00 00                jz <.main+1694 @03de7e>
	<.main+1688 @03de78> : 10 01                      dup.x1 sp(1)
	<.main+1690 @03de7a> : 04 06 00 00                jmp <.main+1696 @03de80>
	<.main+1694 @03de7e> : 10 00                      dup.x1 sp(0)
	<.main+1696 @03de80> : 13 02                      set.x1 sp(2)
	<.main+1698 @03de82> : 09 fc ff ff                inc.sp(-4)
	<.main+1702 @03de86> : 1c 02 00 00 00             load.c32 2
	<.main+1707 @03de8b> : 10 01                      dup.x1 sp(1)
	<.main+1709 @03de8d> : 10 01                      dup.x1 sp(1)
	<.main+1711 @03de8f> : 59                         cgt.i32
	<.main+1712 @03de90> : 06 0a 00 00                jz <.main+1722 @03de9a>
	<.main+1716 @03de94> : 10 01                      dup.x1 sp(1)
	<.main+1718 @03de96> : 04 06 00 00                jmp <.main+1724 @03de9c>
	<.main+1722 @03de9a> : 10 00                      dup.x1 sp(0)
	<.main+1724 @03de9c> : 13 02                      set.x1 sp(2)
	<.main+1726 @03de9e> : 09 fc ff ff                inc.sp(-4)
	<.main+1730 @03dea2> : 1c 08 00 00 00             load.c32 8
	<.main+1735 @03dea7> : 10 01                      dup.x1 sp(1)
	<.main+1737 @03dea9> : 10 01                      dup.x1 sp(1)
	<.main+1739 @03deab> : 59                         cgt.i32
	<.main+1740 @03deac> : 06 0a 00 00                jz <.main+1750 @03deb6>
	<.main+1744 @03deb0> : 10 01                      dup.x1 sp(1)
	<.main+1746 @03deb2> : 04 06 00 00                jmp <.main+1752 @03deb8>
	<.main+1750 @03deb6> : 10 00                      dup.x1 sp(0)
	<.main+1752 @03deb8> : 13 02                      set.x1 sp(2)
	<.main+1754 @03deba> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@03debe> - <@03df0b>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1758 @03debe> : 10 29                      dup.x1 sp(41)
	<.main+1760 @03dec0> : 10 29                      dup.x1 sp(41)
	<.main+1762 @03dec2> : 10 29                      dup.x1 sp(41)
	<.main+1764 @03dec4> : 10 29                      dup.x1 sp(41)
	<.main+1766 @03dec6> : 10 01                      dup.x1 sp(1)
	<.main+1768 @03dec8> : 10 01                      dup.x1 sp(1)
	<.main+1770 @03deca> : 59                         cgt.i32
	<.main+1771 @03decb> : 06 0a 00 00                jz <.main+1781 @03ded5>
	<.main+1775 @03decf> : 10 01                      dup.x1 sp(1)
	<.main+1777 @03ded1> : 04 06 00 00                jmp <.main+1783 @03ded7>
	<.main+1781 @03ded5> : 10 00                      dup.x1 sp(0)
	<.main+1783 @03ded7> : 13 02                      set.x1 sp(2)
	<.main+1785 @03ded9> : 09 fc ff ff                inc.sp(-4)
	<.main+1789 @03dedd> : 10 01                      dup.x1 sp(1)
	<.main+1791 @03dedf> : 10 01                      dup.x1 sp(1)
	<.main+1793 @03dee1> : 59                         cgt.i32
	<.main+1794 @03dee2> : 06 0a 00 00                jz <.main+1804 @03deec>
	<.main+1798 @03dee6> : 10 01                      dup.x1 sp(1)
	<.main+1800 @03dee8> : 04 06 00 00                jmp <.main+1806 @03deee>
	<.main+1804 @03deec> : 10 00                      dup.x1 sp(0)
	<.main+1806 @03deee> : 13 02                      set.x1 sp(2)
	<.main+1808 @03def0> : 09 fc ff ff                inc.sp(-4)
	<.main+1812 @03def4> : 10 01                      dup.x1 sp(1)
	<.main+1814 @03def6> : 10 01                      dup.x1 sp(1)
	<.main+1816 @03def8> : 59                         cgt.i32
	<.main+1817 @03def9> : 06 0a 00 00                jz <.main+1827 @03df03>
	<.main+1821 @03defd> : 10 01                      dup.x1 sp(1)
	<.main+1823 @03deff> : 04 06 00 00                jmp <.main+1829 @03df05>
	<.main+1827 @03df03> : 10 00                      dup.x1 sp(0)
	<.main+1829 @03df05> : 13 02                      set.x1 sp(2)
	<.main+1831 @03df07> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@03df0b> - <@03df58>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1835 @03df0b> : 10 2a                      dup.x1 sp(42)
	<.main+1837 @03df0d> : 10 2a                      dup.x1 sp(42)
	<.main+1839 @03df0f> : 10 01                      dup.x1 sp(1)
	<.main+1841 @03df11> : 10 01                      dup.x1 sp(1)
	<.main+1843 @03df13> : 59                         cgt.i32
	<.main+1844 @03df14> : 06 0a 00 00                jz <.main+1854 @03df1e>
	<.main+1848 @03df18> : 10 01                      dup.x1 sp(1)
	<.main+1850 @03df1a> : 04 06 00 00                jmp <.main+1856 @03df20>
	<.main+1854 @03df1e> : 10 00                      dup.x1 sp(0)
	<.main+1856 @03df20> : 13 02                      set.x1 sp(2)
	<.main+1858 @03df22> : 09 fc ff ff                inc.sp(-4)
	<.main+1862 @03df26> : 10 29                      dup.x1 sp(41)
	<.main+1864 @03df28> : 10 01                      dup.x1 sp(1)
	<.main+1866 @03df2a> : 10 01                      dup.x1 sp(1)
	<.main+1868 @03df2c> : 59                         cgt.i32
	<.main+1869 @03df2d> : 06 0a 00 00                jz <.main+1879 @03df37>
	<.main+1873 @03df31> : 10 01                      dup.x1 sp(1)
	<.main+1875 @03df33> : 04 06 00 00                jmp <.main+1881 @03df39>
	<.main+1879 @03df37> : 10 00                      dup.x1 sp(0)
	<.main+1881 @03df39> : 13 02                      set.x1 sp(2)
	<.main+1883 @03df3b> : 09 fc ff ff                inc.sp(-4)
	<.main+1887 @03df3f> : 10 28                      dup.x1 sp(40)
	<.main+1889 @03df41> : 10 01                      dup.x1 sp(1)
	<.main+1891 @03df43> : 10 01                      dup.x1 sp(1)
	<.main+1893 @03df45> : 59                         cgt.i32
	<.main+1894 @03df46> : 06 0a 00 00                jz <.main+1904 @03df50>
	<.main+1898 @03df4a> : 10 01                      dup.x1 sp(1)
	<.main+1900 @03df4c> : 04 06 00 00                jmp <.main+1906 @03df52>
	<.main+1904 @03df50> : 10 00                      dup.x1 sp(0)
	<.main+1906 @03df52> : 13 02                      set.x1 sp(2)
	<.main+1908 @03df54> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@03df58> - <@03dfb9>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1912 @03df58> : 10 2b                      dup.x1 sp(43)
	<.main+1914 @03df5a> : 0c 01 00 00                inc.i32(+1)
	<.main+1918 @03df5e> : 10 2b                      dup.x1 sp(43)
	<.main+1920 @03df60> : 0c 01 00 00                inc.i32(+1)
	<.main+1924 @03df64> : 10 2b                      dup.x1 sp(43)
	<.main+1926 @03df66> : 0c 01 00 00                inc.i32(+1)
	<.main+1930 @03df6a> : 10 2b                      dup.x1 sp(43)
	<.main+1932 @03df6c> : 0c 01 00 00                inc.i32(+1)
	<.main+1936 @03df70> : 10 01                      dup.x1 sp(1)
	<.main+1938 @03df72> : 10 01                      dup.x1 sp(1)
	<.main+1940 @03df74> : 59                         cgt.i32
	<.main+1941 @03df75> : 06 0a 00 00                jz <.main+1951 @03df7f>
	<.main+1945 @03df79> : 10 01                      dup.x1 sp(1)
	<.main+1947 @03df7b> : 04 06 00 00                jmp <.main+1953 @03df81>
	<.main+1951 @03df7f> : 10 00                      dup.x1 sp(0)
	<.main+1953 @03df81> : 13 02                      set.x1 sp(2)
	<.main+1955 @03df83> : 09 fc ff ff                inc.sp(-4)
	<.main+1959 @03df87> : 10 01                      dup.x1 sp(1)
	<.main+1961 @03df89> : 10 01                      dup.x1 sp(1)
	<.main+1963 @03df8b> : 59                         cgt.i32
	<.main+1964 @03df8c> : 06 0a 00 00                jz <.main+1974 @03df96>
	<.main+1968 @03df90> : 10 01                      dup.x1 sp(1)
	<.main+1970 @03df92> : 04 06 00 00                jmp <.main+1976 @03df98>
	<.main+1974 @03df96> : 10 00                      dup.x1 sp(0)
	<.main+1976 @03df98> : 13 02                      set.x1 sp(2)
	<.main+1978 @03df9a> : 09 fc ff ff                inc.sp(-4)
	<.main+1982 @03df9e> : 10 01                      dup.x1 sp(1)
	<.main+1984 @03dfa0> : 10 01                      dup.x1 sp(1)
	<.main+1986 @03dfa2> : 59                         cgt.i32
	<.main+1987 @03dfa3> : 06 0a 00 00                jz <.main+1997 @03dfad>
	<.main+1991 @03dfa7> : 10 01                      dup.x1 sp(1)
	<.main+1993 @03dfa9> : 04 06 00 00                jmp <.main+1999 @03dfaf>
	<.main+1997 @03dfad> : 10 00                      dup.x1 sp(0)
	<.main+1999 @03dfaf> : 13 02                      set.x1 sp(2)
	<.main+2001 @03dfb1> : 09 fc ff ff                inc.sp(-4)
	<.main+2005 @03dfb5> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@03dfb9> - <@03e01a>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2009 @03dfb9> : 10 2c                      dup.x1 sp(44)
	<.main+2011 @03dfbb> : 0c 01 00 00                inc.i32(+1)
	<.main+2015 @03dfbf> : 10 2c                      dup.x1 sp(44)
	<.main+2017 @03dfc1> : 0c 01 00 00                inc.i32(+1)
	<.main+2021 @03dfc5> : 10 01                      dup.x1 sp(1)
	<.main+2023 @03dfc7> : 10 01                      dup.x1 sp(1)
	<.main+2025 @03dfc9> : 59                         cgt.i32
	<.main+2026 @03dfca> : 06 0a 00 00                jz <.main+2036 @03dfd4>
	<.main+2030 @03dfce> : 10 01                      dup.x1 sp(1)
	<.main+2032 @03dfd0> : 04 06 00 00                jmp <.main+2038 @03dfd6>
	<.main+2036 @03dfd4> : 10 00                      dup.x1 sp(0)
	<.main+2038 @03dfd6> : 13 02                      set.x1 sp(2)
	<.main+2040 @03dfd8> : 09 fc ff ff                inc.sp(-4)
	<.main+2044 @03dfdc> : 10 2b                      dup.x1 sp(43)
	<.main+2046 @03dfde> : 0c 01 00 00                inc.i32(+1)
	<.main+2050 @03dfe2> : 10 01                      dup.x1 sp(1)
	<.main+2052 @03dfe4> : 10 01                      dup.x1 sp(1)
	<.main+2054 @03dfe6> : 59                         cgt.i32
	<.main+2055 @03dfe7> : 06 0a 00 00                jz <.main+2065 @03dff1>
	<.main+2059 @03dfeb> : 10 01                      dup.x1 sp(1)
	<.main+2061 @03dfed> : 04 06 00 00                jmp <.main+2067 @03dff3>
	<.main+2065 @03dff1> : 10 00                      dup.x1 sp(0)
	<.main+2067 @03dff3> : 13 02                      set.x1 sp(2)
	<.main+2069 @03dff5> : 09 fc ff ff                inc.sp(-4)
	<.main+2073 @03dff9> : 10 2a                      dup.x1 sp(42)
	<.main+2075 @03dffb> : 0c 01 00 00                inc.i32(+1)
	<.main+2079 @03dfff> : 10 01                      dup.x1 sp(1)
	<.main+2081 @03e001> : 10 01                      dup.x1 sp(1)
	<.main+2083 @03e003> : 59                         cgt.i32
	<.main+2084 @03e004> : 06 0a 00 00                jz <.main+2094 @03e00e>
	<.main+2088 @03e008> : 10 01                      dup.x1 sp(1)
	<.main+2090 @03e00a> : 04 06 00 00                jmp <.main+2096 @03e010>
	<.main+2094 @03e00e> : 10 00                      dup.x1 sp(0)
	<.main+2096 @03e010> : 13 02                      set.x1 sp(2)
	<.main+2098 @03e012> : 09 fc ff ff                inc.sp(-4)
	<.main+2102 @03e016> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@03e01a> - <@03e01f>): overload1: float32 := overload
	<.main+2106 @03e01a> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@03e01f> - <@03e024>): overload2: float32 := overload()
	<.main+2111 @03e01f> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@03e024> - <@03e029>): overload3: float32 := overload(0)
	<.main+2116 @03e024> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@03e029> - <@03e02e>): overload4: float32 := overload(0.000000)
	<.main+2121 @03e029> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@03e02e> - <@03e033>): overload5: float32 := overload(void(0, 0))
	<.main+2126 @03e02e> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@03e033> - <@03e03c>): boilC: Celsius := Celsius(100.000000)
	<.main+2131 @03e033> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@03e03c> - <@03e052>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2140 @03e03c> : 11 00                      dup.x2 sp(0)
	<.main+2142 @03e03e> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2151 @03e047> : 83                         mul.f64
	<.main+2152 @03e048> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2161 @03e051> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@03e052> - <@03e057>): valueRef: int64 := value
	<.main+2162 @03e052> : 1f a0 d5 03 00             load.ref <@03d5a0> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@03e057> - <@03e05c>): valuePtr: pointer := value
	<.main+2167 @03e057> : 1f a0 d5 03 00             load.ref <@03d5a0> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@03e05c> - <@03e066>): valueVar: variant := value
	<.main+2172 @03e05c> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2177 @03e061> : 1f a0 d5 03 00             load.ref <@03d5a0> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@03e066> - <@03e069>): fromRef: int64 := valueRef
	<.main+2182 @03e066> : 10 03                      dup.x1 sp(3)
	<.main+2184 @03e068> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@03e069> - <@03e06b>): fromPtr: int64 := valuePtr
	<.main+2185 @03e069> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@03e06b> - <@03e06d>): fromVar: int64 := valueVar
	<.main+2187 @03e06b> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@03e06d> - <@03e072>): nullRef: int64 := null
	<.main+2189 @03e06d> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@03e072> - <@03e077>): nullPtr: pointer := null
	<.main+2194 @03e072> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@03e077> - <@03e081>): nullVar: variant := null
	<.main+2199 @03e077> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2204 @03e07c> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@03e081> - <@03e086>): nullTyp: typename := null
	<.main+2209 @03e081> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@03e086> - <@03e08b>): nullFun: function := null
	<.main+2214 @03e086> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@03e08b> - <@03e090>): nullObj: object := null
	<.main+2219 @03e08b> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@03e090> - <@03e095>): typePtr: pointer := int64
	<.main+2224 @03e090> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@03e095> - <@03e09f>): typeVar: variant := int64
	<.main+2229 @03e095> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2234 @03e09a> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@03e09f> - <@03e0a4>): typeTyp: typename := int64
	<.main+2239 @03e09f> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@03e0a4> - <@03e0a8>): local: int64 := value
	<.main+2244 @03e0a4> : 2b a0 d5 03                load.m64 <@03d5a0> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@03e0a8> - <@03e0aa>): copyVal: int64 := local
	<.main+2248 @03e0a8> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@03e0aa> - <@03e0ac>): copyRef: int64 := valueRef
	<.main+2250 @03e0aa> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@03e0ac> - <@03e0ae>): copyPtr: pointer := valuePtr
	<.main+2252 @03e0ac> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@03e0ae> - <@03e0b0>): copyVar: variant := valueVar
	<.main+2254 @03e0ae> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@03e0b0> - <@03e0b2>): copyTyp: typename := typeTyp
	<.main+2256 @03e0b0> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@03e0b2> - <@03e0b7>): ptrVoid: pointer := void
	<.main+2258 @03e0b2> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@03e0b7> - <@03e0bc>): ptrBool: pointer := bool
	<.main+2263 @03e0b7> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@03e0bc> - <@03e0c1>): ptrChar: pointer := char
	<.main+2268 @03e0bc> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@03e0c1> - <@03e0c6>): ptrInt8: pointer := int8
	<.main+2273 @03e0c1> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@03e0c6> - <@03e0cb>): ptrInt16: pointer := int16
	<.main+2278 @03e0c6> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@03e0cb> - <@03e0d0>): ptrInt32: pointer := int32
	<.main+2283 @03e0cb> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@03e0d0> - <@03e0d5>): ptrInt64: pointer := int64
	<.main+2288 @03e0d0> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@03e0d5> - <@03e0da>): ptrUint8: pointer := uint8
	<.main+2293 @03e0d5> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@03e0da> - <@03e0df>): ptrUint16: pointer := uint16
	<.main+2298 @03e0da> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@03e0df> - <@03e0e4>): ptrUint32: pointer := uint32
	<.main+2303 @03e0df> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@03e0e4> - <@03e0e9>): ptrUint64: pointer := uint64
	<.main+2308 @03e0e4> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@03e0e9> - <@03e0ee>): ptrFloat32: pointer := float32
	<.main+2313 @03e0e9> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@03e0ee> - <@03e0f3>): ptrFloat64: pointer := float64
	<.main+2318 @03e0ee> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@03e0f3> - <@03e0f8>): ptrTypename: pointer := typename
	<.main+2323 @03e0f3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@03e0f8> - <@03e0fd>): ptrFunction: pointer := function
	<.main+2328 @03e0f8> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@03e0fd> - <@03e102>): ptrPointer: pointer := pointer
	<.main+2333 @03e0fd> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@03e102> - <@03e107>): ptrVariant: pointer := variant
	<.main+2338 @03e102> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@03e107> - <@03e10c>): ptrObject: pointer := object
	<.main+2343 @03e107> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@03e10c> - <@03e116>): varVoid: variant := void
	<.main+2348 @03e10c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2353 @03e111> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@03e116> - <@03e120>): varBool: variant := bool
	<.main+2358 @03e116> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2363 @03e11b> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@03e120> - <@03e12a>): varChar: variant := char
	<.main+2368 @03e120> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2373 @03e125> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@03e12a> - <@03e134>): varInt8: variant := int8
	<.main+2378 @03e12a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2383 @03e12f> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@03e134> - <@03e13e>): varInt16: variant := int16
	<.main+2388 @03e134> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2393 @03e139> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@03e13e> - <@03e148>): varInt32: variant := int32
	<.main+2398 @03e13e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2403 @03e143> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@03e148> - <@03e152>): varInt64: variant := int64
	<.main+2408 @03e148> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2413 @03e14d> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@03e152> - <@03e15c>): varUint8: variant := uint8
	<.main+2418 @03e152> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2423 @03e157> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@03e15c> - <@03e166>): varUint16: variant := uint16
	<.main+2428 @03e15c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2433 @03e161> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@03e166> - <@03e170>): varUint32: variant := uint32
	<.main+2438 @03e166> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2443 @03e16b> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@03e170> - <@03e17a>): varUint64: variant := uint64
	<.main+2448 @03e170> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2453 @03e175> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@03e17a> - <@03e184>): varFloat32: variant := float32
	<.main+2458 @03e17a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2463 @03e17f> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@03e184> - <@03e18e>): varFloat64: variant := float64
	<.main+2468 @03e184> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2473 @03e189> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@03e18e> - <@03e198>): varTypename: variant := typename
	<.main+2478 @03e18e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2483 @03e193> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@03e198> - <@03e1a2>): varFunction: variant := function
	<.main+2488 @03e198> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2493 @03e19d> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@03e1a2> - <@03e1ac>): varPointer: variant := pointer
	<.main+2498 @03e1a2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2503 @03e1a7> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@03e1ac> - <@03e1b6>): varVariant: variant := variant
	<.main+2508 @03e1ac> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2513 @03e1b1> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@03e1b6> - <@03e1c0>): varObject: variant := object
	<.main+2518 @03e1b6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2523 @03e1bb> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@03e1c0> - <@03e1c5>): typVoid: typename := void
	<.main+2528 @03e1c0> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@03e1c5> - <@03e1ca>): typBool: typename := bool
	<.main+2533 @03e1c5> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@03e1ca> - <@03e1cf>): typChar: typename := char
	<.main+2538 @03e1ca> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@03e1cf> - <@03e1d4>): typInt8: typename := int8
	<.main+2543 @03e1cf> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@03e1d4> - <@03e1d9>): typInt16: typename := int16
	<.main+2548 @03e1d4> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@03e1d9> - <@03e1de>): typInt32: typename := int32
	<.main+2553 @03e1d9> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@03e1de> - <@03e1e3>): typInt64: typename := int64
	<.main+2558 @03e1de> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@03e1e3> - <@03e1e8>): typUint8: typename := uint8
	<.main+2563 @03e1e3> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@03e1e8> - <@03e1ed>): typUint16: typename := uint16
	<.main+2568 @03e1e8> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@03e1ed> - <@03e1f2>): typUint32: typename := uint32
	<.main+2573 @03e1ed> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@03e1f2> - <@03e1f7>): typUint64: typename := uint64
	<.main+2578 @03e1f2> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@03e1f7> - <@03e1fc>): typFloat32: typename := float32
	<.main+2583 @03e1f7> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@03e1fc> - <@03e201>): typFloat64: typename := float64
	<.main+2588 @03e1fc> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@03e201> - <@03e206>): typTypename: typename := typename
	<.main+2593 @03e201> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@03e206> - <@03e20b>): typFunction: typename := function
	<.main+2598 @03e206> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@03e20b> - <@03e210>): typPointer: typename := pointer
	<.main+2603 @03e20b> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@03e210> - <@03e215>): typVariant: typename := variant
	<.main+2608 @03e210> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@03e215> - <@03e21a>): typObject: typename := object
	<.main+2613 @03e215> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@03e21a> - <@03e21f>): valueOfPtr: pointer := pointer(value)
	<.main+2618 @03e21a> : 1f a0 d5 03 00             load.ref <@03d5a0> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@03e21f> - <@03e229>): valueOfVar: variant := variant(value)
	<.main+2623 @03e21f> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2628 @03e224> : 1f a0 d5 03 00             load.ref <@03d5a0> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@03e229> - <@03e22e>): valueOfTyp: typename := typename(value)
	<.main+2633 @03e229> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@03e22e> - <@03e233>): typeOfValue: typename := typename(value)
	<.main+2638 @03e22e> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@03e233> - <@03e23a>): copyPtrFloat64: variant := ptrFloat64
	<.main+2643 @03e233> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2648 @03e238> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@03e23a> - <@03e23c>): copyVarFloat64: pointer := varFloat64
	<.main+2650 @03e23a> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@03e23c> - <@03e251>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2652 @03e23c> : 19                         load.z32
	<.main+2653 @03e23d> : 1c 02 00 00 00             load.c32 2
	<.main+2658 @03e242> : 1c 07 00 00 00             load.c32 7
	<.main+2663 @03e247> : 1f b0 d5 03 00             load.ref <@03d5b0> ;funAdd(x: int32, y: int32): int32
	<.main+2668 @03e24c> : 02                         call
	<.main+2669 @03e24d> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@03e251> - <@03e256>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2673 @03e251> : 1f b0 d5 03 00             load.ref <@03d5b0> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@03e256> - <@03e268>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2678 @03e256> : 19                         load.z32
	<.main+2679 @03e257> : 1c 02 00 00 00             load.c32 2
	<.main+2684 @03e25c> : 1c 08 00 00 00             load.c32 8
	<.main+2689 @03e261> : 10 03                      dup.x1 sp(3)
	<.main+2691 @03e263> : 02                         call
	<.main+2692 @03e264> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@03e268> - <@03e26d>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2696 @03e268> : 1f b8 d5 03 00             load.ref <@03d5b8> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@03e26d> - <@03e27f>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2701 @03e26d> : 19                         load.z32
	<.main+2702 @03e26e> : 1c 02 00 00 00             load.c32 2
	<.main+2707 @03e273> : 1c 06 00 00 00             load.c32 6
	<.main+2712 @03e278> : 10 03                      dup.x1 sp(3)
	<.main+2714 @03e27a> : 02                         call
	<.main+2715 @03e27b> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@03e27f> - <@03e281>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2719 @03e27f> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@03e281> - <@03e293>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2721 @03e281> : 19                         load.z32
	<.main+2722 @03e282> : 1c 02 00 00 00             load.c32 2
	<.main+2727 @03e287> : 1c 07 00 00 00             load.c32 7
	<.main+2732 @03e28c> : 10 03                      dup.x1 sp(3)
	<.main+2734 @03e28e> : 02                         call
	<.main+2735 @03e28f> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@03e293> - <@03e2a3>): fibonacci_13: uint32 := fib(13)
	<.main+2739 @03e293> : 19                         load.z32
	<.main+2740 @03e294> : 1c 0d 00 00 00             load.c32 13
	<.main+2745 @03e299> : 1f c0 d5 03 00             load.ref <@03d5c0> ;fib(n: uint32): uint32
	<.main+2750 @03e29e> : 02                         call
	<.main+2751 @03e29f> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@03e2a3> - <@03e2a7>): sizeofVoid: int32 := sizeof(void)
	<.main+2755 @03e2a3> : 2a b8 00 00                load.m32 <@0000b8>
	test/lang/reflect.ci:4: (4 bytes: <@03e2a7> - <@03e2ab>): sizeofBool: int32 := sizeof(bool)
	<.main+2759 @03e2a7> : 2a 48 01 00                load.m32 <@000148>
	test/lang/reflect.ci:5: (4 bytes: <@03e2ab> - <@03e2af>): sizeofChar: int32 := sizeof(char)
	<.main+2763 @03e2ab> : 2a d8 01 00                load.m32 <@0001d8>
	test/lang/reflect.ci:6: (4 bytes: <@03e2af> - <@03e2b3>): sizeofInt8: int32 := sizeof(int8)
	<.main+2767 @03e2af> : 2a 68 02 00                load.m32 <@000268>
	test/lang/reflect.ci:7: (4 bytes: <@03e2b3> - <@03e2b7>): sizeofInt16: int32 := sizeof(int16)
	<.main+2771 @03e2b3> : 2a f8 02 00                load.m32 <@0002f8>
	test/lang/reflect.ci:8: (4 bytes: <@03e2b7> - <@03e2bb>): sizeofInt32: int32 := sizeof(int32)
	<.main+2775 @03e2b7> : 2a 88 03 00                load.m32 <@000388>
	test/lang/reflect.ci:9: (4 bytes: <@03e2bb> - <@03e2bf>): sizeofInt64: int32 := sizeof(int64)
	<.main+2779 @03e2bb> : 2a 18 04 00                load.m32 <@000418>
	test/lang/reflect.ci:10: (4 bytes: <@03e2bf> - <@03e2c3>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2783 @03e2bf> : 2a a8 04 00                load.m32 <@0004a8>
	test/lang/reflect.ci:11: (4 bytes: <@03e2c3> - <@03e2c7>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2787 @03e2c3> : 2a 38 05 00                load.m32 <@000538>
	test/lang/reflect.ci:12: (4 bytes: <@03e2c7> - <@03e2cb>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2791 @03e2c7> : 2a c8 05 00                load.m32 <@0005c8>
	test/lang/reflect.ci:13: (4 bytes: <@03e2cb> - <@03e2cf>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2795 @03e2cb> : 2a 58 06 00                load.m32 <@000658>
	test/lang/reflect.ci:14: (4 bytes: <@03e2cf> - <@03e2d3>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2799 @03e2cf> : 2a e8 06 00                load.m32 <@0006e8>
	test/lang/reflect.ci:15: (4 bytes: <@03e2d3> - <@03e2d7>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2803 @03e2d3> : 2a 78 07 00                load.m32 <@000778>
	test/lang/reflect.ci:16: (4 bytes: <@03e2d7> - <@03e2db>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2807 @03e2d7> : 2a 08 08 00                load.m32 <@000808>
	test/lang/reflect.ci:17: (4 bytes: <@03e2db> - <@03e2df>): sizeofVariant: int32 := sizeof(variant)
	<.main+2811 @03e2db> : 2a 98 08 00                load.m32 <@000898>
	test/lang/reflect.ci:18: (4 bytes: <@03e2df> - <@03e2e3>): sizeofTypename: int32 := sizeof(typename)
	<.main+2815 @03e2df> : 2a 20 00 00                load.m32 <@000020> ;typename+24
	test/lang/reflect.ci:19: (4 bytes: <@03e2e3> - <@03e2e7>): sizeofFunction: int32 := sizeof(function)
	<.main+2819 @03e2e3> : 2a 28 09 00                load.m32 <@000928>
	test/lang/reflect.ci:20: (4 bytes: <@03e2e7> - <@03e2eb>): sizeofObject: int32 := sizeof(object)
	<.main+2823 @03e2e7> : 2a c0 09 00                load.m32 <@0009c0>
	test/lang/reflect.ci:30: (5 bytes: <@03e2eb> - <@03e2f0>): typeofRecord: typename := RecordSizeofExt
	<.main+2827 @03e2eb> : 1f f0 8f 02 00             load.ref <@028ff0> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@03e2f0> - <@03e2f6>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2832 @03e2f0> : 10 00                      dup.x1 sp(0)
	<.main+2834 @03e2f2> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@03e2f6> - <@03e2fd>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2838 @03e2f6> : 10 01                      dup.x1 sp(1)
	<.main+2840 @03e2f8> : 0c 20 00 00                inc.i32(+32)
	<.main+2844 @03e2fc> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@03e2fd> - <@03e304>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2845 @03e2fd> : 10 02                      dup.x1 sp(2)
	<.main+2847 @03e2ff> : 0c 18 00 00                inc.i32(+24)
	<.main+2851 @03e303> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@03e304> - <@03e30a>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2852 @03e304> : 10 03                      dup.x1 sp(3)
	<.main+2854 @03e306> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@03e30a> - <@03e310>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2858 @03e30a> : 10 04                      dup.x1 sp(4)
	<.main+2860 @03e30c> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@03e310> - <@03e316>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2864 @03e310> : 10 05                      dup.x1 sp(5)
	<.main+2866 @03e312> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@03e316> - <@03e31c>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2870 @03e316> : 10 00                      dup.x1 sp(0)
	<.main+2872 @03e318> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@03e31c> - <@03e323>): offsetOfBase: int32 := typeofBase.offset
	<.main+2876 @03e31c> : 10 01                      dup.x1 sp(1)
	<.main+2878 @03e31e> : 0c 20 00 00                inc.i32(+32)
	<.main+2882 @03e322> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@03e323> - <@03e32a>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2883 @03e323> : 10 02                      dup.x1 sp(2)
	<.main+2885 @03e325> : 0c 18 00 00                inc.i32(+24)
	<.main+2889 @03e329> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@03e32a> - <@03e330>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2890 @03e32a> : 10 03                      dup.x1 sp(3)
	<.main+2892 @03e32c> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@03e330> - <@03e336>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2896 @03e330> : 10 04                      dup.x1 sp(4)
	<.main+2898 @03e332> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@03e336> - <@03e33c>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2902 @03e336> : 10 05                      dup.x1 sp(5)
	<.main+2904 @03e338> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@03e33c> - <@03e343>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2908 @03e33c> : 10 00                      dup.x1 sp(0)
	<.main+2910 @03e33e> : 0c 20 00 00                inc.i32(+32)
	<.main+2914 @03e342> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@03e343> - <@03e34a>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2915 @03e343> : 10 01                      dup.x1 sp(1)
	<.main+2917 @03e345> : 0c 18 00 00                inc.i32(+24)
	<.main+2921 @03e349> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@03e34a> - <@03e350>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2922 @03e34a> : 10 02                      dup.x1 sp(2)
	<.main+2924 @03e34c> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@03e350> - <@03e357>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2928 @03e350> : 10 00                      dup.x1 sp(0)
	<.main+2930 @03e352> : 0c 20 00 00                inc.i32(+32)
	<.main+2934 @03e356> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@03e357> - <@03e35e>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2935 @03e357> : 10 01                      dup.x1 sp(1)
	<.main+2937 @03e359> : 0c 18 00 00                inc.i32(+24)
	<.main+2941 @03e35d> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@03e35e> - <@03e367>): pi64: float64 := 3.141593
	<.main+2942 @03e35e> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@03e367> - <@03e370>): e64: float64 := 2.718282
	<.main+2951 @03e367> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@03e370> - <@03e373>): pi32: float32 := pi64
	<.main+2960 @03e370> : 11 02                      dup.x2 sp(2)
	<.main+2962 @03e372> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@03e373> - <@03e376>): e32: float32 := e64
	<.main+2963 @03e373> : 11 01                      dup.x2 sp(1)
	<.main+2965 @03e375> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@03e376> - <@03e37d>): r_comp: int32 := int32(14 << 3)
	<.main+2966 @03e376> : 1c 0e 00 00 00             load.c32 14
	<.main+2971 @03e37b> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@03e37d> - <@03e384>): g_comp: int32 := int32(63 << 2)
	<.main+2973 @03e37d> : 1c 3f 00 00 00             load.c32 63
	<.main+2978 @03e382> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@03e384> - <@03e38b>): b_comp: int32 := int32(31 << 3)
	<.main+2980 @03e384> : 1c 1f 00 00 00             load.c32 31
	<.main+2985 @03e389> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@03e38b> - <@03e3a7>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2987 @03e38b> : 10 02                      dup.x1 sp(2)
	<.main+2989 @03e38d> : 3f 48                      b32.shl 0x008
	<.main+2991 @03e38f> : 1c 00 f8 00 00             load.c32 63488
	<.main+2996 @03e394> : 31                         and.b32
	<.main+2997 @03e395> : 10 02                      dup.x1 sp(2)
	<.main+2999 @03e397> : 3f 43                      b32.shl 0x003
	<.main+3001 @03e399> : 1c e0 07 00 00             load.c32 2016
	<.main+3006 @03e39e> : 31                         and.b32
	<.main+3007 @03e39f> : 32                         or.b32
	<.main+3008 @03e3a0> : 10 01                      dup.x1 sp(1)
	<.main+3010 @03e3a2> : 3f c3                      b32.sar 0x003
	<.main+3012 @03e3a4> : 3f 05                      b32.and 0x01f
	<.main+3014 @03e3a6> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@03e3a7> - <@03e3c1>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3015 @03e3a7> : 10 03                      dup.x1 sp(3)
	<.main+3017 @03e3a9> : 3f 50                      b32.shl 0x010
	<.main+3019 @03e3ab> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3024 @03e3b0> : 31                         and.b32
	<.main+3025 @03e3b1> : 10 03                      dup.x1 sp(3)
	<.main+3027 @03e3b3> : 3f 48                      b32.shl 0x008
	<.main+3029 @03e3b5> : 1c 00 ff 00 00             load.c32 65280
	<.main+3034 @03e3ba> : 31                         and.b32
	<.main+3035 @03e3bb> : 32                         or.b32
	<.main+3036 @03e3bc> : 10 02                      dup.x1 sp(2)
	<.main+3038 @03e3be> : 3f 08                      b32.and 0x0ff
	<.main+3040 @03e3c0> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@03e3c1> - <@03e3d1>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3041 @03e3c1> : 10 01                      dup.x1 sp(1)
	<.main+3043 @03e3c3> : 1c 0b 00 00 00             load.c32 11
	<.main+3048 @03e3c8> : 1c 05 00 00 00             load.c32 5
	<.main+3053 @03e3cd> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@03e3d1> - <@03e3e1>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3057 @03e3d1> : 10 02                      dup.x1 sp(2)
	<.main+3059 @03e3d3> : 1c 05 00 00 00             load.c32 5
	<.main+3064 @03e3d8> : 1c 06 00 00 00             load.c32 6
	<.main+3069 @03e3dd> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@03e3e1> - <@03e3ed>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3073 @03e3e1> : 10 03                      dup.x1 sp(3)
	<.main+3075 @03e3e3> : 19                         load.z32
	<.main+3076 @03e3e4> : 1c 05 00 00 00             load.c32 5
	<.main+3081 @03e3e9> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@03e3ed> - <@03e3fd>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3085 @03e3ed> : 10 04                      dup.x1 sp(4)
	<.main+3087 @03e3ef> : 1c 0b 00 00 00             load.c32 11
	<.main+3092 @03e3f4> : 1c 05 00 00 00             load.c32 5
	<.main+3097 @03e3f9> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@03e3fd> - <@03e40d>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3101 @03e3fd> : 10 05                      dup.x1 sp(5)
	<.main+3103 @03e3ff> : 1c 05 00 00 00             load.c32 5
	<.main+3108 @03e404> : 1c 06 00 00 00             load.c32 6
	<.main+3113 @03e409> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@03e40d> - <@03e419>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3117 @03e40d> : 10 06                      dup.x1 sp(6)
	<.main+3119 @03e40f> : 19                         load.z32
	<.main+3120 @03e410> : 1c 05 00 00 00             load.c32 5
	<.main+3125 @03e415> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@03e419> - <@03e429>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3129 @03e419> : 10 06                      dup.x1 sp(6)
	<.main+3131 @03e41b> : 1c 10 00 00 00             load.c32 16
	<.main+3136 @03e420> : 1c 08 00 00 00             load.c32 8
	<.main+3141 @03e425> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@03e429> - <@03e439>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3145 @03e429> : 10 07                      dup.x1 sp(7)
	<.main+3147 @03e42b> : 1c 08 00 00 00             load.c32 8
	<.main+3152 @03e430> : 1c 08 00 00 00             load.c32 8
	<.main+3157 @03e435> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@03e439> - <@03e445>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3161 @03e439> : 10 08                      dup.x1 sp(8)
	<.main+3163 @03e43b> : 19                         load.z32
	<.main+3164 @03e43c> : 1c 08 00 00 00             load.c32 8
	<.main+3169 @03e441> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@03e445> - <@03e455>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3173 @03e445> : 10 09                      dup.x1 sp(9)
	<.main+3175 @03e447> : 1c 10 00 00 00             load.c32 16
	<.main+3180 @03e44c> : 1c 08 00 00 00             load.c32 8
	<.main+3185 @03e451> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@03e455> - <@03e465>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3189 @03e455> : 10 0a                      dup.x1 sp(10)
	<.main+3191 @03e457> : 1c 08 00 00 00             load.c32 8
	<.main+3196 @03e45c> : 1c 08 00 00 00             load.c32 8
	<.main+3201 @03e461> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@03e465> - <@03e471>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3205 @03e465> : 10 0b                      dup.x1 sp(11)
	<.main+3207 @03e467> : 19                         load.z32
	<.main+3208 @03e468> : 1c 08 00 00 00             load.c32 8
	<.main+3213 @03e46d> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@03e471> - <@03e481>): sinF64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3217 @03e471> : 11 15                      dup.x2 sp(21)
	<.main+3219 @03e473> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3228 @03e47c> : 84                         div.f64
	<.main+3229 @03e47d> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@03e481> - <@03e491>): cosF64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3233 @03e481> : 11 17                      dup.x2 sp(23)
	<.main+3235 @03e483> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3244 @03e48c> : 84                         div.f64
	<.main+3245 @03e48d> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@03e491> - <@03e4a1>): tanF64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3249 @03e491> : 11 19                      dup.x2 sp(25)
	<.main+3251 @03e493> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3260 @03e49c> : 84                         div.f64
	<.main+3261 @03e49d> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@03e4a1> - <@03e4ad>): logF64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3265 @03e4a1> : 11 19                      dup.x2 sp(25)
	<.main+3267 @03e4a3> : 11 1b                      dup.x2 sp(27)
	<.main+3269 @03e4a5> : 83                         mul.f64
	<.main+3270 @03e4a6> : 11 1b                      dup.x2 sp(27)
	<.main+3272 @03e4a8> : 83                         mul.f64
	<.main+3273 @03e4a9> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@03e4ad> - <@03e4ba>): expF64: float64 := float64.exp(1.000000)
	<.main+3277 @03e4ad> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3286 @03e4b6> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@03e4ba> - <@03e4cc>): powF64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3290 @03e4ba> : 11 1f                      dup.x2 sp(31)
	<.main+3292 @03e4bc> : 11 21                      dup.x2 sp(33)
	<.main+3294 @03e4be> : 83                         mul.f64
	<.main+3295 @03e4bf> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3304 @03e4c8> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@03e4cc> - <@03e4d5>): sqrtF64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3308 @03e4cc> : 11 21                      dup.x2 sp(33)
	<.main+3310 @03e4ce> : 11 23                      dup.x2 sp(35)
	<.main+3312 @03e4d0> : 83                         mul.f64
	<.main+3313 @03e4d1> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@03e4d5> - <@03e4e4>): atanF64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3317 @03e4d5> : 11 23                      dup.x2 sp(35)
	<.main+3319 @03e4d7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3328 @03e4e0> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@03e4e4> - <@03e4f0>): sinF32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3332 @03e4e4> : 10 22                      dup.x1 sp(34)
	<.main+3334 @03e4e6> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3339 @03e4eb> : 74                         div.f32
	<.main+3340 @03e4ec> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@03e4f0> - <@03e4fc>): cosF32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3344 @03e4f0> : 10 23                      dup.x1 sp(35)
	<.main+3346 @03e4f2> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3351 @03e4f7> : 74                         div.f32
	<.main+3352 @03e4f8> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@03e4fc> - <@03e508>): tanF32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3356 @03e4fc> : 10 24                      dup.x1 sp(36)
	<.main+3358 @03e4fe> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3363 @03e503> : 74                         div.f32
	<.main+3364 @03e504> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@03e508> - <@03e514>): logF32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3368 @03e508> : 10 24                      dup.x1 sp(36)
	<.main+3370 @03e50a> : 10 25                      dup.x1 sp(37)
	<.main+3372 @03e50c> : 73                         mul.f32
	<.main+3373 @03e50d> : 10 25                      dup.x1 sp(37)
	<.main+3375 @03e50f> : 73                         mul.f32
	<.main+3376 @03e510> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@03e514> - <@03e51d>): expF32: float32 := float32.exp(1.000000)
	<.main+3380 @03e514> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3385 @03e519> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@03e51d> - <@03e52b>): powF32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3389 @03e51d> : 10 27                      dup.x1 sp(39)
	<.main+3391 @03e51f> : 10 28                      dup.x1 sp(40)
	<.main+3393 @03e521> : 73                         mul.f32
	<.main+3394 @03e522> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3399 @03e527> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@03e52b> - <@03e534>): sqrtF32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3403 @03e52b> : 10 28                      dup.x1 sp(40)
	<.main+3405 @03e52d> : 10 29                      dup.x1 sp(41)
	<.main+3407 @03e52f> : 73                         mul.f32
	<.main+3408 @03e530> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@03e534> - <@03e53f>): atanF32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3412 @03e534> : 10 29                      dup.x1 sp(41)
	<.main+3414 @03e536> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3419 @03e53b> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/memory.ci:7: (14 bytes: <@03e53f> - <@03e54d>): p1: pointer := malloc(1024)
	<.main+3423 @03e53f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3428 @03e544> : 1c 00 04 00 00             load.c32 1024
	<.main+3433 @03e549> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@03e54d> - <@03e55b>): p2: pointer := malloc(80)
	<.main+3437 @03e54d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3442 @03e552> : 1c 50 00 00 00             load.c32 80
	<.main+3447 @03e557> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@03e55b> - <@03e569>): p3: pointer := malloc(160)
	<.main+3451 @03e55b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3456 @03e560> : 1c a0 00 00 00             load.c32 160
	<.main+3461 @03e565> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@03e569> - <@03e577>): p4: pointer := malloc(820)
	<.main+3465 @03e569> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3470 @03e56e> : 1c 34 03 00 00             load.c32 820
	<.main+3475 @03e573> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@03e577> - <@03e587>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3479 @03e577> : 10 03                      dup.x1 sp(3)
	<.main+3481 @03e579> : 19                         load.z32
	<.main+3482 @03e57a> : 1c 00 04 00 00             load.c32 1024
	<.main+3487 @03e57f> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3491 @03e583> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@03e587> - <@03e598>): pointer.copy(void(void(p1, p3), 160));
	<.main+3495 @03e587> : 10 03                      dup.x1 sp(3)
	<.main+3497 @03e589> : 10 02                      dup.x1 sp(2)
	<.main+3499 @03e58b> : 1c a0 00 00 00             load.c32 160
	<.main+3504 @03e590> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3508 @03e594> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@03e598> - <@03e5a3>): free(p1);
	<.main+3512 @03e598> : 10 03                      dup.x1 sp(3)
	<.main+3514 @03e59a> : 19                         load.z32
	<.main+3515 @03e59b> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3519 @03e59f> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@03e5a3> - <@03e5ae>): free(p2);
	<.main+3523 @03e5a3> : 10 02                      dup.x1 sp(2)
	<.main+3525 @03e5a5> : 19                         load.z32
	<.main+3526 @03e5a6> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3530 @03e5aa> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@03e5ae> - <@03e5b9>): free(p3);
	<.main+3534 @03e5ae> : 10 01                      dup.x1 sp(1)
	<.main+3536 @03e5b0> : 19                         load.z32
	<.main+3537 @03e5b1> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3541 @03e5b5> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@03e5b9> - <@03e5c4>): free(p4);
	<.main+3545 @03e5b9> : 10 00                      dup.x1 sp(0)
	<.main+3547 @03e5bb> : 19                         load.z32
	<.main+3548 @03e5bc> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3552 @03e5c0> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@03e5c4> - <@03e5cd>): val1: int64 := 42
	<.main+3556 @03e5c4> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@03e5cd> - <@03e5d6>): val2: int64 := 96
	<.main+3565 @03e5cd> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@03e5d6> - <@03e5f8>): debug(void("val1", val1));
	<.main+3574 @03e5d6> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3579 @03e5db> : 1c 1a 00 00 00             load.c32 26
	<.main+3584 @03e5e0> : 1c 0e 00 00 00             load.c32 14
	<.main+3589 @03e5e5> : 19                         load.z32
	<.main+3590 @03e5e6> : 1f ed b6 02 00             load.ref <@02b6ed> ;"val1"
	<.main+3595 @03e5eb> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3600 @03e5f0> : 0a 20 00 00                load.sp(+32)
	<.main+3604 @03e5f4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@03e5f8> - <@03e61a>): debug(void("val2", val2));
	<.main+3608 @03e5f8> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3613 @03e5fd> : 1c 1b 00 00 00             load.c32 27
	<.main+3618 @03e602> : 1c 0e 00 00 00             load.c32 14
	<.main+3623 @03e607> : 19                         load.z32
	<.main+3624 @03e608> : 1f f2 b6 02 00             load.ref <@02b6f2> ;"val2"
	<.main+3629 @03e60d> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3634 @03e612> : 0a 18 00 00                load.sp(+24)
	<.main+3638 @03e616> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@03e61a> - <@03e62e>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3642 @03e61a> : 0a 00 00 00                load.sp(+0)
	<.main+3646 @03e61e> : 0a 0c 00 00                load.sp(+12)
	<.main+3650 @03e622> : 2a 18 04 00                load.m32 <@000418>
	<.main+3654 @03e626> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3658 @03e62a> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@03e62e> - <@03e63f>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3662 @03e62e> : 0a 08 00 00                load.sp(+8)
	<.main+3666 @03e632> : 19                         load.z32
	<.main+3667 @03e633> : 2a 18 04 00                load.m32 <@000418>
	<.main+3671 @03e637> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3675 @03e63b> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@03e63f> - <@03e661>): debug(void("val1", val1));
	<.main+3679 @03e63f> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3684 @03e644> : 1c 20 00 00 00             load.c32 32
	<.main+3689 @03e649> : 1c 0e 00 00 00             load.c32 14
	<.main+3694 @03e64e> : 19                         load.z32
	<.main+3695 @03e64f> : 1f ed b6 02 00             load.ref <@02b6ed> ;"val1"
	<.main+3700 @03e654> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3705 @03e659> : 0a 20 00 00                load.sp(+32)
	<.main+3709 @03e65d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@03e661> - <@03e683>): debug(void("val2", val2));
	<.main+3713 @03e661> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3718 @03e666> : 1c 21 00 00 00             load.c32 33
	<.main+3723 @03e66b> : 1c 0e 00 00 00             load.c32 14
	<.main+3728 @03e670> : 19                         load.z32
	<.main+3729 @03e671> : 1f f2 b6 02 00             load.ref <@02b6f2> ;"val2"
	<.main+3734 @03e676> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3739 @03e67b> : 0a 18 00 00                load.sp(+24)
	<.main+3743 @03e67f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@03e683> - <@03e691>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3747 @03e683> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3752 @03e688> : 1f f8 d5 03 00             load.ref <@03d5f8> ;noError(ptr: pointer): void
	<.main+3757 @03e68d> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@03e691> - <@03e69f>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3761 @03e691> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3766 @03e696> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3771 @03e69b> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@03e69f> - <@03e6ad>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3775 @03e69f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3780 @03e6a4> : 1f 00 d6 03 00             load.ref <@03d600> ;stackOverflow(ptr: pointer): void
	<.main+3785 @03e6a9> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@03e6ad> - <@03e6bb>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3789 @03e6ad> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3794 @03e6b2> : 1f 18 d6 03 00             load.ref <@03d618> ;divisionByZero(args: pointer): void
	<.main+3799 @03e6b7> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@03e6bb> - <@03e6c9>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3803 @03e6bb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3808 @03e6c0> : 1f 80 d6 03 00             load.ref <@03d680> ;invalidInstruction(args: pointer): void
	<.main+3813 @03e6c5> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@03e6c9> - <@03e6d7>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3817 @03e6c9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3822 @03e6ce> : 1f 70 d6 03 00             load.ref <@03d670> ;invalidMemoryAccess(args: pointer): void
	<.main+3827 @03e6d3> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@03e6d7> - <@03e6e5>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3831 @03e6d7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3836 @03e6dc> : 1f 28 d6 03 00             load.ref <@03d628> ;abortExecution(args: pointer): void
	<.main+3841 @03e6e1> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@03e6e5> - <@03e6e9>): arrFixedNoInit: int64[7]
	<.main+3845 @03e6e5> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@03e6e9> - <@03e6ed>): arrArrayNoInit: int64[*]
	<.main+3849 @03e6e9> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@03e6ed> - <@03e6f1>): arrSliceNoInit: int64[]
	<.main+3853 @03e6ed> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@03e6f1> - <@03e71e>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3857 @03e6f1> : 19                         load.z32
	<.main+3858 @03e6f2> : 04 1c 00 00                jmp <.main+3886 @03e70e>
	test/lang/array.ci:55: (20 bytes: <@03e6f6> - <@03e70a>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3862 @03e6f6> : 1c 2a 00 00 00             load.c32 42
	<.main+3867 @03e6fb> : 10 01                      dup.x1 sp(1)
	<.main+3869 @03e6fd> : 51                         add.i32
	<.main+3870 @03e6fe> : 5c                         i32.2i64
	<.main+3871 @03e6ff> : 0a 18 00 00                load.sp(+24)
	<.main+3875 @03e703> : 10 03                      dup.x1 sp(3)
	<.main+3877 @03e705> : 0d 08 00 00                mad.u32 8
	<.main+3881 @03e709> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@03e70a> - <@03e70e>): int32(i := int32(i + 1))
	<.main+3882 @03e70a> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@03e70e> - <@03e71a>): bool(i < arrFixedNoInit.length)
	<.main+3886 @03e70e> : 10 00                      dup.x1 sp(0)
	<.main+3888 @03e710> : 1c 07 00 00 00             load.c32 7
	<.main+3893 @03e715> : 58                         clt.i32
	<.main+3894 @03e716> : 05 e0 ff ff                jnz <.main+3862 @03e6f6>
	<.main+3898 @03e71a> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@03e71e> - <@03e723>): arrArrayInitNull: int64[*] := null
	<.main+3902 @03e71e> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@03e723> - <@03e729>): arrSliceInitNull: int64[] := null
	<.main+3907 @03e723> : 19                         load.z32
	<.main+3908 @03e724> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@03e729> - <@03e72d>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3913 @03e729> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@03e72d> - <@03e736>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3917 @03e72d> : 1c 07 00 00 00             load.c32 7
	<.main+3922 @03e732> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@03e736> - <@03e738>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3926 @03e736> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@03e738> - <@03e73a>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3928 @03e738> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@03e73a> - <@03e73c>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3930 @03e73a> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@03e73c> - <@03e740>): strFixed: char[7]
	<.main+3932 @03e73c> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@03e740> - <@03e756>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+3936 @03e740> : 0a 00 00 00                load.sp(+0)
	<.main+3940 @03e744> : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	<.main+3945 @03e749> : 1c 07 00 00 00             load.c32 7
	<.main+3950 @03e74e> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3954 @03e752> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@03e756> - <@03e778>): debug(void("string as variant", strFixed));
	<.main+3958 @03e756> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+3963 @03e75b> : 1c 53 00 00 00             load.c32 83
	<.main+3968 @03e760> : 1c 0e 00 00 00             load.c32 14
	<.main+3973 @03e765> : 19                         load.z32
	<.main+3974 @03e766> : 1f c3 d4 02 00             load.ref <@02d4c3> ;"string as variant"
	<.main+3979 @03e76b> : 1f 60 e1 02 00             load.ref <@02e160>
	<.main+3984 @03e770> : 0a 18 00 00                load.sp(+24)
	<.main+3988 @03e774> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@03e778> - <@03e79a>): debug(void("string to variant", variant(strFixed)));
	<.main+3992 @03e778> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+3997 @03e77d> : 1c 54 00 00 00             load.c32 84
	<.main+4002 @03e782> : 1c 0e 00 00 00             load.c32 14
	<.main+4007 @03e787> : 19                         load.z32
	<.main+4008 @03e788> : 1f d5 d4 02 00             load.ref <@02d4d5> ;"string to variant"
	<.main+4013 @03e78d> : 1f 60 e1 02 00             load.ref <@02e160>
	<.main+4018 @03e792> : 0a 18 00 00                load.sp(+24)
	<.main+4022 @03e796> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@03e79a> - <@03e79f>): strArray: char[*] := "string"
	<.main+4026 @03e79a> : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	test/lang/array.ci:87: (32 bytes: <@03e79f> - <@03e7bf>): debug(void("string as variant", strArray));
	<.main+4031 @03e79f> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4036 @03e7a4> : 1c 57 00 00 00             load.c32 87
	<.main+4041 @03e7a9> : 1c 0e 00 00 00             load.c32 14
	<.main+4046 @03e7ae> : 19                         load.z32
	<.main+4047 @03e7af> : 1f c3 d4 02 00             load.ref <@02d4c3> ;"string as variant"
	<.main+4052 @03e7b4> : 1f f8 e2 02 00             load.ref <@02e2f8>
	<.main+4057 @03e7b9> : 10 06                      dup.x1 sp(6)
	<.main+4059 @03e7bb> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@03e7bf> - <@03e7df>): debug(void("string to variant", variant(strArray)));
	<.main+4063 @03e7bf> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4068 @03e7c4> : 1c 58 00 00 00             load.c32 88
	<.main+4073 @03e7c9> : 1c 0e 00 00 00             load.c32 14
	<.main+4078 @03e7ce> : 19                         load.z32
	<.main+4079 @03e7cf> : 1f d5 d4 02 00             load.ref <@02d4d5> ;"string to variant"
	<.main+4084 @03e7d4> : 1f f8 e2 02 00             load.ref <@02e2f8>
	<.main+4089 @03e7d9> : 10 06                      dup.x1 sp(6)
	<.main+4091 @03e7db> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@03e7df> - <@03e7e9>): strSlice: char[] := "string"
	<.main+4095 @03e7df> : 1c 06 00 00 00             load.c32 6
	<.main+4100 @03e7e4> : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	test/lang/array.ci:91: (32 bytes: <@03e7e9> - <@03e809>): debug(void("string as variant", strSlice));
	<.main+4105 @03e7e9> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4110 @03e7ee> : 1c 5b 00 00 00             load.c32 91
	<.main+4115 @03e7f3> : 1c 0e 00 00 00             load.c32 14
	<.main+4120 @03e7f8> : 19                         load.z32
	<.main+4121 @03e7f9> : 1f c3 d4 02 00             load.ref <@02d4c3> ;"string as variant"
	<.main+4126 @03e7fe> : 1f 08 e4 02 00             load.ref <@02e408>
	<.main+4131 @03e803> : 10 06                      dup.x1 sp(6)
	<.main+4133 @03e805> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@03e809> - <@03e829>): debug(void("string to variant", variant(strSlice)));
	<.main+4137 @03e809> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4142 @03e80e> : 1c 5c 00 00 00             load.c32 92
	<.main+4147 @03e813> : 1c 0e 00 00 00             load.c32 14
	<.main+4152 @03e818> : 19                         load.z32
	<.main+4153 @03e819> : 1f d5 d4 02 00             load.ref <@02d4d5> ;"string to variant"
	<.main+4158 @03e81e> : 1f 08 e4 02 00             load.ref <@02e408>
	<.main+4163 @03e823> : 10 06                      dup.x1 sp(6)
	<.main+4165 @03e825> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@03e829> - <@03e85c>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4169 @03e829> : 10 10                      dup.x1 sp(16)
	<.main+4171 @03e82b> : 19                         load.z32
	<.main+4172 @03e82c> : 38                         clt.u32
	<.main+4173 @03e82d> : 05 08 00 00                jnz <.main+4181 @03e835>
	<.main+4177 @03e831> : 04 2b 00 00                jmp <.main+4220 @03e85c>
	<.main+4181 @03e835> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4186 @03e83a> : 1c 62 00 00 00             load.c32 98
	<.main+4191 @03e83f> : 1c fe ff ff ff             load.c32 -2
	<.main+4196 @03e844> : 1c 80 00 00 00             load.c32 128
	<.main+4201 @03e849> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4206 @03e84e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4211 @03e853> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4216 @03e858> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@03e85c> - <@03e88f>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4220 @03e85c> : 10 0d                      dup.x1 sp(13)
	<.main+4222 @03e85e> : 19                         load.z32
	<.main+4223 @03e85f> : 57                         ceq.i32
	<.main+4224 @03e860> : 06 08 00 00                jz <.main+4232 @03e868>
	<.main+4228 @03e864> : 04 2b 00 00                jmp <.main+4271 @03e88f>
	<.main+4232 @03e868> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4237 @03e86d> : 1c 63 00 00 00             load.c32 99
	<.main+4242 @03e872> : 1c fe ff ff ff             load.c32 -2
	<.main+4247 @03e877> : 1c 80 00 00 00             load.c32 128
	<.main+4252 @03e87c> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4257 @03e881> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4262 @03e886> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4267 @03e88b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@03e88f> - <@03e8ca>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4271 @03e88f> : 11 12                      dup.x2 sp(18)
	<.main+4273 @03e891> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4282 @03e89a> : 67                         ceq.i64
	<.main+4283 @03e89b> : 06 08 00 00                jz <.main+4291 @03e8a3>
	<.main+4287 @03e89f> : 04 2b 00 00                jmp <.main+4330 @03e8ca>
	<.main+4291 @03e8a3> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4296 @03e8a8> : 1c 65 00 00 00             load.c32 101
	<.main+4301 @03e8ad> : 1c fe ff ff ff             load.c32 -2
	<.main+4306 @03e8b2> : 1c 80 00 00 00             load.c32 128
	<.main+4311 @03e8b7> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4316 @03e8bc> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4321 @03e8c1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4326 @03e8c6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@03e8ca> - <@03e8e3>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4330 @03e8ca> : 1c 07 00 00 00             load.c32 7
	<.main+4335 @03e8cf> : 1c 07 00 00 00             load.c32 7
	<.main+4340 @03e8d4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4345 @03e8d9> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4350 @03e8de> : 02                         call
	<.main+4351 @03e8df> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@03e8e3> - <@03e8f9>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4355 @03e8e3> : 1c 07 00 00 00             load.c32 7
	<.main+4360 @03e8e8> : 10 0b                      dup.x1 sp(11)
	<.main+4362 @03e8ea> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4367 @03e8ef> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4372 @03e8f4> : 02                         call
	<.main+4373 @03e8f5> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@03e8f9> - <@03e90f>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4377 @03e8f9> : 1c 07 00 00 00             load.c32 7
	<.main+4382 @03e8fe> : 10 08                      dup.x1 sp(8)
	<.main+4384 @03e900> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4389 @03e905> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4394 @03e90a> : 02                         call
	<.main+4395 @03e90b> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@03e90f> - <@03e92f>): assertEq(void(0, lenSlice(null)));
	<.main+4399 @03e90f> : 19                         load.z32
	<.main+4400 @03e910> : 1a                         load.z64
	<.main+4401 @03e911> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4406 @03e916> : 1f 88 d6 03 00             load.ref <@03d688> ;lenSlice(values: int64[]): int32
	<.main+4411 @03e91b> : 02                         call
	<.main+4412 @03e91c> : 09 f8 ff ff                inc.sp(-8)
	<.main+4416 @03e920> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4421 @03e925> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4426 @03e92a> : 02                         call
	<.main+4427 @03e92b> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@03e92f> - <@03e94c>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4431 @03e92f> : 19                         load.z32
	<.main+4432 @03e930> : 19                         load.z32
	<.main+4433 @03e931> : 11 0e                      dup.x2 sp(14)
	<.main+4435 @03e933> : 1f 88 d6 03 00             load.ref <@03d688> ;lenSlice(values: int64[]): int32
	<.main+4440 @03e938> : 02                         call
	<.main+4441 @03e939> : 09 f8 ff ff                inc.sp(-8)
	<.main+4445 @03e93d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4450 @03e942> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4455 @03e947> : 02                         call
	<.main+4456 @03e948> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@03e94c> - <@03e974>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4460 @03e94c> : 1c 07 00 00 00             load.c32 7
	<.main+4465 @03e951> : 19                         load.z32
	<.main+4466 @03e952> : 1c 07 00 00 00             load.c32 7
	<.main+4471 @03e957> : 0a 54 00 00                load.sp(+84)
	<.main+4475 @03e95b> : 1f 88 d6 03 00             load.ref <@03d688> ;lenSlice(values: int64[]): int32
	<.main+4480 @03e960> : 02                         call
	<.main+4481 @03e961> : 09 f8 ff ff                inc.sp(-8)
	<.main+4485 @03e965> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4490 @03e96a> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4495 @03e96f> : 02                         call
	<.main+4496 @03e970> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@03e974> - <@03e995>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4500 @03e974> : 1c 07 00 00 00             load.c32 7
	<.main+4505 @03e979> : 19                         load.z32
	<.main+4506 @03e97a> : 11 0b                      dup.x2 sp(11)
	<.main+4508 @03e97c> : 1f 88 d6 03 00             load.ref <@03d688> ;lenSlice(values: int64[]): int32
	<.main+4513 @03e981> : 02                         call
	<.main+4514 @03e982> : 09 f8 ff ff                inc.sp(-8)
	<.main+4518 @03e986> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4523 @03e98b> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4528 @03e990> : 02                         call
	<.main+4529 @03e991> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@03e995> - <@03e9b6>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4533 @03e995> : 1c 07 00 00 00             load.c32 7
	<.main+4538 @03e99a> : 19                         load.z32
	<.main+4539 @03e99b> : 11 08                      dup.x2 sp(8)
	<.main+4541 @03e99d> : 1f 88 d6 03 00             load.ref <@03d688> ;lenSlice(values: int64[]): int32
	<.main+4546 @03e9a2> : 02                         call
	<.main+4547 @03e9a3> : 09 f8 ff ff                inc.sp(-8)
	<.main+4551 @03e9a7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4556 @03e9ac> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4561 @03e9b1> : 02                         call
	<.main+4562 @03e9b2> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@03e9b6> - <@03ecdd>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4566 @03e9b6> : 19                         load.z32
	<.main+4567 @03e9b7> : 04 16 03 00                jmp <.main+5357 @03eccd>
	test/lang/array.ci:119: (9 bytes: <@03e9bb> - <@03e9c4>): expected: int64 := int32(42 + i)
	<.main+4571 @03e9bb> : 1c 2a 00 00 00             load.c32 42
	<.main+4576 @03e9c0> : 10 01                      dup.x1 sp(1)
	<.main+4578 @03e9c2> : 51                         add.i32
	<.main+4579 @03e9c3> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@03e9c4> - <@03ea01>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4580 @03e9c4> : 11 00                      dup.x2 sp(0)
	<.main+4582 @03e9c6> : 0a 5c 00 00                load.sp(+92)
	<.main+4586 @03e9ca> : 10 05                      dup.x1 sp(5)
	<.main+4588 @03e9cc> : 0d 08 00 00                mad.u32 8
	<.main+4592 @03e9d0> : 23                         load.i64
	<.main+4593 @03e9d1> : 67                         ceq.i64
	<.main+4594 @03e9d2> : 06 08 00 00                jz <.main+4602 @03e9da>
	<.main+4598 @03e9d6> : 04 2b 00 00                jmp <.main+4641 @03ea01>
	<.main+4602 @03e9da> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4607 @03e9df> : 1c 78 00 00 00             load.c32 120
	<.main+4612 @03e9e4> : 1c fe ff ff ff             load.c32 -2
	<.main+4617 @03e9e9> : 1c 80 00 00 00             load.c32 128
	<.main+4622 @03e9ee> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4627 @03e9f3> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4632 @03e9f8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4637 @03e9fd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@03ea01> - <@03ea3c>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4641 @03ea01> : 11 00                      dup.x2 sp(0)
	<.main+4643 @03ea03> : 10 10                      dup.x1 sp(16)
	<.main+4645 @03ea05> : 10 05                      dup.x1 sp(5)
	<.main+4647 @03ea07> : 0d 08 00 00                mad.u32 8
	<.main+4651 @03ea0b> : 23                         load.i64
	<.main+4652 @03ea0c> : 67                         ceq.i64
	<.main+4653 @03ea0d> : 06 08 00 00                jz <.main+4661 @03ea15>
	<.main+4657 @03ea11> : 04 2b 00 00                jmp <.main+4700 @03ea3c>
	<.main+4661 @03ea15> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4666 @03ea1a> : 1c 79 00 00 00             load.c32 121
	<.main+4671 @03ea1f> : 1c fe ff ff ff             load.c32 -2
	<.main+4676 @03ea24> : 1c 80 00 00 00             load.c32 128
	<.main+4681 @03ea29> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4686 @03ea2e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4691 @03ea33> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4696 @03ea38> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@03ea3c> - <@03ea77>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4700 @03ea3c> : 11 00                      dup.x2 sp(0)
	<.main+4702 @03ea3e> : 10 0e                      dup.x1 sp(14)
	<.main+4704 @03ea40> : 10 05                      dup.x1 sp(5)
	<.main+4706 @03ea42> : 0d 08 00 00                mad.u32 8
	<.main+4710 @03ea46> : 23                         load.i64
	<.main+4711 @03ea47> : 67                         ceq.i64
	<.main+4712 @03ea48> : 06 08 00 00                jz <.main+4720 @03ea50>
	<.main+4716 @03ea4c> : 04 2b 00 00                jmp <.main+4759 @03ea77>
	<.main+4720 @03ea50> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4725 @03ea55> : 1c 7a 00 00 00             load.c32 122
	<.main+4730 @03ea5a> : 1c fe ff ff ff             load.c32 -2
	<.main+4735 @03ea5f> : 1c 80 00 00 00             load.c32 128
	<.main+4740 @03ea64> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4745 @03ea69> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4750 @03ea6e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4755 @03ea73> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@03ea77> - <@03eaba>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4759 @03ea77> : 11 00                      dup.x2 sp(0)
	<.main+4761 @03ea79> : 1a                         load.z64
	<.main+4762 @03ea7a> : 10 06                      dup.x1 sp(6)
	<.main+4764 @03ea7c> : 0a 68 00 00                load.sp(+104)
	<.main+4768 @03ea80> : 1f 90 d6 03 00             load.ref <@03d690> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4773 @03ea85> : 02                         call
	<.main+4774 @03ea86> : 09 f8 ff ff                inc.sp(-8)
	<.main+4778 @03ea8a> : 67                         ceq.i64
	<.main+4779 @03ea8b> : 06 08 00 00                jz <.main+4787 @03ea93>
	<.main+4783 @03ea8f> : 04 2b 00 00                jmp <.main+4826 @03eaba>
	<.main+4787 @03ea93> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4792 @03ea98> : 1c 7c 00 00 00             load.c32 124
	<.main+4797 @03ea9d> : 1c fe ff ff ff             load.c32 -2
	<.main+4802 @03eaa2> : 1c 80 00 00 00             load.c32 128
	<.main+4807 @03eaa7> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4812 @03eaac> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4817 @03eab1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4822 @03eab6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@03eaba> - <@03eafb>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4826 @03eaba> : 11 00                      dup.x2 sp(0)
	<.main+4828 @03eabc> : 1a                         load.z64
	<.main+4829 @03eabd> : 10 06                      dup.x1 sp(6)
	<.main+4831 @03eabf> : 10 13                      dup.x1 sp(19)
	<.main+4833 @03eac1> : 1f 90 d6 03 00             load.ref <@03d690> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4838 @03eac6> : 02                         call
	<.main+4839 @03eac7> : 09 f8 ff ff                inc.sp(-8)
	<.main+4843 @03eacb> : 67                         ceq.i64
	<.main+4844 @03eacc> : 06 08 00 00                jz <.main+4852 @03ead4>
	<.main+4848 @03ead0> : 04 2b 00 00                jmp <.main+4891 @03eafb>
	<.main+4852 @03ead4> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4857 @03ead9> : 1c 7d 00 00 00             load.c32 125
	<.main+4862 @03eade> : 1c fe ff ff ff             load.c32 -2
	<.main+4867 @03eae3> : 1c 80 00 00 00             load.c32 128
	<.main+4872 @03eae8> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4877 @03eaed> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4882 @03eaf2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4887 @03eaf7> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@03eafb> - <@03eb3c>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4891 @03eafb> : 11 00                      dup.x2 sp(0)
	<.main+4893 @03eafd> : 1a                         load.z64
	<.main+4894 @03eafe> : 10 06                      dup.x1 sp(6)
	<.main+4896 @03eb00> : 10 11                      dup.x1 sp(17)
	<.main+4898 @03eb02> : 1f 90 d6 03 00             load.ref <@03d690> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4903 @03eb07> : 02                         call
	<.main+4904 @03eb08> : 09 f8 ff ff                inc.sp(-8)
	<.main+4908 @03eb0c> : 67                         ceq.i64
	<.main+4909 @03eb0d> : 06 08 00 00                jz <.main+4917 @03eb15>
	<.main+4913 @03eb11> : 04 2b 00 00                jmp <.main+4956 @03eb3c>
	<.main+4917 @03eb15> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4922 @03eb1a> : 1c 7e 00 00 00             load.c32 126
	<.main+4927 @03eb1f> : 1c fe ff ff ff             load.c32 -2
	<.main+4932 @03eb24> : 1c 80 00 00 00             load.c32 128
	<.main+4937 @03eb29> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4942 @03eb2e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4947 @03eb33> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4952 @03eb38> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@03eb3c> - <@03eb7f>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+4956 @03eb3c> : 11 00                      dup.x2 sp(0)
	<.main+4958 @03eb3e> : 1a                         load.z64
	<.main+4959 @03eb3f> : 10 06                      dup.x1 sp(6)
	<.main+4961 @03eb41> : 0a 68 00 00                load.sp(+104)
	<.main+4965 @03eb45> : 1f a0 d6 03 00             load.ref <@03d6a0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+4970 @03eb4a> : 02                         call
	<.main+4971 @03eb4b> : 09 f8 ff ff                inc.sp(-8)
	<.main+4975 @03eb4f> : 67                         ceq.i64
	<.main+4976 @03eb50> : 06 08 00 00                jz <.main+4984 @03eb58>
	<.main+4980 @03eb54> : 04 2b 00 00                jmp <.main+5023 @03eb7f>
	<.main+4984 @03eb58> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4989 @03eb5d> : 1c 80 00 00 00             load.c32 128
	<.main+4994 @03eb62> : 1c fe ff ff ff             load.c32 -2
	<.main+4999 @03eb67> : 1c 80 00 00 00             load.c32 128
	<.main+5004 @03eb6c> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5009 @03eb71> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5014 @03eb76> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5019 @03eb7b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@03eb7f> - <@03ebc0>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5023 @03eb7f> : 11 00                      dup.x2 sp(0)
	<.main+5025 @03eb81> : 1a                         load.z64
	<.main+5026 @03eb82> : 10 06                      dup.x1 sp(6)
	<.main+5028 @03eb84> : 10 13                      dup.x1 sp(19)
	<.main+5030 @03eb86> : 1f a0 d6 03 00             load.ref <@03d6a0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5035 @03eb8b> : 02                         call
	<.main+5036 @03eb8c> : 09 f8 ff ff                inc.sp(-8)
	<.main+5040 @03eb90> : 67                         ceq.i64
	<.main+5041 @03eb91> : 06 08 00 00                jz <.main+5049 @03eb99>
	<.main+5045 @03eb95> : 04 2b 00 00                jmp <.main+5088 @03ebc0>
	<.main+5049 @03eb99> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5054 @03eb9e> : 1c 81 00 00 00             load.c32 129
	<.main+5059 @03eba3> : 1c fe ff ff ff             load.c32 -2
	<.main+5064 @03eba8> : 1c 80 00 00 00             load.c32 128
	<.main+5069 @03ebad> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5074 @03ebb2> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5079 @03ebb7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5084 @03ebbc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@03ebc0> - <@03ec01>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5088 @03ebc0> : 11 00                      dup.x2 sp(0)
	<.main+5090 @03ebc2> : 1a                         load.z64
	<.main+5091 @03ebc3> : 10 06                      dup.x1 sp(6)
	<.main+5093 @03ebc5> : 10 11                      dup.x1 sp(17)
	<.main+5095 @03ebc7> : 1f a0 d6 03 00             load.ref <@03d6a0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5100 @03ebcc> : 02                         call
	<.main+5101 @03ebcd> : 09 f8 ff ff                inc.sp(-8)
	<.main+5105 @03ebd1> : 67                         ceq.i64
	<.main+5106 @03ebd2> : 06 08 00 00                jz <.main+5114 @03ebda>
	<.main+5110 @03ebd6> : 04 2b 00 00                jmp <.main+5153 @03ec01>
	<.main+5114 @03ebda> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5119 @03ebdf> : 1c 82 00 00 00             load.c32 130
	<.main+5124 @03ebe4> : 1c fe ff ff ff             load.c32 -2
	<.main+5129 @03ebe9> : 1c 80 00 00 00             load.c32 128
	<.main+5134 @03ebee> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5139 @03ebf3> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5144 @03ebf8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5149 @03ebfd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@03ec01> - <@03ec49>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5153 @03ec01> : 11 00                      dup.x2 sp(0)
	<.main+5155 @03ec03> : 1a                         load.z64
	<.main+5156 @03ec04> : 10 06                      dup.x1 sp(6)
	<.main+5158 @03ec06> : 1c 07 00 00 00             load.c32 7
	<.main+5163 @03ec0b> : 0a 6c 00 00                load.sp(+108)
	<.main+5167 @03ec0f> : 1f b0 d6 03 00             load.ref <@03d6b0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5172 @03ec14> : 02                         call
	<.main+5173 @03ec15> : 09 f4 ff ff                inc.sp(-12)
	<.main+5177 @03ec19> : 67                         ceq.i64
	<.main+5178 @03ec1a> : 06 08 00 00                jz <.main+5186 @03ec22>
	<.main+5182 @03ec1e> : 04 2b 00 00                jmp <.main+5225 @03ec49>
	<.main+5186 @03ec22> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5191 @03ec27> : 1c 84 00 00 00             load.c32 132
	<.main+5196 @03ec2c> : 1c fe ff ff ff             load.c32 -2
	<.main+5201 @03ec31> : 1c 80 00 00 00             load.c32 128
	<.main+5206 @03ec36> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5211 @03ec3b> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5216 @03ec40> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5221 @03ec45> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@03ec49> - <@03ec8a>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5225 @03ec49> : 11 00                      dup.x2 sp(0)
	<.main+5227 @03ec4b> : 1a                         load.z64
	<.main+5228 @03ec4c> : 10 06                      dup.x1 sp(6)
	<.main+5230 @03ec4e> : 11 11                      dup.x2 sp(17)
	<.main+5232 @03ec50> : 1f b0 d6 03 00             load.ref <@03d6b0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5237 @03ec55> : 02                         call
	<.main+5238 @03ec56> : 09 f4 ff ff                inc.sp(-12)
	<.main+5242 @03ec5a> : 67                         ceq.i64
	<.main+5243 @03ec5b> : 06 08 00 00                jz <.main+5251 @03ec63>
	<.main+5247 @03ec5f> : 04 2b 00 00                jmp <.main+5290 @03ec8a>
	<.main+5251 @03ec63> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5256 @03ec68> : 1c 86 00 00 00             load.c32 134
	<.main+5261 @03ec6d> : 1c fe ff ff ff             load.c32 -2
	<.main+5266 @03ec72> : 1c 80 00 00 00             load.c32 128
	<.main+5271 @03ec77> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5276 @03ec7c> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5281 @03ec81> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5286 @03ec86> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@03ec8a> - <@03ecc5>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5290 @03ec8a> : 11 00                      dup.x2 sp(0)
	<.main+5292 @03ec8c> : 10 0b                      dup.x1 sp(11)
	<.main+5294 @03ec8e> : 10 05                      dup.x1 sp(5)
	<.main+5296 @03ec90> : 0d 08 00 00                mad.u32 8
	<.main+5300 @03ec94> : 23                         load.i64
	<.main+5301 @03ec95> : 67                         ceq.i64
	<.main+5302 @03ec96> : 06 08 00 00                jz <.main+5310 @03ec9e>
	<.main+5306 @03ec9a> : 04 2b 00 00                jmp <.main+5349 @03ecc5>
	<.main+5310 @03ec9e> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5315 @03eca3> : 1c 88 00 00 00             load.c32 136
	<.main+5320 @03eca8> : 1c fe ff ff ff             load.c32 -2
	<.main+5325 @03ecad> : 1c 80 00 00 00             load.c32 128
	<.main+5330 @03ecb2> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5335 @03ecb7> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5340 @03ecbc> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5345 @03ecc1> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5349 @03ecc5> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@03ecc9> - <@03eccd>): int32(i := int32(i + 1))
	<.main+5353 @03ecc9> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@03eccd> - <@03ecd9>): bool(i < arrFixedNoInit.length)
	<.main+5357 @03eccd> : 10 00                      dup.x1 sp(0)
	<.main+5359 @03eccf> : 1c 07 00 00 00             load.c32 7
	<.main+5364 @03ecd4> : 58                         clt.i32
	<.main+5365 @03ecd5> : 05 e6 fc ff                jnz <.main+4571 @03e9bb>
	<.main+5369 @03ecd9> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@03ecdd> - <@03ed19>): recordMemberTest: RecordMemberTest := {...}
	<.main+5373 @03ecdd> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@03ece1> - <@03ece8>): void(recordMemberTest.member := 6);
	<.main+5377 @03ece1> : 1c 06 00 00 00             load.c32 6
	<.main+5382 @03ece6> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@03ece8> - <@03ecef>): void(recordMemberTest.constant := 7);
	<.main+5384 @03ece8> : 1c 07 00 00 00             load.c32 7
	<.main+5389 @03eced> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@03ecef> - <@03ecf6>): void(recordMemberTest.memberInit := 8);
	<.main+5391 @03ecef> : 1c 08 00 00 00             load.c32 8
	<.main+5396 @03ecf4> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@03ecf6> - <@03ecfd>): void(recordMemberTest.constantInit := 9);
	<.main+5398 @03ecf6> : 1c 09 00 00 00             load.c32 9
	<.main+5403 @03ecfb> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@03ecfd> - <@03ed04>): void(recordMemberTest.memberRec.member := 61);
	<.main+5405 @03ecfd> : 1c 3d 00 00 00             load.c32 61
	<.main+5410 @03ed02> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@03ed04> - <@03ed0b>): void(recordMemberTest.memberRec.constant := 62);
	<.main+5412 @03ed04> : 1c 3e 00 00 00             load.c32 62
	<.main+5417 @03ed09> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@03ed0b> - <@03ed12>): void(recordMemberTest.constantRec.member := 71);
	<.main+5419 @03ed0b> : 1c 47 00 00 00             load.c32 71
	<.main+5424 @03ed10> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@03ed12> - <@03ed19>): void(recordMemberTest.constantRec.constant := 72);
	<.main+5426 @03ed12> : 1c 48 00 00 00             load.c32 72
	<.main+5431 @03ed17> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:53: (32 bytes: <@03ed19> - <@03ed39>): recordMethodTest: RecordMethodTest := {...}
	<.main+5433 @03ed19> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:54: (7 bytes: <@03ed1d> - <@03ed24>): void(recordMethodTest.delegateMethod := globalFunction);
	<.main+5437 @03ed1d> : 1f 60 d7 03 00             load.ref <@03d760> ;globalFunction(x: int32, y: int32): int32
	<.main+5442 @03ed22> : 13 02                      set.x1 sp(2)
	test/lang/method.ci:55: (7 bytes: <@03ed24> - <@03ed2b>): void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
	<.main+5444 @03ed24> : 1f f0 d6 03 00             load.ref <@03d6f0> ;RecordMethodTest.staticMethod(x: int32, y: int32): int32
	<.main+5449 @03ed29> : 13 01                      set.x1 sp(1)
	:: (7 bytes: <@03ed2b> - <@03ed32>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5451 @03ed2b> : 1f 00 d7 03 00             load.ref <@03d700> ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+5456 @03ed30> : 13 03                      set.x1 sp(3)
	:: (7 bytes: <@03ed32> - <@03ed39>): void(recordMethodTest.print := print)
	<.main+5458 @03ed32> : 1f 10 d7 03 00             load.ref <@03d710> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5463 @03ed37> : 13 04                      set.x1 sp(4)
	test/lang/method.ci:63: (31 bytes: <@03ed39> - <@03ed58>): recordMethodTestCustomPrint: RecordMethodTest := {...}
	<.main+5465 @03ed39> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:64: (7 bytes: <@03ed3d> - <@03ed44>): void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
	<.main+5469 @03ed3d> : 1f 60 d7 03 00             load.ref <@03d760> ;globalFunction(x: int32, y: int32): int32
	<.main+5474 @03ed42> : 13 01                      set.x1 sp(1)
	test/lang/method.ci:65: (7 bytes: <@03ed44> - <@03ed4b>): void(recordMethodTestCustomPrint.print := customPrint);
	<.main+5476 @03ed44> : 1f 68 d7 03 00             load.ref <@03d768> ;customPrint(this: RecordMethodTest): void
	<.main+5481 @03ed49> : 13 04                      set.x1 sp(4)
	:: (6 bytes: <@03ed4b> - <@03ed51>): void(recordMethodTestCustomPrint.delegateMethod := forwardMethod)
	<.main+5483 @03ed4b> : 2a f8 d6 03                load.m32 <@03d6f8> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+5487 @03ed4f> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@03ed51> - <@03ed58>): void(recordMethodTestCustomPrint.virtualMethod := virtualMethod)
	<.main+5489 @03ed51> : 1f 00 d7 03 00             load.ref <@03d700> ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+5494 @03ed56> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:69: (9 bytes: <@03ed58> - <@03ed61>): recordMethodTest.print(recordMethodTest);
	<.main+5496 @03ed58> : 12 04                      dup.x4 sp(4)
	<.main+5498 @03ed5a> : 10 0b                      dup.x1 sp(11)
	<.main+5500 @03ed5c> : 02                         call
	<.main+5501 @03ed5d> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:70: (9 bytes: <@03ed61> - <@03ed6a>): recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
	<.main+5505 @03ed61> : 12 00                      dup.x4 sp(0)
	<.main+5507 @03ed63> : 10 07                      dup.x1 sp(7)
	<.main+5509 @03ed65> : 02                         call
	<.main+5510 @03ed66> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:73: (12 bytes: <@03ed6a> - <@03ed76>): recordMethodTest.printStatic(recordMethodTest);
	<.main+5514 @03ed6a> : 12 04                      dup.x4 sp(4)
	<.main+5516 @03ed6c> : 1f 38 d7 03 00             load.ref <@03d738> ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+5521 @03ed71> : 02                         call
	<.main+5522 @03ed72> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:84: (12 bytes: <@03ed76> - <@03ed82>): print(recordMethodTest);
	<.main+5526 @03ed76> : 12 04                      dup.x4 sp(4)
	<.main+5528 @03ed78> : 1f 90 d7 03 00             load.ref <@03d790> ;print(this: RecordMethodTest): void
	<.main+5533 @03ed7d> : 02                         call
	<.main+5534 @03ed7e> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:85: (12 bytes: <@03ed82> - <@03ed8e>): printStatic(recordMethodTest);
	<.main+5538 @03ed82> : 12 04                      dup.x4 sp(4)
	<.main+5540 @03ed84> : 1f b8 d7 03 00             load.ref <@03d7b8> ;printStatic(this: RecordMethodTest): void
	<.main+5545 @03ed89> : 02                         call
	<.main+5546 @03ed8a> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:86: (12 bytes: <@03ed8e> - <@03ed9a>): print(recordMethodTestCustomPrint);
	<.main+5550 @03ed8e> : 12 00                      dup.x4 sp(0)
	<.main+5552 @03ed90> : 1f 90 d7 03 00             load.ref <@03d790> ;print(this: RecordMethodTest): void
	<.main+5557 @03ed95> : 02                         call
	<.main+5558 @03ed96> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:89: (12 bytes: <@03ed9a> - <@03eda6>): RecordMethodTest.print(recordMethodTest);
	<.main+5562 @03ed9a> : 12 04                      dup.x4 sp(4)
	<.main+5564 @03ed9c> : 1f 10 d7 03 00             load.ref <@03d710> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5569 @03eda1> : 02                         call
	<.main+5570 @03eda2> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:90: (12 bytes: <@03eda6> - <@03edb2>): RecordMethodTest.printStatic(recordMethodTest);
	<.main+5574 @03eda6> : 12 04                      dup.x4 sp(4)
	<.main+5576 @03eda8> : 1f 38 d7 03 00             load.ref <@03d738> ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+5581 @03edad> : 02                         call
	<.main+5582 @03edae> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:91: (12 bytes: <@03edb2> - <@03edbe>): RecordMethodTest.print(recordMethodTestCustomPrint);
	<.main+5586 @03edb2> : 12 00                      dup.x4 sp(0)
	<.main+5588 @03edb4> : 1f 10 d7 03 00             load.ref <@03d710> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5593 @03edb9> : 02                         call
	<.main+5594 @03edba> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@03edbe> - <@03edd4>): black: rgbU8 := {...}
	<.main+5598 @03edbe> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@03edc2> - <@03edc8>): void(black.r := (0));
	<.main+5602 @03edc2> : 19                         load.z32
	<.main+5603 @03edc3> : 0a 06 00 00                load.sp(+6)
	<.main+5607 @03edc7> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@03edc8> - <@03edce>): void(black.g := (0));
	<.main+5608 @03edc8> : 19                         load.z32
	<.main+5609 @03edc9> : 0a 05 00 00                load.sp(+5)
	<.main+5613 @03edcd> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@03edce> - <@03edd4>): void(black.b := (0));
	<.main+5614 @03edce> : 19                         load.z32
	<.main+5615 @03edcf> : 0a 04 00 00                load.sp(+4)
	<.main+5619 @03edd3> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@03edd4> - <@03edee>): green: rgbU8 := {...}
	<.main+5620 @03edd4> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@03edd8> - <@03edde>): void(green.r := (0));
	<.main+5624 @03edd8> : 19                         load.z32
	<.main+5625 @03edd9> : 0a 06 00 00                load.sp(+6)
	<.main+5629 @03eddd> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@03edde> - <@03ede8>): void(green.g := (255));
	<.main+5630 @03edde> : 1c ff 00 00 00             load.c32 255
	<.main+5635 @03ede3> : 0a 05 00 00                load.sp(+5)
	<.main+5639 @03ede7> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@03ede8> - <@03edee>): void(green.b := (0));
	<.main+5640 @03ede8> : 19                         load.z32
	<.main+5641 @03ede9> : 0a 04 00 00                load.sp(+4)
	<.main+5645 @03eded> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@03edee> - <@03ee10>): white: rgbU8 := {...}
	<.main+5646 @03edee> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@03edf2> - <@03edfc>): void(white.r := (255));
	<.main+5650 @03edf2> : 1c ff 00 00 00             load.c32 255
	<.main+5655 @03edf7> : 0a 06 00 00                load.sp(+6)
	<.main+5659 @03edfb> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@03edfc> - <@03ee06>): void(white.g := (255));
	<.main+5660 @03edfc> : 1c ff 00 00 00             load.c32 255
	<.main+5665 @03ee01> : 0a 05 00 00                load.sp(+5)
	<.main+5669 @03ee05> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@03ee06> - <@03ee10>): void(white.b := (255));
	<.main+5670 @03ee06> : 1c ff 00 00 00             load.c32 255
	<.main+5675 @03ee0b> : 0a 04 00 00                load.sp(+4)
	<.main+5679 @03ee0f> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@03ee10> - <@03ee1b>): cyan: color := {...}
	<.main+5680 @03ee10> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@03ee14> - <@03ee1b>): void(cyan.col := (65535));
	<.main+5684 @03ee14> : 1c ff ff 00 00             load.c32 65535
	<.main+5689 @03ee19> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@03ee1b> - <@03ee35>): blue: color := {...}
	<.main+5691 @03ee1b> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@03ee1f> - <@03ee25>): void(blue.rgb.r := (0));
	<.main+5695 @03ee1f> : 19                         load.z32
	<.main+5696 @03ee20> : 0a 06 00 00                load.sp(+6)
	<.main+5700 @03ee24> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@03ee25> - <@03ee2b>): void(blue.rgb.g := (0));
	<.main+5701 @03ee25> : 19                         load.z32
	<.main+5702 @03ee26> : 0a 05 00 00                load.sp(+5)
	<.main+5706 @03ee2a> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@03ee2b> - <@03ee35>): void(blue.rgb.b := (255));
	<.main+5707 @03ee2b> : 1c ff 00 00 00             load.c32 255
	<.main+5712 @03ee30> : 0a 04 00 00                load.sp(+4)
	<.main+5716 @03ee34> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@03ee35> - <@03ee3a>): shift: int32 := 2
	<.main+5717 @03ee35> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@03ee3a> - <@03ee3f>): boolA: bool := true
	<.main+5722 @03ee3a> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@03ee3f> - <@03ee44>): boolB: bool := bool(!false)
	<.main+5727 @03ee3f> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@03ee44> - <@03ee4f>): boolAnd: bool := bool(boolA & boolB)
	<.main+5732 @03ee44> : 0a 04 00 00                load.sp(+4)
	<.main+5736 @03ee48> : 20                         load.i8
	<.main+5737 @03ee49> : 0a 04 00 00                load.sp(+4)
	<.main+5741 @03ee4d> : 20                         load.i8
	<.main+5742 @03ee4e> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@03ee4f> - <@03ee5a>): boolIor: bool := bool(boolA | boolB)
	<.main+5743 @03ee4f> : 0a 08 00 00                load.sp(+8)
	<.main+5747 @03ee53> : 20                         load.i8
	<.main+5748 @03ee54> : 0a 08 00 00                load.sp(+8)
	<.main+5752 @03ee58> : 20                         load.i8
	<.main+5753 @03ee59> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@03ee5a> - <@03ee65>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5754 @03ee5a> : 0a 0c 00 00                load.sp(+12)
	<.main+5758 @03ee5e> : 20                         load.i8
	<.main+5759 @03ee5f> : 0a 0c 00 00                load.sp(+12)
	<.main+5763 @03ee63> : 20                         load.i8
	<.main+5764 @03ee64> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@03ee65> - <@03ee6b>): boolNot: bool := bool(!boolB)
	<.main+5765 @03ee65> : 0a 0c 00 00                load.sp(+12)
	<.main+5769 @03ee69> : 20                         load.i8
	<.main+5770 @03ee6a> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@03ee6b> - <@03ee76>): boolCeq: bool := bool(boolA == boolB)
	<.main+5771 @03ee6b> : 0a 14 00 00                load.sp(+20)
	<.main+5775 @03ee6f> : 20                         load.i8
	<.main+5776 @03ee70> : 0a 14 00 00                load.sp(+20)
	<.main+5780 @03ee74> : 20                         load.i8
	<.main+5781 @03ee75> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@03ee76> - <@03ee82>): boolCne: bool := bool(boolA != boolB)
	<.main+5782 @03ee76> : 0a 18 00 00                load.sp(+24)
	<.main+5786 @03ee7a> : 20                         load.i8
	<.main+5787 @03ee7b> : 0a 18 00 00                load.sp(+24)
	<.main+5791 @03ee7f> : 20                         load.i8
	<.main+5792 @03ee80> : 57                         ceq.i32
	<.main+5793 @03ee81> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@03ee82> - <@03ee8d>): boolClt: bool := bool(boolA < boolB)
	<.main+5794 @03ee82> : 0a 1c 00 00                load.sp(+28)
	<.main+5798 @03ee86> : 20                         load.i8
	<.main+5799 @03ee87> : 0a 1c 00 00                load.sp(+28)
	<.main+5803 @03ee8b> : 20                         load.i8
	<.main+5804 @03ee8c> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@03ee8d> - <@03ee99>): boolCle: bool := bool(boolA <= boolB)
	<.main+5805 @03ee8d> : 0a 20 00 00                load.sp(+32)
	<.main+5809 @03ee91> : 20                         load.i8
	<.main+5810 @03ee92> : 0a 20 00 00                load.sp(+32)
	<.main+5814 @03ee96> : 20                         load.i8
	<.main+5815 @03ee97> : 59                         cgt.i32
	<.main+5816 @03ee98> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@03ee99> - <@03eea4>): boolCgt: bool := bool(boolA > boolB)
	<.main+5817 @03ee99> : 0a 24 00 00                load.sp(+36)
	<.main+5821 @03ee9d> : 20                         load.i8
	<.main+5822 @03ee9e> : 0a 24 00 00                load.sp(+36)
	<.main+5826 @03eea2> : 20                         load.i8
	<.main+5827 @03eea3> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@03eea4> - <@03eeb0>): boolCge: bool := bool(boolA >= boolB)
	<.main+5828 @03eea4> : 0a 28 00 00                load.sp(+40)
	<.main+5832 @03eea8> : 20                         load.i8
	<.main+5833 @03eea9> : 0a 28 00 00                load.sp(+40)
	<.main+5837 @03eead> : 20                         load.i8
	<.main+5838 @03eeae> : 58                         clt.i32
	<.main+5839 @03eeaf> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@03eeb0> - <@03eeb5>): chrA: char := 'a'
	<.main+5840 @03eeb0> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@03eeb5> - <@03eeba>): chrB: char := 'b'
	<.main+5845 @03eeb5> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@03eeba> - <@03eebf>): chrPls: char := char(+chrB)
	<.main+5850 @03eeba> : 0a 00 00 00                load.sp(+0)
	<.main+5854 @03eebe> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@03eebf> - <@03eec5>): chrNeg: char := char(-chrB)
	<.main+5855 @03eebf> : 0a 04 00 00                load.sp(+4)
	<.main+5859 @03eec3> : 20                         load.i8
	<.main+5860 @03eec4> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@03eec5> - <@03eecb>): chrCmt: char := char(~chrB)
	<.main+5861 @03eec5> : 0a 08 00 00                load.sp(+8)
	<.main+5865 @03eec9> : 20                         load.i8
	<.main+5866 @03eeca> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@03eecb> - <@03eed6>): chrAdd: char := char(chrA + chrB)
	<.main+5867 @03eecb> : 0a 10 00 00                load.sp(+16)
	<.main+5871 @03eecf> : 20                         load.i8
	<.main+5872 @03eed0> : 0a 10 00 00                load.sp(+16)
	<.main+5876 @03eed4> : 20                         load.i8
	<.main+5877 @03eed5> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@03eed6> - <@03eee1>): chrSub: char := char(chrA - chrB)
	<.main+5878 @03eed6> : 0a 14 00 00                load.sp(+20)
	<.main+5882 @03eeda> : 20                         load.i8
	<.main+5883 @03eedb> : 0a 14 00 00                load.sp(+20)
	<.main+5887 @03eedf> : 20                         load.i8
	<.main+5888 @03eee0> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@03eee1> - <@03eeec>): chrMul: char := char(chrA * chrB)
	<.main+5889 @03eee1> : 0a 18 00 00                load.sp(+24)
	<.main+5893 @03eee5> : 20                         load.i8
	<.main+5894 @03eee6> : 0a 18 00 00                load.sp(+24)
	<.main+5898 @03eeea> : 20                         load.i8
	<.main+5899 @03eeeb> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@03eeec> - <@03eef7>): chrDiv: char := char(chrA / chrB)
	<.main+5900 @03eeec> : 0a 1c 00 00                load.sp(+28)
	<.main+5904 @03eef0> : 20                         load.i8
	<.main+5905 @03eef1> : 0a 1c 00 00                load.sp(+28)
	<.main+5909 @03eef5> : 20                         load.i8
	<.main+5910 @03eef6> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@03eef7> - <@03ef02>): chrMod: char := char(chrA % chrB)
	<.main+5911 @03eef7> : 0a 20 00 00                load.sp(+32)
	<.main+5915 @03eefb> : 20                         load.i8
	<.main+5916 @03eefc> : 0a 20 00 00                load.sp(+32)
	<.main+5920 @03ef00> : 20                         load.i8
	<.main+5921 @03ef01> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@03ef02> - <@03ef0d>): chrAnd: char := char(chrA & chrB)
	<.main+5922 @03ef02> : 0a 24 00 00                load.sp(+36)
	<.main+5926 @03ef06> : 20                         load.i8
	<.main+5927 @03ef07> : 0a 24 00 00                load.sp(+36)
	<.main+5931 @03ef0b> : 20                         load.i8
	<.main+5932 @03ef0c> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@03ef0d> - <@03ef18>): chrIor: char := char(chrA | chrB)
	<.main+5933 @03ef0d> : 0a 28 00 00                load.sp(+40)
	<.main+5937 @03ef11> : 20                         load.i8
	<.main+5938 @03ef12> : 0a 28 00 00                load.sp(+40)
	<.main+5942 @03ef16> : 20                         load.i8
	<.main+5943 @03ef17> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@03ef18> - <@03ef23>): chrXor: char := char(chrA ^ chrB)
	<.main+5944 @03ef18> : 0a 2c 00 00                load.sp(+44)
	<.main+5948 @03ef1c> : 20                         load.i8
	<.main+5949 @03ef1d> : 0a 2c 00 00                load.sp(+44)
	<.main+5953 @03ef21> : 20                         load.i8
	<.main+5954 @03ef22> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@03ef23> - <@03ef2b>): chrShl: char := int32((chrA) << shift)
	<.main+5955 @03ef23> : 0a 30 00 00                load.sp(+48)
	<.main+5959 @03ef27> : 20                         load.i8
	<.main+5960 @03ef28> : 10 1a                      dup.x1 sp(26)
	<.main+5962 @03ef2a> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@03ef2b> - <@03ef33>): chrShr: char := int32((chrA) >> shift)
	<.main+5963 @03ef2b> : 0a 34 00 00                load.sp(+52)
	<.main+5967 @03ef2f> : 20                         load.i8
	<.main+5968 @03ef30> : 10 1b                      dup.x1 sp(27)
	<.main+5970 @03ef32> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@03ef33> - <@03ef3a>): chrNot: bool := bool(!(chrB))
	<.main+5971 @03ef33> : 0a 34 00 00                load.sp(+52)
	<.main+5975 @03ef37> : 20                         load.i8
	<.main+5976 @03ef38> : 5a                         i32.2bool
	<.main+5977 @03ef39> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@03ef3a> - <@03ef45>): chrCeq: bool := bool(chrA == chrB)
	<.main+5978 @03ef3a> : 0a 3c 00 00                load.sp(+60)
	<.main+5982 @03ef3e> : 20                         load.i8
	<.main+5983 @03ef3f> : 0a 3c 00 00                load.sp(+60)
	<.main+5987 @03ef43> : 20                         load.i8
	<.main+5988 @03ef44> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@03ef45> - <@03ef51>): chrCne: bool := bool(chrA != chrB)
	<.main+5989 @03ef45> : 0a 40 00 00                load.sp(+64)
	<.main+5993 @03ef49> : 20                         load.i8
	<.main+5994 @03ef4a> : 0a 40 00 00                load.sp(+64)
	<.main+5998 @03ef4e> : 20                         load.i8
	<.main+5999 @03ef4f> : 57                         ceq.i32
	<.main+6000 @03ef50> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@03ef51> - <@03ef5c>): chrClt: bool := bool(chrA < chrB)
	<.main+6001 @03ef51> : 0a 44 00 00                load.sp(+68)
	<.main+6005 @03ef55> : 20                         load.i8
	<.main+6006 @03ef56> : 0a 44 00 00                load.sp(+68)
	<.main+6010 @03ef5a> : 20                         load.i8
	<.main+6011 @03ef5b> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@03ef5c> - <@03ef68>): chrCle: bool := bool(chrA <= chrB)
	<.main+6012 @03ef5c> : 0a 48 00 00                load.sp(+72)
	<.main+6016 @03ef60> : 20                         load.i8
	<.main+6017 @03ef61> : 0a 48 00 00                load.sp(+72)
	<.main+6021 @03ef65> : 20                         load.i8
	<.main+6022 @03ef66> : 59                         cgt.i32
	<.main+6023 @03ef67> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@03ef68> - <@03ef73>): chrCgt: bool := bool(chrA > chrB)
	<.main+6024 @03ef68> : 0a 4c 00 00                load.sp(+76)
	<.main+6028 @03ef6c> : 20                         load.i8
	<.main+6029 @03ef6d> : 0a 4c 00 00                load.sp(+76)
	<.main+6033 @03ef71> : 20                         load.i8
	<.main+6034 @03ef72> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@03ef73> - <@03ef7f>): chrCge: bool := bool(chrA >= chrB)
	<.main+6035 @03ef73> : 0a 50 00 00                load.sp(+80)
	<.main+6039 @03ef77> : 20                         load.i8
	<.main+6040 @03ef78> : 0a 50 00 00                load.sp(+80)
	<.main+6044 @03ef7c> : 20                         load.i8
	<.main+6045 @03ef7d> : 58                         clt.i32
	<.main+6046 @03ef7e> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@03ef7f> - <@03ef84>): i8A: int8 := a
	<.main+6047 @03ef7f> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@03ef84> - <@03ef89>): i8B: int8 := b
	<.main+6052 @03ef84> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@03ef89> - <@03ef8e>): i8Pls: int8 := int8(+i8B)
	<.main+6057 @03ef89> : 0a 00 00 00                load.sp(+0)
	<.main+6061 @03ef8d> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@03ef8e> - <@03ef94>): i8Neg: int8 := int8(-i8B)
	<.main+6062 @03ef8e> : 0a 04 00 00                load.sp(+4)
	<.main+6066 @03ef92> : 20                         load.i8
	<.main+6067 @03ef93> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@03ef94> - <@03ef9a>): i8Cmt: int8 := int8(~i8B)
	<.main+6068 @03ef94> : 0a 08 00 00                load.sp(+8)
	<.main+6072 @03ef98> : 20                         load.i8
	<.main+6073 @03ef99> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@03ef9a> - <@03efa5>): i8Add: int8 := int8(i8A + i8B)
	<.main+6074 @03ef9a> : 0a 10 00 00                load.sp(+16)
	<.main+6078 @03ef9e> : 20                         load.i8
	<.main+6079 @03ef9f> : 0a 10 00 00                load.sp(+16)
	<.main+6083 @03efa3> : 20                         load.i8
	<.main+6084 @03efa4> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@03efa5> - <@03efb0>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6085 @03efa5> : 0a 14 00 00                load.sp(+20)
	<.main+6089 @03efa9> : 20                         load.i8
	<.main+6090 @03efaa> : 0a 14 00 00                load.sp(+20)
	<.main+6094 @03efae> : 20                         load.i8
	<.main+6095 @03efaf> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@03efb0> - <@03efbb>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6096 @03efb0> : 0a 18 00 00                load.sp(+24)
	<.main+6100 @03efb4> : 20                         load.i8
	<.main+6101 @03efb5> : 0a 18 00 00                load.sp(+24)
	<.main+6105 @03efb9> : 20                         load.i8
	<.main+6106 @03efba> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@03efbb> - <@03efc6>): i8Div: int8 := int8(i8A / i8B)
	<.main+6107 @03efbb> : 0a 1c 00 00                load.sp(+28)
	<.main+6111 @03efbf> : 20                         load.i8
	<.main+6112 @03efc0> : 0a 1c 00 00                load.sp(+28)
	<.main+6116 @03efc4> : 20                         load.i8
	<.main+6117 @03efc5> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@03efc6> - <@03efd1>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6118 @03efc6> : 0a 20 00 00                load.sp(+32)
	<.main+6122 @03efca> : 20                         load.i8
	<.main+6123 @03efcb> : 0a 20 00 00                load.sp(+32)
	<.main+6127 @03efcf> : 20                         load.i8
	<.main+6128 @03efd0> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@03efd1> - <@03efdc>): i8And: int8 := int8(i8A & i8B)
	<.main+6129 @03efd1> : 0a 24 00 00                load.sp(+36)
	<.main+6133 @03efd5> : 20                         load.i8
	<.main+6134 @03efd6> : 0a 24 00 00                load.sp(+36)
	<.main+6138 @03efda> : 20                         load.i8
	<.main+6139 @03efdb> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@03efdc> - <@03efe7>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6140 @03efdc> : 0a 28 00 00                load.sp(+40)
	<.main+6144 @03efe0> : 20                         load.i8
	<.main+6145 @03efe1> : 0a 28 00 00                load.sp(+40)
	<.main+6149 @03efe5> : 20                         load.i8
	<.main+6150 @03efe6> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@03efe7> - <@03eff2>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6151 @03efe7> : 0a 2c 00 00                load.sp(+44)
	<.main+6155 @03efeb> : 20                         load.i8
	<.main+6156 @03efec> : 0a 2c 00 00                load.sp(+44)
	<.main+6160 @03eff0> : 20                         load.i8
	<.main+6161 @03eff1> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@03eff2> - <@03effa>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6162 @03eff2> : 0a 30 00 00                load.sp(+48)
	<.main+6166 @03eff6> : 20                         load.i8
	<.main+6167 @03eff7> : 10 30                      dup.x1 sp(48)
	<.main+6169 @03eff9> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@03effa> - <@03f002>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6170 @03effa> : 0a 34 00 00                load.sp(+52)
	<.main+6174 @03effe> : 20                         load.i8
	<.main+6175 @03efff> : 10 31                      dup.x1 sp(49)
	<.main+6177 @03f001> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@03f002> - <@03f009>): i8Not: bool := bool(!(i8B))
	<.main+6178 @03f002> : 0a 34 00 00                load.sp(+52)
	<.main+6182 @03f006> : 20                         load.i8
	<.main+6183 @03f007> : 5a                         i32.2bool
	<.main+6184 @03f008> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@03f009> - <@03f014>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6185 @03f009> : 0a 3c 00 00                load.sp(+60)
	<.main+6189 @03f00d> : 20                         load.i8
	<.main+6190 @03f00e> : 0a 3c 00 00                load.sp(+60)
	<.main+6194 @03f012> : 20                         load.i8
	<.main+6195 @03f013> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@03f014> - <@03f020>): i8Cne: bool := bool(i8A != i8B)
	<.main+6196 @03f014> : 0a 40 00 00                load.sp(+64)
	<.main+6200 @03f018> : 20                         load.i8
	<.main+6201 @03f019> : 0a 40 00 00                load.sp(+64)
	<.main+6205 @03f01d> : 20                         load.i8
	<.main+6206 @03f01e> : 57                         ceq.i32
	<.main+6207 @03f01f> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@03f020> - <@03f02b>): i8Clt: bool := bool(i8A < i8B)
	<.main+6208 @03f020> : 0a 44 00 00                load.sp(+68)
	<.main+6212 @03f024> : 20                         load.i8
	<.main+6213 @03f025> : 0a 44 00 00                load.sp(+68)
	<.main+6217 @03f029> : 20                         load.i8
	<.main+6218 @03f02a> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@03f02b> - <@03f037>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6219 @03f02b> : 0a 48 00 00                load.sp(+72)
	<.main+6223 @03f02f> : 20                         load.i8
	<.main+6224 @03f030> : 0a 48 00 00                load.sp(+72)
	<.main+6228 @03f034> : 20                         load.i8
	<.main+6229 @03f035> : 59                         cgt.i32
	<.main+6230 @03f036> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@03f037> - <@03f042>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6231 @03f037> : 0a 4c 00 00                load.sp(+76)
	<.main+6235 @03f03b> : 20                         load.i8
	<.main+6236 @03f03c> : 0a 4c 00 00                load.sp(+76)
	<.main+6240 @03f040> : 20                         load.i8
	<.main+6241 @03f041> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@03f042> - <@03f04e>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6242 @03f042> : 0a 50 00 00                load.sp(+80)
	<.main+6246 @03f046> : 20                         load.i8
	<.main+6247 @03f047> : 0a 50 00 00                load.sp(+80)
	<.main+6251 @03f04b> : 20                         load.i8
	<.main+6252 @03f04c> : 58                         clt.i32
	<.main+6253 @03f04d> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@03f04e> - <@03f053>): u8A: uint8 := a
	<.main+6254 @03f04e> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@03f053> - <@03f058>): u8B: uint8 := b
	<.main+6259 @03f053> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@03f058> - <@03f05d>): u8Pls: uint8 := uint8(+u8B)
	<.main+6264 @03f058> : 0a 00 00 00                load.sp(+0)
	<.main+6268 @03f05c> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@03f05d> - <@03f063>): u8Neg: uint8 := uint8(-u8B)
	<.main+6269 @03f05d> : 0a 04 00 00                load.sp(+4)
	<.main+6273 @03f061> : 20                         load.i8
	<.main+6274 @03f062> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@03f063> - <@03f069>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6275 @03f063> : 0a 08 00 00                load.sp(+8)
	<.main+6279 @03f067> : 20                         load.i8
	<.main+6280 @03f068> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@03f069> - <@03f074>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6281 @03f069> : 0a 10 00 00                load.sp(+16)
	<.main+6285 @03f06d> : 20                         load.i8
	<.main+6286 @03f06e> : 0a 10 00 00                load.sp(+16)
	<.main+6290 @03f072> : 20                         load.i8
	<.main+6291 @03f073> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@03f074> - <@03f07f>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6292 @03f074> : 0a 14 00 00                load.sp(+20)
	<.main+6296 @03f078> : 20                         load.i8
	<.main+6297 @03f079> : 0a 14 00 00                load.sp(+20)
	<.main+6301 @03f07d> : 20                         load.i8
	<.main+6302 @03f07e> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@03f07f> - <@03f08a>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6303 @03f07f> : 0a 18 00 00                load.sp(+24)
	<.main+6307 @03f083> : 20                         load.i8
	<.main+6308 @03f084> : 0a 18 00 00                load.sp(+24)
	<.main+6312 @03f088> : 20                         load.i8
	<.main+6313 @03f089> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@03f08a> - <@03f095>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6314 @03f08a> : 0a 1c 00 00                load.sp(+28)
	<.main+6318 @03f08e> : 20                         load.i8
	<.main+6319 @03f08f> : 0a 1c 00 00                load.sp(+28)
	<.main+6323 @03f093> : 20                         load.i8
	<.main+6324 @03f094> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@03f095> - <@03f0a0>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6325 @03f095> : 0a 20 00 00                load.sp(+32)
	<.main+6329 @03f099> : 20                         load.i8
	<.main+6330 @03f09a> : 0a 20 00 00                load.sp(+32)
	<.main+6334 @03f09e> : 20                         load.i8
	<.main+6335 @03f09f> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@03f0a0> - <@03f0ab>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6336 @03f0a0> : 0a 24 00 00                load.sp(+36)
	<.main+6340 @03f0a4> : 20                         load.i8
	<.main+6341 @03f0a5> : 0a 24 00 00                load.sp(+36)
	<.main+6345 @03f0a9> : 20                         load.i8
	<.main+6346 @03f0aa> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@03f0ab> - <@03f0b6>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6347 @03f0ab> : 0a 28 00 00                load.sp(+40)
	<.main+6351 @03f0af> : 20                         load.i8
	<.main+6352 @03f0b0> : 0a 28 00 00                load.sp(+40)
	<.main+6356 @03f0b4> : 20                         load.i8
	<.main+6357 @03f0b5> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@03f0b6> - <@03f0c1>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6358 @03f0b6> : 0a 2c 00 00                load.sp(+44)
	<.main+6362 @03f0ba> : 20                         load.i8
	<.main+6363 @03f0bb> : 0a 2c 00 00                load.sp(+44)
	<.main+6367 @03f0bf> : 20                         load.i8
	<.main+6368 @03f0c0> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@03f0c1> - <@03f0c9>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6369 @03f0c1> : 0a 30 00 00                load.sp(+48)
	<.main+6373 @03f0c5> : 20                         load.i8
	<.main+6374 @03f0c6> : 10 46                      dup.x1 sp(70)
	<.main+6376 @03f0c8> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@03f0c9> - <@03f0d1>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6377 @03f0c9> : 0a 34 00 00                load.sp(+52)
	<.main+6381 @03f0cd> : 20                         load.i8
	<.main+6382 @03f0ce> : 10 47                      dup.x1 sp(71)
	<.main+6384 @03f0d0> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@03f0d1> - <@03f0d8>): u8Not: bool := bool(!(u8B))
	<.main+6385 @03f0d1> : 0a 34 00 00                load.sp(+52)
	<.main+6389 @03f0d5> : 20                         load.i8
	<.main+6390 @03f0d6> : 5a                         i32.2bool
	<.main+6391 @03f0d7> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@03f0d8> - <@03f0e3>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6392 @03f0d8> : 0a 3c 00 00                load.sp(+60)
	<.main+6396 @03f0dc> : 20                         load.i8
	<.main+6397 @03f0dd> : 0a 3c 00 00                load.sp(+60)
	<.main+6401 @03f0e1> : 20                         load.i8
	<.main+6402 @03f0e2> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@03f0e3> - <@03f0ef>): u8Cne: bool := bool(u8A != u8B)
	<.main+6403 @03f0e3> : 0a 40 00 00                load.sp(+64)
	<.main+6407 @03f0e7> : 20                         load.i8
	<.main+6408 @03f0e8> : 0a 40 00 00                load.sp(+64)
	<.main+6412 @03f0ec> : 20                         load.i8
	<.main+6413 @03f0ed> : 57                         ceq.i32
	<.main+6414 @03f0ee> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@03f0ef> - <@03f0fa>): u8Clt: bool := bool(u8A < u8B)
	<.main+6415 @03f0ef> : 0a 44 00 00                load.sp(+68)
	<.main+6419 @03f0f3> : 20                         load.i8
	<.main+6420 @03f0f4> : 0a 44 00 00                load.sp(+68)
	<.main+6424 @03f0f8> : 20                         load.i8
	<.main+6425 @03f0f9> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@03f0fa> - <@03f106>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6426 @03f0fa> : 0a 48 00 00                load.sp(+72)
	<.main+6430 @03f0fe> : 20                         load.i8
	<.main+6431 @03f0ff> : 0a 48 00 00                load.sp(+72)
	<.main+6435 @03f103> : 20                         load.i8
	<.main+6436 @03f104> : 39                         cgt.u32
	<.main+6437 @03f105> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@03f106> - <@03f111>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6438 @03f106> : 0a 4c 00 00                load.sp(+76)
	<.main+6442 @03f10a> : 20                         load.i8
	<.main+6443 @03f10b> : 0a 4c 00 00                load.sp(+76)
	<.main+6447 @03f10f> : 20                         load.i8
	<.main+6448 @03f110> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@03f111> - <@03f11d>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6449 @03f111> : 0a 50 00 00                load.sp(+80)
	<.main+6453 @03f115> : 20                         load.i8
	<.main+6454 @03f116> : 0a 50 00 00                load.sp(+80)
	<.main+6458 @03f11a> : 20                         load.i8
	<.main+6459 @03f11b> : 38                         clt.u32
	<.main+6460 @03f11c> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@03f11d> - <@03f122>): i16A: int16 := a
	<.main+6461 @03f11d> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@03f122> - <@03f127>): i16B: int16 := b
	<.main+6466 @03f122> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@03f127> - <@03f12c>): i16Pls: int16 := int16(+i16B)
	<.main+6471 @03f127> : 0a 00 00 00                load.sp(+0)
	<.main+6475 @03f12b> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@03f12c> - <@03f132>): i16Neg: int16 := int16(-i16B)
	<.main+6476 @03f12c> : 0a 04 00 00                load.sp(+4)
	<.main+6480 @03f130> : 21                         load.i16
	<.main+6481 @03f131> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@03f132> - <@03f138>): i16Cmt: int16 := int16(~i16B)
	<.main+6482 @03f132> : 0a 08 00 00                load.sp(+8)
	<.main+6486 @03f136> : 21                         load.i16
	<.main+6487 @03f137> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@03f138> - <@03f143>): i16Add: int16 := int16(i16A + i16B)
	<.main+6488 @03f138> : 0a 10 00 00                load.sp(+16)
	<.main+6492 @03f13c> : 21                         load.i16
	<.main+6493 @03f13d> : 0a 10 00 00                load.sp(+16)
	<.main+6497 @03f141> : 21                         load.i16
	<.main+6498 @03f142> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@03f143> - <@03f14e>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6499 @03f143> : 0a 14 00 00                load.sp(+20)
	<.main+6503 @03f147> : 21                         load.i16
	<.main+6504 @03f148> : 0a 14 00 00                load.sp(+20)
	<.main+6508 @03f14c> : 21                         load.i16
	<.main+6509 @03f14d> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@03f14e> - <@03f159>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6510 @03f14e> : 0a 18 00 00                load.sp(+24)
	<.main+6514 @03f152> : 21                         load.i16
	<.main+6515 @03f153> : 0a 18 00 00                load.sp(+24)
	<.main+6519 @03f157> : 21                         load.i16
	<.main+6520 @03f158> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@03f159> - <@03f164>): i16Div: int16 := int16(i16A / i16B)
	<.main+6521 @03f159> : 0a 1c 00 00                load.sp(+28)
	<.main+6525 @03f15d> : 21                         load.i16
	<.main+6526 @03f15e> : 0a 1c 00 00                load.sp(+28)
	<.main+6530 @03f162> : 21                         load.i16
	<.main+6531 @03f163> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@03f164> - <@03f16f>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6532 @03f164> : 0a 20 00 00                load.sp(+32)
	<.main+6536 @03f168> : 21                         load.i16
	<.main+6537 @03f169> : 0a 20 00 00                load.sp(+32)
	<.main+6541 @03f16d> : 21                         load.i16
	<.main+6542 @03f16e> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@03f16f> - <@03f17a>): i16And: int16 := int16(i16A & i16B)
	<.main+6543 @03f16f> : 0a 24 00 00                load.sp(+36)
	<.main+6547 @03f173> : 21                         load.i16
	<.main+6548 @03f174> : 0a 24 00 00                load.sp(+36)
	<.main+6552 @03f178> : 21                         load.i16
	<.main+6553 @03f179> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@03f17a> - <@03f185>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6554 @03f17a> : 0a 28 00 00                load.sp(+40)
	<.main+6558 @03f17e> : 21                         load.i16
	<.main+6559 @03f17f> : 0a 28 00 00                load.sp(+40)
	<.main+6563 @03f183> : 21                         load.i16
	<.main+6564 @03f184> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@03f185> - <@03f190>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6565 @03f185> : 0a 2c 00 00                load.sp(+44)
	<.main+6569 @03f189> : 21                         load.i16
	<.main+6570 @03f18a> : 0a 2c 00 00                load.sp(+44)
	<.main+6574 @03f18e> : 21                         load.i16
	<.main+6575 @03f18f> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@03f190> - <@03f198>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6576 @03f190> : 0a 30 00 00                load.sp(+48)
	<.main+6580 @03f194> : 21                         load.i16
	<.main+6581 @03f195> : 10 5c                      dup.x1 sp(92)
	<.main+6583 @03f197> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@03f198> - <@03f1a0>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6584 @03f198> : 0a 34 00 00                load.sp(+52)
	<.main+6588 @03f19c> : 21                         load.i16
	<.main+6589 @03f19d> : 10 5d                      dup.x1 sp(93)
	<.main+6591 @03f19f> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@03f1a0> - <@03f1a7>): i16Not: bool := bool(!(i16B))
	<.main+6592 @03f1a0> : 0a 34 00 00                load.sp(+52)
	<.main+6596 @03f1a4> : 21                         load.i16
	<.main+6597 @03f1a5> : 5a                         i32.2bool
	<.main+6598 @03f1a6> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@03f1a7> - <@03f1b2>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6599 @03f1a7> : 0a 3c 00 00                load.sp(+60)
	<.main+6603 @03f1ab> : 21                         load.i16
	<.main+6604 @03f1ac> : 0a 3c 00 00                load.sp(+60)
	<.main+6608 @03f1b0> : 21                         load.i16
	<.main+6609 @03f1b1> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@03f1b2> - <@03f1be>): i16Cne: bool := bool(i16A != i16B)
	<.main+6610 @03f1b2> : 0a 40 00 00                load.sp(+64)
	<.main+6614 @03f1b6> : 21                         load.i16
	<.main+6615 @03f1b7> : 0a 40 00 00                load.sp(+64)
	<.main+6619 @03f1bb> : 21                         load.i16
	<.main+6620 @03f1bc> : 57                         ceq.i32
	<.main+6621 @03f1bd> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@03f1be> - <@03f1c9>): i16Clt: bool := bool(i16A < i16B)
	<.main+6622 @03f1be> : 0a 44 00 00                load.sp(+68)
	<.main+6626 @03f1c2> : 21                         load.i16
	<.main+6627 @03f1c3> : 0a 44 00 00                load.sp(+68)
	<.main+6631 @03f1c7> : 21                         load.i16
	<.main+6632 @03f1c8> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@03f1c9> - <@03f1d5>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6633 @03f1c9> : 0a 48 00 00                load.sp(+72)
	<.main+6637 @03f1cd> : 21                         load.i16
	<.main+6638 @03f1ce> : 0a 48 00 00                load.sp(+72)
	<.main+6642 @03f1d2> : 21                         load.i16
	<.main+6643 @03f1d3> : 59                         cgt.i32
	<.main+6644 @03f1d4> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@03f1d5> - <@03f1e0>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6645 @03f1d5> : 0a 4c 00 00                load.sp(+76)
	<.main+6649 @03f1d9> : 21                         load.i16
	<.main+6650 @03f1da> : 0a 4c 00 00                load.sp(+76)
	<.main+6654 @03f1de> : 21                         load.i16
	<.main+6655 @03f1df> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@03f1e0> - <@03f1ec>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6656 @03f1e0> : 0a 50 00 00                load.sp(+80)
	<.main+6660 @03f1e4> : 21                         load.i16
	<.main+6661 @03f1e5> : 0a 50 00 00                load.sp(+80)
	<.main+6665 @03f1e9> : 21                         load.i16
	<.main+6666 @03f1ea> : 58                         clt.i32
	<.main+6667 @03f1eb> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@03f1ec> - <@03f1f1>): u16A: uint16 := a
	<.main+6668 @03f1ec> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@03f1f1> - <@03f1f6>): u16B: uint16 := b
	<.main+6673 @03f1f1> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@03f1f6> - <@03f1fb>): u16Pls: uint16 := uint16(+u16B)
	<.main+6678 @03f1f6> : 0a 00 00 00                load.sp(+0)
	<.main+6682 @03f1fa> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@03f1fb> - <@03f201>): u16Neg: uint16 := uint16(-u16B)
	<.main+6683 @03f1fb> : 0a 04 00 00                load.sp(+4)
	<.main+6687 @03f1ff> : 21                         load.i16
	<.main+6688 @03f200> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@03f201> - <@03f207>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6689 @03f201> : 0a 08 00 00                load.sp(+8)
	<.main+6693 @03f205> : 21                         load.i16
	<.main+6694 @03f206> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@03f207> - <@03f212>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6695 @03f207> : 0a 10 00 00                load.sp(+16)
	<.main+6699 @03f20b> : 21                         load.i16
	<.main+6700 @03f20c> : 0a 10 00 00                load.sp(+16)
	<.main+6704 @03f210> : 21                         load.i16
	<.main+6705 @03f211> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@03f212> - <@03f21d>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6706 @03f212> : 0a 14 00 00                load.sp(+20)
	<.main+6710 @03f216> : 21                         load.i16
	<.main+6711 @03f217> : 0a 14 00 00                load.sp(+20)
	<.main+6715 @03f21b> : 21                         load.i16
	<.main+6716 @03f21c> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@03f21d> - <@03f228>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6717 @03f21d> : 0a 18 00 00                load.sp(+24)
	<.main+6721 @03f221> : 21                         load.i16
	<.main+6722 @03f222> : 0a 18 00 00                load.sp(+24)
	<.main+6726 @03f226> : 21                         load.i16
	<.main+6727 @03f227> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@03f228> - <@03f233>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6728 @03f228> : 0a 1c 00 00                load.sp(+28)
	<.main+6732 @03f22c> : 21                         load.i16
	<.main+6733 @03f22d> : 0a 1c 00 00                load.sp(+28)
	<.main+6737 @03f231> : 21                         load.i16
	<.main+6738 @03f232> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@03f233> - <@03f23e>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6739 @03f233> : 0a 20 00 00                load.sp(+32)
	<.main+6743 @03f237> : 21                         load.i16
	<.main+6744 @03f238> : 0a 20 00 00                load.sp(+32)
	<.main+6748 @03f23c> : 21                         load.i16
	<.main+6749 @03f23d> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@03f23e> - <@03f249>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6750 @03f23e> : 0a 24 00 00                load.sp(+36)
	<.main+6754 @03f242> : 21                         load.i16
	<.main+6755 @03f243> : 0a 24 00 00                load.sp(+36)
	<.main+6759 @03f247> : 21                         load.i16
	<.main+6760 @03f248> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@03f249> - <@03f254>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6761 @03f249> : 0a 28 00 00                load.sp(+40)
	<.main+6765 @03f24d> : 21                         load.i16
	<.main+6766 @03f24e> : 0a 28 00 00                load.sp(+40)
	<.main+6770 @03f252> : 21                         load.i16
	<.main+6771 @03f253> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@03f254> - <@03f25f>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6772 @03f254> : 0a 2c 00 00                load.sp(+44)
	<.main+6776 @03f258> : 21                         load.i16
	<.main+6777 @03f259> : 0a 2c 00 00                load.sp(+44)
	<.main+6781 @03f25d> : 21                         load.i16
	<.main+6782 @03f25e> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@03f25f> - <@03f267>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6783 @03f25f> : 0a 30 00 00                load.sp(+48)
	<.main+6787 @03f263> : 21                         load.i16
	<.main+6788 @03f264> : 10 72                      dup.x1 sp(114)
	<.main+6790 @03f266> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@03f267> - <@03f26f>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6791 @03f267> : 0a 34 00 00                load.sp(+52)
	<.main+6795 @03f26b> : 21                         load.i16
	<.main+6796 @03f26c> : 10 73                      dup.x1 sp(115)
	<.main+6798 @03f26e> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@03f26f> - <@03f276>): u16Not: bool := bool(!(u16B))
	<.main+6799 @03f26f> : 0a 34 00 00                load.sp(+52)
	<.main+6803 @03f273> : 21                         load.i16
	<.main+6804 @03f274> : 5a                         i32.2bool
	<.main+6805 @03f275> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@03f276> - <@03f281>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6806 @03f276> : 0a 3c 00 00                load.sp(+60)
	<.main+6810 @03f27a> : 21                         load.i16
	<.main+6811 @03f27b> : 0a 3c 00 00                load.sp(+60)
	<.main+6815 @03f27f> : 21                         load.i16
	<.main+6816 @03f280> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@03f281> - <@03f28d>): u16Cne: bool := bool(u16A != u16B)
	<.main+6817 @03f281> : 0a 40 00 00                load.sp(+64)
	<.main+6821 @03f285> : 21                         load.i16
	<.main+6822 @03f286> : 0a 40 00 00                load.sp(+64)
	<.main+6826 @03f28a> : 21                         load.i16
	<.main+6827 @03f28b> : 57                         ceq.i32
	<.main+6828 @03f28c> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@03f28d> - <@03f298>): u16Clt: bool := bool(u16A < u16B)
	<.main+6829 @03f28d> : 0a 44 00 00                load.sp(+68)
	<.main+6833 @03f291> : 21                         load.i16
	<.main+6834 @03f292> : 0a 44 00 00                load.sp(+68)
	<.main+6838 @03f296> : 21                         load.i16
	<.main+6839 @03f297> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@03f298> - <@03f2a4>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6840 @03f298> : 0a 48 00 00                load.sp(+72)
	<.main+6844 @03f29c> : 21                         load.i16
	<.main+6845 @03f29d> : 0a 48 00 00                load.sp(+72)
	<.main+6849 @03f2a1> : 21                         load.i16
	<.main+6850 @03f2a2> : 39                         cgt.u32
	<.main+6851 @03f2a3> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@03f2a4> - <@03f2af>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6852 @03f2a4> : 0a 4c 00 00                load.sp(+76)
	<.main+6856 @03f2a8> : 21                         load.i16
	<.main+6857 @03f2a9> : 0a 4c 00 00                load.sp(+76)
	<.main+6861 @03f2ad> : 21                         load.i16
	<.main+6862 @03f2ae> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@03f2af> - <@03f2bb>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6863 @03f2af> : 0a 50 00 00                load.sp(+80)
	<.main+6867 @03f2b3> : 21                         load.i16
	<.main+6868 @03f2b4> : 0a 50 00 00                load.sp(+80)
	<.main+6872 @03f2b8> : 21                         load.i16
	<.main+6873 @03f2b9> : 38                         clt.u32
	<.main+6874 @03f2ba> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@03f2bb> - <@03f2c0>): i32A: int32 := a
	<.main+6875 @03f2bb> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@03f2c0> - <@03f2c5>): i32B: int32 := b
	<.main+6880 @03f2c0> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@03f2c5> - <@03f2c7>): i32Pls: int32 := int32(+i32B)
	<.main+6885 @03f2c5> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@03f2c7> - <@03f2ca>): i32Neg: int32 := int32(-i32B)
	<.main+6887 @03f2c7> : 10 01                      dup.x1 sp(1)
	<.main+6889 @03f2c9> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@03f2ca> - <@03f2cd>): i32Cmt: int32 := int32(~i32B)
	<.main+6890 @03f2ca> : 10 02                      dup.x1 sp(2)
	<.main+6892 @03f2cc> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@03f2cd> - <@03f2d2>): i32Add: int32 := int32(i32A + i32B)
	<.main+6893 @03f2cd> : 10 04                      dup.x1 sp(4)
	<.main+6895 @03f2cf> : 10 04                      dup.x1 sp(4)
	<.main+6897 @03f2d1> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@03f2d2> - <@03f2d7>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6898 @03f2d2> : 10 05                      dup.x1 sp(5)
	<.main+6900 @03f2d4> : 10 05                      dup.x1 sp(5)
	<.main+6902 @03f2d6> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@03f2d7> - <@03f2dc>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6903 @03f2d7> : 10 06                      dup.x1 sp(6)
	<.main+6905 @03f2d9> : 10 06                      dup.x1 sp(6)
	<.main+6907 @03f2db> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@03f2dc> - <@03f2e1>): i32Div: int32 := int32(i32A / i32B)
	<.main+6908 @03f2dc> : 10 07                      dup.x1 sp(7)
	<.main+6910 @03f2de> : 10 07                      dup.x1 sp(7)
	<.main+6912 @03f2e0> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@03f2e1> - <@03f2e6>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6913 @03f2e1> : 10 08                      dup.x1 sp(8)
	<.main+6915 @03f2e3> : 10 08                      dup.x1 sp(8)
	<.main+6917 @03f2e5> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@03f2e6> - <@03f2eb>): i32And: int32 := int32(i32A & i32B)
	<.main+6918 @03f2e6> : 10 09                      dup.x1 sp(9)
	<.main+6920 @03f2e8> : 10 09                      dup.x1 sp(9)
	<.main+6922 @03f2ea> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@03f2eb> - <@03f2f0>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6923 @03f2eb> : 10 0a                      dup.x1 sp(10)
	<.main+6925 @03f2ed> : 10 0a                      dup.x1 sp(10)
	<.main+6927 @03f2ef> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@03f2f0> - <@03f2f5>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6928 @03f2f0> : 10 0b                      dup.x1 sp(11)
	<.main+6930 @03f2f2> : 10 0b                      dup.x1 sp(11)
	<.main+6932 @03f2f4> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@03f2f5> - <@03f2fa>): i32Shl: int32 := int32(i32A << shift)
	<.main+6933 @03f2f5> : 10 0c                      dup.x1 sp(12)
	<.main+6935 @03f2f7> : 10 88                      dup.x1 sp(136)
	<.main+6937 @03f2f9> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@03f2fa> - <@03f2ff>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6938 @03f2fa> : 10 0d                      dup.x1 sp(13)
	<.main+6940 @03f2fc> : 10 89                      dup.x1 sp(137)
	<.main+6942 @03f2fe> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@03f2ff> - <@03f303>): i32Not: bool := bool(!(i32B))
	<.main+6943 @03f2ff> : 10 0d                      dup.x1 sp(13)
	<.main+6945 @03f301> : 5a                         i32.2bool
	<.main+6946 @03f302> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@03f303> - <@03f308>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6947 @03f303> : 10 0f                      dup.x1 sp(15)
	<.main+6949 @03f305> : 10 0f                      dup.x1 sp(15)
	<.main+6951 @03f307> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@03f308> - <@03f30e>): i32Cne: bool := bool(i32A != i32B)
	<.main+6952 @03f308> : 10 10                      dup.x1 sp(16)
	<.main+6954 @03f30a> : 10 10                      dup.x1 sp(16)
	<.main+6956 @03f30c> : 57                         ceq.i32
	<.main+6957 @03f30d> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@03f30e> - <@03f313>): i32Clt: bool := bool(i32A < i32B)
	<.main+6958 @03f30e> : 10 11                      dup.x1 sp(17)
	<.main+6960 @03f310> : 10 11                      dup.x1 sp(17)
	<.main+6962 @03f312> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@03f313> - <@03f319>): i32Cle: bool := bool(i32A <= i32B)
	<.main+6963 @03f313> : 10 12                      dup.x1 sp(18)
	<.main+6965 @03f315> : 10 12                      dup.x1 sp(18)
	<.main+6967 @03f317> : 59                         cgt.i32
	<.main+6968 @03f318> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@03f319> - <@03f31e>): i32Cgt: bool := bool(i32A > i32B)
	<.main+6969 @03f319> : 10 13                      dup.x1 sp(19)
	<.main+6971 @03f31b> : 10 13                      dup.x1 sp(19)
	<.main+6973 @03f31d> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@03f31e> - <@03f324>): i32Cge: bool := bool(i32A >= i32B)
	<.main+6974 @03f31e> : 10 14                      dup.x1 sp(20)
	<.main+6976 @03f320> : 10 14                      dup.x1 sp(20)
	<.main+6978 @03f322> : 58                         clt.i32
	<.main+6979 @03f323> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@03f324> - <@03f329>): u32A: uint32 := a
	<.main+6980 @03f324> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@03f329> - <@03f32e>): u32B: uint32 := b
	<.main+6985 @03f329> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@03f32e> - <@03f330>): u32Pls: uint32 := uint32(+u32B)
	<.main+6990 @03f32e> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@03f330> - <@03f333>): u32Neg: uint32 := uint32(-u32B)
	<.main+6992 @03f330> : 10 01                      dup.x1 sp(1)
	<.main+6994 @03f332> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@03f333> - <@03f336>): u32Cmt: uint32 := uint32(~u32B)
	<.main+6995 @03f333> : 10 02                      dup.x1 sp(2)
	<.main+6997 @03f335> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@03f336> - <@03f33b>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+6998 @03f336> : 10 04                      dup.x1 sp(4)
	<.main+7000 @03f338> : 10 04                      dup.x1 sp(4)
	<.main+7002 @03f33a> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@03f33b> - <@03f340>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7003 @03f33b> : 10 05                      dup.x1 sp(5)
	<.main+7005 @03f33d> : 10 05                      dup.x1 sp(5)
	<.main+7007 @03f33f> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@03f340> - <@03f345>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7008 @03f340> : 10 06                      dup.x1 sp(6)
	<.main+7010 @03f342> : 10 06                      dup.x1 sp(6)
	<.main+7012 @03f344> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@03f345> - <@03f34a>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7013 @03f345> : 10 07                      dup.x1 sp(7)
	<.main+7015 @03f347> : 10 07                      dup.x1 sp(7)
	<.main+7017 @03f349> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@03f34a> - <@03f34f>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7018 @03f34a> : 10 08                      dup.x1 sp(8)
	<.main+7020 @03f34c> : 10 08                      dup.x1 sp(8)
	<.main+7022 @03f34e> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@03f34f> - <@03f354>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7023 @03f34f> : 10 09                      dup.x1 sp(9)
	<.main+7025 @03f351> : 10 09                      dup.x1 sp(9)
	<.main+7027 @03f353> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@03f354> - <@03f359>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7028 @03f354> : 10 0a                      dup.x1 sp(10)
	<.main+7030 @03f356> : 10 0a                      dup.x1 sp(10)
	<.main+7032 @03f358> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@03f359> - <@03f35e>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7033 @03f359> : 10 0b                      dup.x1 sp(11)
	<.main+7035 @03f35b> : 10 0b                      dup.x1 sp(11)
	<.main+7037 @03f35d> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@03f35e> - <@03f363>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7038 @03f35e> : 10 0c                      dup.x1 sp(12)
	<.main+7040 @03f360> : 10 9e                      dup.x1 sp(158)
	<.main+7042 @03f362> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@03f363> - <@03f368>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7043 @03f363> : 10 0d                      dup.x1 sp(13)
	<.main+7045 @03f365> : 10 9f                      dup.x1 sp(159)
	<.main+7047 @03f367> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@03f368> - <@03f36c>): u32Not: bool := bool(!(u32B))
	<.main+7048 @03f368> : 10 0d                      dup.x1 sp(13)
	<.main+7050 @03f36a> : 5a                         i32.2bool
	<.main+7051 @03f36b> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@03f36c> - <@03f371>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7052 @03f36c> : 10 0f                      dup.x1 sp(15)
	<.main+7054 @03f36e> : 10 0f                      dup.x1 sp(15)
	<.main+7056 @03f370> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@03f371> - <@03f377>): u32Cne: bool := bool(u32A != u32B)
	<.main+7057 @03f371> : 10 10                      dup.x1 sp(16)
	<.main+7059 @03f373> : 10 10                      dup.x1 sp(16)
	<.main+7061 @03f375> : 57                         ceq.i32
	<.main+7062 @03f376> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@03f377> - <@03f37c>): u32Clt: bool := bool(u32A < u32B)
	<.main+7063 @03f377> : 10 11                      dup.x1 sp(17)
	<.main+7065 @03f379> : 10 11                      dup.x1 sp(17)
	<.main+7067 @03f37b> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@03f37c> - <@03f382>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7068 @03f37c> : 10 12                      dup.x1 sp(18)
	<.main+7070 @03f37e> : 10 12                      dup.x1 sp(18)
	<.main+7072 @03f380> : 39                         cgt.u32
	<.main+7073 @03f381> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@03f382> - <@03f387>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7074 @03f382> : 10 13                      dup.x1 sp(19)
	<.main+7076 @03f384> : 10 13                      dup.x1 sp(19)
	<.main+7078 @03f386> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@03f387> - <@03f38d>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7079 @03f387> : 10 14                      dup.x1 sp(20)
	<.main+7081 @03f389> : 10 14                      dup.x1 sp(20)
	<.main+7083 @03f38b> : 38                         clt.u32
	<.main+7084 @03f38c> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@03f38d> - <@03f396>): i64A: int64 := a
	<.main+7085 @03f38d> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@03f396> - <@03f39f>): i64B: int64 := b
	<.main+7094 @03f396> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@03f39f> - <@03f3a1>): i64Pls: int64 := int64(+i64B)
	<.main+7103 @03f39f> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@03f3a1> - <@03f3a4>): i64Neg: int64 := int64(-i64B)
	<.main+7105 @03f3a1> : 11 02                      dup.x2 sp(2)
	<.main+7107 @03f3a3> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@03f3a4> - <@03f3a7>): i64Cmt: int64 := int64(~i64B)
	<.main+7108 @03f3a4> : 11 04                      dup.x2 sp(4)
	<.main+7110 @03f3a6> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@03f3a7> - <@03f3ac>): i64Add: int64 := int64(i64A + i64B)
	<.main+7111 @03f3a7> : 11 08                      dup.x2 sp(8)
	<.main+7113 @03f3a9> : 11 08                      dup.x2 sp(8)
	<.main+7115 @03f3ab> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@03f3ac> - <@03f3b1>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7116 @03f3ac> : 11 0a                      dup.x2 sp(10)
	<.main+7118 @03f3ae> : 11 0a                      dup.x2 sp(10)
	<.main+7120 @03f3b0> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@03f3b1> - <@03f3b6>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7121 @03f3b1> : 11 0c                      dup.x2 sp(12)
	<.main+7123 @03f3b3> : 11 0c                      dup.x2 sp(12)
	<.main+7125 @03f3b5> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@03f3b6> - <@03f3bb>): i64Div: int64 := int64(i64A / i64B)
	<.main+7126 @03f3b6> : 11 0e                      dup.x2 sp(14)
	<.main+7128 @03f3b8> : 11 0e                      dup.x2 sp(14)
	<.main+7130 @03f3ba> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@03f3bb> - <@03f3c0>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7131 @03f3bb> : 11 10                      dup.x2 sp(16)
	<.main+7133 @03f3bd> : 11 10                      dup.x2 sp(16)
	<.main+7135 @03f3bf> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@03f3c0> - <@03f3c5>): i64And: int64 := int64(i64A & i64B)
	<.main+7136 @03f3c0> : 11 12                      dup.x2 sp(18)
	<.main+7138 @03f3c2> : 11 12                      dup.x2 sp(18)
	<.main+7140 @03f3c4> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@03f3c5> - <@03f3ca>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7141 @03f3c5> : 11 14                      dup.x2 sp(20)
	<.main+7143 @03f3c7> : 11 14                      dup.x2 sp(20)
	<.main+7145 @03f3c9> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@03f3ca> - <@03f3cf>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7146 @03f3ca> : 11 16                      dup.x2 sp(22)
	<.main+7148 @03f3cc> : 11 16                      dup.x2 sp(22)
	<.main+7150 @03f3ce> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@03f3cf> - <@03f3d4>): i64Shl: int64 := int64(i64A << shift)
	<.main+7151 @03f3cf> : 11 18                      dup.x2 sp(24)
	<.main+7153 @03f3d1> : 10 c2                      dup.x1 sp(194)
	<.main+7155 @03f3d3> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@03f3d4> - <@03f3d9>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7156 @03f3d4> : 11 1a                      dup.x2 sp(26)
	<.main+7158 @03f3d6> : 10 c4                      dup.x1 sp(196)
	<.main+7160 @03f3d8> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@03f3d9> - <@03f3dd>): i64Not: bool := bool(!(i64B))
	<.main+7161 @03f3d9> : 11 1a                      dup.x2 sp(26)
	<.main+7163 @03f3db> : 6c                         i64.2bool
	<.main+7164 @03f3dc> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@03f3dd> - <@03f3e2>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7165 @03f3dd> : 11 1d                      dup.x2 sp(29)
	<.main+7167 @03f3df> : 11 1d                      dup.x2 sp(29)
	<.main+7169 @03f3e1> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@03f3e2> - <@03f3e8>): i64Cne: bool := bool(i64A != i64B)
	<.main+7170 @03f3e2> : 11 1e                      dup.x2 sp(30)
	<.main+7172 @03f3e4> : 11 1e                      dup.x2 sp(30)
	<.main+7174 @03f3e6> : 67                         ceq.i64
	<.main+7175 @03f3e7> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@03f3e8> - <@03f3ed>): i64Clt: bool := bool(i64A < i64B)
	<.main+7176 @03f3e8> : 11 1f                      dup.x2 sp(31)
	<.main+7178 @03f3ea> : 11 1f                      dup.x2 sp(31)
	<.main+7180 @03f3ec> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@03f3ed> - <@03f3f3>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7181 @03f3ed> : 11 20                      dup.x2 sp(32)
	<.main+7183 @03f3ef> : 11 20                      dup.x2 sp(32)
	<.main+7185 @03f3f1> : 69                         cgt.i64
	<.main+7186 @03f3f2> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@03f3f3> - <@03f3f8>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7187 @03f3f3> : 11 21                      dup.x2 sp(33)
	<.main+7189 @03f3f5> : 11 21                      dup.x2 sp(33)
	<.main+7191 @03f3f7> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@03f3f8> - <@03f3fe>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7192 @03f3f8> : 11 22                      dup.x2 sp(34)
	<.main+7194 @03f3fa> : 11 22                      dup.x2 sp(34)
	<.main+7196 @03f3fc> : 68                         clt.i64
	<.main+7197 @03f3fd> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@03f3fe> - <@03f407>): u64A: uint64 := a
	<.main+7198 @03f3fe> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@03f407> - <@03f410>): u64B: uint64 := b
	<.main+7207 @03f407> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@03f410> - <@03f412>): u64Pls: uint64 := uint64(+u64B)
	<.main+7216 @03f410> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@03f412> - <@03f415>): u64Neg: uint64 := uint64(-u64B)
	<.main+7218 @03f412> : 11 02                      dup.x2 sp(2)
	<.main+7220 @03f414> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@03f415> - <@03f418>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7221 @03f415> : 11 04                      dup.x2 sp(4)
	<.main+7223 @03f417> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@03f418> - <@03f41d>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7224 @03f418> : 11 08                      dup.x2 sp(8)
	<.main+7226 @03f41a> : 11 08                      dup.x2 sp(8)
	<.main+7228 @03f41c> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@03f41d> - <@03f422>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7229 @03f41d> : 11 0a                      dup.x2 sp(10)
	<.main+7231 @03f41f> : 11 0a                      dup.x2 sp(10)
	<.main+7233 @03f421> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@03f422> - <@03f427>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7234 @03f422> : 11 0c                      dup.x2 sp(12)
	<.main+7236 @03f424> : 11 0c                      dup.x2 sp(12)
	<.main+7238 @03f426> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@03f427> - <@03f42c>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7239 @03f427> : 11 0e                      dup.x2 sp(14)
	<.main+7241 @03f429> : 11 0e                      dup.x2 sp(14)
	<.main+7243 @03f42b> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@03f42c> - <@03f431>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7244 @03f42c> : 11 10                      dup.x2 sp(16)
	<.main+7246 @03f42e> : 11 10                      dup.x2 sp(16)
	<.main+7248 @03f430> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@03f431> - <@03f436>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7249 @03f431> : 11 12                      dup.x2 sp(18)
	<.main+7251 @03f433> : 11 12                      dup.x2 sp(18)
	<.main+7253 @03f435> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@03f436> - <@03f43b>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7254 @03f436> : 11 14                      dup.x2 sp(20)
	<.main+7256 @03f438> : 11 14                      dup.x2 sp(20)
	<.main+7258 @03f43a> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@03f43b> - <@03f440>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7259 @03f43b> : 11 16                      dup.x2 sp(22)
	<.main+7261 @03f43d> : 11 16                      dup.x2 sp(22)
	<.main+7263 @03f43f> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@03f440> - <@03f445>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7264 @03f440> : 11 18                      dup.x2 sp(24)
	<.main+7266 @03f442> : 10 e7                      dup.x1 sp(231)
	<.main+7268 @03f444> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@03f445> - <@03f44a>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7269 @03f445> : 11 1a                      dup.x2 sp(26)
	<.main+7271 @03f447> : 10 e9                      dup.x1 sp(233)
	<.main+7273 @03f449> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@03f44a> - <@03f44e>): u64Not: bool := bool(!(u64B))
	<.main+7274 @03f44a> : 11 1a                      dup.x2 sp(26)
	<.main+7276 @03f44c> : 6c                         i64.2bool
	<.main+7277 @03f44d> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@03f44e> - <@03f453>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7278 @03f44e> : 11 1d                      dup.x2 sp(29)
	<.main+7280 @03f450> : 11 1d                      dup.x2 sp(29)
	<.main+7282 @03f452> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@03f453> - <@03f459>): u64Cne: bool := bool(u64A != u64B)
	<.main+7283 @03f453> : 11 1e                      dup.x2 sp(30)
	<.main+7285 @03f455> : 11 1e                      dup.x2 sp(30)
	<.main+7287 @03f457> : 67                         ceq.i64
	<.main+7288 @03f458> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@03f459> - <@03f45e>): u64Clt: bool := bool(u64A < u64B)
	<.main+7289 @03f459> : 11 1f                      dup.x2 sp(31)
	<.main+7291 @03f45b> : 11 1f                      dup.x2 sp(31)
	<.main+7293 @03f45d> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@03f45e> - <@03f464>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7294 @03f45e> : 11 20                      dup.x2 sp(32)
	<.main+7296 @03f460> : 11 20                      dup.x2 sp(32)
	<.main+7298 @03f462> : 49                         cgt.u64
	<.main+7299 @03f463> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@03f464> - <@03f469>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7300 @03f464> : 11 21                      dup.x2 sp(33)
	<.main+7302 @03f466> : 11 21                      dup.x2 sp(33)
	<.main+7304 @03f468> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@03f469> - <@03f46f>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7305 @03f469> : 11 22                      dup.x2 sp(34)
	<.main+7307 @03f46b> : 11 22                      dup.x2 sp(34)
	<.main+7309 @03f46d> : 48                         clt.u64
	<.main+7310 @03f46e> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@03f46f> - <@03f474>): f32A: float32 := a
	<.main+7311 @03f46f> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@03f474> - <@03f479>): f32B: float32 := b
	<.main+7316 @03f474> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@03f479> - <@03f47b>): f32Pls: float32 := float32(+f32B)
	<.main+7321 @03f479> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@03f47b> - <@03f47e>): f32Neg: float32 := float32(-f32B)
	<.main+7323 @03f47b> : 10 01                      dup.x1 sp(1)
	<.main+7325 @03f47d> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@03f47e> - <@03f483>): f32Add: float32 := float32(f32A + f32B)
	<.main+7326 @03f47e> : 10 03                      dup.x1 sp(3)
	<.main+7328 @03f480> : 10 03                      dup.x1 sp(3)
	<.main+7330 @03f482> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@03f483> - <@03f488>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7331 @03f483> : 10 04                      dup.x1 sp(4)
	<.main+7333 @03f485> : 10 04                      dup.x1 sp(4)
	<.main+7335 @03f487> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@03f488> - <@03f48d>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7336 @03f488> : 10 05                      dup.x1 sp(5)
	<.main+7338 @03f48a> : 10 05                      dup.x1 sp(5)
	<.main+7340 @03f48c> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@03f48d> - <@03f492>): f32Div: float32 := float32(f32A / f32B)
	<.main+7341 @03f48d> : 10 06                      dup.x1 sp(6)
	<.main+7343 @03f48f> : 10 06                      dup.x1 sp(6)
	<.main+7345 @03f491> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@03f492> - <@03f497>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7346 @03f492> : 10 07                      dup.x1 sp(7)
	<.main+7348 @03f494> : 10 07                      dup.x1 sp(7)
	<.main+7350 @03f496> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@03f497> - <@03f49b>): f32Not: bool := bool(!(f32B))
	<.main+7351 @03f497> : 10 07                      dup.x1 sp(7)
	<.main+7353 @03f499> : 7b                         f32.2bool
	<.main+7354 @03f49a> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@03f49b> - <@03f4a0>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7355 @03f49b> : 10 09                      dup.x1 sp(9)
	<.main+7357 @03f49d> : 10 09                      dup.x1 sp(9)
	<.main+7359 @03f49f> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@03f4a0> - <@03f4a6>): f32Cne: bool := bool(f32A != f32B)
	<.main+7360 @03f4a0> : 10 0a                      dup.x1 sp(10)
	<.main+7362 @03f4a2> : 10 0a                      dup.x1 sp(10)
	<.main+7364 @03f4a4> : 77                         ceq.f32
	<.main+7365 @03f4a5> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@03f4a6> - <@03f4ab>): f32Clt: bool := bool(f32A < f32B)
	<.main+7366 @03f4a6> : 10 0b                      dup.x1 sp(11)
	<.main+7368 @03f4a8> : 10 0b                      dup.x1 sp(11)
	<.main+7370 @03f4aa> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@03f4ab> - <@03f4b1>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7371 @03f4ab> : 10 0c                      dup.x1 sp(12)
	<.main+7373 @03f4ad> : 10 0c                      dup.x1 sp(12)
	<.main+7375 @03f4af> : 79                         cgt.f32
	<.main+7376 @03f4b0> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@03f4b1> - <@03f4b6>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7377 @03f4b1> : 10 0d                      dup.x1 sp(13)
	<.main+7379 @03f4b3> : 10 0d                      dup.x1 sp(13)
	<.main+7381 @03f4b5> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@03f4b6> - <@03f4bc>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7382 @03f4b6> : 10 0e                      dup.x1 sp(14)
	<.main+7384 @03f4b8> : 10 0e                      dup.x1 sp(14)
	<.main+7386 @03f4ba> : 78                         clt.f32
	<.main+7387 @03f4bb> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@03f4bc> - <@03f4c5>): f64A: float64 := a
	<.main+7388 @03f4bc> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@03f4c5> - <@03f4ce>): f64B: float64 := b
	<.main+7397 @03f4c5> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@03f4ce> - <@03f4d0>): f64Pls: float64 := float64(+f64B)
	<.main+7406 @03f4ce> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@03f4d0> - <@03f4d3>): f64Neg: float64 := float64(-f64B)
	<.main+7408 @03f4d0> : 11 02                      dup.x2 sp(2)
	<.main+7410 @03f4d2> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@03f4d3> - <@03f4d8>): f64Add: float64 := float64(f64A + f64B)
	<.main+7411 @03f4d3> : 11 06                      dup.x2 sp(6)
	<.main+7413 @03f4d5> : 11 06                      dup.x2 sp(6)
	<.main+7415 @03f4d7> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@03f4d8> - <@03f4dd>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7416 @03f4d8> : 11 08                      dup.x2 sp(8)
	<.main+7418 @03f4da> : 11 08                      dup.x2 sp(8)
	<.main+7420 @03f4dc> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@03f4dd> - <@03f4e2>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7421 @03f4dd> : 11 0a                      dup.x2 sp(10)
	<.main+7423 @03f4df> : 11 0a                      dup.x2 sp(10)
	<.main+7425 @03f4e1> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@03f4e2> - <@03f4e7>): f64Div: float64 := float64(f64A / f64B)
	<.main+7426 @03f4e2> : 11 0c                      dup.x2 sp(12)
	<.main+7428 @03f4e4> : 11 0c                      dup.x2 sp(12)
	<.main+7430 @03f4e6> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@03f4e7> - <@03f4ec>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7431 @03f4e7> : 11 0e                      dup.x2 sp(14)
	<.main+7433 @03f4e9> : 11 0e                      dup.x2 sp(14)
	<.main+7435 @03f4eb> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@03f4ec> - <@03f4f0>): f64Not: bool := bool(!(f64B))
	<.main+7436 @03f4ec> : 11 0e                      dup.x2 sp(14)
	<.main+7438 @03f4ee> : 8d                         f64.2bool
	<.main+7439 @03f4ef> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@03f4f0> - <@03f4f5>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7440 @03f4f0> : 11 11                      dup.x2 sp(17)
	<.main+7442 @03f4f2> : 11 11                      dup.x2 sp(17)
	<.main+7444 @03f4f4> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@03f4f5> - <@03f4fb>): f64Cne: bool := bool(f64A != f64B)
	<.main+7445 @03f4f5> : 11 12                      dup.x2 sp(18)
	<.main+7447 @03f4f7> : 11 12                      dup.x2 sp(18)
	<.main+7449 @03f4f9> : 87                         ceq.f64
	<.main+7450 @03f4fa> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@03f4fb> - <@03f500>): f64Clt: bool := bool(f64A < f64B)
	<.main+7451 @03f4fb> : 11 13                      dup.x2 sp(19)
	<.main+7453 @03f4fd> : 11 13                      dup.x2 sp(19)
	<.main+7455 @03f4ff> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@03f500> - <@03f506>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7456 @03f500> : 11 14                      dup.x2 sp(20)
	<.main+7458 @03f502> : 11 14                      dup.x2 sp(20)
	<.main+7460 @03f504> : 89                         cgt.f64
	<.main+7461 @03f505> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@03f506> - <@03f50b>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7462 @03f506> : 11 15                      dup.x2 sp(21)
	<.main+7464 @03f508> : 11 15                      dup.x2 sp(21)
	<.main+7466 @03f50a> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@03f50b> - <@03f511>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7467 @03f50b> : 11 16                      dup.x2 sp(22)
	<.main+7469 @03f50d> : 11 16                      dup.x2 sp(22)
	<.main+7471 @03f50f> : 88                         clt.f64
	<.main+7472 @03f510> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@03f511> - <@03f516>): ptrA: pointer := null
	<.main+7473 @03f511> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@03f516> - <@03f51a>): ptrB: pointer := pointer(shift)
	<.main+7478 @03f516> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@03f51a> - <@03f51f>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7482 @03f51a> : 10 01                      dup.x1 sp(1)
	<.main+7484 @03f51c> : 10 01                      dup.x1 sp(1)
	<.main+7486 @03f51e> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@03f51f> - <@03f525>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7487 @03f51f> : 10 02                      dup.x1 sp(2)
	<.main+7489 @03f521> : 10 02                      dup.x1 sp(2)
	<.main+7491 @03f523> : 57                         ceq.i32
	<.main+7492 @03f524> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@03f525> - <@03f54c>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7493 @03f525> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7498 @03f52a> : 1c 04 00 00 00             load.c32 4
	<.main+7503 @03f52f> : 1c 0e 00 00 00             load.c32 14
	<.main+7508 @03f534> : 1c 01 00 00 00             load.c32 1
	<.main+7513 @03f539> : 1f a1 c0 03 00             load.ref <@03c0a1> ;"0 == 0"
	<.main+7518 @03f53e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7523 @03f543> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7528 @03f548> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@03f54c> - <@03f573>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7532 @03f54c> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7537 @03f551> : 1c 0c 00 00 00             load.c32 12
	<.main+7542 @03f556> : 1c 0e 00 00 00             load.c32 14
	<.main+7547 @03f55b> : 1c 03 00 00 00             load.c32 3
	<.main+7552 @03f560> : 1f a1 c0 03 00             load.ref <@03c0a1> ;"0 == 0"
	<.main+7557 @03f565> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7562 @03f56a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7567 @03f56f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@03f573> - <@03f59a>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7571 @03f573> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7576 @03f578> : 1c 16 00 00 00             load.c32 22
	<.main+7581 @03f57d> : 1c 0e 00 00 00             load.c32 14
	<.main+7586 @03f582> : 1c 06 00 00 00             load.c32 6
	<.main+7591 @03f587> : 1f a1 c0 03 00             load.ref <@03c0a1> ;"0 == 0"
	<.main+7596 @03f58c> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7601 @03f591> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7606 @03f596> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@03f59a> - <@03f59b>): t: int32 := 0
	<.main+7610 @03f59a> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@03f59b> - <@03f5c9>): if (bool(t == 0))
	<.main+7611 @03f59b> : 10 00                      dup.x1 sp(0)
	<.main+7613 @03f59d> : 19                         load.z32
	<.main+7614 @03f59e> : 57                         ceq.i32
	<.main+7615 @03f59f> : 06 2a 00 00                jz <.main+7657 @03f5c9>
	test/lang/statementIf.ci:29: (38 bytes: <@03f5a3> - <@03f5c9>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7619 @03f5a3> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7624 @03f5a8> : 1c 1d 00 00 00             load.c32 29
	<.main+7629 @03f5ad> : 1c 0e 00 00 00             load.c32 14
	<.main+7634 @03f5b2> : 1c 07 00 00 00             load.c32 7
	<.main+7639 @03f5b7> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7644 @03f5bc> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7649 @03f5c1> : 0a 18 00 00                load.sp(+24)
	<.main+7653 @03f5c5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@03f5c9> - <@03f5f7>): if (bool(t != 0))
	<.main+7657 @03f5c9> : 10 00                      dup.x1 sp(0)
	<.main+7659 @03f5cb> : 19                         load.z32
	<.main+7660 @03f5cc> : 57                         ceq.i32
	<.main+7661 @03f5cd> : 05 2a 00 00                jnz <.main+7703 @03f5f7>
	test/lang/statementIf.ci:33: (38 bytes: <@03f5d1> - <@03f5f7>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7665 @03f5d1> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7670 @03f5d6> : 1c 21 00 00 00             load.c32 33
	<.main+7675 @03f5db> : 1c 0e 00 00 00             load.c32 14
	<.main+7680 @03f5e0> : 1c 08 00 00 00             load.c32 8
	<.main+7685 @03f5e5> : 1f b6 c0 03 00             load.ref <@03c0b6> ;"t != 0"
	<.main+7690 @03f5ea> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7695 @03f5ef> : 0a 18 00 00                load.sp(+24)
	<.main+7699 @03f5f3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@03f5f7> - <@03f64f>): if (bool(t == 0))
	<.main+7703 @03f5f7> : 10 00                      dup.x1 sp(0)
	<.main+7705 @03f5f9> : 19                         load.z32
	<.main+7706 @03f5fa> : 57                         ceq.i32
	<.main+7707 @03f5fb> : 06 2e 00 00                jz <.main+7753 @03f629>
	test/lang/statementIf.ci:37: (38 bytes: <@03f5ff> - <@03f625>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7711 @03f5ff> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7716 @03f604> : 1c 25 00 00 00             load.c32 37
	<.main+7721 @03f609> : 1c 0e 00 00 00             load.c32 14
	<.main+7726 @03f60e> : 1c 09 00 00 00             load.c32 9
	<.main+7731 @03f613> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7736 @03f618> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7741 @03f61d> : 0a 18 00 00                load.sp(+24)
	<.main+7745 @03f621> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7749 @03f625> : 04 2a 00 00                jmp <.main+7791 @03f64f>
	test/lang/statementIf.ci:40: (38 bytes: <@03f629> - <@03f64f>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7753 @03f629> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7758 @03f62e> : 1c 28 00 00 00             load.c32 40
	<.main+7763 @03f633> : 1c 0e 00 00 00             load.c32 14
	<.main+7768 @03f638> : 1c 0a 00 00 00             load.c32 10
	<.main+7773 @03f63d> : 1f b6 c0 03 00             load.ref <@03c0b6> ;"t != 0"
	<.main+7778 @03f642> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7783 @03f647> : 0a 18 00 00                load.sp(+24)
	<.main+7787 @03f64b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@03f64f> - <@03f6a7>): if (bool(t != 0))
	<.main+7791 @03f64f> : 10 00                      dup.x1 sp(0)
	<.main+7793 @03f651> : 19                         load.z32
	<.main+7794 @03f652> : 57                         ceq.i32
	<.main+7795 @03f653> : 05 2e 00 00                jnz <.main+7841 @03f681>
	test/lang/statementIf.ci:44: (38 bytes: <@03f657> - <@03f67d>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7799 @03f657> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7804 @03f65c> : 1c 2c 00 00 00             load.c32 44
	<.main+7809 @03f661> : 1c 0e 00 00 00             load.c32 14
	<.main+7814 @03f666> : 1c 0b 00 00 00             load.c32 11
	<.main+7819 @03f66b> : 1f b6 c0 03 00             load.ref <@03c0b6> ;"t != 0"
	<.main+7824 @03f670> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7829 @03f675> : 0a 18 00 00                load.sp(+24)
	<.main+7833 @03f679> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7837 @03f67d> : 04 2a 00 00                jmp <.main+7879 @03f6a7>
	test/lang/statementIf.ci:47: (38 bytes: <@03f681> - <@03f6a7>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7841 @03f681> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7846 @03f686> : 1c 2f 00 00 00             load.c32 47
	<.main+7851 @03f68b> : 1c 0e 00 00 00             load.c32 14
	<.main+7856 @03f690> : 1c 0c 00 00 00             load.c32 12
	<.main+7861 @03f695> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7866 @03f69a> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7871 @03f69f> : 0a 18 00 00                load.sp(+24)
	<.main+7875 @03f6a3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@03f6a7> - <@03f80d>): if (bool(t == 0))
	<.main+7879 @03f6a7> : 10 00                      dup.x1 sp(0)
	<.main+7881 @03f6a9> : 19                         load.z32
	<.main+7882 @03f6aa> : 57                         ceq.i32
	<.main+7883 @03f6ab> : 06 2e 00 00                jz <.main+7929 @03f6d9>
	test/lang/statementIf.ci:51: (38 bytes: <@03f6af> - <@03f6d5>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7887 @03f6af> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7892 @03f6b4> : 1c 33 00 00 00             load.c32 51
	<.main+7897 @03f6b9> : 1c 0e 00 00 00             load.c32 14
	<.main+7902 @03f6be> : 1c 09 00 00 00             load.c32 9
	<.main+7907 @03f6c3> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7912 @03f6c8> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7917 @03f6cd> : 0a 18 00 00                load.sp(+24)
	<.main+7921 @03f6d1> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7925 @03f6d5> : 04 38 01 00                jmp <.main+8237 @03f80d>
	test/lang/statementIf.ci:53: (308 bytes: <@03f6d9> - <@03f80d>): if (bool(t == 1))
	<.main+7929 @03f6d9> : 10 00                      dup.x1 sp(0)
	<.main+7931 @03f6db> : 1c 01 00 00 00             load.c32 1
	<.main+7936 @03f6e0> : 57                         ceq.i32
	<.main+7937 @03f6e1> : 06 2e 00 00                jz <.main+7983 @03f70f>
	test/lang/statementIf.ci:54: (38 bytes: <@03f6e5> - <@03f70b>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7941 @03f6e5> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7946 @03f6ea> : 1c 36 00 00 00             load.c32 54
	<.main+7951 @03f6ef> : 1c 0e 00 00 00             load.c32 14
	<.main+7956 @03f6f4> : 1c 0a 00 00 00             load.c32 10
	<.main+7961 @03f6f9> : 1f bd c0 03 00             load.ref <@03c0bd> ;"t == 1"
	<.main+7966 @03f6fe> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7971 @03f703> : 0a 18 00 00                load.sp(+24)
	<.main+7975 @03f707> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7979 @03f70b> : 04 02 01 00                jmp <.main+8237 @03f80d>
	test/lang/statementIf.ci:56: (254 bytes: <@03f70f> - <@03f80d>): if (bool(t == 2))
	<.main+7983 @03f70f> : 10 00                      dup.x1 sp(0)
	<.main+7985 @03f711> : 1c 02 00 00 00             load.c32 2
	<.main+7990 @03f716> : 57                         ceq.i32
	<.main+7991 @03f717> : 06 2e 00 00                jz <.main+8037 @03f745>
	test/lang/statementIf.ci:57: (38 bytes: <@03f71b> - <@03f741>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+7995 @03f71b> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8000 @03f720> : 1c 39 00 00 00             load.c32 57
	<.main+8005 @03f725> : 1c 0e 00 00 00             load.c32 14
	<.main+8010 @03f72a> : 1c 0a 00 00 00             load.c32 10
	<.main+8015 @03f72f> : 1f c4 c0 03 00             load.ref <@03c0c4> ;"t == 2"
	<.main+8020 @03f734> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8025 @03f739> : 0a 18 00 00                load.sp(+24)
	<.main+8029 @03f73d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8033 @03f741> : 04 cc 00 00                jmp <.main+8237 @03f80d>
	test/lang/statementIf.ci:59: (200 bytes: <@03f745> - <@03f80d>): if (bool(t == 3))
	<.main+8037 @03f745> : 10 00                      dup.x1 sp(0)
	<.main+8039 @03f747> : 1c 03 00 00 00             load.c32 3
	<.main+8044 @03f74c> : 57                         ceq.i32
	<.main+8045 @03f74d> : 06 2e 00 00                jz <.main+8091 @03f77b>
	test/lang/statementIf.ci:60: (38 bytes: <@03f751> - <@03f777>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8049 @03f751> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8054 @03f756> : 1c 3c 00 00 00             load.c32 60
	<.main+8059 @03f75b> : 1c 0e 00 00 00             load.c32 14
	<.main+8064 @03f760> : 1c 0a 00 00 00             load.c32 10
	<.main+8069 @03f765> : 1f cb c0 03 00             load.ref <@03c0cb> ;"t == 3"
	<.main+8074 @03f76a> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8079 @03f76f> : 0a 18 00 00                load.sp(+24)
	<.main+8083 @03f773> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8087 @03f777> : 04 96 00 00                jmp <.main+8237 @03f80d>
	test/lang/statementIf.ci:62: (146 bytes: <@03f77b> - <@03f80d>): if (bool(t == 4))
	<.main+8091 @03f77b> : 10 00                      dup.x1 sp(0)
	<.main+8093 @03f77d> : 1c 04 00 00 00             load.c32 4
	<.main+8098 @03f782> : 57                         ceq.i32
	<.main+8099 @03f783> : 06 2e 00 00                jz <.main+8145 @03f7b1>
	test/lang/statementIf.ci:63: (38 bytes: <@03f787> - <@03f7ad>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8103 @03f787> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8108 @03f78c> : 1c 3f 00 00 00             load.c32 63
	<.main+8113 @03f791> : 1c 0e 00 00 00             load.c32 14
	<.main+8118 @03f796> : 1c 0a 00 00 00             load.c32 10
	<.main+8123 @03f79b> : 1f d2 c0 03 00             load.ref <@03c0d2> ;"t == 4"
	<.main+8128 @03f7a0> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8133 @03f7a5> : 0a 18 00 00                load.sp(+24)
	<.main+8137 @03f7a9> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8141 @03f7ad> : 04 60 00 00                jmp <.main+8237 @03f80d>
	test/lang/statementIf.ci:65: (92 bytes: <@03f7b1> - <@03f80d>): if (bool(t == 5))
	<.main+8145 @03f7b1> : 10 00                      dup.x1 sp(0)
	<.main+8147 @03f7b3> : 1c 05 00 00 00             load.c32 5
	<.main+8152 @03f7b8> : 57                         ceq.i32
	<.main+8153 @03f7b9> : 06 2e 00 00                jz <.main+8199 @03f7e7>
	test/lang/statementIf.ci:66: (38 bytes: <@03f7bd> - <@03f7e3>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8157 @03f7bd> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8162 @03f7c2> : 1c 42 00 00 00             load.c32 66
	<.main+8167 @03f7c7> : 1c 0e 00 00 00             load.c32 14
	<.main+8172 @03f7cc> : 1c 0a 00 00 00             load.c32 10
	<.main+8177 @03f7d1> : 1f d9 c0 03 00             load.ref <@03c0d9> ;"t == 5"
	<.main+8182 @03f7d6> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8187 @03f7db> : 0a 18 00 00                load.sp(+24)
	<.main+8191 @03f7df> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8195 @03f7e3> : 04 2a 00 00                jmp <.main+8237 @03f80d>
	test/lang/statementIf.ci:69: (38 bytes: <@03f7e7> - <@03f80d>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8199 @03f7e7> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8204 @03f7ec> : 1c 45 00 00 00             load.c32 69
	<.main+8209 @03f7f1> : 1c 0e 00 00 00             load.c32 14
	<.main+8214 @03f7f6> : 1c 0a 00 00 00             load.c32 10
	<.main+8219 @03f7fb> : 1f e0 c0 03 00             load.ref <@03c0e0> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8224 @03f800> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8229 @03f805> : 0a 18 00 00                load.sp(+24)
	<.main+8233 @03f809> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@03f80d> - <@03f83c>): for ( ; ; )
	<.main+8237 @03f80d> : 04 2b 00 00                jmp <.main+8280 @03f838>
	test/lang/statementFor.ci:4: (35 bytes: <@03f811> - <@03f834>): debug("for ( ; ; )");
	<.main+8241 @03f811> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8246 @03f816> : 1c 04 00 00 00             load.c32 4
	<.main+8251 @03f81b> : 1c 0e 00 00 00             load.c32 14
	<.main+8256 @03f820> : 19                         load.z32
	<.main+8257 @03f821> : 1f d2 c1 03 00             load.ref <@03c1d2> ;"for ( ; ; )"
	<.main+8262 @03f826> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+8267 @03f82b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8272 @03f830> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@03f834> - <@03f838>): break;
	<.main+8276 @03f834> : 04 08 00 00                jmp <.main+8284 @03f83c>
	:: (4 bytes: <@03f838> - <@03f83c>)
	<.main+8280 @03f838> : 04 d9 ff ff                jmp <.main+8241 @03f811>
	test/lang/statementFor.ci:8: (59 bytes: <@03f83c> - <@03f877>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8284 @03f83c> : 19                         load.z32
	<.main+8285 @03f83d> : 04 2a 00 00                jmp <.main+8327 @03f867>
	test/lang/statementFor.ci:9: (34 bytes: <@03f841> - <@03f863>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8289 @03f841> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8294 @03f846> : 1c 09 00 00 00             load.c32 9
	<.main+8299 @03f84b> : 1c 0e 00 00 00             load.c32 14
	<.main+8304 @03f850> : 19                         load.z32
	<.main+8305 @03f851> : 1f de c1 03 00             load.ref <@03c1de> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8310 @03f856> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8315 @03f85b> : 0a 18 00 00                load.sp(+24)
	<.main+8319 @03f85f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@03f863> - <@03f867>): int32(i := int32(i + 1))
	<.main+8323 @03f863> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@03f867> - <@03f873>): bool(i < 2)
	<.main+8327 @03f867> : 10 00                      dup.x1 sp(0)
	<.main+8329 @03f869> : 1c 02 00 00 00             load.c32 2
	<.main+8334 @03f86e> : 58                         clt.i32
	<.main+8335 @03f86f> : 05 d2 ff ff                jnz <.main+8289 @03f841>
	<.main+8339 @03f873> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@03f877> - <@03f878>): forIdx: int32
	<.main+8343 @03f877> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@03f878> - <@03f8b1>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8344 @03f878> : 19                         load.z32
	<.main+8345 @03f879> : 13 01                      set.x1 sp(1)
	<.main+8347 @03f87b> : 04 2a 00 00                jmp <.main+8389 @03f8a5>
	test/lang/statementFor.ci:14: (34 bytes: <@03f87f> - <@03f8a1>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8351 @03f87f> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8356 @03f884> : 1c 0e 00 00 00             load.c32 14
	<.main+8361 @03f889> : 1c 0e 00 00 00             load.c32 14
	<.main+8366 @03f88e> : 19                         load.z32
	<.main+8367 @03f88f> : 1f 04 c2 03 00             load.ref <@03c204> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8372 @03f894> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8377 @03f899> : 0a 18 00 00                load.sp(+24)
	<.main+8381 @03f89d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@03f8a1> - <@03f8a5>): int32(forIdx := int32(forIdx + 1))
	<.main+8385 @03f8a1> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@03f8a5> - <@03f8b1>): bool(forIdx < 2)
	<.main+8389 @03f8a5> : 10 00                      dup.x1 sp(0)
	<.main+8391 @03f8a7> : 1c 02 00 00 00             load.c32 2
	<.main+8396 @03f8ac> : 58                         clt.i32
	<.main+8397 @03f8ad> : 05 d2 ff ff                jnz <.main+8351 @03f87f>
	test/lang/statementFor.ci:17: (75 bytes: <@03f8b1> - <@03f8fc>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8401 @03f8b1> : 19                         load.z32
	<.main+8402 @03f8b2> : 04 3a 00 00                jmp <.main+8460 @03f8ec>
	test/lang/statementFor.ci:18: (16 bytes: <@03f8b6> - <@03f8c6>): if (bool(i < 2))
	<.main+8406 @03f8b6> : 10 00                      dup.x1 sp(0)
	<.main+8408 @03f8b8> : 1c 02 00 00 00             load.c32 2
	<.main+8413 @03f8bd> : 58                         clt.i32
	<.main+8414 @03f8be> : 06 08 00 00                jz <.main+8422 @03f8c6>
	test/lang/statementFor.ci:19: (4 bytes: <@03f8c2> - <@03f8c6>): continue;
	<.main+8418 @03f8c2> : 04 26 00 00                jmp <.main+8456 @03f8e8>
	test/lang/statementFor.ci:21: (34 bytes: <@03f8c6> - <@03f8e8>): debug(void("for with continue", i));
	<.main+8422 @03f8c6> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8427 @03f8cb> : 1c 15 00 00 00             load.c32 21
	<.main+8432 @03f8d0> : 1c 0e 00 00 00             load.c32 14
	<.main+8437 @03f8d5> : 19                         load.z32
	<.main+8438 @03f8d6> : 1f 2e c2 03 00             load.ref <@03c22e> ;"for with continue"
	<.main+8443 @03f8db> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8448 @03f8e0> : 0a 18 00 00                load.sp(+24)
	<.main+8452 @03f8e4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@03f8e8> - <@03f8ec>): int32(i := int32(i + 1))
	<.main+8456 @03f8e8> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@03f8ec> - <@03f8f8>): bool(i < 7)
	<.main+8460 @03f8ec> : 10 00                      dup.x1 sp(0)
	<.main+8462 @03f8ee> : 1c 07 00 00 00             load.c32 7
	<.main+8467 @03f8f3> : 58                         clt.i32
	<.main+8468 @03f8f4> : 05 c2 ff ff                jnz <.main+8406 @03f8b6>
	<.main+8472 @03f8f8> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@03f8fc> - <@03f947>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8476 @03f8fc> : 19                         load.z32
	<.main+8477 @03f8fd> : 04 3a 00 00                jmp <.main+8535 @03f937>
	test/lang/statementFor.ci:25: (16 bytes: <@03f901> - <@03f911>): if (bool(i > 2))
	<.main+8481 @03f901> : 10 00                      dup.x1 sp(0)
	<.main+8483 @03f903> : 1c 02 00 00 00             load.c32 2
	<.main+8488 @03f908> : 59                         cgt.i32
	<.main+8489 @03f909> : 06 08 00 00                jz <.main+8497 @03f911>
	test/lang/statementFor.ci:26: (4 bytes: <@03f90d> - <@03f911>): break;
	<.main+8493 @03f90d> : 04 36 00 00                jmp <.main+8547 @03f943>
	test/lang/statementFor.ci:28: (34 bytes: <@03f911> - <@03f933>): debug(void("for with break", i));
	<.main+8497 @03f911> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8502 @03f916> : 1c 1c 00 00 00             load.c32 28
	<.main+8507 @03f91b> : 1c 0e 00 00 00             load.c32 14
	<.main+8512 @03f920> : 19                         load.z32
	<.main+8513 @03f921> : 1f 40 c2 03 00             load.ref <@03c240> ;"for with break"
	<.main+8518 @03f926> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8523 @03f92b> : 0a 18 00 00                load.sp(+24)
	<.main+8527 @03f92f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@03f933> - <@03f937>): int32(i := int32(i + 1))
	<.main+8531 @03f933> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@03f937> - <@03f943>): bool(i < 7)
	<.main+8535 @03f937> : 10 00                      dup.x1 sp(0)
	<.main+8537 @03f939> : 1c 07 00 00 00             load.c32 7
	<.main+8542 @03f93e> : 58                         clt.i32
	<.main+8543 @03f93f> : 05 c2 ff ff                jnz <.main+8481 @03f901>
	<.main+8547 @03f943> : 09 fc ff ff                inc.sp(-4)
	<.main+8551 @03f947> : 01 00 00 00                nfc(0) ;halt(): void
.references:
}

---------- Execute: byte-code
[ 192.65] > .main
[ 192.69]  > float32.sin(x: float32): float32
[ 192.71]  < return
[ 193.00]  > funAdd(x: int32, y: int32): int32
[ 193.01]  < return
[ 193.02]  > funAdd(x: int32, y: int32): int32
[ 193.03]  < return
[ 193.04]  > funMul(x: int32, y: int32): int32
[ 193.04]  < return
[ 193.06]  > funMul(x: int32, y: int32): int32
[ 193.06]  < return
[ 193.07]  > fib(n: uint32): uint32
[ 193.08]   > fib(n: uint32): uint32
[ 193.09]    > fib(n: uint32): uint32
[ 193.10]     > fib(n: uint32): uint32
[ 193.11]      > fib(n: uint32): uint32
[ 193.12]       > fib(n: uint32): uint32
[ 193.13]        > fib(n: uint32): uint32
[ 193.13]         > fib(n: uint32): uint32
[ 193.14]          > fib(n: uint32): uint32
[ 193.15]           > fib(n: uint32): uint32
[ 193.16]            > fib(n: uint32): uint32
[ 193.17]             > fib(n: uint32): uint32
[ 193.18]              > fib(n: uint32): uint32
[ 193.19]              < return
[ 193.19]              > fib(n: uint32): uint32
[ 193.20]              < return
[ 193.21]             < return
[ 193.22]             > fib(n: uint32): uint32
[ 193.22]             < return
[ 193.23]            < return
[ 193.24]            > fib(n: uint32): uint32
[ 193.25]             > fib(n: uint32): uint32
[ 193.25]             < return
[ 193.26]             > fib(n: uint32): uint32
[ 193.27]             < return
[ 193.28]            < return
[ 193.28]           < return
[ 193.29]           > fib(n: uint32): uint32
[ 193.30]            > fib(n: uint32): uint32
[ 193.31]             > fib(n: uint32): uint32
[ 193.31]             < return
[ 193.32]             > fib(n: uint32): uint32
[ 193.33]             < return
[ 193.34]            < return
[ 193.34]            > fib(n: uint32): uint32
[ 193.35]            < return
[ 193.36]           < return
[ 193.36]          < return
[ 193.37]          > fib(n: uint32): uint32
[ 193.38]           > fib(n: uint32): uint32
[ 193.39]            > fib(n: uint32): uint32
[ 193.40]             > fib(n: uint32): uint32
[ 193.41]             < return
[ 193.41]             > fib(n: uint32): uint32
[ 193.42]             < return
[ 193.43]            < return
[ 193.43]            > fib(n: uint32): uint32
[ 193.44]            < return
[ 193.45]           < return
[ 193.46]           > fib(n: uint32): uint32
[ 193.46]            > fib(n: uint32): uint32
[ 193.47]            < return
[ 193.48]            > fib(n: uint32): uint32
[ 193.49]            < return
[ 193.49]           < return
[ 193.50]          < return
[ 193.51]         < return
[ 193.51]         > fib(n: uint32): uint32
[ 193.52]          > fib(n: uint32): uint32
[ 193.53]           > fib(n: uint32): uint32
[ 193.54]            > fib(n: uint32): uint32
[ 193.55]             > fib(n: uint32): uint32
[ 193.56]             < return
[ 193.57]             > fib(n: uint32): uint32
[ 193.57]             < return
[ 193.58]            < return
[ 193.59]            > fib(n: uint32): uint32
[ 193.60]            < return
[ 193.60]           < return
[ 193.61]           > fib(n: uint32): uint32
[ 193.62]            > fib(n: uint32): uint32
[ 193.63]            < return
[ 193.63]            > fib(n: uint32): uint32
[ 193.64]            < return
[ 193.65]           < return
[ 193.65]          < return
[ 193.66]          > fib(n: uint32): uint32
[ 193.67]           > fib(n: uint32): uint32
[ 193.68]            > fib(n: uint32): uint32
[ 193.69]            < return
[ 193.69]            > fib(n: uint32): uint32
[ 193.70]            < return
[ 193.71]           < return
[ 193.72]           > fib(n: uint32): uint32
[ 193.72]           < return
[ 193.73]          < return
[ 193.74]         < return
[ 193.74]        < return
[ 193.75]        > fib(n: uint32): uint32
[ 193.76]         > fib(n: uint32): uint32
[ 193.77]          > fib(n: uint32): uint32
[ 193.78]           > fib(n: uint32): uint32
[ 193.79]            > fib(n: uint32): uint32
[ 193.80]             > fib(n: uint32): uint32
[ 193.81]             < return
[ 193.81]             > fib(n: uint32): uint32
[ 193.82]             < return
[ 193.83]            < return
[ 193.84]            > fib(n: uint32): uint32
[ 193.84]            < return
[ 193.85]           < return
[ 193.86]           > fib(n: uint32): uint32
[ 193.87]            > fib(n: uint32): uint32
[ 193.87]            < return
[ 193.88]            > fib(n: uint32): uint32
[ 193.89]            < return
[ 193.90]           < return
[ 193.90]          < return
[ 193.91]          > fib(n: uint32): uint32
[ 193.92]           > fib(n: uint32): uint32
[ 193.93]            > fib(n: uint32): uint32
[ 193.94]            < return
[ 193.94]            > fib(n: uint32): uint32
[ 193.95]            < return
[ 193.96]           < return
[ 193.97]           > fib(n: uint32): uint32
[ 193.97]           < return
[ 193.98]          < return
[ 193.99]         < return
[ 193.99]         > fib(n: uint32): uint32
[ 194.00]          > fib(n: uint32): uint32
[ 194.01]           > fib(n: uint32): uint32
[ 194.02]            > fib(n: uint32): uint32
[ 194.03]            < return
[ 194.03]            > fib(n: uint32): uint32
[ 194.04]            < return
[ 194.05]           < return
[ 194.06]           > fib(n: uint32): uint32
[ 194.06]           < return
[ 194.07]          < return
[ 194.08]          > fib(n: uint32): uint32
[ 194.09]           > fib(n: uint32): uint32
[ 194.09]           < return
[ 194.10]           > fib(n: uint32): uint32
[ 194.11]           < return
[ 194.12]          < return
[ 194.12]         < return
[ 194.13]        < return
[ 194.13]       < return
[ 194.14]       > fib(n: uint32): uint32
[ 194.15]        > fib(n: uint32): uint32
[ 194.16]         > fib(n: uint32): uint32
[ 194.17]          > fib(n: uint32): uint32
[ 194.18]           > fib(n: uint32): uint32
[ 194.18]            > fib(n: uint32): uint32
[ 194.19]             > fib(n: uint32): uint32
[ 194.20]             < return
[ 194.21]             > fib(n: uint32): uint32
[ 194.22]             < return
[ 194.23]            < return
[ 194.23]            > fib(n: uint32): uint32
[ 194.24]            < return
[ 194.25]           < return
[ 194.26]           > fib(n: uint32): uint32
[ 194.26]            > fib(n: uint32): uint32
[ 194.27]            < return
[ 194.28]            > fib(n: uint32): uint32
[ 194.29]            < return
[ 194.29]           < return
[ 194.30]          < return
[ 194.31]          > fib(n: uint32): uint32
[ 194.32]           > fib(n: uint32): uint32
[ 194.32]            > fib(n: uint32): uint32
[ 194.33]            < return
[ 194.34]            > fib(n: uint32): uint32
[ 194.35]            < return
[ 194.35]           < return
[ 194.36]           > fib(n: uint32): uint32
[ 194.37]           < return
[ 194.38]          < return
[ 194.38]         < return
[ 194.39]         > fib(n: uint32): uint32
[ 194.40]          > fib(n: uint32): uint32
[ 194.41]           > fib(n: uint32): uint32
[ 194.42]            > fib(n: uint32): uint32
[ 194.43]            < return
[ 194.43]            > fib(n: uint32): uint32
[ 194.44]            < return
[ 194.45]           < return
[ 194.46]           > fib(n: uint32): uint32
[ 194.46]           < return
[ 194.47]          < return
[ 194.48]          > fib(n: uint32): uint32
[ 194.49]           > fib(n: uint32): uint32
[ 194.50]           < return
[ 194.50]           > fib(n: uint32): uint32
[ 194.51]           < return
[ 194.52]          < return
[ 194.52]         < return
[ 194.53]        < return
[ 194.54]        > fib(n: uint32): uint32
[ 194.55]         > fib(n: uint32): uint32
[ 194.56]          > fib(n: uint32): uint32
[ 194.56]           > fib(n: uint32): uint32
[ 194.57]            > fib(n: uint32): uint32
[ 194.58]            < return
[ 194.59]            > fib(n: uint32): uint32
[ 194.60]            < return
[ 194.60]           < return
[ 194.61]           > fib(n: uint32): uint32
[ 194.62]           < return
[ 194.62]          < return
[ 194.63]          > fib(n: uint32): uint32
[ 194.64]           > fib(n: uint32): uint32
[ 194.65]           < return
[ 194.65]           > fib(n: uint32): uint32
[ 194.66]           < return
[ 194.67]          < return
[ 194.68]         < return
[ 194.68]         > fib(n: uint32): uint32
[ 194.69]          > fib(n: uint32): uint32
[ 194.70]           > fib(n: uint32): uint32
[ 194.71]           < return
[ 194.71]           > fib(n: uint32): uint32
[ 194.72]           < return
[ 194.73]          < return
[ 194.74]          > fib(n: uint32): uint32
[ 194.74]          < return
[ 194.75]         < return
[ 194.76]        < return
[ 194.76]       < return
[ 194.77]      < return
[ 194.78]      > fib(n: uint32): uint32
[ 194.78]       > fib(n: uint32): uint32
[ 194.79]        > fib(n: uint32): uint32
[ 194.80]         > fib(n: uint32): uint32
[ 194.81]          > fib(n: uint32): uint32
[ 194.82]           > fib(n: uint32): uint32
[ 194.83]            > fib(n: uint32): uint32
[ 194.84]             > fib(n: uint32): uint32
[ 194.85]             < return
[ 194.85]             > fib(n: uint32): uint32
[ 194.86]             < return
[ 194.87]            < return
[ 194.87]            > fib(n: uint32): uint32
[ 194.88]            < return
[ 194.89]           < return
[ 194.89]           > fib(n: uint32): uint32
[ 194.90]            > fib(n: uint32): uint32
[ 194.91]            < return
[ 194.92]            > fib(n: uint32): uint32
[ 194.93]            < return
[ 194.93]           < return
[ 194.94]          < return
[ 194.95]          > fib(n: uint32): uint32
[ 194.96]           > fib(n: uint32): uint32
[ 194.96]            > fib(n: uint32): uint32
[ 194.97]            < return
[ 194.98]            > fib(n: uint32): uint32
[ 194.99]            < return
[ 194.99]           < return
[ 195.00]           > fib(n: uint32): uint32
[ 195.01]           < return
[ 195.01]          < return
[ 195.02]         < return
[ 195.03]         > fib(n: uint32): uint32
[ 195.04]          > fib(n: uint32): uint32
[ 195.04]           > fib(n: uint32): uint32
[ 195.05]            > fib(n: uint32): uint32
[ 195.06]            < return
[ 195.07]            > fib(n: uint32): uint32
[ 195.08]            < return
[ 195.08]           < return
[ 195.09]           > fib(n: uint32): uint32
[ 195.10]           < return
[ 195.10]          < return
[ 195.11]          > fib(n: uint32): uint32
[ 195.12]           > fib(n: uint32): uint32
[ 195.13]           < return
[ 195.13]           > fib(n: uint32): uint32
[ 195.14]           < return
[ 195.15]          < return
[ 195.16]         < return
[ 195.16]        < return
[ 195.17]        > fib(n: uint32): uint32
[ 195.18]         > fib(n: uint32): uint32
[ 195.19]          > fib(n: uint32): uint32
[ 195.19]           > fib(n: uint32): uint32
[ 195.20]            > fib(n: uint32): uint32
[ 195.21]            < return
[ 195.22]            > fib(n: uint32): uint32
[ 195.23]            < return
[ 195.23]           < return
[ 195.24]           > fib(n: uint32): uint32
[ 195.25]           < return
[ 195.26]          < return
[ 195.26]          > fib(n: uint32): uint32
[ 195.27]           > fib(n: uint32): uint32
[ 195.28]           < return
[ 195.29]           > fib(n: uint32): uint32
[ 195.29]           < return
[ 195.30]          < return
[ 195.31]         < return
[ 195.31]         > fib(n: uint32): uint32
[ 195.32]          > fib(n: uint32): uint32
[ 195.33]           > fib(n: uint32): uint32
[ 195.34]           < return
[ 195.35]           > fib(n: uint32): uint32
[ 195.35]           < return
[ 195.36]          < return
[ 195.37]          > fib(n: uint32): uint32
[ 195.38]          < return
[ 195.38]         < return
[ 195.39]        < return
[ 195.39]       < return
[ 195.40]       > fib(n: uint32): uint32
[ 195.41]        > fib(n: uint32): uint32
[ 195.42]         > fib(n: uint32): uint32
[ 195.43]          > fib(n: uint32): uint32
[ 195.44]           > fib(n: uint32): uint32
[ 195.44]            > fib(n: uint32): uint32
[ 195.45]            < return
[ 195.46]            > fib(n: uint32): uint32
[ 195.47]            < return
[ 195.47]           < return
[ 195.48]           > fib(n: uint32): uint32
[ 195.49]           < return
[ 195.50]          < return
[ 195.50]          > fib(n: uint32): uint32
[ 195.51]           > fib(n: uint32): uint32
[ 195.52]           < return
[ 195.53]           > fib(n: uint32): uint32
[ 195.53]           < return
[ 195.54]          < return
[ 195.55]         < return
[ 195.55]         > fib(n: uint32): uint32
[ 195.56]          > fib(n: uint32): uint32
[ 195.57]           > fib(n: uint32): uint32
[ 195.58]           < return
[ 195.59]           > fib(n: uint32): uint32
[ 195.59]           < return
[ 195.60]          < return
[ 195.61]          > fib(n: uint32): uint32
[ 195.62]          < return
[ 195.62]         < return
[ 195.63]        < return
[ 195.63]        > fib(n: uint32): uint32
[ 195.64]         > fib(n: uint32): uint32
[ 195.65]          > fib(n: uint32): uint32
[ 195.66]           > fib(n: uint32): uint32
[ 195.67]           < return
[ 195.68]           > fib(n: uint32): uint32
[ 195.68]           < return
[ 195.69]          < return
[ 195.70]          > fib(n: uint32): uint32
[ 195.71]          < return
[ 195.71]         < return
[ 195.72]         > fib(n: uint32): uint32
[ 195.73]          > fib(n: uint32): uint32
[ 195.74]          < return
[ 195.74]          > fib(n: uint32): uint32
[ 195.75]          < return
[ 195.76]         < return
[ 195.76]        < return
[ 195.77]       < return
[ 195.78]      < return
[ 195.78]     < return
[ 195.79]     > fib(n: uint32): uint32
[ 195.80]      > fib(n: uint32): uint32
[ 195.81]       > fib(n: uint32): uint32
[ 195.81]        > fib(n: uint32): uint32
[ 195.82]         > fib(n: uint32): uint32
[ 195.83]          > fib(n: uint32): uint32
[ 195.84]           > fib(n: uint32): uint32
[ 195.85]            > fib(n: uint32): uint32
[ 195.86]             > fib(n: uint32): uint32
[ 195.87]             < return
[ 195.87]             > fib(n: uint32): uint32
[ 195.88]             < return
[ 195.89]            < return
[ 195.90]            > fib(n: uint32): uint32
[ 195.90]            < return
[ 195.91]           < return
[ 195.92]           > fib(n: uint32): uint32
[ 195.93]            > fib(n: uint32): uint32
[ 195.93]            < return
[ 195.94]            > fib(n: uint32): uint32
[ 195.95]            < return
[ 195.95]           < return
[ 195.96]          < return
[ 195.97]          > fib(n: uint32): uint32
[ 195.98]           > fib(n: uint32): uint32
[ 195.99]            > fib(n: uint32): uint32
[ 195.99]            < return
[ 196.00]            > fib(n: uint32): uint32
[ 196.01]            < return
[ 196.01]           < return
[ 196.02]           > fib(n: uint32): uint32
[ 196.03]           < return
[ 196.03]          < return
[ 196.04]         < return
[ 196.05]         > fib(n: uint32): uint32
[ 196.06]          > fib(n: uint32): uint32
[ 196.06]           > fib(n: uint32): uint32
[ 196.07]            > fib(n: uint32): uint32
[ 196.08]            < return
[ 196.09]            > fib(n: uint32): uint32
[ 196.10]            < return
[ 196.11]           < return
[ 196.11]           > fib(n: uint32): uint32
[ 196.12]           < return
[ 196.13]          < return
[ 196.13]          > fib(n: uint32): uint32
[ 196.14]           > fib(n: uint32): uint32
[ 196.15]           < return
[ 196.16]           > fib(n: uint32): uint32
[ 196.17]           < return
[ 196.17]          < return
[ 196.18]         < return
[ 196.18]        < return
[ 196.19]        > fib(n: uint32): uint32
[ 196.20]         > fib(n: uint32): uint32
[ 196.21]          > fib(n: uint32): uint32
[ 196.22]           > fib(n: uint32): uint32
[ 196.23]            > fib(n: uint32): uint32
[ 196.23]            < return
[ 196.24]            > fib(n: uint32): uint32
[ 196.25]            < return
[ 196.26]           < return
[ 196.26]           > fib(n: uint32): uint32
[ 196.27]           < return
[ 196.28]          < return
[ 196.28]          > fib(n: uint32): uint32
[ 196.29]           > fib(n: uint32): uint32
[ 196.30]           < return
[ 196.31]           > fib(n: uint32): uint32
[ 196.31]           < return
[ 196.32]          < return
[ 196.33]         < return
[ 196.34]         > fib(n: uint32): uint32
[ 196.34]          > fib(n: uint32): uint32
[ 196.35]           > fib(n: uint32): uint32
[ 196.36]           < return
[ 196.37]           > fib(n: uint32): uint32
[ 196.38]           < return
[ 196.38]          < return
[ 196.39]          > fib(n: uint32): uint32
[ 196.40]          < return
[ 196.41]         < return
[ 196.41]        < return
[ 196.42]       < return
[ 196.42]       > fib(n: uint32): uint32
[ 196.43]        > fib(n: uint32): uint32
[ 196.44]         > fib(n: uint32): uint32
[ 196.45]          > fib(n: uint32): uint32
[ 196.46]           > fib(n: uint32): uint32
[ 196.47]            > fib(n: uint32): uint32
[ 196.48]            < return
[ 196.48]            > fib(n: uint32): uint32
[ 196.49]            < return
[ 196.50]           < return
[ 196.51]           > fib(n: uint32): uint32
[ 196.51]           < return
[ 196.52]          < return
[ 196.53]          > fib(n: uint32): uint32
[ 196.54]           > fib(n: uint32): uint32
[ 196.55]           < return
[ 196.55]           > fib(n: uint32): uint32
[ 196.56]           < return
[ 196.57]          < return
[ 196.57]         < return
[ 196.58]         > fib(n: uint32): uint32
[ 196.60]          > fib(n: uint32): uint32
[ 196.60]           > fib(n: uint32): uint32
[ 196.61]           < return
[ 196.62]           > fib(n: uint32): uint32
[ 196.63]           < return
[ 196.64]          < return
[ 196.64]          > fib(n: uint32): uint32
[ 196.65]          < return
[ 196.66]         < return
[ 196.66]        < return
[ 196.67]        > fib(n: uint32): uint32
[ 196.68]         > fib(n: uint32): uint32
[ 196.69]          > fib(n: uint32): uint32
[ 196.70]           > fib(n: uint32): uint32
[ 196.71]           < return
[ 196.71]           > fib(n: uint32): uint32
[ 196.72]           < return
[ 196.73]          < return
[ 196.74]          > fib(n: uint32): uint32
[ 196.74]          < return
[ 196.75]         < return
[ 196.76]         > fib(n: uint32): uint32
[ 196.77]          > fib(n: uint32): uint32
[ 196.78]          < return
[ 196.78]          > fib(n: uint32): uint32
[ 196.79]          < return
[ 196.80]         < return
[ 196.80]        < return
[ 196.81]       < return
[ 196.82]      < return
[ 196.82]      > fib(n: uint32): uint32
[ 196.83]       > fib(n: uint32): uint32
[ 196.84]        > fib(n: uint32): uint32
[ 196.85]         > fib(n: uint32): uint32
[ 196.86]          > fib(n: uint32): uint32
[ 196.87]           > fib(n: uint32): uint32
[ 196.88]            > fib(n: uint32): uint32
[ 196.89]            < return
[ 196.90]            > fib(n: uint32): uint32
[ 196.90]            < return
[ 196.91]           < return
[ 196.92]           > fib(n: uint32): uint32
[ 196.93]           < return
[ 196.93]          < return
[ 196.94]          > fib(n: uint32): uint32
[ 196.95]           > fib(n: uint32): uint32
[ 196.96]           < return
[ 196.96]           > fib(n: uint32): uint32
[ 196.97]           < return
[ 196.98]          < return
[ 196.99]         < return
[ 197.00]         > fib(n: uint32): uint32
[ 197.01]          > fib(n: uint32): uint32
[ 197.01]           > fib(n: uint32): uint32
[ 197.02]           < return
[ 197.03]           > fib(n: uint32): uint32
[ 197.04]           < return
[ 197.05]          < return
[ 197.05]          > fib(n: uint32): uint32
[ 197.06]          < return
[ 197.07]         < return
[ 197.07]        < return
[ 197.08]        > fib(n: uint32): uint32
[ 197.09]         > fib(n: uint32): uint32
[ 197.10]          > fib(n: uint32): uint32
[ 197.11]           > fib(n: uint32): uint32
[ 197.12]           < return
[ 197.12]           > fib(n: uint32): uint32
[ 197.13]           < return
[ 197.14]          < return
[ 197.15]          > fib(n: uint32): uint32
[ 197.16]          < return
[ 197.16]         < return
[ 197.17]         > fib(n: uint32): uint32
[ 197.18]          > fib(n: uint32): uint32
[ 197.19]          < return
[ 197.19]          > fib(n: uint32): uint32
[ 197.20]          < return
[ 197.21]         < return
[ 197.22]        < return
[ 197.22]       < return
[ 197.23]       > fib(n: uint32): uint32
[ 197.24]        > fib(n: uint32): uint32
[ 197.25]         > fib(n: uint32): uint32
[ 197.26]          > fib(n: uint32): uint32
[ 197.27]           > fib(n: uint32): uint32
[ 197.28]           < return
[ 197.28]           > fib(n: uint32): uint32
[ 197.29]           < return
[ 197.30]          < return
[ 197.30]          > fib(n: uint32): uint32
[ 197.31]          < return
[ 197.32]         < return
[ 197.32]         > fib(n: uint32): uint32
[ 197.34]          > fib(n: uint32): uint32
[ 197.34]          < return
[ 197.35]          > fib(n: uint32): uint32
[ 197.36]          < return
[ 197.37]         < return
[ 197.37]        < return
[ 197.38]        > fib(n: uint32): uint32
[ 197.39]         > fib(n: uint32): uint32
[ 197.40]          > fib(n: uint32): uint32
[ 197.41]          < return
[ 197.41]          > fib(n: uint32): uint32
[ 197.42]          < return
[ 197.43]         < return
[ 197.44]         > fib(n: uint32): uint32
[ 197.44]         < return
[ 197.45]        < return
[ 197.46]       < return
[ 197.47]      < return
[ 197.47]     < return
[ 197.48]    < return
[ 197.49]    > fib(n: uint32): uint32
[ 197.50]     > fib(n: uint32): uint32
[ 197.50]      > fib(n: uint32): uint32
[ 197.51]       > fib(n: uint32): uint32
[ 197.52]        > fib(n: uint32): uint32
[ 197.53]         > fib(n: uint32): uint32
[ 197.54]          > fib(n: uint32): uint32
[ 197.55]           > fib(n: uint32): uint32
[ 197.56]            > fib(n: uint32): uint32
[ 197.57]             > fib(n: uint32): uint32
[ 197.58]             < return
[ 197.59]             > fib(n: uint32): uint32
[ 197.59]             < return
[ 197.60]            < return
[ 197.61]            > fib(n: uint32): uint32
[ 197.62]            < return
[ 197.62]           < return
[ 197.63]           > fib(n: uint32): uint32
[ 197.64]            > fib(n: uint32): uint32
[ 197.65]            < return
[ 197.66]            > fib(n: uint32): uint32
[ 197.66]            < return
[ 197.67]           < return
[ 197.68]          < return
[ 197.68]          > fib(n: uint32): uint32
[ 197.69]           > fib(n: uint32): uint32
[ 197.70]            > fib(n: uint32): uint32
[ 197.71]            < return
[ 197.72]            > fib(n: uint32): uint32
[ 197.73]            < return
[ 197.73]           < return
[ 197.74]           > fib(n: uint32): uint32
[ 197.75]           < return
[ 197.76]          < return
[ 197.76]         < return
[ 197.77]         > fib(n: uint32): uint32
[ 197.78]          > fib(n: uint32): uint32
[ 197.79]           > fib(n: uint32): uint32
[ 197.80]            > fib(n: uint32): uint32
[ 197.81]            < return
[ 197.81]            > fib(n: uint32): uint32
[ 197.82]            < return
[ 197.83]           < return
[ 197.84]           > fib(n: uint32): uint32
[ 197.84]           < return
[ 197.85]          < return
[ 197.86]          > fib(n: uint32): uint32
[ 197.87]           > fib(n: uint32): uint32
[ 197.88]           < return
[ 197.88]           > fib(n: uint32): uint32
[ 197.90]           < return
[ 197.90]          < return
[ 197.91]         < return
[ 197.91]        < return
[ 197.92]        > fib(n: uint32): uint32
[ 197.93]         > fib(n: uint32): uint32
[ 197.94]          > fib(n: uint32): uint32
[ 197.95]           > fib(n: uint32): uint32
[ 197.96]            > fib(n: uint32): uint32
[ 197.97]            < return
[ 197.97]            > fib(n: uint32): uint32
[ 197.98]            < return
[ 197.99]           < return
[ 198.00]           > fib(n: uint32): uint32
[ 198.01]           < return
[ 198.01]          < return
[ 198.02]          > fib(n: uint32): uint32
[ 198.03]           > fib(n: uint32): uint32
[ 198.04]           < return
[ 198.05]           > fib(n: uint32): uint32
[ 198.05]           < return
[ 198.06]          < return
[ 198.07]         < return
[ 198.07]         > fib(n: uint32): uint32
[ 198.08]          > fib(n: uint32): uint32
[ 198.09]           > fib(n: uint32): uint32
[ 198.10]           < return
[ 198.11]           > fib(n: uint32): uint32
[ 198.12]           < return
[ 198.12]          < return
[ 198.13]          > fib(n: uint32): uint32
[ 198.14]          < return
[ 198.15]         < return
[ 198.15]        < return
[ 198.16]       < return
[ 198.17]       > fib(n: uint32): uint32
[ 198.18]        > fib(n: uint32): uint32
[ 198.19]         > fib(n: uint32): uint32
[ 198.19]          > fib(n: uint32): uint32
[ 198.20]           > fib(n: uint32): uint32
[ 198.21]            > fib(n: uint32): uint32
[ 198.23]            < return
[ 198.24]            > fib(n: uint32): uint32
[ 198.24]            < return
[ 198.25]           < return
[ 198.26]           > fib(n: uint32): uint32
[ 198.26]           < return
[ 198.27]          < return
[ 198.28]          > fib(n: uint32): uint32
[ 198.29]           > fib(n: uint32): uint32
[ 198.30]           < return
[ 198.31]           > fib(n: uint32): uint32
[ 198.31]           < return
[ 198.32]          < return
[ 198.33]         < return
[ 198.33]         > fib(n: uint32): uint32
[ 198.34]          > fib(n: uint32): uint32
[ 198.35]           > fib(n: uint32): uint32
[ 198.36]           < return
[ 198.37]           > fib(n: uint32): uint32
[ 198.38]           < return
[ 198.38]          < return
[ 198.39]          > fib(n: uint32): uint32
[ 198.40]          < return
[ 198.41]         < return
[ 198.41]        < return
[ 198.42]        > fib(n: uint32): uint32
[ 198.43]         > fib(n: uint32): uint32
[ 198.44]          > fib(n: uint32): uint32
[ 198.45]           > fib(n: uint32): uint32
[ 198.46]           < return
[ 198.46]           > fib(n: uint32): uint32
[ 198.47]           < return
[ 198.48]          < return
[ 198.49]          > fib(n: uint32): uint32
[ 198.50]          < return
[ 198.50]         < return
[ 198.51]         > fib(n: uint32): uint32
[ 198.52]          > fib(n: uint32): uint32
[ 198.53]          < return
[ 198.53]          > fib(n: uint32): uint32
[ 198.54]          < return
[ 198.55]         < return
[ 198.56]        < return
[ 198.56]       < return
[ 198.57]      < return
[ 198.58]      > fib(n: uint32): uint32
[ 198.59]       > fib(n: uint32): uint32
[ 198.59]        > fib(n: uint32): uint32
[ 198.60]         > fib(n: uint32): uint32
[ 198.61]          > fib(n: uint32): uint32
[ 198.62]           > fib(n: uint32): uint32
[ 198.63]            > fib(n: uint32): uint32
[ 198.64]            < return
[ 198.65]            > fib(n: uint32): uint32
[ 198.66]            < return
[ 198.66]           < return
[ 198.67]           > fib(n: uint32): uint32
[ 198.68]           < return
[ 198.69]          < return
[ 198.69]          > fib(n: uint32): uint32
[ 198.70]           > fib(n: uint32): uint32
[ 198.71]           < return
[ 198.72]           > fib(n: uint32): uint32
[ 198.73]           < return
[ 198.73]          < return
[ 198.74]         < return
[ 198.75]         > fib(n: uint32): uint32
[ 198.76]          > fib(n: uint32): uint32
[ 198.77]           > fib(n: uint32): uint32
[ 198.77]           < return
[ 198.78]           > fib(n: uint32): uint32
[ 198.79]           < return
[ 198.80]          < return
[ 198.81]          > fib(n: uint32): uint32
[ 198.82]          < return
[ 198.82]         < return
[ 198.83]        < return
[ 198.84]        > fib(n: uint32): uint32
[ 198.85]         > fib(n: uint32): uint32
[ 198.86]          > fib(n: uint32): uint32
[ 198.87]           > fib(n: uint32): uint32
[ 198.87]           < return
[ 198.88]           > fib(n: uint32): uint32
[ 198.89]           < return
[ 198.90]          < return
[ 198.90]          > fib(n: uint32): uint32
[ 198.91]          < return
[ 198.92]         < return
[ 198.93]         > fib(n: uint32): uint32
[ 198.93]          > fib(n: uint32): uint32
[ 198.94]          < return
[ 198.95]          > fib(n: uint32): uint32
[ 198.96]          < return
[ 198.97]         < return
[ 198.97]        < return
[ 198.98]       < return
[ 198.99]       > fib(n: uint32): uint32
[ 199.00]        > fib(n: uint32): uint32
[ 199.00]         > fib(n: uint32): uint32
[ 199.01]          > fib(n: uint32): uint32
[ 199.02]           > fib(n: uint32): uint32
[ 199.03]           < return
[ 199.04]           > fib(n: uint32): uint32
[ 199.05]           < return
[ 199.06]          < return
[ 199.06]          > fib(n: uint32): uint32
[ 199.07]          < return
[ 199.08]         < return
[ 199.08]         > fib(n: uint32): uint32
[ 199.09]          > fib(n: uint32): uint32
[ 199.10]          < return
[ 199.11]          > fib(n: uint32): uint32
[ 199.12]          < return
[ 199.12]         < return
[ 199.13]        < return
[ 199.14]        > fib(n: uint32): uint32
[ 199.15]         > fib(n: uint32): uint32
[ 199.16]          > fib(n: uint32): uint32
[ 199.17]          < return
[ 199.17]          > fib(n: uint32): uint32
[ 199.18]          < return
[ 199.19]         < return
[ 199.19]         > fib(n: uint32): uint32
[ 199.20]         < return
[ 199.21]        < return
[ 199.22]       < return
[ 199.22]      < return
[ 199.23]     < return
[ 199.24]     > fib(n: uint32): uint32
[ 199.25]      > fib(n: uint32): uint32
[ 199.25]       > fib(n: uint32): uint32
[ 199.26]        > fib(n: uint32): uint32
[ 199.27]         > fib(n: uint32): uint32
[ 199.28]          > fib(n: uint32): uint32
[ 199.29]           > fib(n: uint32): uint32
[ 199.30]            > fib(n: uint32): uint32
[ 199.31]            < return
[ 199.32]            > fib(n: uint32): uint32
[ 199.32]            < return
[ 199.33]           < return
[ 199.34]           > fib(n: uint32): uint32
[ 199.35]           < return
[ 199.35]          < return
[ 199.36]          > fib(n: uint32): uint32
[ 199.37]           > fib(n: uint32): uint32
[ 199.38]           < return
[ 199.39]           > fib(n: uint32): uint32
[ 199.40]           < return
[ 199.40]          < return
[ 199.41]         < return
[ 199.41]         > fib(n: uint32): uint32
[ 199.43]          > fib(n: uint32): uint32
[ 199.43]           > fib(n: uint32): uint32
[ 199.44]           < return
[ 199.45]           > fib(n: uint32): uint32
[ 199.46]           < return
[ 199.47]          < return
[ 199.47]          > fib(n: uint32): uint32
[ 199.48]          < return
[ 199.49]         < return
[ 199.50]        < return
[ 199.50]        > fib(n: uint32): uint32
[ 199.51]         > fib(n: uint32): uint32
[ 199.52]          > fib(n: uint32): uint32
[ 199.53]           > fib(n: uint32): uint32
[ 199.54]           < return
[ 199.55]           > fib(n: uint32): uint32
[ 199.55]           < return
[ 199.56]          < return
[ 199.57]          > fib(n: uint32): uint32
[ 199.58]          < return
[ 199.58]         < return
[ 199.59]         > fib(n: uint32): uint32
[ 199.60]          > fib(n: uint32): uint32
[ 199.61]          < return
[ 199.62]          > fib(n: uint32): uint32
[ 199.62]          < return
[ 199.63]         < return
[ 199.64]        < return
[ 199.65]       < return
[ 199.65]       > fib(n: uint32): uint32
[ 199.66]        > fib(n: uint32): uint32
[ 199.67]         > fib(n: uint32): uint32
[ 199.68]          > fib(n: uint32): uint32
[ 199.69]           > fib(n: uint32): uint32
[ 199.70]           < return
[ 199.71]           > fib(n: uint32): uint32
[ 199.72]           < return
[ 199.72]          < return
[ 199.73]          > fib(n: uint32): uint32
[ 199.74]          < return
[ 199.75]         < return
[ 199.75]         > fib(n: uint32): uint32
[ 199.76]          > fib(n: uint32): uint32
[ 199.77]          < return
[ 199.78]          > fib(n: uint32): uint32
[ 199.79]          < return
[ 199.80]         < return
[ 199.80]        < return
[ 199.81]        > fib(n: uint32): uint32
[ 199.82]         > fib(n: uint32): uint32
[ 199.83]          > fib(n: uint32): uint32
[ 199.84]          < return
[ 199.84]          > fib(n: uint32): uint32
[ 199.85]          < return
[ 199.86]         < return
[ 199.87]         > fib(n: uint32): uint32
[ 199.87]         < return
[ 199.88]        < return
[ 199.89]       < return
[ 199.89]      < return
[ 199.90]      > fib(n: uint32): uint32
[ 199.91]       > fib(n: uint32): uint32
[ 199.92]        > fib(n: uint32): uint32
[ 199.93]         > fib(n: uint32): uint32
[ 199.94]          > fib(n: uint32): uint32
[ 199.95]           > fib(n: uint32): uint32
[ 199.96]           < return
[ 199.96]           > fib(n: uint32): uint32
[ 199.97]           < return
[ 199.98]          < return
[ 199.98]          > fib(n: uint32): uint32
[ 199.99]          < return
[ 200.00]         < return
[ 200.01]         > fib(n: uint32): uint32
[ 200.01]          > fib(n: uint32): uint32
[ 200.02]          < return
[ 200.03]          > fib(n: uint32): uint32
[ 200.04]          < return
[ 200.05]         < return
[ 200.05]        < return
[ 200.06]        > fib(n: uint32): uint32
[ 200.07]         > fib(n: uint32): uint32
[ 200.08]          > fib(n: uint32): uint32
[ 200.09]          < return
[ 200.09]          > fib(n: uint32): uint32
[ 200.10]          < return
[ 200.11]         < return
[ 200.12]         > fib(n: uint32): uint32
[ 200.12]         < return
[ 200.13]        < return
[ 200.14]       < return
[ 200.14]       > fib(n: uint32): uint32
[ 200.15]        > fib(n: uint32): uint32
[ 200.16]         > fib(n: uint32): uint32
[ 200.17]          > fib(n: uint32): uint32
[ 200.18]          < return
[ 200.19]          > fib(n: uint32): uint32
[ 200.19]          < return
[ 200.20]         < return
[ 200.21]         > fib(n: uint32): uint32
[ 200.22]         < return
[ 200.22]        < return
[ 200.23]        > fib(n: uint32): uint32
[ 200.24]         > fib(n: uint32): uint32
[ 200.25]         < return
[ 200.26]         > fib(n: uint32): uint32
[ 200.26]         < return
[ 200.27]        < return
[ 200.28]       < return
[ 200.28]      < return
[ 200.29]     < return
[ 200.30]    < return
[ 200.30]   < return
[ 200.31]   > fib(n: uint32): uint32
[ 200.32]    > fib(n: uint32): uint32
[ 200.33]     > fib(n: uint32): uint32
[ 200.34]      > fib(n: uint32): uint32
[ 200.35]       > fib(n: uint32): uint32
[ 200.36]        > fib(n: uint32): uint32
[ 200.37]         > fib(n: uint32): uint32
[ 200.38]          > fib(n: uint32): uint32
[ 200.38]           > fib(n: uint32): uint32
[ 200.40]            > fib(n: uint32): uint32
[ 200.40]             > fib(n: uint32): uint32
[ 200.41]             < return
[ 200.42]             > fib(n: uint32): uint32
[ 200.43]             < return
[ 200.44]            < return
[ 200.44]            > fib(n: uint32): uint32
[ 200.45]            < return
[ 200.46]           < return
[ 200.46]           > fib(n: uint32): uint32
[ 200.47]            > fib(n: uint32): uint32
[ 200.48]            < return
[ 200.49]            > fib(n: uint32): uint32
[ 200.50]            < return
[ 200.50]           < return
[ 200.51]          < return
[ 200.52]          > fib(n: uint32): uint32
[ 200.53]           > fib(n: uint32): uint32
[ 200.54]            > fib(n: uint32): uint32
[ 200.54]            < return
[ 200.55]            > fib(n: uint32): uint32
[ 200.56]            < return
[ 200.57]           < return
[ 200.57]           > fib(n: uint32): uint32
[ 200.58]           < return
[ 200.59]          < return
[ 200.60]         < return
[ 200.60]         > fib(n: uint32): uint32
[ 200.61]          > fib(n: uint32): uint32
[ 200.62]           > fib(n: uint32): uint32
[ 200.64]            > fib(n: uint32): uint32
[ 200.64]            < return
[ 200.65]            > fib(n: uint32): uint32
[ 200.66]            < return
[ 200.67]           < return
[ 200.67]           > fib(n: uint32): uint32
[ 200.68]           < return
[ 200.69]          < return
[ 200.70]          > fib(n: uint32): uint32
[ 200.71]           > fib(n: uint32): uint32
[ 200.71]           < return
[ 200.72]           > fib(n: uint32): uint32
[ 200.73]           < return
[ 200.74]          < return
[ 200.74]         < return
[ 200.75]        < return
[ 200.75]        > fib(n: uint32): uint32
[ 200.76]         > fib(n: uint32): uint32
[ 200.77]          > fib(n: uint32): uint32
[ 200.78]           > fib(n: uint32): uint32
[ 200.79]            > fib(n: uint32): uint32
[ 200.80]            < return
[ 200.80]            > fib(n: uint32): uint32
[ 200.81]            < return
[ 200.82]           < return
[ 200.82]           > fib(n: uint32): uint32
[ 200.83]           < return
[ 200.84]          < return
[ 200.84]          > fib(n: uint32): uint32
[ 200.85]           > fib(n: uint32): uint32
[ 200.86]           < return
[ 200.87]           > fib(n: uint32): uint32
[ 200.88]           < return
[ 200.88]          < return
[ 200.89]         < return
[ 200.90]         > fib(n: uint32): uint32
[ 200.90]          > fib(n: uint32): uint32
[ 200.91]           > fib(n: uint32): uint32
[ 200.92]           < return
[ 200.93]           > fib(n: uint32): uint32
[ 200.94]           < return
[ 200.94]          < return
[ 200.95]          > fib(n: uint32): uint32
[ 200.96]          < return
[ 200.96]         < return
[ 200.97]        < return
[ 200.97]       < return
[ 200.98]       > fib(n: uint32): uint32
[ 200.99]        > fib(n: uint32): uint32
[ 201.00]         > fib(n: uint32): uint32
[ 201.01]          > fib(n: uint32): uint32
[ 201.02]           > fib(n: uint32): uint32
[ 201.03]            > fib(n: uint32): uint32
[ 201.03]            < return
[ 201.04]            > fib(n: uint32): uint32
[ 201.05]            < return
[ 201.05]           < return
[ 201.06]           > fib(n: uint32): uint32
[ 201.07]           < return
[ 201.07]          < return
[ 201.08]          > fib(n: uint32): uint32
[ 201.09]           > fib(n: uint32): uint32
[ 201.10]           < return
[ 201.10]           > fib(n: uint32): uint32
[ 201.11]           < return
[ 201.12]          < return
[ 201.12]         < return
[ 201.13]         > fib(n: uint32): uint32
[ 201.14]          > fib(n: uint32): uint32
[ 201.15]           > fib(n: uint32): uint32
[ 201.16]           < return
[ 201.16]           > fib(n: uint32): uint32
[ 201.17]           < return
[ 201.18]          < return
[ 201.18]          > fib(n: uint32): uint32
[ 201.19]          < return
[ 201.20]         < return
[ 201.21]        < return
[ 201.21]        > fib(n: uint32): uint32
[ 201.22]         > fib(n: uint32): uint32
[ 201.23]          > fib(n: uint32): uint32
[ 201.24]           > fib(n: uint32): uint32
[ 201.25]           < return
[ 201.25]           > fib(n: uint32): uint32
[ 201.26]           < return
[ 201.27]          < return
[ 201.27]          > fib(n: uint32): uint32
[ 201.28]          < return
[ 201.29]         < return
[ 201.29]         > fib(n: uint32): uint32
[ 201.30]          > fib(n: uint32): uint32
[ 201.31]          < return
[ 201.32]          > fib(n: uint32): uint32
[ 201.33]          < return
[ 201.33]         < return
[ 201.34]        < return
[ 201.34]       < return
[ 201.35]      < return
[ 201.36]      > fib(n: uint32): uint32
[ 201.37]       > fib(n: uint32): uint32
[ 201.38]        > fib(n: uint32): uint32
[ 201.38]         > fib(n: uint32): uint32
[ 201.39]          > fib(n: uint32): uint32
[ 201.40]           > fib(n: uint32): uint32
[ 201.41]            > fib(n: uint32): uint32
[ 201.42]            < return
[ 201.43]            > fib(n: uint32): uint32
[ 201.43]            < return
[ 201.44]           < return
[ 201.45]           > fib(n: uint32): uint32
[ 201.45]           < return
[ 201.46]          < return
[ 201.47]          > fib(n: uint32): uint32
[ 201.48]           > fib(n: uint32): uint32
[ 201.49]           < return
[ 201.49]           > fib(n: uint32): uint32
[ 201.50]           < return
[ 201.51]          < return
[ 201.51]         < return
[ 201.52]         > fib(n: uint32): uint32
[ 201.53]          > fib(n: uint32): uint32
[ 201.54]           > fib(n: uint32): uint32
[ 201.55]           < return
[ 201.55]           > fib(n: uint32): uint32
[ 201.56]           < return
[ 201.57]          < return
[ 201.57]          > fib(n: uint32): uint32
[ 201.58]          < return
[ 201.59]         < return
[ 201.59]        < return
[ 201.60]        > fib(n: uint32): uint32
[ 201.61]         > fib(n: uint32): uint32
[ 201.62]          > fib(n: uint32): uint32
[ 201.63]           > fib(n: uint32): uint32
[ 201.63]           < return
[ 201.64]           > fib(n: uint32): uint32
[ 201.65]           < return
[ 201.66]          < return
[ 201.66]          > fib(n: uint32): uint32
[ 201.67]          < return
[ 201.68]         < return
[ 201.68]         > fib(n: uint32): uint32
[ 201.69]          > fib(n: uint32): uint32
[ 201.70]          < return
[ 201.71]          > fib(n: uint32): uint32
[ 201.72]          < return
[ 201.72]         < return
[ 201.73]        < return
[ 201.73]       < return
[ 201.74]       > fib(n: uint32): uint32
[ 201.75]        > fib(n: uint32): uint32
[ 201.76]         > fib(n: uint32): uint32
[ 201.77]          > fib(n: uint32): uint32
[ 201.78]           > fib(n: uint32): uint32
[ 201.78]           < return
[ 201.79]           > fib(n: uint32): uint32
[ 201.80]           < return
[ 201.81]          < return
[ 201.81]          > fib(n: uint32): uint32
[ 201.82]          < return
[ 201.83]         < return
[ 201.83]         > fib(n: uint32): uint32
[ 201.84]          > fib(n: uint32): uint32
[ 201.85]          < return
[ 201.86]          > fib(n: uint32): uint32
[ 201.86]          < return
[ 201.87]         < return
[ 201.88]        < return
[ 201.88]        > fib(n: uint32): uint32
[ 201.89]         > fib(n: uint32): uint32
[ 201.90]          > fib(n: uint32): uint32
[ 201.91]          < return
[ 201.91]          > fib(n: uint32): uint32
[ 201.92]          < return
[ 201.93]         < return
[ 201.94]         > fib(n: uint32): uint32
[ 201.94]         < return
[ 201.95]        < return
[ 201.96]       < return
[ 201.96]      < return
[ 201.97]     < return
[ 201.97]     > fib(n: uint32): uint32
[ 201.98]      > fib(n: uint32): uint32
[ 201.99]       > fib(n: uint32): uint32
[ 202.00]        > fib(n: uint32): uint32
[ 202.01]         > fib(n: uint32): uint32
[ 202.02]          > fib(n: uint32): uint32
[ 202.03]           > fib(n: uint32): uint32
[ 202.04]            > fib(n: uint32): uint32
[ 202.04]            < return
[ 202.05]            > fib(n: uint32): uint32
[ 202.06]            < return
[ 202.07]           < return
[ 202.07]           > fib(n: uint32): uint32
[ 202.08]           < return
[ 202.09]          < return
[ 202.09]          > fib(n: uint32): uint32
[ 202.10]           > fib(n: uint32): uint32
[ 202.11]           < return
[ 202.12]           > fib(n: uint32): uint32
[ 202.12]           < return
[ 202.13]          < return
[ 202.14]         < return
[ 202.14]         > fib(n: uint32): uint32
[ 202.15]          > fib(n: uint32): uint32
[ 202.16]           > fib(n: uint32): uint32
[ 202.17]           < return
[ 202.18]           > fib(n: uint32): uint32
[ 202.18]           < return
[ 202.19]          < return
[ 202.20]          > fib(n: uint32): uint32
[ 202.21]          < return
[ 202.21]         < return
[ 202.22]        < return
[ 202.23]        > fib(n: uint32): uint32
[ 202.24]         > fib(n: uint32): uint32
[ 202.25]          > fib(n: uint32): uint32
[ 202.26]           > fib(n: uint32): uint32
[ 202.26]           < return
[ 202.27]           > fib(n: uint32): uint32
[ 202.28]           < return
[ 202.29]          < return
[ 202.29]          > fib(n: uint32): uint32
[ 202.30]          < return
[ 202.31]         < return
[ 202.31]         > fib(n: uint32): uint32
[ 202.32]          > fib(n: uint32): uint32
[ 202.33]          < return
[ 202.34]          > fib(n: uint32): uint32
[ 202.35]          < return
[ 202.36]         < return
[ 202.37]        < return
[ 202.37]       < return
[ 202.38]       > fib(n: uint32): uint32
[ 202.39]        > fib(n: uint32): uint32
[ 202.40]         > fib(n: uint32): uint32
[ 202.41]          > fib(n: uint32): uint32
[ 202.41]           > fib(n: uint32): uint32
[ 202.42]           < return
[ 202.43]           > fib(n: uint32): uint32
[ 202.44]           < return
[ 202.44]          < return
[ 202.45]          > fib(n: uint32): uint32
[ 202.46]          < return
[ 202.47]         < return
[ 202.47]         > fib(n: uint32): uint32
[ 202.48]          > fib(n: uint32): uint32
[ 202.49]          < return
[ 202.50]          > fib(n: uint32): uint32
[ 202.50]          < return
[ 202.51]         < return
[ 202.52]        < return
[ 202.52]        > fib(n: uint32): uint32
[ 202.53]         > fib(n: uint32): uint32
[ 202.54]          > fib(n: uint32): uint32
[ 202.55]          < return
[ 202.56]          > fib(n: uint32): uint32
[ 202.56]          < return
[ 202.57]         < return
[ 202.57]         > fib(n: uint32): uint32
[ 202.58]         < return
[ 202.59]        < return
[ 202.60]       < return
[ 202.60]      < return
[ 202.61]      > fib(n: uint32): uint32
[ 202.62]       > fib(n: uint32): uint32
[ 202.63]        > fib(n: uint32): uint32
[ 202.63]         > fib(n: uint32): uint32
[ 202.64]          > fib(n: uint32): uint32
[ 202.65]           > fib(n: uint32): uint32
[ 202.66]           < return
[ 202.67]           > fib(n: uint32): uint32
[ 202.68]           < return
[ 202.68]          < return
[ 202.69]          > fib(n: uint32): uint32
[ 202.70]          < return
[ 202.70]         < return
[ 202.71]         > fib(n: uint32): uint32
[ 202.72]          > fib(n: uint32): uint32
[ 202.73]          < return
[ 202.74]          > fib(n: uint32): uint32
[ 202.75]          < return
[ 202.75]         < return
[ 202.76]        < return
[ 202.76]        > fib(n: uint32): uint32
[ 202.77]         > fib(n: uint32): uint32
[ 202.78]          > fib(n: uint32): uint32
[ 202.79]          < return
[ 202.80]          > fib(n: uint32): uint32
[ 202.81]          < return
[ 202.81]         < return
[ 202.82]         > fib(n: uint32): uint32
[ 202.83]         < return
[ 202.83]        < return
[ 202.84]       < return
[ 202.84]       > fib(n: uint32): uint32
[ 202.85]        > fib(n: uint32): uint32
[ 202.86]         > fib(n: uint32): uint32
[ 202.87]          > fib(n: uint32): uint32
[ 202.88]          < return
[ 202.89]          > fib(n: uint32): uint32
[ 202.89]          < return
[ 202.90]         < return
[ 202.91]         > fib(n: uint32): uint32
[ 202.91]         < return
[ 202.92]        < return
[ 202.93]        > fib(n: uint32): uint32
[ 202.94]         > fib(n: uint32): uint32
[ 202.94]         < return
[ 202.95]         > fib(n: uint32): uint32
[ 202.96]         < return
[ 202.97]        < return
[ 202.97]       < return
[ 202.98]      < return
[ 202.98]     < return
[ 202.99]    < return
[ 203.00]    > fib(n: uint32): uint32
[ 203.00]     > fib(n: uint32): uint32
[ 203.01]      > fib(n: uint32): uint32
[ 203.02]       > fib(n: uint32): uint32
[ 203.03]        > fib(n: uint32): uint32
[ 203.04]         > fib(n: uint32): uint32
[ 203.05]          > fib(n: uint32): uint32
[ 203.06]           > fib(n: uint32): uint32
[ 203.07]            > fib(n: uint32): uint32
[ 203.07]            < return
[ 203.08]            > fib(n: uint32): uint32
[ 203.09]            < return
[ 203.10]           < return
[ 203.10]           > fib(n: uint32): uint32
[ 203.11]           < return
[ 203.12]          < return
[ 203.12]          > fib(n: uint32): uint32
[ 203.13]           > fib(n: uint32): uint32
[ 203.14]           < return
[ 203.15]           > fib(n: uint32): uint32
[ 203.15]           < return
[ 203.16]          < return
[ 203.17]         < return
[ 203.17]         > fib(n: uint32): uint32
[ 203.18]          > fib(n: uint32): uint32
[ 203.19]           > fib(n: uint32): uint32
[ 203.20]           < return
[ 203.21]           > fib(n: uint32): uint32
[ 203.22]           < return
[ 203.22]          < return
[ 203.23]          > fib(n: uint32): uint32
[ 203.24]          < return
[ 203.24]         < return
[ 203.25]        < return
[ 203.26]        > fib(n: uint32): uint32
[ 203.26]         > fib(n: uint32): uint32
[ 203.27]          > fib(n: uint32): uint32
[ 203.28]           > fib(n: uint32): uint32
[ 203.29]           < return
[ 203.30]           > fib(n: uint32): uint32
[ 203.31]           < return
[ 203.31]          < return
[ 203.32]          > fib(n: uint32): uint32
[ 203.33]          < return
[ 203.33]         < return
[ 203.34]         > fib(n: uint32): uint32
[ 203.35]          > fib(n: uint32): uint32
[ 203.36]          < return
[ 203.36]          > fib(n: uint32): uint32
[ 203.37]          < return
[ 203.38]         < return
[ 203.38]        < return
[ 203.39]       < return
[ 203.40]       > fib(n: uint32): uint32
[ 203.41]        > fib(n: uint32): uint32
[ 203.41]         > fib(n: uint32): uint32
[ 203.42]          > fib(n: uint32): uint32
[ 203.43]           > fib(n: uint32): uint32
[ 203.44]           < return
[ 203.45]           > fib(n: uint32): uint32
[ 203.45]           < return
[ 203.46]          < return
[ 203.47]          > fib(n: uint32): uint32
[ 203.47]          < return
[ 203.48]         < return
[ 203.49]         > fib(n: uint32): uint32
[ 203.50]          > fib(n: uint32): uint32
[ 203.50]          < return
[ 203.51]          > fib(n: uint32): uint32
[ 203.52]          < return
[ 203.53]         < return
[ 203.53]        < return
[ 203.54]        > fib(n: uint32): uint32
[ 203.55]         > fib(n: uint32): uint32
[ 203.56]          > fib(n: uint32): uint32
[ 203.56]          < return
[ 203.57]          > fib(n: uint32): uint32
[ 203.58]          < return
[ 203.59]         < return
[ 203.59]         > fib(n: uint32): uint32
[ 203.60]         < return
[ 203.61]        < return
[ 203.61]       < return
[ 203.62]      < return
[ 203.62]      > fib(n: uint32): uint32
[ 203.63]       > fib(n: uint32): uint32
[ 203.64]        > fib(n: uint32): uint32
[ 203.65]         > fib(n: uint32): uint32
[ 203.66]          > fib(n: uint32): uint32
[ 203.67]           > fib(n: uint32): uint32
[ 203.68]           < return
[ 203.68]           > fib(n: uint32): uint32
[ 203.69]           < return
[ 203.70]          < return
[ 203.71]          > fib(n: uint32): uint32
[ 203.71]          < return
[ 203.72]         < return
[ 203.73]         > fib(n: uint32): uint32
[ 203.73]          > fib(n: uint32): uint32
[ 203.74]          < return
[ 203.75]          > fib(n: uint32): uint32
[ 203.76]          < return
[ 203.76]         < return
[ 203.77]        < return
[ 203.78]        > fib(n: uint32): uint32
[ 203.78]         > fib(n: uint32): uint32
[ 203.79]          > fib(n: uint32): uint32
[ 203.80]          < return
[ 203.81]          > fib(n: uint32): uint32
[ 203.82]          < return
[ 203.82]         < return
[ 203.83]         > fib(n: uint32): uint32
[ 203.84]         < return
[ 203.84]        < return
[ 203.85]       < return
[ 203.86]       > fib(n: uint32): uint32
[ 203.87]        > fib(n: uint32): uint32
[ 203.87]         > fib(n: uint32): uint32
[ 203.88]          > fib(n: uint32): uint32
[ 203.89]          < return
[ 203.90]          > fib(n: uint32): uint32
[ 203.91]          < return
[ 203.91]         < return
[ 203.92]         > fib(n: uint32): uint32
[ 203.93]         < return
[ 203.93]        < return
[ 203.94]        > fib(n: uint32): uint32
[ 203.95]         > fib(n: uint32): uint32
[ 203.96]         < return
[ 203.96]         > fib(n: uint32): uint32
[ 203.97]         < return
[ 203.98]        < return
[ 203.98]       < return
[ 203.99]      < return
[ 204.00]     < return
[ 204.00]     > fib(n: uint32): uint32
[ 204.01]      > fib(n: uint32): uint32
[ 204.02]       > fib(n: uint32): uint32
[ 204.03]        > fib(n: uint32): uint32
[ 204.04]         > fib(n: uint32): uint32
[ 204.05]          > fib(n: uint32): uint32
[ 204.06]           > fib(n: uint32): uint32
[ 204.06]           < return
[ 204.07]           > fib(n: uint32): uint32
[ 204.08]           < return
[ 204.09]          < return
[ 204.09]          > fib(n: uint32): uint32
[ 204.10]          < return
[ 204.11]         < return
[ 204.12]         > fib(n: uint32): uint32
[ 204.12]          > fib(n: uint32): uint32
[ 204.13]          < return
[ 204.14]          > fib(n: uint32): uint32
[ 204.15]          < return
[ 204.15]         < return
[ 204.16]        < return
[ 204.16]        > fib(n: uint32): uint32
[ 204.17]         > fib(n: uint32): uint32
[ 204.18]          > fib(n: uint32): uint32
[ 204.19]          < return
[ 204.20]          > fib(n: uint32): uint32
[ 204.21]          < return
[ 204.21]         < return
[ 204.22]         > fib(n: uint32): uint32
[ 204.23]         < return
[ 204.23]        < return
[ 204.24]       < return
[ 204.25]       > fib(n: uint32): uint32
[ 204.25]        > fib(n: uint32): uint32
[ 204.26]         > fib(n: uint32): uint32
[ 204.27]          > fib(n: uint32): uint32
[ 204.28]          < return
[ 204.29]          > fib(n: uint32): uint32
[ 204.29]          < return
[ 204.30]         < return
[ 204.31]         > fib(n: uint32): uint32
[ 204.32]         < return
[ 204.32]        < return
[ 204.33]        > fib(n: uint32): uint32
[ 204.34]         > fib(n: uint32): uint32
[ 204.35]         < return
[ 204.35]         > fib(n: uint32): uint32
[ 204.36]         < return
[ 204.37]        < return
[ 204.37]       < return
[ 204.38]      < return
[ 204.39]      > fib(n: uint32): uint32
[ 204.39]       > fib(n: uint32): uint32
[ 204.40]        > fib(n: uint32): uint32
[ 204.41]         > fib(n: uint32): uint32
[ 204.42]          > fib(n: uint32): uint32
[ 204.43]          < return
[ 204.44]          > fib(n: uint32): uint32
[ 204.44]          < return
[ 204.45]         < return
[ 204.46]         > fib(n: uint32): uint32
[ 204.47]         < return
[ 204.47]        < return
[ 204.48]        > fib(n: uint32): uint32
[ 204.49]         > fib(n: uint32): uint32
[ 204.50]         < return
[ 204.50]         > fib(n: uint32): uint32
[ 204.51]         < return
[ 204.52]        < return
[ 204.52]       < return
[ 204.53]       > fib(n: uint32): uint32
[ 204.54]        > fib(n: uint32): uint32
[ 204.55]         > fib(n: uint32): uint32
[ 204.55]         < return
[ 204.56]         > fib(n: uint32): uint32
[ 204.57]         < return
[ 204.58]        < return
[ 204.58]        > fib(n: uint32): uint32
[ 204.59]        < return
[ 204.60]       < return
[ 204.60]      < return
[ 204.61]     < return
[ 204.62]    < return
[ 204.62]   < return
[ 204.63]  < return
[ 204.66]  > typename.name(type: typename): .cstr
[ 204.67]  < return
[ 204.69]  > typename.file(type: typename): .cstr
[ 204.70]  < return
[ 204.70]  > typename.line(type: typename): int32
[ 204.71]  < return
[ 204.72]  > typename.base(type: typename): typename
[ 204.73]  < return
[ 204.74]  > typename.name(type: typename): .cstr
[ 204.75]  < return
[ 204.76]  > typename.file(type: typename): .cstr
[ 204.77]  < return
[ 204.78]  > typename.line(type: typename): int32
[ 204.78]  < return
[ 204.79]  > typename.base(type: typename): typename
[ 204.80]  < return
[ 204.81]  > typename.base(type: typename): typename
[ 204.82]  < return
[ 204.86]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 204.87]  < return
[ 204.88]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 204.89]  < return
[ 204.90]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 204.91]  < return
[ 204.92]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 204.93]  < return
[ 204.93]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 204.94]  < return
[ 204.95]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 204.96]  < return
[ 204.97]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 204.98]  < return
[ 204.99]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 204.99]  < return
[ 205.00]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 205.01]  < return
[ 205.02]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 205.03]  < return
[ 205.04]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 205.05]  < return
[ 205.06]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 205.07]  < return
[ 205.07]  > float64.sin(x: float64): float64
[ 205.09]  < return
[ 205.10]  > float64.cos(x: float64): float64
[ 205.11]  < return
[ 205.12]  > float64.tan(x: float64): float64
[ 205.13]  < return
[ 205.14]  > float64.log(x: float64): float64
[ 205.15]  < return
[ 205.16]  > float64.exp(x: float64): float64
[ 205.17]  < return
[ 205.18]  > float64.pow(x: float64, y: float64): float64
[ 205.19]  < return
[ 205.20]  > float64.sqrt(x: float64): float64
[ 205.21]  < return
[ 205.21]  > float64.atan2(x: float64, y: float64): float64
[ 205.22]  < return
[ 205.23]  > float32.sin(x: float32): float32
[ 205.24]  < return
[ 205.25]  > float32.cos(x: float32): float32
[ 205.26]  < return
[ 205.27]  > float32.tan(x: float32): float32
[ 205.27]  < return
[ 205.28]  > float32.log(x: float32): float32
[ 205.29]  < return
[ 205.30]  > float32.exp(x: float32): float32
[ 205.31]  < return
[ 205.32]  > float32.pow(x: float32, y: float32): float32
[ 205.33]  < return
[ 205.34]  > float32.sqrt(x: float32): float32
[ 205.34]  < return
[ 205.35]  > float32.atan2(x: float32, y: float32): float32
[ 205.37]  < return
[ 205.37]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.38]  < return
[ 205.39]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.40]  < return
[ 205.41]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.42]  < return
[ 205.43]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.44]  < return
[ 205.44]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 205.45]  < return
[ 205.46]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 205.47]  < return
[ 205.48]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.49]  < return
[ 205.50]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.51]  < return
[ 205.52]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.53]  < return
[ 205.53]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 205.54]  < return
[ 205.56]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 205.58]  < return
[ 205.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 205.62]  < return
[ 205.63]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 205.64]  < return
[ 205.65]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 205.65]  < return
[ 205.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 205.69]  < return
[ 205.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 205.72]  < return
[ 205.73]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 205.74]   > noError(ptr: pointer): void
[ 205.75]   < return
[ 205.75]   > halt(): void
[ 205.76]   < return
[ 205.77]  < return
[ 205.78]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 205.79]  < return
[ 205.79]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 205.80]   > stackOverflow(ptr: pointer): void
[ 205.81]    > stackOverflow(ptr: pointer): void
[ 205.82]     > stackOverflow(ptr: pointer): void
[ 205.83]      > stackOverflow(ptr: pointer): void
[ 205.84]       > stackOverflow(ptr: pointer): void
[ 205.85]        > stackOverflow(ptr: pointer): void
[ 205.85]         > stackOverflow(ptr: pointer): void
[ 205.86]          > stackOverflow(ptr: pointer): void
[ 205.87]           > stackOverflow(ptr: pointer): void
[ 205.88]            > stackOverflow(ptr: pointer): void
[ 205.89]             > stackOverflow(ptr: pointer): void
[ 205.90]              > stackOverflow(ptr: pointer): void
[ 205.91]               > stackOverflow(ptr: pointer): void
[ 205.92]                > stackOverflow(ptr: pointer): void
[ 205.93]                 > stackOverflow(ptr: pointer): void
[ 205.93]                  > stackOverflow(ptr: pointer): void
[ 205.94]                   > stackOverflow(ptr: pointer): void
[ 205.95]                    > stackOverflow(ptr: pointer): void
[ 205.96]                     > stackOverflow(ptr: pointer): void
[ 205.97]                      > stackOverflow(ptr: pointer): void
[ 205.97]                       > stackOverflow(ptr: pointer): void
[ 205.98]                        > stackOverflow(ptr: pointer): void
[ 205.99]                         > stackOverflow(ptr: pointer): void
[ 206.00]                          > stackOverflow(ptr: pointer): void
[ 206.01]                           > stackOverflow(ptr: pointer): void
[ 206.02]                            > stackOverflow(ptr: pointer): void
[ 206.03]                             > stackOverflow(ptr: pointer): void
[ 206.03]                              > stackOverflow(ptr: pointer): void
[ 206.04]                               > stackOverflow(ptr: pointer): void
[ 206.05]                                > stackOverflow(ptr: pointer): void
[ 206.06]                                 > stackOverflow(ptr: pointer): void
[ 206.07]                                  > stackOverflow(ptr: pointer): void
[ 206.07]                                   > stackOverflow(ptr: pointer): void
[ 206.08]                                    > stackOverflow(ptr: pointer): void
[ 206.09]                                     > stackOverflow(ptr: pointer): void
[ 206.10]                                      > stackOverflow(ptr: pointer): void
[ 206.11]                                       > stackOverflow(ptr: pointer): void
[ 206.12]                                        > stackOverflow(ptr: pointer): void
[ 206.12]                                         > stackOverflow(ptr: pointer): void
[ 206.13]                                          > stackOverflow(ptr: pointer): void
[ 206.14]                                           > stackOverflow(ptr: pointer): void
[ 206.15]                                            > stackOverflow(ptr: pointer): void
[ 206.16]                                             > stackOverflow(ptr: pointer): void
[ 206.16]                                              > stackOverflow(ptr: pointer): void
[ 206.17]                                               > stackOverflow(ptr: pointer): void
[ 206.18]                                                > stackOverflow(ptr: pointer): void
[ 206.19]                                                 > stackOverflow(ptr: pointer): void
[ 206.20]                                                  > stackOverflow(ptr: pointer): void
[ 206.21]                                                   > stackOverflow(ptr: pointer): void
[ 206.21]                                                    > stackOverflow(ptr: pointer): void
[ 206.23]                                                     > stackOverflow(ptr: pointer): void
[ 206.24]                                                      > stackOverflow(ptr: pointer): void
[ 206.25]                                                       > stackOverflow(ptr: pointer): void
[ 206.25]                                                        > stackOverflow(ptr: pointer): void
[ 206.26]                                                         > stackOverflow(ptr: pointer): void
[ 206.27]                                                          > stackOverflow(ptr: pointer): void
[ 206.28]                                                           > stackOverflow(ptr: pointer): void
[ 206.29]                                                            > stackOverflow(ptr: pointer): void
[ 206.30]                                                             > stackOverflow(ptr: pointer): void
[ 206.30]                                                              > stackOverflow(ptr: pointer): void
[ 206.31]                                                               > stackOverflow(ptr: pointer): void
[ 206.33]                                                                > stackOverflow(ptr: pointer): void
[ 206.34]                                                                 > stackOverflow(ptr: pointer): void
[ 206.34]                                                                  > stackOverflow(ptr: pointer): void
[ 206.35]                                                                  < return
[ 206.36]                                                                 < return
[ 206.36]                                                                < return
[ 206.37]                                                               < return
[ 206.38]                                                              < return
[ 206.38]                                                             < return
[ 206.39]                                                            < return
[ 206.40]                                                           < return
[ 206.40]                                                          < return
[ 206.41]                                                         < return
[ 206.41]                                                        < return
[ 206.42]                                                       < return
[ 206.43]                                                      < return
[ 206.43]                                                     < return
[ 206.44]                                                    < return
[ 206.45]                                                   < return
[ 206.45]                                                  < return
[ 206.46]                                                 < return
[ 206.47]                                                < return
[ 206.47]                                               < return
[ 206.48]                                              < return
[ 206.49]                                             < return
[ 206.49]                                            < return
[ 206.50]                                           < return
[ 206.50]                                          < return
[ 206.51]                                         < return
[ 206.52]                                        < return
[ 206.52]                                       < return
[ 206.53]                                      < return
[ 206.54]                                     < return
[ 206.54]                                    < return
[ 206.55]                                   < return
[ 206.56]                                  < return
[ 206.56]                                 < return
[ 206.57]                                < return
[ 206.57]                               < return
[ 206.58]                              < return
[ 206.59]                             < return
[ 206.59]                            < return
[ 206.60]                           < return
[ 206.60]                          < return
[ 206.61]                         < return
[ 206.62]                        < return
[ 206.62]                       < return
[ 206.63]                      < return
[ 206.64]                     < return
[ 206.64]                    < return
[ 206.65]                   < return
[ 206.66]                  < return
[ 206.66]                 < return
[ 206.67]                < return
[ 206.67]               < return
[ 206.68]              < return
[ 206.69]             < return
[ 206.69]            < return
[ 206.70]           < return
[ 206.71]          < return
[ 206.71]         < return
[ 206.72]        < return
[ 206.72]       < return
[ 206.73]      < return
[ 206.74]     < return
[ 206.74]    < return
[ 206.75]   < return
[ 206.76]  < return
[ 206.76]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 206.77]   > divisionByZero(args: pointer): void
[ 206.78]   < return
[ 206.79]  < return
[ 206.80]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 206.81]   > invalidInstruction(args: pointer): void
[ 206.81]   < return
[ 206.82]  < return
[ 206.83]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 206.84]   > invalidMemoryAccess(args: pointer): void
[ 206.85]   < return
[ 206.85]  < return
[ 206.86]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 206.87]   > abortExecution(args: pointer): void
[ 206.88]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 206.97]    < return
[ 206.98]   < return
[ 206.99]  < return
[ 207.08]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 207.09]  < return
[ 207.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 207.18]  < return
[ 207.19]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 207.25]  < return
[ 207.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 207.29]  < return
[ 207.30]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 207.33]  < return
[ 207.34]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 207.37]  < return
[ 207.38]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 207.40]  < return
[ 207.42]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.43]  < return
[ 207.44]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.45]  < return
[ 207.46]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.47]  < return
[ 207.48]  > lenSlice(values: int64[]): int32
[ 207.49]  < return
[ 207.50]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.51]  < return
[ 207.52]  > lenSlice(values: int64[]): int32
[ 207.53]  < return
[ 207.53]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.54]  < return
[ 207.56]  > lenSlice(values: int64[]): int32
[ 207.56]  < return
[ 207.57]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.58]  < return
[ 207.59]  > lenSlice(values: int64[]): int32
[ 207.60]  < return
[ 207.61]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.62]  < return
[ 207.63]  > lenSlice(values: int64[]): int32
[ 207.64]  < return
[ 207.65]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 207.65]  < return
[ 207.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 207.70]  < return
[ 207.71]  > nthFixed(idx: int32, values: int64[7]): int64
[ 207.72]  < return
[ 207.74]  > nthFixed(idx: int32, values: int64[7]): int64
[ 207.75]  < return
[ 207.76]  > nthArray(idx: int32, values: int64[*]): int64
[ 207.77]  < return
[ 207.78]  > nthArray(idx: int32, values: int64[*]): int64
[ 207.79]  < return
[ 207.81]  > nthArray(idx: int32, values: int64[*]): int64
[ 207.82]  < return
[ 207.83]  > nthSlice(idx: int32, values: int64[]): int64
[ 207.84]  < return
[ 207.85]  > nthSlice(idx: int32, values: int64[]): int64
[ 207.86]  < return
[ 207.91]  > nthFixed(idx: int32, values: int64[7]): int64
[ 207.92]  < return
[ 207.93]  > nthFixed(idx: int32, values: int64[7]): int64
[ 207.94]  < return
[ 207.95]  > nthFixed(idx: int32, values: int64[7]): int64
[ 207.96]  < return
[ 207.98]  > nthArray(idx: int32, values: int64[*]): int64
[ 207.99]  < return
[ 208.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.01]  < return
[ 208.03]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.04]  < return
[ 208.05]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.06]  < return
[ 208.07]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.08]  < return
[ 208.13]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.14]  < return
[ 208.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.16]  < return
[ 208.18]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.19]  < return
[ 208.20]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.21]  < return
[ 208.22]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.23]  < return
[ 208.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.25]  < return
[ 208.27]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.28]  < return
[ 208.29]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.30]  < return
[ 208.34]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.35]  < return
[ 208.37]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.38]  < return
[ 208.39]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.40]  < return
[ 208.41]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.42]  < return
[ 208.44]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.45]  < return
[ 208.46]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.47]  < return
[ 208.48]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.49]  < return
[ 208.51]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.52]  < return
[ 208.56]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.57]  < return
[ 208.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.59]  < return
[ 208.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.62]  < return
[ 208.63]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.64]  < return
[ 208.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.66]  < return
[ 208.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.69]  < return
[ 208.70]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.71]  < return
[ 208.72]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.73]  < return
[ 208.78]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.79]  < return
[ 208.80]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.81]  < return
[ 208.82]  > nthFixed(idx: int32, values: int64[7]): int64
[ 208.83]  < return
[ 208.85]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.86]  < return
[ 208.87]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.88]  < return
[ 208.89]  > nthArray(idx: int32, values: int64[*]): int64
[ 208.90]  < return
[ 208.92]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.93]  < return
[ 208.94]  > nthSlice(idx: int32, values: int64[]): int64
[ 208.95]  < return
[ 208.99]  > nthFixed(idx: int32, values: int64[7]): int64
[ 209.00]  < return
[ 209.02]  > nthFixed(idx: int32, values: int64[7]): int64
[ 209.03]  < return
[ 209.04]  > nthFixed(idx: int32, values: int64[7]): int64
[ 209.05]  < return
[ 209.06]  > nthArray(idx: int32, values: int64[*]): int64
[ 209.07]  < return
[ 209.09]  > nthArray(idx: int32, values: int64[*]): int64
[ 209.10]  < return
[ 209.11]  > nthArray(idx: int32, values: int64[*]): int64
[ 209.12]  < return
[ 209.13]  > nthSlice(idx: int32, values: int64[]): int64
[ 209.14]  < return
[ 209.16]  > nthSlice(idx: int32, values: int64[]): int64
[ 209.17]  < return
[ 209.22]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 209.23]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:69: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 209.31]   < return
[ 209.32]  < return
[ 209.33]  > customPrint(this: RecordMethodTest): void
[ 209.34]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:60: debug: override
	test/lang/method.ci:70: customPrint(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 209.42]   < return
[ 209.43]  < return
[ 209.44]  > RecordMethodTest.printStatic(this: RecordMethodTest): void
[ 209.44]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:45: debug: static
	test/lang/method.ci:73: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 209.52]   < return
[ 209.53]  < return
[ 209.54]  > print(this: RecordMethodTest): void
[ 209.55]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:76: debug: extension
	test/lang/method.ci:84: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 209.62]   < return
[ 209.63]  < return
[ 209.64]  > printStatic(this: RecordMethodTest): void
[ 209.65]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:80: debug: extension
	test/lang/method.ci:85: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 209.72]   < return
[ 209.73]  < return
[ 209.74]  > print(this: RecordMethodTest): void
[ 209.75]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:76: debug: extension
	test/lang/method.ci:86: print(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 209.83]   < return
[ 209.84]  < return
[ 209.84]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 209.85]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:89: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 209.94]   < return
[ 209.95]  < return
[ 209.96]  > RecordMethodTest.printStatic(this: RecordMethodTest): void
[ 209.97]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:45: debug: static
	test/lang/method.ci:90: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 210.04]   < return
[ 210.05]  < return
[ 210.06]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 210.07]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:91: print(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 210.15]   < return
[ 210.15]  < return
[ 211.06]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 211.08]  < return
[ 211.10]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 211.12]  < return
[ 211.14]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 211.16]  < return
[ 211.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 211.20]  < return
[ 211.23]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 211.25]  < return
[ 211.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 211.30]  < return
[ 211.31]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 211.34]  < return
[ 211.36]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 211.38]  < return
[ 211.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 211.42]  < return
[ 211.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 211.46]  < return
[ 211.49]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 211.51]  < return
[ 211.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 211.56]  < return
[ 211.61]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 211.63]  < return
[ 211.66]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 211.68]  < return
[ 211.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 211.72]  < return
[ 211.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 211.77]  < return
[ 211.80]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 211.82]  < return
[ 211.85]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 211.87]  < return
[ 211.90]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 211.92]  < return
[ 211.95]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 211.97]  < return
[ 211.99]  > halt(): void
[ 212.00]  < return
[ 212.00] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:38: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:59: Math.floor: function(<Math.floor>)
lib/std/math.ci:71: Math.sign: function(<Math.sign>)
lib/std/math.ci:80: Math.sign: function(<Math.sign>)
lib/std/math.ci:90: Math.abs: function(<Math.abs>)
lib/std/math.ci:96: Math.abs: function(<Math.abs>)
lib/std/math.ci:103: Math.min: function(<Math.min>)
lib/std/math.ci:109: Math.min: function(<Math.min>)
lib/std/math.ci:116: Math.max: function(<Math.max>)
lib/std/math.ci:122: Math.max: function(<Math.max>)
lib/std/math.ci:129: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:138: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:148: Math.lerp: function(<Math.lerp>)
lib/std/math.ci:151: Math.lerp: function(<Math.lerp>)
lib/std/math.ci:155: Math.smooth: function(<Math.smooth>)
lib/std/math.ci:159: Math.smooth: function(<Math.smooth>)
lib/std/math.ci:239: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:252: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:266: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:323: Math.tan: function(<Math.tan>)
lib/std/math.ci:380: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:419: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:435: Math.asin: function(<Math.asin>)
lib/std/math.ci:3: Math: typename(<Math>)
lib/std/math.Complex.ci:3: Complex: typename(<Complex>)
lib/std/math.Complex.ci:20: Complex: function(<Complex>)
lib/std/math.Complex.ci:25: Complex: function(<Complex>)
lib/std/math.Complex.ci:66: div: function(<div>)
lib/std/math.Complex.ci:93: inv: function(<inv>)
lib/std/math.Complex.ci:107: pow: function(<pow>)
lib/std/string.ci:3: length: function(<length>)
lib/std/string.ci:14: indexOf: function(<indexOf>)
lib/std/string.ci:24: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:35: startsWith: function(<startsWith>)
lib/std/string.ci:44: endsWith: function(<endsWith>)
lib/std/string.ci:58: compare: function(<compare>)
lib/std/string.ci:70: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:84: caseCmp: function(<caseCmp>)
lib/std/string.ci:106: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:113: append: function(<append>)
lib/std/string.ci:129: append: function(<append>)
lib/std/string.ci:192: append: function(<append>)
lib/std/string.ci:196: append: function(<append>)
lib/std/string.ci:205: append: function(<append>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:11: emitNfcF32: float32(1.000000)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(136)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(167920)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(167648)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2472)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(136)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: sinF64: float64(1.000000)
test/stdc/number.ci:38: cosF64: float64(0.000000)
test/stdc/number.ci:39: tanF64: float64(1.000000)
test/stdc/number.ci:40: logF64: float64(3.000000)
test/stdc/number.ci:41: expF64: float64(2.718282)
test/stdc/number.ci:42: powF64: float64(3.141593)
test/stdc/number.ci:43: sqrtF64: float64(3.141593)
test/stdc/number.ci:44: atanF64: float64(1.262627)
test/stdc/number.ci:46: sinF32: float32(1.000000)
test/stdc/number.ci:47: cosF32: float32(-0.000000)
test/stdc/number.ci:48: tanF32: float32(1.000000)
test/stdc/number.ci:49: logF32: float32(3.000000)
test/stdc/number.ci:50: expF32: float32(2.718282)
test/stdc/number.ci:51: powF32: float32(3.141593)
test/stdc/number.ci:52: sqrtF32: float32(3.141593)
test/stdc/number.ci:53: atanF32: float32(1.262627)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](BadRef)
test/lang/array.ci:51: arrSliceNoInit: int64[](BadRef)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(5)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(6)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 51,
	constant: 52
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 61,
	constant: 62
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 6,
	constant: 7,
	memberInit: 8,
	constantInit: 9,
	memberRec: {
		member: 61,
		constant: 62
	},
	constantRec: {
		member: 71,
		constant: 72
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:12: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:26: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:31: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.print: function(<RecordMethodTest.print>)
test/lang/method.ci:44: RecordMethodTest.printStatic: function(<RecordMethodTest.printStatic>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:49: globalFunction: function(<globalFunction>)
test/lang/method.ci:53: recordMethodTest: RecordMethodTest({
	abstractMethod: <RecordMethodTest.staticMethod>,
	delegateMethod: <globalFunction>,
	virtualMethod: <RecordMethodTest.virtualMethod>,
	print: <RecordMethodTest.print>
})
test/lang/method.ci:59: customPrint: function(<customPrint>)
test/lang/method.ci:63: recordMethodTestCustomPrint: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>,
	print: <customPrint>
})
test/lang/method.ci:75: print: function(<print>)
test/lang/method.ci:79: printStatic: function(<printStatic>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 260427(254.3 Kb)
memory[heap] @03f94b; size: 1312179(1.3 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 247512(241.7 Kb)
memory[code] @000000; size: 12596(12.3 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @03f968; size: 1312128(1.3 Mb)

---------- Profile functions: 49/111, coverage: 44.14%
::[.0052b0, .0052b0): exec(2), time(13 / 0.013 ms): halt(): void
::[.0055a8, .0055a8): exec(3), time(26 / 0.026 ms): typename.base(type: typename): typename
::[.005778, .005778): exec(2), time(17 / 0.017 ms): typename.file(type: typename): .cstr
::[.005948, .005948): exec(2), time(17 / 0.017 ms): typename.line(type: typename): int32
::[.005b18, .005b18): exec(2), time(23 / 0.023 ms): typename.name(type: typename): .cstr
::[.0061f0, .0061f0): exec(40), time(1549 / 1.549 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0069f0, .0069f0): exec(7), time(1207 / 1.207 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.006c50, .006c50): exec(8), time(66 / 0.066 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.006f40, .006f40): exec(2), time(17 / 0.017 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007228, .007228): exec(2), time(19 / 0.019 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.007508, .007508): exec(1), time(8 / 0.008 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.007770, .007770): exec(0), time(0 / 0.000 ms): System.exit(code: int32): void
::[.007948, .007948): exec(0), time(0 / 0.000 ms): System.srand(seed: int32): void
::[.007a90, .007a90): exec(0), time(0 / 0.000 ms): System.rand(): int32
::[.007bd8, .007bd8): exec(0), time(0 / 0.000 ms): System.time(): int32
::[.007d20, .007d20): exec(0), time(0 / 0.000 ms): System.clock(): int32
::[.007e68, .007e68): exec(0), time(0 / 0.000 ms): System.millis(): int64
::[.008038, .008038): exec(0), time(0 / 0.000 ms): System.sleep(millis: int64): void
::[.008328, .008328): exec(6), time(49 / 0.049 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.008608, .008608): exec(6), time(48 / 0.048 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0087d8, .0087d8): exec(0), time(0 / 0.000 ms): uint32.pop(value: int32): int32
::[.0089a8, .0089a8): exec(0), time(0 / 0.000 ms): uint32.swap(value: int32): int32
::[.008b78, .008b78): exec(0), time(0 / 0.000 ms): uint32.bsr(value: int32): int32
::[.008d48, .008d48): exec(0), time(0 / 0.000 ms): uint32.bsf(value: int32): int32
::[.008f18, .008f18): exec(0), time(0 / 0.000 ms): uint32.hib(value: int32): int32
::[.0090e8, .0090e8): exec(0), time(0 / 0.000 ms): uint32.lob(value: int32): int32
::[.0093c0, .0093c0): exec(0), time(0 / 0.000 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.009698, .009698): exec(0), time(0 / 0.000 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.009870, .009870): exec(2), time(31 / 0.031 ms): float32.sin(x: float32): float32
::[.009a40, .009a40): exec(1), time(8 / 0.008 ms): float32.cos(x: float32): float32
::[.009c10, .009c10): exec(1), time(8 / 0.008 ms): float32.tan(x: float32): float32
::[.009de0, .009de0): exec(1), time(8 / 0.008 ms): float32.log(x: float32): float32
::[.009fb0, .009fb0): exec(1), time(8 / 0.008 ms): float32.exp(x: float32): float32
::[.00a210, .00a210): exec(1), time(8 / 0.008 ms): float32.pow(x: float32, y: float32): float32
::[.00a3e0, .00a3e0): exec(1), time(8 / 0.008 ms): float32.sqrt(x: float32): float32
::[.00a638, .00a638): exec(1), time(11 / 0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00a800, .00a800): exec(1), time(16 / 0.016 ms): float64.sin(x: float64): float64
::[.00a9c8, .00a9c8): exec(1), time(11 / 0.011 ms): float64.cos(x: float64): float64
::[.00ab90, .00ab90): exec(1), time(8 / 0.008 ms): float64.tan(x: float64): float64
::[.00ad58, .00ad58): exec(1), time(10 / 0.010 ms): float64.log(x: float64): float64
::[.00af20, .00af20): exec(1), time(8 / 0.008 ms): float64.exp(x: float64): float64
::[.00b170, .00b170): exec(1), time(10 / 0.010 ms): float64.pow(x: float64, y: float64): float64
::[.00b338, .00b338): exec(1), time(7 / 0.007 ms): float64.sqrt(x: float64): float64
::[.00b588, .00b588): exec(1), time(9 / 0.009 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:38:[.03c6d8, .03c72a): exec(8), time(71 / 0.071 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.03c730, .03c78b): exec(0), time(0 / 0.000 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:59:[.03c790, .03c7ad): exec(0), time(0 / 0.000 ms): Math.floor(x: float64): float64
lib/std/math.ci:71:[.03c7b0, .03c7d4): exec(0), time(0 / 0.000 ms): Math.sign(x: float32): int32
lib/std/math.ci:80:[.03c7d8, .03c7fc): exec(0), time(0 / 0.000 ms): Math.sign(x: float64): int32
lib/std/math.ci:90:[.03c800, .03c812): exec(0), time(0 / 0.000 ms): Math.abs(x: float32): float32
lib/std/math.ci:96:[.03c818, .03c82a): exec(0), time(0 / 0.000 ms): Math.abs(x: float64): float64
lib/std/math.ci:103:[.03c830, .03c841): exec(0), time(0 / 0.000 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:109:[.03c848, .03c859): exec(0), time(0 / 0.000 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:116:[.03c860, .03c871): exec(0), time(0 / 0.000 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:122:[.03c878, .03c889): exec(0), time(0 / 0.000 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:129:[.03c890, .03c8ae): exec(0), time(0 / 0.000 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:138:[.03c8b0, .03c8ce): exec(0), time(0 / 0.000 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:148:[.03c8d0, .03c8de): exec(0), time(0 / 0.000 ms): Math.lerp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:151:[.03c8e0, .03c8ee): exec(0), time(0 / 0.000 ms): Math.lerp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:155:[.03c8f0, .03c925): exec(0), time(0 / 0.000 ms): Math.smooth(t: float32, a: float32, b: float32): float32
lib/std/math.ci:159:[.03c928, .03c969): exec(0), time(0 / 0.000 ms): Math.smooth(t: float64, a: float64, b: float64): float64
lib/std/math.ci:239:[.03c970, .03c9a9): exec(0), time(0 / 0.000 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:252:[.03c9b0, .03c9e9): exec(0), time(0 / 0.000 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:266:[.03c9f0, .03cb44): exec(0), time(0 / 0.000 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:323:[.03cb48, .03ccc0): exec(0), time(0 / 0.000 ms): Math.tan(arg: float64): float64
lib/std/math.ci:380:[.03ccc0, .03cdb6): exec(0), time(0 / 0.000 ms): Math.sinh(x: float64): float64
lib/std/math.ci:419:[.03cdb8, .03ce03): exec(0), time(0 / 0.000 ms): Math.cosh(x: float64): float64
lib/std/math.ci:435:[.03ce08, .03ceb3): exec(0), time(0 / 0.000 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:20:[.03ceb8, .03cebf): exec(0), time(0 / 0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:25:[.03cec0, .03cec7): exec(0), time(0 / 0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:66:[.03cec8, .03cf48): exec(0), time(0 / 0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:93:[.03cf48, .03cf6c): exec(0), time(0 / 0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:107:[.03cf70, .03cfd9): exec(0), time(0 / 0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:3:[.03cfe0, .03d00b): exec(0), time(0 / 0.000 ms): length(str: char[*]): int32
lib/std/string.ci:14:[.03d010, .03d042): exec(0), time(0 / 0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:24:[.03d048, .03d07f): exec(0), time(0 / 0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:35:[.03d080, .03d0c9): exec(0), time(0 / 0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:44:[.03d0d0, .03d153): exec(0), time(0 / 0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:58:[.03d158, .03d19c): exec(0), time(0 / 0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:71:[.03d1a0, .03d1e7): exec(0), time(0 / 0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:70:[.03d1e8, .03d20c): exec(0), time(0 / 0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:84:[.03d210, .03d21e): exec(0), time(0 / 0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:113:[.03d220, .03d274): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:129:[.03d288, .03d51e): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:192:[.03d520, .03d537): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:196:[.03d538, .03d56e): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:205:[.03d580, .03d599): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: uint32): int32
test/lang/function.ci:3:[.03d5a8, .03d5a9): exec(0), time(0 / 0.000 ms): empty(): void
test/lang/function.ci:6:[.03d5b0, .03d5b8): exec(2), time(18 / 0.018 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.03d5b8, .03d5c0): exec(2), time(16 / 0.016 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.03d5c0, .03d5f6): exec(753), time(11555 / 11.555 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.03d5f8, .03d5f9): exec(1), time(11 / 0.011 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.03d600, .03d618): exec(64-64), time(946 / 0.946 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.03d618, .03d624): exec(1-1), time(10 / 0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.03d628, .03d66c): exec(1-1), time(107-87 / 0.107-0.087 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.03d670, .03d67d): exec(1-1), time(11 / 0.011 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.03d680, .03d682): exec(1-1), time(9 / 0.009 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.03d688, .03d68c): exec(5), time(49 / 0.049 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.03d690, .03d69c): exec(21), time(217 / 0.217 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.03d6a0, .03d6ac): exec(21), time(216 / 0.216 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.03d6b0, .03d6bc): exec(14), time(149 / 0.149 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.03d6f0, .03d6f8): exec(0), time(0 / 0.000 ms): RecordMethodTest.staticMethod(x: int32, y: int32): int32
test/lang/method.ci:26:[.03d700, .03d708): exec(0), time(0 / 0.000 ms): RecordMethodTest.virtualMethod(x: int32, y: int32): int32
test/lang/method.ci:31:[.03d708, .03d710): exec(0), time(0 / 0.000 ms): RecordMethodTest.forwardMethod(x: int32, y: int32): int32
test/lang/method.ci:40:[.03d710, .03d738): exec(3), time(291-238 / 0.291-0.238 ms): RecordMethodTest.print(this: RecordMethodTest): void
test/lang/method.ci:44:[.03d738, .03d760): exec(2), time(185-150 / 0.185-0.150 ms): RecordMethodTest.printStatic(this: RecordMethodTest): void
test/lang/method.ci:49:[.03d760, .03d768): exec(0), time(0 / 0.000 ms): globalFunction(x: int32, y: int32): int32
test/lang/method.ci:59:[.03d768, .03d790): exec(1), time(98-80 / 0.098-0.080 ms): customPrint(this: RecordMethodTest): void
test/lang/method.ci:75:[.03d790, .03d7b8): exec(2), time(187-153 / 0.187-0.153 ms): print(this: RecordMethodTest): void
test/lang/method.ci:79:[.03d7b8, .03d7e0): exec(1), time(92-75 / 0.092-0.075 ms): printStatic(this: RecordMethodTest): void
::[.03d7e0, .03f94b): exec(1), time(19351-15589 / 19.351-15.589 ms): .main

---------- Profile statements: 676/991, coverage: 68.21%
lib/stdlib.ci:40:[.03c6e1, .03c6e2) exec(8), time(41-41 / 0.041-0.041 ms): <assertEq+9>
lib/stdlib.ci:39:[.03c6d8, .03c6e2) exec(8-8), time(0 / 0.000 ms): <assertEq+0>
lib/stdlib.ci:43:[.03c6e6, .03c6f1) exec(0), time(0 / 0.000 ms): <assertEq+14>
lib/stdlib.ci:44:[.03c6f1, .03c6fc) exec(0), time(0 / 0.000 ms): <assertEq+25>
lib/stdlib.ci:45:[.03c6fc, .03c6ff) exec(0), time(0 / 0.000 ms): <assertEq+36>
lib/stdlib.ci:42:[.03c6e2, .03c6ff) exec(0), time(0 / 0.000 ms): <assertEq+10>
lib/stdlib.ci:47:[.03c6ff, .03c725) exec(0), time(0 / 0.000 ms): <assertEq+39>
lib/std/math.ci:25:[.03c748, .03c759) exec(0), time(0 / 0.000 ms): <modf+24>
lib/std/math.ci:26:[.03c759, .03c760) exec(0), time(0 / 0.000 ms): <modf+41>
lib/std/math.ci:27:[.03c760, .03c763) exec(0), time(0 / 0.000 ms): <modf+48>
lib/std/math.ci:24:[.03c740, .03c767) exec(0), time(0 / 0.000 ms): <modf+16>
lib/std/math.ci:29:[.03c767, .03c76b) exec(0), time(0 / 0.000 ms): <modf+55>
lib/std/math.ci:30:[.03c76b, .03c76f) exec(0), time(0 / 0.000 ms): <modf+59>
lib/std/math.ci:23:[.03c730, .03c76f) exec(0), time(0 / 0.000 ms): <modf+0>
lib/std/math.ci:32:[.03c76f, .03c77b) exec(0), time(0 / 0.000 ms): <modf+63>
lib/std/math.ci:33:[.03c77b, .03c783) exec(0), time(0 / 0.000 ms): <modf+75>
lib/std/math.ci:34:[.03c783, .03c786) exec(0), time(0 / 0.000 ms): <modf+83>
lib/std/math.ci:60:[.03c790, .03c791) exec(0), time(0 / 0.000 ms): <floor+0>
lib/std/math.ci:61:[.03c791, .03c7a5) exec(0), time(0 / 0.000 ms): <floor+1>
lib/std/math.ci:62:[.03c7a5, .03c7a8) exec(0), time(0 / 0.000 ms): <floor+21>
lib/std/math.ci:73:[.03c7b8, .03c7bc) exec(0), time(0 / 0.000 ms): <sign+8>
lib/std/math.ci:72:[.03c7b0, .03c7bc) exec(0), time(0 / 0.000 ms): <sign+0>
lib/std/math.ci:76:[.03c7c4, .03c7cc) exec(0), time(0 / 0.000 ms): <sign+20>
lib/std/math.ci:75:[.03c7bc, .03c7cc) exec(0), time(0 / 0.000 ms): <sign+12>
lib/std/math.ci:78:[.03c7cc, .03c7d4) exec(0), time(0 / 0.000 ms): <sign+28>
lib/std/math.ci:82:[.03c7e0, .03c7e4) exec(0), time(0 / 0.000 ms): <sign+8>
lib/std/math.ci:81:[.03c7d8, .03c7e4) exec(0), time(0 / 0.000 ms): <sign+0>
lib/std/math.ci:85:[.03c7ec, .03c7f4) exec(0), time(0 / 0.000 ms): <sign+20>
lib/std/math.ci:84:[.03c7e4, .03c7f4) exec(0), time(0 / 0.000 ms): <sign+12>
lib/std/math.ci:87:[.03c7f4, .03c7fc) exec(0), time(0 / 0.000 ms): <sign+28>
lib/std/math.ci:92:[.03c808, .03c80e) exec(0), time(0 / 0.000 ms): <abs+8>
lib/std/math.ci:91:[.03c800, .03c80e) exec(0), time(0 / 0.000 ms): <abs+0>
lib/std/math.ci:94:[.03c80e, .03c812) exec(0), time(0 / 0.000 ms): <abs+14>
lib/std/math.ci:98:[.03c820, .03c826) exec(0), time(0 / 0.000 ms): <abs+8>
lib/std/math.ci:97:[.03c818, .03c826) exec(0), time(0 / 0.000 ms): <abs+0>
lib/std/math.ci:100:[.03c826, .03c82a) exec(0), time(0 / 0.000 ms): <abs+14>
lib/std/math.ci:105:[.03c839, .03c83d) exec(0), time(0 / 0.000 ms): <min+9>
lib/std/math.ci:104:[.03c830, .03c83d) exec(0), time(0 / 0.000 ms): <min+0>
lib/std/math.ci:107:[.03c83d, .03c841) exec(0), time(0 / 0.000 ms): <min+13>
lib/std/math.ci:111:[.03c851, .03c855) exec(0), time(0 / 0.000 ms): <min+9>
lib/std/math.ci:110:[.03c848, .03c855) exec(0), time(0 / 0.000 ms): <min+0>
lib/std/math.ci:113:[.03c855, .03c859) exec(0), time(0 / 0.000 ms): <min+13>
lib/std/math.ci:118:[.03c869, .03c86d) exec(0), time(0 / 0.000 ms): <max+9>
lib/std/math.ci:117:[.03c860, .03c86d) exec(0), time(0 / 0.000 ms): <max+0>
lib/std/math.ci:120:[.03c86d, .03c871) exec(0), time(0 / 0.000 ms): <max+13>
lib/std/math.ci:124:[.03c881, .03c885) exec(0), time(0 / 0.000 ms): <max+9>
lib/std/math.ci:123:[.03c878, .03c885) exec(0), time(0 / 0.000 ms): <max+0>
lib/std/math.ci:126:[.03c885, .03c889) exec(0), time(0 / 0.000 ms): <max+13>
lib/std/math.ci:131:[.03c899, .03c89d) exec(0), time(0 / 0.000 ms): <clamp+9>
lib/std/math.ci:130:[.03c890, .03c89d) exec(0), time(0 / 0.000 ms): <clamp+0>
lib/std/math.ci:134:[.03c8a6, .03c8aa) exec(0), time(0 / 0.000 ms): <clamp+22>
lib/std/math.ci:133:[.03c89d, .03c8aa) exec(0), time(0 / 0.000 ms): <clamp+13>
lib/std/math.ci:136:[.03c8aa, .03c8ae) exec(0), time(0 / 0.000 ms): <clamp+26>
lib/std/math.ci:140:[.03c8b9, .03c8bd) exec(0), time(0 / 0.000 ms): <clamp+9>
lib/std/math.ci:139:[.03c8b0, .03c8bd) exec(0), time(0 / 0.000 ms): <clamp+0>
lib/std/math.ci:143:[.03c8c6, .03c8ca) exec(0), time(0 / 0.000 ms): <clamp+22>
lib/std/math.ci:142:[.03c8bd, .03c8ca) exec(0), time(0 / 0.000 ms): <clamp+13>
lib/std/math.ci:145:[.03c8ca, .03c8ce) exec(0), time(0 / 0.000 ms): <clamp+26>
lib/std/math.ci:149:[.03c8d0, .03c8de) exec(0), time(0 / 0.000 ms): <lerp+0>
lib/std/math.ci:152:[.03c8e0, .03c8ee) exec(0), time(0 / 0.000 ms): <lerp+0>
lib/std/math.ci:156:[.03c8f0, .03c90e) exec(0), time(0 / 0.000 ms): <smooth+0>
lib/std/math.ci:157:[.03c90e, .03c925) exec(0), time(0 / 0.000 ms): <smooth+30>
lib/std/math.ci:160:[.03c928, .03c94a) exec(0), time(0 / 0.000 ms): <smooth+0>
lib/std/math.ci:161:[.03c94a, .03c969) exec(0), time(0 / 0.000 ms): <smooth+34>
lib/std/math.ci:242:[.03c985, .03c98d) exec(0), time(0 / 0.000 ms): <cmp+21>
lib/std/math.ci:241:[.03c979, .03c98d) exec(0), time(0 / 0.000 ms): <cmp+9>
lib/std/math.ci:247:[.03c99d, .03c9a5) exec(0), time(0 / 0.000 ms): <cmp+45>
lib/std/math.ci:246:[.03c991, .03c9a5) exec(0), time(0 / 0.000 ms): <cmp+33>
lib/std/math.ci:240:[.03c970, .03c9a5) exec(0), time(0 / 0.000 ms): <cmp+0>
lib/std/math.ci:250:[.03c9a5, .03c9a9) exec(0), time(0 / 0.000 ms): <cmp+53>
lib/std/math.ci:255:[.03c9c5, .03c9cd) exec(0), time(0 / 0.000 ms): <cmp+21>
lib/std/math.ci:254:[.03c9b9, .03c9cd) exec(0), time(0 / 0.000 ms): <cmp+9>
lib/std/math.ci:260:[.03c9dd, .03c9e5) exec(0), time(0 / 0.000 ms): <cmp+45>
lib/std/math.ci:259:[.03c9d1, .03c9e5) exec(0), time(0 / 0.000 ms): <cmp+33>
lib/std/math.ci:253:[.03c9b0, .03c9e5) exec(0), time(0 / 0.000 ms): <cmp+0>
lib/std/math.ci:263:[.03c9e5, .03c9e9) exec(0), time(0 / 0.000 ms): <cmp+53>
lib/std/math.ci:280:[.03c9f0, .03c9f2) exec(0), time(0 / 0.000 ms): <sinCos+0>
lib/std/math.ci:282:[.03c9fa, .03c9fb) exec(0), time(0 / 0.000 ms): <sinCos+10>
lib/std/math.ci:283:[.03c9fb, .03ca03) exec(0), time(0 / 0.000 ms): <sinCos+11>
lib/std/math.ci:281:[.03c9f2, .03ca03) exec(0), time(0 / 0.000 ms): <sinCos+2>
lib/std/math.ci:286:[.03ca03, .03ca04) exec(0), time(0 / 0.000 ms): <sinCos+19>
lib/std/math.ci:287:[.03ca04, .03ca1c) exec(0), time(0 / 0.000 ms): <sinCos+20>
lib/std/math.ci:289:[.03ca2c, .03ca2d) exec(0), time(0 / 0.000 ms): <sinCos+60>
lib/std/math.ci:290:[.03ca2d, .03ca3f) exec(0), time(0 / 0.000 ms): <sinCos+61>
lib/std/math.ci:291:[.03ca3f, .03ca43) exec(0), time(0 / 0.000 ms): <sinCos+79>
lib/std/math.ci:293:[.03ca43, .03ca44) exec(0), time(0 / 0.000 ms): <sinCos+83>
lib/std/math.ci:294:[.03ca44, .03ca62) exec(0), time(0 / 0.000 ms): <sinCos+84>
lib/std/math.ci:295:[.03ca62, .03ca74) exec(0), time(0 / 0.000 ms): <sinCos+114>
lib/std/math.ci:298:[.03ca7c, .03ca7f) exec(0), time(0 / 0.000 ms): <sinCos+140>
lib/std/math.ci:299:[.03ca7f, .03ca87) exec(0), time(0 / 0.000 ms): <sinCos+143>
lib/std/math.ci:300:[.03ca87, .03ca8e) exec(0), time(0 / 0.000 ms): <sinCos+151>
lib/std/math.ci:301:[.03ca8e, .03ca94) exec(0), time(0 / 0.000 ms): <sinCos+158>
lib/std/math.ci:288:[.03ca1c, .03ca98) exec(0), time(0 / 0.000 ms): <sinCos+44>
lib/std/math.ci:304:[.03caa0, .03caae) exec(0), time(0 / 0.000 ms): <sinCos+176>
lib/std/math.ci:303:[.03ca98, .03caae) exec(0), time(0 / 0.000 ms): <sinCos+168>
lib/std/math.ci:307:[.03caba, .03cabb) exec(0), time(0 / 0.000 ms): <sinCos+202>
lib/std/math.ci:306:[.03caae, .03cabb) exec(0), time(0 / 0.000 ms): <sinCos+190>
lib/std/math.ci:310:[.03cabb, .03cac0) exec(0), time(0 / 0.000 ms): <sinCos+203>
lib/std/math.ci:311:[.03cac0, .03cb00) exec(0), time(0 / 0.000 ms): <sinCos+208>
lib/std/math.ci:312:[.03cb00, .03cb33) exec(0), time(0 / 0.000 ms): <sinCos+272>
lib/std/math.ci:313:[.03cb33, .03cb3f) exec(0), time(0 / 0.000 ms): <sinCos+323>
lib/std/math.ci:336:[.03cb48, .03cb49) exec(0), time(0 / 0.000 ms): <tan+0>
lib/std/math.ci:337:[.03cb49, .03cb4a) exec(0), time(0 / 0.000 ms): <tan+1>
lib/std/math.ci:340:[.03cb52, .03cb57) exec(0), time(0 / 0.000 ms): <tan+10>
lib/std/math.ci:341:[.03cb57, .03cb61) exec(0), time(0 / 0.000 ms): <tan+15>
lib/std/math.ci:339:[.03cb4a, .03cb61) exec(0), time(0 / 0.000 ms): <tan+2>
lib/std/math.ci:343:[.03cb61, .03cb79) exec(0), time(0 / 0.000 ms): <tan+25>
lib/std/math.ci:345:[.03cb79, .03cb7a) exec(0), time(0 / 0.000 ms): <tan+49>
lib/std/math.ci:346:[.03cb7a, .03cb8a) exec(0), time(0 / 0.000 ms): <tan+50>
lib/std/math.ci:347:[.03cb8a, .03cb93) exec(0), time(0 / 0.000 ms): <tan+66>
lib/std/math.ci:351:[.03cba7, .03cbb5) exec(0), time(0 / 0.000 ms): <tan+95>
lib/std/math.ci:352:[.03cbb5, .03cbbf) exec(0), time(0 / 0.000 ms): <tan+109>
lib/std/math.ci:355:[.03cbcf, .03cbda) exec(0), time(0 / 0.000 ms): <tan+135>
lib/std/math.ci:356:[.03cbda, .03cbe4) exec(0), time(0 / 0.000 ms): <tan+146>
lib/std/math.ci:359:[.03cbf4, .03cc02) exec(0), time(0 / 0.000 ms): <tan+172>
lib/std/math.ci:360:[.03cc02, .03cc0d) exec(0), time(0 / 0.000 ms): <tan+186>
lib/std/math.ci:358:[.03cbe8, .03cc0d) exec(0), time(0 / 0.000 ms): <tan+160>
lib/std/math.ci:354:[.03cbc3, .03cc0d) exec(0), time(0 / 0.000 ms): <tan+123>
lib/std/math.ci:350:[.03cb9b, .03cc0d) exec(0), time(0 / 0.000 ms): <tan+83>
lib/std/math.ci:349:[.03cb93, .03cc0d) exec(0), time(0 / 0.000 ms): <tan+75>
lib/std/math.ci:363:[.03cc0d, .03cc12) exec(0), time(0 / 0.000 ms): <tan+197>
lib/std/math.ci:364:[.03cc12, .03cc52) exec(0), time(0 / 0.000 ms): <tan+202>
lib/std/math.ci:365:[.03cc52, .03cc79) exec(0), time(0 / 0.000 ms): <tan+266>
lib/std/math.ci:369:[.03cc8a, .03cc93) exec(0), time(0 / 0.000 ms): <tan+322>
lib/std/math.ci:368:[.03cc82, .03cc93) exec(0), time(0 / 0.000 ms): <tan+314>
lib/std/math.ci:371:[.03cc93, .03cca1) exec(0), time(0 / 0.000 ms): <tan+331>
lib/std/math.ci:367:[.03cc79, .03cca1) exec(0), time(0 / 0.000 ms): <tan+305>
lib/std/math.ci:374:[.03ccaa, .03ccb4) exec(0), time(0 / 0.000 ms): <tan+354>
lib/std/math.ci:373:[.03cca1, .03ccb4) exec(0), time(0 / 0.000 ms): <tan+345>
lib/std/math.ci:376:[.03ccb4, .03ccbb) exec(0), time(0 / 0.000 ms): <tan+364>
lib/std/math.ci:392:[.03ccc0, .03ccc1) exec(0), time(0 / 0.000 ms): <sinh+0>
lib/std/math.ci:394:[.03ccc9, .03ccce) exec(0), time(0 / 0.000 ms): <sinh+9>
lib/std/math.ci:395:[.03ccce, .03ccd8) exec(0), time(0 / 0.000 ms): <sinh+14>
lib/std/math.ci:393:[.03ccc1, .03ccd8) exec(0), time(0 / 0.000 ms): <sinh+1>
lib/std/math.ci:399:[.03cce8, .03ccff) exec(0), time(0 / 0.000 ms): <sinh+40>
lib/std/math.ci:398:[.03ccd8, .03ccff) exec(0), time(0 / 0.000 ms): <sinh+24>
lib/std/math.ci:402:[.03ccff, .03cd00) exec(0), time(0 / 0.000 ms): <sinh+63>
lib/std/math.ci:404:[.03cd10, .03cd2a) exec(0), time(0 / 0.000 ms): <sinh+80>
lib/std/math.ci:407:[.03cd2e, .03cd33) exec(0), time(0 / 0.000 ms): <sinh+110>
lib/std/math.ci:408:[.03cd33, .03cd68) exec(0), time(0 / 0.000 ms): <sinh+115>
lib/std/math.ci:409:[.03cd68, .03cd93) exec(0), time(0 / 0.000 ms): <sinh+168>
lib/std/math.ci:403:[.03cd00, .03cd97) exec(0), time(0 / 0.000 ms): <sinh+64>
lib/std/math.ci:413:[.03cda0, .03cdaa) exec(0), time(0 / 0.000 ms): <sinh+224>
lib/std/math.ci:412:[.03cd97, .03cdaa) exec(0), time(0 / 0.000 ms): <sinh+215>
lib/std/math.ci:415:[.03cdaa, .03cdb1) exec(0), time(0 / 0.000 ms): <sinh+234>
lib/std/math.ci:421:[.03cdc0, .03cdc5) exec(0), time(0 / 0.000 ms): <cosh+8>
lib/std/math.ci:420:[.03cdb8, .03cdc5) exec(0), time(0 / 0.000 ms): <cosh+0>
lib/std/math.ci:424:[.03cdd5, .03cde8) exec(0), time(0 / 0.000 ms): <cosh+29>
lib/std/math.ci:423:[.03cdc5, .03cde8) exec(0), time(0 / 0.000 ms): <cosh+13>
lib/std/math.ci:426:[.03cde8, .03ce03) exec(0), time(0 / 0.000 ms): <cosh+48>
lib/std/math.ci:438:[.03ce10, .03ce14) exec(0), time(0 / 0.000 ms): <asin+8>
lib/std/math.ci:436:[.03ce08, .03ce14) exec(0), time(0 / 0.000 ms): <asin+0>
lib/std/math.ci:441:[.03ce14, .03ce15) exec(0), time(0 / 0.000 ms): <asin+12>
lib/std/math.ci:443:[.03ce1d, .03ce27) exec(0), time(0 / 0.000 ms): <asin+21>
lib/std/math.ci:444:[.03ce27, .03ce2c) exec(0), time(0 / 0.000 ms): <asin+31>
lib/std/math.ci:442:[.03ce15, .03ce2c) exec(0), time(0 / 0.000 ms): <asin+13>
lib/std/math.ci:449:[.03ce3c, .03ce45) exec(0), time(0 / 0.000 ms): <asin+52>
lib/std/math.ci:447:[.03ce2c, .03ce45) exec(0), time(0 / 0.000 ms): <asin+36>
lib/std/math.ci:452:[.03ce45, .03ce58) exec(0), time(0 / 0.000 ms): <asin+61>
lib/std/math.ci:454:[.03ce68, .03ce86) exec(0), time(0 / 0.000 ms): <asin+96>
lib/std/math.ci:457:[.03ce8a, .03ce94) exec(0), time(0 / 0.000 ms): <asin+130>
lib/std/math.ci:453:[.03ce58, .03ce94) exec(0), time(0 / 0.000 ms): <asin+80>
lib/std/math.ci:461:[.03ce9d, .03cea7) exec(0), time(0 / 0.000 ms): <asin+149>
lib/std/math.ci:460:[.03ce94, .03cea7) exec(0), time(0 / 0.000 ms): <asin+140>
lib/std/math.ci:463:[.03cea7, .03ceae) exec(0), time(0 / 0.000 ms): <asin+159>
::[.03cebb, .03cebe) exec(0), time(0 / 0.000 ms): <Complex+3>
lib/std/math.Complex.ci:21:[.03ceb8, .03cebf) exec(0), time(0 / 0.000 ms): <Complex+0>
lib/std/math.Complex.ci:28:[.03cec3, .03cec6) exec(0), time(0 / 0.000 ms): <Complex+3>
lib/std/math.Complex.ci:26:[.03cec0, .03cec7) exec(0), time(0 / 0.000 ms): <Complex+0>
lib/std/math.Complex.ci:71:[.03cee7, .03ceec) exec(0), time(0 / 0.000 ms): <div+31>
lib/std/math.Complex.ci:72:[.03ceec, .03cef4) exec(0), time(0 / 0.000 ms): <div+36>
lib/std/math.Complex.ci:75:[.03cf01, .03cf0e) exec(0), time(0 / 0.000 ms): <div+57>
lib/std/math.Complex.ci:73:[.03cef4, .03cf13) exec(0), time(0 / 0.000 ms): <div+44>
lib/std/math.Complex.ci:70:[.03cec8, .03cf17) exec(0), time(0 / 0.000 ms): <div+0>
lib/std/math.Complex.ci:78:[.03cf17, .03cf1c) exec(0), time(0 / 0.000 ms): <div+79>
lib/std/math.Complex.ci:79:[.03cf1c, .03cf24) exec(0), time(0 / 0.000 ms): <div+84>
lib/std/math.Complex.ci:82:[.03cf31, .03cf3e) exec(0), time(0 / 0.000 ms): <div+105>
lib/std/math.Complex.ci:80:[.03cf24, .03cf43) exec(0), time(0 / 0.000 ms): <div+92>
lib/std/math.Complex.ci:94:[.03cf48, .03cf53) exec(0), time(0 / 0.000 ms): <inv+0>
lib/std/math.Complex.ci:97:[.03cf5a, .03cf62) exec(0), time(0 / 0.000 ms): <inv+18>
lib/std/math.Complex.ci:95:[.03cf53, .03cf67) exec(0), time(0 / 0.000 ms): <inv+11>
lib/std/math.Complex.ci:108:[.03cf70, .03cf87) exec(0), time(0 / 0.000 ms): <pow+0>
lib/std/math.Complex.ci:109:[.03cf87, .03cf97) exec(0), time(0 / 0.000 ms): <pow+23>
lib/std/math.Complex.ci:110:[.03cf97, .03cfa6) exec(0), time(0 / 0.000 ms): <pow+39>
lib/std/math.Complex.ci:111:[.03cfa6, .03cfb9) exec(0), time(0 / 0.000 ms): <pow+54>
lib/std/math.Complex.ci:114:[.03cfc4, .03cfcf) exec(0), time(0 / 0.000 ms): <pow+84>
lib/std/math.Complex.ci:112:[.03cfb9, .03cfd4) exec(0), time(0 / 0.000 ms): <pow+73>
lib/std/string.ci:5:[.03cfec, .03cff0) exec(0), time(0 / 0.000 ms): <length+12>
lib/std/string.ci:4:[.03cfe0, .03cff0) exec(0), time(0 / 0.000 ms): <length+0>
lib/std/string.ci:7:[.03cff0, .03cff1) exec(0), time(0 / 0.000 ms): <length+16>
lib/std/string.ci:8:[.03cff5, .03cff9) exec(0), time(0 / 0.000 ms): <length+21>
lib/std/string.ci:8:[.03cff9, .03d003) exec(0), time(0 / 0.000 ms): <length+25>
lib/std/string.ci:8:[.03cff1, .03d003) exec(0), time(0 / 0.000 ms): <length+17>
lib/std/string.ci:10:[.03d003, .03d006) exec(0), time(0 / 0.000 ms): <length+35>
lib/std/string.ci:17:[.03d025, .03d028) exec(0), time(0 / 0.000 ms): <indexOf+21>
lib/std/string.ci:16:[.03d015, .03d028) exec(0), time(0 / 0.000 ms): <indexOf+5>
lib/std/string.ci:15:[.03d028, .03d02c) exec(0), time(0 / 0.000 ms): <indexOf+24>
lib/std/string.ci:15:[.03d02c, .03d036) exec(0), time(0 / 0.000 ms): <indexOf+28>
lib/std/string.ci:15:[.03d010, .03d03a) exec(0), time(0 / 0.000 ms): <indexOf+0>
lib/std/string.ci:20:[.03d03a, .03d042) exec(0), time(0 / 0.000 ms): <indexOf+42>
lib/std/string.ci:25:[.03d048, .03d04d) exec(0), time(0 / 0.000 ms): <lastIndexOf+0>
lib/std/string.ci:28:[.03d062, .03d065) exec(0), time(0 / 0.000 ms): <lastIndexOf+26>
lib/std/string.ci:27:[.03d052, .03d065) exec(0), time(0 / 0.000 ms): <lastIndexOf+10>
lib/std/string.ci:26:[.03d065, .03d069) exec(0), time(0 / 0.000 ms): <lastIndexOf+29>
lib/std/string.ci:26:[.03d069, .03d073) exec(0), time(0 / 0.000 ms): <lastIndexOf+33>
lib/std/string.ci:26:[.03d04d, .03d077) exec(0), time(0 / 0.000 ms): <lastIndexOf+5>
lib/std/string.ci:31:[.03d077, .03d07a) exec(0), time(0 / 0.000 ms): <lastIndexOf+47>
lib/std/string.ci:38:[.03d09f, .03d0aa) exec(0), time(0 / 0.000 ms): <startsWith+31>
lib/std/string.ci:37:[.03d085, .03d0aa) exec(0), time(0 / 0.000 ms): <startsWith+5>
lib/std/string.ci:36:[.03d0aa, .03d0ae) exec(0), time(0 / 0.000 ms): <startsWith+42>
lib/std/string.ci:36:[.03d0ae, .03d0ba) exec(0), time(0 / 0.000 ms): <startsWith+46>
lib/std/string.ci:36:[.03d080, .03d0be) exec(0), time(0 / 0.000 ms): <startsWith+0>
lib/std/string.ci:41:[.03d0be, .03d0c9) exec(0), time(0 / 0.000 ms): <startsWith+62>
lib/std/string.ci:45:[.03d0d0, .03d0dd) exec(0), time(0 / 0.000 ms): <endsWith+0>
lib/std/string.ci:46:[.03d0dd, .03d0ea) exec(0), time(0 / 0.000 ms): <endsWith+13>
lib/std/string.ci:48:[.03d0f3, .03d0fe) exec(0), time(0 / 0.000 ms): <endsWith+35>
lib/std/string.ci:47:[.03d0ea, .03d0fe) exec(0), time(0 / 0.000 ms): <endsWith+26>
lib/std/string.ci:52:[.03d123, .03d12e) exec(0), time(0 / 0.000 ms): <endsWith+83>
lib/std/string.ci:51:[.03d103, .03d12e) exec(0), time(0 / 0.000 ms): <endsWith+51>
lib/std/string.ci:50:[.03d12e, .03d132) exec(0), time(0 / 0.000 ms): <endsWith+94>
lib/std/string.ci:50:[.03d132, .03d13b) exec(0), time(0 / 0.000 ms): <endsWith+98>
lib/std/string.ci:50:[.03d0fe, .03d13f) exec(0), time(0 / 0.000 ms): <endsWith+46>
lib/std/string.ci:55:[.03d13f, .03d14e) exec(0), time(0 / 0.000 ms): <endsWith+111>
lib/std/string.ci:59:[.03d158, .03d159) exec(0), time(0 / 0.000 ms): <compare+0>
lib/std/string.ci:61:[.03d15e, .03d174) exec(0), time(0 / 0.000 ms): <compare+6>
lib/std/string.ci:63:[.03d180, .03d184) exec(0), time(0 / 0.000 ms): <compare+40>
lib/std/string.ci:62:[.03d174, .03d184) exec(0), time(0 / 0.000 ms): <compare+28>
lib/std/string.ci:60:[.03d184, .03d188) exec(0), time(0 / 0.000 ms): <compare+44>
lib/std/string.ci:60:[.03d188, .03d190) exec(0), time(0 / 0.000 ms): <compare+48>
lib/std/string.ci:60:[.03d159, .03d194) exec(0), time(0 / 0.000 ms): <compare+1>
lib/std/string.ci:66:[.03d194, .03d197) exec(0), time(0 / 0.000 ms): <compare+60>
lib/std/string.ci:73:[.03d1af, .03d1ba) exec(0), time(0 / 0.000 ms): <ignCase+15>
lib/std/string.ci:72:[.03d1a0, .03d1ba) exec(0), time(0 / 0.000 ms): <ignCase+0>
lib/std/string.ci:76:[.03d1c9, .03d1d4) exec(0), time(0 / 0.000 ms): <ignCase+41>
lib/std/string.ci:75:[.03d1ba, .03d1d4) exec(0), time(0 / 0.000 ms): <ignCase+26>
lib/std/string.ci:78:[.03d1d4, .03d1e7) exec(0), time(0 / 0.000 ms): <ignCase+52>
lib/std/string.ci:81:[.03d1e8, .03d20c) exec(0), time(0 / 0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:85:[.03d210, .03d21e) exec(0), time(0 / 0.000 ms): <caseCmp+0>
lib/std/string.ci:116:[.03d22e, .03d232) exec(0), time(0 / 0.000 ms): <append+14>
lib/std/string.ci:115:[.03d225, .03d232) exec(0), time(0 / 0.000 ms): <append+5>
lib/std/string.ci:118:[.03d232, .03d23e) exec(0), time(0 / 0.000 ms): <append+18>
lib/std/string.ci:119:[.03d23e, .03d246) exec(0), time(0 / 0.000 ms): <append+30>
lib/std/string.ci:114:[.03d246, .03d24a) exec(0), time(0 / 0.000 ms): <append+38>
lib/std/string.ci:114:[.03d24a, .03d254) exec(0), time(0 / 0.000 ms): <append+42>
lib/std/string.ci:114:[.03d220, .03d258) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:123:[.03d261, .03d269) exec(0), time(0 / 0.000 ms): <append+65>
lib/std/string.ci:122:[.03d258, .03d269) exec(0), time(0 / 0.000 ms): <append+56>
lib/std/string.ci:125:[.03d269, .03d270) exec(0), time(0 / 0.000 ms): <append+73>
lib/std/string.ci:126:[.03d270, .03d274) exec(0), time(0 / 0.000 ms): <append+80>
lib/std/string.ci:133:[.03d288, .03d289) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:134:[.03d289, .03d28d) exec(0), time(0 / 0.000 ms): <append+1>
lib/std/string.ci:136:[.03d28d, .03d290) exec(0), time(0 / 0.000 ms): <append+5>
lib/std/string.ci:137:[.03d290, .03d2c6) exec(0), time(0 / 0.000 ms): <append+8>
lib/std/string.ci:138:[.03d2c6, .03d2fb) exec(0), time(0 / 0.000 ms): <append+62>
lib/std/string.ci:142:[.03d2ff, .03d31a) exec(0), time(0 / 0.000 ms): <append+119>
lib/std/string.ci:141:[.03d31a, .03d321) exec(0), time(0 / 0.000 ms): <append+146>
lib/std/string.ci:141:[.03d321, .03d329) exec(0), time(0 / 0.000 ms): <append+153>
lib/std/string.ci:141:[.03d2fb, .03d329) exec(0), time(0 / 0.000 ms): <append+115>
lib/std/string.ci:145:[.03d331, .03d346) exec(0), time(0 / 0.000 ms): <append+169>
lib/std/string.ci:144:[.03d329, .03d346) exec(0), time(0 / 0.000 ms): <append+161>
lib/std/string.ci:148:[.03d346, .03d350) exec(0), time(0 / 0.000 ms): <append+190>
lib/std/string.ci:150:[.03d350, .03d357) exec(0), time(0 / 0.000 ms): <append+200>
lib/std/string.ci:152:[.03d362, .03d36c) exec(0), time(0 / 0.000 ms): <append+218>
lib/std/string.ci:151:[.03d357, .03d36c) exec(0), time(0 / 0.000 ms): <append+207>
lib/std/string.ci:157:[.03d377, .03d37f) exec(0), time(0 / 0.000 ms): <append+239>
lib/std/string.ci:161:[.03d39d, .03d3d1) exec(0), time(0 / 0.000 ms): <append+277>
lib/std/string.ci:162:[.03d3d1, .03d3dc) exec(0), time(0 / 0.000 ms): <append+329>
lib/std/string.ci:163:[.03d3dc, .03d3e4) exec(0), time(0 / 0.000 ms): <append+340>
lib/std/string.ci:160:[.03d3e4, .03d3ec) exec(0), time(0 / 0.000 ms): <append+348>
lib/std/string.ci:160:[.03d3ec, .03d3f4) exec(0), time(0 / 0.000 ms): <append+356>
lib/std/string.ci:160:[.03d399, .03d3f4) exec(0), time(0 / 0.000 ms): <append+273>
lib/std/string.ci:158:[.03d37f, .03d3f4) exec(0), time(0 / 0.000 ms): <append+247>
lib/std/string.ci:166:[.03d3f4, .03d428) exec(0), time(0 / 0.000 ms): <append+364>
lib/std/string.ci:167:[.03d428, .03d433) exec(0), time(0 / 0.000 ms): <append+416>
lib/std/string.ci:168:[.03d433, .03d43b) exec(0), time(0 / 0.000 ms): <append+427>
lib/std/string.ci:156:[.03d36c, .03d43b) exec(0), time(0 / 0.000 ms): <append+228>
lib/std/string.ci:173:[.03d43f, .03d473) exec(0), time(0 / 0.000 ms): <append+439>
lib/std/string.ci:174:[.03d473, .03d47e) exec(0), time(0 / 0.000 ms): <append+491>
lib/std/string.ci:175:[.03d47e, .03d486) exec(0), time(0 / 0.000 ms): <append+502>
lib/std/string.ci:172:[.03d486, .03d48e) exec(0), time(0 / 0.000 ms): <append+510>
lib/std/string.ci:172:[.03d48e, .03d496) exec(0), time(0 / 0.000 ms): <append+518>
lib/std/string.ci:172:[.03d43b, .03d496) exec(0), time(0 / 0.000 ms): <append+435>
lib/std/string.ci:180:[.03d49b, .03d4cf) exec(0), time(0 / 0.000 ms): <append+531>
lib/std/string.ci:181:[.03d4cf, .03d4e0) exec(0), time(0 / 0.000 ms): <append+583>
lib/std/string.ci:182:[.03d4e0, .03d4e8) exec(0), time(0 / 0.000 ms): <append+600>
lib/std/string.ci:179:[.03d4e8, .03d4ec) exec(0), time(0 / 0.000 ms): <append+608>
lib/std/string.ci:179:[.03d4ec, .03d4f5) exec(0), time(0 / 0.000 ms): <append+612>
lib/std/string.ci:179:[.03d496, .03d4f9) exec(0), time(0 / 0.000 ms): <append+526>
lib/std/string.ci:186:[.03d502, .03d50a) exec(0), time(0 / 0.000 ms): <append+634>
lib/std/string.ci:185:[.03d4f9, .03d50a) exec(0), time(0 / 0.000 ms): <append+625>
lib/std/string.ci:188:[.03d50a, .03d511) exec(0), time(0 / 0.000 ms): <append+642>
lib/std/string.ci:189:[.03d511, .03d519) exec(0), time(0 / 0.000 ms): <append+649>
lib/std/string.ci:193:[.03d520, .03d537) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:197:[.03d538, .03d539) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:199:[.03d541, .03d548) exec(0), time(0 / 0.000 ms): <append+9>
lib/std/string.ci:200:[.03d548, .03d54d) exec(0), time(0 / 0.000 ms): <append+16>
lib/std/string.ci:198:[.03d539, .03d54d) exec(0), time(0 / 0.000 ms): <append+1>
lib/std/string.ci:202:[.03d54d, .03d569) exec(0), time(0 / 0.000 ms): <append+21>
lib/std/string.ci:207:[.03d580, .03d599) exec(0), time(0 / 0.000 ms): <append+0>
test/lang/function.ci:7:[.03d5b0, .03d5b8) exec(2), time(14-14 / 0.014-0.014 ms): <funAdd+0>
test/lang/function.ci:33:[.03d5b8, .03d5c0) exec(2), time(12-12 / 0.012-0.012 ms): <funMul+0>
test/lang/function.ci:39:[.03d5cc, .03d5d0) exec(377), time(2273-2273 / 2.273-2.273 ms): <fib+12>
test/lang/function.ci:38:[.03d5c0, .03d5d0) exec(753-377), time(362-362 / 0.362-0.362 ms): <fib+0>
test/lang/function.ci:41:[.03d5d0, .03d5f6) exec(376-375), time(11552-11552 / 11.552-11.552 ms): <fib+16>
test/stdc/tryExec.ci:15:[.03d600, .03d604) exec(64-1), time(28-28 / 0.028-0.028 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.03d604, .03d613) exec(63-63), time(0 / 0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.03d618, .03d61f) exec(1-1), time(0 / 0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.03d62c, .03d633) exec(1), time(0 / 0.000 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.03d633, .03d63a) exec(1), time(0 / 0.000 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.03d63a, .03d641) exec(1), time(0 / 0.000 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.03d628, .03d641) exec(1-1), time(0 / 0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.03d641, .03d667) exec(1-1), time(0 / 0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.03d670, .03d675) exec(1), time(0 / 0.000 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.03d675, .03d678) exec(1-1), time(0 / 0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.03d680, .03d682) exec(1-1), time(0 / 0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.03d688, .03d68c) exec(5), time(29-29 / 0.029-0.029 ms): <lenSlice+0>
test/lang/array.ci:104:[.03d690, .03d69c) exec(21), time(140-140 / 0.140-0.140 ms): <nthFixed+0>
test/lang/array.ci:105:[.03d6a0, .03d6ac) exec(21), time(135-135 / 0.135-0.135 ms): <nthArray+0>
test/lang/array.ci:106:[.03d6b0, .03d6bc) exec(14), time(96-96 / 0.096-0.096 ms): <nthSlice+0>
test/lang/method.ci:7:[.03d6f0, .03d6f8) exec(0), time(0 / 0.000 ms): <staticMethod+0>
test/lang/method.ci:27:[.03d700, .03d708) exec(0), time(0 / 0.000 ms): <virtualMethod+0>
test/lang/method.ci:32:[.03d708, .03d710) exec(0), time(0 / 0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.03d710, .03d737) exec(3), time(261-261 / 0.261-0.261 ms): <print+0>
test/lang/method.ci:45:[.03d738, .03d75f) exec(2), time(165-165 / 0.165-0.165 ms): <printStatic+0>
test/lang/method.ci:50:[.03d760, .03d768) exec(0), time(0 / 0.000 ms): <globalFunction+0>
test/lang/method.ci:60:[.03d768, .03d78f) exec(1), time(88-88 / 0.088-0.088 ms): <customPrint+0>
test/lang/method.ci:76:[.03d790, .03d7b7) exec(2), time(168-168 / 0.168-0.168 ms): <print+0>
test/lang/method.ci:80:[.03d7b8, .03d7df) exec(1), time(83-83 / 0.083-0.083 ms): <printStatic+0>
lib/std/string.ci:130:[.03d7e0, .03d7ee) exec(1), time(1-1 / 0.001-0.001 ms): <.main+0>
lib/std/string.ci:131:[.03d7ee, .03d7fc) exec(1), time(1-1 / 0.001-0.001 ms): <.main+14>
::[.03d805, .03d80c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+37>
::[.03d80c, .03d811) exec(1), time(0 / 0.000 ms): <.main+44>
::[.03d811, .03d816) exec(1), time(0 / 0.000 ms): <.main+49>
lib/std/string.ci:206:[.03d7fc, .03d816) exec(1-1), time(0 / 0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.03d816, .03d823) exec(1), time(1-1 / 0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.03d823, .03d828) exec(1), time(1-1 / 0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.03d828, .03d831) exec(1), time(1-1 / 0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.03d831, .03d83a) exec(1), time(0 / 0.000 ms): <.main+81>
test/lang/member.ci:47:[.03d843, .03d84c) exec(1), time(0 / 0.000 ms): <.main+99>
test/lang/member.ci:47:[.03d83a, .03d84c) exec(1-1), time(0 / 0.000 ms): <.main+90>
test/lang/member.ci:50:[.03d855, .03d85e) exec(1), time(0 / 0.000 ms): <.main+117>
test/lang/member.ci:50:[.03d84c, .03d85e) exec(1-1), time(0 / 0.000 ms): <.main+108>
test/lang/method.ci:12:[.03d85e, .03d867) exec(1), time(0 / 0.000 ms): <.main+126>
test/lang/emit.ci:3:[.03d867, .03d868) exec(1), time(0 / 0.000 ms): <.main+135>
test/lang/emit.ci:4:[.03d868, .03d869) exec(1), time(0 / 0.000 ms): <.main+136>
test/lang/emit.ci:6:[.03d869, .03d86e) exec(1), time(0 / 0.000 ms): <.main+137>
test/lang/emit.ci:7:[.03d86e, .03d873) exec(1), time(0 / 0.000 ms): <.main+142>
test/lang/emit.ci:9:[.03d873, .03d878) exec(1), time(1-1 / 0.001-0.001 ms): <.main+147>
test/lang/emit.ci:10:[.03d878, .03d883) exec(1), time(1-1 / 0.001-0.001 ms): <.main+152>
test/lang/emit.ci:11:[.03d883, .03d89b) exec(1), time(32-32 / 0.032-0.032 ms): <.main+163>
test/lang/emit.ci:17:[.03d89b, .03d8a0) exec(1), time(0 / 0.000 ms): <.main+187>
test/lang/emit.ci:18:[.03d8a0, .03d8a6) exec(1), time(0 / 0.000 ms): <.main+192>
test/lang/emit.ci:19:[.03d8a6, .03d8b0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+198>
test/lang/emit.ci:20:[.03d8b0, .03d8b9) exec(1), time(0 / 0.000 ms): <.main+208>
test/lang/emit.ci:23:[.03d8b9, .03d8c3) exec(1), time(0 / 0.000 ms): <.main+217>
test/lang/inlineMacros.ci:10:[.03d8c3, .03d8c8) exec(1), time(0 / 0.000 ms): <.main+227>
test/lang/inlineMacros.ci:11:[.03d8c8, .03d8cd) exec(1), time(0 / 0.000 ms): <.main+232>
test/lang/inlineMacros.ci:12:[.03d8cd, .03d8d2) exec(1), time(0 / 0.000 ms): <.main+237>
test/lang/inlineMacros.ci:13:[.03d8d2, .03d8d7) exec(1), time(0 / 0.000 ms): <.main+242>
test/lang/inlineMacros.ci:15:[.03d8d7, .03d8d8) exec(1), time(0 / 0.000 ms): <.main+247>
test/lang/inlineMacros.ci:16:[.03d8d8, .03d8d9) exec(1), time(0 / 0.000 ms): <.main+248>
test/lang/inlineMacros.ci:17:[.03d8d9, .03d8da) exec(1), time(0 / 0.000 ms): <.main+249>
test/lang/inlineMacros.ci:19:[.03d8da, .03d8df) exec(1), time(0 / 0.000 ms): <.main+250>
test/lang/inlineMacros.ci:20:[.03d8df, .03d8e1) exec(1), time(0 / 0.000 ms): <.main+255>
test/lang/inlineMacros.ci:21:[.03d8e1, .03d8eb) exec(1), time(0 / 0.000 ms): <.main+257>
test/lang/inlineMacros.ci:23:[.03d8eb, .03d8f4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+267>
test/lang/inlineMacros.ci:24:[.03d8f4, .03d8f9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+276>
test/lang/inlineMacros.ci:25:[.03d8f9, .03d90a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+281>
test/lang/inlineMacros.ci:27:[.03d90a, .03d922) exec(1), time(2-2 / 0.002-0.002 ms): <.main+298>
test/lang/inlineMacros.ci:28:[.03d922, .03d934) exec(1), time(2-2 / 0.002-0.002 ms): <.main+322>
test/lang/inlineMacros.ci:29:[.03d934, .03d952) exec(1), time(2-2 / 0.002-0.002 ms): <.main+340>
test/lang/inlineMacros.ci:31:[.03d952, .03d973) exec(1), time(2-2 / 0.002-0.002 ms): <.main+370>
test/lang/inlineMacros.ci:32:[.03d973, .03d98e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+403>
test/lang/inlineMacros.ci:33:[.03d98e, .03d9b5) exec(1), time(3-3 / 0.003-0.003 ms): <.main+430>
test/lang/inlineMacros.ci:35:[.03d9b5, .03d9d6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+469>
test/lang/inlineMacros.ci:36:[.03d9d6, .03d9f1) exec(1), time(2-2 / 0.002-0.002 ms): <.main+502>
test/lang/inlineMacros.ci:37:[.03d9f1, .03da18) exec(1), time(3-3 / 0.003-0.003 ms): <.main+529>
test/lang/inlineMacros.ci:41:[.03da18, .03da2d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+568>
test/lang/inlineMacros.ci:42:[.03da2d, .03da3e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+589>
test/lang/inlineMacros.ci:43:[.03da3e, .03da49) exec(1), time(2-2 / 0.002-0.002 ms): <.main+606>
test/lang/inlineMacros.ci:44:[.03da49, .03da54) exec(1), time(1-1 / 0.001-0.001 ms): <.main+617>
test/lang/inlineMacros.ci:45:[.03da54, .03da73) exec(1), time(3-3 / 0.003-0.003 ms): <.main+628>
test/lang/inlineMacros.ci:46:[.03da73, .03da92) exec(1), time(2-2 / 0.002-0.002 ms): <.main+659>
test/lang/inlineMacros.ci:50:[.03da92, .03dad0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+690>
test/lang/inlineMacros.ci:51:[.03dad0, .03db0e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+752>
test/lang/inlineMacros.ci:52:[.03db0e, .03db40) exec(1), time(1-1 / 0.001-0.001 ms): <.main+814>
test/lang/inlineMacros.ci:53:[.03db40, .03db72) exec(1), time(4-4 / 0.004-0.004 ms): <.main+864>
test/lang/inlineMacros.ci:54:[.03db72, .03dbb8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+914>
test/lang/inlineMacros.ci:55:[.03dbb8, .03dbfe) exec(1), time(4-4 / 0.004-0.004 ms): <.main+984>
test/lang/inlineMacros.ci:59:[.03dbfe, .03dc57) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1054>
test/lang/inlineMacros.ci:60:[.03dc57, .03dcb0) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1143>
test/lang/inlineMacros.ci:61:[.03dcb0, .03dcfd) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1232>
test/lang/inlineMacros.ci:62:[.03dcfd, .03dd4a) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1309>
test/lang/inlineMacros.ci:63:[.03dd4a, .03ddab) exec(1), time(7-7 / 0.007-0.007 ms): <.main+1386>
test/lang/inlineMacros.ci:64:[.03ddab, .03de0c) exec(1), time(7-7 / 0.007-0.007 ms): <.main+1483>
test/lang/inlineMacros.ci:68:[.03de0c, .03de65) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1580>
test/lang/inlineMacros.ci:69:[.03de65, .03debe) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1669>
test/lang/inlineMacros.ci:70:[.03debe, .03df0b) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1758>
test/lang/inlineMacros.ci:71:[.03df0b, .03df58) exec(1), time(6-6 / 0.006-0.006 ms): <.main+1835>
test/lang/inlineMacros.ci:72:[.03df58, .03dfb9) exec(1), time(7-7 / 0.007-0.007 ms): <.main+1912>
test/lang/inlineMacros.ci:73:[.03dfb9, .03e01a) exec(1), time(7-7 / 0.007-0.007 ms): <.main+2009>
test/lang/overload.inline.ci:9:[.03e01a, .03e01f) exec(1), time(0 / 0.000 ms): <.main+2106>
test/lang/overload.inline.ci:10:[.03e01f, .03e024) exec(1), time(0 / 0.000 ms): <.main+2111>
test/lang/overload.inline.ci:11:[.03e024, .03e029) exec(1), time(0 / 0.000 ms): <.main+2116>
test/lang/overload.inline.ci:12:[.03e029, .03e02e) exec(1), time(0 / 0.000 ms): <.main+2121>
test/lang/overload.inline.ci:13:[.03e02e, .03e033) exec(1), time(0 / 0.000 ms): <.main+2126>
test/lang/overload.inline.ci:28:[.03e033, .03e03c) exec(1), time(0 / 0.000 ms): <.main+2131>
test/lang/overload.inline.ci:29:[.03e03c, .03e052) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2140>
test/lang/initByRef.ci:8:[.03e052, .03e057) exec(1), time(0 / 0.000 ms): <.main+2162>
test/lang/initByRef.ci:9:[.03e057, .03e05c) exec(1), time(0 / 0.000 ms): <.main+2167>
test/lang/initByRef.ci:10:[.03e05c, .03e066) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2172>
test/lang/initByRef.ci:12:[.03e066, .03e069) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2182>
test/lang/initByRef.ci:13:[.03e069, .03e06b) exec(1), time(0 / 0.000 ms): <.main+2185>
test/lang/initByRef.ci:14:[.03e06b, .03e06d) exec(1), time(0 / 0.000 ms): <.main+2187>
test/lang/initByRef.ci:16:[.03e06d, .03e072) exec(1), time(0 / 0.000 ms): <.main+2189>
test/lang/initByRef.ci:17:[.03e072, .03e077) exec(1), time(0 / 0.000 ms): <.main+2194>
test/lang/initByRef.ci:18:[.03e077, .03e081) exec(1), time(0 / 0.000 ms): <.main+2199>
test/lang/initByRef.ci:19:[.03e081, .03e086) exec(1), time(0 / 0.000 ms): <.main+2209>
test/lang/initByRef.ci:20:[.03e086, .03e08b) exec(1), time(0 / 0.000 ms): <.main+2214>
test/lang/initByRef.ci:21:[.03e08b, .03e090) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2219>
test/lang/initByRef.ci:23:[.03e090, .03e095) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2224>
test/lang/initByRef.ci:24:[.03e095, .03e09f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2229>
test/lang/initByRef.ci:25:[.03e09f, .03e0a4) exec(1), time(0 / 0.000 ms): <.main+2239>
test/lang/initByRef.ci:27:[.03e0a4, .03e0a8) exec(1), time(0 / 0.000 ms): <.main+2244>
test/lang/initByRef.ci:28:[.03e0a8, .03e0aa) exec(1), time(0 / 0.000 ms): <.main+2248>
test/lang/initByRef.ci:29:[.03e0aa, .03e0ac) exec(1), time(0 / 0.000 ms): <.main+2250>
test/lang/initByRef.ci:30:[.03e0ac, .03e0ae) exec(1), time(0 / 0.000 ms): <.main+2252>
test/lang/initByRef.ci:31:[.03e0ae, .03e0b0) exec(1), time(0 / 0.000 ms): <.main+2254>
test/lang/initByRef.ci:32:[.03e0b0, .03e0b2) exec(1), time(0 / 0.000 ms): <.main+2256>
test/lang/initByRef.ci:35:[.03e0b2, .03e0b7) exec(1), time(0 / 0.000 ms): <.main+2258>
test/lang/initByRef.ci:36:[.03e0b7, .03e0bc) exec(1), time(0 / 0.000 ms): <.main+2263>
test/lang/initByRef.ci:37:[.03e0bc, .03e0c1) exec(1), time(0 / 0.000 ms): <.main+2268>
test/lang/initByRef.ci:38:[.03e0c1, .03e0c6) exec(1), time(0 / 0.000 ms): <.main+2273>
test/lang/initByRef.ci:39:[.03e0c6, .03e0cb) exec(1), time(0 / 0.000 ms): <.main+2278>
test/lang/initByRef.ci:40:[.03e0cb, .03e0d0) exec(1), time(0 / 0.000 ms): <.main+2283>
test/lang/initByRef.ci:41:[.03e0d0, .03e0d5) exec(1), time(0 / 0.000 ms): <.main+2288>
test/lang/initByRef.ci:42:[.03e0d5, .03e0da) exec(1), time(0 / 0.000 ms): <.main+2293>
test/lang/initByRef.ci:43:[.03e0da, .03e0df) exec(1), time(0 / 0.000 ms): <.main+2298>
test/lang/initByRef.ci:44:[.03e0df, .03e0e4) exec(1), time(0 / 0.000 ms): <.main+2303>
test/lang/initByRef.ci:45:[.03e0e4, .03e0e9) exec(1), time(0 / 0.000 ms): <.main+2308>
test/lang/initByRef.ci:46:[.03e0e9, .03e0ee) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2313>
test/lang/initByRef.ci:47:[.03e0ee, .03e0f3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2318>
test/lang/initByRef.ci:48:[.03e0f3, .03e0f8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2323>
test/lang/initByRef.ci:49:[.03e0f8, .03e0fd) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2328>
test/lang/initByRef.ci:50:[.03e0fd, .03e102) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2333>
test/lang/initByRef.ci:51:[.03e102, .03e107) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2338>
test/lang/initByRef.ci:52:[.03e107, .03e10c) exec(1), time(0 / 0.000 ms): <.main+2343>
test/lang/initByRef.ci:55:[.03e10c, .03e116) exec(1), time(0 / 0.000 ms): <.main+2348>
test/lang/initByRef.ci:56:[.03e116, .03e120) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2358>
test/lang/initByRef.ci:57:[.03e120, .03e12a) exec(1), time(0 / 0.000 ms): <.main+2368>
test/lang/initByRef.ci:58:[.03e12a, .03e134) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2378>
test/lang/initByRef.ci:59:[.03e134, .03e13e) exec(1), time(0 / 0.000 ms): <.main+2388>
test/lang/initByRef.ci:60:[.03e13e, .03e148) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2398>
test/lang/initByRef.ci:61:[.03e148, .03e152) exec(1), time(0 / 0.000 ms): <.main+2408>
test/lang/initByRef.ci:62:[.03e152, .03e15c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2418>
test/lang/initByRef.ci:63:[.03e15c, .03e166) exec(1), time(0 / 0.000 ms): <.main+2428>
test/lang/initByRef.ci:64:[.03e166, .03e170) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2438>
test/lang/initByRef.ci:65:[.03e170, .03e17a) exec(1), time(0 / 0.000 ms): <.main+2448>
test/lang/initByRef.ci:66:[.03e17a, .03e184) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2458>
test/lang/initByRef.ci:67:[.03e184, .03e18e) exec(1), time(0 / 0.000 ms): <.main+2468>
test/lang/initByRef.ci:68:[.03e18e, .03e198) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2478>
test/lang/initByRef.ci:69:[.03e198, .03e1a2) exec(1), time(0 / 0.000 ms): <.main+2488>
test/lang/initByRef.ci:70:[.03e1a2, .03e1ac) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2498>
test/lang/initByRef.ci:71:[.03e1ac, .03e1b6) exec(1), time(0 / 0.000 ms): <.main+2508>
test/lang/initByRef.ci:72:[.03e1b6, .03e1c0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2518>
test/lang/initByRef.ci:75:[.03e1c0, .03e1c5) exec(1), time(0 / 0.000 ms): <.main+2528>
test/lang/initByRef.ci:76:[.03e1c5, .03e1ca) exec(1), time(0 / 0.000 ms): <.main+2533>
test/lang/initByRef.ci:77:[.03e1ca, .03e1cf) exec(1), time(0 / 0.000 ms): <.main+2538>
test/lang/initByRef.ci:78:[.03e1cf, .03e1d4) exec(1), time(0 / 0.000 ms): <.main+2543>
test/lang/initByRef.ci:79:[.03e1d4, .03e1d9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2548>
test/lang/initByRef.ci:80:[.03e1d9, .03e1de) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2553>
test/lang/initByRef.ci:81:[.03e1de, .03e1e3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2558>
test/lang/initByRef.ci:82:[.03e1e3, .03e1e8) exec(1), time(0 / 0.000 ms): <.main+2563>
test/lang/initByRef.ci:83:[.03e1e8, .03e1ed) exec(1), time(0 / 0.000 ms): <.main+2568>
test/lang/initByRef.ci:84:[.03e1ed, .03e1f2) exec(1), time(0 / 0.000 ms): <.main+2573>
test/lang/initByRef.ci:85:[.03e1f2, .03e1f7) exec(1), time(0 / 0.000 ms): <.main+2578>
test/lang/initByRef.ci:86:[.03e1f7, .03e1fc) exec(1), time(0 / 0.000 ms): <.main+2583>
test/lang/initByRef.ci:87:[.03e1fc, .03e201) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2588>
test/lang/initByRef.ci:88:[.03e201, .03e206) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2593>
test/lang/initByRef.ci:89:[.03e206, .03e20b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2598>
test/lang/initByRef.ci:90:[.03e20b, .03e210) exec(1), time(0 / 0.000 ms): <.main+2603>
test/lang/initByRef.ci:91:[.03e210, .03e215) exec(1), time(0 / 0.000 ms): <.main+2608>
test/lang/initByRef.ci:92:[.03e215, .03e21a) exec(1), time(0 / 0.000 ms): <.main+2613>
test/lang/initByRef.ci:95:[.03e21a, .03e21f) exec(1), time(0 / 0.000 ms): <.main+2618>
test/lang/initByRef.ci:96:[.03e21f, .03e229) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2623>
test/lang/initByRef.ci:97:[.03e229, .03e22e) exec(1), time(0 / 0.000 ms): <.main+2633>
test/lang/initByRef.ci:99:[.03e22e, .03e233) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2638>
test/lang/initByRef.ci:105:[.03e233, .03e23a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2643>
test/lang/initByRef.ci:108:[.03e23a, .03e23c) exec(1), time(0 / 0.000 ms): <.main+2650>
test/lang/function.ci:11:[.03e23c, .03e251) exec(1), time(18-18 / 0.018-0.018 ms): <.main+2652>
test/lang/function.ci:14:[.03e251, .03e256) exec(1), time(0 / 0.000 ms): <.main+2673>
test/lang/function.ci:17:[.03e256, .03e268) exec(1), time(17-17 / 0.017-0.017 ms): <.main+2678>
test/lang/function.ci:20:[.03e268, .03e26d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2696>
test/lang/function.ci:23:[.03e26d, .03e27f) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2701>
test/lang/function.ci:26:[.03e27f, .03e281) exec(1), time(0 / 0.000 ms): <.main+2719>
test/lang/function.ci:29:[.03e281, .03e293) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2721>
test/lang/function.ci:45:[.03e293, .03e2a3) exec(1), time(11564-11564 / 11.564-11.564 ms): <.main+2739>
test/lang/reflect.ci:3:[.03e2a3, .03e2a7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2755>
test/lang/reflect.ci:4:[.03e2a7, .03e2ab) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2759>
test/lang/reflect.ci:5:[.03e2ab, .03e2af) exec(1), time(0 / 0.000 ms): <.main+2763>
test/lang/reflect.ci:6:[.03e2af, .03e2b3) exec(1), time(0 / 0.000 ms): <.main+2767>
test/lang/reflect.ci:7:[.03e2b3, .03e2b7) exec(1), time(0 / 0.000 ms): <.main+2771>
test/lang/reflect.ci:8:[.03e2b7, .03e2bb) exec(1), time(0 / 0.000 ms): <.main+2775>
test/lang/reflect.ci:9:[.03e2bb, .03e2bf) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2779>
test/lang/reflect.ci:10:[.03e2bf, .03e2c3) exec(1), time(0 / 0.000 ms): <.main+2783>
test/lang/reflect.ci:11:[.03e2c3, .03e2c7) exec(1), time(0 / 0.000 ms): <.main+2787>
test/lang/reflect.ci:12:[.03e2c7, .03e2cb) exec(1), time(0 / 0.000 ms): <.main+2791>
test/lang/reflect.ci:13:[.03e2cb, .03e2cf) exec(1), time(0 / 0.000 ms): <.main+2795>
test/lang/reflect.ci:14:[.03e2cf, .03e2d3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2799>
test/lang/reflect.ci:15:[.03e2d3, .03e2d7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2803>
test/lang/reflect.ci:16:[.03e2d7, .03e2db) exec(1), time(0 / 0.000 ms): <.main+2807>
test/lang/reflect.ci:17:[.03e2db, .03e2df) exec(1), time(0 / 0.000 ms): <.main+2811>
test/lang/reflect.ci:18:[.03e2df, .03e2e3) exec(1), time(0 / 0.000 ms): <.main+2815>
test/lang/reflect.ci:19:[.03e2e3, .03e2e7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2819>
test/lang/reflect.ci:20:[.03e2e7, .03e2eb) exec(1), time(0 / 0.000 ms): <.main+2823>
test/lang/reflect.ci:30:[.03e2eb, .03e2f0) exec(1), time(0 / 0.000 ms): <.main+2827>
test/lang/reflect.ci:31:[.03e2f0, .03e2f6) exec(1), time(22-22 / 0.022-0.022 ms): <.main+2832>
test/lang/reflect.ci:32:[.03e2f6, .03e2fd) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2838>
test/lang/reflect.ci:33:[.03e2fd, .03e304) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2845>
test/lang/reflect.ci:34:[.03e304, .03e30a) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2852>
test/lang/reflect.ci:35:[.03e30a, .03e310) exec(1), time(15-15 / 0.015-0.015 ms): <.main+2858>
test/lang/reflect.ci:37:[.03e310, .03e316) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2864>
test/lang/reflect.ci:38:[.03e316, .03e31c) exec(1), time(15-15 / 0.015-0.015 ms): <.main+2870>
test/lang/reflect.ci:39:[.03e31c, .03e323) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2876>
test/lang/reflect.ci:40:[.03e323, .03e32a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2883>
test/lang/reflect.ci:41:[.03e32a, .03e330) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2890>
test/lang/reflect.ci:42:[.03e330, .03e336) exec(1), time(17-17 / 0.017-0.017 ms): <.main+2896>
test/lang/reflect.ci:44:[.03e336, .03e33c) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2902>
test/lang/reflect.ci:45:[.03e33c, .03e343) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2908>
test/lang/reflect.ci:46:[.03e343, .03e34a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2915>
test/lang/reflect.ci:48:[.03e34a, .03e350) exec(1), time(15-15 / 0.015-0.015 ms): <.main+2922>
test/lang/reflect.ci:49:[.03e350, .03e357) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2928>
test/lang/reflect.ci:50:[.03e357, .03e35e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2935>
test/stdc/number.ci:3:[.03e35e, .03e367) exec(1), time(0 / 0.000 ms): <.main+2942>
test/stdc/number.ci:4:[.03e367, .03e370) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2951>
test/stdc/number.ci:6:[.03e370, .03e373) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2960>
test/stdc/number.ci:7:[.03e373, .03e376) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2963>
test/stdc/number.ci:14:[.03e376, .03e37d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2966>
test/stdc/number.ci:15:[.03e37d, .03e384) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2973>
test/stdc/number.ci:16:[.03e384, .03e38b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2980>
test/stdc/number.ci:18:[.03e38b, .03e3a7) exec(1), time(7-7 / 0.007-0.007 ms): <.main+2987>
test/stdc/number.ci:19:[.03e3a7, .03e3c1) exec(1), time(6-6 / 0.006-0.006 ms): <.main+3015>
test/stdc/number.ci:21:[.03e3c1, .03e3d1) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3041>
test/stdc/number.ci:22:[.03e3d1, .03e3e1) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3057>
test/stdc/number.ci:23:[.03e3e1, .03e3ed) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3073>
test/stdc/number.ci:25:[.03e3ed, .03e3fd) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3085>
test/stdc/number.ci:26:[.03e3fd, .03e40d) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3101>
test/stdc/number.ci:27:[.03e40d, .03e419) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3117>
test/stdc/number.ci:29:[.03e419, .03e429) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3129>
test/stdc/number.ci:30:[.03e429, .03e439) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3145>
test/stdc/number.ci:31:[.03e439, .03e445) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3161>
test/stdc/number.ci:33:[.03e445, .03e455) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3173>
test/stdc/number.ci:34:[.03e455, .03e465) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3189>
test/stdc/number.ci:35:[.03e465, .03e471) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3205>
test/stdc/number.ci:37:[.03e471, .03e481) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3217>
test/stdc/number.ci:38:[.03e481, .03e491) exec(1), time(20-20 / 0.020-0.020 ms): <.main+3233>
test/stdc/number.ci:39:[.03e491, .03e4a1) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3249>
test/stdc/number.ci:40:[.03e4a1, .03e4ad) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3265>
test/stdc/number.ci:41:[.03e4ad, .03e4ba) exec(1), time(15-15 / 0.015-0.015 ms): <.main+3277>
test/stdc/number.ci:42:[.03e4ba, .03e4cc) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3290>
test/stdc/number.ci:43:[.03e4cc, .03e4d5) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3308>
test/stdc/number.ci:44:[.03e4d5, .03e4e4) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3317>
test/stdc/number.ci:46:[.03e4e4, .03e4f0) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3332>
test/stdc/number.ci:47:[.03e4f0, .03e4fc) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3344>
test/stdc/number.ci:48:[.03e4fc, .03e508) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3356>
test/stdc/number.ci:49:[.03e508, .03e514) exec(1), time(18-18 / 0.018-0.018 ms): <.main+3368>
test/stdc/number.ci:50:[.03e514, .03e51d) exec(1), time(15-15 / 0.015-0.015 ms): <.main+3380>
test/stdc/number.ci:51:[.03e51d, .03e52b) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3389>
test/stdc/number.ci:52:[.03e52b, .03e534) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3403>
test/stdc/number.ci:53:[.03e534, .03e53f) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3412>
test/stdc/memory.ci:7:[.03e53f, .03e54d) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3423>
test/stdc/memory.ci:8:[.03e54d, .03e55b) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3437>
test/stdc/memory.ci:9:[.03e55b, .03e569) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3451>
test/stdc/memory.ci:10:[.03e569, .03e577) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3465>
test/stdc/memory.ci:13:[.03e577, .03e587) exec(1), time(18-18 / 0.018-0.018 ms): <.main+3479>
test/stdc/memory.ci:14:[.03e587, .03e598) exec(1), time(18-18 / 0.018-0.018 ms): <.main+3495>
test/stdc/memory.ci:17:[.03e598, .03e5a3) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3512>
test/stdc/memory.ci:18:[.03e5a3, .03e5ae) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3523>
test/stdc/memory.ci:19:[.03e5ae, .03e5b9) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3534>
test/stdc/memory.ci:20:[.03e5b9, .03e5c4) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3545>
test/stdc/memory.ci:23:[.03e5c4, .03e5cd) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3556>
test/stdc/memory.ci:24:[.03e5cd, .03e5d6) exec(1), time(0 / 0.000 ms): <.main+3565>
test/stdc/memory.ci:26:[.03e5d6, .03e5f8) exec(1), time(34-34 / 0.034-0.034 ms): <.main+3574>
test/stdc/memory.ci:27:[.03e5f8, .03e61a) exec(1), time(35-35 / 0.035-0.035 ms): <.main+3608>
test/stdc/memory.ci:29:[.03e61a, .03e62e) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3642>
test/stdc/memory.ci:30:[.03e62e, .03e63f) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3662>
test/stdc/memory.ci:32:[.03e63f, .03e661) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3679>
test/stdc/memory.ci:33:[.03e661, .03e683) exec(1), time(30-30 / 0.030-0.030 ms): <.main+3713>
test/stdc/tryExec.ci:46:[.03e683, .03e691) exec(1), time(48-48 / 0.048-0.048 ms): <.main+3747>
test/stdc/tryExec.ci:47:[.03e691, .03e69f) exec(1), time(20-20 / 0.020-0.020 ms): <.main+3761>
test/stdc/tryExec.ci:48:[.03e69f, .03e6ad) exec(1), time(968-968 / 0.968-0.968 ms): <.main+3775>
test/stdc/tryExec.ci:49:[.03e6ad, .03e6bb) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3789>
test/stdc/tryExec.ci:50:[.03e6bb, .03e6c9) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3803>
test/stdc/tryExec.ci:51:[.03e6c9, .03e6d7) exec(1), time(34-34 / 0.034-0.034 ms): <.main+3817>
test/stdc/tryExec.ci:52:[.03e6d7, .03e6e5) exec(1), time(129-129 / 0.129-0.129 ms): <.main+3831>
test/lang/array.ci:49:[.03e6e5, .03e6e9) exec(1), time(0 / 0.000 ms): <.main+3845>
test/lang/array.ci:50:[.03e6e9, .03e6ed) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3849>
test/lang/array.ci:51:[.03e6ed, .03e6f1) exec(1), time(0 / 0.000 ms): <.main+3853>
test/lang/array.ci:55:[.03e6f6, .03e70a) exec(7), time(30-30 / 0.030-0.030 ms): <.main+3862>
test/lang/array.ci:54:[.03e70a, .03e70e) exec(7), time(2-2 / 0.002-0.002 ms): <.main+3882>
test/lang/array.ci:54:[.03e70e, .03e71a) exec(8), time(19-19 / 0.019-0.019 ms): <.main+3886>
test/lang/array.ci:54:[.03e6f1, .03e71e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+3857>
test/lang/array.ci:59:[.03e71e, .03e723) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3902>
test/lang/array.ci:60:[.03e723, .03e729) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3907>
test/lang/array.ci:63:[.03e729, .03e72d) exec(1), time(0 / 0.000 ms): <.main+3913>
test/lang/array.ci:64:[.03e72d, .03e736) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3917>
test/lang/array.ci:67:[.03e736, .03e738) exec(1), time(0 / 0.000 ms): <.main+3926>
test/lang/array.ci:68:[.03e738, .03e73a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3928>
test/lang/array.ci:71:[.03e73a, .03e73c) exec(1), time(0 / 0.000 ms): <.main+3930>
test/lang/array.ci:81:[.03e73c, .03e740) exec(1), time(0 / 0.000 ms): <.main+3932>
test/lang/array.ci:82:[.03e740, .03e756) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3936>
test/lang/array.ci:83:[.03e756, .03e778) exec(1), time(79-79 / 0.079-0.079 ms): <.main+3958>
test/lang/array.ci:84:[.03e778, .03e79a) exec(1), time(78-78 / 0.078-0.078 ms): <.main+3992>
test/lang/array.ci:86:[.03e79a, .03e79f) exec(1), time(0 / 0.000 ms): <.main+4026>
test/lang/array.ci:87:[.03e79f, .03e7bf) exec(1), time(36-36 / 0.036-0.036 ms): <.main+4031>
test/lang/array.ci:88:[.03e7bf, .03e7df) exec(1), time(37-37 / 0.037-0.037 ms): <.main+4063>
test/lang/array.ci:90:[.03e7df, .03e7e9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+4095>
test/lang/array.ci:91:[.03e7e9, .03e809) exec(1), time(34-34 / 0.034-0.034 ms): <.main+4105>
test/lang/array.ci:92:[.03e809, .03e829) exec(1), time(35-35 / 0.035-0.035 ms): <.main+4137>
test/lang/array.ci:98:[.03e829, .03e85c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4169>
test/lang/array.ci:99:[.03e85c, .03e88f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+4220>
test/lang/array.ci:101:[.03e88f, .03e8ca) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4271>
test/lang/array.ci:108:[.03e8ca, .03e8e3) exec(1), time(18-18 / 0.018-0.018 ms): <.main+4330>
test/lang/array.ci:109:[.03e8e3, .03e8f9) exec(1), time(18-18 / 0.018-0.018 ms): <.main+4355>
test/lang/array.ci:110:[.03e8f9, .03e90f) exec(1), time(18-18 / 0.018-0.018 ms): <.main+4377>
test/lang/array.ci:112:[.03e90f, .03e92f) exec(1), time(36-36 / 0.036-0.036 ms): <.main+4399>
test/lang/array.ci:113:[.03e92f, .03e94c) exec(1), time(35-35 / 0.035-0.035 ms): <.main+4431>
test/lang/array.ci:114:[.03e94c, .03e974) exec(1), time(36-36 / 0.036-0.036 ms): <.main+4460>
test/lang/array.ci:115:[.03e974, .03e995) exec(1), time(35-35 / 0.035-0.035 ms): <.main+4500>
test/lang/array.ci:116:[.03e995, .03e9b6) exec(1), time(36-36 / 0.036-0.036 ms): <.main+4533>
test/lang/array.ci:119:[.03e9bb, .03e9c4) exec(7), time(16-16 / 0.016-0.016 ms): <.main+4571>
test/lang/array.ci:120:[.03e9c4, .03ea01) exec(7), time(35-35 / 0.035-0.035 ms): <.main+4580>
test/lang/array.ci:121:[.03ea01, .03ea3c) exec(7), time(31-31 / 0.031-0.031 ms): <.main+4641>
test/lang/array.ci:122:[.03ea3c, .03ea77) exec(7), time(34-34 / 0.034-0.034 ms): <.main+4700>
test/lang/array.ci:124:[.03ea77, .03eaba) exec(7), time(155-155 / 0.155-0.155 ms): <.main+4759>
test/lang/array.ci:125:[.03eaba, .03eafb) exec(7), time(155-155 / 0.155-0.155 ms): <.main+4826>
test/lang/array.ci:126:[.03eafb, .03eb3c) exec(7), time(153-153 / 0.153-0.153 ms): <.main+4891>
test/lang/array.ci:128:[.03eb3c, .03eb7f) exec(7), time(157-157 / 0.157-0.157 ms): <.main+4956>
test/lang/array.ci:129:[.03eb7f, .03ebc0) exec(7), time(154-154 / 0.154-0.154 ms): <.main+5023>
test/lang/array.ci:130:[.03ebc0, .03ec01) exec(7), time(156-156 / 0.156-0.156 ms): <.main+5088>
test/lang/array.ci:132:[.03ec01, .03ec49) exec(7), time(160-160 / 0.160-0.160 ms): <.main+5153>
test/lang/array.ci:134:[.03ec49, .03ec8a) exec(7), time(155-155 / 0.155-0.155 ms): <.main+5225>
test/lang/array.ci:136:[.03ec8a, .03ecc5) exec(7), time(35-35 / 0.035-0.035 ms): <.main+5290>
test/lang/array.ci:118:[.03ecc9, .03eccd) exec(7), time(3-3 / 0.003-0.003 ms): <.main+5353>
test/lang/array.ci:118:[.03eccd, .03ecd9) exec(8), time(17-17 / 0.017-0.017 ms): <.main+5357>
test/lang/array.ci:118:[.03e9b6, .03ecdd) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4566>
test/lang/member.ci:54:[.03ece1, .03ece8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5377>
test/lang/member.ci:55:[.03ece8, .03ecef) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5384>
test/lang/member.ci:56:[.03ecef, .03ecf6) exec(1), time(0 / 0.000 ms): <.main+5391>
test/lang/member.ci:57:[.03ecf6, .03ecfd) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5398>
test/lang/member.ci:60:[.03ecfd, .03ed04) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5405>
test/lang/member.ci:61:[.03ed04, .03ed0b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5412>
test/lang/member.ci:65:[.03ed0b, .03ed12) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5419>
test/lang/member.ci:66:[.03ed12, .03ed19) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5426>
test/lang/member.ci:53:[.03ecdd, .03ed19) exec(1-1), time(0 / 0.000 ms): <.main+5373>
test/lang/method.ci:54:[.03ed1d, .03ed24) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5437>
test/lang/method.ci:55:[.03ed24, .03ed2b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5444>
::[.03ed2b, .03ed32) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5451>
::[.03ed32, .03ed39) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5458>
test/lang/method.ci:53:[.03ed19, .03ed39) exec(1-1), time(0 / 0.000 ms): <.main+5433>
test/lang/method.ci:64:[.03ed3d, .03ed44) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5469>
test/lang/method.ci:65:[.03ed44, .03ed4b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5476>
::[.03ed4b, .03ed51) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5483>
::[.03ed51, .03ed58) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5489>
test/lang/method.ci:63:[.03ed39, .03ed58) exec(1-1), time(0 / 0.000 ms): <.main+5465>
test/lang/method.ci:69:[.03ed58, .03ed61) exec(1), time(103-103 / 0.103-0.103 ms): <.main+5496>
test/lang/method.ci:70:[.03ed61, .03ed6a) exec(1), time(106-106 / 0.106-0.106 ms): <.main+5505>
test/lang/method.ci:73:[.03ed6a, .03ed76) exec(1), time(101-101 / 0.101-0.101 ms): <.main+5514>
test/lang/method.ci:84:[.03ed76, .03ed82) exec(1), time(101-101 / 0.101-0.101 ms): <.main+5526>
test/lang/method.ci:85:[.03ed82, .03ed8e) exec(1), time(101-101 / 0.101-0.101 ms): <.main+5538>
test/lang/method.ci:86:[.03ed8e, .03ed9a) exec(1), time(104-104 / 0.104-0.104 ms): <.main+5550>
test/lang/method.ci:89:[.03ed9a, .03eda6) exec(1), time(113-113 / 0.113-0.113 ms): <.main+5562>
test/lang/method.ci:90:[.03eda6, .03edb2) exec(1), time(101-101 / 0.101-0.101 ms): <.main+5574>
test/lang/method.ci:91:[.03edb2, .03edbe) exec(1), time(101-101 / 0.101-0.101 ms): <.main+5586>
test/lang/recUnion.ci:26:[.03edc2, .03edc8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5602>
test/lang/recUnion.ci:26:[.03edc8, .03edce) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5608>
test/lang/recUnion.ci:26:[.03edce, .03edd4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5614>
test/lang/recUnion.ci:26:[.03edbe, .03edd4) exec(1-1), time(0 / 0.000 ms): <.main+5598>
test/lang/recUnion.ci:27:[.03edd8, .03edde) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5624>
test/lang/recUnion.ci:27:[.03edde, .03ede8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5630>
test/lang/recUnion.ci:27:[.03ede8, .03edee) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5640>
test/lang/recUnion.ci:27:[.03edd4, .03edee) exec(1-1), time(0 / 0.000 ms): <.main+5620>
test/lang/recUnion.ci:28:[.03edf2, .03edfc) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5650>
test/lang/recUnion.ci:28:[.03edfc, .03ee06) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5660>
test/lang/recUnion.ci:28:[.03ee06, .03ee10) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5670>
test/lang/recUnion.ci:28:[.03edee, .03ee10) exec(1-1), time(0 / 0.000 ms): <.main+5646>
test/lang/recUnion.ci:30:[.03ee14, .03ee1b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5684>
test/lang/recUnion.ci:30:[.03ee10, .03ee1b) exec(1-1), time(0 / 0.000 ms): <.main+5680>
test/lang/recUnion.ci:31:[.03ee1f, .03ee25) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5695>
test/lang/recUnion.ci:31:[.03ee25, .03ee2b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5701>
test/lang/recUnion.ci:31:[.03ee2b, .03ee35) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5707>
test/lang/recUnion.ci:31:[.03ee1b, .03ee35) exec(1-1), time(0 / 0.000 ms): <.main+5691>
test/lang/useOperator.ci:5:[.03ee35, .03ee3a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5717>
test/lang/useOperator.ci:7:[.03ee3a, .03ee3f) exec(1), time(0 / 0.000 ms): <.main+5722>
test/lang/useOperator.ci:8:[.03ee3f, .03ee44) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5727>
test/lang/useOperator.ci:17:[.03ee44, .03ee4f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5732>
test/lang/useOperator.ci:18:[.03ee4f, .03ee5a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5743>
test/lang/useOperator.ci:19:[.03ee5a, .03ee65) exec(1), time(6-6 / 0.006-0.006 ms): <.main+5754>
test/lang/useOperator.ci:22:[.03ee65, .03ee6b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5765>
test/lang/useOperator.ci:23:[.03ee6b, .03ee76) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5771>
test/lang/useOperator.ci:24:[.03ee76, .03ee82) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5782>
test/lang/useOperator.ci:25:[.03ee82, .03ee8d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5794>
test/lang/useOperator.ci:26:[.03ee8d, .03ee99) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5805>
test/lang/useOperator.ci:27:[.03ee99, .03eea4) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5817>
test/lang/useOperator.ci:28:[.03eea4, .03eeb0) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5828>
test/lang/useOperator.ci:30:[.03eeb0, .03eeb5) exec(1), time(0 / 0.000 ms): <.main+5840>
test/lang/useOperator.ci:31:[.03eeb5, .03eeba) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5845>
test/lang/useOperator.ci:32:[.03eeba, .03eebf) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5850>
test/lang/useOperator.ci:33:[.03eebf, .03eec5) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5855>
test/lang/useOperator.ci:34:[.03eec5, .03eecb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5861>
test/lang/useOperator.ci:35:[.03eecb, .03eed6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5867>
test/lang/useOperator.ci:36:[.03eed6, .03eee1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5878>
test/lang/useOperator.ci:37:[.03eee1, .03eeec) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5889>
test/lang/useOperator.ci:38:[.03eeec, .03eef7) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5900>
test/lang/useOperator.ci:39:[.03eef7, .03ef02) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5911>
test/lang/useOperator.ci:40:[.03ef02, .03ef0d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5922>
test/lang/useOperator.ci:41:[.03ef0d, .03ef18) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5933>
test/lang/useOperator.ci:42:[.03ef18, .03ef23) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5944>
test/lang/useOperator.ci:43:[.03ef23, .03ef2b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5955>
test/lang/useOperator.ci:44:[.03ef2b, .03ef33) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5963>
test/lang/useOperator.ci:45:[.03ef33, .03ef3a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5971>
test/lang/useOperator.ci:46:[.03ef3a, .03ef45) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5978>
test/lang/useOperator.ci:47:[.03ef45, .03ef51) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5989>
test/lang/useOperator.ci:48:[.03ef51, .03ef5c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6001>
test/lang/useOperator.ci:49:[.03ef5c, .03ef68) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6012>
test/lang/useOperator.ci:50:[.03ef68, .03ef73) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6024>
test/lang/useOperator.ci:51:[.03ef73, .03ef7f) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6035>
test/lang/useOperator.ci:53:[.03ef7f, .03ef84) exec(1), time(0 / 0.000 ms): <.main+6047>
test/lang/useOperator.ci:54:[.03ef84, .03ef89) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6052>
test/lang/useOperator.ci:55:[.03ef89, .03ef8e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6057>
test/lang/useOperator.ci:56:[.03ef8e, .03ef94) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6062>
test/lang/useOperator.ci:57:[.03ef94, .03ef9a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6068>
test/lang/useOperator.ci:58:[.03ef9a, .03efa5) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6074>
test/lang/useOperator.ci:59:[.03efa5, .03efb0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6085>
test/lang/useOperator.ci:60:[.03efb0, .03efbb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6096>
test/lang/useOperator.ci:61:[.03efbb, .03efc6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6107>
test/lang/useOperator.ci:62:[.03efc6, .03efd1) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6118>
test/lang/useOperator.ci:63:[.03efd1, .03efdc) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6129>
test/lang/useOperator.ci:64:[.03efdc, .03efe7) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6140>
test/lang/useOperator.ci:65:[.03efe7, .03eff2) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6151>
test/lang/useOperator.ci:66:[.03eff2, .03effa) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6162>
test/lang/useOperator.ci:67:[.03effa, .03f002) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6170>
test/lang/useOperator.ci:68:[.03f002, .03f009) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6178>
test/lang/useOperator.ci:69:[.03f009, .03f014) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6185>
test/lang/useOperator.ci:70:[.03f014, .03f020) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6196>
test/lang/useOperator.ci:71:[.03f020, .03f02b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6208>
test/lang/useOperator.ci:72:[.03f02b, .03f037) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6219>
test/lang/useOperator.ci:73:[.03f037, .03f042) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6231>
test/lang/useOperator.ci:74:[.03f042, .03f04e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6242>
test/lang/useOperator.ci:76:[.03f04e, .03f053) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6254>
test/lang/useOperator.ci:77:[.03f053, .03f058) exec(1), time(0 / 0.000 ms): <.main+6259>
test/lang/useOperator.ci:78:[.03f058, .03f05d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6264>
test/lang/useOperator.ci:79:[.03f05d, .03f063) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6269>
test/lang/useOperator.ci:80:[.03f063, .03f069) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6275>
test/lang/useOperator.ci:81:[.03f069, .03f074) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6281>
test/lang/useOperator.ci:82:[.03f074, .03f07f) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6292>
test/lang/useOperator.ci:83:[.03f07f, .03f08a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6303>
test/lang/useOperator.ci:84:[.03f08a, .03f095) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6314>
test/lang/useOperator.ci:85:[.03f095, .03f0a0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6325>
test/lang/useOperator.ci:86:[.03f0a0, .03f0ab) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6336>
test/lang/useOperator.ci:87:[.03f0ab, .03f0b6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6347>
test/lang/useOperator.ci:88:[.03f0b6, .03f0c1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6358>
test/lang/useOperator.ci:89:[.03f0c1, .03f0c9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6369>
test/lang/useOperator.ci:90:[.03f0c9, .03f0d1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6377>
test/lang/useOperator.ci:91:[.03f0d1, .03f0d8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6385>
test/lang/useOperator.ci:92:[.03f0d8, .03f0e3) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6392>
test/lang/useOperator.ci:93:[.03f0e3, .03f0ef) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6403>
test/lang/useOperator.ci:94:[.03f0ef, .03f0fa) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6415>
test/lang/useOperator.ci:95:[.03f0fa, .03f106) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6426>
test/lang/useOperator.ci:96:[.03f106, .03f111) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6438>
test/lang/useOperator.ci:97:[.03f111, .03f11d) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6449>
test/lang/useOperator.ci:99:[.03f11d, .03f122) exec(1), time(0 / 0.000 ms): <.main+6461>
test/lang/useOperator.ci:100:[.03f122, .03f127) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6466>
test/lang/useOperator.ci:101:[.03f127, .03f12c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6471>
test/lang/useOperator.ci:102:[.03f12c, .03f132) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6476>
test/lang/useOperator.ci:103:[.03f132, .03f138) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6482>
test/lang/useOperator.ci:104:[.03f138, .03f143) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6488>
test/lang/useOperator.ci:105:[.03f143, .03f14e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6499>
test/lang/useOperator.ci:106:[.03f14e, .03f159) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6510>
test/lang/useOperator.ci:107:[.03f159, .03f164) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6521>
test/lang/useOperator.ci:108:[.03f164, .03f16f) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6532>
test/lang/useOperator.ci:109:[.03f16f, .03f17a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6543>
test/lang/useOperator.ci:110:[.03f17a, .03f185) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6554>
test/lang/useOperator.ci:111:[.03f185, .03f190) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6565>
test/lang/useOperator.ci:112:[.03f190, .03f198) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6576>
test/lang/useOperator.ci:113:[.03f198, .03f1a0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6584>
test/lang/useOperator.ci:114:[.03f1a0, .03f1a7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6592>
test/lang/useOperator.ci:115:[.03f1a7, .03f1b2) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6599>
test/lang/useOperator.ci:116:[.03f1b2, .03f1be) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6610>
test/lang/useOperator.ci:117:[.03f1be, .03f1c9) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6622>
test/lang/useOperator.ci:118:[.03f1c9, .03f1d5) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6633>
test/lang/useOperator.ci:119:[.03f1d5, .03f1e0) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6645>
test/lang/useOperator.ci:120:[.03f1e0, .03f1ec) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6656>
test/lang/useOperator.ci:122:[.03f1ec, .03f1f1) exec(1), time(0 / 0.000 ms): <.main+6668>
test/lang/useOperator.ci:123:[.03f1f1, .03f1f6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6673>
test/lang/useOperator.ci:124:[.03f1f6, .03f1fb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6678>
test/lang/useOperator.ci:125:[.03f1fb, .03f201) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6683>
test/lang/useOperator.ci:126:[.03f201, .03f207) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6689>
test/lang/useOperator.ci:127:[.03f207, .03f212) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6695>
test/lang/useOperator.ci:128:[.03f212, .03f21d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6706>
test/lang/useOperator.ci:129:[.03f21d, .03f228) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6717>
test/lang/useOperator.ci:130:[.03f228, .03f233) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6728>
test/lang/useOperator.ci:131:[.03f233, .03f23e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6739>
test/lang/useOperator.ci:132:[.03f23e, .03f249) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6750>
test/lang/useOperator.ci:133:[.03f249, .03f254) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6761>
test/lang/useOperator.ci:134:[.03f254, .03f25f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6772>
test/lang/useOperator.ci:135:[.03f25f, .03f267) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6783>
test/lang/useOperator.ci:136:[.03f267, .03f26f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6791>
test/lang/useOperator.ci:137:[.03f26f, .03f276) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6799>
test/lang/useOperator.ci:138:[.03f276, .03f281) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6806>
test/lang/useOperator.ci:139:[.03f281, .03f28d) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6817>
test/lang/useOperator.ci:140:[.03f28d, .03f298) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6829>
test/lang/useOperator.ci:141:[.03f298, .03f2a4) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6840>
test/lang/useOperator.ci:142:[.03f2a4, .03f2af) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6852>
test/lang/useOperator.ci:143:[.03f2af, .03f2bb) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6863>
test/lang/useOperator.ci:145:[.03f2bb, .03f2c0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6875>
test/lang/useOperator.ci:146:[.03f2c0, .03f2c5) exec(1), time(0 / 0.000 ms): <.main+6880>
test/lang/useOperator.ci:147:[.03f2c5, .03f2c7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6885>
test/lang/useOperator.ci:148:[.03f2c7, .03f2ca) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6887>
test/lang/useOperator.ci:149:[.03f2ca, .03f2cd) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6890>
test/lang/useOperator.ci:150:[.03f2cd, .03f2d2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6893>
test/lang/useOperator.ci:151:[.03f2d2, .03f2d7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6898>
test/lang/useOperator.ci:152:[.03f2d7, .03f2dc) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6903>
test/lang/useOperator.ci:153:[.03f2dc, .03f2e1) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6908>
test/lang/useOperator.ci:154:[.03f2e1, .03f2e6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6913>
test/lang/useOperator.ci:155:[.03f2e6, .03f2eb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6918>
test/lang/useOperator.ci:156:[.03f2eb, .03f2f0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6923>
test/lang/useOperator.ci:157:[.03f2f0, .03f2f5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6928>
test/lang/useOperator.ci:158:[.03f2f5, .03f2fa) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6933>
test/lang/useOperator.ci:159:[.03f2fa, .03f2ff) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6938>
test/lang/useOperator.ci:160:[.03f2ff, .03f303) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6943>
test/lang/useOperator.ci:161:[.03f303, .03f308) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6947>
test/lang/useOperator.ci:162:[.03f308, .03f30e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6952>
test/lang/useOperator.ci:163:[.03f30e, .03f313) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6958>
test/lang/useOperator.ci:164:[.03f313, .03f319) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6963>
test/lang/useOperator.ci:165:[.03f319, .03f31e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6969>
test/lang/useOperator.ci:166:[.03f31e, .03f324) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6974>
test/lang/useOperator.ci:168:[.03f324, .03f329) exec(1), time(0 / 0.000 ms): <.main+6980>
test/lang/useOperator.ci:169:[.03f329, .03f32e) exec(1), time(0 / 0.000 ms): <.main+6985>
test/lang/useOperator.ci:170:[.03f32e, .03f330) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6990>
test/lang/useOperator.ci:171:[.03f330, .03f333) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6992>
test/lang/useOperator.ci:172:[.03f333, .03f336) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6995>
test/lang/useOperator.ci:173:[.03f336, .03f33b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6998>
test/lang/useOperator.ci:174:[.03f33b, .03f340) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7003>
test/lang/useOperator.ci:175:[.03f340, .03f345) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7008>
test/lang/useOperator.ci:176:[.03f345, .03f34a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7013>
test/lang/useOperator.ci:177:[.03f34a, .03f34f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7018>
test/lang/useOperator.ci:178:[.03f34f, .03f354) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7023>
test/lang/useOperator.ci:179:[.03f354, .03f359) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7028>
test/lang/useOperator.ci:180:[.03f359, .03f35e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7033>
test/lang/useOperator.ci:181:[.03f35e, .03f363) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7038>
test/lang/useOperator.ci:182:[.03f363, .03f368) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7043>
test/lang/useOperator.ci:183:[.03f368, .03f36c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7048>
test/lang/useOperator.ci:184:[.03f36c, .03f371) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7052>
test/lang/useOperator.ci:185:[.03f371, .03f377) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7057>
test/lang/useOperator.ci:186:[.03f377, .03f37c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7063>
test/lang/useOperator.ci:187:[.03f37c, .03f382) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7068>
test/lang/useOperator.ci:188:[.03f382, .03f387) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7074>
test/lang/useOperator.ci:189:[.03f387, .03f38d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7079>
test/lang/useOperator.ci:191:[.03f38d, .03f396) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7085>
test/lang/useOperator.ci:192:[.03f396, .03f39f) exec(1), time(0 / 0.000 ms): <.main+7094>
test/lang/useOperator.ci:193:[.03f39f, .03f3a1) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7103>
test/lang/useOperator.ci:194:[.03f3a1, .03f3a4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7105>
test/lang/useOperator.ci:195:[.03f3a4, .03f3a7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7108>
test/lang/useOperator.ci:196:[.03f3a7, .03f3ac) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7111>
test/lang/useOperator.ci:197:[.03f3ac, .03f3b1) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7116>
test/lang/useOperator.ci:198:[.03f3b1, .03f3b6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7121>
test/lang/useOperator.ci:199:[.03f3b6, .03f3bb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7126>
test/lang/useOperator.ci:200:[.03f3bb, .03f3c0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7131>
test/lang/useOperator.ci:201:[.03f3c0, .03f3c5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7136>
test/lang/useOperator.ci:202:[.03f3c5, .03f3ca) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7141>
test/lang/useOperator.ci:203:[.03f3ca, .03f3cf) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7146>
test/lang/useOperator.ci:204:[.03f3cf, .03f3d4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7151>
test/lang/useOperator.ci:205:[.03f3d4, .03f3d9) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7156>
test/lang/useOperator.ci:206:[.03f3d9, .03f3dd) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7161>
test/lang/useOperator.ci:207:[.03f3dd, .03f3e2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7165>
test/lang/useOperator.ci:208:[.03f3e2, .03f3e8) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7170>
test/lang/useOperator.ci:209:[.03f3e8, .03f3ed) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7176>
test/lang/useOperator.ci:210:[.03f3ed, .03f3f3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7181>
test/lang/useOperator.ci:211:[.03f3f3, .03f3f8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7187>
test/lang/useOperator.ci:212:[.03f3f8, .03f3fe) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7192>
test/lang/useOperator.ci:214:[.03f3fe, .03f407) exec(1), time(0 / 0.000 ms): <.main+7198>
test/lang/useOperator.ci:215:[.03f407, .03f410) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7207>
test/lang/useOperator.ci:216:[.03f410, .03f412) exec(1), time(0 / 0.000 ms): <.main+7216>
test/lang/useOperator.ci:217:[.03f412, .03f415) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7218>
test/lang/useOperator.ci:218:[.03f415, .03f418) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7221>
test/lang/useOperator.ci:219:[.03f418, .03f41d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7224>
test/lang/useOperator.ci:220:[.03f41d, .03f422) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7229>
test/lang/useOperator.ci:221:[.03f422, .03f427) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7234>
test/lang/useOperator.ci:222:[.03f427, .03f42c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7239>
test/lang/useOperator.ci:223:[.03f42c, .03f431) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7244>
test/lang/useOperator.ci:224:[.03f431, .03f436) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7249>
test/lang/useOperator.ci:225:[.03f436, .03f43b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7254>
test/lang/useOperator.ci:226:[.03f43b, .03f440) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7259>
test/lang/useOperator.ci:227:[.03f440, .03f445) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7264>
test/lang/useOperator.ci:228:[.03f445, .03f44a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7269>
test/lang/useOperator.ci:229:[.03f44a, .03f44e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7274>
test/lang/useOperator.ci:230:[.03f44e, .03f453) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7278>
test/lang/useOperator.ci:231:[.03f453, .03f459) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7283>
test/lang/useOperator.ci:232:[.03f459, .03f45e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7289>
test/lang/useOperator.ci:233:[.03f45e, .03f464) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7294>
test/lang/useOperator.ci:234:[.03f464, .03f469) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7300>
test/lang/useOperator.ci:235:[.03f469, .03f46f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7305>
test/lang/useOperator.ci:237:[.03f46f, .03f474) exec(1), time(0 / 0.000 ms): <.main+7311>
test/lang/useOperator.ci:238:[.03f474, .03f479) exec(1), time(0 / 0.000 ms): <.main+7316>
test/lang/useOperator.ci:239:[.03f479, .03f47b) exec(1), time(0 / 0.000 ms): <.main+7321>
test/lang/useOperator.ci:240:[.03f47b, .03f47e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7323>
test/lang/useOperator.ci:242:[.03f47e, .03f483) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7326>
test/lang/useOperator.ci:243:[.03f483, .03f488) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7331>
test/lang/useOperator.ci:244:[.03f488, .03f48d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7336>
test/lang/useOperator.ci:245:[.03f48d, .03f492) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7341>
test/lang/useOperator.ci:246:[.03f492, .03f497) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7346>
test/lang/useOperator.ci:252:[.03f497, .03f49b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7351>
test/lang/useOperator.ci:253:[.03f49b, .03f4a0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7355>
test/lang/useOperator.ci:254:[.03f4a0, .03f4a6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7360>
test/lang/useOperator.ci:255:[.03f4a6, .03f4ab) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7366>
test/lang/useOperator.ci:256:[.03f4ab, .03f4b1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7371>
test/lang/useOperator.ci:257:[.03f4b1, .03f4b6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7377>
test/lang/useOperator.ci:258:[.03f4b6, .03f4bc) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7382>
test/lang/useOperator.ci:260:[.03f4bc, .03f4c5) exec(1), time(0 / 0.000 ms): <.main+7388>
test/lang/useOperator.ci:261:[.03f4c5, .03f4ce) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7397>
test/lang/useOperator.ci:262:[.03f4ce, .03f4d0) exec(1), time(0 / 0.000 ms): <.main+7406>
test/lang/useOperator.ci:263:[.03f4d0, .03f4d3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7408>
test/lang/useOperator.ci:265:[.03f4d3, .03f4d8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7411>
test/lang/useOperator.ci:266:[.03f4d8, .03f4dd) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7416>
test/lang/useOperator.ci:267:[.03f4dd, .03f4e2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7421>
test/lang/useOperator.ci:268:[.03f4e2, .03f4e7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7426>
test/lang/useOperator.ci:269:[.03f4e7, .03f4ec) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7431>
test/lang/useOperator.ci:275:[.03f4ec, .03f4f0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7436>
test/lang/useOperator.ci:276:[.03f4f0, .03f4f5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7440>
test/lang/useOperator.ci:277:[.03f4f5, .03f4fb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7445>
test/lang/useOperator.ci:278:[.03f4fb, .03f500) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7451>
test/lang/useOperator.ci:279:[.03f500, .03f506) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7456>
test/lang/useOperator.ci:280:[.03f506, .03f50b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7462>
test/lang/useOperator.ci:281:[.03f50b, .03f511) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7467>
test/lang/useOperator.ci:283:[.03f511, .03f516) exec(1), time(0 / 0.000 ms): <.main+7473>
test/lang/useOperator.ci:284:[.03f516, .03f51a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7478>
test/lang/useOperator.ci:299:[.03f51a, .03f51f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7482>
test/lang/useOperator.ci:300:[.03f51f, .03f525) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7487>
test/lang/statementIf.ci:4:[.03f525, .03f54c) exec(1), time(35-35 / 0.035-0.035 ms): <.main+7493>
test/lang/statementIf.ci:12:[.03f54c, .03f573) exec(1), time(37-37 / 0.037-0.037 ms): <.main+7532>
test/lang/statementIf.ci:22:[.03f573, .03f59a) exec(1), time(33-33 / 0.033-0.033 ms): <.main+7571>
test/lang/statementIf.ci:26:[.03f59a, .03f59b) exec(1), time(0 / 0.000 ms): <.main+7610>
test/lang/statementIf.ci:29:[.03f5a3, .03f5c9) exec(1), time(40-40 / 0.040-0.040 ms): <.main+7619>
test/lang/statementIf.ci:28:[.03f59b, .03f5c9) exec(1-1), time(0 / 0.000 ms): <.main+7611>
test/lang/statementIf.ci:33:[.03f5d1, .03f5f7) exec(0), time(0 / 0.000 ms): <.main+7665>
test/lang/statementIf.ci:32:[.03f5c9, .03f5f7) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7657>
test/lang/statementIf.ci:37:[.03f5ff, .03f625) exec(1), time(38-38 / 0.038-0.038 ms): <.main+7711>
test/lang/statementIf.ci:40:[.03f629, .03f64f) exec(0), time(0 / 0.000 ms): <.main+7753>
test/lang/statementIf.ci:36:[.03f5f7, .03f64f) exec(1), time(40-40 / 0.040-0.040 ms): <.main+7703>
test/lang/statementIf.ci:44:[.03f657, .03f67d) exec(0), time(0 / 0.000 ms): <.main+7799>
test/lang/statementIf.ci:47:[.03f681, .03f6a7) exec(1), time(39-39 / 0.039-0.039 ms): <.main+7841>
test/lang/statementIf.ci:43:[.03f64f, .03f6a7) exec(1-1), time(0 / 0.000 ms): <.main+7791>
test/lang/statementIf.ci:51:[.03f6af, .03f6d5) exec(1), time(39-39 / 0.039-0.039 ms): <.main+7887>
test/lang/statementIf.ci:54:[.03f6e5, .03f70b) exec(0), time(0 / 0.000 ms): <.main+7941>
test/lang/statementIf.ci:57:[.03f71b, .03f741) exec(0), time(0 / 0.000 ms): <.main+7995>
test/lang/statementIf.ci:60:[.03f751, .03f777) exec(0), time(0 / 0.000 ms): <.main+8049>
test/lang/statementIf.ci:63:[.03f787, .03f7ad) exec(0), time(0 / 0.000 ms): <.main+8103>
test/lang/statementIf.ci:66:[.03f7bd, .03f7e3) exec(0), time(0 / 0.000 ms): <.main+8157>
test/lang/statementIf.ci:69:[.03f7e7, .03f80d) exec(0), time(0 / 0.000 ms): <.main+8199>
test/lang/statementIf.ci:65:[.03f7b1, .03f80d) exec(0), time(0 / 0.000 ms): <.main+8145>
test/lang/statementIf.ci:62:[.03f77b, .03f80d) exec(0), time(0 / 0.000 ms): <.main+8091>
test/lang/statementIf.ci:59:[.03f745, .03f80d) exec(0), time(0 / 0.000 ms): <.main+8037>
test/lang/statementIf.ci:56:[.03f70f, .03f80d) exec(0), time(0 / 0.000 ms): <.main+7983>
test/lang/statementIf.ci:53:[.03f6d9, .03f80d) exec(0), time(0 / 0.000 ms): <.main+7929>
test/lang/statementIf.ci:50:[.03f6a7, .03f80d) exec(1), time(40-40 / 0.040-0.040 ms): <.main+7879>
test/lang/statementFor.ci:4:[.03f811, .03f834) exec(1), time(29-29 / 0.029-0.029 ms): <.main+8241>
test/lang/statementFor.ci:5:[.03f834, .03f838) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8276>
::[.03f838, .03f83c) exec(1), time(0 / 0.000 ms): <.main+8280>
test/lang/statementFor.ci:3:[.03f80d, .03f83c) exec(1-1), time(0 / 0.000 ms): <.main+8237>
test/lang/statementFor.ci:9:[.03f841, .03f863) exec(2), time(68-68 / 0.068-0.068 ms): <.main+8289>
test/lang/statementFor.ci:8:[.03f863, .03f867) exec(2), time(2-2 / 0.002-0.002 ms): <.main+8323>
test/lang/statementFor.ci:8:[.03f867, .03f873) exec(3), time(9-9 / 0.009-0.009 ms): <.main+8327>
test/lang/statementFor.ci:8:[.03f83c, .03f877) exec(1), time(4-4 / 0.004-0.004 ms): <.main+8284>
test/lang/statementFor.ci:12:[.03f877, .03f878) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8343>
test/lang/statementFor.ci:14:[.03f87f, .03f8a1) exec(2), time(68-68 / 0.068-0.068 ms): <.main+8351>
test/lang/statementFor.ci:13:[.03f8a1, .03f8a5) exec(2), time(1-1 / 0.001-0.001 ms): <.main+8385>
test/lang/statementFor.ci:13:[.03f8a5, .03f8b1) exec(3), time(10-10 / 0.010-0.010 ms): <.main+8389>
test/lang/statementFor.ci:13:[.03f878, .03f8b1) exec(1-1), time(0 / 0.000 ms): <.main+8344>
test/lang/statementFor.ci:19:[.03f8c2, .03f8c6) exec(2), time(1-1 / 0.001-0.001 ms): <.main+8418>
test/lang/statementFor.ci:18:[.03f8b6, .03f8c6) exec(7-2), time(16-16 / 0.016-0.016 ms): <.main+8406>
test/lang/statementFor.ci:21:[.03f8c6, .03f8e8) exec(5), time(173-173 / 0.173-0.173 ms): <.main+8422>
test/lang/statementFor.ci:17:[.03f8e8, .03f8ec) exec(7), time(4-4 / 0.004-0.004 ms): <.main+8456>
test/lang/statementFor.ci:17:[.03f8ec, .03f8f8) exec(8), time(27-27 / 0.027-0.027 ms): <.main+8460>
test/lang/statementFor.ci:17:[.03f8b1, .03f8fc) exec(1), time(4-4 / 0.004-0.004 ms): <.main+8401>
test/lang/statementFor.ci:26:[.03f90d, .03f911) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8493>
test/lang/statementFor.ci:25:[.03f901, .03f911) exec(4-1), time(10-10 / 0.010-0.010 ms): <.main+8481>
test/lang/statementFor.ci:28:[.03f911, .03f933) exec(3), time(108-108 / 0.108-0.108 ms): <.main+8497>
test/lang/statementFor.ci:24:[.03f933, .03f937) exec(3), time(1-1 / 0.001-0.001 ms): <.main+8531>
test/lang/statementFor.ci:24:[.03f937, .03f943) exec(4), time(13-13 / 0.013-0.013 ms): <.main+8535>
test/lang/statementFor.ci:24:[.03f8fc, .03f947) exec(1), time(2-2 / 0.002-0.002 ms): <.main+8476>

---------- Exitcode: 0, time: 19.360 ms
