
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:59: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:80: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:81: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:82: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:79: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:67: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:94: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:532: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:95: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:119: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:155: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:155: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:170: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:175: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:187: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:199: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:200: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:200: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:202: warn: adding implicit cast char(0: int32)
lib/std/string.ci:215: warn: adding implicit cast int32('-': char)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:116: warn: adding implicit cast char(0: int32)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:97: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:98: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:99: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:78: warn: comment does not belong to a declaration
test/lang/method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
test/lang/method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@005f68>, cast: static const inline)
.field file: function (size: 0, offs: <@006168>, cast: static const inline)
.field line: function (size: 0, offs: <@006368>, cast: static const inline)
.field name: function (size: 0, offs: <@006568>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:92: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:92: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005f68>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006168>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006368>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006568>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:90: referenced as `void`
	test/lang/method.ci:84: referenced as `void`
	test/lang/method.ci:57: referenced as `void`
	test/lang/method.ci:47: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:32: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:18: referenced as `void`
	test/lang/method.ci:10: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:75: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/stdc/test.math.ci:68: referenced as `bool`
	test/stdc/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:56: referenced as `bool`
	lib/stdlib.ci:54: referenced as `bool`
	lib/stdlib.ci:52: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:75: referenced as `char`
	lib/stdlib.ci:70: referenced as `char`
	lib/stdlib.ci:54: referenced as `char`
	lib/stdlib.ci:52: referenced as `char`
	lib/stdlib.ci:47: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:42: referenced as `char`
	lib/stdlib.ci:40: referenced as `char`
	lib/stdlib.ci:37: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:32: referenced as `char`
	lib/stdlib.ci:30: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:25: referenced as `char`
	lib/stdlib.ci:22: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:90: referenced as `int32`
	test/lang/method.ci:84: referenced as `int32`
	test/lang/method.ci:57: referenced as `int32`
	test/lang/method.ci:47: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:32: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:18: referenced as `int32`
	test/lang/method.ci:10: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:30: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:24: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:18: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:12: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:92: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0091a8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@0094d8>, cast: static const inline)
.field pop: function (size: 0, offs: <@0096d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0098d8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009ad8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009cd8>, cast: static const inline)
.field hib: function (size: 0, offs: <@009ed8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a0d8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0091a8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.usages:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0094d8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.usages:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.usages:
	test/stdc/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098d8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/stdc/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ad8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/stdc/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009cd8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/stdc/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ed8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/stdc/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0d8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/stdc/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00a400>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a728>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a400>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/stdc/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a728>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/stdc/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00a928>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ab28>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ad28>, cast: static const inline)
.field log: function (size: 0, offs: <@00af28>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b128>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b3c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b5c0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b858>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:94: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:89: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/stdc/test.math.ci:85: referenced as `float32`
	test/stdc/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:92: referenced as `float32`
	lib/vec/vec4f.ci:88: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:80: referenced as `float32`
	lib/vec/vec4f.ci:78: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:34: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a928>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.usages:
	test/stdc/number.ci:46: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab28>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.usages:
	test/stdc/number.ci:47: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad28>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.usages:
	test/stdc/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af28>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/stdc/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b128>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/stdc/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b3c0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/stdc/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5c0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:98: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b858>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/stdc/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00ba50>, cast: static const inline)
.field cos: function (size: 0, offs: <@00bc48>, cast: static const inline)
.field tan: function (size: 0, offs: <@00be40>, cast: static const inline)
.field log: function (size: 0, offs: <@00c038>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c230>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c4c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c6b8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c948>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:80: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:75: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:71: referenced as `float64`
	test/stdc/test.math.ci:70: referenced as `float64`
	test/stdc/test.math.ci:64: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:58: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:49: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:44: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:39: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba50>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.usages:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc48>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.usages:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be40>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.usages:
	test/stdc/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c038>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c230>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c4c0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6b8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c948>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007880>, cast: static const inline)
.field fill: function (size: 0, offs: <@007bb8>, cast: static const inline)
.field copy: function (size: 0, offs: <@007ef0>, cast: static const inline)
.field move: function (size: 0, offs: <@008220>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007880>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.usages:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bb8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.usages:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007ef0>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008220>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/stdc/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:67: referenced as `variant`
	lib/stdlib.ci:64: referenced as `variant`
	lib/stdlib.ci:61: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:45: referenced as `variant`
	lib/stdlib.ci:40: referenced as `variant`
	lib/stdlib.ci:35: referenced as `variant`
	lib/stdlib.ci:30: referenced as `variant`
	lib/stdlib.ci:25: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:15: referenced as `variant`
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:92: referenced as `null`
	test/lang/method.ci:86: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:87: referenced as `null`
	lib/stdlib.ci:70: referenced as `null`
	lib/stdlib.ci:67: referenced as `null`
	lib/stdlib.ci:49: referenced as `null`
	lib/stdlib.ci:47: referenced as `null`
	lib/stdlib.ci:42: referenced as `null`
	lib/stdlib.ci:37: referenced as `null`
	lib/stdlib.ci:32: referenced as `null`
	lib/stdlib.ci:27: referenced as `null`
	lib/stdlib.ci:22: referenced as `null`
	lib/stdlib.ci:17: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.usages:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.usages:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.usages:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@001058>
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@0010f8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0014b8>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001558>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0017d8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001d78>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@002110>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@0022f0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0024c0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002690>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002860>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002a30>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002d30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@003180>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@0035b0>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0039e0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f40>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044a0>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0048d0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004d00>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005130>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005560>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005730>, cast: static const typename(void))
.usages:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:92: referenced as `emit`
	lib/vec/vec4f.ci:88: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:80: referenced as `emit`
	lib/vec/vec4f.ci:78: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec4f.ci:71: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:67: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0014b8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:92: referenced as `p4x`
	lib/vec/vec4f.ci:88: referenced as `p4x`
	lib/vec/vec4f.ci:84: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:92: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:88: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001558>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0017d8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001d78>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002110>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022f0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0024c0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002690>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002860>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a30>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002d30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:67: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003180>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:69: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:69: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0035b0>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:71: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:71: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0039e0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:73: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f40>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:75: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044a0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0048d0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004d00>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005130>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005560>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:78: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:78: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005730>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:80: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:80: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005c20>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006d00>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(5)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:84: referenced as `abort`
	lib/stdlib.ci:49: referenced as `abort`
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:42: referenced as `error`
	lib/stdlib.ci:40: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:37: referenced as `warn`
	lib/stdlib.ci:35: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:32: referenced as `info`
	lib/stdlib.ci:30: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:27: referenced as `debug`
	lib/stdlib.ci:25: referenced as `debug`
	lib/stdlib.ci:22: referenced as `debug`
	lib/stdlib.ci:20: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:17: referenced as `verbose`
	lib/stdlib.ci:15: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:37: referenced as `noTrace`
	lib/stdlib.ci:35: referenced as `noTrace`
	lib/stdlib.ci:32: referenced as `noTrace`
	lib/stdlib.ci:30: referenced as `noTrace`
	lib/stdlib.ci:22: referenced as `noTrace`
	lib/stdlib.ci:20: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:84: referenced as `defTrace`
	lib/stdlib.ci:49: referenced as `defTrace`
	lib/stdlib.ci:47: referenced as `defTrace`
	lib/stdlib.ci:45: referenced as `defTrace`
	lib/stdlib.ci:42: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:27: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0075e0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008250>
.name: 'System'
.field exit: function (size: 0, offs: <@0084c8>, cast: static const inline)
.field srand: function (size: 0, offs: <@0086d0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008838>, cast: static const inline)
.field time: function (size: 0, offs: <@0089a0>, cast: static const inline)
.field clock: function (size: 0, offs: <@008b08>, cast: static const inline)
.field millis: function (size: 0, offs: <@008c70>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008e70>, cast: static const inline)
.usages:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0084c8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0086d0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008838>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b08>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008c70>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e70>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.usages:
	internal usages: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:15: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:17: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:20: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:22'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:91: referenced as `debug`
	test/lang/method.ci:85: referenced as `debug`
	lib/stdlib.ci:22: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:58: referenced as `trace`
	test/lang/method.ci:48: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:11: referenced as `trace`
	lib/stdlib.ci:25: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:27: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:30'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:30: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:32'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:32: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:35'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:35: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:37: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/stdlib.ci:40: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:42: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:52: referenced as `abort`
	lib/stdlib.ci:45: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:56: referenced as `abort`
	lib/stdlib.ci:54: referenced as `abort`
	lib/stdlib.ci:47: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/stdlib.ci:49: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:52'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:52: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:54'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:54: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:56'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:56: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00fbe0>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:59'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:79: referenced as `NotEquals`
	lib/stdlib.ci:59: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/stdlib.ci:80: referenced as `expected`
	lib/stdlib.ci:61: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:64'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/stdlib.ci:81: referenced as `returned`
	lib/stdlib.ci:64: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:67'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:67: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:70'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:82: referenced as `message`
	lib/stdlib.ci:70: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@050210>
.name: 'assertEq'
.file: 'lib/stdlib.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@050210> - <@05026e>)
	lib/stdlib.ci:76: (10 bytes: <@050210> - <@05021a>): if (bool(returned == expected))
	<assertEq @050210>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @050212>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @050214>    : 57                         ceq.i32
	<assertEq+5 @050215>    : 06 05 00 00                jz <assertEq+10 @05021a>
	lib/stdlib.ci:77: (1 byte: <@050219> - <@05021a>): return;
	<assertEq+9 @050219>    : 03                         ret
	lib/stdlib.ci:79: (41 bytes: <@05021a> - <@050243>): details: NotEquals := {...}
	<assertEq+10 @05021a>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:80: (11 bytes: <@05021e> - <@050229>): void(details.expected := (expected));
	<assertEq+14 @05021e>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @050223>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @050227>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:81: (11 bytes: <@050229> - <@050234>): void(details.returned := (returned));
	<assertEq+25 @050229>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @05022e>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @050232>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:82: (3 bytes: <@050234> - <@050237>): void(details.message := (message));
	<assertEq+36 @050234>   : 16 06 09                   mov.x1 sp(6, 9)
	:: (12 bytes: <@050237> - <@050243>): void(details.argument := (null))
	<assertEq+39 @050237>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @05023c>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @050241>   : 14 06                      set.x2 sp(6)
	lib/stdlib.ci:84: (38 bytes: <@050243> - <@050269>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @050243>   : 1f 78 c9 00 00             load.ref <@00c978> ;"lib/stdlib.ci"
	<assertEq+56 @050248>   : 1c 54 00 00 00             load.c32 84
	<assertEq+61 @05024d>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @050252>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @050257>   : 1f 7b cc 00 00             load.ref <@00cc7b> ;"assertion failed"
	<assertEq+76 @05025c>   : 1f e0 fb 00 00             load.ref <@00fbe0> ;NotEquals
	<assertEq+81 @050261>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @050265>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @050269>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @05026d>   : 03                         ret
.usages:
	lib/stdlib.ci:87: referenced as `assertEq`
	lib/stdlib.ci:75: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:87'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:87: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:92'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:92: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@010e58>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@050270>, cast: static const function)
.field floor: function (size: 24, offs: <@0502c8>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@0502e0>, cast: static const function)
.field abs: function (size: 18, offs: <@0502f8>, cast: static const function)
.field absMod: function (size: 27, offs: <@050310>, cast: static const function)
.field absMod: function (size: 27, offs: <@050330>, cast: static const function)
.field min: function (size: 17, offs: <@050350>, cast: static const function)
.field min: function (size: 17, offs: <@050368>, cast: static const function)
.field max: function (size: 17, offs: <@050380>, cast: static const function)
.field max: function (size: 17, offs: <@050398>, cast: static const function)
.field clamp: function (size: 30, offs: <@0503b0>, cast: static const function)
.field clamp: function (size: 30, offs: <@0503d0>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@0503f0>, cast: static const function)
.field max: function (size: 72, offs: <@050438>, cast: static const function)
.field sum: function (size: 40, offs: <@050480>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@0504a8>, cast: static const function)
.field cmp: function (size: 57, offs: <@0504d8>, cast: static const function)
.field cmp: function (size: 57, offs: <@050518>, cast: static const function)
.field sinCos: function (size: 335, offs: <@050558>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@0506a8>, cast: static const function)
.field sinh: function (size: 241, offs: <@050820>, cast: static const function)
.field cosh: function (size: 75, offs: <@050918>, cast: static const function)
.field asin: function (size: 166, offs: <@050968>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:94: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:89: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:85: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:80: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:75: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:71: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:68: referenced as `Math`
	test/stdc/test.math.ci:67: referenced as `Math`
	test/stdc/test.math.ci:64: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:50: referenced as `Math`
	test/stdc/test.math.ci:49: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:44: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:39: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	test/stdc/test.math.ci:58: referenced as `pi`
	test/stdc/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: float64(1.000000 / ln2)
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: float64(1.000000 / ln10)
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: float64((0) / 0.000000)
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: float64((1) / 0.000000)
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@050270>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@050270> - <@0502c6>)
	lib/std/math.ci:23: (63 bytes: <@050270> - <@0502af>): if (bool(x < (1)))
	<modf @050270>      : 11 02                      dup.x2 sp(2)
	<modf+2 @050272>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @05027b>   : 88                         clt.f64
	<modf+12 @05027c>   : 06 33 00 00                jz <modf+63 @0502af>
	lib/std/math.ci:24: (39 bytes: <@050280> - <@0502a7>): if (bool(x < (0)))
	<modf+16 @050280>   : 11 02                      dup.x2 sp(2)
	<modf+18 @050282>   : 1a                         load.z64
	<modf+19 @050283>   : 88                         clt.f64
	<modf+20 @050284>   : 06 23 00 00                jz <modf+55 @0502a7>
	lib/std/math.ci:25: (17 bytes: <@050288> - <@050299>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @050288>   : 1a                         load.z64
	<modf+25 @050289>   : 11 04                      dup.x2 sp(4)
	<modf+27 @05028b>   : 80                         neg.f64
	<modf+28 @05028c>   : 10 05                      dup.x1 sp(5)
	<modf+30 @05028e>   : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @050293>   : 02                         call
	<modf+36 @050294>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @050298>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@050299> - <@0502a0>): float64(intPart := float64(-intPart));
	<modf+41 @050299>   : 10 03                      dup.x1 sp(3)
	<modf+43 @05029b>   : 23                         load.i64
	<modf+44 @05029c>   : 80                         neg.f64
	<modf+45 @05029d>   : 10 05                      dup.x1 sp(5)
	<modf+47 @05029f>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@0502a0> - <@0502a3>): return float64(.result := result);
	<modf+48 @0502a0>   : 14 06                      set.x2 sp(6)
	<modf+50 @0502a2>   : 03                         ret
	<modf+51 @0502a3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@0502a7> - <@0502ab>): float64(intPart := (0));
	<modf+55 @0502a7>   : 1a                         load.z64
	<modf+56 @0502a8>   : 10 03                      dup.x1 sp(3)
	<modf+58 @0502aa>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@0502ab> - <@0502af>): return float64(.result := x);
	<modf+59 @0502ab>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @0502ae>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@0502af> - <@0502bb>): result: float64 := float64(x % (1))
	<modf+63 @0502af>   : 11 02                      dup.x2 sp(2)
	<modf+65 @0502b1>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @0502ba>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@0502bb> - <@0502c3>): float64(intPart := float64(x - result));
	<modf+75 @0502bb>   : 11 04                      dup.x2 sp(4)
	<modf+77 @0502bd>   : 11 02                      dup.x2 sp(2)
	<modf+79 @0502bf>   : 82                         sub.f64
	<modf+80 @0502c0>   : 10 05                      dup.x1 sp(5)
	<modf+82 @0502c2>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@0502c3> - <@0502c6>): return float64(.result := result);
	<modf+83 @0502c3>   : 14 06                      set.x2 sp(6)
	<modf+85 @0502c5>   : 03                         ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@0502c8>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@0502c8> - <@0502e0>)
	lib/std/math.ci:48: (1 byte: <@0502c8> - <@0502c9>): result: float64
	<floor @0502c8>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@0502c9> - <@0502dd>): modf(void(x, result));
	<floor+1 @0502c9>    : 11 05                      dup.x2 sp(5)
	<floor+3 @0502cb>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @0502cf>    : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @0502d4>   : 02                         call
	<floor+13 @0502d5>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @0502d9>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@0502dd> - <@0502e0>): return float64(.result := result);
	<floor+21 @0502dd>   : 14 05                      set.x2 sp(5)
	<floor+23 @0502df>   : 03                         ret
.usages:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@0502e0>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@0502e0> - <@0502f2>)
	lib/std/math.ci:78: (14 bytes: <@0502e0> - <@0502ee>): if (bool(x < (0)))
	<abs @0502e0>      : 10 01                      dup.x1 sp(1)
	<abs+2 @0502e2>    : 19                         load.z32
	<abs+3 @0502e3>    : 78                         clt.f32
	<abs+4 @0502e4>    : 06 0a 00 00                jz <abs+14 @0502ee>
	lib/std/math.ci:79: (6 bytes: <@0502e8> - <@0502ee>): return float32(.result := float32(-x));
	<abs+8 @0502e8>    : 10 01                      dup.x1 sp(1)
	<abs+10 @0502ea>   : 70                         neg.f32
	<abs+11 @0502eb>   : 13 03                      set.x1 sp(3)
	<abs+13 @0502ed>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@0502ee> - <@0502f2>): return float32(.result := x);
	<abs+14 @0502ee>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @0502f1>   : 03                         ret
.usages:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@0502f8>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@0502f8> - <@05030a>)
	lib/std/math.ci:86: (14 bytes: <@0502f8> - <@050306>): if (bool(x < (0)))
	<abs @0502f8>      : 11 01                      dup.x2 sp(1)
	<abs+2 @0502fa>    : 1a                         load.z64
	<abs+3 @0502fb>    : 88                         clt.f64
	<abs+4 @0502fc>    : 06 0a 00 00                jz <abs+14 @050306>
	lib/std/math.ci:87: (6 bytes: <@050300> - <@050306>): return float64(.result := float64(-x));
	<abs+8 @050300>    : 11 01                      dup.x2 sp(1)
	<abs+10 @050302>   : 80                         neg.f64
	<abs+11 @050303>   : 14 05                      set.x2 sp(5)
	<abs+13 @050305>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@050306> - <@05030a>): return float64(.result := x);
	<abs+14 @050306>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @050309>   : 03                         ret
.usages:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@050310>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@050310> - <@05032b>)
	lib/std/math.ci:94: (23 bytes: <@050310> - <@050327>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @050310>      : 10 02                      dup.x1 sp(2)
	<absMod+2 @050312>    : 10 02                      dup.x1 sp(2)
	<absMod+4 @050314>    : 75                         mod.f32
	<absMod+5 @050315>    : 10 00                      dup.x1 sp(0)
	<absMod+7 @050317>    : 13 04                      set.x1 sp(4)
	<absMod+9 @050319>    : 19                         load.z32
	<absMod+10 @05031a>   : 78                         clt.f32
	<absMod+11 @05031b>   : 06 0c 00 00                jz <absMod+23 @050327>
	lib/std/math.ci:95: (8 bytes: <@05031f> - <@050327>): return float32(.result := float32(val + mod));
	<absMod+15 @05031f>   : 10 02                      dup.x1 sp(2)
	<absMod+17 @050321>   : 10 02                      dup.x1 sp(2)
	<absMod+19 @050323>   : 71                         add.f32
	<absMod+20 @050324>   : 13 04                      set.x1 sp(4)
	<absMod+22 @050326>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@050327> - <@05032b>): return float32(.result := val);
	<absMod+23 @050327>   : 16 03 02                   mov.x1 sp(3, 2)
	<absMod+26 @05032a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:94: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:89: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	test/stdc/test.math.ci:85: referenced as `absMod`
	test/stdc/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@050330>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@050330> - <@05034b>)
	lib/std/math.ci:102: (23 bytes: <@050330> - <@050347>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @050330>      : 11 03                      dup.x2 sp(3)
	<absMod+2 @050332>    : 11 03                      dup.x2 sp(3)
	<absMod+4 @050334>    : 85                         mod.f64
	<absMod+5 @050335>    : 11 00                      dup.x2 sp(0)
	<absMod+7 @050337>    : 14 07                      set.x2 sp(7)
	<absMod+9 @050339>    : 1a                         load.z64
	<absMod+10 @05033a>   : 88                         clt.f64
	<absMod+11 @05033b>   : 06 0c 00 00                jz <absMod+23 @050347>
	lib/std/math.ci:103: (8 bytes: <@05033f> - <@050347>): return float64(.result := float64(val + mod));
	<absMod+15 @05033f>   : 11 03                      dup.x2 sp(3)
	<absMod+17 @050341>   : 11 03                      dup.x2 sp(3)
	<absMod+19 @050343>   : 81                         add.f64
	<absMod+20 @050344>   : 14 07                      set.x2 sp(7)
	<absMod+22 @050346>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@050347> - <@05034b>): return float64(.result := val);
	<absMod+23 @050347>   : 17 05 03                   mov.x2 sp(5, 3)
	<absMod+26 @05034a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:80: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:75: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	test/stdc/test.math.ci:71: referenced as `absMod`
	test/stdc/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050350>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@050350> - <@050361>)
	lib/std/math.ci:116: (13 bytes: <@050350> - <@05035d>): if (bool(a < b))
	<min @050350>      : 10 02                      dup.x1 sp(2)
	<min+2 @050352>    : 10 02                      dup.x1 sp(2)
	<min+4 @050354>    : 78                         clt.f32
	<min+5 @050355>    : 06 08 00 00                jz <min+13 @05035d>
	lib/std/math.ci:117: (4 bytes: <@050359> - <@05035d>): return float32(.result := a);
	<min+9 @050359>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @05035c>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@05035d> - <@050361>): return float32(.result := b);
	<min+13 @05035d>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @050360>   : 03                         ret
.usages:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050368>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@050368> - <@050379>)
	lib/std/math.ci:124: (13 bytes: <@050368> - <@050375>): if (bool(a < b))
	<min @050368>      : 11 03                      dup.x2 sp(3)
	<min+2 @05036a>    : 11 03                      dup.x2 sp(3)
	<min+4 @05036c>    : 88                         clt.f64
	<min+5 @05036d>    : 06 08 00 00                jz <min+13 @050375>
	lib/std/math.ci:125: (4 bytes: <@050371> - <@050375>): return float64(.result := a);
	<min+9 @050371>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @050374>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@050375> - <@050379>): return float64(.result := b);
	<min+13 @050375>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @050378>   : 03                         ret
.usages:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050380>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@050380> - <@050391>)
	lib/std/math.ci:138: (13 bytes: <@050380> - <@05038d>): if (bool(a > b))
	<max @050380>      : 10 02                      dup.x1 sp(2)
	<max+2 @050382>    : 10 02                      dup.x1 sp(2)
	<max+4 @050384>    : 79                         cgt.f32
	<max+5 @050385>    : 06 08 00 00                jz <max+13 @05038d>
	lib/std/math.ci:139: (4 bytes: <@050389> - <@05038d>): return float32(.result := a);
	<max+9 @050389>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @05038c>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@05038d> - <@050391>): return float32(.result := b);
	<max+13 @05038d>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @050390>   : 03                         ret
.usages:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050398>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@050398> - <@0503a9>)
	lib/std/math.ci:146: (13 bytes: <@050398> - <@0503a5>): if (bool(a > b))
	<max @050398>      : 11 03                      dup.x2 sp(3)
	<max+2 @05039a>    : 11 03                      dup.x2 sp(3)
	<max+4 @05039c>    : 89                         cgt.f64
	<max+5 @05039d>    : 06 08 00 00                jz <max+13 @0503a5>
	lib/std/math.ci:147: (4 bytes: <@0503a1> - <@0503a5>): return float64(.result := a);
	<max+9 @0503a1>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @0503a4>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@0503a5> - <@0503a9>): return float64(.result := b);
	<max+13 @0503a5>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @0503a8>   : 03                         ret
.usages:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0503b0>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@0503b0> - <@0503ce>)
	lib/std/math.ci:160: (13 bytes: <@0503b0> - <@0503bd>): if (bool(t < a))
	<clamp @0503b0>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @0503b2>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @0503b4>    : 78                         clt.f32
	<clamp+5 @0503b5>    : 06 08 00 00                jz <clamp+13 @0503bd>
	lib/std/math.ci:161: (4 bytes: <@0503b9> - <@0503bd>): return float32(.result := a);
	<clamp+9 @0503b9>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @0503bc>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@0503bd> - <@0503ca>): if (bool(t > b))
	<clamp+13 @0503bd>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @0503bf>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @0503c1>   : 79                         cgt.f32
	<clamp+18 @0503c2>   : 06 08 00 00                jz <clamp+26 @0503ca>
	lib/std/math.ci:164: (4 bytes: <@0503c6> - <@0503ca>): return float32(.result := b);
	<clamp+22 @0503c6>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @0503c9>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@0503ca> - <@0503ce>): return float32(.result := t);
	<clamp+26 @0503ca>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @0503cd>   : 03                         ret
.usages:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0503d0>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@0503d0> - <@0503ee>)
	lib/std/math.ci:171: (13 bytes: <@0503d0> - <@0503dd>): if (bool(t < a))
	<clamp @0503d0>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @0503d2>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @0503d4>    : 88                         clt.f64
	<clamp+5 @0503d5>    : 06 08 00 00                jz <clamp+13 @0503dd>
	lib/std/math.ci:172: (4 bytes: <@0503d9> - <@0503dd>): return float64(.result := a);
	<clamp+9 @0503d9>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @0503dc>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@0503dd> - <@0503ea>): if (bool(t > b))
	<clamp+13 @0503dd>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @0503df>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @0503e1>   : 89                         cgt.f64
	<clamp+18 @0503e2>   : 06 08 00 00                jz <clamp+26 @0503ea>
	lib/std/math.ci:175: (4 bytes: <@0503e6> - <@0503ea>): return float64(.result := b);
	<clamp+22 @0503e6>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @0503e9>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@0503ea> - <@0503ee>): return float64(.result := t);
	<clamp+26 @0503ea>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @0503ed>   : 03                         ret
.usages:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@0503f0>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@0503f0> - <@050438>)
	lib/std/math.ci:202: (13 bytes: <@0503f0> - <@0503fd>): if (bool(data.length == (0)))
	<min @0503f0>      : 10 02                      dup.x1 sp(2)
	<min+2 @0503f2>    : 19                         load.z32
	<min+3 @0503f3>    : 57                         ceq.i32
	<min+4 @0503f4>    : 06 09 00 00                jz <min+13 @0503fd>
	lib/std/math.ci:203: (5 bytes: <@0503f8> - <@0503fd>): return float64(.result := nan);
	<min+8 @0503f8>    : 1b                         load.z128
	<min+9 @0503f9>    : 84                         div.f64
	<min+10 @0503fa>   : 14 05                      set.x2 sp(5)
	<min+12 @0503fc>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@0503fd> - <@050400>): result: float64 := data[0]
	<min+13 @0503fd>   : 10 01                      dup.x1 sp(1)
	<min+15 @0503ff>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@050400> - <@050435>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @050400>   : 1c 01 00 00 00             load.c32 1
	<min+21 @050405>   : 04 23 00 00                jmp <min+56 @050428>
	lib/std/math.ci:207: (27 bytes: <@050409> - <@050424>): if (bool(result > data[i]))
	<min+25 @050409>   : 11 01                      dup.x2 sp(1)
	<min+27 @05040b>   : 10 06                      dup.x1 sp(6)
	<min+29 @05040d>   : 10 03                      dup.x1 sp(3)
	<min+31 @05040f>   : 0d 08 00 00                mad.u32 8
	<min+35 @050413>   : 23                         load.i64
	<min+36 @050414>   : 89                         cgt.f64
	<min+37 @050415>   : 06 0f 00 00                jz <min+52 @050424>
	lib/std/math.ci:208: (11 bytes: <@050419> - <@050424>): float64(result := data[i]);
	<min+41 @050419>   : 10 04                      dup.x1 sp(4)
	<min+43 @05041b>   : 10 01                      dup.x1 sp(1)
	<min+45 @05041d>   : 0d 08 00 00                mad.u32 8
	<min+49 @050421>   : 23                         load.i64
	<min+50 @050422>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:206: (4 bytes: <@050424> - <@050428>): int32(i := int32(i + 1))
	<min+52 @050424>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@050428> - <@050431>): bool(i < (data.length))
	<min+56 @050428>   : 10 00                      dup.x1 sp(0)
	<min+58 @05042a>   : 10 06                      dup.x1 sp(6)
	<min+60 @05042c>   : 58                         clt.i32
	<min+61 @05042d>   : 05 dc ff ff                jnz <min+25 @050409>
	<min+65 @050431>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@050435> - <@050438>): return float64(.result := result);
	<min+69 @050435>   : 14 05                      set.x2 sp(5)
	<min+71 @050437>   : 03                         ret
.usages:
	test/stdc/test.math.ci:39: referenced as `min`
	test/stdc/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@050438>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@050438> - <@050480>)
	lib/std/math.ci:216: (13 bytes: <@050438> - <@050445>): if (bool(data.length == (0)))
	<max @050438>      : 10 02                      dup.x1 sp(2)
	<max+2 @05043a>    : 19                         load.z32
	<max+3 @05043b>    : 57                         ceq.i32
	<max+4 @05043c>    : 06 09 00 00                jz <max+13 @050445>
	lib/std/math.ci:217: (5 bytes: <@050440> - <@050445>): return float64(.result := nan);
	<max+8 @050440>    : 1b                         load.z128
	<max+9 @050441>    : 84                         div.f64
	<max+10 @050442>   : 14 05                      set.x2 sp(5)
	<max+12 @050444>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@050445> - <@050448>): result: float64 := data[0]
	<max+13 @050445>   : 10 01                      dup.x1 sp(1)
	<max+15 @050447>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@050448> - <@05047d>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @050448>   : 1c 01 00 00 00             load.c32 1
	<max+21 @05044d>   : 04 23 00 00                jmp <max+56 @050470>
	lib/std/math.ci:221: (27 bytes: <@050451> - <@05046c>): if (bool(result < data[i]))
	<max+25 @050451>   : 11 01                      dup.x2 sp(1)
	<max+27 @050453>   : 10 06                      dup.x1 sp(6)
	<max+29 @050455>   : 10 03                      dup.x1 sp(3)
	<max+31 @050457>   : 0d 08 00 00                mad.u32 8
	<max+35 @05045b>   : 23                         load.i64
	<max+36 @05045c>   : 88                         clt.f64
	<max+37 @05045d>   : 06 0f 00 00                jz <max+52 @05046c>
	lib/std/math.ci:222: (11 bytes: <@050461> - <@05046c>): float64(result := data[i]);
	<max+41 @050461>   : 10 04                      dup.x1 sp(4)
	<max+43 @050463>   : 10 01                      dup.x1 sp(1)
	<max+45 @050465>   : 0d 08 00 00                mad.u32 8
	<max+49 @050469>   : 23                         load.i64
	<max+50 @05046a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:220: (4 bytes: <@05046c> - <@050470>): int32(i := int32(i + 1))
	<max+52 @05046c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@050470> - <@050479>): bool(i < (data.length))
	<max+56 @050470>   : 10 00                      dup.x1 sp(0)
	<max+58 @050472>   : 10 06                      dup.x1 sp(6)
	<max+60 @050474>   : 58                         clt.i32
	<max+61 @050475>   : 05 dc ff ff                jnz <max+25 @050451>
	<max+65 @050479>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@05047d> - <@050480>): return float64(.result := result);
	<max+69 @05047d>   : 14 05                      set.x2 sp(5)
	<max+71 @05047f>   : 03                         ret
.usages:
	test/stdc/test.math.ci:41: referenced as `max`
	test/stdc/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@050480>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@050480> - <@0504a8>)
	lib/std/math.ci:230: (1 byte: <@050480> - <@050481>): result: float64 := 0
	<sum @050480>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@050481> - <@0504a5>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @050481>    : 6a                         i64.2i32
	<sum+2 @050482>    : 04 16 00 00                jmp <sum+24 @050498>
	lib/std/math.ci:232: (14 bytes: <@050486> - <@050494>): float64(result := float64(result + data[i]));
	<sum+6 @050486>    : 11 01                      dup.x2 sp(1)
	<sum+8 @050488>    : 10 06                      dup.x1 sp(6)
	<sum+10 @05048a>   : 10 03                      dup.x1 sp(3)
	<sum+12 @05048c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @050490>   : 23                         load.i64
	<sum+17 @050491>   : 81                         add.f64
	<sum+18 @050492>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:231: (4 bytes: <@050494> - <@050498>): int32(i := int32(i + 1))
	<sum+20 @050494>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@050498> - <@0504a1>): bool(i < (data.length))
	<sum+24 @050498>   : 10 00                      dup.x1 sp(0)
	<sum+26 @05049a>   : 10 06                      dup.x1 sp(6)
	<sum+28 @05049c>   : 58                         clt.i32
	<sum+29 @05049d>   : 05 e9 ff ff                jnz <sum+6 @050486>
	<sum+33 @0504a1>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@0504a5> - <@0504a8>): return float64(.result := result);
	<sum+37 @0504a5>   : 14 05                      set.x2 sp(5)
	<sum+39 @0504a7>   : 03                         ret
.usages:
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	test/stdc/test.math.ci:44: referenced as `sum`
	test/stdc/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/stdc/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@0504a8>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@0504a8> - <@0504d7>)
	lib/std/math.ci:257: (1 byte: <@0504a8> - <@0504a9>): result: float64 := 0
	<eval @0504a8>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@0504a9> - <@0504d4>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @0504a9>    : 10 04                      dup.x1 sp(4)
	<eval+3 @0504ab>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @0504af>    : 04 19 00 00                jmp <eval+32 @0504c8>
	lib/std/math.ci:259: (17 bytes: <@0504b3> - <@0504c4>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @0504b3>   : 11 01                      dup.x2 sp(1)
	<eval+13 @0504b5>   : 11 08                      dup.x2 sp(8)
	<eval+15 @0504b7>   : 83                         mul.f64
	<eval+16 @0504b8>   : 10 06                      dup.x1 sp(6)
	<eval+18 @0504ba>   : 10 03                      dup.x1 sp(3)
	<eval+20 @0504bc>   : 0d 08 00 00                mad.u32 8
	<eval+24 @0504c0>   : 23                         load.i64
	<eval+25 @0504c1>   : 81                         add.f64
	<eval+26 @0504c2>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:258: (4 bytes: <@0504c4> - <@0504c8>): int32(i := int32(i - 1))
	<eval+28 @0504c4>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@0504c8> - <@0504d0>): bool(i >= 0)
	<eval+32 @0504c8>   : 10 00                      dup.x1 sp(0)
	<eval+34 @0504ca>   : 19                         load.z32
	<eval+35 @0504cb>   : 58                         clt.i32
	<eval+36 @0504cc>   : 06 e7 ff ff                jz <eval+11 @0504b3>
	<eval+40 @0504d0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@0504d4> - <@0504d7>): return float64(.result := result);
	<eval+44 @0504d4>   : 14 07                      set.x2 sp(7)
	<eval+46 @0504d6>   : 03                         ret
.usages:
	test/stdc/test.math.ci:55: referenced as `eval`
	test/stdc/test.math.ci:54: referenced as `eval`
	test/stdc/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@0504d8>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@0504d8> - <@050511>)
	lib/std/math.ci:266: (53 bytes: <@0504d8> - <@05050d>): if (bool(a < b))
	<cmp @0504d8>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @0504da>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @0504dc>    : 78                         clt.f32
	<cmp+5 @0504dd>    : 06 1c 00 00                jz <cmp+33 @0504f9>
	lib/std/math.ci:267: (20 bytes: <@0504e1> - <@0504f5>): if (bool(eps < (float32(b - a))))
	<cmp+9 @0504e1>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @0504e3>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @0504e5>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @0504e7>   : 72                         sub.f32
	<cmp+16 @0504e8>   : 78                         clt.f32
	<cmp+17 @0504e9>   : 06 0c 00 00                jz <cmp+29 @0504f5>
	lib/std/math.ci:268: (8 bytes: <@0504ed> - <@0504f5>): return int32(.result := int32(-1));
	<cmp+21 @0504ed>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @0504f2>   : 13 05                      set.x1 sp(5)
	<cmp+28 @0504f4>   : 03                         ret
	<cmp+29 @0504f5>   : 04 18 00 00                jmp <cmp+53 @05050d>
	lib/std/math.ci:272: (20 bytes: <@0504f9> - <@05050d>): if (bool(eps < (float32(a - b))))
	<cmp+33 @0504f9>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @0504fb>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @0504fd>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @0504ff>   : 72                         sub.f32
	<cmp+40 @050500>   : 78                         clt.f32
	<cmp+41 @050501>   : 06 0c 00 00                jz <cmp+53 @05050d>
	lib/std/math.ci:273: (8 bytes: <@050505> - <@05050d>): return int32(.result := int32(+1));
	<cmp+45 @050505>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05050a>   : 13 05                      set.x1 sp(5)
	<cmp+52 @05050c>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@05050d> - <@050511>): return int32(.result := 0);
	<cmp+53 @05050d>   : 19                         load.z32
	<cmp+54 @05050e>   : 13 05                      set.x1 sp(5)
	<cmp+56 @050510>   : 03                         ret
.usages:
	test/stdc/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@050518>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@050518> - <@050551>)
	lib/std/math.ci:281: (53 bytes: <@050518> - <@05054d>): if (bool(a < b))
	<cmp @050518>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @05051a>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @05051c>    : 88                         clt.f64
	<cmp+5 @05051d>    : 06 1c 00 00                jz <cmp+33 @050539>
	lib/std/math.ci:282: (20 bytes: <@050521> - <@050535>): if (bool(eps < (float64(b - a))))
	<cmp+9 @050521>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @050523>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @050525>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @050527>   : 82                         sub.f64
	<cmp+16 @050528>   : 88                         clt.f64
	<cmp+17 @050529>   : 06 0c 00 00                jz <cmp+29 @050535>
	lib/std/math.ci:283: (8 bytes: <@05052d> - <@050535>): return int32(.result := int32(-1));
	<cmp+21 @05052d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @050532>   : 13 08                      set.x1 sp(8)
	<cmp+28 @050534>   : 03                         ret
	<cmp+29 @050535>   : 04 18 00 00                jmp <cmp+53 @05054d>
	lib/std/math.ci:287: (20 bytes: <@050539> - <@05054d>): if (bool(eps < (float64(a - b))))
	<cmp+33 @050539>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @05053b>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @05053d>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @05053f>   : 82                         sub.f64
	<cmp+40 @050540>   : 88                         clt.f64
	<cmp+41 @050541>   : 06 0c 00 00                jz <cmp+53 @05054d>
	lib/std/math.ci:288: (8 bytes: <@050545> - <@05054d>): return int32(.result := int32(+1));
	<cmp+45 @050545>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05054a>   : 13 08                      set.x1 sp(8)
	<cmp+52 @05054c>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@05054d> - <@050551>): return int32(.result := 0);
	<cmp+53 @05054d>   : 19                         load.z32
	<cmp+54 @05054e>   : 13 08                      set.x1 sp(8)
	<cmp+56 @050550>   : 03                         ret
.usages:
	test/stdc/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@050558>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@050558> - <@0506a7>)
	lib/std/math.ci:309: (2 bytes: <@050558> - <@05055a>): x: float64 := arg
	<sinCos @050558>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:310: (17 bytes: <@05055a> - <@05056b>): if (bool(x < (0)))
	<sinCos+2 @05055a>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @05055c>    : 1a                         load.z64
	<sinCos+5 @05055d>    : 88                         clt.f64
	<sinCos+6 @05055e>    : 06 0d 00 00                jz <sinCos+19 @05056b>
	lib/std/math.ci:311: (1 byte: <@050562> - <@050563>): float64(x := float64(-x));
	<sinCos+10 @050562>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@050563> - <@05056b>): int32(quad := int32(quad + 2));
	<sinCos+11 @050563>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @050565>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @050569>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:315: (1 byte: <@05056b> - <@05056c>): y: float64
	<sinCos+19 @05056b>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@05056c> - <@050584>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @05056c>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @05056e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @050577>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @050580>   : 84                         div.f64
	<sinCos+41 @050581>   : 83                         mul.f64
	<sinCos+42 @050582>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:317: (124 bytes: <@050584> - <@050600>): if (bool(x > (32764)))
	<sinCos+44 @050584>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @050586>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05058f>   : 89                         cgt.f64
	<sinCos+56 @050590>   : 06 54 00 00                jz <sinCos+140 @0505e4>
	lib/std/math.ci:318: (1 byte: <@050594> - <@050595>): e: float64
	<sinCos+60 @050594>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@050595> - <@0505a7>): float64(y := modf(void(x, e)));
	<sinCos+61 @050595>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @050597>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05059b>   : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @0505a0>   : 02                         call
	<sinCos+73 @0505a1>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @0505a5>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:320: (4 bytes: <@0505a7> - <@0505ab>): float64(e := float64(e + (quad)));
	<sinCos+79 @0505a7>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @0505a9>   : 5d                         i32.2f64
	<sinCos+82 @0505aa>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@0505ab> - <@0505ac>): f: float64
	<sinCos+83 @0505ab>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@0505ac> - <@0505ca>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @0505ac>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @0505b5>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @0505b7>   : 83                         mul.f64
	<sinCos+96 @0505b8>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @0505bc>  : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @0505c1>  : 02                         call
	<sinCos+106 @0505c2>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @0505c6>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@0505ca> - <@0505dc>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @0505ca>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @0505cc>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @0505d5>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @0505d7>  : 83                         mul.f64
	<sinCos+128 @0505d8>  : 82                         sub.f64
	<sinCos+129 @0505d9>  : 8a                         f64.2i32
	<sinCos+130 @0505da>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @0505dc>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @0505e0>  : 04 20 00 00                jmp <sinCos+168 @050600>
	lib/std/math.ci:327: (3 bytes: <@0505e4> - <@0505e7>): k: int32 := x
	<sinCos+140 @0505e4>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @0505e6>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@0505e7> - <@0505ef>): float64(y := float64(x - (k)));
	<sinCos+143 @0505e7>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @0505e9>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @0505eb>  : 5d                         i32.2f64
	<sinCos+148 @0505ec>  : 82                         sub.f64
	<sinCos+149 @0505ed>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:329: (7 bytes: <@0505ef> - <@0505f6>): int32(quad := int32(quad + k));
	<sinCos+151 @0505ef>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @0505f1>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @0505f3>  : 51                         add.i32
	<sinCos+156 @0505f4>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:330: (6 bytes: <@0505f6> - <@0505fc>): int32(quad := int32(quad & 3));
	<sinCos+158 @0505f6>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @0505f8>  : 3f 02                      b32.and 0x003
	<sinCos+162 @0505fa>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @0505fc>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@050600> - <@050616>): if (int32(quad & 1))
	<sinCos+168 @050600>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @050602>  : 3f 01                      b32.and 0x001
	<sinCos+172 @050604>  : 06 12 00 00                jz <sinCos+190 @050616>
	lib/std/math.ci:333: (14 bytes: <@050608> - <@050616>): float64(y := float64((1) - y));
	<sinCos+176 @050608>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @050611>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @050613>  : 82                         sub.f64
	<sinCos+188 @050614>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:335: (13 bytes: <@050616> - <@050623>): if (bool(quad > 1))
	<sinCos+190 @050616>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @050618>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @05061d>  : 59                         cgt.i32
	<sinCos+198 @05061e>  : 06 05 00 00                jz <sinCos+203 @050623>
	lib/std/math.ci:336: (1 byte: <@050622> - <@050623>): float64(y := float64(-y));
	<sinCos+202 @050622>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@050623> - <@050628>): ysq: float64 := float64(y * y)
	<sinCos+203 @050623>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @050625>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @050627>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@050628> - <@050668>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @050628>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @050631>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @050633>  : 83                         mul.f64
	<sinCos+220 @050634>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @05063d>  : 81                         add.f64
	<sinCos+230 @05063e>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @050640>  : 83                         mul.f64
	<sinCos+233 @050641>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @05064a>  : 81                         add.f64
	<sinCos+243 @05064b>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @05064d>  : 83                         mul.f64
	<sinCos+246 @05064e>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @050657>  : 81                         add.f64
	<sinCos+256 @050658>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @05065a>  : 83                         mul.f64
	<sinCos+259 @05065b>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @050664>  : 81                         add.f64
	<sinCos+269 @050665>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @050667>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@050668> - <@05069b>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @050668>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @05066a>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @050673>  : 81                         add.f64
	<sinCos+284 @050674>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @050676>  : 83                         mul.f64
	<sinCos+287 @050677>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @050680>  : 81                         add.f64
	<sinCos+297 @050681>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @050683>  : 83                         mul.f64
	<sinCos+300 @050684>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05068d>  : 81                         add.f64
	<sinCos+310 @05068e>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @050690>  : 83                         mul.f64
	<sinCos+313 @050691>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05069a>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@05069b> - <@0506a7>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @05069b>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @05069d>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @05069f>  : 84                         div.f64
	<sinCos+328 @0506a0>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @0506a2>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @0506a6>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/stdc/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/stdc/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@0506a8>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@0506a8> - <@05081b>)
	lib/std/math.ci:365: (1 byte: <@0506a8> - <@0506a9>): complement: bool := false
	<tan @0506a8>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@0506a9> - <@0506aa>): negate: bool := false
	<tan+1 @0506a9>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@0506aa> - <@0506c1>): if (bool(arg < (0)))
	<tan+2 @0506aa>    : 11 03                      dup.x2 sp(3)
	<tan+4 @0506ac>    : 1a                         load.z64
	<tan+5 @0506ad>    : 88                         clt.f64
	<tan+6 @0506ae>    : 06 13 00 00                jz <tan+25 @0506c1>
	lib/std/math.ci:369: (5 bytes: <@0506b2> - <@0506b7>): float64(arg := float64(-arg));
	<tan+10 @0506b2>   : 11 03                      dup.x2 sp(3)
	<tan+12 @0506b4>   : 80                         neg.f64
	<tan+13 @0506b5>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:370: (10 bytes: <@0506b7> - <@0506c1>): bool(negate := true);
	<tan+15 @0506b7>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @0506bc>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @0506c0>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@0506c1> - <@0506d9>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @0506c1>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @0506ca>   : 11 05                      dup.x2 sp(5)
	<tan+36 @0506cc>   : 83                         mul.f64
	<tan+37 @0506cd>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @0506d6>   : 84                         div.f64
	<tan+47 @0506d7>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:374: (1 byte: <@0506d9> - <@0506da>): e: float64
	<tan+49 @0506d9>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@0506da> - <@0506ea>): x: float64 := modf(void(arg, e))
	<tan+50 @0506da>   : 11 07                      dup.x2 sp(7)
	<tan+52 @0506dc>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @0506e0>   : 1f 70 02 05 00             load.ref <@050270> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @0506e5>   : 02                         call
	<tan+62 @0506e6>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@0506ea> - <@0506f3>): i: int32 := int32(int32(e) % 4)
	<tan+66 @0506ea>   : 11 02                      dup.x2 sp(2)
	<tan+68 @0506ec>   : 8a                         f64.2i32
	<tan+69 @0506ed>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @0506f2>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@0506f3> - <@05076d>): if (bool(i == 0))
	<tan+75 @0506f3>   : 10 00                      dup.x1 sp(0)
	<tan+77 @0506f5>   : 19                         load.z32
	<tan+78 @0506f6>   : 57                         ceq.i32
	<tan+79 @0506f7>   : 05 76 00 00                jnz <tan+197 @05076d>
	lib/std/math.ci:379: (114 bytes: <@0506fb> - <@05076d>): if (bool(i == 1))
	<tan+83 @0506fb>   : 10 00                      dup.x1 sp(0)
	<tan+85 @0506fd>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @050702>   : 57                         ceq.i32
	<tan+91 @050703>   : 06 20 00 00                jz <tan+123 @050723>
	lib/std/math.ci:380: (14 bytes: <@050707> - <@050715>): float64(x := float64((1) - x));
	<tan+95 @050707>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @050710>  : 11 03                      dup.x2 sp(3)
	<tan+106 @050712>  : 82                         sub.f64
	<tan+107 @050713>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:381: (10 bytes: <@050715> - <@05071f>): bool(complement := true);
	<tan+109 @050715>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @05071a>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @05071e>  : 25                         store.i8
	<tan+119 @05071f>  : 04 4e 00 00                jmp <tan+197 @05076d>
	lib/std/math.ci:383: (74 bytes: <@050723> - <@05076d>): if (bool(i == 2))
	<tan+123 @050723>  : 10 00                      dup.x1 sp(0)
	<tan+125 @050725>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @05072a>  : 57                         ceq.i32
	<tan+131 @05072b>  : 06 1d 00 00                jz <tan+160 @050748>
	lib/std/math.ci:384: (11 bytes: <@05072f> - <@05073a>): bool(negate := bool(!negate));
	<tan+135 @05072f>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @050733>  : 20                         load.i8
	<tan+140 @050734>  : 0b                         not.b32
	<tan+141 @050735>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @050739>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@05073a> - <@050744>): bool(complement := true);
	<tan+146 @05073a>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @05073f>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @050743>  : 25                         store.i8
	<tan+156 @050744>  : 04 29 00 00                jmp <tan+197 @05076d>
	lib/std/math.ci:387: (37 bytes: <@050748> - <@05076d>): if (bool(i == 3))
	<tan+160 @050748>  : 10 00                      dup.x1 sp(0)
	<tan+162 @05074a>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @05074f>  : 57                         ceq.i32
	<tan+168 @050750>  : 06 1d 00 00                jz <tan+197 @05076d>
	lib/std/math.ci:388: (14 bytes: <@050754> - <@050762>): float64(x := float64((1) - x));
	<tan+172 @050754>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @05075d>  : 11 03                      dup.x2 sp(3)
	<tan+183 @05075f>  : 82                         sub.f64
	<tan+184 @050760>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:389: (11 bytes: <@050762> - <@05076d>): bool(negate := bool(!negate));
	<tan+186 @050762>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @050766>  : 20                         load.i8
	<tan+191 @050767>  : 0b                         not.b32
	<tan+192 @050768>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @05076c>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@05076d> - <@050772>): xsq: float64 := float64(x * x)
	<tan+197 @05076d>  : 11 01                      dup.x2 sp(1)
	<tan+199 @05076f>  : 11 03                      dup.x2 sp(3)
	<tan+201 @050771>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@050772> - <@0507b2>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @050772>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @05077b>  : 11 02                      dup.x2 sp(2)
	<tan+213 @05077d>  : 83                         mul.f64
	<tan+214 @05077e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @050787>  : 81                         add.f64
	<tan+224 @050788>  : 11 02                      dup.x2 sp(2)
	<tan+226 @05078a>  : 83                         mul.f64
	<tan+227 @05078b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @050794>  : 81                         add.f64
	<tan+237 @050795>  : 11 02                      dup.x2 sp(2)
	<tan+239 @050797>  : 83                         mul.f64
	<tan+240 @050798>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @0507a1>  : 81                         add.f64
	<tan+250 @0507a2>  : 11 02                      dup.x2 sp(2)
	<tan+252 @0507a4>  : 83                         mul.f64
	<tan+253 @0507a5>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @0507ae>  : 81                         add.f64
	<tan+263 @0507af>  : 11 05                      dup.x2 sp(5)
	<tan+265 @0507b1>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@0507b2> - <@0507d9>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @0507b2>  : 11 02                      dup.x2 sp(2)
	<tan+268 @0507b4>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @0507bd>  : 81                         add.f64
	<tan+278 @0507be>  : 11 04                      dup.x2 sp(4)
	<tan+280 @0507c0>  : 83                         mul.f64
	<tan+281 @0507c1>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @0507ca>  : 81                         add.f64
	<tan+291 @0507cb>  : 11 04                      dup.x2 sp(4)
	<tan+293 @0507cd>  : 83                         mul.f64
	<tan+294 @0507ce>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @0507d7>  : 81                         add.f64
	<tan+304 @0507d8>  : 84                         div.f64
	lib/std/math.ci:396: (40 bytes: <@0507d9> - <@050801>): if (complement)
	<tan+305 @0507d9>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @0507dd>  : 20                         load.i8
	<tan+310 @0507de>  : 06 23 00 00                jz <tan+345 @050801>
	lib/std/math.ci:397: (17 bytes: <@0507e2> - <@0507f3>): if (bool(result == (0)))
	<tan+314 @0507e2>  : 11 00                      dup.x2 sp(0)
	<tan+316 @0507e4>  : 1a                         load.z64
	<tan+317 @0507e5>  : 87                         ceq.f64
	<tan+318 @0507e6>  : 06 0d 00 00                jz <tan+331 @0507f3>
	lib/std/math.ci:398: (9 bytes: <@0507ea> - <@0507f3>): return float64(.result := nan);
	<tan+322 @0507ea>  : 1b                         load.z128
	<tan+323 @0507eb>  : 84                         div.f64
	<tan+324 @0507ec>  : 14 10                      set.x2 sp(16)
	<tan+326 @0507ee>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @0507f2>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@0507f3> - <@050801>): float64(result := float64((1) / result));
	<tan+331 @0507f3>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @0507fc>  : 11 02                      dup.x2 sp(2)
	<tan+342 @0507fe>  : 84                         div.f64
	<tan+343 @0507ff>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:402: (19 bytes: <@050801> - <@050814>): if (negate)
	<tan+345 @050801>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @050805>  : 20                         load.i8
	<tan+350 @050806>  : 06 0e 00 00                jz <tan+364 @050814>
	lib/std/math.ci:403: (10 bytes: <@05080a> - <@050814>): return float64(.result := float64(-result));
	<tan+354 @05080a>  : 11 00                      dup.x2 sp(0)
	<tan+356 @05080c>  : 80                         neg.f64
	<tan+357 @05080d>  : 14 10                      set.x2 sp(16)
	<tan+359 @05080f>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @050813>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@050814> - <@05081b>): return float64(.result := result);
	<tan+364 @050814>  : 14 0e                      set.x2 sp(14)
	<tan+366 @050816>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @05081a>  : 03                         ret
.usages:
	test/stdc/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@050820>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@050820> - <@050911>)
	lib/std/math.ci:421: (1 byte: <@050820> - <@050821>): negate: bool := false
	<sinh @050820>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@050821> - <@050838>): if (bool(x < (0)))
	<sinh+1 @050821>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @050823>    : 1a                         load.z64
	<sinh+4 @050824>    : 88                         clt.f64
	<sinh+5 @050825>    : 06 13 00 00                jz <sinh+24 @050838>
	lib/std/math.ci:423: (5 bytes: <@050829> - <@05082e>): float64(x := float64(-x));
	<sinh+9 @050829>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @05082b>   : 80                         neg.f64
	<sinh+12 @05082c>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:424: (10 bytes: <@05082e> - <@050838>): bool(negate := true);
	<sinh+14 @05082e>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @050833>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @050837>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@050838> - <@05085f>): if (bool(x > (21)))
	<sinh+24 @050838>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @05083a>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @050843>   : 89                         cgt.f64
	<sinh+36 @050844>   : 06 1b 00 00                jz <sinh+63 @05085f>
	lib/std/math.ci:428: (23 bytes: <@050848> - <@05085f>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @050848>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @05084a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @05084e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @050857>   : 84                         div.f64
	<sinh+56 @050858>   : 14 06                      set.x2 sp(6)
	<sinh+58 @05085a>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @05085e>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@05085f> - <@050860>): result: float64
	<sinh+63 @05085f>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@050860> - <@0508f7>): if (bool(x > 0.500000))
	<sinh+64 @050860>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @050862>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @05086b>   : 89                         cgt.f64
	<sinh+76 @05086c>   : 06 22 00 00                jz <sinh+110 @05088e>
	lib/std/math.ci:433: (26 bytes: <@050870> - <@05088a>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @050870>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @050872>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @050876>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @050878>   : 80                         neg.f64
	<sinh+89 @050879>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @05087d>   : 82                         sub.f64
	<sinh+94 @05087e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @050887>  : 84                         div.f64
	<sinh+104 @050888>  : 14 02                      set.x2 sp(2)
	<sinh+106 @05088a>  : 04 6d 00 00                jmp <sinh+215 @0508f7>
	lib/std/math.ci:436: (5 bytes: <@05088e> - <@050893>): sq: float64 := float64(x * x)
	<sinh+110 @05088e>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @050890>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @050892>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@050893> - <@0508c8>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @050893>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @05089c>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @05089e>  : 83                         mul.f64
	<sinh+127 @05089f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @0508a8>  : 81                         add.f64
	<sinh+137 @0508a9>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @0508ab>  : 83                         mul.f64
	<sinh+140 @0508ac>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @0508b5>  : 81                         add.f64
	<sinh+150 @0508b6>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @0508b8>  : 83                         mul.f64
	<sinh+153 @0508b9>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @0508c2>  : 81                         add.f64
	<sinh+163 @0508c3>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @0508c5>  : 83                         mul.f64
	<sinh+166 @0508c6>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:438: (43 bytes: <@0508c8> - <@0508f3>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @0508c8>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @0508ca>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @0508cc>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @0508d5>  : 81                         add.f64
	<sinh+182 @0508d6>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @0508d8>  : 83                         mul.f64
	<sinh+185 @0508d9>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @0508e2>  : 81                         add.f64
	<sinh+195 @0508e3>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @0508e5>  : 83                         mul.f64
	<sinh+198 @0508e6>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @0508ef>  : 81                         add.f64
	<sinh+208 @0508f0>  : 84                         div.f64
	<sinh+209 @0508f1>  : 14 04                      set.x2 sp(4)
	<sinh+211 @0508f3>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@0508f7> - <@05090a>): if (negate)
	<sinh+215 @0508f7>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @0508fb>  : 20                         load.i8
	<sinh+220 @0508fc>  : 06 0e 00 00                jz <sinh+234 @05090a>
	lib/std/math.ci:442: (10 bytes: <@050900> - <@05090a>): return float64(.result := float64(-result));
	<sinh+224 @050900>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @050902>  : 80                         neg.f64
	<sinh+227 @050903>  : 14 08                      set.x2 sp(8)
	<sinh+229 @050905>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @050909>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@05090a> - <@050911>): return float64(.result := result);
	<sinh+234 @05090a>  : 14 06                      set.x2 sp(6)
	<sinh+236 @05090c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @050910>  : 03                         ret
.usages:
	test/stdc/test.math.ci:60: referenced as `sinh`
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@050918>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@050918> - <@050963>)
	lib/std/math.ci:449: (13 bytes: <@050918> - <@050925>): if (bool(x < (0)))
	<cosh @050918>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @05091a>    : 1a                         load.z64
	<cosh+3 @05091b>    : 88                         clt.f64
	<cosh+4 @05091c>    : 06 09 00 00                jz <cosh+13 @050925>
	lib/std/math.ci:450: (5 bytes: <@050920> - <@050925>): float64(x := float64(-x));
	<cosh+8 @050920>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @050922>   : 80                         neg.f64
	<cosh+11 @050923>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:452: (35 bytes: <@050925> - <@050948>): if (bool(x > (21)))
	<cosh+13 @050925>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @050927>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @050930>   : 89                         cgt.f64
	<cosh+25 @050931>   : 06 17 00 00                jz <cosh+48 @050948>
	lib/std/math.ci:453: (19 bytes: <@050935> - <@050948>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @050935>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @050937>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @05093b>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @050944>   : 84                         div.f64
	<cosh+45 @050945>   : 14 05                      set.x2 sp(5)
	<cosh+47 @050947>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@050948> - <@050963>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @050948>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @05094a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @05094e>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @050950>   : 80                         neg.f64
	<cosh+57 @050951>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @050955>   : 81                         add.f64
	<cosh+62 @050956>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @05095f>   : 84                         div.f64
	<cosh+72 @050960>   : 14 05                      set.x2 sp(5)
	<cosh+74 @050962>   : 03                         ret
.usages:
	test/stdc/test.math.ci:61: referenced as `cosh`
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@050968>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@050968> - <@050a0e>)
	lib/std/math.ci:464: (12 bytes: <@050968> - <@050974>): if (bool(x == (0)))
	<asin @050968>      : 11 01                      dup.x2 sp(1)
	<asin+2 @05096a>    : 1a                         load.z64
	<asin+3 @05096b>    : 87                         ceq.f64
	<asin+4 @05096c>    : 06 08 00 00                jz <asin+12 @050974>
	lib/std/math.ci:466: (4 bytes: <@050970> - <@050974>): return float64(.result := x);
	<asin+8 @050970>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @050973>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@050974> - <@050975>): negate: bool := false
	<asin+12 @050974>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@050975> - <@05098c>): if (bool(x < (0)))
	<asin+13 @050975>   : 11 02                      dup.x2 sp(2)
	<asin+15 @050977>   : 1a                         load.z64
	<asin+16 @050978>   : 88                         clt.f64
	<asin+17 @050979>   : 06 13 00 00                jz <asin+36 @05098c>
	lib/std/math.ci:471: (10 bytes: <@05097d> - <@050987>): bool(negate := true);
	<asin+21 @05097d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @050982>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @050986>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@050987> - <@05098c>): float64(x := float64(-x));
	<asin+31 @050987>   : 11 02                      dup.x2 sp(2)
	<asin+33 @050989>   : 80                         neg.f64
	<asin+34 @05098a>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:475: (25 bytes: <@05098c> - <@0509a5>): if (bool(x > (1)))
	<asin+36 @05098c>   : 11 02                      dup.x2 sp(2)
	<asin+38 @05098e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @050997>   : 89                         cgt.f64
	<asin+48 @050998>   : 06 0d 00 00                jz <asin+61 @0509a5>
	lib/std/math.ci:477: (9 bytes: <@05099c> - <@0509a5>): return float64(.result := nan);
	<asin+52 @05099c>   : 1b                         load.z128
	<asin+53 @05099d>   : 84                         div.f64
	<asin+54 @05099e>   : 14 06                      set.x2 sp(6)
	<asin+56 @0509a0>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @0509a4>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@0509a5> - <@0509b8>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @0509a5>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @0509ae>   : 11 04                      dup.x2 sp(4)
	<asin+72 @0509b0>   : 11 06                      dup.x2 sp(6)
	<asin+74 @0509b2>   : 83                         mul.f64
	<asin+75 @0509b3>   : 82                         sub.f64
	<asin+76 @0509b4>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@0509b8> - <@0509f4>): if (bool(x > 0.700000))
	<asin+80 @0509b8>   : 11 04                      dup.x2 sp(4)
	<asin+82 @0509ba>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @0509c3>   : 89                         cgt.f64
	<asin+92 @0509c4>   : 06 26 00 00                jz <asin+130 @0509ea>
	lib/std/math.ci:482: (30 bytes: <@0509c8> - <@0509e6>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @0509c8>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @0509d1>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @0509da>  : 84                         div.f64
	<asin+115 @0509db>  : 11 02                      dup.x2 sp(2)
	<asin+117 @0509dd>  : 11 08                      dup.x2 sp(8)
	<asin+119 @0509df>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @0509e3>  : 82                         sub.f64
	<asin+124 @0509e4>  : 14 02                      set.x2 sp(2)
	<asin+126 @0509e6>  : 04 0e 00 00                jmp <asin+140 @0509f4>
	lib/std/math.ci:485: (10 bytes: <@0509ea> - <@0509f4>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @0509ea>  : 11 04                      dup.x2 sp(4)
	<asin+132 @0509ec>  : 11 02                      dup.x2 sp(2)
	<asin+134 @0509ee>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @0509f2>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:488: (19 bytes: <@0509f4> - <@050a07>): if (negate)
	<asin+140 @0509f4>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @0509f8>  : 20                         load.i8
	<asin+145 @0509f9>  : 06 0e 00 00                jz <asin+159 @050a07>
	lib/std/math.ci:489: (10 bytes: <@0509fd> - <@050a07>): return float64(.result := float64(-result));
	<asin+149 @0509fd>  : 11 00                      dup.x2 sp(0)
	<asin+151 @0509ff>  : 80                         neg.f64
	<asin+152 @050a00>  : 14 08                      set.x2 sp(8)
	<asin+154 @050a02>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @050a06>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@050a07> - <@050a0e>): return float64(.result := result);
	<asin+159 @050a07>  : 14 06                      set.x2 sp(6)
	<asin+161 @050a09>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @050a0d>  : 03                         ret
.usages:
	test/stdc/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/stdc/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@019b78>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050a10>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@050a10> - <@050a17>)
	lib/std/math.Complex.ci:25: (7 bytes: <@050a10> - <@050a17>): return void(.result := {...});
	<Complex @050a10>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@050a13> - <@050a16>): void(.result.im := (0))
	<Complex+3 @050a13>    : 1a                         load.z64
	<Complex+4 @050a14>    : 14 07                      set.x2 sp(7)
	<Complex+6 @050a16>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050a18>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@050a18> - <@050a1f>)
	lib/std/math.Complex.ci:32: (7 bytes: <@050a18> - <@050a1f>): return void(.result := {...});
	<Complex @050a18>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes: <@050a1b> - <@050a1e>): void(.result.im := im);
	<Complex+3 @050a1b>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @050a1e>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/vec/vec4f.ci:67: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@050a20>
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@050a20> - <@050a9b>)
	lib/std/math.Complex.ci:87: (79 bytes: <@050a20> - <@050a6f>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @050a20>      : 1a                         load.z64
	<div+1 @050a21>    : 11 03                      dup.x2 sp(3)
	<div+3 @050a23>    : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<div+8 @050a28>    : 02                         call
	<div+9 @050a29>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @050a2d>   : 1a                         load.z64
	<div+14 @050a2e>   : 11 07                      dup.x2 sp(7)
	<div+16 @050a30>   : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<div+21 @050a35>   : 02                         call
	<div+22 @050a36>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @050a3a>   : 88                         clt.f64
	<div+27 @050a3b>   : 05 34 00 00                jnz <div+79 @050a6f>
	lib/std/math.Complex.ci:88: (5 bytes: <@050a3f> - <@050a44>): r: float64 := float64(b.im / b.re)
	<div+31 @050a3f>   : 11 03                      dup.x2 sp(3)
	<div+33 @050a41>   : 11 03                      dup.x2 sp(3)
	<div+35 @050a43>   : 84                         div.f64
	lib/std/math.Complex.ci:89: (8 bytes: <@050a44> - <@050a4c>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @050a44>   : 11 03                      dup.x2 sp(3)
	<div+38 @050a46>   : 11 02                      dup.x2 sp(2)
	<div+40 @050a48>   : 11 09                      dup.x2 sp(9)
	<div+42 @050a4a>   : 83                         mul.f64
	<div+43 @050a4b>   : 81                         add.f64
	lib/std/math.Complex.ci:90: (31 bytes: <@050a4c> - <@050a6b>): return void(.result := {...});
	<div+44 @050a4c>   : 11 09                      dup.x2 sp(9)
	<div+46 @050a4e>   : 11 04                      dup.x2 sp(4)
	<div+48 @050a50>   : 11 0f                      dup.x2 sp(15)
	<div+50 @050a52>   : 83                         mul.f64
	<div+51 @050a53>   : 81                         add.f64
	<div+52 @050a54>   : 11 02                      dup.x2 sp(2)
	<div+54 @050a56>   : 84                         div.f64
	<div+55 @050a57>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes: <@050a59> - <@050a66>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @050a59>   : 11 0b                      dup.x2 sp(11)
	<div+59 @050a5b>   : 11 04                      dup.x2 sp(4)
	<div+61 @050a5d>   : 11 0d                      dup.x2 sp(13)
	<div+63 @050a5f>   : 83                         mul.f64
	<div+64 @050a60>   : 82                         sub.f64
	<div+65 @050a61>   : 11 02                      dup.x2 sp(2)
	<div+67 @050a63>   : 84                         div.f64
	<div+68 @050a64>   : 14 11                      set.x2 sp(17)
	<div+70 @050a66>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @050a6a>   : 03                         ret
	<div+75 @050a6b>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes: <@050a6f> - <@050a74>): r: float64 := float64(b.re / b.im)
	<div+79 @050a6f>   : 11 01                      dup.x2 sp(1)
	<div+81 @050a71>   : 11 05                      dup.x2 sp(5)
	<div+83 @050a73>   : 84                         div.f64
	lib/std/math.Complex.ci:96: (8 bytes: <@050a74> - <@050a7c>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @050a74>   : 11 05                      dup.x2 sp(5)
	<div+86 @050a76>   : 11 02                      dup.x2 sp(2)
	<div+88 @050a78>   : 11 07                      dup.x2 sp(7)
	<div+90 @050a7a>   : 83                         mul.f64
	<div+91 @050a7b>   : 81                         add.f64
	lib/std/math.Complex.ci:97: (31 bytes: <@050a7c> - <@050a9b>): return void(.result := {...});
	<div+92 @050a7c>   : 11 09                      dup.x2 sp(9)
	<div+94 @050a7e>   : 11 04                      dup.x2 sp(4)
	<div+96 @050a80>   : 83                         mul.f64
	<div+97 @050a81>   : 11 0d                      dup.x2 sp(13)
	<div+99 @050a83>   : 81                         add.f64
	<div+100 @050a84>  : 11 02                      dup.x2 sp(2)
	<div+102 @050a86>  : 84                         div.f64
	<div+103 @050a87>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes: <@050a89> - <@050a96>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @050a89>  : 11 0b                      dup.x2 sp(11)
	<div+107 @050a8b>  : 11 04                      dup.x2 sp(4)
	<div+109 @050a8d>  : 83                         mul.f64
	<div+110 @050a8e>  : 11 0b                      dup.x2 sp(11)
	<div+112 @050a90>  : 82                         sub.f64
	<div+113 @050a91>  : 11 02                      dup.x2 sp(2)
	<div+115 @050a93>  : 84                         div.f64
	<div+116 @050a94>  : 14 11                      set.x2 sp(17)
	<div+118 @050a96>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @050a9a>  : 03                         ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@050aa0>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@050aa0> - <@050abf>)
	lib/std/math.Complex.ci:115: (11 bytes: <@050aa0> - <@050aab>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @050aa0>      : 11 01                      dup.x2 sp(1)
	<inv+2 @050aa2>    : 11 03                      dup.x2 sp(3)
	<inv+4 @050aa4>    : 83                         mul.f64
	<inv+5 @050aa5>    : 11 05                      dup.x2 sp(5)
	<inv+7 @050aa7>    : 11 07                      dup.x2 sp(7)
	<inv+9 @050aa9>    : 83                         mul.f64
	<inv+10 @050aaa>   : 81                         add.f64
	lib/std/math.Complex.ci:116: (20 bytes: <@050aab> - <@050abf>): return void(.result := {...});
	<inv+11 @050aab>   : 11 03                      dup.x2 sp(3)
	<inv+13 @050aad>   : 11 02                      dup.x2 sp(2)
	<inv+15 @050aaf>   : 84                         div.f64
	<inv+16 @050ab0>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes: <@050ab2> - <@050aba>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @050ab2>   : 11 05                      dup.x2 sp(5)
	<inv+20 @050ab4>   : 80                         neg.f64
	<inv+21 @050ab5>   : 11 02                      dup.x2 sp(2)
	<inv+23 @050ab7>   : 84                         div.f64
	<inv+24 @050ab8>   : 14 0b                      set.x2 sp(11)
	<inv+26 @050aba>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @050abe>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@050ac0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@050ac0> - <@050b24>)
	lib/std/math.Complex.ci:133: (23 bytes: <@050ac0> - <@050ad7>): r: float64 := abs(a)
	<pow @050ac0>      : 12 05                      dup.x4 sp(5)
	<pow+2 @050ac2>    : 11 00                      dup.x2 sp(0)
	<pow+4 @050ac4>    : 11 02                      dup.x2 sp(2)
	<pow+6 @050ac6>    : 83                         mul.f64
	<pow+7 @050ac7>    : 11 04                      dup.x2 sp(4)
	<pow+9 @050ac9>    : 11 06                      dup.x2 sp(6)
	<pow+11 @050acb>   : 83                         mul.f64
	<pow+12 @050acc>   : 81                         add.f64
	<pow+13 @050acd>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @050ad1>   : 14 04                      set.x2 sp(4)
	<pow+19 @050ad3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes: <@050ad7> - <@050ae7>): t: float64 := arg(a)
	<pow+23 @050ad7>   : 12 07                      dup.x4 sp(7)
	<pow+25 @050ad9>   : 11 00                      dup.x2 sp(0)
	<pow+27 @050adb>   : 11 04                      dup.x2 sp(4)
	<pow+29 @050add>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @050ae1>   : 14 04                      set.x2 sp(4)
	<pow+35 @050ae3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes: <@050ae7> - <@050af6>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @050ae7>   : 11 05                      dup.x2 sp(5)
	<pow+41 @050ae9>   : 11 02                      dup.x2 sp(2)
	<pow+43 @050aeb>   : 83                         mul.f64
	<pow+44 @050aec>   : 11 09                      dup.x2 sp(9)
	<pow+46 @050aee>   : 11 06                      dup.x2 sp(6)
	<pow+48 @050af0>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @050af4>   : 83                         mul.f64
	<pow+53 @050af5>   : 81                         add.f64
	lib/std/math.Complex.ci:136: (19 bytes: <@050af6> - <@050b09>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @050af6>   : 11 04                      dup.x2 sp(4)
	<pow+56 @050af8>   : 11 09                      dup.x2 sp(9)
	<pow+58 @050afa>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @050afe>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @050b00>   : 80                         neg.f64
	<pow+65 @050b01>   : 11 06                      dup.x2 sp(6)
	<pow+67 @050b03>   : 83                         mul.f64
	<pow+68 @050b04>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @050b08>   : 83                         mul.f64
	lib/std/math.Complex.ci:137: (27 bytes: <@050b09> - <@050b24>): return void(.result := {...});
	<pow+73 @050b09>   : 11 00                      dup.x2 sp(0)
	<pow+75 @050b0b>   : 11 04                      dup.x2 sp(4)
	<pow+77 @050b0d>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @050b11>   : 83                         mul.f64
	<pow+82 @050b12>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes: <@050b14> - <@050b1f>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @050b14>   : 11 00                      dup.x2 sp(0)
	<pow+86 @050b16>   : 11 04                      dup.x2 sp(4)
	<pow+88 @050b18>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @050b1c>   : 83                         mul.f64
	<pow+93 @050b1d>   : 14 15                      set.x2 sp(21)
	<pow+95 @050b1f>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @050b23>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@050b28>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@050b28> - <@050b4e>)
	lib/std/string.ci:5: (16 bytes: <@050b28> - <@050b38>): if (bool((str) == null))
	<length @050b28>      : 10 01                      dup.x1 sp(1)
	<length+2 @050b2a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @050b2f>    : 57                         ceq.i32
	<length+8 @050b30>    : 06 08 00 00                jz <length+16 @050b38>
	lib/std/string.ci:6: (4 bytes: <@050b34> - <@050b38>): return int32(.result := 0);
	<length+12 @050b34>   : 19                         load.z32
	<length+13 @050b35>   : 13 03                      set.x1 sp(3)
	<length+15 @050b37>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@050b38> - <@050b39>): result: int32 := 0
	<length+16 @050b38>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@050b39> - <@050b4b>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @050b39>   : 04 08 00 00                jmp <length+25 @050b41>
	lib/std/string.ci:9: (4 bytes: <@050b3d> - <@050b41>): int32(result := int32(result + 1))
	<length+21 @050b3d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@050b41> - <@050b4b>): str[result]
	<length+25 @050b41>   : 10 02                      dup.x1 sp(2)
	<length+27 @050b43>   : 10 01                      dup.x1 sp(1)
	<length+29 @050b45>   : 51                         add.i32
	<length+30 @050b46>   : 20                         load.i8
	<length+31 @050b47>   : 05 f6 ff ff                jnz <length+21 @050b3d>
	lib/std/string.ci:11: (3 bytes: <@050b4b> - <@050b4e>): return int32(.result := result);
	<length+35 @050b4b>   : 13 03                      set.x1 sp(3)
	<length+37 @050b4d>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050b50>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@050b50> - <@050b82>)
	lib/std/string.ci:16: (42 bytes: <@050b50> - <@050b7a>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @050b50>      : 19                         load.z32
	<indexOf+1 @050b51>    : 04 1b 00 00                jmp <indexOf+28 @050b6c>
	lib/std/string.ci:17: (19 bytes: <@050b55> - <@050b68>): if (bool(str[i] == chr))
	<indexOf+5 @050b55>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @050b57>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @050b59>    : 51                         add.i32
	<indexOf+10 @050b5a>   : 20                         load.i8
	<indexOf+11 @050b5b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @050b5f>   : 20                         load.i8
	<indexOf+16 @050b60>   : 57                         ceq.i32
	<indexOf+17 @050b61>   : 06 07 00 00                jz <indexOf+24 @050b68>
	lib/std/string.ci:18: (3 bytes: <@050b65> - <@050b68>): return int32(.result := i);
	<indexOf+21 @050b65>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @050b67>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@050b68> - <@050b6c>): int32(i := int32(i + 1))
	<indexOf+24 @050b68>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@050b6c> - <@050b76>): str[i]
	<indexOf+28 @050b6c>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @050b6e>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @050b70>   : 51                         add.i32
	<indexOf+33 @050b71>   : 20                         load.i8
	<indexOf+34 @050b72>   : 05 e3 ff ff                jnz <indexOf+5 @050b55>
	<indexOf+38 @050b76>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@050b7a> - <@050b82>): return int32(.result := int32(-1));
	<indexOf+42 @050b7a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @050b7f>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @050b81>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050b88>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@050b88> - <@050bba>)
	lib/std/string.ci:26: (5 bytes: <@050b88> - <@050b8d>): result: int32 := int32(-1)
	<lastIndexOf @050b88>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@050b8d> - <@050bb7>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @050b8d>    : 19                         load.z32
	<lastIndexOf+6 @050b8e>    : 04 1b 00 00                jmp <lastIndexOf+33 @050ba9>
	lib/std/string.ci:28: (19 bytes: <@050b92> - <@050ba5>): if (bool(str[i] == chr))
	<lastIndexOf+10 @050b92>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @050b94>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @050b96>   : 51                         add.i32
	<lastIndexOf+15 @050b97>   : 20                         load.i8
	<lastIndexOf+16 @050b98>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @050b9c>   : 20                         load.i8
	<lastIndexOf+21 @050b9d>   : 57                         ceq.i32
	<lastIndexOf+22 @050b9e>   : 06 07 00 00                jz <lastIndexOf+29 @050ba5>
	lib/std/string.ci:29: (3 bytes: <@050ba2> - <@050ba5>): int32(result := i);
	<lastIndexOf+26 @050ba2>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@050ba5> - <@050ba9>): int32(i := int32(i + 1))
	<lastIndexOf+29 @050ba5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@050ba9> - <@050bb3>): str[i]
	<lastIndexOf+33 @050ba9>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @050bab>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @050bad>   : 51                         add.i32
	<lastIndexOf+38 @050bae>   : 20                         load.i8
	<lastIndexOf+39 @050baf>   : 05 e3 ff ff                jnz <lastIndexOf+10 @050b92>
	<lastIndexOf+43 @050bb3>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@050bb7> - <@050bba>): return int32(.result := result);
	<lastIndexOf+47 @050bb7>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @050bb9>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@050bc0>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@050bc0> - <@050c09>)
	lib/std/string.ci:37: (62 bytes: <@050bc0> - <@050bfe>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @050bc0>      : 19                         load.z32
	<startsWith+1 @050bc1>    : 04 2d 00 00                jmp <startsWith+46 @050bee>
	lib/std/string.ci:38: (37 bytes: <@050bc5> - <@050bea>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @050bc5>    : 19                         load.z32
	<startsWith+6 @050bc6>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @050bc8>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @050bca>   : 51                         add.i32
	<startsWith+11 @050bcb>   : 20                         load.i8
	<startsWith+12 @050bcc>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @050bce>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @050bd0>   : 51                         add.i32
	<startsWith+17 @050bd1>   : 20                         load.i8
	<startsWith+18 @050bd2>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @050bd4>   : 02                         call
	<startsWith+21 @050bd5>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @050bd9>   : 19                         load.z32
	<startsWith+26 @050bda>   : 57                         ceq.i32
	<startsWith+27 @050bdb>   : 05 0f 00 00                jnz <startsWith+42 @050bea>
	lib/std/string.ci:39: (11 bytes: <@050bdf> - <@050bea>): return bool(.result := false);
	<startsWith+31 @050bdf>   : 19                         load.z32
	<startsWith+32 @050be0>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @050be4>   : 25                         store.i8
	<startsWith+37 @050be5>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @050be9>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@050bea> - <@050bee>): int32(i := int32(i + 1))
	<startsWith+42 @050bea>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@050bee> - <@050bfa>): bool((with[i]) != 0)
	<startsWith+46 @050bee>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @050bf0>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @050bf2>   : 51                         add.i32
	<startsWith+51 @050bf3>   : 20                         load.i8
	<startsWith+52 @050bf4>   : 19                         load.z32
	<startsWith+53 @050bf5>   : 57                         ceq.i32
	<startsWith+54 @050bf6>   : 06 cf ff ff                jz <startsWith+5 @050bc5>
	<startsWith+58 @050bfa>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@050bfe> - <@050c09>): return bool(.result := true);
	<startsWith+62 @050bfe>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @050c03>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @050c07>   : 25                         store.i8
	<startsWith+72 @050c08>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@050c10>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@050c10> - <@050c8e>)
	lib/std/string.ci:47: (13 bytes: <@050c10> - <@050c1d>): withLen: int32 := length(with)
	<endsWith @050c10>      : 19                         load.z32
	<endsWith+1 @050c11>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @050c13>    : 1f 28 0b 05 00             load.ref <@050b28> ;length(str: char[*]): int32
	<endsWith+8 @050c18>    : 02                         call
	<endsWith+9 @050c19>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@050c1d> - <@050c2a>): strLen: int32 := length(str)
	<endsWith+13 @050c1d>   : 19                         load.z32
	<endsWith+14 @050c1e>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @050c20>   : 1f 28 0b 05 00             load.ref <@050b28> ;length(str: char[*]): int32
	<endsWith+21 @050c25>   : 02                         call
	<endsWith+22 @050c26>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@050c2a> - <@050c3e>): if (bool(strLen < withLen))
	<endsWith+26 @050c2a>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @050c2c>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @050c2e>   : 58                         clt.i32
	<endsWith+31 @050c2f>   : 06 0f 00 00                jz <endsWith+46 @050c3e>
	lib/std/string.ci:50: (11 bytes: <@050c33> - <@050c3e>): return bool(.result := false);
	<endsWith+35 @050c33>   : 19                         load.z32
	<endsWith+36 @050c34>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @050c38>   : 25                         store.i8
	<endsWith+41 @050c39>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @050c3d>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@050c3e> - <@050c7f>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @050c3e>   : 19                         load.z32
	<endsWith+47 @050c3f>   : 04 33 00 00                jmp <endsWith+98 @050c72>
	lib/std/string.ci:53: (43 bytes: <@050c43> - <@050c6e>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @050c43>   : 19                         load.z32
	<endsWith+52 @050c44>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @050c46>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @050c48>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @050c4a>   : 52                         sub.i32
	<endsWith+59 @050c4b>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @050c4d>   : 51                         add.i32
	<endsWith+62 @050c4e>   : 51                         add.i32
	<endsWith+63 @050c4f>   : 20                         load.i8
	<endsWith+64 @050c50>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @050c52>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @050c54>   : 51                         add.i32
	<endsWith+69 @050c55>   : 20                         load.i8
	<endsWith+70 @050c56>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @050c58>   : 02                         call
	<endsWith+73 @050c59>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @050c5d>   : 19                         load.z32
	<endsWith+78 @050c5e>   : 57                         ceq.i32
	<endsWith+79 @050c5f>   : 05 0f 00 00                jnz <endsWith+94 @050c6e>
	lib/std/string.ci:54: (11 bytes: <@050c63> - <@050c6e>): return bool(.result := false);
	<endsWith+83 @050c63>   : 19                         load.z32
	<endsWith+84 @050c64>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @050c68>   : 25                         store.i8
	<endsWith+89 @050c69>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @050c6d>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@050c6e> - <@050c72>): int32(i := int32(i + 1))
	<endsWith+94 @050c6e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@050c72> - <@050c7b>): bool(i < withLen)
	<endsWith+98 @050c72>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @050c74>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @050c76>  : 58                         clt.i32
	<endsWith+103 @050c77>  : 05 cc ff ff                jnz <endsWith+51 @050c43>
	<endsWith+107 @050c7b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@050c7f> - <@050c8e>): return bool(.result := true);
	<endsWith+111 @050c7f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @050c84>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @050c88>  : 25                         store.i8
	<endsWith+121 @050c89>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @050c8d>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@050c90>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@050c90> - <@050ccf>)
	lib/std/string.ci:62: (1 byte: <@050c90> - <@050c91>): result: int32 := 0
	<compare @050c90>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@050c91> - <@050ccc>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @050c91>    : 19                         load.z32
	<compare+2 @050c92>    : 04 2e 00 00                jmp <compare+48 @050cc0>
	lib/std/string.ci:64: (22 bytes: <@050c96> - <@050cac>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @050c96>    : 19                         load.z32
	<compare+7 @050c97>    : 10 06                      dup.x1 sp(6)
	<compare+9 @050c99>    : 10 02                      dup.x1 sp(2)
	<compare+11 @050c9b>   : 51                         add.i32
	<compare+12 @050c9c>   : 20                         load.i8
	<compare+13 @050c9d>   : 10 06                      dup.x1 sp(6)
	<compare+15 @050c9f>   : 10 03                      dup.x1 sp(3)
	<compare+17 @050ca1>   : 51                         add.i32
	<compare+18 @050ca2>   : 20                         load.i8
	<compare+19 @050ca3>   : 10 06                      dup.x1 sp(6)
	<compare+21 @050ca5>   : 02                         call
	<compare+22 @050ca6>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @050caa>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:65: (16 bytes: <@050cac> - <@050cbc>): if (bool((str[i]) == 0))
	<compare+28 @050cac>   : 10 05                      dup.x1 sp(5)
	<compare+30 @050cae>   : 10 01                      dup.x1 sp(1)
	<compare+32 @050cb0>   : 51                         add.i32
	<compare+33 @050cb1>   : 20                         load.i8
	<compare+34 @050cb2>   : 19                         load.z32
	<compare+35 @050cb3>   : 57                         ceq.i32
	<compare+36 @050cb4>   : 06 08 00 00                jz <compare+44 @050cbc>
	lib/std/string.ci:66: (4 bytes: <@050cb8> - <@050cbc>): break;
	<compare+40 @050cb8>   : 04 10 00 00                jmp <compare+56 @050cc8>
	lib/std/string.ci:63: (4 bytes: <@050cbc> - <@050cc0>): int32(i := int32(i + 1))
	<compare+44 @050cbc>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@050cc0> - <@050cc8>): bool(result == 0)
	<compare+48 @050cc0>   : 10 01                      dup.x1 sp(1)
	<compare+50 @050cc2>   : 19                         load.z32
	<compare+51 @050cc3>   : 57                         ceq.i32
	<compare+52 @050cc4>   : 05 d2 ff ff                jnz <compare+6 @050c96>
	<compare+56 @050cc8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@050ccc> - <@050ccf>): return int32(.result := result);
	<compare+60 @050ccc>   : 13 05                      set.x1 sp(5)
	<compare+62 @050cce>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@050d18>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@050d18> - <@050d3c>)
	lib/std/string.ci:84: (36 bytes: <@050d18> - <@050d3c>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @050d18>      : 19                         load.z32
	<ignCaseCmp+1 @050d19>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @050d1d>    : 20                         load.i8
	<ignCaseCmp+6 @050d1e>    : 1f d0 0c 05 00             load.ref <@050cd0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @050d23>   : 02                         call
	<ignCaseCmp+12 @050d24>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @050d28>   : 19                         load.z32
	<ignCaseCmp+17 @050d29>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @050d2d>   : 20                         load.i8
	<ignCaseCmp+22 @050d2e>   : 1f d0 0c 05 00             load.ref <@050cd0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @050d33>   : 02                         call
	<ignCaseCmp+28 @050d34>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @050d38>   : 52                         sub.i32
	<ignCaseCmp+33 @050d39>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @050d3b>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@050d40>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@050d40> - <@050d4e>)
	lib/std/string.ci:89: (14 bytes: <@050d40> - <@050d4e>): return char(.result := char(chr - with));
	<caseCmp @050d40>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @050d44>    : 20                         load.i8
	<caseCmp+5 @050d45>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @050d49>    : 20                         load.i8
	<caseCmp+10 @050d4a>   : 52                         sub.i32
	<caseCmp+11 @050d4b>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @050d4d>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0225a0>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@050d50>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@050d50> - <@050da4>)
	lib/std/string.ci:127: (56 bytes: <@050d50> - <@050d88>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @050d50>      : 19                         load.z32
	<append+1 @050d51>    : 04 29 00 00                jmp <append+42 @050d7a>
	lib/std/string.ci:128: (13 bytes: <@050d55> - <@050d62>): if (bool(pos >= (output.length)))
	<append+5 @050d55>    : 10 03                      dup.x1 sp(3)
	<append+7 @050d57>    : 10 06                      dup.x1 sp(6)
	<append+9 @050d59>    : 58                         clt.i32
	<append+10 @050d5a>   : 05 08 00 00                jnz <append+18 @050d62>
	lib/std/string.ci:129: (4 bytes: <@050d5e> - <@050d62>): break;
	<append+14 @050d5e>   : 04 26 00 00                jmp <append+52 @050d84>
	lib/std/string.ci:131: (12 bytes: <@050d62> - <@050d6e>): char(output[pos] := value[i]);
	<append+18 @050d62>   : 10 02                      dup.x1 sp(2)
	<append+20 @050d64>   : 10 01                      dup.x1 sp(1)
	<append+22 @050d66>   : 51                         add.i32
	<append+23 @050d67>   : 20                         load.i8
	<append+24 @050d68>   : 10 05                      dup.x1 sp(5)
	<append+26 @050d6a>   : 10 05                      dup.x1 sp(5)
	<append+28 @050d6c>   : 51                         add.i32
	<append+29 @050d6d>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@050d6e> - <@050d76>): int32(pos := int32(pos + 1));
	<append+30 @050d6e>   : 10 03                      dup.x1 sp(3)
	<append+32 @050d70>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @050d74>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:127: (4 bytes: <@050d76> - <@050d7a>): int32(i := int32(i + 1))
	<append+38 @050d76>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@050d7a> - <@050d84>): value[i]
	<append+42 @050d7a>   : 10 02                      dup.x1 sp(2)
	<append+44 @050d7c>   : 10 01                      dup.x1 sp(1)
	<append+46 @050d7e>   : 51                         add.i32
	<append+47 @050d7f>   : 20                         load.i8
	<append+48 @050d80>   : 05 d5 ff ff                jnz <append+5 @050d55>
	<append+52 @050d84>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@050d88> - <@050d99>): if (bool(pos >= (output.length)))
	<append+56 @050d88>   : 10 02                      dup.x1 sp(2)
	<append+58 @050d8a>   : 10 05                      dup.x1 sp(5)
	<append+60 @050d8c>   : 58                         clt.i32
	<append+61 @050d8d>   : 05 0c 00 00                jnz <append+73 @050d99>
	lib/std/string.ci:136: (8 bytes: <@050d91> - <@050d99>): int32(pos := (uint32(output.length - (1))));
	<append+65 @050d91>   : 10 04                      dup.x1 sp(4)
	<append+67 @050d93>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @050d97>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:138: (7 bytes: <@050d99> - <@050da0>): char(output[pos] := (0));
	<append+73 @050d99>   : 19                         load.z32
	<append+74 @050d9a>   : 10 04                      dup.x1 sp(4)
	<append+76 @050d9c>   : 10 04                      dup.x1 sp(4)
	<append+78 @050d9e>   : 51                         add.i32
	<append+79 @050d9f>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@050da0> - <@050da4>): return int32(.result := pos);
	<append+80 @050da0>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @050da3>   : 03                         ret
.usages:
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@050db8>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@050db8> - <@051049>)
	lib/std/string.ci:147: (1 byte: <@050db8> - <@050db9>): len: int32 := 0
	<append @050db8>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@050db9> - <@050dbd>): digits: char[80]
	<append+1 @050db9>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (3 bytes: <@050dbd> - <@050dc0>): radix: int32 := format.radix
	<append+5 @050dbd>    : 10 16                      dup.x1 sp(22)
	<append+7 @050dbf>    : 22                         load.i32
	lib/std/string.ci:151: (54 bytes: <@050dc0> - <@050df6>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @050dc0>    : 10 00                      dup.x1 sp(0)
	<append+10 @050dc2>   : 1c 01 00 00 00             load.c32 1
	<append+15 @050dc7>   : 59                         cgt.i32
	<append+16 @050dc8>   : 06 08 00 00                jz <append+24 @050dd0>
	<append+20 @050dcc>   : 04 2a 00 00                jmp <append+62 @050df6>
	<append+24 @050dd0>   : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+29 @050dd5>   : 1c 97 00 00 00             load.c32 151
	<append+34 @050dda>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @050ddf>   : 1c 80 00 00 00             load.c32 128
	<append+44 @050de4>   : 1f fa f0 01 00             load.ref <@01f0fa> ;"radix is too small"
	<append+49 @050de9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+54 @050dee>   : 0a 18 00 00                load.sp(+24)
	<append+58 @050df2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes: <@050df6> - <@050e2b>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @050df6>   : 10 00                      dup.x1 sp(0)
	<append+64 @050df8>   : 2a b4 0d 05                load.m32 <@050db4> ;append.radixDigits+4
	<append+68 @050dfc>   : 58                         clt.i32
	<append+69 @050dfd>   : 06 08 00 00                jz <append+77 @050e05>
	<append+73 @050e01>   : 04 2a 00 00                jmp <append+115 @050e2b>
	<append+77 @050e05>   : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+82 @050e0a>   : 1c 98 00 00 00             load.c32 152
	<append+87 @050e0f>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @050e14>   : 1c 80 00 00 00             load.c32 128
	<append+97 @050e19>   : 1f 0d f1 01 00             load.ref <@01f10d> ;"radix is too big"
	<append+102 @050e1e>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+107 @050e23>  : 0a 18 00 00                load.sp(+24)
	<append+111 @050e27>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes: <@050e2b> - <@050e59>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @050e2b>  : 04 26 00 00                jmp <append+153 @050e51>
	lib/std/string.ci:156: (27 bytes: <@050e2f> - <@050e4a>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @050e2f>  : 2a b0 0d 05                load.m32 <@050db0> ;append.radixDigits
	<append+123 @050e33>  : 10 19                      dup.x1 sp(25)
	<append+125 @050e35>  : 10 02                      dup.x1 sp(2)
	<append+127 @050e37>  : 35                         mod.u32
	<append+128 @050e38>  : 51                         add.i32
	<append+129 @050e39>  : 20                         load.i8
	<append+130 @050e3a>  : 0a 08 00 00                load.sp(+8)
	<append+134 @050e3e>  : 10 17                      dup.x1 sp(23)
	<append+136 @050e40>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @050e44>  : 10 00                      dup.x1 sp(0)
	<append+142 @050e46>  : 13 19                      set.x1 sp(25)
	<append+144 @050e48>  : 51                         add.i32
	<append+145 @050e49>  : 25                         store.i8
	lib/std/string.ci:155: (7 bytes: <@050e4a> - <@050e51>): uint32(value := uint32(value / (radix)))
	<append+146 @050e4a>  : 10 18                      dup.x1 sp(24)
	<append+148 @050e4c>  : 10 01                      dup.x1 sp(1)
	<append+150 @050e4e>  : 34                         div.u32
	<append+151 @050e4f>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:155: (8 bytes: <@050e51> - <@050e59>): bool(value > (0))
	<append+153 @050e51>  : 10 18                      dup.x1 sp(24)
	<append+155 @050e53>  : 19                         load.z32
	<append+156 @050e54>  : 39                         cgt.u32
	<append+157 @050e55>  : 05 da ff ff                jnz <append+119 @050e2f>
	lib/std/string.ci:158: (29 bytes: <@050e59> - <@050e76>): if (bool(len == 0))
	<append+161 @050e59>  : 10 15                      dup.x1 sp(21)
	<append+163 @050e5b>  : 19                         load.z32
	<append+164 @050e5c>  : 57                         ceq.i32
	<append+165 @050e5d>  : 06 19 00 00                jz <append+190 @050e76>
	lib/std/string.ci:159: (21 bytes: <@050e61> - <@050e76>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @050e61>  : 1c 30 00 00 00             load.c32 48
	<append+174 @050e66>  : 0a 08 00 00                load.sp(+8)
	<append+178 @050e6a>  : 10 17                      dup.x1 sp(23)
	<append+180 @050e6c>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @050e70>  : 10 00                      dup.x1 sp(0)
	<append+186 @050e72>  : 13 19                      set.x1 sp(25)
	<append+188 @050e74>  : 51                         add.i32
	<append+189 @050e75>  : 25                         store.i8
	lib/std/string.ci:162: (10 bytes: <@050e76> - <@050e80>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @050e76>  : 10 17                      dup.x1 sp(23)
	<append+192 @050e78>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @050e7c>  : 22                         load.i32
	<append+197 @050e7d>  : 10 16                      dup.x1 sp(22)
	<append+199 @050e7f>  : 52                         sub.i32
	lib/std/string.ci:164: (7 bytes: <@050e80> - <@050e87>): padChr: char := format.padChr
	<append+200 @050e80>  : 10 18                      dup.x1 sp(24)
	<append+202 @050e82>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @050e86>  : 20                         load.i8
	lib/std/string.ci:165: (21 bytes: <@050e87> - <@050e9c>): if (bool(padChr == ''))
	<append+207 @050e87>  : 0a 00 00 00                load.sp(+0)
	<append+211 @050e8b>  : 20                         load.i8
	<append+212 @050e8c>  : 19                         load.z32
	<append+213 @050e8d>  : 57                         ceq.i32
	<append+214 @050e8e>  : 06 0e 00 00                jz <append+228 @050e9c>
	lib/std/string.ci:166: (10 bytes: <@050e92> - <@050e9c>): char(padChr := ' ');
	<append+218 @050e92>  : 1c 20 00 00 00             load.c32 32
	<append+223 @050e97>  : 0a 04 00 00                load.sp(+4)
	<append+227 @050e9b>  : 25                         store.i8
	lib/std/string.ci:170: (207 bytes: <@050e9c> - <@050f6b>): if (bool((sign) != 0))
	<append+228 @050e9c>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @050ea0>  : 20                         load.i8
	<append+233 @050ea1>  : 19                         load.z32
	<append+234 @050ea2>  : 57                         ceq.i32
	<append+235 @050ea3>  : 05 c8 00 00                jnz <append+435 @050f6b>
	lib/std/string.ci:171: (8 bytes: <@050ea7> - <@050eaf>): int32(maxLen := int32(maxLen - 1));
	<append+239 @050ea7>  : 10 01                      dup.x1 sp(1)
	<append+241 @050ea9>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @050ead>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (117 bytes: <@050eaf> - <@050f24>): if (contains(void(whiteSpace, padChr)))
	<append+247 @050eaf>  : 19                         load.z32
	<append+248 @050eb0>  : 2a a8 0d 05                load.m32 <@050da8> ;append.whiteSpace
	<append+252 @050eb4>  : 0a 08 00 00                load.sp(+8)
	<append+256 @050eb8>  : 20                         load.i8
	<append+257 @050eb9>  : 1f 50 0b 05 00             load.ref <@050b50> ;indexOf(str: char[*], chr: char): int32
	<append+262 @050ebe>  : 02                         call
	<append+263 @050ebf>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @050ec3>  : 19                         load.z32
	<append+268 @050ec4>  : 58                         clt.i32
	<append+269 @050ec5>  : 05 5f 00 00                jnz <append+364 @050f24>
	lib/std/string.ci:174: (91 bytes: <@050ec9> - <@050f24>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @050ec9>  : 04 53 00 00                jmp <append+356 @050f1c>
	lib/std/string.ci:175: (52 bytes: <@050ecd> - <@050f01>): assert(bool(pos < (output.length)));
	<append+277 @050ecd>  : 10 1c                      dup.x1 sp(28)
	<append+279 @050ecf>  : 10 1f                      dup.x1 sp(31)
	<append+281 @050ed1>  : 58                         clt.i32
	<append+282 @050ed2>  : 06 08 00 00                jz <append+290 @050eda>
	<append+286 @050ed6>  : 04 2b 00 00                jmp <append+329 @050f01>
	<append+290 @050eda>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+295 @050edf>  : 1c af 00 00 00             load.c32 175
	<append+300 @050ee4>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @050ee9>  : 1c 80 00 00 00             load.c32 128
	<append+310 @050eee>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+315 @050ef3>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+320 @050ef8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @050efd>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes: <@050f01> - <@050f0c>): char(output[pos] := padChr);
	<append+329 @050f01>  : 0a 00 00 00                load.sp(+0)
	<append+333 @050f05>  : 20                         load.i8
	<append+334 @050f06>  : 10 1e                      dup.x1 sp(30)
	<append+336 @050f08>  : 10 1e                      dup.x1 sp(30)
	<append+338 @050f0a>  : 51                         add.i32
	<append+339 @050f0b>  : 25                         store.i8
	lib/std/string.ci:177: (8 bytes: <@050f0c> - <@050f14>): int32(pos := int32(pos + 1));
	<append+340 @050f0c>  : 10 1c                      dup.x1 sp(28)
	<append+342 @050f0e>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @050f12>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:174: (8 bytes: <@050f14> - <@050f1c>): int32(maxLen := int32(maxLen - 1))
	<append+348 @050f14>  : 10 01                      dup.x1 sp(1)
	<append+350 @050f16>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @050f1a>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:174: (8 bytes: <@050f1c> - <@050f24>): bool(maxLen > 0)
	<append+356 @050f1c>  : 10 01                      dup.x1 sp(1)
	<append+358 @050f1e>  : 19                         load.z32
	<append+359 @050f1f>  : 59                         cgt.i32
	<append+360 @050f20>  : 05 ad ff ff                jnz <append+277 @050ecd>
	lib/std/string.ci:180: (52 bytes: <@050f24> - <@050f58>): assert(bool(pos < (output.length)));
	<append+364 @050f24>  : 10 1c                      dup.x1 sp(28)
	<append+366 @050f26>  : 10 1f                      dup.x1 sp(31)
	<append+368 @050f28>  : 58                         clt.i32
	<append+369 @050f29>  : 06 08 00 00                jz <append+377 @050f31>
	<append+373 @050f2d>  : 04 2b 00 00                jmp <append+416 @050f58>
	<append+377 @050f31>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+382 @050f36>  : 1c b4 00 00 00             load.c32 180
	<append+387 @050f3b>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @050f40>  : 1c 80 00 00 00             load.c32 128
	<append+397 @050f45>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+402 @050f4a>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+407 @050f4f>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @050f54>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes: <@050f58> - <@050f63>): char(output[pos] := sign);
	<append+416 @050f58>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @050f5c>  : 20                         load.i8
	<append+421 @050f5d>  : 10 1e                      dup.x1 sp(30)
	<append+423 @050f5f>  : 10 1e                      dup.x1 sp(30)
	<append+425 @050f61>  : 51                         add.i32
	<append+426 @050f62>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@050f63> - <@050f6b>): int32(pos := int32(pos + 1));
	<append+427 @050f63>  : 10 1c                      dup.x1 sp(28)
	<append+429 @050f65>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @050f69>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:186: (91 bytes: <@050f6b> - <@050fc6>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @050f6b>  : 04 53 00 00                jmp <append+518 @050fbe>
	lib/std/string.ci:187: (52 bytes: <@050f6f> - <@050fa3>): assert(bool(pos < (output.length)));
	<append+439 @050f6f>  : 10 1c                      dup.x1 sp(28)
	<append+441 @050f71>  : 10 1f                      dup.x1 sp(31)
	<append+443 @050f73>  : 58                         clt.i32
	<append+444 @050f74>  : 06 08 00 00                jz <append+452 @050f7c>
	<append+448 @050f78>  : 04 2b 00 00                jmp <append+491 @050fa3>
	<append+452 @050f7c>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+457 @050f81>  : 1c bb 00 00 00             load.c32 187
	<append+462 @050f86>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @050f8b>  : 1c 80 00 00 00             load.c32 128
	<append+472 @050f90>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+477 @050f95>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+482 @050f9a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @050f9f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes: <@050fa3> - <@050fae>): char(output[pos] := padChr);
	<append+491 @050fa3>  : 0a 00 00 00                load.sp(+0)
	<append+495 @050fa7>  : 20                         load.i8
	<append+496 @050fa8>  : 10 1e                      dup.x1 sp(30)
	<append+498 @050faa>  : 10 1e                      dup.x1 sp(30)
	<append+500 @050fac>  : 51                         add.i32
	<append+501 @050fad>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@050fae> - <@050fb6>): int32(pos := int32(pos + 1));
	<append+502 @050fae>  : 10 1c                      dup.x1 sp(28)
	<append+504 @050fb0>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @050fb4>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:186: (8 bytes: <@050fb6> - <@050fbe>): int32(maxLen := int32(maxLen - 1))
	<append+510 @050fb6>  : 10 01                      dup.x1 sp(1)
	<append+512 @050fb8>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @050fbc>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:186: (8 bytes: <@050fbe> - <@050fc6>): bool(maxLen > 0)
	<append+518 @050fbe>  : 10 01                      dup.x1 sp(1)
	<append+520 @050fc0>  : 19                         load.z32
	<append+521 @050fc1>  : 59                         cgt.i32
	<append+522 @050fc2>  : 05 ad ff ff                jnz <append+439 @050f6f>
	lib/std/string.ci:193: (99 bytes: <@050fc6> - <@051029>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @050fc6>  : 19                         load.z32
	<append+527 @050fc7>  : 04 55 00 00                jmp <append+612 @05101c>
	lib/std/string.ci:194: (52 bytes: <@050fcb> - <@050fff>): assert(bool(i < (output.length)));
	<append+531 @050fcb>  : 10 00                      dup.x1 sp(0)
	<append+533 @050fcd>  : 10 20                      dup.x1 sp(32)
	<append+535 @050fcf>  : 58                         clt.i32
	<append+536 @050fd0>  : 06 08 00 00                jz <append+544 @050fd8>
	<append+540 @050fd4>  : 04 2b 00 00                jmp <append+583 @050fff>
	<append+544 @050fd8>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+549 @050fdd>  : 1c c2 00 00 00             load.c32 194
	<append+554 @050fe2>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @050fe7>  : 1c 80 00 00 00             load.c32 128
	<append+564 @050fec>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+569 @050ff1>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+574 @050ff6>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @050ffb>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes: <@050fff> - <@051010>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @050fff>  : 0a 10 00 00                load.sp(+16)
	<append+587 @051003>  : 10 19                      dup.x1 sp(25)
	<append+589 @051005>  : 10 02                      dup.x1 sp(2)
	<append+591 @051007>  : 52                         sub.i32
	<append+592 @051008>  : 51                         add.i32
	<append+593 @051009>  : 20                         load.i8
	<append+594 @05100a>  : 10 1f                      dup.x1 sp(31)
	<append+596 @05100c>  : 10 1f                      dup.x1 sp(31)
	<append+598 @05100e>  : 51                         add.i32
	<append+599 @05100f>  : 25                         store.i8
	lib/std/string.ci:196: (8 bytes: <@051010> - <@051018>): int32(pos := int32(pos + 1));
	<append+600 @051010>  : 10 1d                      dup.x1 sp(29)
	<append+602 @051012>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @051016>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:193: (4 bytes: <@051018> - <@05101c>): int32(i := int32(i + 1))
	<append+608 @051018>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:193: (9 bytes: <@05101c> - <@051025>): bool(i < len)
	<append+612 @05101c>  : 10 00                      dup.x1 sp(0)
	<append+614 @05101e>  : 10 19                      dup.x1 sp(25)
	<append+616 @051020>  : 58                         clt.i32
	<append+617 @051021>  : 05 aa ff ff                jnz <append+531 @050fcb>
	<append+621 @051025>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:199: (17 bytes: <@051029> - <@05103a>): if (bool(pos >= (output.length)))
	<append+625 @051029>  : 10 1c                      dup.x1 sp(28)
	<append+627 @05102b>  : 10 1f                      dup.x1 sp(31)
	<append+629 @05102d>  : 58                         clt.i32
	<append+630 @05102e>  : 05 0c 00 00                jnz <append+642 @05103a>
	lib/std/string.ci:200: (8 bytes: <@051032> - <@05103a>): int32(pos := (uint32(output.length - (1))));
	<append+634 @051032>  : 10 1e                      dup.x1 sp(30)
	<append+636 @051034>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @051038>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:202: (7 bytes: <@05103a> - <@051041>): char(output[pos] := (0));
	<append+642 @05103a>  : 19                         load.z32
	<append+643 @05103b>  : 10 1e                      dup.x1 sp(30)
	<append+645 @05103d>  : 10 1e                      dup.x1 sp(30)
	<append+647 @05103f>  : 51                         add.i32
	<append+648 @051040>  : 25                         store.i8
	lib/std/string.ci:203: (8 bytes: <@051041> - <@051049>): return int32(.result := pos);
	<append+649 @051041>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @051044>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @051048>  : 03                         ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@051050>
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@051050> - <@051067>)
	lib/std/string.ci:208: (23 bytes: <@051050> - <@051067>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @051050>      : 19                         load.z32
	<append+1 @051051>    : 11 05                      dup.x2 sp(5)
	<append+3 @051053>    : 10 06                      dup.x1 sp(6)
	<append+5 @051055>    : 19                         load.z32
	<append+6 @051056>    : 10 07                      dup.x1 sp(7)
	<append+8 @051058>    : 10 07                      dup.x1 sp(7)
	<append+10 @05105a>   : 1f b8 0d 05 00             load.ref <@050db8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @05105f>   : 02                         call
	<append+16 @051060>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @051064>   : 13 07                      set.x1 sp(7)
	<append+22 @051066>   : 03                         ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@051068>
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@051068> - <@051099>)
	lib/std/string.ci:213: (1 byte: <@051068> - <@051069>): sign: int32 := 0
	<append @051068>      : 19                         load.z32
	lib/std/string.ci:214: (20 bytes: <@051069> - <@05107d>): if (bool(value < 0))
	<append+1 @051069>    : 10 03                      dup.x1 sp(3)
	<append+3 @05106b>    : 19                         load.z32
	<append+4 @05106c>    : 58                         clt.i32
	<append+5 @05106d>    : 06 10 00 00                jz <append+21 @05107d>
	lib/std/string.ci:215: (7 bytes: <@051071> - <@051078>): int32(sign := ('-'));
	<append+9 @051071>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @051076>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:216: (5 bytes: <@051078> - <@05107d>): int32(value := int32(-value));
	<append+16 @051078>   : 10 03                      dup.x1 sp(3)
	<append+18 @05107a>   : 50                         neg.i32
	<append+19 @05107b>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:218: (28 bytes: <@05107d> - <@051099>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @05107d>   : 19                         load.z32
	<append+22 @05107e>   : 11 06                      dup.x2 sp(6)
	<append+24 @051080>   : 10 07                      dup.x1 sp(7)
	<append+26 @051082>   : 10 04                      dup.x1 sp(4)
	<append+28 @051084>   : 10 08                      dup.x1 sp(8)
	<append+30 @051086>   : 10 08                      dup.x1 sp(8)
	<append+32 @051088>   : 1f b8 0d 05 00             load.ref <@050db8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @05108d>   : 02                         call
	<append+38 @05108e>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @051092>   : 13 08                      set.x1 sp(8)
	<append+44 @051094>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @051098>   : 03                         ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@0510b0>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@0510b0> - <@0510c9>)
	lib/std/string.ci:224: (25 bytes: <@0510b0> - <@0510c9>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @0510b0>      : 19                         load.z32
	<append+1 @0510b1>    : 11 04                      dup.x2 sp(4)
	<append+3 @0510b3>    : 10 05                      dup.x1 sp(5)
	<append+5 @0510b5>    : 10 05                      dup.x1 sp(5)
	<append+7 @0510b7>    : 1f a0 10 05 00             load.ref <@0510a0> ;append.format
	<append+12 @0510bc>   : 1f 50 10 05 00             load.ref <@051050> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @0510c1>   : 02                         call
	<append+18 @0510c2>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @0510c6>   : 13 06                      set.x1 sp(6)
	<append+24 @0510c8>   : 03                         ret
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024730>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0510d0>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@0510d0> - <@0510d7>)
	lib/vec/vec2d.ci:17: (7 bytes: <@0510d0> - <@0510d7>): return void(.result := {...});
	<vec2d @0510d0>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes: <@0510d3> - <@0510d6>): void(.result.y := y);
	<vec2d+3 @0510d3>    : 17 07 01                   mov.x2 sp(7, 1)
	<vec2d+6 @0510d6>    : 03                         ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0256e8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:103: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec4f.ci:105'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:105: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:34: referenced as `x`
	lib/vec/mat4f.ci:33: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/vec4f.ci:103: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:34: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:34: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:32: referenced as `y`
	lib/vec/vec4f.ci:103: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:34: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:33: referenced as `z`
	lib/vec/mat4f.ci:32: referenced as `z`
	lib/vec/vec4f.ci:103: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:34: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:34: referenced as `w`
	lib/vec/mat4f.ci:33: referenced as `w`
	lib/vec/mat4f.ci:32: referenced as `w`
	lib/vec/vec4f.ci:103: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@0510d8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@0510d8> - <@0510e5>)
	lib/vec/vec4f.ci:29: (13 bytes: <@0510d8> - <@0510e5>): return void(.result := {...});
	<vec4f @0510d8>      : 16 05 04                   mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes: <@0510db> - <@0510de>): void(.result.y := y);
	<vec4f+3 @0510db>    : 16 06 03                   mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes: <@0510de> - <@0510e1>): void(.result.z := z);
	<vec4f+6 @0510de>    : 16 07 02                   mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes: <@0510e1> - <@0510e4>): void(.result.w := w);
	<vec4f+9 @0510e1>    : 16 08 01                   mov.x1 sp(8, 1)
	<vec4f+12 @0510e4>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:32: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with given x, y, z components, and w with 0'
.value: vec4f(void(void(void(x, y), z), 0.000000))
.usages:
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:32: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/vec/vec4f.ci:34: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:36: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:67'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/vec/vec4f.ci:67: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/vec/vec4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/vec/vec4f.ci:69: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/vec/vec4f.ci:71: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/vec/vec4f.ci:73: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `div`
	lib/vec/vec4f.ci:75: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'lib/vec/vec4f.ci:78'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.usages:
	lib/vec/vec4f.ci:78: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'lib/vec/vec4f.ci:80'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.usages:
	lib/vec/vec4f.ci:80: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.usages:
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/vec4f.ci:98: referenced as `dp3`
	lib/vec/vec4f.ci:84: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.usages:
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/vec4f.ci:88: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.usages:
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/vec4f.ci:92: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/vec/vec4f.ci:95: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'len'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `len`
	lib/vec/vec4f.ci:98: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(len(v))))
.usages:
	lib/vec/vec4f.ci:100: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:103'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/vec/vec4f.ci:103: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@028ac8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:53: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:49: referenced as `mat4f`
	lib/vec/mat4f.ci:47: referenced as `mat4f`
	lib/vec/mat4f.ci:45: referenced as `mat4f`
	lib/vec/mat4f.ci:40: referenced as `mat4f`
	lib/vec/mat4f.ci:27: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `m`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:68'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:68: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:49: referenced as `x`
	lib/vec/mat4f.ci:47: referenced as `x`
	lib/vec/mat4f.ci:45: referenced as `x`
	lib/vec/mat4f.ci:41: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:49: referenced as `y`
	lib/vec/mat4f.ci:47: referenced as `y`
	lib/vec/mat4f.ci:45: referenced as `y`
	lib/vec/mat4f.ci:41: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:49: referenced as `z`
	lib/vec/mat4f.ci:47: referenced as `z`
	lib/vec/mat4f.ci:45: referenced as `z`
	lib/vec/mat4f.ci:41: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:49: referenced as `w`
	lib/vec/mat4f.ci:47: referenced as `w`
	lib/vec/mat4f.ci:41: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0510e8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:27'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@0510e8> - <@051119>)
	lib/vec/mat4f.ci:31: (49 bytes: <@0510e8> - <@051119>): return void(.result := {...});
	<mat4f @0510e8>      : 16 11 10                   mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:32: (3 bytes: <@0510eb> - <@0510ee>): void(.result.x.y := xy);
	<mat4f+3 @0510eb>    : 16 12 0f                   mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:32: (3 bytes: <@0510ee> - <@0510f1>): void(.result.x.z := xz);
	<mat4f+6 @0510ee>    : 16 13 0e                   mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:32: (3 bytes: <@0510f1> - <@0510f4>): void(.result.x.w := xw);
	<mat4f+9 @0510f1>    : 16 14 0d                   mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510f4> - <@0510f7>): void(.result.y.x := yx);
	<mat4f+12 @0510f4>   : 16 15 0c                   mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510f7> - <@0510fa>): void(.result.y.y := yy);
	<mat4f+15 @0510f7>   : 16 16 0b                   mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510fa> - <@0510fd>): void(.result.y.z := yz);
	<mat4f+18 @0510fa>   : 16 17 0a                   mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:33: (3 bytes: <@0510fd> - <@051100>): void(.result.y.w := yw);
	<mat4f+21 @0510fd>   : 16 18 09                   mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:34: (3 bytes: <@051100> - <@051103>): void(.result.z.x := zx);
	<mat4f+24 @051100>   : 16 19 08                   mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:34: (3 bytes: <@051103> - <@051106>): void(.result.z.y := zy);
	<mat4f+27 @051103>   : 16 1a 07                   mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:34: (3 bytes: <@051106> - <@051109>): void(.result.z.z := zz);
	<mat4f+30 @051106>   : 16 1b 06                   mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:34: (3 bytes: <@051109> - <@05110c>): void(.result.z.w := zw);
	<mat4f+33 @051109>   : 16 1c 05                   mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:35: (3 bytes: <@05110c> - <@05110f>): void(.result.w.x := wx);
	<mat4f+36 @05110c>   : 16 1d 04                   mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:35: (3 bytes: <@05110f> - <@051112>): void(.result.w.y := wy);
	<mat4f+39 @05110f>   : 16 1e 03                   mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:35: (3 bytes: <@051112> - <@051115>): void(.result.w.z := wz);
	<mat4f+42 @051112>   : 16 1f 02                   mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:35: (3 bytes: <@051115> - <@051118>): void(.result.w.w := ww);
	<mat4f+45 @051115>   : 16 20 01                   mov.x1 sp(32, 1)
	<mat4f+48 @051118>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:27: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@051120>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:40'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@051120> - <@051135>)
	lib/vec/mat4f.ci:41: (21 bytes: <@051120> - <@051135>): return void(.result := {...});
	<mat4f @051120>      : 10 04                      dup.x1 sp(4)
	<mat4f+2 @051122>    : 24                         load.i128
	<mat4f+3 @051123>    : 15 09                      set.x4 sp(9)
	lib/vec/mat4f.ci:41: (5 bytes: <@051125> - <@05112a>): void(.result.y := y);
	<mat4f+5 @051125>    : 10 03                      dup.x1 sp(3)
	<mat4f+7 @051127>    : 24                         load.i128
	<mat4f+8 @051128>    : 15 0d                      set.x4 sp(13)
	lib/vec/mat4f.ci:41: (5 bytes: <@05112a> - <@05112f>): void(.result.z := z);
	<mat4f+10 @05112a>   : 10 02                      dup.x1 sp(2)
	<mat4f+12 @05112c>   : 24                         load.i128
	<mat4f+13 @05112d>   : 15 11                      set.x4 sp(17)
	lib/vec/mat4f.ci:41: (5 bytes: <@05112f> - <@051134>): void(.result.w := w);
	<mat4f+15 @05112f>   : 10 01                      dup.x1 sp(1)
	<mat4f+17 @051131>   : 24                         load.i128
	<mat4f+18 @051132>   : 15 15                      set.x4 sp(21)
	<mat4f+20 @051134>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:40: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:45'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/vec/mat4f.ci:45: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:47'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:47: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:49'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:63: referenced as `dp4`
	lib/vec/mat4f.ci:62: referenced as `dp4`
	lib/vec/mat4f.ci:61: referenced as `dp4`
	lib/vec/mat4f.ci:60: referenced as `dp4`
	lib/vec/mat4f.ci:49: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@051138>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:52'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@051138> - <@0512d9>)
	lib/vec/mat4f.ci:53: (144 bytes: <@051138> - <@0511c8>): transposed: mat4f := {...}
	<mul @051138>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:54: (5 bytes: <@05113c> - <@051141>): void(transposed.x.x := rhs.x.x);
	<mul+4 @05113c>    : 10 11                      dup.x1 sp(17)
	<mul+6 @05113e>    : 22                         load.i32
	<mul+7 @05113f>    : 13 01                      set.x1 sp(1)
	lib/vec/mat4f.ci:54: (9 bytes: <@051141> - <@05114a>): void(transposed.x.y := rhs.y.x);
	<mul+9 @051141>    : 10 11                      dup.x1 sp(17)
	<mul+11 @051143>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @051147>   : 22                         load.i32
	<mul+16 @051148>   : 13 02                      set.x1 sp(2)
	lib/vec/mat4f.ci:54: (9 bytes: <@05114a> - <@051153>): void(transposed.x.z := rhs.z.x);
	<mul+18 @05114a>   : 10 11                      dup.x1 sp(17)
	<mul+20 @05114c>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @051150>   : 22                         load.i32
	<mul+25 @051151>   : 13 03                      set.x1 sp(3)
	lib/vec/mat4f.ci:54: (9 bytes: <@051153> - <@05115c>): void(transposed.x.w := rhs.w.x);
	<mul+27 @051153>   : 10 11                      dup.x1 sp(17)
	<mul+29 @051155>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @051159>   : 22                         load.i32
	<mul+34 @05115a>   : 13 04                      set.x1 sp(4)
	lib/vec/mat4f.ci:55: (9 bytes: <@05115c> - <@051165>): void(transposed.y.x := rhs.x.y);
	<mul+36 @05115c>   : 10 11                      dup.x1 sp(17)
	<mul+38 @05115e>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @051162>   : 22                         load.i32
	<mul+43 @051163>   : 13 05                      set.x1 sp(5)
	lib/vec/mat4f.ci:55: (9 bytes: <@051165> - <@05116e>): void(transposed.y.y := rhs.y.y);
	<mul+45 @051165>   : 10 11                      dup.x1 sp(17)
	<mul+47 @051167>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @05116b>   : 22                         load.i32
	<mul+52 @05116c>   : 13 06                      set.x1 sp(6)
	lib/vec/mat4f.ci:55: (9 bytes: <@05116e> - <@051177>): void(transposed.y.z := rhs.z.y);
	<mul+54 @05116e>   : 10 11                      dup.x1 sp(17)
	<mul+56 @051170>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @051174>   : 22                         load.i32
	<mul+61 @051175>   : 13 07                      set.x1 sp(7)
	lib/vec/mat4f.ci:55: (9 bytes: <@051177> - <@051180>): void(transposed.y.w := rhs.w.y);
	<mul+63 @051177>   : 10 11                      dup.x1 sp(17)
	<mul+65 @051179>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @05117d>   : 22                         load.i32
	<mul+70 @05117e>   : 13 08                      set.x1 sp(8)
	lib/vec/mat4f.ci:56: (9 bytes: <@051180> - <@051189>): void(transposed.z.x := rhs.x.z);
	<mul+72 @051180>   : 10 11                      dup.x1 sp(17)
	<mul+74 @051182>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @051186>   : 22                         load.i32
	<mul+79 @051187>   : 13 09                      set.x1 sp(9)
	lib/vec/mat4f.ci:56: (9 bytes: <@051189> - <@051192>): void(transposed.z.y := rhs.y.z);
	<mul+81 @051189>   : 10 11                      dup.x1 sp(17)
	<mul+83 @05118b>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @05118f>   : 22                         load.i32
	<mul+88 @051190>   : 13 0a                      set.x1 sp(10)
	lib/vec/mat4f.ci:56: (9 bytes: <@051192> - <@05119b>): void(transposed.z.z := rhs.z.z);
	<mul+90 @051192>   : 10 11                      dup.x1 sp(17)
	<mul+92 @051194>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @051198>   : 22                         load.i32
	<mul+97 @051199>   : 13 0b                      set.x1 sp(11)
	lib/vec/mat4f.ci:56: (9 bytes: <@05119b> - <@0511a4>): void(transposed.z.w := rhs.w.z);
	<mul+99 @05119b>   : 10 11                      dup.x1 sp(17)
	<mul+101 @05119d>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @0511a1>  : 22                         load.i32
	<mul+106 @0511a2>  : 13 0c                      set.x1 sp(12)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511a4> - <@0511ad>): void(transposed.w.x := rhs.x.w);
	<mul+108 @0511a4>  : 10 11                      dup.x1 sp(17)
	<mul+110 @0511a6>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @0511aa>  : 22                         load.i32
	<mul+115 @0511ab>  : 13 0d                      set.x1 sp(13)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511ad> - <@0511b6>): void(transposed.w.y := rhs.y.w);
	<mul+117 @0511ad>  : 10 11                      dup.x1 sp(17)
	<mul+119 @0511af>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @0511b3>  : 22                         load.i32
	<mul+124 @0511b4>  : 13 0e                      set.x1 sp(14)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511b6> - <@0511bf>): void(transposed.w.z := rhs.z.w);
	<mul+126 @0511b6>  : 10 11                      dup.x1 sp(17)
	<mul+128 @0511b8>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @0511bc>  : 22                         load.i32
	<mul+133 @0511bd>  : 13 0f                      set.x1 sp(15)
	lib/vec/mat4f.ci:57: (9 bytes: <@0511bf> - <@0511c8>): void(transposed.w.w := rhs.w.w);
	<mul+135 @0511bf>  : 10 11                      dup.x1 sp(17)
	<mul+137 @0511c1>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @0511c5>  : 22                         load.i32
	<mul+142 @0511c6>  : 13 10                      set.x1 sp(16)
	lib/vec/mat4f.ci:59: (273 bytes: <@0511c8> - <@0512d9>): return void(.result := {...});
	<mul+144 @0511c8>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @0511cc>  : 10 13                      dup.x1 sp(19)
	<mul+150 @0511ce>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @0511d2>  : 10 04                      dup.x1 sp(4)
	<mul+156 @0511d4>  : 24                         load.i128
	<mul+157 @0511d5>  : 10 09                      dup.x1 sp(9)
	<mul+159 @0511d7>  : 24                         load.i128
	<mul+160 @0511d8>  : 9b                         dp4.v4f
	<mul+161 @0511d9>  : 10 05                      dup.x1 sp(5)
	<mul+163 @0511db>  : 24                         load.i128
	<mul+164 @0511dc>  : 10 0a                      dup.x1 sp(10)
	<mul+166 @0511de>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @0511e2>  : 24                         load.i128
	<mul+171 @0511e3>  : 9b                         dp4.v4f
	<mul+172 @0511e4>  : 10 06                      dup.x1 sp(6)
	<mul+174 @0511e6>  : 24                         load.i128
	<mul+175 @0511e7>  : 10 0b                      dup.x1 sp(11)
	<mul+177 @0511e9>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @0511ed>  : 24                         load.i128
	<mul+182 @0511ee>  : 9b                         dp4.v4f
	<mul+183 @0511ef>  : 10 07                      dup.x1 sp(7)
	<mul+185 @0511f1>  : 24                         load.i128
	<mul+186 @0511f2>  : 10 0c                      dup.x1 sp(12)
	<mul+188 @0511f4>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @0511f8>  : 24                         load.i128
	<mul+193 @0511f9>  : 9b                         dp4.v4f
	<mul+194 @0511fa>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @0511ff>  : 02                         call
	<mul+200 @051200>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @051204>  : 15 02                      set.x4 sp(2)
	<mul+206 @051206>  : 15 17                      set.x4 sp(23)
	lib/vec/mat4f.ci:61: (68 bytes: <@051208> - <@05124c>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @051208>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @05120c>  : 10 13                      dup.x1 sp(19)
	<mul+214 @05120e>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @051212>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @051216>  : 10 04                      dup.x1 sp(4)
	<mul+224 @051218>  : 24                         load.i128
	<mul+225 @051219>  : 10 09                      dup.x1 sp(9)
	<mul+227 @05121b>  : 24                         load.i128
	<mul+228 @05121c>  : 9b                         dp4.v4f
	<mul+229 @05121d>  : 10 05                      dup.x1 sp(5)
	<mul+231 @05121f>  : 24                         load.i128
	<mul+232 @051220>  : 10 0a                      dup.x1 sp(10)
	<mul+234 @051222>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @051226>  : 24                         load.i128
	<mul+239 @051227>  : 9b                         dp4.v4f
	<mul+240 @051228>  : 10 06                      dup.x1 sp(6)
	<mul+242 @05122a>  : 24                         load.i128
	<mul+243 @05122b>  : 10 0b                      dup.x1 sp(11)
	<mul+245 @05122d>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @051231>  : 24                         load.i128
	<mul+250 @051232>  : 9b                         dp4.v4f
	<mul+251 @051233>  : 10 07                      dup.x1 sp(7)
	<mul+253 @051235>  : 24                         load.i128
	<mul+254 @051236>  : 10 0c                      dup.x1 sp(12)
	<mul+256 @051238>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @05123c>  : 24                         load.i128
	<mul+261 @05123d>  : 9b                         dp4.v4f
	<mul+262 @05123e>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @051243>  : 02                         call
	<mul+268 @051244>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @051248>  : 15 02                      set.x4 sp(2)
	<mul+274 @05124a>  : 15 1b                      set.x4 sp(27)
	lib/vec/mat4f.ci:62: (68 bytes: <@05124c> - <@051290>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @05124c>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @051250>  : 10 13                      dup.x1 sp(19)
	<mul+282 @051252>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @051256>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @05125a>  : 10 04                      dup.x1 sp(4)
	<mul+292 @05125c>  : 24                         load.i128
	<mul+293 @05125d>  : 10 09                      dup.x1 sp(9)
	<mul+295 @05125f>  : 24                         load.i128
	<mul+296 @051260>  : 9b                         dp4.v4f
	<mul+297 @051261>  : 10 05                      dup.x1 sp(5)
	<mul+299 @051263>  : 24                         load.i128
	<mul+300 @051264>  : 10 0a                      dup.x1 sp(10)
	<mul+302 @051266>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @05126a>  : 24                         load.i128
	<mul+307 @05126b>  : 9b                         dp4.v4f
	<mul+308 @05126c>  : 10 06                      dup.x1 sp(6)
	<mul+310 @05126e>  : 24                         load.i128
	<mul+311 @05126f>  : 10 0b                      dup.x1 sp(11)
	<mul+313 @051271>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @051275>  : 24                         load.i128
	<mul+318 @051276>  : 9b                         dp4.v4f
	<mul+319 @051277>  : 10 07                      dup.x1 sp(7)
	<mul+321 @051279>  : 24                         load.i128
	<mul+322 @05127a>  : 10 0c                      dup.x1 sp(12)
	<mul+324 @05127c>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @051280>  : 24                         load.i128
	<mul+329 @051281>  : 9b                         dp4.v4f
	<mul+330 @051282>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @051287>  : 02                         call
	<mul+336 @051288>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @05128c>  : 15 02                      set.x4 sp(2)
	<mul+342 @05128e>  : 15 1f                      set.x4 sp(31)
	lib/vec/mat4f.ci:63: (68 bytes: <@051290> - <@0512d4>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @051290>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @051294>  : 10 13                      dup.x1 sp(19)
	<mul+350 @051296>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @05129a>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @05129e>  : 10 04                      dup.x1 sp(4)
	<mul+360 @0512a0>  : 24                         load.i128
	<mul+361 @0512a1>  : 10 09                      dup.x1 sp(9)
	<mul+363 @0512a3>  : 24                         load.i128
	<mul+364 @0512a4>  : 9b                         dp4.v4f
	<mul+365 @0512a5>  : 10 05                      dup.x1 sp(5)
	<mul+367 @0512a7>  : 24                         load.i128
	<mul+368 @0512a8>  : 10 0a                      dup.x1 sp(10)
	<mul+370 @0512aa>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @0512ae>  : 24                         load.i128
	<mul+375 @0512af>  : 9b                         dp4.v4f
	<mul+376 @0512b0>  : 10 06                      dup.x1 sp(6)
	<mul+378 @0512b2>  : 24                         load.i128
	<mul+379 @0512b3>  : 10 0b                      dup.x1 sp(11)
	<mul+381 @0512b5>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @0512b9>  : 24                         load.i128
	<mul+386 @0512ba>  : 9b                         dp4.v4f
	<mul+387 @0512bb>  : 10 07                      dup.x1 sp(7)
	<mul+389 @0512bd>  : 24                         load.i128
	<mul+390 @0512be>  : 10 0c                      dup.x1 sp(12)
	<mul+392 @0512c0>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @0512c4>  : 24                         load.i128
	<mul+397 @0512c5>  : 9b                         dp4.v4f
	<mul+398 @0512c6>  : 1f d8 10 05 00             load.ref <@0510d8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @0512cb>  : 02                         call
	<mul+404 @0512cc>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @0512d0>  : 15 02                      set.x4 sp(2)
	<mul+410 @0512d2>  : 15 23                      set.x4 sp(35)
	<mul+412 @0512d4>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @0512d8>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:52: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+32>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+40>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+44>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+52>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+60>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+64>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+248>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@030ff0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031120>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+272>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+280>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0512e0>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+284>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+288>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+296>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+304>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+308>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+320>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+328>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+332>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+336>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+340>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+344>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+352>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+356>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+364>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+372>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+376>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+380>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+388>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+392>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+396>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+472>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+480>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+488>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+496>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+504>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+512>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+520>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+528>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+536>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+544>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+552>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+560>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+568>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+576>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+584>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+592>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+600>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+608>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+612>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+684>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+692>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+696>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+708>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+712>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@0512e8>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@0512e8> - <@0512e9>)
	<empty @0512e8>      : 03                         ret
.usages:
	test/lang/function.ci:4: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@0512f0>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@0512f0> - <@0512f8>)
	test/lang/function.ci:8: (8 bytes: <@0512f0> - <@0512f8>): return int32(.result := int32(x + y));
	<funAdd @0512f0>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @0512f2>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @0512f4>    : 51                         add.i32
	<funAdd+5 @0512f5>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @0512f7>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
	test/lang/function.ci:7: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+716>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:12: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+720>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
	test/lang/function.ci:15: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+724>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:18: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+728>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
	test/lang/function.ci:21: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+732>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:24: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+736>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
	test/lang/function.ci:27: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+740>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:30: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@0512f8>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@0512f8> - <@051300>)
	test/lang/function.ci:34: (8 bytes: <@0512f8> - <@051300>): return int32(.result := int32(x * y));
	<funMul @0512f8>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @0512fa>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @0512fc>    : 53                         mul.i32
	<funMul+5 @0512fd>    : 13 04                      set.x1 sp(4)
	<funMul+7 @0512ff>    : 03                         ret
.usages:
	test/lang/function.ci:33: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@051300>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@051300> - <@051336>)
	test/lang/function.ci:39: (16 bytes: <@051300> - <@051310>): if (bool(n <= (1)))
	<fib @051300>      : 10 01                      dup.x1 sp(1)
	<fib+2 @051302>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @051307>    : 39                         cgt.u32
	<fib+8 @051308>    : 05 08 00 00                jnz <fib+16 @051310>
	test/lang/function.ci:40: (4 bytes: <@05130c> - <@051310>): return uint32(.result := n);
	<fib+12 @05130c>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @05130f>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@051310> - <@051336>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @051310>   : 19                         load.z32
	<fib+17 @051311>   : 10 02                      dup.x1 sp(2)
	<fib+19 @051313>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @051317>   : 1f 00 13 05 00             load.ref <@051300> ;fib(n: uint32): uint32
	<fib+28 @05131c>   : 02                         call
	<fib+29 @05131d>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @051321>   : 19                         load.z32
	<fib+34 @051322>   : 10 03                      dup.x1 sp(3)
	<fib+36 @051324>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @051328>   : 1f 00 13 05 00             load.ref <@051300> ;fib(n: uint32): uint32
	<fib+45 @05132d>   : 02                         call
	<fib+46 @05132e>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @051332>   : 51                         add.i32
	<fib+51 @051333>   : 13 03                      set.x1 sp(3)
	<fib+53 @051335>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:38: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+744>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
	test/lang/function.ci:46: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+748>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@036f88>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@0370b8>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+820>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+824>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+828>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+836>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+840>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+844>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+848>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+852>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+860>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+864>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+868>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+872>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+880>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+884>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+896>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.usages:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+904>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.usages:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+908>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.usages:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.usages:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+916>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+988>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+996>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1004>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1012>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1020>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1028>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1036>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1044>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1048>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1080>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1084>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1088>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1092>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1096>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1100>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1104>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1108>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1112>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1120>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.usages:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1124>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.usages:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1128>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.usages:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1132>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.usages:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1140>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.usages:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1148>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.usages:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@051338>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@051338> - <@051339>)
	<noError @051338>      : 03                         ret
.usages:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@051340>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@051340> - <@051358>)
	test/stdc/tryExec.ci:15: (4 bytes: <@051340> - <@051344>): data: uint8[8192]
	<stackOverflow @051340>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@051344> - <@051353>): stackOverflow(ptr);
	<stackOverflow+4 @051344>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @051348>    : 22                         load.i32
	<stackOverflow+9 @051349>    : 1f 40 13 05 00             load.ref <@051340> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @05134e>   : 02                         call
	<stackOverflow+15 @05134f>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @051353>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @051357>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@051358>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@051358> - <@051364>)
	test/stdc/tryExec.ci:20: (7 bytes: <@051358> - <@05135f>): value: int32 := int32(3 / 0)
	<divisionByZero @051358>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @05135d>    : 19                         load.z32
	<divisionByZero+6 @05135e>    : 54                         div.i32
	<divisionByZero+7 @05135f>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @051363>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@051368>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@051368> - <@0513ac>)
	test/stdc/tryExec.ci:29: (25 bytes: <@051368> - <@051381>): details: NotEquals := {...}
	<abortExecution @051368>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@05136c> - <@051373>): void(details.message := ("assertion failed"));
	<abortExecution+4 @05136c>    : 1f 7b cc 00 00             load.ref <@00cc7b> ;"assertion failed"
	<abortExecution+9 @051371>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@051373> - <@05137a>): void(details.expected := 97);
	<abortExecution+11 @051373>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @051378>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@05137a> - <@051381>): void(details.returned := 77);
	<abortExecution+18 @05137a>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @05137f>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@051381> - <@0513a7>): abort(void("fatal error", details));
	<abortExecution+25 @051381>   : 1f 28 ad 03 00             load.ref <@03ad28> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @051386>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @05138b>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @051390>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @051395>   : 1f 71 ad 03 00             load.ref <@03ad71> ;"fatal error"
	<abortExecution+50 @05139a>   : 1f 88 b7 03 00             load.ref <@03b788> ;abortExecution.NotEquals
	<abortExecution+55 @05139f>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @0513a3>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @0513a7>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @0513ab>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@0513b0>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@0513b0> - <@0513bd>)
	test/stdc/tryExec.ci:38: (5 bytes: <@0513b0> - <@0513b5>): i32Ref: int32 := null
	<invalidMemoryAccess @0513b0>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@0513b5> - <@0513b8>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @0513b5>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @0513b7>    : 22                         load.i32
	<invalidMemoryAccess+8 @0513b8>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @0513bc>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@0513c0>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@0513c0> - <@0513c2>)
	test/stdc/tryExec.ci:43: (2 bytes: <@0513c0> - <@0513c2>): emit(void(load.z32, ret));
	<invalidInstruction @0513c0>      : 19                         load.z32
	<invalidInstruction+1 @0513c1>    : 03                         ret
.usages:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1152>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1156>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1160>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1164>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1168>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1172>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1176>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1232>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1256>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1260>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1268>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1272>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1280>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1284>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1292>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1296>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1304>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@0513c8>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@0513c8> - <@0513cc>)
	test/lang/array.ci:103: (4 bytes: <@0513c8> - <@0513cc>): return uint32(.result := values.length);
	<lenSlice @0513c8>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @0513cb>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0513d0>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0513d0> - <@0513dc>)
	test/lang/array.ci:104: (12 bytes: <@0513d0> - <@0513dc>): return int64(.result := values[idx]);
	<nthFixed @0513d0>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @0513d2>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @0513d4>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @0513d8>    : 23                         load.i64
	<nthFixed+9 @0513d9>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @0513db>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0513e0>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0513e0> - <@0513ec>)
	test/lang/array.ci:105: (12 bytes: <@0513e0> - <@0513ec>): return int64(.result := values[idx]);
	<nthArray @0513e0>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @0513e2>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @0513e4>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @0513e8>    : 23                         load.i64
	<nthArray+9 @0513e9>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @0513eb>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0513f0>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0513f0> - <@0513fc>)
	test/lang/array.ci:106: (12 bytes: <@0513f0> - <@0513fc>): return int64(.result := values[idx]);
	<nthSlice @0513f0>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @0513f2>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @0513f4>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @0513f8>    : 23                         load.i64
	<nthSlice+9 @0513f9>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @0513fb>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03e4d0>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@03e568>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@051400>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@051408>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@051410>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@051418>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@051420>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@051428>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03e568>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051400>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051408>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@051410>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@051418>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@051420>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@051428>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1336>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03f3a8>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:4'
.field staticMethod: function (size: 39, offs: <@051430>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@051458>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@051460>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@051488>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/method.ci:102: referenced as `RecordMethodTest`
	test/lang/method.ci:101: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:87: referenced as `RecordMethodTest`
	test/lang/method.ci:84: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:57: referenced as `RecordMethodTest`
	test/lang/method.ci:47: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:32: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:18: referenced as `RecordMethodTest`
	test/lang/method.ci:10: referenced as `RecordMethodTest`
	test/lang/method.ci:4: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051430>
.name: 'staticMethod'
.file: 'test/lang/method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@051430> - <@051457>)
	test/lang/method.ci:11: (38 bytes: <@051430> - <@051456>): trace(void("staticMethod", x));
	<staticMethod @051430>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<staticMethod+5 @051435>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @05143a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @05143f>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @051444>   : 1f 85 ef 03 00             load.ref <@03ef85> ;"staticMethod"
	<staticMethod+25 @051449>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @05144e>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @051452>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @051456>   : 03                         ret
.usages:
	test/lang/method.ci:101: referenced as `staticMethod`
	test/lang/method.ci:87: referenced as `staticMethod`
	test/lang/method.ci:78: referenced as `staticMethod`
	test/lang/method.ci:10: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051458>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: referenced as `forwardMethod`
	test/lang/method.ci:18: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:25: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/method.ci:103: referenced as `virtualMethod`
	test/lang/method.ci:93: referenced as `virtualMethod`
	test/lang/method.ci:79: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051460>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@051460> - <@051487>)
	test/lang/method.ci:41: (38 bytes: <@051460> - <@051486>): trace(void("virtualMethod", x));
	<virtualMethod @051460>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<virtualMethod+5 @051465>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @05146a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @05146f>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @051474>   : 1f 76 f2 03 00             load.ref <@03f276> ;"virtualMethod"
	<virtualMethod+25 @051479>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @05147e>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @051482>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @051486>   : 03                         ret
.usages:
	test/lang/method.ci:102: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@051488>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@051488> - <@0514af>)
	test/lang/method.ci:48: (38 bytes: <@051488> - <@0514ae>): trace(void("forwardMethod", x));
	<forwardMethod @051488>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<forwardMethod+5 @05148d>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @051492>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @051497>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @05149c>   : 1f fd ef 03 00             load.ref <@03effd> ;"forwardMethod"
	<forwardMethod+25 @0514a1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @0514a6>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @0514aa>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @0514ae>   : 03                         ret
.usages:
	test/lang/method.ci:47: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@0514b0>
.name: 'globalFunction'
.file: 'test/lang/method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@0514b0> - <@0514d7>)
	test/lang/method.ci:58: (38 bytes: <@0514b0> - <@0514d6>): trace(void("globalFunction", x));
	<globalFunction @0514b0>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<globalFunction+5 @0514b5>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @0514ba>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @0514bf>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @0514c4>   : 1f a9 f2 03 00             load.ref <@03f2a9> ;"globalFunction"
	<globalFunction+25 @0514c9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @0514ce>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @0514d2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @0514d6>   : 03                         ret
.usages:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:57: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1352>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:102: referenced as `recordMethodTest`
	test/lang/method.ci:101: referenced as `recordMethodTest`
	test/lang/method.ci:98: referenced as `recordMethodTest`
	test/lang/method.ci:97: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:78: referenced as `recordMethodTest`
	test/lang/method.ci:62: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@0514d8>
.name: 'staticMethod'
.file: 'test/lang/method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@0514d8> - <@05151a>)
	test/lang/method.ci:85: (35 bytes: <@0514d8> - <@0514fb>): debug("extension.staticMethod");
	<staticMethod @0514d8>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<staticMethod+5 @0514dd>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @0514e2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0514e7>   : 19                         load.z32
	<staticMethod+16 @0514e8>   : 1f 77 f3 03 00             load.ref <@03f377> ;"extension.staticMethod"
	<staticMethod+21 @0514ed>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @0514f2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @0514f7>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:86: (30 bytes: <@0514fb> - <@051519>): if (bool((this) != null))
	<staticMethod+35 @0514fb>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @0514ff>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @051504>   : 57                         ceq.i32
	<staticMethod+45 @051505>   : 05 14 00 00                jnz <staticMethod+65 @051519>
	test/lang/method.ci:87: (16 bytes: <@051509> - <@051519>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @051509>   : 12 02                      dup.x4 sp(2)
	<staticMethod+51 @05150b>   : 10 05                      dup.x1 sp(5)
	<staticMethod+53 @05150d>   : 13 04                      set.x1 sp(4)
	<staticMethod+55 @05150f>   : 1f 30 14 05 00             load.ref <@051430> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @051514>   : 02                         call
	<staticMethod+61 @051515>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @051519>   : 03                         ret
.usages:
	test/lang/method.ci:97: referenced as `staticMethod`
	test/lang/method.ci:84: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@051520>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@051520> - <@05155f>)
	test/lang/method.ci:91: (35 bytes: <@051520> - <@051543>): debug("extension.virtualMethod");
	<virtualMethod @051520>      : 1f e8 ee 03 00             load.ref <@03eee8> ;"test/lang/method.ci"
	<virtualMethod+5 @051525>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @05152a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @05152f>   : 19                         load.z32
	<virtualMethod+16 @051530>   : 1f 8e f3 03 00             load.ref <@03f38e> ;"extension.virtualMethod"
	<virtualMethod+21 @051535>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @05153a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @05153f>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:92: (27 bytes: <@051543> - <@05155e>): if (bool((this) != null))
	<virtualMethod+35 @051543>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @051547>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @05154c>   : 57                         ceq.i32
	<virtualMethod+45 @05154d>   : 05 11 00 00                jnz <virtualMethod+62 @05155e>
	test/lang/method.ci:93: (13 bytes: <@051551> - <@05155e>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @051551>   : 12 02                      dup.x4 sp(2)
	<virtualMethod+51 @051553>   : 10 05                      dup.x1 sp(5)
	<virtualMethod+53 @051555>   : 13 04                      set.x1 sp(4)
	<virtualMethod+55 @051557>   : 10 08                      dup.x1 sp(8)
	<virtualMethod+57 @051559>   : 02                         call
	<virtualMethod+58 @05155a>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @05155e>   : 03                         ret
.usages:
	test/lang/method.ci:98: referenced as `virtualMethod`
	test/lang/method.ci:90: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@040b28>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@040d88>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@040fe8>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@0411b0>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1356>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1360>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1364>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1368>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1372>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@041650>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@041a78>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@041ea0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@0422c8>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0426f0>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@042b18>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1376>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1408>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1412>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1416>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1420>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1424>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1468>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1472>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1476>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1480>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1484>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1496>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1500>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1504>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1508>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1512>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1556>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1560>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1564>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1568>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1572>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1584>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1588>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1592>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1596>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1600>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1644>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1648>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1652>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1656>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1660>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1672>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1676>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1680>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1684>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1688>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1732>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1736>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1740>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1744>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1748>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1760>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1764>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1768>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1772>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1776>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1820>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1824>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1828>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1832>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1836>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1848>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1852>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1856>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1860>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1864>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1908>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1912>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1916>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1920>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1924>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1936>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1940>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1944>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1948>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1952>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1996>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2000>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2004>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2008>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2012>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2024>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2028>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2032>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2036>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2040>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2048>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2056>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2064>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2072>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2080>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2088>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2096>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2104>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2112>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2120>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2128>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2136>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2144>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2152>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2160>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2172>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2176>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2180>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2184>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2188>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2196>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2204>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2212>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2220>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2228>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2236>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2244>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2252>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2260>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2268>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2276>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2284>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2292>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2300>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2308>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2320>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2324>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2328>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2332>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2336>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2356>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2360>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2364>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2368>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2372>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2384>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2388>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2392>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2396>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2400>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2408>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2416>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2424>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2432>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2440>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2448>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2456>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2464>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2472>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2484>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2488>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2500>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2504>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2508>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2512>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2516>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2520>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2524>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2532>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2540>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2548>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2556>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2564>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2572>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2580>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2588>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2596>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2604>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2612>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2620>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2628>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2636>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2644>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2652>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2660>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2668>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2676>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2684>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2692>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2700>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2708>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2716>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2724>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2732>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2740>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2748>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2756>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:38'
.value: Math.min()
.usages:
	test/stdc/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2764>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2772>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.max()
.usages:
	test/stdc/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2780>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2788>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:43'
.value: Math.sum()
.usages:
	test/stdc/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2796>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/stdc/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2804>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/stdc/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2812>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/stdc/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2820>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:48'
.value: 10
.usages:
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: referenced as `testMathEval_x`
	test/stdc/test.math.ci:49: referenced as `testMathEval_x`
	test/stdc/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2828>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/stdc/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2836>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/stdc/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2844>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2852>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2860>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2868>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2876>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2884>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2892>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2900>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/stdc/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2908>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2916>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2924>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/stdc/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2932>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/stdc/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2936>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2940>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2948>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2956>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2964>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2972>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2980>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2988>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2996>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3004>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3012>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3020>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3028>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3032>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3036>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3040>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3044>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3048>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3052>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3056>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3060>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3064>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3068>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3072>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 10884
.offset: <@05155f>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@001058>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@0010f8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005c20>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006d00>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0075e0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008250>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 32, offs: <@00fbe0>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@050210>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@010e58>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@019b78>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@050a10>, cast: static const function)
.field Complex: function (size: 7, offs: <@050a18>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 123, offs: <@050a20>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 31, offs: <@050aa0>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 100, offs: <@050ac0>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 38, offs: <@050b28>, cast: static const function)
.field indexOf: function (size: 50, offs: <@050b50>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@050b88>, cast: static const function)
.field startsWith: function (size: 73, offs: <@050bc0>, cast: static const function)
.field endsWith: function (size: 126, offs: <@050c10>, cast: static const function)
.field compare: function (size: 63, offs: <@050c90>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@050d18>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@050d40>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@0225a0>, cast: static const typename(val))
.field append: function (size: 84, offs: <@050d50>, cast: static const function)
.field append: function (size: 657, offs: <@050db8>, cast: static const function)
.field append: function (size: 23, offs: <@051050>, cast: static const function)
.field append: function (size: 49, offs: <@051068>, cast: static const function)
.field append: function (size: 25, offs: <@0510b0>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@024730>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@0510d0>, cast: static const function)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field dot: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: typename (size: 16, offs: <@0256e8>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@0510d8>, cast: static const function)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field cross: function (size: 0, offs: <+0>, cast: inline)
.field len: function (size: 0, offs: <+0>, cast: inline)
.field normalize: function (size: 0, offs: <+0>, cast: inline)
.field eval: function (size: 0, offs: <+0>, cast: inline)
.field mat4f: typename (size: 64, offs: <@028ac8>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@0510e8>, cast: static const function)
.field mat4f: function (size: 21, offs: <@051120>, cast: static const function)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 417, offs: <@051138>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+32>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+40>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+44>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+52>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+60>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+64>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+248>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@030ff0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@031120>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+272>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+280>, cast: variable(val))
.field value: int64 (size: 8, offs: <@0512e0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+284>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+288>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+296>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+304>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+308>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+320>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+328>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+332>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+336>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+340>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+344>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+352>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+356>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+364>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+372>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+376>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+380>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+388>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+392>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+396>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+472>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+480>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+488>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+496>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+504>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+512>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+520>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+528>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+536>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+544>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+552>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+560>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+568>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+576>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+584>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+592>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+600>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+608>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+612>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+680>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+692>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+696>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+700>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+708>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+712>, cast: variable(ref))
.field empty: function (size: 1, offs: <@0512e8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@0512f0>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+716>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+720>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+724>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+728>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+732>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+736>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+740>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@0512f8>, cast: static const function)
.field fib: function (size: 54, offs: <@051300>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+744>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+748>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@036f88>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@0370b8>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+820>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+824>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+828>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+836>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+840>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+844>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+848>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+852>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+860>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+864>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+868>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+872>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+880>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+884>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+896>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+904>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+908>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+916>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field testSin_f64: float64 (size: 8, offs: <+988>, cast: variable(f64))
.field testCos_f64: float64 (size: 8, offs: <+996>, cast: variable(f64))
.field testTan_f64: float64 (size: 8, offs: <+1004>, cast: variable(f64))
.field testLog_f64: float64 (size: 8, offs: <+1012>, cast: variable(f64))
.field testExp_f64: float64 (size: 8, offs: <+1020>, cast: variable(f64))
.field testPow_f64: float64 (size: 8, offs: <+1028>, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <+1036>, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <+1044>, cast: variable(f64))
.field testSin_f32: float32 (size: 4, offs: <+1048>, cast: variable(f32))
.field testCos_f32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field testTan_f32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field testLog_f32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field testExp_f32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field testPow_f32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <+1080>, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <+1084>, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <+1088>, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <+1092>, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <+1096>, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <+1100>, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <+1104>, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <+1108>, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <+1112>, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1120>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1124>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1128>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1132>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1140>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1148>, cast: variable(i64))
.field noError: function (size: 1, offs: <@051338>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@051340>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@051358>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@051368>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@0513b0>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@0513c0>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1152>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1156>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1160>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1164>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1168>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1172>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1176>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1232>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1256>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1268>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1272>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1280>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1284>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1292>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1296>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1304>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@0513c8>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@0513d0>, cast: static const function)
.field nthArray: function (size: 12, offs: <@0513e0>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@0513f0>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@03e4d0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1336>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@03f3a8>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@0514b0>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1352>, cast: variable(val))
.field staticMethod: function (size: 66, offs: <@0514d8>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@051520>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@040b28>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@040d88>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@040fe8>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@0411b0>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1356>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1360>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1364>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1368>, cast: variable(val))
.field blue: color (size: 4, offs: <+1372>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@041650>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@041a78>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@041ea0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@0422c8>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@0426f0>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@042b18>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1376>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1408>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1412>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1416>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1420>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1424>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1468>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1472>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1476>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1480>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1484>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1496>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1500>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1504>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1508>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1512>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1556>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1560>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1564>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1568>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1572>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1584>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1588>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1592>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1596>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1600>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1644>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1648>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1652>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1656>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1660>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1672>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1676>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1680>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1684>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1688>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1732>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1736>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1740>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1744>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1748>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1760>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1764>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1768>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1772>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1776>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1820>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1824>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1828>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1832>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1836>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1848>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1852>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1856>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1860>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1864>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1908>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1912>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1916>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1920>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1924>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1936>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1940>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1944>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1948>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1952>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1996>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+2000>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+2004>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+2008>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+2012>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2024>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2028>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2032>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2036>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2040>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2048>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2056>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2064>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2072>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2080>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2088>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2096>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2104>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2112>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2120>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2128>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2136>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2144>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2152>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2160>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2172>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2176>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2180>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2184>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2188>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2196>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2204>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2212>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2220>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2228>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2236>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2244>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2252>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2260>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2268>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2276>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2284>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2292>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2300>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2308>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2320>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2324>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2328>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2332>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2336>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2356>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2360>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2364>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2368>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2372>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2384>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2388>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2392>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2396>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2400>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2408>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2416>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2424>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2432>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2440>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2448>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2456>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2464>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2472>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2484>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2488>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2500>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2504>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2508>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2512>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2516>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2520>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2524>, cast: variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <+2532>, cast: variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <+2540>, cast: variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <+2548>, cast: variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <+2556>, cast: variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <+2564>, cast: variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <+2572>, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <+2580>, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <+2588>, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <+2596>, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <+2604>, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <+2612>, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <+2620>, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <+2628>, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <+2636>, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <+2644>, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <+2652>, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <+2660>, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <+2668>, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <+2676>, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <+2684>, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <+2692>, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <+2700>, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <+2708>, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <+2716>, cast: variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <+2724>, cast: variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <+2732>, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <+2740>, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <+2748>, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <+2756>, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <+2764>, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <+2772>, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <+2780>, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <+2788>, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <+2796>, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <+2804>, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <+2812>, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <+2820>, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <+2828>, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <+2836>, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <+2844>, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <+2852>, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <+2860>, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <+2868>, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <+2876>, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <+2884>, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <+2892>, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <+2900>, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <+2908>, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <+2916>, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <+2924>, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <+2932>, cast: variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <+2936>, cast: variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <+2940>, cast: variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <+2948>, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <+2956>, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <+2964>, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <+2972>, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <+2980>, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <+2988>, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <+2996>, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <+3004>, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <+3012>, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <+3020>, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <+3028>, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <+3032>, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <+3036>, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <+3040>, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <+3044>, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <+3048>, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <+3052>, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <+3056>, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <+3060>, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <+3064>, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <+3068>, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <+3072>, cast: variable(f32))
.field .main: function (size: 10884, offs: <@05155f>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				m: float32[4][4];
				data: float32[16];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		testExp_f64: float64 := float64.exp(1.000000);
		testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		testExp_f32: float32 := float32.exp(1.000000);
		testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		testPopulation_u32: int32 := uint32.pop(r5g6b5);
		testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		testHighBit_u32: int32 := uint32.hib(r5g6b5);
		testLowBit_u32: int32 := uint32.lob(r5g6b5);
		testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		testMathFloor_1: float64 := Math.floor(3.200000);
		testMathFloor_2: float64 := Math.floor(3.500000);
		testMathFloor_3: float64 := Math.floor(3.600000);
		testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(void(1, 2));
		testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (10884 bytes: <@05155f> - <@053fe3>)
	lib/std/string.ci:144: (14 bytes: <@05155f> - <@05156d>): static const whiteSpace: char[] := " \t\n\r"
	<.main @05155f>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @051564>    : 1f b9 f0 01 00             load.ref <@01f0b9> ;" \t\n\r"
	<.main+10 @051569>   : 2d a8 0d 05                store.m64 <@050da8> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@05156d> - <@05157b>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @05156d>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @051572>   : 1f ca f0 01 00             load.ref <@01f0ca> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @051577>   : 2d b0 0d 05                store.m64 <@050db0> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes: <@05157b> - <@051595>): static const format: FormatFlags := {...}
	<.main+28 @05157b>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @051580>   : 2e a0 10 05                store.m32 <@0510a0> ;append.format
	:: (7 bytes: <@051584> - <@05158b>): void(format.padChr := (0))
	<.main+37 @051584>   : 19                         load.z32
	<.main+38 @051585>   : 1f a4 10 05 00             load.ref <@0510a4> ;append.format+4
	<.main+43 @05158a>   : 25                         store.i8
	:: (5 bytes: <@05158b> - <@051590>): void(format.padLen := 0)
	<.main+44 @05158b>   : 19                         load.z32
	<.main+45 @05158c>   : 2e a8 10 05                store.m32 <@0510a8> ;append.format+8
	:: (5 bytes: <@051590> - <@051595>): void(format.precision := 0)
	<.main+49 @051590>   : 19                         load.z32
	<.main+50 @051591>   : 2e ac 10 05                store.m32 <@0510ac> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@051595> - <@0515a2>): static value: int64 := 42
	<.main+54 @051595>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @05159e>   : 2d e0 12 05                store.m64 <@0512e0> ;value
	test/lang/member.ci:35: (5 bytes: <@0515a2> - <@0515a7>): static global: int32
	<.main+67 @0515a2>   : 19                         load.z32
	<.main+68 @0515a3>   : 2e 00 14 05                store.m32 <@051400> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@0515a7> - <@0515b0>): static globalInit: int32 := 1
	<.main+72 @0515a7>   : 1c 01 00 00 00             load.c32 1
	<.main+77 @0515ac>   : 2e 08 14 05                store.m32 <@051408> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@0515b0> - <@0515b9>): static const globalConstant: int32 := 2
	<.main+81 @0515b0>   : 1c 02 00 00 00             load.c32 2
	<.main+86 @0515b5>   : 2e 10 14 05                store.m32 <@051410> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@0515b9> - <@0515cb>): static globalRecInit: Inner := {...}
	<.main+90 @0515b9>   : 1c 04 00 00 00             load.c32 4
	<.main+95 @0515be>   : 2e 20 14 05                store.m32 <@051420> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@0515c2> - <@0515cb>): void(globalRecInit.constant := 5);
	<.main+99 @0515c2>   : 1c 05 00 00 00             load.c32 5
	<.main+104 @0515c7>  : 2e 24 14 05                store.m32 <@051424> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@0515cb> - <@0515dd>): static const globalConstantRec: Inner := {...}
	<.main+108 @0515cb>  : 1c 06 00 00 00             load.c32 6
	<.main+113 @0515d0>  : 2e 28 14 05                store.m32 <@051428> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@0515d4> - <@0515dd>): void(globalConstantRec.constant := 7);
	<.main+117 @0515d4>  : 1c 07 00 00 00             load.c32 7
	<.main+122 @0515d9>  : 2e 2c 14 05                store.m32 <@05142c> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:18: (9 bytes: <@0515dd> - <@0515e6>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+126 @0515dd>  : 1f 88 14 05 00             load.ref <@051488> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+131 @0515e2>  : 2e 58 14 05                store.m32 <@051458> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/emit.ci:3: (1 byte: <@0515e6> - <@0515e7>): emitldz32: int32 := emit(load.z32)
	<.main+135 @0515e6>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@0515e7> - <@0515e8>): emitldz64: int64 := emit(load.z64)
	<.main+136 @0515e7>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@0515e8> - <@0515ed>): emitA: int32 := 42
	<.main+137 @0515e8>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@0515ed> - <@0515f2>): emitB: int32 := 96
	<.main+142 @0515ed>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@0515f2> - <@0515f7>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @0515f2>  : 10 01                      dup.x1 sp(1)
	<.main+149 @0515f4>  : 10 01                      dup.x1 sp(1)
	<.main+151 @0515f6>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@0515f7> - <@051602>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @0515f7>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @0515fc>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @051601>  : 54                         div.i32
	test/lang/emit.ci:17: (5 bytes: <@051602> - <@051607>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+163 @051602>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@051607> - <@05160d>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+168 @051607>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+173 @05160c>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@05160d> - <@051617>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+174 @05160d>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+183 @051616>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@051617> - <@051620>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+184 @051617>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@051620> - <@05162a>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+193 @051620>  : 1c 03 00 00 00             load.c32 3
	<.main+198 @051625>  : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@05162a> - <@05162f>): i3: int32 := 3
	<.main+203 @05162a>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@05162f> - <@051634>): i6: int32 := 6
	<.main+208 @05162f>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@051634> - <@051639>): i2: int32 := 2
	<.main+213 @051634>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@051639> - <@05163e>): i8: int32 := 8
	<.main+218 @051639>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@05163e> - <@05163f>): zeroVal: int32 := zero(void(3, 6))
	<.main+223 @05163e>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@05163f> - <@051640>): zeroVar: int32 := zero(void(i3, i6))
	<.main+224 @05163f>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@051640> - <@051641>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+225 @051640>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@051641> - <@051646>): lastVal: int32 := last(void(3, 6))
	<.main+226 @051641>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@051646> - <@051648>): lastVar: int32 := last(void(i3, i6))
	<.main+231 @051646>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@051648> - <@051652>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+233 @051648>  : 10 07                      dup.x1 sp(7)
	<.main+235 @05164a>  : 0c 01 00 00                inc.i32(+1)
	<.main+239 @05164e>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@051652> - <@05165b>): sum2Val: int32 := sum(void(3, 6))
	<.main+243 @051652>  : 1c 03 00 00 00             load.c32 3
	<.main+248 @051657>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@05165b> - <@051660>): sum2Var: int32 := sum(void(i3, i6))
	<.main+252 @05165b>  : 10 0a                      dup.x1 sp(10)
	<.main+254 @05165d>  : 10 0a                      dup.x1 sp(10)
	<.main+256 @05165f>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@051660> - <@051671>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+257 @051660>  : 10 0b                      dup.x1 sp(11)
	<.main+259 @051662>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @051666>  : 10 0b                      dup.x1 sp(11)
	<.main+265 @051668>  : 0c 01 00 00                inc.i32(+1)
	<.main+269 @05166c>  : 51                         add.i32
	<.main+270 @05166d>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@051671> - <@051689>): any2Val: int32 := any(void(3, 6))
	<.main+274 @051671>  : 1c 03 00 00 00             load.c32 3
	<.main+279 @051676>  : 10 00                      dup.x1 sp(0)
	<.main+281 @051678>  : 06 0a 00 00                jz <.main+291 @051682>
	<.main+285 @05167c>  : 10 00                      dup.x1 sp(0)
	<.main+287 @05167e>  : 04 09 00 00                jmp <.main+296 @051687>
	<.main+291 @051682>  : 1c 06 00 00 00             load.c32 6
	<.main+296 @051687>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@051689> - <@05169b>): any2Var: int32 := any(void(i3, i6))
	<.main+298 @051689>  : 10 0d                      dup.x1 sp(13)
	<.main+300 @05168b>  : 10 00                      dup.x1 sp(0)
	<.main+302 @05168d>  : 06 0a 00 00                jz <.main+312 @051697>
	<.main+306 @051691>  : 10 00                      dup.x1 sp(0)
	<.main+308 @051693>  : 04 06 00 00                jmp <.main+314 @051699>
	<.main+312 @051697>  : 10 0d                      dup.x1 sp(13)
	<.main+314 @051699>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@05169b> - <@0516b9>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+316 @05169b>  : 10 0e                      dup.x1 sp(14)
	<.main+318 @05169d>  : 0c 01 00 00                inc.i32(+1)
	<.main+322 @0516a1>  : 10 00                      dup.x1 sp(0)
	<.main+324 @0516a3>  : 06 0a 00 00                jz <.main+334 @0516ad>
	<.main+328 @0516a7>  : 10 00                      dup.x1 sp(0)
	<.main+330 @0516a9>  : 04 0a 00 00                jmp <.main+340 @0516b3>
	<.main+334 @0516ad>  : 10 0e                      dup.x1 sp(14)
	<.main+336 @0516af>  : 0c 01 00 00                inc.i32(+1)
	<.main+340 @0516b3>  : 13 01                      set.x1 sp(1)
	<.main+342 @0516b5>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@0516b9> - <@0516da>): min2Val: int32 := min(void(3, 6))
	<.main+346 @0516b9>  : 1c 03 00 00 00             load.c32 3
	<.main+351 @0516be>  : 1c 06 00 00 00             load.c32 6
	<.main+356 @0516c3>  : 10 01                      dup.x1 sp(1)
	<.main+358 @0516c5>  : 10 01                      dup.x1 sp(1)
	<.main+360 @0516c7>  : 58                         clt.i32
	<.main+361 @0516c8>  : 06 0a 00 00                jz <.main+371 @0516d2>
	<.main+365 @0516cc>  : 10 01                      dup.x1 sp(1)
	<.main+367 @0516ce>  : 04 06 00 00                jmp <.main+373 @0516d4>
	<.main+371 @0516d2>  : 10 00                      dup.x1 sp(0)
	<.main+373 @0516d4>  : 13 02                      set.x1 sp(2)
	<.main+375 @0516d6>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@0516da> - <@0516f5>): min2Var: int32 := min(void(i3, i6))
	<.main+379 @0516da>  : 10 10                      dup.x1 sp(16)
	<.main+381 @0516dc>  : 10 10                      dup.x1 sp(16)
	<.main+383 @0516de>  : 10 01                      dup.x1 sp(1)
	<.main+385 @0516e0>  : 10 01                      dup.x1 sp(1)
	<.main+387 @0516e2>  : 58                         clt.i32
	<.main+388 @0516e3>  : 06 0a 00 00                jz <.main+398 @0516ed>
	<.main+392 @0516e7>  : 10 01                      dup.x1 sp(1)
	<.main+394 @0516e9>  : 04 06 00 00                jmp <.main+400 @0516ef>
	<.main+398 @0516ed>  : 10 00                      dup.x1 sp(0)
	<.main+400 @0516ef>  : 13 02                      set.x1 sp(2)
	<.main+402 @0516f1>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@0516f5> - <@05171c>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+406 @0516f5>  : 10 11                      dup.x1 sp(17)
	<.main+408 @0516f7>  : 0c 01 00 00                inc.i32(+1)
	<.main+412 @0516fb>  : 10 11                      dup.x1 sp(17)
	<.main+414 @0516fd>  : 0c 01 00 00                inc.i32(+1)
	<.main+418 @051701>  : 10 01                      dup.x1 sp(1)
	<.main+420 @051703>  : 10 01                      dup.x1 sp(1)
	<.main+422 @051705>  : 58                         clt.i32
	<.main+423 @051706>  : 06 0a 00 00                jz <.main+433 @051710>
	<.main+427 @05170a>  : 10 01                      dup.x1 sp(1)
	<.main+429 @05170c>  : 04 06 00 00                jmp <.main+435 @051712>
	<.main+433 @051710>  : 10 00                      dup.x1 sp(0)
	<.main+435 @051712>  : 13 02                      set.x1 sp(2)
	<.main+437 @051714>  : 09 fc ff ff                inc.sp(-4)
	<.main+441 @051718>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@05171c> - <@05173d>): max2Val: int32 := max(void(3, 6))
	<.main+445 @05171c>  : 1c 03 00 00 00             load.c32 3
	<.main+450 @051721>  : 1c 06 00 00 00             load.c32 6
	<.main+455 @051726>  : 10 01                      dup.x1 sp(1)
	<.main+457 @051728>  : 10 01                      dup.x1 sp(1)
	<.main+459 @05172a>  : 59                         cgt.i32
	<.main+460 @05172b>  : 06 0a 00 00                jz <.main+470 @051735>
	<.main+464 @05172f>  : 10 01                      dup.x1 sp(1)
	<.main+466 @051731>  : 04 06 00 00                jmp <.main+472 @051737>
	<.main+470 @051735>  : 10 00                      dup.x1 sp(0)
	<.main+472 @051737>  : 13 02                      set.x1 sp(2)
	<.main+474 @051739>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@05173d> - <@051758>): max2Var: int32 := max(void(i3, i6))
	<.main+478 @05173d>  : 10 13                      dup.x1 sp(19)
	<.main+480 @05173f>  : 10 13                      dup.x1 sp(19)
	<.main+482 @051741>  : 10 01                      dup.x1 sp(1)
	<.main+484 @051743>  : 10 01                      dup.x1 sp(1)
	<.main+486 @051745>  : 59                         cgt.i32
	<.main+487 @051746>  : 06 0a 00 00                jz <.main+497 @051750>
	<.main+491 @05174a>  : 10 01                      dup.x1 sp(1)
	<.main+493 @05174c>  : 04 06 00 00                jmp <.main+499 @051752>
	<.main+497 @051750>  : 10 00                      dup.x1 sp(0)
	<.main+499 @051752>  : 13 02                      set.x1 sp(2)
	<.main+501 @051754>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@051758> - <@05177f>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+505 @051758>  : 10 14                      dup.x1 sp(20)
	<.main+507 @05175a>  : 0c 01 00 00                inc.i32(+1)
	<.main+511 @05175e>  : 10 14                      dup.x1 sp(20)
	<.main+513 @051760>  : 0c 01 00 00                inc.i32(+1)
	<.main+517 @051764>  : 10 01                      dup.x1 sp(1)
	<.main+519 @051766>  : 10 01                      dup.x1 sp(1)
	<.main+521 @051768>  : 59                         cgt.i32
	<.main+522 @051769>  : 06 0a 00 00                jz <.main+532 @051773>
	<.main+526 @05176d>  : 10 01                      dup.x1 sp(1)
	<.main+528 @05176f>  : 04 06 00 00                jmp <.main+534 @051775>
	<.main+532 @051773>  : 10 00                      dup.x1 sp(0)
	<.main+534 @051775>  : 13 02                      set.x1 sp(2)
	<.main+536 @051777>  : 09 fc ff ff                inc.sp(-4)
	<.main+540 @05177b>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@05177f> - <@051794>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+544 @05177f>  : 1c 03 00 00 00             load.c32 3
	<.main+549 @051784>  : 1c 06 00 00 00             load.c32 6
	<.main+554 @051789>  : 1c 02 00 00 00             load.c32 2
	<.main+559 @05178e>  : 0c 08 00 00                inc.i32(+8)
	<.main+563 @051792>  : 51                         add.i32
	<.main+564 @051793>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@051794> - <@0517a5>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+565 @051794>  : 1c 03 00 00 00             load.c32 3
	<.main+570 @051799>  : 0c 06 00 00                inc.i32(+6)
	<.main+574 @05179d>  : 0c 02 00 00                inc.i32(+2)
	<.main+578 @0517a1>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@0517a5> - <@0517b0>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+582 @0517a5>  : 10 17                      dup.x1 sp(23)
	<.main+584 @0517a7>  : 10 17                      dup.x1 sp(23)
	<.main+586 @0517a9>  : 10 17                      dup.x1 sp(23)
	<.main+588 @0517ab>  : 10 17                      dup.x1 sp(23)
	<.main+590 @0517ad>  : 51                         add.i32
	<.main+591 @0517ae>  : 51                         add.i32
	<.main+592 @0517af>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@0517b0> - <@0517bb>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+593 @0517b0>  : 10 18                      dup.x1 sp(24)
	<.main+595 @0517b2>  : 10 18                      dup.x1 sp(24)
	<.main+597 @0517b4>  : 51                         add.i32
	<.main+598 @0517b5>  : 10 17                      dup.x1 sp(23)
	<.main+600 @0517b7>  : 51                         add.i32
	<.main+601 @0517b8>  : 10 16                      dup.x1 sp(22)
	<.main+603 @0517ba>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@0517bb> - <@0517da>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+604 @0517bb>  : 10 19                      dup.x1 sp(25)
	<.main+606 @0517bd>  : 0c 01 00 00                inc.i32(+1)
	<.main+610 @0517c1>  : 10 19                      dup.x1 sp(25)
	<.main+612 @0517c3>  : 0c 01 00 00                inc.i32(+1)
	<.main+616 @0517c7>  : 10 19                      dup.x1 sp(25)
	<.main+618 @0517c9>  : 0c 01 00 00                inc.i32(+1)
	<.main+622 @0517cd>  : 10 19                      dup.x1 sp(25)
	<.main+624 @0517cf>  : 0c 01 00 00                inc.i32(+1)
	<.main+628 @0517d3>  : 51                         add.i32
	<.main+629 @0517d4>  : 51                         add.i32
	<.main+630 @0517d5>  : 51                         add.i32
	<.main+631 @0517d6>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@0517da> - <@0517f9>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+635 @0517da>  : 10 1a                      dup.x1 sp(26)
	<.main+637 @0517dc>  : 0c 01 00 00                inc.i32(+1)
	<.main+641 @0517e0>  : 10 1a                      dup.x1 sp(26)
	<.main+643 @0517e2>  : 0c 01 00 00                inc.i32(+1)
	<.main+647 @0517e6>  : 51                         add.i32
	<.main+648 @0517e7>  : 10 19                      dup.x1 sp(25)
	<.main+650 @0517e9>  : 0c 01 00 00                inc.i32(+1)
	<.main+654 @0517ed>  : 51                         add.i32
	<.main+655 @0517ee>  : 10 18                      dup.x1 sp(24)
	<.main+657 @0517f0>  : 0c 01 00 00                inc.i32(+1)
	<.main+661 @0517f4>  : 51                         add.i32
	<.main+662 @0517f5>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@0517f9> - <@051837>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+666 @0517f9>  : 1c 03 00 00 00             load.c32 3
	<.main+671 @0517fe>  : 10 00                      dup.x1 sp(0)
	<.main+673 @051800>  : 06 0a 00 00                jz <.main+683 @05180a>
	<.main+677 @051804>  : 10 00                      dup.x1 sp(0)
	<.main+679 @051806>  : 04 2f 00 00                jmp <.main+726 @051835>
	<.main+683 @05180a>  : 1c 06 00 00 00             load.c32 6
	<.main+688 @05180f>  : 10 00                      dup.x1 sp(0)
	<.main+690 @051811>  : 06 0a 00 00                jz <.main+700 @05181b>
	<.main+694 @051815>  : 10 00                      dup.x1 sp(0)
	<.main+696 @051817>  : 04 1c 00 00                jmp <.main+724 @051833>
	<.main+700 @05181b>  : 1c 02 00 00 00             load.c32 2
	<.main+705 @051820>  : 10 00                      dup.x1 sp(0)
	<.main+707 @051822>  : 06 0a 00 00                jz <.main+717 @05182c>
	<.main+711 @051826>  : 10 00                      dup.x1 sp(0)
	<.main+713 @051828>  : 04 09 00 00                jmp <.main+722 @051831>
	<.main+717 @05182c>  : 1c 08 00 00 00             load.c32 8
	<.main+722 @051831>  : 13 01                      set.x1 sp(1)
	<.main+724 @051833>  : 13 01                      set.x1 sp(1)
	<.main+726 @051835>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@051837> - <@051875>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+728 @051837>  : 1c 03 00 00 00             load.c32 3
	<.main+733 @05183c>  : 10 00                      dup.x1 sp(0)
	<.main+735 @05183e>  : 06 0a 00 00                jz <.main+745 @051848>
	<.main+739 @051842>  : 10 00                      dup.x1 sp(0)
	<.main+741 @051844>  : 04 09 00 00                jmp <.main+750 @05184d>
	<.main+745 @051848>  : 1c 06 00 00 00             load.c32 6
	<.main+750 @05184d>  : 13 01                      set.x1 sp(1)
	<.main+752 @05184f>  : 10 00                      dup.x1 sp(0)
	<.main+754 @051851>  : 06 0a 00 00                jz <.main+764 @05185b>
	<.main+758 @051855>  : 10 00                      dup.x1 sp(0)
	<.main+760 @051857>  : 04 09 00 00                jmp <.main+769 @051860>
	<.main+764 @05185b>  : 1c 02 00 00 00             load.c32 2
	<.main+769 @051860>  : 13 01                      set.x1 sp(1)
	<.main+771 @051862>  : 10 00                      dup.x1 sp(0)
	<.main+773 @051864>  : 06 0a 00 00                jz <.main+783 @05186e>
	<.main+777 @051868>  : 10 00                      dup.x1 sp(0)
	<.main+779 @05186a>  : 04 09 00 00                jmp <.main+788 @051873>
	<.main+783 @05186e>  : 1c 08 00 00 00             load.c32 8
	<.main+788 @051873>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@051875> - <@0518a7>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+790 @051875>  : 10 1d                      dup.x1 sp(29)
	<.main+792 @051877>  : 10 00                      dup.x1 sp(0)
	<.main+794 @051879>  : 06 0a 00 00                jz <.main+804 @051883>
	<.main+798 @05187d>  : 10 00                      dup.x1 sp(0)
	<.main+800 @05187f>  : 04 26 00 00                jmp <.main+838 @0518a5>
	<.main+804 @051883>  : 10 1d                      dup.x1 sp(29)
	<.main+806 @051885>  : 10 00                      dup.x1 sp(0)
	<.main+808 @051887>  : 06 0a 00 00                jz <.main+818 @051891>
	<.main+812 @05188b>  : 10 00                      dup.x1 sp(0)
	<.main+814 @05188d>  : 04 16 00 00                jmp <.main+836 @0518a3>
	<.main+818 @051891>  : 10 1d                      dup.x1 sp(29)
	<.main+820 @051893>  : 10 00                      dup.x1 sp(0)
	<.main+822 @051895>  : 06 0a 00 00                jz <.main+832 @05189f>
	<.main+826 @051899>  : 10 00                      dup.x1 sp(0)
	<.main+828 @05189b>  : 04 06 00 00                jmp <.main+834 @0518a1>
	<.main+832 @05189f>  : 10 1d                      dup.x1 sp(29)
	<.main+834 @0518a1>  : 13 01                      set.x1 sp(1)
	<.main+836 @0518a3>  : 13 01                      set.x1 sp(1)
	<.main+838 @0518a5>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@0518a7> - <@0518d9>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+840 @0518a7>  : 10 1e                      dup.x1 sp(30)
	<.main+842 @0518a9>  : 10 00                      dup.x1 sp(0)
	<.main+844 @0518ab>  : 06 0a 00 00                jz <.main+854 @0518b5>
	<.main+848 @0518af>  : 10 00                      dup.x1 sp(0)
	<.main+850 @0518b1>  : 04 06 00 00                jmp <.main+856 @0518b7>
	<.main+854 @0518b5>  : 10 1e                      dup.x1 sp(30)
	<.main+856 @0518b7>  : 13 01                      set.x1 sp(1)
	<.main+858 @0518b9>  : 10 00                      dup.x1 sp(0)
	<.main+860 @0518bb>  : 06 0a 00 00                jz <.main+870 @0518c5>
	<.main+864 @0518bf>  : 10 00                      dup.x1 sp(0)
	<.main+866 @0518c1>  : 04 06 00 00                jmp <.main+872 @0518c7>
	<.main+870 @0518c5>  : 10 1d                      dup.x1 sp(29)
	<.main+872 @0518c7>  : 13 01                      set.x1 sp(1)
	<.main+874 @0518c9>  : 10 00                      dup.x1 sp(0)
	<.main+876 @0518cb>  : 06 0a 00 00                jz <.main+886 @0518d5>
	<.main+880 @0518cf>  : 10 00                      dup.x1 sp(0)
	<.main+882 @0518d1>  : 04 06 00 00                jmp <.main+888 @0518d7>
	<.main+886 @0518d5>  : 10 1c                      dup.x1 sp(28)
	<.main+888 @0518d7>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@0518d9> - <@05191f>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+890 @0518d9>  : 10 1f                      dup.x1 sp(31)
	<.main+892 @0518db>  : 0c 01 00 00                inc.i32(+1)
	<.main+896 @0518df>  : 10 00                      dup.x1 sp(0)
	<.main+898 @0518e1>  : 06 0a 00 00                jz <.main+908 @0518eb>
	<.main+902 @0518e5>  : 10 00                      dup.x1 sp(0)
	<.main+904 @0518e7>  : 04 32 00 00                jmp <.main+954 @051919>
	<.main+908 @0518eb>  : 10 1f                      dup.x1 sp(31)
	<.main+910 @0518ed>  : 0c 01 00 00                inc.i32(+1)
	<.main+914 @0518f1>  : 10 00                      dup.x1 sp(0)
	<.main+916 @0518f3>  : 06 0a 00 00                jz <.main+926 @0518fd>
	<.main+920 @0518f7>  : 10 00                      dup.x1 sp(0)
	<.main+922 @0518f9>  : 04 1e 00 00                jmp <.main+952 @051917>
	<.main+926 @0518fd>  : 10 1f                      dup.x1 sp(31)
	<.main+928 @0518ff>  : 0c 01 00 00                inc.i32(+1)
	<.main+932 @051903>  : 10 00                      dup.x1 sp(0)
	<.main+934 @051905>  : 06 0a 00 00                jz <.main+944 @05190f>
	<.main+938 @051909>  : 10 00                      dup.x1 sp(0)
	<.main+940 @05190b>  : 04 0a 00 00                jmp <.main+950 @051915>
	<.main+944 @05190f>  : 10 1f                      dup.x1 sp(31)
	<.main+946 @051911>  : 0c 01 00 00                inc.i32(+1)
	<.main+950 @051915>  : 13 01                      set.x1 sp(1)
	<.main+952 @051917>  : 13 01                      set.x1 sp(1)
	<.main+954 @051919>  : 13 01                      set.x1 sp(1)
	<.main+956 @05191b>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@05191f> - <@051965>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+960 @05191f>  : 10 20                      dup.x1 sp(32)
	<.main+962 @051921>  : 0c 01 00 00                inc.i32(+1)
	<.main+966 @051925>  : 10 00                      dup.x1 sp(0)
	<.main+968 @051927>  : 06 0a 00 00                jz <.main+978 @051931>
	<.main+972 @05192b>  : 10 00                      dup.x1 sp(0)
	<.main+974 @05192d>  : 04 0a 00 00                jmp <.main+984 @051937>
	<.main+978 @051931>  : 10 20                      dup.x1 sp(32)
	<.main+980 @051933>  : 0c 01 00 00                inc.i32(+1)
	<.main+984 @051937>  : 13 01                      set.x1 sp(1)
	<.main+986 @051939>  : 10 00                      dup.x1 sp(0)
	<.main+988 @05193b>  : 06 0a 00 00                jz <.main+998 @051945>
	<.main+992 @05193f>  : 10 00                      dup.x1 sp(0)
	<.main+994 @051941>  : 04 0a 00 00                jmp <.main+1004 @05194b>
	<.main+998 @051945>  : 10 1f                      dup.x1 sp(31)
	<.main+1000 @051947> : 0c 01 00 00                inc.i32(+1)
	<.main+1004 @05194b> : 13 01                      set.x1 sp(1)
	<.main+1006 @05194d> : 10 00                      dup.x1 sp(0)
	<.main+1008 @05194f> : 06 0a 00 00                jz <.main+1018 @051959>
	<.main+1012 @051953> : 10 00                      dup.x1 sp(0)
	<.main+1014 @051955> : 04 0a 00 00                jmp <.main+1024 @05195f>
	<.main+1018 @051959> : 10 1e                      dup.x1 sp(30)
	<.main+1020 @05195b> : 0c 01 00 00                inc.i32(+1)
	<.main+1024 @05195f> : 13 01                      set.x1 sp(1)
	<.main+1026 @051961> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@051965> - <@0519be>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1030 @051965> : 1c 03 00 00 00             load.c32 3
	<.main+1035 @05196a> : 1c 06 00 00 00             load.c32 6
	<.main+1040 @05196f> : 1c 02 00 00 00             load.c32 2
	<.main+1045 @051974> : 1c 08 00 00 00             load.c32 8
	<.main+1050 @051979> : 10 01                      dup.x1 sp(1)
	<.main+1052 @05197b> : 10 01                      dup.x1 sp(1)
	<.main+1054 @05197d> : 58                         clt.i32
	<.main+1055 @05197e> : 06 0a 00 00                jz <.main+1065 @051988>
	<.main+1059 @051982> : 10 01                      dup.x1 sp(1)
	<.main+1061 @051984> : 04 06 00 00                jmp <.main+1067 @05198a>
	<.main+1065 @051988> : 10 00                      dup.x1 sp(0)
	<.main+1067 @05198a> : 13 02                      set.x1 sp(2)
	<.main+1069 @05198c> : 09 fc ff ff                inc.sp(-4)
	<.main+1073 @051990> : 10 01                      dup.x1 sp(1)
	<.main+1075 @051992> : 10 01                      dup.x1 sp(1)
	<.main+1077 @051994> : 58                         clt.i32
	<.main+1078 @051995> : 06 0a 00 00                jz <.main+1088 @05199f>
	<.main+1082 @051999> : 10 01                      dup.x1 sp(1)
	<.main+1084 @05199b> : 04 06 00 00                jmp <.main+1090 @0519a1>
	<.main+1088 @05199f> : 10 00                      dup.x1 sp(0)
	<.main+1090 @0519a1> : 13 02                      set.x1 sp(2)
	<.main+1092 @0519a3> : 09 fc ff ff                inc.sp(-4)
	<.main+1096 @0519a7> : 10 01                      dup.x1 sp(1)
	<.main+1098 @0519a9> : 10 01                      dup.x1 sp(1)
	<.main+1100 @0519ab> : 58                         clt.i32
	<.main+1101 @0519ac> : 06 0a 00 00                jz <.main+1111 @0519b6>
	<.main+1105 @0519b0> : 10 01                      dup.x1 sp(1)
	<.main+1107 @0519b2> : 04 06 00 00                jmp <.main+1113 @0519b8>
	<.main+1111 @0519b6> : 10 00                      dup.x1 sp(0)
	<.main+1113 @0519b8> : 13 02                      set.x1 sp(2)
	<.main+1115 @0519ba> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@0519be> - <@051a17>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1119 @0519be> : 1c 03 00 00 00             load.c32 3
	<.main+1124 @0519c3> : 1c 06 00 00 00             load.c32 6
	<.main+1129 @0519c8> : 10 01                      dup.x1 sp(1)
	<.main+1131 @0519ca> : 10 01                      dup.x1 sp(1)
	<.main+1133 @0519cc> : 58                         clt.i32
	<.main+1134 @0519cd> : 06 0a 00 00                jz <.main+1144 @0519d7>
	<.main+1138 @0519d1> : 10 01                      dup.x1 sp(1)
	<.main+1140 @0519d3> : 04 06 00 00                jmp <.main+1146 @0519d9>
	<.main+1144 @0519d7> : 10 00                      dup.x1 sp(0)
	<.main+1146 @0519d9> : 13 02                      set.x1 sp(2)
	<.main+1148 @0519db> : 09 fc ff ff                inc.sp(-4)
	<.main+1152 @0519df> : 1c 02 00 00 00             load.c32 2
	<.main+1157 @0519e4> : 10 01                      dup.x1 sp(1)
	<.main+1159 @0519e6> : 10 01                      dup.x1 sp(1)
	<.main+1161 @0519e8> : 58                         clt.i32
	<.main+1162 @0519e9> : 06 0a 00 00                jz <.main+1172 @0519f3>
	<.main+1166 @0519ed> : 10 01                      dup.x1 sp(1)
	<.main+1168 @0519ef> : 04 06 00 00                jmp <.main+1174 @0519f5>
	<.main+1172 @0519f3> : 10 00                      dup.x1 sp(0)
	<.main+1174 @0519f5> : 13 02                      set.x1 sp(2)
	<.main+1176 @0519f7> : 09 fc ff ff                inc.sp(-4)
	<.main+1180 @0519fb> : 1c 08 00 00 00             load.c32 8
	<.main+1185 @051a00> : 10 01                      dup.x1 sp(1)
	<.main+1187 @051a02> : 10 01                      dup.x1 sp(1)
	<.main+1189 @051a04> : 58                         clt.i32
	<.main+1190 @051a05> : 06 0a 00 00                jz <.main+1200 @051a0f>
	<.main+1194 @051a09> : 10 01                      dup.x1 sp(1)
	<.main+1196 @051a0b> : 04 06 00 00                jmp <.main+1202 @051a11>
	<.main+1200 @051a0f> : 10 00                      dup.x1 sp(0)
	<.main+1202 @051a11> : 13 02                      set.x1 sp(2)
	<.main+1204 @051a13> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@051a17> - <@051a64>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1208 @051a17> : 10 23                      dup.x1 sp(35)
	<.main+1210 @051a19> : 10 23                      dup.x1 sp(35)
	<.main+1212 @051a1b> : 10 23                      dup.x1 sp(35)
	<.main+1214 @051a1d> : 10 23                      dup.x1 sp(35)
	<.main+1216 @051a1f> : 10 01                      dup.x1 sp(1)
	<.main+1218 @051a21> : 10 01                      dup.x1 sp(1)
	<.main+1220 @051a23> : 58                         clt.i32
	<.main+1221 @051a24> : 06 0a 00 00                jz <.main+1231 @051a2e>
	<.main+1225 @051a28> : 10 01                      dup.x1 sp(1)
	<.main+1227 @051a2a> : 04 06 00 00                jmp <.main+1233 @051a30>
	<.main+1231 @051a2e> : 10 00                      dup.x1 sp(0)
	<.main+1233 @051a30> : 13 02                      set.x1 sp(2)
	<.main+1235 @051a32> : 09 fc ff ff                inc.sp(-4)
	<.main+1239 @051a36> : 10 01                      dup.x1 sp(1)
	<.main+1241 @051a38> : 10 01                      dup.x1 sp(1)
	<.main+1243 @051a3a> : 58                         clt.i32
	<.main+1244 @051a3b> : 06 0a 00 00                jz <.main+1254 @051a45>
	<.main+1248 @051a3f> : 10 01                      dup.x1 sp(1)
	<.main+1250 @051a41> : 04 06 00 00                jmp <.main+1256 @051a47>
	<.main+1254 @051a45> : 10 00                      dup.x1 sp(0)
	<.main+1256 @051a47> : 13 02                      set.x1 sp(2)
	<.main+1258 @051a49> : 09 fc ff ff                inc.sp(-4)
	<.main+1262 @051a4d> : 10 01                      dup.x1 sp(1)
	<.main+1264 @051a4f> : 10 01                      dup.x1 sp(1)
	<.main+1266 @051a51> : 58                         clt.i32
	<.main+1267 @051a52> : 06 0a 00 00                jz <.main+1277 @051a5c>
	<.main+1271 @051a56> : 10 01                      dup.x1 sp(1)
	<.main+1273 @051a58> : 04 06 00 00                jmp <.main+1279 @051a5e>
	<.main+1277 @051a5c> : 10 00                      dup.x1 sp(0)
	<.main+1279 @051a5e> : 13 02                      set.x1 sp(2)
	<.main+1281 @051a60> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@051a64> - <@051ab1>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1285 @051a64> : 10 24                      dup.x1 sp(36)
	<.main+1287 @051a66> : 10 24                      dup.x1 sp(36)
	<.main+1289 @051a68> : 10 01                      dup.x1 sp(1)
	<.main+1291 @051a6a> : 10 01                      dup.x1 sp(1)
	<.main+1293 @051a6c> : 58                         clt.i32
	<.main+1294 @051a6d> : 06 0a 00 00                jz <.main+1304 @051a77>
	<.main+1298 @051a71> : 10 01                      dup.x1 sp(1)
	<.main+1300 @051a73> : 04 06 00 00                jmp <.main+1306 @051a79>
	<.main+1304 @051a77> : 10 00                      dup.x1 sp(0)
	<.main+1306 @051a79> : 13 02                      set.x1 sp(2)
	<.main+1308 @051a7b> : 09 fc ff ff                inc.sp(-4)
	<.main+1312 @051a7f> : 10 23                      dup.x1 sp(35)
	<.main+1314 @051a81> : 10 01                      dup.x1 sp(1)
	<.main+1316 @051a83> : 10 01                      dup.x1 sp(1)
	<.main+1318 @051a85> : 58                         clt.i32
	<.main+1319 @051a86> : 06 0a 00 00                jz <.main+1329 @051a90>
	<.main+1323 @051a8a> : 10 01                      dup.x1 sp(1)
	<.main+1325 @051a8c> : 04 06 00 00                jmp <.main+1331 @051a92>
	<.main+1329 @051a90> : 10 00                      dup.x1 sp(0)
	<.main+1331 @051a92> : 13 02                      set.x1 sp(2)
	<.main+1333 @051a94> : 09 fc ff ff                inc.sp(-4)
	<.main+1337 @051a98> : 10 22                      dup.x1 sp(34)
	<.main+1339 @051a9a> : 10 01                      dup.x1 sp(1)
	<.main+1341 @051a9c> : 10 01                      dup.x1 sp(1)
	<.main+1343 @051a9e> : 58                         clt.i32
	<.main+1344 @051a9f> : 06 0a 00 00                jz <.main+1354 @051aa9>
	<.main+1348 @051aa3> : 10 01                      dup.x1 sp(1)
	<.main+1350 @051aa5> : 04 06 00 00                jmp <.main+1356 @051aab>
	<.main+1354 @051aa9> : 10 00                      dup.x1 sp(0)
	<.main+1356 @051aab> : 13 02                      set.x1 sp(2)
	<.main+1358 @051aad> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@051ab1> - <@051b12>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1362 @051ab1> : 10 25                      dup.x1 sp(37)
	<.main+1364 @051ab3> : 0c 01 00 00                inc.i32(+1)
	<.main+1368 @051ab7> : 10 25                      dup.x1 sp(37)
	<.main+1370 @051ab9> : 0c 01 00 00                inc.i32(+1)
	<.main+1374 @051abd> : 10 25                      dup.x1 sp(37)
	<.main+1376 @051abf> : 0c 01 00 00                inc.i32(+1)
	<.main+1380 @051ac3> : 10 25                      dup.x1 sp(37)
	<.main+1382 @051ac5> : 0c 01 00 00                inc.i32(+1)
	<.main+1386 @051ac9> : 10 01                      dup.x1 sp(1)
	<.main+1388 @051acb> : 10 01                      dup.x1 sp(1)
	<.main+1390 @051acd> : 58                         clt.i32
	<.main+1391 @051ace> : 06 0a 00 00                jz <.main+1401 @051ad8>
	<.main+1395 @051ad2> : 10 01                      dup.x1 sp(1)
	<.main+1397 @051ad4> : 04 06 00 00                jmp <.main+1403 @051ada>
	<.main+1401 @051ad8> : 10 00                      dup.x1 sp(0)
	<.main+1403 @051ada> : 13 02                      set.x1 sp(2)
	<.main+1405 @051adc> : 09 fc ff ff                inc.sp(-4)
	<.main+1409 @051ae0> : 10 01                      dup.x1 sp(1)
	<.main+1411 @051ae2> : 10 01                      dup.x1 sp(1)
	<.main+1413 @051ae4> : 58                         clt.i32
	<.main+1414 @051ae5> : 06 0a 00 00                jz <.main+1424 @051aef>
	<.main+1418 @051ae9> : 10 01                      dup.x1 sp(1)
	<.main+1420 @051aeb> : 04 06 00 00                jmp <.main+1426 @051af1>
	<.main+1424 @051aef> : 10 00                      dup.x1 sp(0)
	<.main+1426 @051af1> : 13 02                      set.x1 sp(2)
	<.main+1428 @051af3> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @051af7> : 10 01                      dup.x1 sp(1)
	<.main+1434 @051af9> : 10 01                      dup.x1 sp(1)
	<.main+1436 @051afb> : 58                         clt.i32
	<.main+1437 @051afc> : 06 0a 00 00                jz <.main+1447 @051b06>
	<.main+1441 @051b00> : 10 01                      dup.x1 sp(1)
	<.main+1443 @051b02> : 04 06 00 00                jmp <.main+1449 @051b08>
	<.main+1447 @051b06> : 10 00                      dup.x1 sp(0)
	<.main+1449 @051b08> : 13 02                      set.x1 sp(2)
	<.main+1451 @051b0a> : 09 fc ff ff                inc.sp(-4)
	<.main+1455 @051b0e> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@051b12> - <@051b73>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1459 @051b12> : 10 26                      dup.x1 sp(38)
	<.main+1461 @051b14> : 0c 01 00 00                inc.i32(+1)
	<.main+1465 @051b18> : 10 26                      dup.x1 sp(38)
	<.main+1467 @051b1a> : 0c 01 00 00                inc.i32(+1)
	<.main+1471 @051b1e> : 10 01                      dup.x1 sp(1)
	<.main+1473 @051b20> : 10 01                      dup.x1 sp(1)
	<.main+1475 @051b22> : 58                         clt.i32
	<.main+1476 @051b23> : 06 0a 00 00                jz <.main+1486 @051b2d>
	<.main+1480 @051b27> : 10 01                      dup.x1 sp(1)
	<.main+1482 @051b29> : 04 06 00 00                jmp <.main+1488 @051b2f>
	<.main+1486 @051b2d> : 10 00                      dup.x1 sp(0)
	<.main+1488 @051b2f> : 13 02                      set.x1 sp(2)
	<.main+1490 @051b31> : 09 fc ff ff                inc.sp(-4)
	<.main+1494 @051b35> : 10 25                      dup.x1 sp(37)
	<.main+1496 @051b37> : 0c 01 00 00                inc.i32(+1)
	<.main+1500 @051b3b> : 10 01                      dup.x1 sp(1)
	<.main+1502 @051b3d> : 10 01                      dup.x1 sp(1)
	<.main+1504 @051b3f> : 58                         clt.i32
	<.main+1505 @051b40> : 06 0a 00 00                jz <.main+1515 @051b4a>
	<.main+1509 @051b44> : 10 01                      dup.x1 sp(1)
	<.main+1511 @051b46> : 04 06 00 00                jmp <.main+1517 @051b4c>
	<.main+1515 @051b4a> : 10 00                      dup.x1 sp(0)
	<.main+1517 @051b4c> : 13 02                      set.x1 sp(2)
	<.main+1519 @051b4e> : 09 fc ff ff                inc.sp(-4)
	<.main+1523 @051b52> : 10 24                      dup.x1 sp(36)
	<.main+1525 @051b54> : 0c 01 00 00                inc.i32(+1)
	<.main+1529 @051b58> : 10 01                      dup.x1 sp(1)
	<.main+1531 @051b5a> : 10 01                      dup.x1 sp(1)
	<.main+1533 @051b5c> : 58                         clt.i32
	<.main+1534 @051b5d> : 06 0a 00 00                jz <.main+1544 @051b67>
	<.main+1538 @051b61> : 10 01                      dup.x1 sp(1)
	<.main+1540 @051b63> : 04 06 00 00                jmp <.main+1546 @051b69>
	<.main+1544 @051b67> : 10 00                      dup.x1 sp(0)
	<.main+1546 @051b69> : 13 02                      set.x1 sp(2)
	<.main+1548 @051b6b> : 09 fc ff ff                inc.sp(-4)
	<.main+1552 @051b6f> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@051b73> - <@051bcc>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1556 @051b73> : 1c 03 00 00 00             load.c32 3
	<.main+1561 @051b78> : 1c 06 00 00 00             load.c32 6
	<.main+1566 @051b7d> : 1c 02 00 00 00             load.c32 2
	<.main+1571 @051b82> : 1c 08 00 00 00             load.c32 8
	<.main+1576 @051b87> : 10 01                      dup.x1 sp(1)
	<.main+1578 @051b89> : 10 01                      dup.x1 sp(1)
	<.main+1580 @051b8b> : 59                         cgt.i32
	<.main+1581 @051b8c> : 06 0a 00 00                jz <.main+1591 @051b96>
	<.main+1585 @051b90> : 10 01                      dup.x1 sp(1)
	<.main+1587 @051b92> : 04 06 00 00                jmp <.main+1593 @051b98>
	<.main+1591 @051b96> : 10 00                      dup.x1 sp(0)
	<.main+1593 @051b98> : 13 02                      set.x1 sp(2)
	<.main+1595 @051b9a> : 09 fc ff ff                inc.sp(-4)
	<.main+1599 @051b9e> : 10 01                      dup.x1 sp(1)
	<.main+1601 @051ba0> : 10 01                      dup.x1 sp(1)
	<.main+1603 @051ba2> : 59                         cgt.i32
	<.main+1604 @051ba3> : 06 0a 00 00                jz <.main+1614 @051bad>
	<.main+1608 @051ba7> : 10 01                      dup.x1 sp(1)
	<.main+1610 @051ba9> : 04 06 00 00                jmp <.main+1616 @051baf>
	<.main+1614 @051bad> : 10 00                      dup.x1 sp(0)
	<.main+1616 @051baf> : 13 02                      set.x1 sp(2)
	<.main+1618 @051bb1> : 09 fc ff ff                inc.sp(-4)
	<.main+1622 @051bb5> : 10 01                      dup.x1 sp(1)
	<.main+1624 @051bb7> : 10 01                      dup.x1 sp(1)
	<.main+1626 @051bb9> : 59                         cgt.i32
	<.main+1627 @051bba> : 06 0a 00 00                jz <.main+1637 @051bc4>
	<.main+1631 @051bbe> : 10 01                      dup.x1 sp(1)
	<.main+1633 @051bc0> : 04 06 00 00                jmp <.main+1639 @051bc6>
	<.main+1637 @051bc4> : 10 00                      dup.x1 sp(0)
	<.main+1639 @051bc6> : 13 02                      set.x1 sp(2)
	<.main+1641 @051bc8> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@051bcc> - <@051c25>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1645 @051bcc> : 1c 03 00 00 00             load.c32 3
	<.main+1650 @051bd1> : 1c 06 00 00 00             load.c32 6
	<.main+1655 @051bd6> : 10 01                      dup.x1 sp(1)
	<.main+1657 @051bd8> : 10 01                      dup.x1 sp(1)
	<.main+1659 @051bda> : 59                         cgt.i32
	<.main+1660 @051bdb> : 06 0a 00 00                jz <.main+1670 @051be5>
	<.main+1664 @051bdf> : 10 01                      dup.x1 sp(1)
	<.main+1666 @051be1> : 04 06 00 00                jmp <.main+1672 @051be7>
	<.main+1670 @051be5> : 10 00                      dup.x1 sp(0)
	<.main+1672 @051be7> : 13 02                      set.x1 sp(2)
	<.main+1674 @051be9> : 09 fc ff ff                inc.sp(-4)
	<.main+1678 @051bed> : 1c 02 00 00 00             load.c32 2
	<.main+1683 @051bf2> : 10 01                      dup.x1 sp(1)
	<.main+1685 @051bf4> : 10 01                      dup.x1 sp(1)
	<.main+1687 @051bf6> : 59                         cgt.i32
	<.main+1688 @051bf7> : 06 0a 00 00                jz <.main+1698 @051c01>
	<.main+1692 @051bfb> : 10 01                      dup.x1 sp(1)
	<.main+1694 @051bfd> : 04 06 00 00                jmp <.main+1700 @051c03>
	<.main+1698 @051c01> : 10 00                      dup.x1 sp(0)
	<.main+1700 @051c03> : 13 02                      set.x1 sp(2)
	<.main+1702 @051c05> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @051c09> : 1c 08 00 00 00             load.c32 8
	<.main+1711 @051c0e> : 10 01                      dup.x1 sp(1)
	<.main+1713 @051c10> : 10 01                      dup.x1 sp(1)
	<.main+1715 @051c12> : 59                         cgt.i32
	<.main+1716 @051c13> : 06 0a 00 00                jz <.main+1726 @051c1d>
	<.main+1720 @051c17> : 10 01                      dup.x1 sp(1)
	<.main+1722 @051c19> : 04 06 00 00                jmp <.main+1728 @051c1f>
	<.main+1726 @051c1d> : 10 00                      dup.x1 sp(0)
	<.main+1728 @051c1f> : 13 02                      set.x1 sp(2)
	<.main+1730 @051c21> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@051c25> - <@051c72>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1734 @051c25> : 10 29                      dup.x1 sp(41)
	<.main+1736 @051c27> : 10 29                      dup.x1 sp(41)
	<.main+1738 @051c29> : 10 29                      dup.x1 sp(41)
	<.main+1740 @051c2b> : 10 29                      dup.x1 sp(41)
	<.main+1742 @051c2d> : 10 01                      dup.x1 sp(1)
	<.main+1744 @051c2f> : 10 01                      dup.x1 sp(1)
	<.main+1746 @051c31> : 59                         cgt.i32
	<.main+1747 @051c32> : 06 0a 00 00                jz <.main+1757 @051c3c>
	<.main+1751 @051c36> : 10 01                      dup.x1 sp(1)
	<.main+1753 @051c38> : 04 06 00 00                jmp <.main+1759 @051c3e>
	<.main+1757 @051c3c> : 10 00                      dup.x1 sp(0)
	<.main+1759 @051c3e> : 13 02                      set.x1 sp(2)
	<.main+1761 @051c40> : 09 fc ff ff                inc.sp(-4)
	<.main+1765 @051c44> : 10 01                      dup.x1 sp(1)
	<.main+1767 @051c46> : 10 01                      dup.x1 sp(1)
	<.main+1769 @051c48> : 59                         cgt.i32
	<.main+1770 @051c49> : 06 0a 00 00                jz <.main+1780 @051c53>
	<.main+1774 @051c4d> : 10 01                      dup.x1 sp(1)
	<.main+1776 @051c4f> : 04 06 00 00                jmp <.main+1782 @051c55>
	<.main+1780 @051c53> : 10 00                      dup.x1 sp(0)
	<.main+1782 @051c55> : 13 02                      set.x1 sp(2)
	<.main+1784 @051c57> : 09 fc ff ff                inc.sp(-4)
	<.main+1788 @051c5b> : 10 01                      dup.x1 sp(1)
	<.main+1790 @051c5d> : 10 01                      dup.x1 sp(1)
	<.main+1792 @051c5f> : 59                         cgt.i32
	<.main+1793 @051c60> : 06 0a 00 00                jz <.main+1803 @051c6a>
	<.main+1797 @051c64> : 10 01                      dup.x1 sp(1)
	<.main+1799 @051c66> : 04 06 00 00                jmp <.main+1805 @051c6c>
	<.main+1803 @051c6a> : 10 00                      dup.x1 sp(0)
	<.main+1805 @051c6c> : 13 02                      set.x1 sp(2)
	<.main+1807 @051c6e> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@051c72> - <@051cbf>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1811 @051c72> : 10 2a                      dup.x1 sp(42)
	<.main+1813 @051c74> : 10 2a                      dup.x1 sp(42)
	<.main+1815 @051c76> : 10 01                      dup.x1 sp(1)
	<.main+1817 @051c78> : 10 01                      dup.x1 sp(1)
	<.main+1819 @051c7a> : 59                         cgt.i32
	<.main+1820 @051c7b> : 06 0a 00 00                jz <.main+1830 @051c85>
	<.main+1824 @051c7f> : 10 01                      dup.x1 sp(1)
	<.main+1826 @051c81> : 04 06 00 00                jmp <.main+1832 @051c87>
	<.main+1830 @051c85> : 10 00                      dup.x1 sp(0)
	<.main+1832 @051c87> : 13 02                      set.x1 sp(2)
	<.main+1834 @051c89> : 09 fc ff ff                inc.sp(-4)
	<.main+1838 @051c8d> : 10 29                      dup.x1 sp(41)
	<.main+1840 @051c8f> : 10 01                      dup.x1 sp(1)
	<.main+1842 @051c91> : 10 01                      dup.x1 sp(1)
	<.main+1844 @051c93> : 59                         cgt.i32
	<.main+1845 @051c94> : 06 0a 00 00                jz <.main+1855 @051c9e>
	<.main+1849 @051c98> : 10 01                      dup.x1 sp(1)
	<.main+1851 @051c9a> : 04 06 00 00                jmp <.main+1857 @051ca0>
	<.main+1855 @051c9e> : 10 00                      dup.x1 sp(0)
	<.main+1857 @051ca0> : 13 02                      set.x1 sp(2)
	<.main+1859 @051ca2> : 09 fc ff ff                inc.sp(-4)
	<.main+1863 @051ca6> : 10 28                      dup.x1 sp(40)
	<.main+1865 @051ca8> : 10 01                      dup.x1 sp(1)
	<.main+1867 @051caa> : 10 01                      dup.x1 sp(1)
	<.main+1869 @051cac> : 59                         cgt.i32
	<.main+1870 @051cad> : 06 0a 00 00                jz <.main+1880 @051cb7>
	<.main+1874 @051cb1> : 10 01                      dup.x1 sp(1)
	<.main+1876 @051cb3> : 04 06 00 00                jmp <.main+1882 @051cb9>
	<.main+1880 @051cb7> : 10 00                      dup.x1 sp(0)
	<.main+1882 @051cb9> : 13 02                      set.x1 sp(2)
	<.main+1884 @051cbb> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@051cbf> - <@051d20>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1888 @051cbf> : 10 2b                      dup.x1 sp(43)
	<.main+1890 @051cc1> : 0c 01 00 00                inc.i32(+1)
	<.main+1894 @051cc5> : 10 2b                      dup.x1 sp(43)
	<.main+1896 @051cc7> : 0c 01 00 00                inc.i32(+1)
	<.main+1900 @051ccb> : 10 2b                      dup.x1 sp(43)
	<.main+1902 @051ccd> : 0c 01 00 00                inc.i32(+1)
	<.main+1906 @051cd1> : 10 2b                      dup.x1 sp(43)
	<.main+1908 @051cd3> : 0c 01 00 00                inc.i32(+1)
	<.main+1912 @051cd7> : 10 01                      dup.x1 sp(1)
	<.main+1914 @051cd9> : 10 01                      dup.x1 sp(1)
	<.main+1916 @051cdb> : 59                         cgt.i32
	<.main+1917 @051cdc> : 06 0a 00 00                jz <.main+1927 @051ce6>
	<.main+1921 @051ce0> : 10 01                      dup.x1 sp(1)
	<.main+1923 @051ce2> : 04 06 00 00                jmp <.main+1929 @051ce8>
	<.main+1927 @051ce6> : 10 00                      dup.x1 sp(0)
	<.main+1929 @051ce8> : 13 02                      set.x1 sp(2)
	<.main+1931 @051cea> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @051cee> : 10 01                      dup.x1 sp(1)
	<.main+1937 @051cf0> : 10 01                      dup.x1 sp(1)
	<.main+1939 @051cf2> : 59                         cgt.i32
	<.main+1940 @051cf3> : 06 0a 00 00                jz <.main+1950 @051cfd>
	<.main+1944 @051cf7> : 10 01                      dup.x1 sp(1)
	<.main+1946 @051cf9> : 04 06 00 00                jmp <.main+1952 @051cff>
	<.main+1950 @051cfd> : 10 00                      dup.x1 sp(0)
	<.main+1952 @051cff> : 13 02                      set.x1 sp(2)
	<.main+1954 @051d01> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @051d05> : 10 01                      dup.x1 sp(1)
	<.main+1960 @051d07> : 10 01                      dup.x1 sp(1)
	<.main+1962 @051d09> : 59                         cgt.i32
	<.main+1963 @051d0a> : 06 0a 00 00                jz <.main+1973 @051d14>
	<.main+1967 @051d0e> : 10 01                      dup.x1 sp(1)
	<.main+1969 @051d10> : 04 06 00 00                jmp <.main+1975 @051d16>
	<.main+1973 @051d14> : 10 00                      dup.x1 sp(0)
	<.main+1975 @051d16> : 13 02                      set.x1 sp(2)
	<.main+1977 @051d18> : 09 fc ff ff                inc.sp(-4)
	<.main+1981 @051d1c> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@051d20> - <@051d81>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1985 @051d20> : 10 2c                      dup.x1 sp(44)
	<.main+1987 @051d22> : 0c 01 00 00                inc.i32(+1)
	<.main+1991 @051d26> : 10 2c                      dup.x1 sp(44)
	<.main+1993 @051d28> : 0c 01 00 00                inc.i32(+1)
	<.main+1997 @051d2c> : 10 01                      dup.x1 sp(1)
	<.main+1999 @051d2e> : 10 01                      dup.x1 sp(1)
	<.main+2001 @051d30> : 59                         cgt.i32
	<.main+2002 @051d31> : 06 0a 00 00                jz <.main+2012 @051d3b>
	<.main+2006 @051d35> : 10 01                      dup.x1 sp(1)
	<.main+2008 @051d37> : 04 06 00 00                jmp <.main+2014 @051d3d>
	<.main+2012 @051d3b> : 10 00                      dup.x1 sp(0)
	<.main+2014 @051d3d> : 13 02                      set.x1 sp(2)
	<.main+2016 @051d3f> : 09 fc ff ff                inc.sp(-4)
	<.main+2020 @051d43> : 10 2b                      dup.x1 sp(43)
	<.main+2022 @051d45> : 0c 01 00 00                inc.i32(+1)
	<.main+2026 @051d49> : 10 01                      dup.x1 sp(1)
	<.main+2028 @051d4b> : 10 01                      dup.x1 sp(1)
	<.main+2030 @051d4d> : 59                         cgt.i32
	<.main+2031 @051d4e> : 06 0a 00 00                jz <.main+2041 @051d58>
	<.main+2035 @051d52> : 10 01                      dup.x1 sp(1)
	<.main+2037 @051d54> : 04 06 00 00                jmp <.main+2043 @051d5a>
	<.main+2041 @051d58> : 10 00                      dup.x1 sp(0)
	<.main+2043 @051d5a> : 13 02                      set.x1 sp(2)
	<.main+2045 @051d5c> : 09 fc ff ff                inc.sp(-4)
	<.main+2049 @051d60> : 10 2a                      dup.x1 sp(42)
	<.main+2051 @051d62> : 0c 01 00 00                inc.i32(+1)
	<.main+2055 @051d66> : 10 01                      dup.x1 sp(1)
	<.main+2057 @051d68> : 10 01                      dup.x1 sp(1)
	<.main+2059 @051d6a> : 59                         cgt.i32
	<.main+2060 @051d6b> : 06 0a 00 00                jz <.main+2070 @051d75>
	<.main+2064 @051d6f> : 10 01                      dup.x1 sp(1)
	<.main+2066 @051d71> : 04 06 00 00                jmp <.main+2072 @051d77>
	<.main+2070 @051d75> : 10 00                      dup.x1 sp(0)
	<.main+2072 @051d77> : 13 02                      set.x1 sp(2)
	<.main+2074 @051d79> : 09 fc ff ff                inc.sp(-4)
	<.main+2078 @051d7d> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@051d81> - <@051d86>): overload1: float32 := overload
	<.main+2082 @051d81> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@051d86> - <@051d8b>): overload2: float32 := overload()
	<.main+2087 @051d86> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@051d8b> - <@051d90>): overload3: float32 := overload(0)
	<.main+2092 @051d8b> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@051d90> - <@051d95>): overload4: float32 := overload(0.000000)
	<.main+2097 @051d90> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@051d95> - <@051d9a>): overload5: float32 := overload(void(0, 0))
	<.main+2102 @051d95> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@051d9a> - <@051da3>): boilC: Celsius := Celsius(100.000000)
	<.main+2107 @051d9a> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@051da3> - <@051db9>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2116 @051da3> : 11 00                      dup.x2 sp(0)
	<.main+2118 @051da5> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2127 @051dae> : 83                         mul.f64
	<.main+2128 @051daf> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2137 @051db8> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@051db9> - <@051dbe>): valueRef: int64 := value
	<.main+2138 @051db9> : 1f e0 12 05 00             load.ref <@0512e0> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@051dbe> - <@051dc3>): valuePtr: pointer := value
	<.main+2143 @051dbe> : 1f e0 12 05 00             load.ref <@0512e0> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@051dc3> - <@051dcd>): valueVar: variant := value
	<.main+2148 @051dc3> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2153 @051dc8> : 1f e0 12 05 00             load.ref <@0512e0> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@051dcd> - <@051dd0>): fromRef: int64 := valueRef
	<.main+2158 @051dcd> : 10 03                      dup.x1 sp(3)
	<.main+2160 @051dcf> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@051dd0> - <@051dd2>): fromPtr: int64 := valuePtr
	<.main+2161 @051dd0> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@051dd2> - <@051dd4>): fromVar: int64 := valueVar
	<.main+2163 @051dd2> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@051dd4> - <@051dd9>): nullRef: int64 := null
	<.main+2165 @051dd4> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@051dd9> - <@051dde>): nullPtr: pointer := null
	<.main+2170 @051dd9> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@051dde> - <@051de8>): nullVar: variant := null
	<.main+2175 @051dde> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2180 @051de3> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@051de8> - <@051ded>): nullTyp: typename := null
	<.main+2185 @051de8> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@051ded> - <@051df2>): nullFun: function := null
	<.main+2190 @051ded> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@051df2> - <@051df7>): nullObj: object := null
	<.main+2195 @051df2> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@051df7> - <@051dfc>): typePtr: pointer := int64
	<.main+2200 @051df7> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@051dfc> - <@051e06>): typeVar: variant := int64
	<.main+2205 @051dfc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2210 @051e01> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@051e06> - <@051e0b>): typeTyp: typename := int64
	<.main+2215 @051e06> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@051e0b> - <@051e0f>): local: int64 := value
	<.main+2220 @051e0b> : 2b e0 12 05                load.m64 <@0512e0> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@051e0f> - <@051e11>): copyVal: int64 := local
	<.main+2224 @051e0f> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@051e11> - <@051e13>): copyRef: int64 := valueRef
	<.main+2226 @051e11> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@051e13> - <@051e15>): copyPtr: pointer := valuePtr
	<.main+2228 @051e13> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@051e15> - <@051e17>): copyVar: variant := valueVar
	<.main+2230 @051e15> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@051e17> - <@051e19>): copyTyp: typename := typeTyp
	<.main+2232 @051e17> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@051e19> - <@051e1e>): ptrVoid: pointer := void
	<.main+2234 @051e19> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@051e1e> - <@051e23>): ptrBool: pointer := bool
	<.main+2239 @051e1e> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@051e23> - <@051e28>): ptrChar: pointer := char
	<.main+2244 @051e23> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@051e28> - <@051e2d>): ptrInt8: pointer := int8
	<.main+2249 @051e28> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@051e2d> - <@051e32>): ptrInt16: pointer := int16
	<.main+2254 @051e2d> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@051e32> - <@051e37>): ptrInt32: pointer := int32
	<.main+2259 @051e32> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@051e37> - <@051e3c>): ptrInt64: pointer := int64
	<.main+2264 @051e37> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@051e3c> - <@051e41>): ptrUint8: pointer := uint8
	<.main+2269 @051e3c> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@051e41> - <@051e46>): ptrUint16: pointer := uint16
	<.main+2274 @051e41> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@051e46> - <@051e4b>): ptrUint32: pointer := uint32
	<.main+2279 @051e46> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@051e4b> - <@051e50>): ptrUint64: pointer := uint64
	<.main+2284 @051e4b> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@051e50> - <@051e55>): ptrFloat32: pointer := float32
	<.main+2289 @051e50> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@051e55> - <@051e5a>): ptrFloat64: pointer := float64
	<.main+2294 @051e55> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@051e5a> - <@051e5f>): ptrTypename: pointer := typename
	<.main+2299 @051e5a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@051e5f> - <@051e64>): ptrFunction: pointer := function
	<.main+2304 @051e5f> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@051e64> - <@051e69>): ptrPointer: pointer := pointer
	<.main+2309 @051e64> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@051e69> - <@051e6e>): ptrVariant: pointer := variant
	<.main+2314 @051e69> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@051e6e> - <@051e73>): ptrObject: pointer := object
	<.main+2319 @051e6e> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@051e73> - <@051e7d>): varVoid: variant := void
	<.main+2324 @051e73> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2329 @051e78> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@051e7d> - <@051e87>): varBool: variant := bool
	<.main+2334 @051e7d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2339 @051e82> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@051e87> - <@051e91>): varChar: variant := char
	<.main+2344 @051e87> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2349 @051e8c> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@051e91> - <@051e9b>): varInt8: variant := int8
	<.main+2354 @051e91> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2359 @051e96> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@051e9b> - <@051ea5>): varInt16: variant := int16
	<.main+2364 @051e9b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2369 @051ea0> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@051ea5> - <@051eaf>): varInt32: variant := int32
	<.main+2374 @051ea5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2379 @051eaa> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@051eaf> - <@051eb9>): varInt64: variant := int64
	<.main+2384 @051eaf> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2389 @051eb4> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@051eb9> - <@051ec3>): varUint8: variant := uint8
	<.main+2394 @051eb9> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2399 @051ebe> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@051ec3> - <@051ecd>): varUint16: variant := uint16
	<.main+2404 @051ec3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2409 @051ec8> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@051ecd> - <@051ed7>): varUint32: variant := uint32
	<.main+2414 @051ecd> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2419 @051ed2> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@051ed7> - <@051ee1>): varUint64: variant := uint64
	<.main+2424 @051ed7> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2429 @051edc> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@051ee1> - <@051eeb>): varFloat32: variant := float32
	<.main+2434 @051ee1> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2439 @051ee6> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@051eeb> - <@051ef5>): varFloat64: variant := float64
	<.main+2444 @051eeb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2449 @051ef0> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@051ef5> - <@051eff>): varTypename: variant := typename
	<.main+2454 @051ef5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2459 @051efa> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@051eff> - <@051f09>): varFunction: variant := function
	<.main+2464 @051eff> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2469 @051f04> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@051f09> - <@051f13>): varPointer: variant := pointer
	<.main+2474 @051f09> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2479 @051f0e> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@051f13> - <@051f1d>): varVariant: variant := variant
	<.main+2484 @051f13> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2489 @051f18> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@051f1d> - <@051f27>): varObject: variant := object
	<.main+2494 @051f1d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2499 @051f22> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@051f27> - <@051f2c>): typVoid: typename := void
	<.main+2504 @051f27> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@051f2c> - <@051f31>): typBool: typename := bool
	<.main+2509 @051f2c> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@051f31> - <@051f36>): typChar: typename := char
	<.main+2514 @051f31> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@051f36> - <@051f3b>): typInt8: typename := int8
	<.main+2519 @051f36> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@051f3b> - <@051f40>): typInt16: typename := int16
	<.main+2524 @051f3b> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@051f40> - <@051f45>): typInt32: typename := int32
	<.main+2529 @051f40> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@051f45> - <@051f4a>): typInt64: typename := int64
	<.main+2534 @051f45> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@051f4a> - <@051f4f>): typUint8: typename := uint8
	<.main+2539 @051f4a> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@051f4f> - <@051f54>): typUint16: typename := uint16
	<.main+2544 @051f4f> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@051f54> - <@051f59>): typUint32: typename := uint32
	<.main+2549 @051f54> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@051f59> - <@051f5e>): typUint64: typename := uint64
	<.main+2554 @051f59> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@051f5e> - <@051f63>): typFloat32: typename := float32
	<.main+2559 @051f5e> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@051f63> - <@051f68>): typFloat64: typename := float64
	<.main+2564 @051f63> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@051f68> - <@051f6d>): typTypename: typename := typename
	<.main+2569 @051f68> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@051f6d> - <@051f72>): typFunction: typename := function
	<.main+2574 @051f6d> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@051f72> - <@051f77>): typPointer: typename := pointer
	<.main+2579 @051f72> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@051f77> - <@051f7c>): typVariant: typename := variant
	<.main+2584 @051f77> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@051f7c> - <@051f81>): typObject: typename := object
	<.main+2589 @051f7c> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@051f81> - <@051f86>): valueOfPtr: pointer := pointer(value)
	<.main+2594 @051f81> : 1f e0 12 05 00             load.ref <@0512e0> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@051f86> - <@051f90>): valueOfVar: variant := variant(value)
	<.main+2599 @051f86> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2604 @051f8b> : 1f e0 12 05 00             load.ref <@0512e0> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@051f90> - <@051f95>): valueOfTyp: typename := typename(value)
	<.main+2609 @051f90> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@051f95> - <@051f9a>): typeOfValue: typename := typename(value)
	<.main+2614 @051f95> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@051f9a> - <@051fa1>): copyPtrFloat64: variant := ptrFloat64
	<.main+2619 @051f9a> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2624 @051f9f> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@051fa1> - <@051fa3>): copyVarFloat64: pointer := varFloat64
	<.main+2626 @051fa1> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:12: (21 bytes: <@051fa3> - <@051fb8>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2628 @051fa3> : 19                         load.z32
	<.main+2629 @051fa4> : 1c 02 00 00 00             load.c32 2
	<.main+2634 @051fa9> : 1c 07 00 00 00             load.c32 7
	<.main+2639 @051fae> : 1f f0 12 05 00             load.ref <@0512f0> ;funAdd(x: int32, y: int32): int32
	<.main+2644 @051fb3> : 02                         call
	<.main+2645 @051fb4> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:15: (5 bytes: <@051fb8> - <@051fbd>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2649 @051fb8> : 1f f0 12 05 00             load.ref <@0512f0> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:18: (18 bytes: <@051fbd> - <@051fcf>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2654 @051fbd> : 19                         load.z32
	<.main+2655 @051fbe> : 1c 02 00 00 00             load.c32 2
	<.main+2660 @051fc3> : 1c 08 00 00 00             load.c32 8
	<.main+2665 @051fc8> : 10 03                      dup.x1 sp(3)
	<.main+2667 @051fca> : 02                         call
	<.main+2668 @051fcb> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:21: (5 bytes: <@051fcf> - <@051fd4>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2672 @051fcf> : 1f f8 12 05 00             load.ref <@0512f8> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (18 bytes: <@051fd4> - <@051fe6>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2677 @051fd4> : 19                         load.z32
	<.main+2678 @051fd5> : 1c 02 00 00 00             load.c32 2
	<.main+2683 @051fda> : 1c 06 00 00 00             load.c32 6
	<.main+2688 @051fdf> : 10 03                      dup.x1 sp(3)
	<.main+2690 @051fe1> : 02                         call
	<.main+2691 @051fe2> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:27: (2 bytes: <@051fe6> - <@051fe8>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2695 @051fe6> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:30: (18 bytes: <@051fe8> - <@051ffa>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2697 @051fe8> : 19                         load.z32
	<.main+2698 @051fe9> : 1c 02 00 00 00             load.c32 2
	<.main+2703 @051fee> : 1c 07 00 00 00             load.c32 7
	<.main+2708 @051ff3> : 10 03                      dup.x1 sp(3)
	<.main+2710 @051ff5> : 02                         call
	<.main+2711 @051ff6> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:46: (16 bytes: <@051ffa> - <@05200a>): fibonacci_13: uint32 := fib(13)
	<.main+2715 @051ffa> : 19                         load.z32
	<.main+2716 @051ffb> : 1c 0d 00 00 00             load.c32 13
	<.main+2721 @052000> : 1f 00 13 05 00             load.ref <@051300> ;fib(n: uint32): uint32
	<.main+2726 @052005> : 02                         call
	<.main+2727 @052006> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@05200a> - <@05200e>): sizeofVoid: int32 := sizeof(void)
	<.main+2731 @05200a> : 2a d0 00 00                load.m32 <@0000d0>
	test/lang/reflect.ci:4: (4 bytes: <@05200e> - <@052012>): sizeofBool: int32 := sizeof(bool)
	<.main+2735 @05200e> : 2a 70 01 00                load.m32 <@000170>
	test/lang/reflect.ci:5: (4 bytes: <@052012> - <@052016>): sizeofChar: int32 := sizeof(char)
	<.main+2739 @052012> : 2a 10 02 00                load.m32 <@000210>
	test/lang/reflect.ci:6: (4 bytes: <@052016> - <@05201a>): sizeofInt8: int32 := sizeof(int8)
	<.main+2743 @052016> : 2a b0 02 00                load.m32 <@0002b0>
	test/lang/reflect.ci:7: (4 bytes: <@05201a> - <@05201e>): sizeofInt16: int32 := sizeof(int16)
	<.main+2747 @05201a> : 2a 50 03 00                load.m32 <@000350>
	test/lang/reflect.ci:8: (4 bytes: <@05201e> - <@052022>): sizeofInt32: int32 := sizeof(int32)
	<.main+2751 @05201e> : 2a f0 03 00                load.m32 <@0003f0>
	test/lang/reflect.ci:9: (4 bytes: <@052022> - <@052026>): sizeofInt64: int32 := sizeof(int64)
	<.main+2755 @052022> : 2a 90 04 00                load.m32 <@000490>
	test/lang/reflect.ci:10: (4 bytes: <@052026> - <@05202a>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2759 @052026> : 2a 30 05 00                load.m32 <@000530>
	test/lang/reflect.ci:11: (4 bytes: <@05202a> - <@05202e>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2763 @05202a> : 2a d0 05 00                load.m32 <@0005d0>
	test/lang/reflect.ci:12: (4 bytes: <@05202e> - <@052032>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2767 @05202e> : 2a 70 06 00                load.m32 <@000670>
	test/lang/reflect.ci:13: (4 bytes: <@052032> - <@052036>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2771 @052032> : 2a 10 07 00                load.m32 <@000710>
	test/lang/reflect.ci:14: (4 bytes: <@052036> - <@05203a>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2775 @052036> : 2a b0 07 00                load.m32 <@0007b0>
	test/lang/reflect.ci:15: (4 bytes: <@05203a> - <@05203e>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2779 @05203a> : 2a 50 08 00                load.m32 <@000850>
	test/lang/reflect.ci:16: (4 bytes: <@05203e> - <@052042>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2783 @05203e> : 2a f0 08 00                load.m32 <@0008f0>
	test/lang/reflect.ci:17: (4 bytes: <@052042> - <@052046>): sizeofVariant: int32 := sizeof(variant)
	<.main+2787 @052042> : 2a 90 09 00                load.m32 <@000990>
	test/lang/reflect.ci:18: (4 bytes: <@052046> - <@05204a>): sizeofTypename: int32 := sizeof(typename)
	<.main+2791 @052046> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	test/lang/reflect.ci:19: (4 bytes: <@05204a> - <@05204e>): sizeofFunction: int32 := sizeof(function)
	<.main+2795 @05204a> : 2a 30 0a 00                load.m32 <@000a30>
	test/lang/reflect.ci:20: (4 bytes: <@05204e> - <@052052>): sizeofObject: int32 := sizeof(object)
	<.main+2799 @05204e> : 2a d8 0a 00                load.m32 <@000ad8>
	test/lang/reflect.ci:30: (5 bytes: <@052052> - <@052057>): typeofRecord: typename := RecordSizeofExt
	<.main+2803 @052052> : 1f b8 70 03 00             load.ref <@0370b8> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@052057> - <@05205d>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2808 @052057> : 10 00                      dup.x1 sp(0)
	<.main+2810 @052059> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@05205d> - <@052064>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2814 @05205d> : 10 01                      dup.x1 sp(1)
	<.main+2816 @05205f> : 0c 28 00 00                inc.i32(+40)
	<.main+2820 @052063> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@052064> - <@05206b>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2821 @052064> : 10 02                      dup.x1 sp(2)
	<.main+2823 @052066> : 0c 20 00 00                inc.i32(+32)
	<.main+2827 @05206a> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@05206b> - <@052071>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2828 @05206b> : 10 03                      dup.x1 sp(3)
	<.main+2830 @05206d> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@052071> - <@052077>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2834 @052071> : 10 04                      dup.x1 sp(4)
	<.main+2836 @052073> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@052077> - <@05207d>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2840 @052077> : 10 05                      dup.x1 sp(5)
	<.main+2842 @052079> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@05207d> - <@052083>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2846 @05207d> : 10 00                      dup.x1 sp(0)
	<.main+2848 @05207f> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@052083> - <@05208a>): offsetOfBase: int32 := typeofBase.offset
	<.main+2852 @052083> : 10 01                      dup.x1 sp(1)
	<.main+2854 @052085> : 0c 28 00 00                inc.i32(+40)
	<.main+2858 @052089> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@05208a> - <@052091>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2859 @05208a> : 10 02                      dup.x1 sp(2)
	<.main+2861 @05208c> : 0c 20 00 00                inc.i32(+32)
	<.main+2865 @052090> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@052091> - <@052097>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2866 @052091> : 10 03                      dup.x1 sp(3)
	<.main+2868 @052093> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@052097> - <@05209d>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2872 @052097> : 10 04                      dup.x1 sp(4)
	<.main+2874 @052099> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@05209d> - <@0520a3>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2878 @05209d> : 10 05                      dup.x1 sp(5)
	<.main+2880 @05209f> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@0520a3> - <@0520aa>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2884 @0520a3> : 10 00                      dup.x1 sp(0)
	<.main+2886 @0520a5> : 0c 28 00 00                inc.i32(+40)
	<.main+2890 @0520a9> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@0520aa> - <@0520b1>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2891 @0520aa> : 10 01                      dup.x1 sp(1)
	<.main+2893 @0520ac> : 0c 20 00 00                inc.i32(+32)
	<.main+2897 @0520b0> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@0520b1> - <@0520b7>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2898 @0520b1> : 10 02                      dup.x1 sp(2)
	<.main+2900 @0520b3> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@0520b7> - <@0520be>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2904 @0520b7> : 10 00                      dup.x1 sp(0)
	<.main+2906 @0520b9> : 0c 28 00 00                inc.i32(+40)
	<.main+2910 @0520bd> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@0520be> - <@0520c5>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2911 @0520be> : 10 01                      dup.x1 sp(1)
	<.main+2913 @0520c0> : 0c 20 00 00                inc.i32(+32)
	<.main+2917 @0520c4> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@0520c5> - <@0520ce>): pi64: float64 := 3.141593
	<.main+2918 @0520c5> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@0520ce> - <@0520d7>): e64: float64 := 2.718282
	<.main+2927 @0520ce> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@0520d7> - <@0520da>): pi32: float32 := pi64
	<.main+2936 @0520d7> : 11 02                      dup.x2 sp(2)
	<.main+2938 @0520d9> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@0520da> - <@0520dd>): e32: float32 := e64
	<.main+2939 @0520da> : 11 01                      dup.x2 sp(1)
	<.main+2941 @0520dc> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@0520dd> - <@0520e4>): r_comp: int32 := int32(14 << 3)
	<.main+2942 @0520dd> : 1c 0e 00 00 00             load.c32 14
	<.main+2947 @0520e2> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@0520e4> - <@0520eb>): g_comp: int32 := int32(63 << 2)
	<.main+2949 @0520e4> : 1c 3f 00 00 00             load.c32 63
	<.main+2954 @0520e9> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@0520eb> - <@0520f2>): b_comp: int32 := int32(31 << 3)
	<.main+2956 @0520eb> : 1c 1f 00 00 00             load.c32 31
	<.main+2961 @0520f0> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@0520f2> - <@05210e>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2963 @0520f2> : 10 02                      dup.x1 sp(2)
	<.main+2965 @0520f4> : 3f 48                      b32.shl 0x008
	<.main+2967 @0520f6> : 1c 00 f8 00 00             load.c32 63488
	<.main+2972 @0520fb> : 31                         and.b32
	<.main+2973 @0520fc> : 10 02                      dup.x1 sp(2)
	<.main+2975 @0520fe> : 3f 43                      b32.shl 0x003
	<.main+2977 @052100> : 1c e0 07 00 00             load.c32 2016
	<.main+2982 @052105> : 31                         and.b32
	<.main+2983 @052106> : 32                         or.b32
	<.main+2984 @052107> : 10 01                      dup.x1 sp(1)
	<.main+2986 @052109> : 3f c3                      b32.sar 0x003
	<.main+2988 @05210b> : 3f 05                      b32.and 0x01f
	<.main+2990 @05210d> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@05210e> - <@052128>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+2991 @05210e> : 10 03                      dup.x1 sp(3)
	<.main+2993 @052110> : 3f 50                      b32.shl 0x010
	<.main+2995 @052112> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3000 @052117> : 31                         and.b32
	<.main+3001 @052118> : 10 03                      dup.x1 sp(3)
	<.main+3003 @05211a> : 3f 48                      b32.shl 0x008
	<.main+3005 @05211c> : 1c 00 ff 00 00             load.c32 65280
	<.main+3010 @052121> : 31                         and.b32
	<.main+3011 @052122> : 32                         or.b32
	<.main+3012 @052123> : 10 02                      dup.x1 sp(2)
	<.main+3014 @052125> : 3f 08                      b32.and 0x0ff
	<.main+3016 @052127> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@052128> - <@052138>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3017 @052128> : 10 01                      dup.x1 sp(1)
	<.main+3019 @05212a> : 1c 0b 00 00 00             load.c32 11
	<.main+3024 @05212f> : 1c 05 00 00 00             load.c32 5
	<.main+3029 @052134> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@052138> - <@052148>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3033 @052138> : 10 02                      dup.x1 sp(2)
	<.main+3035 @05213a> : 1c 05 00 00 00             load.c32 5
	<.main+3040 @05213f> : 1c 06 00 00 00             load.c32 6
	<.main+3045 @052144> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@052148> - <@052154>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3049 @052148> : 10 03                      dup.x1 sp(3)
	<.main+3051 @05214a> : 19                         load.z32
	<.main+3052 @05214b> : 1c 05 00 00 00             load.c32 5
	<.main+3057 @052150> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@052154> - <@052164>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3061 @052154> : 10 04                      dup.x1 sp(4)
	<.main+3063 @052156> : 1c 0b 00 00 00             load.c32 11
	<.main+3068 @05215b> : 1c 05 00 00 00             load.c32 5
	<.main+3073 @052160> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@052164> - <@052174>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3077 @052164> : 10 05                      dup.x1 sp(5)
	<.main+3079 @052166> : 1c 05 00 00 00             load.c32 5
	<.main+3084 @05216b> : 1c 06 00 00 00             load.c32 6
	<.main+3089 @052170> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@052174> - <@052180>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3093 @052174> : 10 06                      dup.x1 sp(6)
	<.main+3095 @052176> : 19                         load.z32
	<.main+3096 @052177> : 1c 05 00 00 00             load.c32 5
	<.main+3101 @05217c> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@052180> - <@052190>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3105 @052180> : 10 06                      dup.x1 sp(6)
	<.main+3107 @052182> : 1c 10 00 00 00             load.c32 16
	<.main+3112 @052187> : 1c 08 00 00 00             load.c32 8
	<.main+3117 @05218c> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@052190> - <@0521a0>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3121 @052190> : 10 07                      dup.x1 sp(7)
	<.main+3123 @052192> : 1c 08 00 00 00             load.c32 8
	<.main+3128 @052197> : 1c 08 00 00 00             load.c32 8
	<.main+3133 @05219c> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@0521a0> - <@0521ac>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3137 @0521a0> : 10 08                      dup.x1 sp(8)
	<.main+3139 @0521a2> : 19                         load.z32
	<.main+3140 @0521a3> : 1c 08 00 00 00             load.c32 8
	<.main+3145 @0521a8> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@0521ac> - <@0521bc>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3149 @0521ac> : 10 09                      dup.x1 sp(9)
	<.main+3151 @0521ae> : 1c 10 00 00 00             load.c32 16
	<.main+3156 @0521b3> : 1c 08 00 00 00             load.c32 8
	<.main+3161 @0521b8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@0521bc> - <@0521cc>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3165 @0521bc> : 10 0a                      dup.x1 sp(10)
	<.main+3167 @0521be> : 1c 08 00 00 00             load.c32 8
	<.main+3172 @0521c3> : 1c 08 00 00 00             load.c32 8
	<.main+3177 @0521c8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@0521cc> - <@0521d8>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3181 @0521cc> : 10 0b                      dup.x1 sp(11)
	<.main+3183 @0521ce> : 19                         load.z32
	<.main+3184 @0521cf> : 1c 08 00 00 00             load.c32 8
	<.main+3189 @0521d4> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@0521d8> - <@0521e8>): testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3193 @0521d8> : 11 15                      dup.x2 sp(21)
	<.main+3195 @0521da> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3204 @0521e3> : 84                         div.f64
	<.main+3205 @0521e4> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@0521e8> - <@0521f8>): testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3209 @0521e8> : 11 17                      dup.x2 sp(23)
	<.main+3211 @0521ea> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3220 @0521f3> : 84                         div.f64
	<.main+3221 @0521f4> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@0521f8> - <@052208>): testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3225 @0521f8> : 11 19                      dup.x2 sp(25)
	<.main+3227 @0521fa> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3236 @052203> : 84                         div.f64
	<.main+3237 @052204> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@052208> - <@052214>): testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3241 @052208> : 11 19                      dup.x2 sp(25)
	<.main+3243 @05220a> : 11 1b                      dup.x2 sp(27)
	<.main+3245 @05220c> : 83                         mul.f64
	<.main+3246 @05220d> : 11 1b                      dup.x2 sp(27)
	<.main+3248 @05220f> : 83                         mul.f64
	<.main+3249 @052210> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@052214> - <@052221>): testExp_f64: float64 := float64.exp(1.000000)
	<.main+3253 @052214> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3262 @05221d> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@052221> - <@052233>): testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3266 @052221> : 11 1f                      dup.x2 sp(31)
	<.main+3268 @052223> : 11 21                      dup.x2 sp(33)
	<.main+3270 @052225> : 83                         mul.f64
	<.main+3271 @052226> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3280 @05222f> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@052233> - <@05223c>): testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3284 @052233> : 11 21                      dup.x2 sp(33)
	<.main+3286 @052235> : 11 23                      dup.x2 sp(35)
	<.main+3288 @052237> : 83                         mul.f64
	<.main+3289 @052238> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@05223c> - <@05224b>): testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3293 @05223c> : 11 23                      dup.x2 sp(35)
	<.main+3295 @05223e> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3304 @052247> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@05224b> - <@052257>): testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3308 @05224b> : 10 22                      dup.x1 sp(34)
	<.main+3310 @05224d> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3315 @052252> : 74                         div.f32
	<.main+3316 @052253> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@052257> - <@052263>): testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3320 @052257> : 10 23                      dup.x1 sp(35)
	<.main+3322 @052259> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3327 @05225e> : 74                         div.f32
	<.main+3328 @05225f> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@052263> - <@05226f>): testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3332 @052263> : 10 24                      dup.x1 sp(36)
	<.main+3334 @052265> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3339 @05226a> : 74                         div.f32
	<.main+3340 @05226b> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@05226f> - <@05227b>): testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3344 @05226f> : 10 24                      dup.x1 sp(36)
	<.main+3346 @052271> : 10 25                      dup.x1 sp(37)
	<.main+3348 @052273> : 73                         mul.f32
	<.main+3349 @052274> : 10 25                      dup.x1 sp(37)
	<.main+3351 @052276> : 73                         mul.f32
	<.main+3352 @052277> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@05227b> - <@052284>): testExp_f32: float32 := float32.exp(1.000000)
	<.main+3356 @05227b> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3361 @052280> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@052284> - <@052292>): testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3365 @052284> : 10 27                      dup.x1 sp(39)
	<.main+3367 @052286> : 10 28                      dup.x1 sp(40)
	<.main+3369 @052288> : 73                         mul.f32
	<.main+3370 @052289> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3375 @05228e> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@052292> - <@05229b>): testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3379 @052292> : 10 28                      dup.x1 sp(40)
	<.main+3381 @052294> : 10 29                      dup.x1 sp(41)
	<.main+3383 @052296> : 73                         mul.f32
	<.main+3384 @052297> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@05229b> - <@0522a6>): testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3388 @05229b> : 10 29                      dup.x1 sp(41)
	<.main+3390 @05229d> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3395 @0522a2> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/number.ci:55: (6 bytes: <@0522a6> - <@0522ac>): testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3399 @0522a6> : 10 25                      dup.x1 sp(37)
	<.main+3401 @0522a8> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	test/stdc/number.ci:56: (6 bytes: <@0522ac> - <@0522b2>): testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3405 @0522ac> : 10 26                      dup.x1 sp(38)
	<.main+3407 @0522ae> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	test/stdc/number.ci:57: (6 bytes: <@0522b2> - <@0522b8>): testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3411 @0522b2> : 10 27                      dup.x1 sp(39)
	<.main+3413 @0522b4> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	test/stdc/number.ci:58: (6 bytes: <@0522b8> - <@0522be>): testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3417 @0522b8> : 10 28                      dup.x1 sp(40)
	<.main+3419 @0522ba> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	test/stdc/number.ci:59: (6 bytes: <@0522be> - <@0522c4>): testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3423 @0522be> : 10 29                      dup.x1 sp(41)
	<.main+3425 @0522c0> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	test/stdc/number.ci:60: (6 bytes: <@0522c4> - <@0522ca>): testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3429 @0522c4> : 10 2a                      dup.x1 sp(42)
	<.main+3431 @0522c6> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	test/stdc/number.ci:62: (12 bytes: <@0522ca> - <@0522d6>): testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3435 @0522ca> : 10 2b                      dup.x1 sp(43)
	<.main+3437 @0522cc> : 19                         load.z32
	<.main+3438 @0522cd> : 1c 05 00 00 00             load.c32 5
	<.main+3443 @0522d2> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:63: (12 bytes: <@0522d6> - <@0522e2>): testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3447 @0522d6> : 10 2c                      dup.x1 sp(44)
	<.main+3449 @0522d8> : 19                         load.z32
	<.main+3450 @0522d9> : 1c 05 00 00 00             load.c32 5
	<.main+3455 @0522de> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:65: (14 bytes: <@0522e2> - <@0522f0>): testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+3459 @0522e2> : 10 2d                      dup.x1 sp(45)
	<.main+3461 @0522e4> : 5c                         i32.2i64
	<.main+3462 @0522e5> : 19                         load.z32
	<.main+3463 @0522e6> : 1c 05 00 00 00             load.c32 5
	<.main+3468 @0522eb> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3472 @0522ef> : 6a                         i64.2i32
	test/stdc/number.ci:66: (14 bytes: <@0522f0> - <@0522fe>): testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+3473 @0522f0> : 10 2e                      dup.x1 sp(46)
	<.main+3475 @0522f2> : 5c                         i32.2i64
	<.main+3476 @0522f3> : 19                         load.z32
	<.main+3477 @0522f4> : 1c 05 00 00 00             load.c32 5
	<.main+3482 @0522f9> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3486 @0522fd> : 6a                         i64.2i32
	test/stdc/memory.ci:7: (14 bytes: <@0522fe> - <@05230c>): p1: pointer := malloc(1024)
	<.main+3487 @0522fe> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3492 @052303> : 1c 00 04 00 00             load.c32 1024
	<.main+3497 @052308> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@05230c> - <@05231a>): p2: pointer := malloc(80)
	<.main+3501 @05230c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3506 @052311> : 1c 50 00 00 00             load.c32 80
	<.main+3511 @052316> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@05231a> - <@052328>): p3: pointer := malloc(160)
	<.main+3515 @05231a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3520 @05231f> : 1c a0 00 00 00             load.c32 160
	<.main+3525 @052324> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@052328> - <@052336>): p4: pointer := malloc(820)
	<.main+3529 @052328> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3534 @05232d> : 1c 34 03 00 00             load.c32 820
	<.main+3539 @052332> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@052336> - <@052346>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3543 @052336> : 10 03                      dup.x1 sp(3)
	<.main+3545 @052338> : 19                         load.z32
	<.main+3546 @052339> : 1c 00 04 00 00             load.c32 1024
	<.main+3551 @05233e> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3555 @052342> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@052346> - <@052357>): pointer.copy(void(void(p1, p3), 160));
	<.main+3559 @052346> : 10 03                      dup.x1 sp(3)
	<.main+3561 @052348> : 10 02                      dup.x1 sp(2)
	<.main+3563 @05234a> : 1c a0 00 00 00             load.c32 160
	<.main+3568 @05234f> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3572 @052353> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@052357> - <@052362>): free(p1);
	<.main+3576 @052357> : 10 03                      dup.x1 sp(3)
	<.main+3578 @052359> : 19                         load.z32
	<.main+3579 @05235a> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3583 @05235e> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@052362> - <@05236d>): free(p2);
	<.main+3587 @052362> : 10 02                      dup.x1 sp(2)
	<.main+3589 @052364> : 19                         load.z32
	<.main+3590 @052365> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3594 @052369> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@05236d> - <@052378>): free(p3);
	<.main+3598 @05236d> : 10 01                      dup.x1 sp(1)
	<.main+3600 @05236f> : 19                         load.z32
	<.main+3601 @052370> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3605 @052374> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@052378> - <@052383>): free(p4);
	<.main+3609 @052378> : 10 00                      dup.x1 sp(0)
	<.main+3611 @05237a> : 19                         load.z32
	<.main+3612 @05237b> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3616 @05237f> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@052383> - <@05238c>): val1: int64 := 42
	<.main+3620 @052383> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@05238c> - <@052395>): val2: int64 := 96
	<.main+3629 @05238c> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@052395> - <@0523b7>): debug(void("val1", val1));
	<.main+3638 @052395> : 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+3643 @05239a> : 1c 1a 00 00 00             load.c32 26
	<.main+3648 @05239f> : 1c 0e 00 00 00             load.c32 14
	<.main+3653 @0523a4> : 19                         load.z32
	<.main+3654 @0523a5> : 1f 98 a3 03 00             load.ref <@03a398> ;"val1"
	<.main+3659 @0523aa> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3664 @0523af> : 0a 20 00 00                load.sp(+32)
	<.main+3668 @0523b3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@0523b7> - <@0523d9>): debug(void("val2", val2));
	<.main+3672 @0523b7> : 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+3677 @0523bc> : 1c 1b 00 00 00             load.c32 27
	<.main+3682 @0523c1> : 1c 0e 00 00 00             load.c32 14
	<.main+3687 @0523c6> : 19                         load.z32
	<.main+3688 @0523c7> : 1f 9d a3 03 00             load.ref <@03a39d> ;"val2"
	<.main+3693 @0523cc> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3698 @0523d1> : 0a 18 00 00                load.sp(+24)
	<.main+3702 @0523d5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@0523d9> - <@0523ed>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3706 @0523d9> : 0a 00 00 00                load.sp(+0)
	<.main+3710 @0523dd> : 0a 0c 00 00                load.sp(+12)
	<.main+3714 @0523e1> : 2a 90 04 00                load.m32 <@000490>
	<.main+3718 @0523e5> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3722 @0523e9> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@0523ed> - <@0523fe>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3726 @0523ed> : 0a 08 00 00                load.sp(+8)
	<.main+3730 @0523f1> : 19                         load.z32
	<.main+3731 @0523f2> : 2a 90 04 00                load.m32 <@000490>
	<.main+3735 @0523f6> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3739 @0523fa> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@0523fe> - <@052420>): debug(void("val1", val1));
	<.main+3743 @0523fe> : 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+3748 @052403> : 1c 20 00 00 00             load.c32 32
	<.main+3753 @052408> : 1c 0e 00 00 00             load.c32 14
	<.main+3758 @05240d> : 19                         load.z32
	<.main+3759 @05240e> : 1f 98 a3 03 00             load.ref <@03a398> ;"val1"
	<.main+3764 @052413> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3769 @052418> : 0a 20 00 00                load.sp(+32)
	<.main+3773 @05241c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@052420> - <@052442>): debug(void("val2", val2));
	<.main+3777 @052420> : 1f 70 a3 03 00             load.ref <@03a370> ;"test/stdc/memory.ci"
	<.main+3782 @052425> : 1c 21 00 00 00             load.c32 33
	<.main+3787 @05242a> : 1c 0e 00 00 00             load.c32 14
	<.main+3792 @05242f> : 19                         load.z32
	<.main+3793 @052430> : 1f 9d a3 03 00             load.ref <@03a39d> ;"val2"
	<.main+3798 @052435> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3803 @05243a> : 0a 18 00 00                load.sp(+24)
	<.main+3807 @05243e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@052442> - <@052450>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3811 @052442> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3816 @052447> : 1f 38 13 05 00             load.ref <@051338> ;noError(ptr: pointer): void
	<.main+3821 @05244c> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@052450> - <@05245e>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3825 @052450> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3830 @052455> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3835 @05245a> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@05245e> - <@05246c>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3839 @05245e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3844 @052463> : 1f 40 13 05 00             load.ref <@051340> ;stackOverflow(ptr: pointer): void
	<.main+3849 @052468> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@05246c> - <@05247a>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3853 @05246c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3858 @052471> : 1f 58 13 05 00             load.ref <@051358> ;divisionByZero(args: pointer): void
	<.main+3863 @052476> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@05247a> - <@052488>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3867 @05247a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3872 @05247f> : 1f c0 13 05 00             load.ref <@0513c0> ;invalidInstruction(args: pointer): void
	<.main+3877 @052484> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@052488> - <@052496>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3881 @052488> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3886 @05248d> : 1f b0 13 05 00             load.ref <@0513b0> ;invalidMemoryAccess(args: pointer): void
	<.main+3891 @052492> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@052496> - <@0524a4>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3895 @052496> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3900 @05249b> : 1f 68 13 05 00             load.ref <@051368> ;abortExecution(args: pointer): void
	<.main+3905 @0524a0> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@0524a4> - <@0524a8>): arrFixedNoInit: int64[7]
	<.main+3909 @0524a4> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@0524a8> - <@0524ac>): arrArrayNoInit: int64[*]
	<.main+3913 @0524a8> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@0524ac> - <@0524b0>): arrSliceNoInit: int64[]
	<.main+3917 @0524ac> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@0524b0> - <@0524dd>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3921 @0524b0> : 19                         load.z32
	<.main+3922 @0524b1> : 04 1c 00 00                jmp <.main+3950 @0524cd>
	test/lang/array.ci:55: (20 bytes: <@0524b5> - <@0524c9>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3926 @0524b5> : 1c 2a 00 00 00             load.c32 42
	<.main+3931 @0524ba> : 10 01                      dup.x1 sp(1)
	<.main+3933 @0524bc> : 51                         add.i32
	<.main+3934 @0524bd> : 5c                         i32.2i64
	<.main+3935 @0524be> : 0a 18 00 00                load.sp(+24)
	<.main+3939 @0524c2> : 10 03                      dup.x1 sp(3)
	<.main+3941 @0524c4> : 0d 08 00 00                mad.u32 8
	<.main+3945 @0524c8> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@0524c9> - <@0524cd>): int32(i := int32(i + 1))
	<.main+3946 @0524c9> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@0524cd> - <@0524d9>): bool(i < arrFixedNoInit.length)
	<.main+3950 @0524cd> : 10 00                      dup.x1 sp(0)
	<.main+3952 @0524cf> : 1c 07 00 00 00             load.c32 7
	<.main+3957 @0524d4> : 58                         clt.i32
	<.main+3958 @0524d5> : 05 e0 ff ff                jnz <.main+3926 @0524b5>
	<.main+3962 @0524d9> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@0524dd> - <@0524e2>): arrArrayInitNull: int64[*] := null
	<.main+3966 @0524dd> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@0524e2> - <@0524e8>): arrSliceInitNull: int64[] := null
	<.main+3971 @0524e2> : 19                         load.z32
	<.main+3972 @0524e3> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@0524e8> - <@0524ec>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3977 @0524e8> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@0524ec> - <@0524f5>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3981 @0524ec> : 1c 07 00 00 00             load.c32 7
	<.main+3986 @0524f1> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@0524f5> - <@0524f7>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3990 @0524f5> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@0524f7> - <@0524f9>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3992 @0524f7> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@0524f9> - <@0524fb>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3994 @0524f9> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@0524fb> - <@0524ff>): strFixed: char[7]
	<.main+3996 @0524fb> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@0524ff> - <@052515>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+4000 @0524ff> : 0a 00 00 00                load.sp(+0)
	<.main+4004 @052503> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	<.main+4009 @052508> : 1c 07 00 00 00             load.c32 7
	<.main+4014 @05250d> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+4018 @052511> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@052515> - <@052537>): debug(void("string as variant", strFixed));
	<.main+4022 @052515> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4027 @05251a> : 1c 53 00 00 00             load.c32 83
	<.main+4032 @05251f> : 1c 0e 00 00 00             load.c32 14
	<.main+4037 @052524> : 19                         load.z32
	<.main+4038 @052525> : 1f c3 c4 03 00             load.ref <@03c4c3> ;"string as variant"
	<.main+4043 @05252a> : 1f d0 d2 03 00             load.ref <@03d2d0>
	<.main+4048 @05252f> : 0a 18 00 00                load.sp(+24)
	<.main+4052 @052533> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@052537> - <@052559>): debug(void("string to variant", variant(strFixed)));
	<.main+4056 @052537> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4061 @05253c> : 1c 54 00 00 00             load.c32 84
	<.main+4066 @052541> : 1c 0e 00 00 00             load.c32 14
	<.main+4071 @052546> : 19                         load.z32
	<.main+4072 @052547> : 1f d5 c4 03 00             load.ref <@03c4d5> ;"string to variant"
	<.main+4077 @05254c> : 1f d0 d2 03 00             load.ref <@03d2d0>
	<.main+4082 @052551> : 0a 18 00 00                load.sp(+24)
	<.main+4086 @052555> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@052559> - <@05255e>): strArray: char[*] := "string"
	<.main+4090 @052559> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	test/lang/array.ci:87: (32 bytes: <@05255e> - <@05257e>): debug(void("string as variant", strArray));
	<.main+4095 @05255e> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4100 @052563> : 1c 57 00 00 00             load.c32 87
	<.main+4105 @052568> : 1c 0e 00 00 00             load.c32 14
	<.main+4110 @05256d> : 19                         load.z32
	<.main+4111 @05256e> : 1f c3 c4 03 00             load.ref <@03c4c3> ;"string as variant"
	<.main+4116 @052573> : 1f 98 d4 03 00             load.ref <@03d498>
	<.main+4121 @052578> : 10 06                      dup.x1 sp(6)
	<.main+4123 @05257a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@05257e> - <@05259e>): debug(void("string to variant", variant(strArray)));
	<.main+4127 @05257e> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4132 @052583> : 1c 58 00 00 00             load.c32 88
	<.main+4137 @052588> : 1c 0e 00 00 00             load.c32 14
	<.main+4142 @05258d> : 19                         load.z32
	<.main+4143 @05258e> : 1f d5 c4 03 00             load.ref <@03c4d5> ;"string to variant"
	<.main+4148 @052593> : 1f 98 d4 03 00             load.ref <@03d498>
	<.main+4153 @052598> : 10 06                      dup.x1 sp(6)
	<.main+4155 @05259a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@05259e> - <@0525a8>): strSlice: char[] := "string"
	<.main+4159 @05259e> : 1c 06 00 00 00             load.c32 6
	<.main+4164 @0525a3> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	test/lang/array.ci:91: (32 bytes: <@0525a8> - <@0525c8>): debug(void("string as variant", strSlice));
	<.main+4169 @0525a8> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4174 @0525ad> : 1c 5b 00 00 00             load.c32 91
	<.main+4179 @0525b2> : 1c 0e 00 00 00             load.c32 14
	<.main+4184 @0525b7> : 19                         load.z32
	<.main+4185 @0525b8> : 1f c3 c4 03 00             load.ref <@03c4c3> ;"string as variant"
	<.main+4190 @0525bd> : 1f c8 d5 03 00             load.ref <@03d5c8>
	<.main+4195 @0525c2> : 10 06                      dup.x1 sp(6)
	<.main+4197 @0525c4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@0525c8> - <@0525e8>): debug(void("string to variant", variant(strSlice)));
	<.main+4201 @0525c8> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4206 @0525cd> : 1c 5c 00 00 00             load.c32 92
	<.main+4211 @0525d2> : 1c 0e 00 00 00             load.c32 14
	<.main+4216 @0525d7> : 19                         load.z32
	<.main+4217 @0525d8> : 1f d5 c4 03 00             load.ref <@03c4d5> ;"string to variant"
	<.main+4222 @0525dd> : 1f c8 d5 03 00             load.ref <@03d5c8>
	<.main+4227 @0525e2> : 10 06                      dup.x1 sp(6)
	<.main+4229 @0525e4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@0525e8> - <@05261b>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4233 @0525e8> : 10 10                      dup.x1 sp(16)
	<.main+4235 @0525ea> : 19                         load.z32
	<.main+4236 @0525eb> : 38                         clt.u32
	<.main+4237 @0525ec> : 05 08 00 00                jnz <.main+4245 @0525f4>
	<.main+4241 @0525f0> : 04 2b 00 00                jmp <.main+4284 @05261b>
	<.main+4245 @0525f4> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4250 @0525f9> : 1c 62 00 00 00             load.c32 98
	<.main+4255 @0525fe> : 1c fe ff ff ff             load.c32 -2
	<.main+4260 @052603> : 1c 80 00 00 00             load.c32 128
	<.main+4265 @052608> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4270 @05260d> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4275 @052612> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4280 @052617> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@05261b> - <@05264e>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4284 @05261b> : 10 0d                      dup.x1 sp(13)
	<.main+4286 @05261d> : 19                         load.z32
	<.main+4287 @05261e> : 57                         ceq.i32
	<.main+4288 @05261f> : 06 08 00 00                jz <.main+4296 @052627>
	<.main+4292 @052623> : 04 2b 00 00                jmp <.main+4335 @05264e>
	<.main+4296 @052627> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4301 @05262c> : 1c 63 00 00 00             load.c32 99
	<.main+4306 @052631> : 1c fe ff ff ff             load.c32 -2
	<.main+4311 @052636> : 1c 80 00 00 00             load.c32 128
	<.main+4316 @05263b> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4321 @052640> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4326 @052645> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4331 @05264a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@05264e> - <@052689>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4335 @05264e> : 11 12                      dup.x2 sp(18)
	<.main+4337 @052650> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4346 @052659> : 67                         ceq.i64
	<.main+4347 @05265a> : 06 08 00 00                jz <.main+4355 @052662>
	<.main+4351 @05265e> : 04 2b 00 00                jmp <.main+4394 @052689>
	<.main+4355 @052662> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4360 @052667> : 1c 65 00 00 00             load.c32 101
	<.main+4365 @05266c> : 1c fe ff ff ff             load.c32 -2
	<.main+4370 @052671> : 1c 80 00 00 00             load.c32 128
	<.main+4375 @052676> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4380 @05267b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4385 @052680> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4390 @052685> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@052689> - <@0526a2>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4394 @052689> : 1c 07 00 00 00             load.c32 7
	<.main+4399 @05268e> : 1c 07 00 00 00             load.c32 7
	<.main+4404 @052693> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4409 @052698> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4414 @05269d> : 02                         call
	<.main+4415 @05269e> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@0526a2> - <@0526b8>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4419 @0526a2> : 1c 07 00 00 00             load.c32 7
	<.main+4424 @0526a7> : 10 0b                      dup.x1 sp(11)
	<.main+4426 @0526a9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4431 @0526ae> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4436 @0526b3> : 02                         call
	<.main+4437 @0526b4> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@0526b8> - <@0526ce>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4441 @0526b8> : 1c 07 00 00 00             load.c32 7
	<.main+4446 @0526bd> : 10 08                      dup.x1 sp(8)
	<.main+4448 @0526bf> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4453 @0526c4> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4458 @0526c9> : 02                         call
	<.main+4459 @0526ca> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@0526ce> - <@0526ee>): assertEq(void(0, lenSlice(null)));
	<.main+4463 @0526ce> : 19                         load.z32
	<.main+4464 @0526cf> : 1a                         load.z64
	<.main+4465 @0526d0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4470 @0526d5> : 1f c8 13 05 00             load.ref <@0513c8> ;lenSlice(values: int64[]): int32
	<.main+4475 @0526da> : 02                         call
	<.main+4476 @0526db> : 09 f8 ff ff                inc.sp(-8)
	<.main+4480 @0526df> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4485 @0526e4> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4490 @0526e9> : 02                         call
	<.main+4491 @0526ea> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@0526ee> - <@05270b>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4495 @0526ee> : 19                         load.z32
	<.main+4496 @0526ef> : 19                         load.z32
	<.main+4497 @0526f0> : 11 0e                      dup.x2 sp(14)
	<.main+4499 @0526f2> : 1f c8 13 05 00             load.ref <@0513c8> ;lenSlice(values: int64[]): int32
	<.main+4504 @0526f7> : 02                         call
	<.main+4505 @0526f8> : 09 f8 ff ff                inc.sp(-8)
	<.main+4509 @0526fc> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4514 @052701> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4519 @052706> : 02                         call
	<.main+4520 @052707> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@05270b> - <@052733>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4524 @05270b> : 1c 07 00 00 00             load.c32 7
	<.main+4529 @052710> : 19                         load.z32
	<.main+4530 @052711> : 1c 07 00 00 00             load.c32 7
	<.main+4535 @052716> : 0a 54 00 00                load.sp(+84)
	<.main+4539 @05271a> : 1f c8 13 05 00             load.ref <@0513c8> ;lenSlice(values: int64[]): int32
	<.main+4544 @05271f> : 02                         call
	<.main+4545 @052720> : 09 f8 ff ff                inc.sp(-8)
	<.main+4549 @052724> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4554 @052729> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4559 @05272e> : 02                         call
	<.main+4560 @05272f> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@052733> - <@052754>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4564 @052733> : 1c 07 00 00 00             load.c32 7
	<.main+4569 @052738> : 19                         load.z32
	<.main+4570 @052739> : 11 0b                      dup.x2 sp(11)
	<.main+4572 @05273b> : 1f c8 13 05 00             load.ref <@0513c8> ;lenSlice(values: int64[]): int32
	<.main+4577 @052740> : 02                         call
	<.main+4578 @052741> : 09 f8 ff ff                inc.sp(-8)
	<.main+4582 @052745> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4587 @05274a> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4592 @05274f> : 02                         call
	<.main+4593 @052750> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@052754> - <@052775>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4597 @052754> : 1c 07 00 00 00             load.c32 7
	<.main+4602 @052759> : 19                         load.z32
	<.main+4603 @05275a> : 11 08                      dup.x2 sp(8)
	<.main+4605 @05275c> : 1f c8 13 05 00             load.ref <@0513c8> ;lenSlice(values: int64[]): int32
	<.main+4610 @052761> : 02                         call
	<.main+4611 @052762> : 09 f8 ff ff                inc.sp(-8)
	<.main+4615 @052766> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4620 @05276b> : 1f 10 02 05 00             load.ref <@050210> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4625 @052770> : 02                         call
	<.main+4626 @052771> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@052775> - <@052a9c>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4630 @052775> : 19                         load.z32
	<.main+4631 @052776> : 04 16 03 00                jmp <.main+5421 @052a8c>
	test/lang/array.ci:119: (9 bytes: <@05277a> - <@052783>): expected: int64 := int32(42 + i)
	<.main+4635 @05277a> : 1c 2a 00 00 00             load.c32 42
	<.main+4640 @05277f> : 10 01                      dup.x1 sp(1)
	<.main+4642 @052781> : 51                         add.i32
	<.main+4643 @052782> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@052783> - <@0527c0>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4644 @052783> : 11 00                      dup.x2 sp(0)
	<.main+4646 @052785> : 0a 5c 00 00                load.sp(+92)
	<.main+4650 @052789> : 10 05                      dup.x1 sp(5)
	<.main+4652 @05278b> : 0d 08 00 00                mad.u32 8
	<.main+4656 @05278f> : 23                         load.i64
	<.main+4657 @052790> : 67                         ceq.i64
	<.main+4658 @052791> : 06 08 00 00                jz <.main+4666 @052799>
	<.main+4662 @052795> : 04 2b 00 00                jmp <.main+4705 @0527c0>
	<.main+4666 @052799> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4671 @05279e> : 1c 78 00 00 00             load.c32 120
	<.main+4676 @0527a3> : 1c fe ff ff ff             load.c32 -2
	<.main+4681 @0527a8> : 1c 80 00 00 00             load.c32 128
	<.main+4686 @0527ad> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4691 @0527b2> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4696 @0527b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4701 @0527bc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@0527c0> - <@0527fb>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4705 @0527c0> : 11 00                      dup.x2 sp(0)
	<.main+4707 @0527c2> : 10 10                      dup.x1 sp(16)
	<.main+4709 @0527c4> : 10 05                      dup.x1 sp(5)
	<.main+4711 @0527c6> : 0d 08 00 00                mad.u32 8
	<.main+4715 @0527ca> : 23                         load.i64
	<.main+4716 @0527cb> : 67                         ceq.i64
	<.main+4717 @0527cc> : 06 08 00 00                jz <.main+4725 @0527d4>
	<.main+4721 @0527d0> : 04 2b 00 00                jmp <.main+4764 @0527fb>
	<.main+4725 @0527d4> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4730 @0527d9> : 1c 79 00 00 00             load.c32 121
	<.main+4735 @0527de> : 1c fe ff ff ff             load.c32 -2
	<.main+4740 @0527e3> : 1c 80 00 00 00             load.c32 128
	<.main+4745 @0527e8> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4750 @0527ed> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4755 @0527f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4760 @0527f7> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@0527fb> - <@052836>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4764 @0527fb> : 11 00                      dup.x2 sp(0)
	<.main+4766 @0527fd> : 10 0e                      dup.x1 sp(14)
	<.main+4768 @0527ff> : 10 05                      dup.x1 sp(5)
	<.main+4770 @052801> : 0d 08 00 00                mad.u32 8
	<.main+4774 @052805> : 23                         load.i64
	<.main+4775 @052806> : 67                         ceq.i64
	<.main+4776 @052807> : 06 08 00 00                jz <.main+4784 @05280f>
	<.main+4780 @05280b> : 04 2b 00 00                jmp <.main+4823 @052836>
	<.main+4784 @05280f> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4789 @052814> : 1c 7a 00 00 00             load.c32 122
	<.main+4794 @052819> : 1c fe ff ff ff             load.c32 -2
	<.main+4799 @05281e> : 1c 80 00 00 00             load.c32 128
	<.main+4804 @052823> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4809 @052828> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4814 @05282d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4819 @052832> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@052836> - <@052879>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4823 @052836> : 11 00                      dup.x2 sp(0)
	<.main+4825 @052838> : 1a                         load.z64
	<.main+4826 @052839> : 10 06                      dup.x1 sp(6)
	<.main+4828 @05283b> : 0a 68 00 00                load.sp(+104)
	<.main+4832 @05283f> : 1f d0 13 05 00             load.ref <@0513d0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4837 @052844> : 02                         call
	<.main+4838 @052845> : 09 f8 ff ff                inc.sp(-8)
	<.main+4842 @052849> : 67                         ceq.i64
	<.main+4843 @05284a> : 06 08 00 00                jz <.main+4851 @052852>
	<.main+4847 @05284e> : 04 2b 00 00                jmp <.main+4890 @052879>
	<.main+4851 @052852> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4856 @052857> : 1c 7c 00 00 00             load.c32 124
	<.main+4861 @05285c> : 1c fe ff ff ff             load.c32 -2
	<.main+4866 @052861> : 1c 80 00 00 00             load.c32 128
	<.main+4871 @052866> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4876 @05286b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4881 @052870> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4886 @052875> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@052879> - <@0528ba>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4890 @052879> : 11 00                      dup.x2 sp(0)
	<.main+4892 @05287b> : 1a                         load.z64
	<.main+4893 @05287c> : 10 06                      dup.x1 sp(6)
	<.main+4895 @05287e> : 10 13                      dup.x1 sp(19)
	<.main+4897 @052880> : 1f d0 13 05 00             load.ref <@0513d0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4902 @052885> : 02                         call
	<.main+4903 @052886> : 09 f8 ff ff                inc.sp(-8)
	<.main+4907 @05288a> : 67                         ceq.i64
	<.main+4908 @05288b> : 06 08 00 00                jz <.main+4916 @052893>
	<.main+4912 @05288f> : 04 2b 00 00                jmp <.main+4955 @0528ba>
	<.main+4916 @052893> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4921 @052898> : 1c 7d 00 00 00             load.c32 125
	<.main+4926 @05289d> : 1c fe ff ff ff             load.c32 -2
	<.main+4931 @0528a2> : 1c 80 00 00 00             load.c32 128
	<.main+4936 @0528a7> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4941 @0528ac> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4946 @0528b1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4951 @0528b6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@0528ba> - <@0528fb>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4955 @0528ba> : 11 00                      dup.x2 sp(0)
	<.main+4957 @0528bc> : 1a                         load.z64
	<.main+4958 @0528bd> : 10 06                      dup.x1 sp(6)
	<.main+4960 @0528bf> : 10 11                      dup.x1 sp(17)
	<.main+4962 @0528c1> : 1f d0 13 05 00             load.ref <@0513d0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4967 @0528c6> : 02                         call
	<.main+4968 @0528c7> : 09 f8 ff ff                inc.sp(-8)
	<.main+4972 @0528cb> : 67                         ceq.i64
	<.main+4973 @0528cc> : 06 08 00 00                jz <.main+4981 @0528d4>
	<.main+4977 @0528d0> : 04 2b 00 00                jmp <.main+5020 @0528fb>
	<.main+4981 @0528d4> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+4986 @0528d9> : 1c 7e 00 00 00             load.c32 126
	<.main+4991 @0528de> : 1c fe ff ff ff             load.c32 -2
	<.main+4996 @0528e3> : 1c 80 00 00 00             load.c32 128
	<.main+5001 @0528e8> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5006 @0528ed> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5011 @0528f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5016 @0528f7> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@0528fb> - <@05293e>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+5020 @0528fb> : 11 00                      dup.x2 sp(0)
	<.main+5022 @0528fd> : 1a                         load.z64
	<.main+5023 @0528fe> : 10 06                      dup.x1 sp(6)
	<.main+5025 @052900> : 0a 68 00 00                load.sp(+104)
	<.main+5029 @052904> : 1f e0 13 05 00             load.ref <@0513e0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5034 @052909> : 02                         call
	<.main+5035 @05290a> : 09 f8 ff ff                inc.sp(-8)
	<.main+5039 @05290e> : 67                         ceq.i64
	<.main+5040 @05290f> : 06 08 00 00                jz <.main+5048 @052917>
	<.main+5044 @052913> : 04 2b 00 00                jmp <.main+5087 @05293e>
	<.main+5048 @052917> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+5053 @05291c> : 1c 80 00 00 00             load.c32 128
	<.main+5058 @052921> : 1c fe ff ff ff             load.c32 -2
	<.main+5063 @052926> : 1c 80 00 00 00             load.c32 128
	<.main+5068 @05292b> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5073 @052930> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5078 @052935> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5083 @05293a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@05293e> - <@05297f>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5087 @05293e> : 11 00                      dup.x2 sp(0)
	<.main+5089 @052940> : 1a                         load.z64
	<.main+5090 @052941> : 10 06                      dup.x1 sp(6)
	<.main+5092 @052943> : 10 13                      dup.x1 sp(19)
	<.main+5094 @052945> : 1f e0 13 05 00             load.ref <@0513e0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5099 @05294a> : 02                         call
	<.main+5100 @05294b> : 09 f8 ff ff                inc.sp(-8)
	<.main+5104 @05294f> : 67                         ceq.i64
	<.main+5105 @052950> : 06 08 00 00                jz <.main+5113 @052958>
	<.main+5109 @052954> : 04 2b 00 00                jmp <.main+5152 @05297f>
	<.main+5113 @052958> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+5118 @05295d> : 1c 81 00 00 00             load.c32 129
	<.main+5123 @052962> : 1c fe ff ff ff             load.c32 -2
	<.main+5128 @052967> : 1c 80 00 00 00             load.c32 128
	<.main+5133 @05296c> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5138 @052971> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5143 @052976> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5148 @05297b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@05297f> - <@0529c0>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5152 @05297f> : 11 00                      dup.x2 sp(0)
	<.main+5154 @052981> : 1a                         load.z64
	<.main+5155 @052982> : 10 06                      dup.x1 sp(6)
	<.main+5157 @052984> : 10 11                      dup.x1 sp(17)
	<.main+5159 @052986> : 1f e0 13 05 00             load.ref <@0513e0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5164 @05298b> : 02                         call
	<.main+5165 @05298c> : 09 f8 ff ff                inc.sp(-8)
	<.main+5169 @052990> : 67                         ceq.i64
	<.main+5170 @052991> : 06 08 00 00                jz <.main+5178 @052999>
	<.main+5174 @052995> : 04 2b 00 00                jmp <.main+5217 @0529c0>
	<.main+5178 @052999> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+5183 @05299e> : 1c 82 00 00 00             load.c32 130
	<.main+5188 @0529a3> : 1c fe ff ff ff             load.c32 -2
	<.main+5193 @0529a8> : 1c 80 00 00 00             load.c32 128
	<.main+5198 @0529ad> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5203 @0529b2> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5208 @0529b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5213 @0529bc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@0529c0> - <@052a08>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5217 @0529c0> : 11 00                      dup.x2 sp(0)
	<.main+5219 @0529c2> : 1a                         load.z64
	<.main+5220 @0529c3> : 10 06                      dup.x1 sp(6)
	<.main+5222 @0529c5> : 1c 07 00 00 00             load.c32 7
	<.main+5227 @0529ca> : 0a 6c 00 00                load.sp(+108)
	<.main+5231 @0529ce> : 1f f0 13 05 00             load.ref <@0513f0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5236 @0529d3> : 02                         call
	<.main+5237 @0529d4> : 09 f4 ff ff                inc.sp(-12)
	<.main+5241 @0529d8> : 67                         ceq.i64
	<.main+5242 @0529d9> : 06 08 00 00                jz <.main+5250 @0529e1>
	<.main+5246 @0529dd> : 04 2b 00 00                jmp <.main+5289 @052a08>
	<.main+5250 @0529e1> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+5255 @0529e6> : 1c 84 00 00 00             load.c32 132
	<.main+5260 @0529eb> : 1c fe ff ff ff             load.c32 -2
	<.main+5265 @0529f0> : 1c 80 00 00 00             load.c32 128
	<.main+5270 @0529f5> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5275 @0529fa> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5280 @0529ff> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5285 @052a04> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@052a08> - <@052a49>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5289 @052a08> : 11 00                      dup.x2 sp(0)
	<.main+5291 @052a0a> : 1a                         load.z64
	<.main+5292 @052a0b> : 10 06                      dup.x1 sp(6)
	<.main+5294 @052a0d> : 11 11                      dup.x2 sp(17)
	<.main+5296 @052a0f> : 1f f0 13 05 00             load.ref <@0513f0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5301 @052a14> : 02                         call
	<.main+5302 @052a15> : 09 f4 ff ff                inc.sp(-12)
	<.main+5306 @052a19> : 67                         ceq.i64
	<.main+5307 @052a1a> : 06 08 00 00                jz <.main+5315 @052a22>
	<.main+5311 @052a1e> : 04 2b 00 00                jmp <.main+5354 @052a49>
	<.main+5315 @052a22> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+5320 @052a27> : 1c 86 00 00 00             load.c32 134
	<.main+5325 @052a2c> : 1c fe ff ff ff             load.c32 -2
	<.main+5330 @052a31> : 1c 80 00 00 00             load.c32 128
	<.main+5335 @052a36> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5340 @052a3b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5345 @052a40> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5350 @052a45> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@052a49> - <@052a84>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5354 @052a49> : 11 00                      dup.x2 sp(0)
	<.main+5356 @052a4b> : 10 0b                      dup.x1 sp(11)
	<.main+5358 @052a4d> : 10 05                      dup.x1 sp(5)
	<.main+5360 @052a4f> : 0d 08 00 00                mad.u32 8
	<.main+5364 @052a53> : 23                         load.i64
	<.main+5365 @052a54> : 67                         ceq.i64
	<.main+5366 @052a55> : 06 08 00 00                jz <.main+5374 @052a5d>
	<.main+5370 @052a59> : 04 2b 00 00                jmp <.main+5413 @052a84>
	<.main+5374 @052a5d> : 1f 00 c4 03 00             load.ref <@03c400> ;"test/lang/array.ci"
	<.main+5379 @052a62> : 1c 88 00 00 00             load.c32 136
	<.main+5384 @052a67> : 1c fe ff ff ff             load.c32 -2
	<.main+5389 @052a6c> : 1c 80 00 00 00             load.c32 128
	<.main+5394 @052a71> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5399 @052a76> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5404 @052a7b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5409 @052a80> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5413 @052a84> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@052a88> - <@052a8c>): int32(i := int32(i + 1))
	<.main+5417 @052a88> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@052a8c> - <@052a98>): bool(i < arrFixedNoInit.length)
	<.main+5421 @052a8c> : 10 00                      dup.x1 sp(0)
	<.main+5423 @052a8e> : 1c 07 00 00 00             load.c32 7
	<.main+5428 @052a93> : 58                         clt.i32
	<.main+5429 @052a94> : 05 e6 fc ff                jnz <.main+4635 @05277a>
	<.main+5433 @052a98> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@052a9c> - <@052ad8>): recordMemberTest: RecordMemberTest := {...}
	<.main+5437 @052a9c> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@052aa0> - <@052aa7>): void(recordMemberTest.member := 10);
	<.main+5441 @052aa0> : 1c 0a 00 00 00             load.c32 10
	<.main+5446 @052aa5> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@052aa7> - <@052aae>): void(recordMemberTest.constant := 11);
	<.main+5448 @052aa7> : 1c 0b 00 00 00             load.c32 11
	<.main+5453 @052aac> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@052aae> - <@052ab5>): void(recordMemberTest.memberInit := 12);
	<.main+5455 @052aae> : 1c 0c 00 00 00             load.c32 12
	<.main+5460 @052ab3> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@052ab5> - <@052abc>): void(recordMemberTest.constantInit := 13);
	<.main+5462 @052ab5> : 1c 0d 00 00 00             load.c32 13
	<.main+5467 @052aba> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@052abc> - <@052ac3>): void(recordMemberTest.memberRec.member := 14);
	<.main+5469 @052abc> : 1c 0e 00 00 00             load.c32 14
	<.main+5474 @052ac1> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@052ac3> - <@052aca>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5476 @052ac3> : 1c 0f 00 00 00             load.c32 15
	<.main+5481 @052ac8> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@052aca> - <@052ad1>): void(recordMemberTest.constantRec.member := 16);
	<.main+5483 @052aca> : 1c 10 00 00 00             load.c32 16
	<.main+5488 @052acf> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@052ad1> - <@052ad8>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5490 @052ad1> : 1c 11 00 00 00             load.c32 17
	<.main+5495 @052ad6> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:62: (24 bytes: <@052ad8> - <@052af0>): recordMethodTest: RecordMethodTest := {...}
	<.main+5497 @052ad8> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:64: (7 bytes: <@052adc> - <@052ae3>): void(recordMethodTest.abstractMethod := globalFunction);
	<.main+5501 @052adc> : 1f b0 14 05 00             load.ref <@0514b0> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5506 @052ae1> : 13 01                      set.x1 sp(1)
	:: (6 bytes: <@052ae3> - <@052ae9>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5508 @052ae3> : 2a 58 14 05                load.m32 <@051458> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5512 @052ae7> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@052ae9> - <@052af0>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5514 @052ae9> : 1f 60 14 05 00             load.ref <@051460> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5519 @052aee> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:78: (19 bytes: <@052af0> - <@052b03>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+5521 @052af0> : 12 00                      dup.x4 sp(0)
	<.main+5523 @052af2> : 1c 01 00 00 00             load.c32 1
	<.main+5528 @052af7> : 13 04                      set.x1 sp(4)
	<.main+5530 @052af9> : 1f 30 14 05 00             load.ref <@051430> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5535 @052afe> : 02                         call
	<.main+5536 @052aff> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:79: (16 bytes: <@052b03> - <@052b13>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+5540 @052b03> : 12 00                      dup.x4 sp(0)
	<.main+5542 @052b05> : 1c 01 00 00 00             load.c32 1
	<.main+5547 @052b0a> : 13 04                      set.x1 sp(4)
	<.main+5549 @052b0c> : 10 06                      dup.x1 sp(6)
	<.main+5551 @052b0e> : 02                         call
	<.main+5552 @052b0f> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:97: (17 bytes: <@052b13> - <@052b24>): staticMethod(void(recordMethodTest, 2));
	<.main+5556 @052b13> : 12 00                      dup.x4 sp(0)
	<.main+5558 @052b15> : 1c 02 00 00 00             load.c32 2
	<.main+5563 @052b1a> : 1f d8 14 05 00             load.ref <@0514d8> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5568 @052b1f> : 02                         call
	<.main+5569 @052b20> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:98: (17 bytes: <@052b24> - <@052b35>): virtualMethod(void(recordMethodTest, 2));
	<.main+5573 @052b24> : 12 00                      dup.x4 sp(0)
	<.main+5575 @052b26> : 1c 02 00 00 00             load.c32 2
	<.main+5580 @052b2b> : 1f 20 15 05 00             load.ref <@051520> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5585 @052b30> : 02                         call
	<.main+5586 @052b31> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:101: (19 bytes: <@052b35> - <@052b48>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+5590 @052b35> : 12 00                      dup.x4 sp(0)
	<.main+5592 @052b37> : 1c 03 00 00 00             load.c32 3
	<.main+5597 @052b3c> : 13 04                      set.x1 sp(4)
	<.main+5599 @052b3e> : 1f 30 14 05 00             load.ref <@051430> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5604 @052b43> : 02                         call
	<.main+5605 @052b44> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:102: (19 bytes: <@052b48> - <@052b5b>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5609 @052b48> : 12 00                      dup.x4 sp(0)
	<.main+5611 @052b4a> : 1c 03 00 00 00             load.c32 3
	<.main+5616 @052b4f> : 13 04                      set.x1 sp(4)
	<.main+5618 @052b51> : 1f 60 14 05 00             load.ref <@051460> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5623 @052b56> : 02                         call
	<.main+5624 @052b57> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:103: (16 bytes: <@052b5b> - <@052b6b>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5628 @052b5b> : 12 00                      dup.x4 sp(0)
	<.main+5630 @052b5d> : 1c 03 00 00 00             load.c32 3
	<.main+5635 @052b62> : 13 04                      set.x1 sp(4)
	<.main+5637 @052b64> : 10 06                      dup.x1 sp(6)
	<.main+5639 @052b66> : 02                         call
	<.main+5640 @052b67> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@052b6b> - <@052b81>): black: rgbU8 := {...}
	<.main+5644 @052b6b> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@052b6f> - <@052b75>): void(black.r := (0));
	<.main+5648 @052b6f> : 19                         load.z32
	<.main+5649 @052b70> : 0a 06 00 00                load.sp(+6)
	<.main+5653 @052b74> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@052b75> - <@052b7b>): void(black.g := (0));
	<.main+5654 @052b75> : 19                         load.z32
	<.main+5655 @052b76> : 0a 05 00 00                load.sp(+5)
	<.main+5659 @052b7a> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@052b7b> - <@052b81>): void(black.b := (0));
	<.main+5660 @052b7b> : 19                         load.z32
	<.main+5661 @052b7c> : 0a 04 00 00                load.sp(+4)
	<.main+5665 @052b80> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@052b81> - <@052b9b>): green: rgbU8 := {...}
	<.main+5666 @052b81> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@052b85> - <@052b8b>): void(green.r := (0));
	<.main+5670 @052b85> : 19                         load.z32
	<.main+5671 @052b86> : 0a 06 00 00                load.sp(+6)
	<.main+5675 @052b8a> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@052b8b> - <@052b95>): void(green.g := (255));
	<.main+5676 @052b8b> : 1c ff 00 00 00             load.c32 255
	<.main+5681 @052b90> : 0a 05 00 00                load.sp(+5)
	<.main+5685 @052b94> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@052b95> - <@052b9b>): void(green.b := (0));
	<.main+5686 @052b95> : 19                         load.z32
	<.main+5687 @052b96> : 0a 04 00 00                load.sp(+4)
	<.main+5691 @052b9a> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@052b9b> - <@052bbd>): white: rgbU8 := {...}
	<.main+5692 @052b9b> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@052b9f> - <@052ba9>): void(white.r := (255));
	<.main+5696 @052b9f> : 1c ff 00 00 00             load.c32 255
	<.main+5701 @052ba4> : 0a 06 00 00                load.sp(+6)
	<.main+5705 @052ba8> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@052ba9> - <@052bb3>): void(white.g := (255));
	<.main+5706 @052ba9> : 1c ff 00 00 00             load.c32 255
	<.main+5711 @052bae> : 0a 05 00 00                load.sp(+5)
	<.main+5715 @052bb2> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@052bb3> - <@052bbd>): void(white.b := (255));
	<.main+5716 @052bb3> : 1c ff 00 00 00             load.c32 255
	<.main+5721 @052bb8> : 0a 04 00 00                load.sp(+4)
	<.main+5725 @052bbc> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@052bbd> - <@052bc8>): cyan: color := {...}
	<.main+5726 @052bbd> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@052bc1> - <@052bc8>): void(cyan.col := (65535));
	<.main+5730 @052bc1> : 1c ff ff 00 00             load.c32 65535
	<.main+5735 @052bc6> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@052bc8> - <@052be2>): blue: color := {...}
	<.main+5737 @052bc8> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@052bcc> - <@052bd2>): void(blue.rgb.r := (0));
	<.main+5741 @052bcc> : 19                         load.z32
	<.main+5742 @052bcd> : 0a 06 00 00                load.sp(+6)
	<.main+5746 @052bd1> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@052bd2> - <@052bd8>): void(blue.rgb.g := (0));
	<.main+5747 @052bd2> : 19                         load.z32
	<.main+5748 @052bd3> : 0a 05 00 00                load.sp(+5)
	<.main+5752 @052bd7> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@052bd8> - <@052be2>): void(blue.rgb.b := (255));
	<.main+5753 @052bd8> : 1c ff 00 00 00             load.c32 255
	<.main+5758 @052bdd> : 0a 04 00 00                load.sp(+4)
	<.main+5762 @052be1> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@052be2> - <@052be7>): shift: int32 := 2
	<.main+5763 @052be2> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@052be7> - <@052bec>): boolA: bool := true
	<.main+5768 @052be7> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@052bec> - <@052bf1>): boolB: bool := bool(!false)
	<.main+5773 @052bec> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@052bf1> - <@052bfc>): boolAnd: bool := bool(boolA & boolB)
	<.main+5778 @052bf1> : 0a 04 00 00                load.sp(+4)
	<.main+5782 @052bf5> : 20                         load.i8
	<.main+5783 @052bf6> : 0a 04 00 00                load.sp(+4)
	<.main+5787 @052bfa> : 20                         load.i8
	<.main+5788 @052bfb> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@052bfc> - <@052c07>): boolIor: bool := bool(boolA | boolB)
	<.main+5789 @052bfc> : 0a 08 00 00                load.sp(+8)
	<.main+5793 @052c00> : 20                         load.i8
	<.main+5794 @052c01> : 0a 08 00 00                load.sp(+8)
	<.main+5798 @052c05> : 20                         load.i8
	<.main+5799 @052c06> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@052c07> - <@052c12>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5800 @052c07> : 0a 0c 00 00                load.sp(+12)
	<.main+5804 @052c0b> : 20                         load.i8
	<.main+5805 @052c0c> : 0a 0c 00 00                load.sp(+12)
	<.main+5809 @052c10> : 20                         load.i8
	<.main+5810 @052c11> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@052c12> - <@052c18>): boolNot: bool := bool(!boolB)
	<.main+5811 @052c12> : 0a 0c 00 00                load.sp(+12)
	<.main+5815 @052c16> : 20                         load.i8
	<.main+5816 @052c17> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@052c18> - <@052c23>): boolCeq: bool := bool(boolA == boolB)
	<.main+5817 @052c18> : 0a 14 00 00                load.sp(+20)
	<.main+5821 @052c1c> : 20                         load.i8
	<.main+5822 @052c1d> : 0a 14 00 00                load.sp(+20)
	<.main+5826 @052c21> : 20                         load.i8
	<.main+5827 @052c22> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@052c23> - <@052c2f>): boolCne: bool := bool(boolA != boolB)
	<.main+5828 @052c23> : 0a 18 00 00                load.sp(+24)
	<.main+5832 @052c27> : 20                         load.i8
	<.main+5833 @052c28> : 0a 18 00 00                load.sp(+24)
	<.main+5837 @052c2c> : 20                         load.i8
	<.main+5838 @052c2d> : 57                         ceq.i32
	<.main+5839 @052c2e> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@052c2f> - <@052c3a>): boolClt: bool := bool(boolA < boolB)
	<.main+5840 @052c2f> : 0a 1c 00 00                load.sp(+28)
	<.main+5844 @052c33> : 20                         load.i8
	<.main+5845 @052c34> : 0a 1c 00 00                load.sp(+28)
	<.main+5849 @052c38> : 20                         load.i8
	<.main+5850 @052c39> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@052c3a> - <@052c46>): boolCle: bool := bool(boolA <= boolB)
	<.main+5851 @052c3a> : 0a 20 00 00                load.sp(+32)
	<.main+5855 @052c3e> : 20                         load.i8
	<.main+5856 @052c3f> : 0a 20 00 00                load.sp(+32)
	<.main+5860 @052c43> : 20                         load.i8
	<.main+5861 @052c44> : 59                         cgt.i32
	<.main+5862 @052c45> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@052c46> - <@052c51>): boolCgt: bool := bool(boolA > boolB)
	<.main+5863 @052c46> : 0a 24 00 00                load.sp(+36)
	<.main+5867 @052c4a> : 20                         load.i8
	<.main+5868 @052c4b> : 0a 24 00 00                load.sp(+36)
	<.main+5872 @052c4f> : 20                         load.i8
	<.main+5873 @052c50> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@052c51> - <@052c5d>): boolCge: bool := bool(boolA >= boolB)
	<.main+5874 @052c51> : 0a 28 00 00                load.sp(+40)
	<.main+5878 @052c55> : 20                         load.i8
	<.main+5879 @052c56> : 0a 28 00 00                load.sp(+40)
	<.main+5883 @052c5a> : 20                         load.i8
	<.main+5884 @052c5b> : 58                         clt.i32
	<.main+5885 @052c5c> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@052c5d> - <@052c62>): chrA: char := 'a'
	<.main+5886 @052c5d> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@052c62> - <@052c67>): chrB: char := 'b'
	<.main+5891 @052c62> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@052c67> - <@052c6c>): chrPls: char := char(+chrB)
	<.main+5896 @052c67> : 0a 00 00 00                load.sp(+0)
	<.main+5900 @052c6b> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@052c6c> - <@052c72>): chrNeg: char := char(-chrB)
	<.main+5901 @052c6c> : 0a 04 00 00                load.sp(+4)
	<.main+5905 @052c70> : 20                         load.i8
	<.main+5906 @052c71> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@052c72> - <@052c78>): chrCmt: char := char(~chrB)
	<.main+5907 @052c72> : 0a 08 00 00                load.sp(+8)
	<.main+5911 @052c76> : 20                         load.i8
	<.main+5912 @052c77> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@052c78> - <@052c83>): chrAdd: char := char(chrA + chrB)
	<.main+5913 @052c78> : 0a 10 00 00                load.sp(+16)
	<.main+5917 @052c7c> : 20                         load.i8
	<.main+5918 @052c7d> : 0a 10 00 00                load.sp(+16)
	<.main+5922 @052c81> : 20                         load.i8
	<.main+5923 @052c82> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@052c83> - <@052c8e>): chrSub: char := char(chrA - chrB)
	<.main+5924 @052c83> : 0a 14 00 00                load.sp(+20)
	<.main+5928 @052c87> : 20                         load.i8
	<.main+5929 @052c88> : 0a 14 00 00                load.sp(+20)
	<.main+5933 @052c8c> : 20                         load.i8
	<.main+5934 @052c8d> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@052c8e> - <@052c99>): chrMul: char := char(chrA * chrB)
	<.main+5935 @052c8e> : 0a 18 00 00                load.sp(+24)
	<.main+5939 @052c92> : 20                         load.i8
	<.main+5940 @052c93> : 0a 18 00 00                load.sp(+24)
	<.main+5944 @052c97> : 20                         load.i8
	<.main+5945 @052c98> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@052c99> - <@052ca4>): chrDiv: char := char(chrA / chrB)
	<.main+5946 @052c99> : 0a 1c 00 00                load.sp(+28)
	<.main+5950 @052c9d> : 20                         load.i8
	<.main+5951 @052c9e> : 0a 1c 00 00                load.sp(+28)
	<.main+5955 @052ca2> : 20                         load.i8
	<.main+5956 @052ca3> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@052ca4> - <@052caf>): chrMod: char := char(chrA % chrB)
	<.main+5957 @052ca4> : 0a 20 00 00                load.sp(+32)
	<.main+5961 @052ca8> : 20                         load.i8
	<.main+5962 @052ca9> : 0a 20 00 00                load.sp(+32)
	<.main+5966 @052cad> : 20                         load.i8
	<.main+5967 @052cae> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@052caf> - <@052cba>): chrAnd: char := char(chrA & chrB)
	<.main+5968 @052caf> : 0a 24 00 00                load.sp(+36)
	<.main+5972 @052cb3> : 20                         load.i8
	<.main+5973 @052cb4> : 0a 24 00 00                load.sp(+36)
	<.main+5977 @052cb8> : 20                         load.i8
	<.main+5978 @052cb9> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@052cba> - <@052cc5>): chrIor: char := char(chrA | chrB)
	<.main+5979 @052cba> : 0a 28 00 00                load.sp(+40)
	<.main+5983 @052cbe> : 20                         load.i8
	<.main+5984 @052cbf> : 0a 28 00 00                load.sp(+40)
	<.main+5988 @052cc3> : 20                         load.i8
	<.main+5989 @052cc4> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@052cc5> - <@052cd0>): chrXor: char := char(chrA ^ chrB)
	<.main+5990 @052cc5> : 0a 2c 00 00                load.sp(+44)
	<.main+5994 @052cc9> : 20                         load.i8
	<.main+5995 @052cca> : 0a 2c 00 00                load.sp(+44)
	<.main+5999 @052cce> : 20                         load.i8
	<.main+6000 @052ccf> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@052cd0> - <@052cd8>): chrShl: char := int32((chrA) << shift)
	<.main+6001 @052cd0> : 0a 30 00 00                load.sp(+48)
	<.main+6005 @052cd4> : 20                         load.i8
	<.main+6006 @052cd5> : 10 1a                      dup.x1 sp(26)
	<.main+6008 @052cd7> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@052cd8> - <@052ce0>): chrShr: char := int32((chrA) >> shift)
	<.main+6009 @052cd8> : 0a 34 00 00                load.sp(+52)
	<.main+6013 @052cdc> : 20                         load.i8
	<.main+6014 @052cdd> : 10 1b                      dup.x1 sp(27)
	<.main+6016 @052cdf> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@052ce0> - <@052ce7>): chrNot: bool := bool(!(chrB))
	<.main+6017 @052ce0> : 0a 34 00 00                load.sp(+52)
	<.main+6021 @052ce4> : 20                         load.i8
	<.main+6022 @052ce5> : 5a                         i32.2bool
	<.main+6023 @052ce6> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@052ce7> - <@052cf2>): chrCeq: bool := bool(chrA == chrB)
	<.main+6024 @052ce7> : 0a 3c 00 00                load.sp(+60)
	<.main+6028 @052ceb> : 20                         load.i8
	<.main+6029 @052cec> : 0a 3c 00 00                load.sp(+60)
	<.main+6033 @052cf0> : 20                         load.i8
	<.main+6034 @052cf1> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@052cf2> - <@052cfe>): chrCne: bool := bool(chrA != chrB)
	<.main+6035 @052cf2> : 0a 40 00 00                load.sp(+64)
	<.main+6039 @052cf6> : 20                         load.i8
	<.main+6040 @052cf7> : 0a 40 00 00                load.sp(+64)
	<.main+6044 @052cfb> : 20                         load.i8
	<.main+6045 @052cfc> : 57                         ceq.i32
	<.main+6046 @052cfd> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@052cfe> - <@052d09>): chrClt: bool := bool(chrA < chrB)
	<.main+6047 @052cfe> : 0a 44 00 00                load.sp(+68)
	<.main+6051 @052d02> : 20                         load.i8
	<.main+6052 @052d03> : 0a 44 00 00                load.sp(+68)
	<.main+6056 @052d07> : 20                         load.i8
	<.main+6057 @052d08> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@052d09> - <@052d15>): chrCle: bool := bool(chrA <= chrB)
	<.main+6058 @052d09> : 0a 48 00 00                load.sp(+72)
	<.main+6062 @052d0d> : 20                         load.i8
	<.main+6063 @052d0e> : 0a 48 00 00                load.sp(+72)
	<.main+6067 @052d12> : 20                         load.i8
	<.main+6068 @052d13> : 59                         cgt.i32
	<.main+6069 @052d14> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@052d15> - <@052d20>): chrCgt: bool := bool(chrA > chrB)
	<.main+6070 @052d15> : 0a 4c 00 00                load.sp(+76)
	<.main+6074 @052d19> : 20                         load.i8
	<.main+6075 @052d1a> : 0a 4c 00 00                load.sp(+76)
	<.main+6079 @052d1e> : 20                         load.i8
	<.main+6080 @052d1f> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@052d20> - <@052d2c>): chrCge: bool := bool(chrA >= chrB)
	<.main+6081 @052d20> : 0a 50 00 00                load.sp(+80)
	<.main+6085 @052d24> : 20                         load.i8
	<.main+6086 @052d25> : 0a 50 00 00                load.sp(+80)
	<.main+6090 @052d29> : 20                         load.i8
	<.main+6091 @052d2a> : 58                         clt.i32
	<.main+6092 @052d2b> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@052d2c> - <@052d31>): i8A: int8 := a
	<.main+6093 @052d2c> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@052d31> - <@052d36>): i8B: int8 := b
	<.main+6098 @052d31> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@052d36> - <@052d3b>): i8Pls: int8 := int8(+i8B)
	<.main+6103 @052d36> : 0a 00 00 00                load.sp(+0)
	<.main+6107 @052d3a> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@052d3b> - <@052d41>): i8Neg: int8 := int8(-i8B)
	<.main+6108 @052d3b> : 0a 04 00 00                load.sp(+4)
	<.main+6112 @052d3f> : 20                         load.i8
	<.main+6113 @052d40> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@052d41> - <@052d47>): i8Cmt: int8 := int8(~i8B)
	<.main+6114 @052d41> : 0a 08 00 00                load.sp(+8)
	<.main+6118 @052d45> : 20                         load.i8
	<.main+6119 @052d46> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@052d47> - <@052d52>): i8Add: int8 := int8(i8A + i8B)
	<.main+6120 @052d47> : 0a 10 00 00                load.sp(+16)
	<.main+6124 @052d4b> : 20                         load.i8
	<.main+6125 @052d4c> : 0a 10 00 00                load.sp(+16)
	<.main+6129 @052d50> : 20                         load.i8
	<.main+6130 @052d51> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@052d52> - <@052d5d>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6131 @052d52> : 0a 14 00 00                load.sp(+20)
	<.main+6135 @052d56> : 20                         load.i8
	<.main+6136 @052d57> : 0a 14 00 00                load.sp(+20)
	<.main+6140 @052d5b> : 20                         load.i8
	<.main+6141 @052d5c> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@052d5d> - <@052d68>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6142 @052d5d> : 0a 18 00 00                load.sp(+24)
	<.main+6146 @052d61> : 20                         load.i8
	<.main+6147 @052d62> : 0a 18 00 00                load.sp(+24)
	<.main+6151 @052d66> : 20                         load.i8
	<.main+6152 @052d67> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@052d68> - <@052d73>): i8Div: int8 := int8(i8A / i8B)
	<.main+6153 @052d68> : 0a 1c 00 00                load.sp(+28)
	<.main+6157 @052d6c> : 20                         load.i8
	<.main+6158 @052d6d> : 0a 1c 00 00                load.sp(+28)
	<.main+6162 @052d71> : 20                         load.i8
	<.main+6163 @052d72> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@052d73> - <@052d7e>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6164 @052d73> : 0a 20 00 00                load.sp(+32)
	<.main+6168 @052d77> : 20                         load.i8
	<.main+6169 @052d78> : 0a 20 00 00                load.sp(+32)
	<.main+6173 @052d7c> : 20                         load.i8
	<.main+6174 @052d7d> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@052d7e> - <@052d89>): i8And: int8 := int8(i8A & i8B)
	<.main+6175 @052d7e> : 0a 24 00 00                load.sp(+36)
	<.main+6179 @052d82> : 20                         load.i8
	<.main+6180 @052d83> : 0a 24 00 00                load.sp(+36)
	<.main+6184 @052d87> : 20                         load.i8
	<.main+6185 @052d88> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@052d89> - <@052d94>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6186 @052d89> : 0a 28 00 00                load.sp(+40)
	<.main+6190 @052d8d> : 20                         load.i8
	<.main+6191 @052d8e> : 0a 28 00 00                load.sp(+40)
	<.main+6195 @052d92> : 20                         load.i8
	<.main+6196 @052d93> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@052d94> - <@052d9f>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6197 @052d94> : 0a 2c 00 00                load.sp(+44)
	<.main+6201 @052d98> : 20                         load.i8
	<.main+6202 @052d99> : 0a 2c 00 00                load.sp(+44)
	<.main+6206 @052d9d> : 20                         load.i8
	<.main+6207 @052d9e> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@052d9f> - <@052da7>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6208 @052d9f> : 0a 30 00 00                load.sp(+48)
	<.main+6212 @052da3> : 20                         load.i8
	<.main+6213 @052da4> : 10 30                      dup.x1 sp(48)
	<.main+6215 @052da6> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@052da7> - <@052daf>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6216 @052da7> : 0a 34 00 00                load.sp(+52)
	<.main+6220 @052dab> : 20                         load.i8
	<.main+6221 @052dac> : 10 31                      dup.x1 sp(49)
	<.main+6223 @052dae> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@052daf> - <@052db6>): i8Not: bool := bool(!(i8B))
	<.main+6224 @052daf> : 0a 34 00 00                load.sp(+52)
	<.main+6228 @052db3> : 20                         load.i8
	<.main+6229 @052db4> : 5a                         i32.2bool
	<.main+6230 @052db5> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@052db6> - <@052dc1>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6231 @052db6> : 0a 3c 00 00                load.sp(+60)
	<.main+6235 @052dba> : 20                         load.i8
	<.main+6236 @052dbb> : 0a 3c 00 00                load.sp(+60)
	<.main+6240 @052dbf> : 20                         load.i8
	<.main+6241 @052dc0> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@052dc1> - <@052dcd>): i8Cne: bool := bool(i8A != i8B)
	<.main+6242 @052dc1> : 0a 40 00 00                load.sp(+64)
	<.main+6246 @052dc5> : 20                         load.i8
	<.main+6247 @052dc6> : 0a 40 00 00                load.sp(+64)
	<.main+6251 @052dca> : 20                         load.i8
	<.main+6252 @052dcb> : 57                         ceq.i32
	<.main+6253 @052dcc> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@052dcd> - <@052dd8>): i8Clt: bool := bool(i8A < i8B)
	<.main+6254 @052dcd> : 0a 44 00 00                load.sp(+68)
	<.main+6258 @052dd1> : 20                         load.i8
	<.main+6259 @052dd2> : 0a 44 00 00                load.sp(+68)
	<.main+6263 @052dd6> : 20                         load.i8
	<.main+6264 @052dd7> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@052dd8> - <@052de4>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6265 @052dd8> : 0a 48 00 00                load.sp(+72)
	<.main+6269 @052ddc> : 20                         load.i8
	<.main+6270 @052ddd> : 0a 48 00 00                load.sp(+72)
	<.main+6274 @052de1> : 20                         load.i8
	<.main+6275 @052de2> : 59                         cgt.i32
	<.main+6276 @052de3> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@052de4> - <@052def>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6277 @052de4> : 0a 4c 00 00                load.sp(+76)
	<.main+6281 @052de8> : 20                         load.i8
	<.main+6282 @052de9> : 0a 4c 00 00                load.sp(+76)
	<.main+6286 @052ded> : 20                         load.i8
	<.main+6287 @052dee> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@052def> - <@052dfb>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6288 @052def> : 0a 50 00 00                load.sp(+80)
	<.main+6292 @052df3> : 20                         load.i8
	<.main+6293 @052df4> : 0a 50 00 00                load.sp(+80)
	<.main+6297 @052df8> : 20                         load.i8
	<.main+6298 @052df9> : 58                         clt.i32
	<.main+6299 @052dfa> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@052dfb> - <@052e00>): u8A: uint8 := a
	<.main+6300 @052dfb> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@052e00> - <@052e05>): u8B: uint8 := b
	<.main+6305 @052e00> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@052e05> - <@052e0a>): u8Pls: uint8 := uint8(+u8B)
	<.main+6310 @052e05> : 0a 00 00 00                load.sp(+0)
	<.main+6314 @052e09> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@052e0a> - <@052e10>): u8Neg: uint8 := uint8(-u8B)
	<.main+6315 @052e0a> : 0a 04 00 00                load.sp(+4)
	<.main+6319 @052e0e> : 20                         load.i8
	<.main+6320 @052e0f> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@052e10> - <@052e16>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6321 @052e10> : 0a 08 00 00                load.sp(+8)
	<.main+6325 @052e14> : 20                         load.i8
	<.main+6326 @052e15> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@052e16> - <@052e21>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6327 @052e16> : 0a 10 00 00                load.sp(+16)
	<.main+6331 @052e1a> : 20                         load.i8
	<.main+6332 @052e1b> : 0a 10 00 00                load.sp(+16)
	<.main+6336 @052e1f> : 20                         load.i8
	<.main+6337 @052e20> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@052e21> - <@052e2c>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6338 @052e21> : 0a 14 00 00                load.sp(+20)
	<.main+6342 @052e25> : 20                         load.i8
	<.main+6343 @052e26> : 0a 14 00 00                load.sp(+20)
	<.main+6347 @052e2a> : 20                         load.i8
	<.main+6348 @052e2b> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@052e2c> - <@052e37>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6349 @052e2c> : 0a 18 00 00                load.sp(+24)
	<.main+6353 @052e30> : 20                         load.i8
	<.main+6354 @052e31> : 0a 18 00 00                load.sp(+24)
	<.main+6358 @052e35> : 20                         load.i8
	<.main+6359 @052e36> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@052e37> - <@052e42>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6360 @052e37> : 0a 1c 00 00                load.sp(+28)
	<.main+6364 @052e3b> : 20                         load.i8
	<.main+6365 @052e3c> : 0a 1c 00 00                load.sp(+28)
	<.main+6369 @052e40> : 20                         load.i8
	<.main+6370 @052e41> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@052e42> - <@052e4d>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6371 @052e42> : 0a 20 00 00                load.sp(+32)
	<.main+6375 @052e46> : 20                         load.i8
	<.main+6376 @052e47> : 0a 20 00 00                load.sp(+32)
	<.main+6380 @052e4b> : 20                         load.i8
	<.main+6381 @052e4c> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@052e4d> - <@052e58>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6382 @052e4d> : 0a 24 00 00                load.sp(+36)
	<.main+6386 @052e51> : 20                         load.i8
	<.main+6387 @052e52> : 0a 24 00 00                load.sp(+36)
	<.main+6391 @052e56> : 20                         load.i8
	<.main+6392 @052e57> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@052e58> - <@052e63>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6393 @052e58> : 0a 28 00 00                load.sp(+40)
	<.main+6397 @052e5c> : 20                         load.i8
	<.main+6398 @052e5d> : 0a 28 00 00                load.sp(+40)
	<.main+6402 @052e61> : 20                         load.i8
	<.main+6403 @052e62> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@052e63> - <@052e6e>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6404 @052e63> : 0a 2c 00 00                load.sp(+44)
	<.main+6408 @052e67> : 20                         load.i8
	<.main+6409 @052e68> : 0a 2c 00 00                load.sp(+44)
	<.main+6413 @052e6c> : 20                         load.i8
	<.main+6414 @052e6d> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@052e6e> - <@052e76>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6415 @052e6e> : 0a 30 00 00                load.sp(+48)
	<.main+6419 @052e72> : 20                         load.i8
	<.main+6420 @052e73> : 10 46                      dup.x1 sp(70)
	<.main+6422 @052e75> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@052e76> - <@052e7e>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6423 @052e76> : 0a 34 00 00                load.sp(+52)
	<.main+6427 @052e7a> : 20                         load.i8
	<.main+6428 @052e7b> : 10 47                      dup.x1 sp(71)
	<.main+6430 @052e7d> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@052e7e> - <@052e85>): u8Not: bool := bool(!(u8B))
	<.main+6431 @052e7e> : 0a 34 00 00                load.sp(+52)
	<.main+6435 @052e82> : 20                         load.i8
	<.main+6436 @052e83> : 5a                         i32.2bool
	<.main+6437 @052e84> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@052e85> - <@052e90>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6438 @052e85> : 0a 3c 00 00                load.sp(+60)
	<.main+6442 @052e89> : 20                         load.i8
	<.main+6443 @052e8a> : 0a 3c 00 00                load.sp(+60)
	<.main+6447 @052e8e> : 20                         load.i8
	<.main+6448 @052e8f> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@052e90> - <@052e9c>): u8Cne: bool := bool(u8A != u8B)
	<.main+6449 @052e90> : 0a 40 00 00                load.sp(+64)
	<.main+6453 @052e94> : 20                         load.i8
	<.main+6454 @052e95> : 0a 40 00 00                load.sp(+64)
	<.main+6458 @052e99> : 20                         load.i8
	<.main+6459 @052e9a> : 57                         ceq.i32
	<.main+6460 @052e9b> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@052e9c> - <@052ea7>): u8Clt: bool := bool(u8A < u8B)
	<.main+6461 @052e9c> : 0a 44 00 00                load.sp(+68)
	<.main+6465 @052ea0> : 20                         load.i8
	<.main+6466 @052ea1> : 0a 44 00 00                load.sp(+68)
	<.main+6470 @052ea5> : 20                         load.i8
	<.main+6471 @052ea6> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@052ea7> - <@052eb3>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6472 @052ea7> : 0a 48 00 00                load.sp(+72)
	<.main+6476 @052eab> : 20                         load.i8
	<.main+6477 @052eac> : 0a 48 00 00                load.sp(+72)
	<.main+6481 @052eb0> : 20                         load.i8
	<.main+6482 @052eb1> : 39                         cgt.u32
	<.main+6483 @052eb2> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@052eb3> - <@052ebe>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6484 @052eb3> : 0a 4c 00 00                load.sp(+76)
	<.main+6488 @052eb7> : 20                         load.i8
	<.main+6489 @052eb8> : 0a 4c 00 00                load.sp(+76)
	<.main+6493 @052ebc> : 20                         load.i8
	<.main+6494 @052ebd> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@052ebe> - <@052eca>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6495 @052ebe> : 0a 50 00 00                load.sp(+80)
	<.main+6499 @052ec2> : 20                         load.i8
	<.main+6500 @052ec3> : 0a 50 00 00                load.sp(+80)
	<.main+6504 @052ec7> : 20                         load.i8
	<.main+6505 @052ec8> : 38                         clt.u32
	<.main+6506 @052ec9> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@052eca> - <@052ecf>): i16A: int16 := a
	<.main+6507 @052eca> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@052ecf> - <@052ed4>): i16B: int16 := b
	<.main+6512 @052ecf> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@052ed4> - <@052ed9>): i16Pls: int16 := int16(+i16B)
	<.main+6517 @052ed4> : 0a 00 00 00                load.sp(+0)
	<.main+6521 @052ed8> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@052ed9> - <@052edf>): i16Neg: int16 := int16(-i16B)
	<.main+6522 @052ed9> : 0a 04 00 00                load.sp(+4)
	<.main+6526 @052edd> : 21                         load.i16
	<.main+6527 @052ede> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@052edf> - <@052ee5>): i16Cmt: int16 := int16(~i16B)
	<.main+6528 @052edf> : 0a 08 00 00                load.sp(+8)
	<.main+6532 @052ee3> : 21                         load.i16
	<.main+6533 @052ee4> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@052ee5> - <@052ef0>): i16Add: int16 := int16(i16A + i16B)
	<.main+6534 @052ee5> : 0a 10 00 00                load.sp(+16)
	<.main+6538 @052ee9> : 21                         load.i16
	<.main+6539 @052eea> : 0a 10 00 00                load.sp(+16)
	<.main+6543 @052eee> : 21                         load.i16
	<.main+6544 @052eef> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@052ef0> - <@052efb>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6545 @052ef0> : 0a 14 00 00                load.sp(+20)
	<.main+6549 @052ef4> : 21                         load.i16
	<.main+6550 @052ef5> : 0a 14 00 00                load.sp(+20)
	<.main+6554 @052ef9> : 21                         load.i16
	<.main+6555 @052efa> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@052efb> - <@052f06>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6556 @052efb> : 0a 18 00 00                load.sp(+24)
	<.main+6560 @052eff> : 21                         load.i16
	<.main+6561 @052f00> : 0a 18 00 00                load.sp(+24)
	<.main+6565 @052f04> : 21                         load.i16
	<.main+6566 @052f05> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@052f06> - <@052f11>): i16Div: int16 := int16(i16A / i16B)
	<.main+6567 @052f06> : 0a 1c 00 00                load.sp(+28)
	<.main+6571 @052f0a> : 21                         load.i16
	<.main+6572 @052f0b> : 0a 1c 00 00                load.sp(+28)
	<.main+6576 @052f0f> : 21                         load.i16
	<.main+6577 @052f10> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@052f11> - <@052f1c>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6578 @052f11> : 0a 20 00 00                load.sp(+32)
	<.main+6582 @052f15> : 21                         load.i16
	<.main+6583 @052f16> : 0a 20 00 00                load.sp(+32)
	<.main+6587 @052f1a> : 21                         load.i16
	<.main+6588 @052f1b> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@052f1c> - <@052f27>): i16And: int16 := int16(i16A & i16B)
	<.main+6589 @052f1c> : 0a 24 00 00                load.sp(+36)
	<.main+6593 @052f20> : 21                         load.i16
	<.main+6594 @052f21> : 0a 24 00 00                load.sp(+36)
	<.main+6598 @052f25> : 21                         load.i16
	<.main+6599 @052f26> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@052f27> - <@052f32>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6600 @052f27> : 0a 28 00 00                load.sp(+40)
	<.main+6604 @052f2b> : 21                         load.i16
	<.main+6605 @052f2c> : 0a 28 00 00                load.sp(+40)
	<.main+6609 @052f30> : 21                         load.i16
	<.main+6610 @052f31> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@052f32> - <@052f3d>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6611 @052f32> : 0a 2c 00 00                load.sp(+44)
	<.main+6615 @052f36> : 21                         load.i16
	<.main+6616 @052f37> : 0a 2c 00 00                load.sp(+44)
	<.main+6620 @052f3b> : 21                         load.i16
	<.main+6621 @052f3c> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@052f3d> - <@052f45>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6622 @052f3d> : 0a 30 00 00                load.sp(+48)
	<.main+6626 @052f41> : 21                         load.i16
	<.main+6627 @052f42> : 10 5c                      dup.x1 sp(92)
	<.main+6629 @052f44> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@052f45> - <@052f4d>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6630 @052f45> : 0a 34 00 00                load.sp(+52)
	<.main+6634 @052f49> : 21                         load.i16
	<.main+6635 @052f4a> : 10 5d                      dup.x1 sp(93)
	<.main+6637 @052f4c> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@052f4d> - <@052f54>): i16Not: bool := bool(!(i16B))
	<.main+6638 @052f4d> : 0a 34 00 00                load.sp(+52)
	<.main+6642 @052f51> : 21                         load.i16
	<.main+6643 @052f52> : 5a                         i32.2bool
	<.main+6644 @052f53> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@052f54> - <@052f5f>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6645 @052f54> : 0a 3c 00 00                load.sp(+60)
	<.main+6649 @052f58> : 21                         load.i16
	<.main+6650 @052f59> : 0a 3c 00 00                load.sp(+60)
	<.main+6654 @052f5d> : 21                         load.i16
	<.main+6655 @052f5e> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@052f5f> - <@052f6b>): i16Cne: bool := bool(i16A != i16B)
	<.main+6656 @052f5f> : 0a 40 00 00                load.sp(+64)
	<.main+6660 @052f63> : 21                         load.i16
	<.main+6661 @052f64> : 0a 40 00 00                load.sp(+64)
	<.main+6665 @052f68> : 21                         load.i16
	<.main+6666 @052f69> : 57                         ceq.i32
	<.main+6667 @052f6a> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@052f6b> - <@052f76>): i16Clt: bool := bool(i16A < i16B)
	<.main+6668 @052f6b> : 0a 44 00 00                load.sp(+68)
	<.main+6672 @052f6f> : 21                         load.i16
	<.main+6673 @052f70> : 0a 44 00 00                load.sp(+68)
	<.main+6677 @052f74> : 21                         load.i16
	<.main+6678 @052f75> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@052f76> - <@052f82>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6679 @052f76> : 0a 48 00 00                load.sp(+72)
	<.main+6683 @052f7a> : 21                         load.i16
	<.main+6684 @052f7b> : 0a 48 00 00                load.sp(+72)
	<.main+6688 @052f7f> : 21                         load.i16
	<.main+6689 @052f80> : 59                         cgt.i32
	<.main+6690 @052f81> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@052f82> - <@052f8d>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6691 @052f82> : 0a 4c 00 00                load.sp(+76)
	<.main+6695 @052f86> : 21                         load.i16
	<.main+6696 @052f87> : 0a 4c 00 00                load.sp(+76)
	<.main+6700 @052f8b> : 21                         load.i16
	<.main+6701 @052f8c> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@052f8d> - <@052f99>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6702 @052f8d> : 0a 50 00 00                load.sp(+80)
	<.main+6706 @052f91> : 21                         load.i16
	<.main+6707 @052f92> : 0a 50 00 00                load.sp(+80)
	<.main+6711 @052f96> : 21                         load.i16
	<.main+6712 @052f97> : 58                         clt.i32
	<.main+6713 @052f98> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@052f99> - <@052f9e>): u16A: uint16 := a
	<.main+6714 @052f99> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@052f9e> - <@052fa3>): u16B: uint16 := b
	<.main+6719 @052f9e> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@052fa3> - <@052fa8>): u16Pls: uint16 := uint16(+u16B)
	<.main+6724 @052fa3> : 0a 00 00 00                load.sp(+0)
	<.main+6728 @052fa7> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@052fa8> - <@052fae>): u16Neg: uint16 := uint16(-u16B)
	<.main+6729 @052fa8> : 0a 04 00 00                load.sp(+4)
	<.main+6733 @052fac> : 21                         load.i16
	<.main+6734 @052fad> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@052fae> - <@052fb4>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6735 @052fae> : 0a 08 00 00                load.sp(+8)
	<.main+6739 @052fb2> : 21                         load.i16
	<.main+6740 @052fb3> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@052fb4> - <@052fbf>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6741 @052fb4> : 0a 10 00 00                load.sp(+16)
	<.main+6745 @052fb8> : 21                         load.i16
	<.main+6746 @052fb9> : 0a 10 00 00                load.sp(+16)
	<.main+6750 @052fbd> : 21                         load.i16
	<.main+6751 @052fbe> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@052fbf> - <@052fca>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6752 @052fbf> : 0a 14 00 00                load.sp(+20)
	<.main+6756 @052fc3> : 21                         load.i16
	<.main+6757 @052fc4> : 0a 14 00 00                load.sp(+20)
	<.main+6761 @052fc8> : 21                         load.i16
	<.main+6762 @052fc9> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@052fca> - <@052fd5>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6763 @052fca> : 0a 18 00 00                load.sp(+24)
	<.main+6767 @052fce> : 21                         load.i16
	<.main+6768 @052fcf> : 0a 18 00 00                load.sp(+24)
	<.main+6772 @052fd3> : 21                         load.i16
	<.main+6773 @052fd4> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@052fd5> - <@052fe0>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6774 @052fd5> : 0a 1c 00 00                load.sp(+28)
	<.main+6778 @052fd9> : 21                         load.i16
	<.main+6779 @052fda> : 0a 1c 00 00                load.sp(+28)
	<.main+6783 @052fde> : 21                         load.i16
	<.main+6784 @052fdf> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@052fe0> - <@052feb>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6785 @052fe0> : 0a 20 00 00                load.sp(+32)
	<.main+6789 @052fe4> : 21                         load.i16
	<.main+6790 @052fe5> : 0a 20 00 00                load.sp(+32)
	<.main+6794 @052fe9> : 21                         load.i16
	<.main+6795 @052fea> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@052feb> - <@052ff6>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6796 @052feb> : 0a 24 00 00                load.sp(+36)
	<.main+6800 @052fef> : 21                         load.i16
	<.main+6801 @052ff0> : 0a 24 00 00                load.sp(+36)
	<.main+6805 @052ff4> : 21                         load.i16
	<.main+6806 @052ff5> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@052ff6> - <@053001>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6807 @052ff6> : 0a 28 00 00                load.sp(+40)
	<.main+6811 @052ffa> : 21                         load.i16
	<.main+6812 @052ffb> : 0a 28 00 00                load.sp(+40)
	<.main+6816 @052fff> : 21                         load.i16
	<.main+6817 @053000> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@053001> - <@05300c>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6818 @053001> : 0a 2c 00 00                load.sp(+44)
	<.main+6822 @053005> : 21                         load.i16
	<.main+6823 @053006> : 0a 2c 00 00                load.sp(+44)
	<.main+6827 @05300a> : 21                         load.i16
	<.main+6828 @05300b> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@05300c> - <@053014>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6829 @05300c> : 0a 30 00 00                load.sp(+48)
	<.main+6833 @053010> : 21                         load.i16
	<.main+6834 @053011> : 10 72                      dup.x1 sp(114)
	<.main+6836 @053013> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@053014> - <@05301c>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6837 @053014> : 0a 34 00 00                load.sp(+52)
	<.main+6841 @053018> : 21                         load.i16
	<.main+6842 @053019> : 10 73                      dup.x1 sp(115)
	<.main+6844 @05301b> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@05301c> - <@053023>): u16Not: bool := bool(!(u16B))
	<.main+6845 @05301c> : 0a 34 00 00                load.sp(+52)
	<.main+6849 @053020> : 21                         load.i16
	<.main+6850 @053021> : 5a                         i32.2bool
	<.main+6851 @053022> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@053023> - <@05302e>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6852 @053023> : 0a 3c 00 00                load.sp(+60)
	<.main+6856 @053027> : 21                         load.i16
	<.main+6857 @053028> : 0a 3c 00 00                load.sp(+60)
	<.main+6861 @05302c> : 21                         load.i16
	<.main+6862 @05302d> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@05302e> - <@05303a>): u16Cne: bool := bool(u16A != u16B)
	<.main+6863 @05302e> : 0a 40 00 00                load.sp(+64)
	<.main+6867 @053032> : 21                         load.i16
	<.main+6868 @053033> : 0a 40 00 00                load.sp(+64)
	<.main+6872 @053037> : 21                         load.i16
	<.main+6873 @053038> : 57                         ceq.i32
	<.main+6874 @053039> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@05303a> - <@053045>): u16Clt: bool := bool(u16A < u16B)
	<.main+6875 @05303a> : 0a 44 00 00                load.sp(+68)
	<.main+6879 @05303e> : 21                         load.i16
	<.main+6880 @05303f> : 0a 44 00 00                load.sp(+68)
	<.main+6884 @053043> : 21                         load.i16
	<.main+6885 @053044> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@053045> - <@053051>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6886 @053045> : 0a 48 00 00                load.sp(+72)
	<.main+6890 @053049> : 21                         load.i16
	<.main+6891 @05304a> : 0a 48 00 00                load.sp(+72)
	<.main+6895 @05304e> : 21                         load.i16
	<.main+6896 @05304f> : 39                         cgt.u32
	<.main+6897 @053050> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@053051> - <@05305c>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6898 @053051> : 0a 4c 00 00                load.sp(+76)
	<.main+6902 @053055> : 21                         load.i16
	<.main+6903 @053056> : 0a 4c 00 00                load.sp(+76)
	<.main+6907 @05305a> : 21                         load.i16
	<.main+6908 @05305b> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@05305c> - <@053068>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6909 @05305c> : 0a 50 00 00                load.sp(+80)
	<.main+6913 @053060> : 21                         load.i16
	<.main+6914 @053061> : 0a 50 00 00                load.sp(+80)
	<.main+6918 @053065> : 21                         load.i16
	<.main+6919 @053066> : 38                         clt.u32
	<.main+6920 @053067> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@053068> - <@05306d>): i32A: int32 := a
	<.main+6921 @053068> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@05306d> - <@053072>): i32B: int32 := b
	<.main+6926 @05306d> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@053072> - <@053074>): i32Pls: int32 := int32(+i32B)
	<.main+6931 @053072> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@053074> - <@053077>): i32Neg: int32 := int32(-i32B)
	<.main+6933 @053074> : 10 01                      dup.x1 sp(1)
	<.main+6935 @053076> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@053077> - <@05307a>): i32Cmt: int32 := int32(~i32B)
	<.main+6936 @053077> : 10 02                      dup.x1 sp(2)
	<.main+6938 @053079> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@05307a> - <@05307f>): i32Add: int32 := int32(i32A + i32B)
	<.main+6939 @05307a> : 10 04                      dup.x1 sp(4)
	<.main+6941 @05307c> : 10 04                      dup.x1 sp(4)
	<.main+6943 @05307e> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@05307f> - <@053084>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6944 @05307f> : 10 05                      dup.x1 sp(5)
	<.main+6946 @053081> : 10 05                      dup.x1 sp(5)
	<.main+6948 @053083> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@053084> - <@053089>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6949 @053084> : 10 06                      dup.x1 sp(6)
	<.main+6951 @053086> : 10 06                      dup.x1 sp(6)
	<.main+6953 @053088> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@053089> - <@05308e>): i32Div: int32 := int32(i32A / i32B)
	<.main+6954 @053089> : 10 07                      dup.x1 sp(7)
	<.main+6956 @05308b> : 10 07                      dup.x1 sp(7)
	<.main+6958 @05308d> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@05308e> - <@053093>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6959 @05308e> : 10 08                      dup.x1 sp(8)
	<.main+6961 @053090> : 10 08                      dup.x1 sp(8)
	<.main+6963 @053092> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@053093> - <@053098>): i32And: int32 := int32(i32A & i32B)
	<.main+6964 @053093> : 10 09                      dup.x1 sp(9)
	<.main+6966 @053095> : 10 09                      dup.x1 sp(9)
	<.main+6968 @053097> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@053098> - <@05309d>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6969 @053098> : 10 0a                      dup.x1 sp(10)
	<.main+6971 @05309a> : 10 0a                      dup.x1 sp(10)
	<.main+6973 @05309c> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@05309d> - <@0530a2>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6974 @05309d> : 10 0b                      dup.x1 sp(11)
	<.main+6976 @05309f> : 10 0b                      dup.x1 sp(11)
	<.main+6978 @0530a1> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@0530a2> - <@0530a7>): i32Shl: int32 := int32(i32A << shift)
	<.main+6979 @0530a2> : 10 0c                      dup.x1 sp(12)
	<.main+6981 @0530a4> : 10 88                      dup.x1 sp(136)
	<.main+6983 @0530a6> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@0530a7> - <@0530ac>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6984 @0530a7> : 10 0d                      dup.x1 sp(13)
	<.main+6986 @0530a9> : 10 89                      dup.x1 sp(137)
	<.main+6988 @0530ab> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@0530ac> - <@0530b0>): i32Not: bool := bool(!(i32B))
	<.main+6989 @0530ac> : 10 0d                      dup.x1 sp(13)
	<.main+6991 @0530ae> : 5a                         i32.2bool
	<.main+6992 @0530af> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@0530b0> - <@0530b5>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6993 @0530b0> : 10 0f                      dup.x1 sp(15)
	<.main+6995 @0530b2> : 10 0f                      dup.x1 sp(15)
	<.main+6997 @0530b4> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@0530b5> - <@0530bb>): i32Cne: bool := bool(i32A != i32B)
	<.main+6998 @0530b5> : 10 10                      dup.x1 sp(16)
	<.main+7000 @0530b7> : 10 10                      dup.x1 sp(16)
	<.main+7002 @0530b9> : 57                         ceq.i32
	<.main+7003 @0530ba> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@0530bb> - <@0530c0>): i32Clt: bool := bool(i32A < i32B)
	<.main+7004 @0530bb> : 10 11                      dup.x1 sp(17)
	<.main+7006 @0530bd> : 10 11                      dup.x1 sp(17)
	<.main+7008 @0530bf> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@0530c0> - <@0530c6>): i32Cle: bool := bool(i32A <= i32B)
	<.main+7009 @0530c0> : 10 12                      dup.x1 sp(18)
	<.main+7011 @0530c2> : 10 12                      dup.x1 sp(18)
	<.main+7013 @0530c4> : 59                         cgt.i32
	<.main+7014 @0530c5> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@0530c6> - <@0530cb>): i32Cgt: bool := bool(i32A > i32B)
	<.main+7015 @0530c6> : 10 13                      dup.x1 sp(19)
	<.main+7017 @0530c8> : 10 13                      dup.x1 sp(19)
	<.main+7019 @0530ca> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@0530cb> - <@0530d1>): i32Cge: bool := bool(i32A >= i32B)
	<.main+7020 @0530cb> : 10 14                      dup.x1 sp(20)
	<.main+7022 @0530cd> : 10 14                      dup.x1 sp(20)
	<.main+7024 @0530cf> : 58                         clt.i32
	<.main+7025 @0530d0> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@0530d1> - <@0530d6>): u32A: uint32 := a
	<.main+7026 @0530d1> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@0530d6> - <@0530db>): u32B: uint32 := b
	<.main+7031 @0530d6> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@0530db> - <@0530dd>): u32Pls: uint32 := uint32(+u32B)
	<.main+7036 @0530db> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@0530dd> - <@0530e0>): u32Neg: uint32 := uint32(-u32B)
	<.main+7038 @0530dd> : 10 01                      dup.x1 sp(1)
	<.main+7040 @0530df> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@0530e0> - <@0530e3>): u32Cmt: uint32 := uint32(~u32B)
	<.main+7041 @0530e0> : 10 02                      dup.x1 sp(2)
	<.main+7043 @0530e2> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@0530e3> - <@0530e8>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+7044 @0530e3> : 10 04                      dup.x1 sp(4)
	<.main+7046 @0530e5> : 10 04                      dup.x1 sp(4)
	<.main+7048 @0530e7> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@0530e8> - <@0530ed>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7049 @0530e8> : 10 05                      dup.x1 sp(5)
	<.main+7051 @0530ea> : 10 05                      dup.x1 sp(5)
	<.main+7053 @0530ec> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@0530ed> - <@0530f2>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7054 @0530ed> : 10 06                      dup.x1 sp(6)
	<.main+7056 @0530ef> : 10 06                      dup.x1 sp(6)
	<.main+7058 @0530f1> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@0530f2> - <@0530f7>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7059 @0530f2> : 10 07                      dup.x1 sp(7)
	<.main+7061 @0530f4> : 10 07                      dup.x1 sp(7)
	<.main+7063 @0530f6> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@0530f7> - <@0530fc>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7064 @0530f7> : 10 08                      dup.x1 sp(8)
	<.main+7066 @0530f9> : 10 08                      dup.x1 sp(8)
	<.main+7068 @0530fb> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@0530fc> - <@053101>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7069 @0530fc> : 10 09                      dup.x1 sp(9)
	<.main+7071 @0530fe> : 10 09                      dup.x1 sp(9)
	<.main+7073 @053100> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@053101> - <@053106>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7074 @053101> : 10 0a                      dup.x1 sp(10)
	<.main+7076 @053103> : 10 0a                      dup.x1 sp(10)
	<.main+7078 @053105> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@053106> - <@05310b>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7079 @053106> : 10 0b                      dup.x1 sp(11)
	<.main+7081 @053108> : 10 0b                      dup.x1 sp(11)
	<.main+7083 @05310a> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@05310b> - <@053110>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7084 @05310b> : 10 0c                      dup.x1 sp(12)
	<.main+7086 @05310d> : 10 9e                      dup.x1 sp(158)
	<.main+7088 @05310f> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@053110> - <@053115>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7089 @053110> : 10 0d                      dup.x1 sp(13)
	<.main+7091 @053112> : 10 9f                      dup.x1 sp(159)
	<.main+7093 @053114> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@053115> - <@053119>): u32Not: bool := bool(!(u32B))
	<.main+7094 @053115> : 10 0d                      dup.x1 sp(13)
	<.main+7096 @053117> : 5a                         i32.2bool
	<.main+7097 @053118> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@053119> - <@05311e>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7098 @053119> : 10 0f                      dup.x1 sp(15)
	<.main+7100 @05311b> : 10 0f                      dup.x1 sp(15)
	<.main+7102 @05311d> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@05311e> - <@053124>): u32Cne: bool := bool(u32A != u32B)
	<.main+7103 @05311e> : 10 10                      dup.x1 sp(16)
	<.main+7105 @053120> : 10 10                      dup.x1 sp(16)
	<.main+7107 @053122> : 57                         ceq.i32
	<.main+7108 @053123> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@053124> - <@053129>): u32Clt: bool := bool(u32A < u32B)
	<.main+7109 @053124> : 10 11                      dup.x1 sp(17)
	<.main+7111 @053126> : 10 11                      dup.x1 sp(17)
	<.main+7113 @053128> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@053129> - <@05312f>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7114 @053129> : 10 12                      dup.x1 sp(18)
	<.main+7116 @05312b> : 10 12                      dup.x1 sp(18)
	<.main+7118 @05312d> : 39                         cgt.u32
	<.main+7119 @05312e> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@05312f> - <@053134>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7120 @05312f> : 10 13                      dup.x1 sp(19)
	<.main+7122 @053131> : 10 13                      dup.x1 sp(19)
	<.main+7124 @053133> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@053134> - <@05313a>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7125 @053134> : 10 14                      dup.x1 sp(20)
	<.main+7127 @053136> : 10 14                      dup.x1 sp(20)
	<.main+7129 @053138> : 38                         clt.u32
	<.main+7130 @053139> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@05313a> - <@053143>): i64A: int64 := a
	<.main+7131 @05313a> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@053143> - <@05314c>): i64B: int64 := b
	<.main+7140 @053143> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@05314c> - <@05314e>): i64Pls: int64 := int64(+i64B)
	<.main+7149 @05314c> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@05314e> - <@053151>): i64Neg: int64 := int64(-i64B)
	<.main+7151 @05314e> : 11 02                      dup.x2 sp(2)
	<.main+7153 @053150> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@053151> - <@053154>): i64Cmt: int64 := int64(~i64B)
	<.main+7154 @053151> : 11 04                      dup.x2 sp(4)
	<.main+7156 @053153> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@053154> - <@053159>): i64Add: int64 := int64(i64A + i64B)
	<.main+7157 @053154> : 11 08                      dup.x2 sp(8)
	<.main+7159 @053156> : 11 08                      dup.x2 sp(8)
	<.main+7161 @053158> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@053159> - <@05315e>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7162 @053159> : 11 0a                      dup.x2 sp(10)
	<.main+7164 @05315b> : 11 0a                      dup.x2 sp(10)
	<.main+7166 @05315d> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@05315e> - <@053163>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7167 @05315e> : 11 0c                      dup.x2 sp(12)
	<.main+7169 @053160> : 11 0c                      dup.x2 sp(12)
	<.main+7171 @053162> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@053163> - <@053168>): i64Div: int64 := int64(i64A / i64B)
	<.main+7172 @053163> : 11 0e                      dup.x2 sp(14)
	<.main+7174 @053165> : 11 0e                      dup.x2 sp(14)
	<.main+7176 @053167> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@053168> - <@05316d>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7177 @053168> : 11 10                      dup.x2 sp(16)
	<.main+7179 @05316a> : 11 10                      dup.x2 sp(16)
	<.main+7181 @05316c> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@05316d> - <@053172>): i64And: int64 := int64(i64A & i64B)
	<.main+7182 @05316d> : 11 12                      dup.x2 sp(18)
	<.main+7184 @05316f> : 11 12                      dup.x2 sp(18)
	<.main+7186 @053171> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@053172> - <@053177>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7187 @053172> : 11 14                      dup.x2 sp(20)
	<.main+7189 @053174> : 11 14                      dup.x2 sp(20)
	<.main+7191 @053176> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@053177> - <@05317c>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7192 @053177> : 11 16                      dup.x2 sp(22)
	<.main+7194 @053179> : 11 16                      dup.x2 sp(22)
	<.main+7196 @05317b> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@05317c> - <@053181>): i64Shl: int64 := int64(i64A << shift)
	<.main+7197 @05317c> : 11 18                      dup.x2 sp(24)
	<.main+7199 @05317e> : 10 c2                      dup.x1 sp(194)
	<.main+7201 @053180> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@053181> - <@053186>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7202 @053181> : 11 1a                      dup.x2 sp(26)
	<.main+7204 @053183> : 10 c4                      dup.x1 sp(196)
	<.main+7206 @053185> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@053186> - <@05318a>): i64Not: bool := bool(!(i64B))
	<.main+7207 @053186> : 11 1a                      dup.x2 sp(26)
	<.main+7209 @053188> : 6c                         i64.2bool
	<.main+7210 @053189> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@05318a> - <@05318f>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7211 @05318a> : 11 1d                      dup.x2 sp(29)
	<.main+7213 @05318c> : 11 1d                      dup.x2 sp(29)
	<.main+7215 @05318e> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@05318f> - <@053195>): i64Cne: bool := bool(i64A != i64B)
	<.main+7216 @05318f> : 11 1e                      dup.x2 sp(30)
	<.main+7218 @053191> : 11 1e                      dup.x2 sp(30)
	<.main+7220 @053193> : 67                         ceq.i64
	<.main+7221 @053194> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@053195> - <@05319a>): i64Clt: bool := bool(i64A < i64B)
	<.main+7222 @053195> : 11 1f                      dup.x2 sp(31)
	<.main+7224 @053197> : 11 1f                      dup.x2 sp(31)
	<.main+7226 @053199> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@05319a> - <@0531a0>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7227 @05319a> : 11 20                      dup.x2 sp(32)
	<.main+7229 @05319c> : 11 20                      dup.x2 sp(32)
	<.main+7231 @05319e> : 69                         cgt.i64
	<.main+7232 @05319f> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@0531a0> - <@0531a5>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7233 @0531a0> : 11 21                      dup.x2 sp(33)
	<.main+7235 @0531a2> : 11 21                      dup.x2 sp(33)
	<.main+7237 @0531a4> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@0531a5> - <@0531ab>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7238 @0531a5> : 11 22                      dup.x2 sp(34)
	<.main+7240 @0531a7> : 11 22                      dup.x2 sp(34)
	<.main+7242 @0531a9> : 68                         clt.i64
	<.main+7243 @0531aa> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@0531ab> - <@0531b4>): u64A: uint64 := a
	<.main+7244 @0531ab> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@0531b4> - <@0531bd>): u64B: uint64 := b
	<.main+7253 @0531b4> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@0531bd> - <@0531bf>): u64Pls: uint64 := uint64(+u64B)
	<.main+7262 @0531bd> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@0531bf> - <@0531c2>): u64Neg: uint64 := uint64(-u64B)
	<.main+7264 @0531bf> : 11 02                      dup.x2 sp(2)
	<.main+7266 @0531c1> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@0531c2> - <@0531c5>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7267 @0531c2> : 11 04                      dup.x2 sp(4)
	<.main+7269 @0531c4> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@0531c5> - <@0531ca>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7270 @0531c5> : 11 08                      dup.x2 sp(8)
	<.main+7272 @0531c7> : 11 08                      dup.x2 sp(8)
	<.main+7274 @0531c9> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@0531ca> - <@0531cf>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7275 @0531ca> : 11 0a                      dup.x2 sp(10)
	<.main+7277 @0531cc> : 11 0a                      dup.x2 sp(10)
	<.main+7279 @0531ce> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@0531cf> - <@0531d4>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7280 @0531cf> : 11 0c                      dup.x2 sp(12)
	<.main+7282 @0531d1> : 11 0c                      dup.x2 sp(12)
	<.main+7284 @0531d3> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@0531d4> - <@0531d9>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7285 @0531d4> : 11 0e                      dup.x2 sp(14)
	<.main+7287 @0531d6> : 11 0e                      dup.x2 sp(14)
	<.main+7289 @0531d8> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@0531d9> - <@0531de>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7290 @0531d9> : 11 10                      dup.x2 sp(16)
	<.main+7292 @0531db> : 11 10                      dup.x2 sp(16)
	<.main+7294 @0531dd> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@0531de> - <@0531e3>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7295 @0531de> : 11 12                      dup.x2 sp(18)
	<.main+7297 @0531e0> : 11 12                      dup.x2 sp(18)
	<.main+7299 @0531e2> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@0531e3> - <@0531e8>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7300 @0531e3> : 11 14                      dup.x2 sp(20)
	<.main+7302 @0531e5> : 11 14                      dup.x2 sp(20)
	<.main+7304 @0531e7> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@0531e8> - <@0531ed>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7305 @0531e8> : 11 16                      dup.x2 sp(22)
	<.main+7307 @0531ea> : 11 16                      dup.x2 sp(22)
	<.main+7309 @0531ec> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@0531ed> - <@0531f2>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7310 @0531ed> : 11 18                      dup.x2 sp(24)
	<.main+7312 @0531ef> : 10 e7                      dup.x1 sp(231)
	<.main+7314 @0531f1> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@0531f2> - <@0531f7>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7315 @0531f2> : 11 1a                      dup.x2 sp(26)
	<.main+7317 @0531f4> : 10 e9                      dup.x1 sp(233)
	<.main+7319 @0531f6> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@0531f7> - <@0531fb>): u64Not: bool := bool(!(u64B))
	<.main+7320 @0531f7> : 11 1a                      dup.x2 sp(26)
	<.main+7322 @0531f9> : 6c                         i64.2bool
	<.main+7323 @0531fa> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@0531fb> - <@053200>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7324 @0531fb> : 11 1d                      dup.x2 sp(29)
	<.main+7326 @0531fd> : 11 1d                      dup.x2 sp(29)
	<.main+7328 @0531ff> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@053200> - <@053206>): u64Cne: bool := bool(u64A != u64B)
	<.main+7329 @053200> : 11 1e                      dup.x2 sp(30)
	<.main+7331 @053202> : 11 1e                      dup.x2 sp(30)
	<.main+7333 @053204> : 67                         ceq.i64
	<.main+7334 @053205> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@053206> - <@05320b>): u64Clt: bool := bool(u64A < u64B)
	<.main+7335 @053206> : 11 1f                      dup.x2 sp(31)
	<.main+7337 @053208> : 11 1f                      dup.x2 sp(31)
	<.main+7339 @05320a> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@05320b> - <@053211>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7340 @05320b> : 11 20                      dup.x2 sp(32)
	<.main+7342 @05320d> : 11 20                      dup.x2 sp(32)
	<.main+7344 @05320f> : 49                         cgt.u64
	<.main+7345 @053210> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@053211> - <@053216>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7346 @053211> : 11 21                      dup.x2 sp(33)
	<.main+7348 @053213> : 11 21                      dup.x2 sp(33)
	<.main+7350 @053215> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@053216> - <@05321c>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7351 @053216> : 11 22                      dup.x2 sp(34)
	<.main+7353 @053218> : 11 22                      dup.x2 sp(34)
	<.main+7355 @05321a> : 48                         clt.u64
	<.main+7356 @05321b> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@05321c> - <@053221>): f32A: float32 := a
	<.main+7357 @05321c> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@053221> - <@053226>): f32B: float32 := b
	<.main+7362 @053221> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@053226> - <@053228>): f32Pls: float32 := float32(+f32B)
	<.main+7367 @053226> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@053228> - <@05322b>): f32Neg: float32 := float32(-f32B)
	<.main+7369 @053228> : 10 01                      dup.x1 sp(1)
	<.main+7371 @05322a> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@05322b> - <@053230>): f32Add: float32 := float32(f32A + f32B)
	<.main+7372 @05322b> : 10 03                      dup.x1 sp(3)
	<.main+7374 @05322d> : 10 03                      dup.x1 sp(3)
	<.main+7376 @05322f> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@053230> - <@053235>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7377 @053230> : 10 04                      dup.x1 sp(4)
	<.main+7379 @053232> : 10 04                      dup.x1 sp(4)
	<.main+7381 @053234> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@053235> - <@05323a>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7382 @053235> : 10 05                      dup.x1 sp(5)
	<.main+7384 @053237> : 10 05                      dup.x1 sp(5)
	<.main+7386 @053239> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@05323a> - <@05323f>): f32Div: float32 := float32(f32A / f32B)
	<.main+7387 @05323a> : 10 06                      dup.x1 sp(6)
	<.main+7389 @05323c> : 10 06                      dup.x1 sp(6)
	<.main+7391 @05323e> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@05323f> - <@053244>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7392 @05323f> : 10 07                      dup.x1 sp(7)
	<.main+7394 @053241> : 10 07                      dup.x1 sp(7)
	<.main+7396 @053243> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@053244> - <@053248>): f32Not: bool := bool(!(f32B))
	<.main+7397 @053244> : 10 07                      dup.x1 sp(7)
	<.main+7399 @053246> : 7b                         f32.2bool
	<.main+7400 @053247> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@053248> - <@05324d>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7401 @053248> : 10 09                      dup.x1 sp(9)
	<.main+7403 @05324a> : 10 09                      dup.x1 sp(9)
	<.main+7405 @05324c> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@05324d> - <@053253>): f32Cne: bool := bool(f32A != f32B)
	<.main+7406 @05324d> : 10 0a                      dup.x1 sp(10)
	<.main+7408 @05324f> : 10 0a                      dup.x1 sp(10)
	<.main+7410 @053251> : 77                         ceq.f32
	<.main+7411 @053252> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@053253> - <@053258>): f32Clt: bool := bool(f32A < f32B)
	<.main+7412 @053253> : 10 0b                      dup.x1 sp(11)
	<.main+7414 @053255> : 10 0b                      dup.x1 sp(11)
	<.main+7416 @053257> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@053258> - <@05325e>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7417 @053258> : 10 0c                      dup.x1 sp(12)
	<.main+7419 @05325a> : 10 0c                      dup.x1 sp(12)
	<.main+7421 @05325c> : 79                         cgt.f32
	<.main+7422 @05325d> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@05325e> - <@053263>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7423 @05325e> : 10 0d                      dup.x1 sp(13)
	<.main+7425 @053260> : 10 0d                      dup.x1 sp(13)
	<.main+7427 @053262> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@053263> - <@053269>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7428 @053263> : 10 0e                      dup.x1 sp(14)
	<.main+7430 @053265> : 10 0e                      dup.x1 sp(14)
	<.main+7432 @053267> : 78                         clt.f32
	<.main+7433 @053268> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@053269> - <@053272>): f64A: float64 := a
	<.main+7434 @053269> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@053272> - <@05327b>): f64B: float64 := b
	<.main+7443 @053272> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@05327b> - <@05327d>): f64Pls: float64 := float64(+f64B)
	<.main+7452 @05327b> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@05327d> - <@053280>): f64Neg: float64 := float64(-f64B)
	<.main+7454 @05327d> : 11 02                      dup.x2 sp(2)
	<.main+7456 @05327f> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@053280> - <@053285>): f64Add: float64 := float64(f64A + f64B)
	<.main+7457 @053280> : 11 06                      dup.x2 sp(6)
	<.main+7459 @053282> : 11 06                      dup.x2 sp(6)
	<.main+7461 @053284> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@053285> - <@05328a>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7462 @053285> : 11 08                      dup.x2 sp(8)
	<.main+7464 @053287> : 11 08                      dup.x2 sp(8)
	<.main+7466 @053289> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@05328a> - <@05328f>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7467 @05328a> : 11 0a                      dup.x2 sp(10)
	<.main+7469 @05328c> : 11 0a                      dup.x2 sp(10)
	<.main+7471 @05328e> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@05328f> - <@053294>): f64Div: float64 := float64(f64A / f64B)
	<.main+7472 @05328f> : 11 0c                      dup.x2 sp(12)
	<.main+7474 @053291> : 11 0c                      dup.x2 sp(12)
	<.main+7476 @053293> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@053294> - <@053299>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7477 @053294> : 11 0e                      dup.x2 sp(14)
	<.main+7479 @053296> : 11 0e                      dup.x2 sp(14)
	<.main+7481 @053298> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@053299> - <@05329d>): f64Not: bool := bool(!(f64B))
	<.main+7482 @053299> : 11 0e                      dup.x2 sp(14)
	<.main+7484 @05329b> : 8d                         f64.2bool
	<.main+7485 @05329c> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@05329d> - <@0532a2>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7486 @05329d> : 11 11                      dup.x2 sp(17)
	<.main+7488 @05329f> : 11 11                      dup.x2 sp(17)
	<.main+7490 @0532a1> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@0532a2> - <@0532a8>): f64Cne: bool := bool(f64A != f64B)
	<.main+7491 @0532a2> : 11 12                      dup.x2 sp(18)
	<.main+7493 @0532a4> : 11 12                      dup.x2 sp(18)
	<.main+7495 @0532a6> : 87                         ceq.f64
	<.main+7496 @0532a7> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@0532a8> - <@0532ad>): f64Clt: bool := bool(f64A < f64B)
	<.main+7497 @0532a8> : 11 13                      dup.x2 sp(19)
	<.main+7499 @0532aa> : 11 13                      dup.x2 sp(19)
	<.main+7501 @0532ac> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@0532ad> - <@0532b3>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7502 @0532ad> : 11 14                      dup.x2 sp(20)
	<.main+7504 @0532af> : 11 14                      dup.x2 sp(20)
	<.main+7506 @0532b1> : 89                         cgt.f64
	<.main+7507 @0532b2> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@0532b3> - <@0532b8>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7508 @0532b3> : 11 15                      dup.x2 sp(21)
	<.main+7510 @0532b5> : 11 15                      dup.x2 sp(21)
	<.main+7512 @0532b7> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@0532b8> - <@0532be>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7513 @0532b8> : 11 16                      dup.x2 sp(22)
	<.main+7515 @0532ba> : 11 16                      dup.x2 sp(22)
	<.main+7517 @0532bc> : 88                         clt.f64
	<.main+7518 @0532bd> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@0532be> - <@0532c3>): ptrA: pointer := null
	<.main+7519 @0532be> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@0532c3> - <@0532c7>): ptrB: pointer := pointer(shift)
	<.main+7524 @0532c3> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@0532c7> - <@0532cc>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7528 @0532c7> : 10 01                      dup.x1 sp(1)
	<.main+7530 @0532c9> : 10 01                      dup.x1 sp(1)
	<.main+7532 @0532cb> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@0532cc> - <@0532d2>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7533 @0532cc> : 10 02                      dup.x1 sp(2)
	<.main+7535 @0532ce> : 10 02                      dup.x1 sp(2)
	<.main+7537 @0532d0> : 57                         ceq.i32
	<.main+7538 @0532d1> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@0532d2> - <@0532f9>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7539 @0532d2> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7544 @0532d7> : 1c 04 00 00 00             load.c32 4
	<.main+7549 @0532dc> : 1c 0e 00 00 00             load.c32 14
	<.main+7554 @0532e1> : 1c 01 00 00 00             load.c32 1
	<.main+7559 @0532e6> : 1f b9 c9 04 00             load.ref <@04c9b9> ;"0 == 0"
	<.main+7564 @0532eb> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7569 @0532f0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7574 @0532f5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@0532f9> - <@053320>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7578 @0532f9> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7583 @0532fe> : 1c 0c 00 00 00             load.c32 12
	<.main+7588 @053303> : 1c 0e 00 00 00             load.c32 14
	<.main+7593 @053308> : 1c 03 00 00 00             load.c32 3
	<.main+7598 @05330d> : 1f b9 c9 04 00             load.ref <@04c9b9> ;"0 == 0"
	<.main+7603 @053312> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7608 @053317> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7613 @05331c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@053320> - <@053347>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7617 @053320> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7622 @053325> : 1c 16 00 00 00             load.c32 22
	<.main+7627 @05332a> : 1c 0e 00 00 00             load.c32 14
	<.main+7632 @05332f> : 1c 06 00 00 00             load.c32 6
	<.main+7637 @053334> : 1f b9 c9 04 00             load.ref <@04c9b9> ;"0 == 0"
	<.main+7642 @053339> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7647 @05333e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7652 @053343> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@053347> - <@053348>): t: int32 := 0
	<.main+7656 @053347> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@053348> - <@053376>): if (bool(t == 0))
	<.main+7657 @053348> : 10 00                      dup.x1 sp(0)
	<.main+7659 @05334a> : 19                         load.z32
	<.main+7660 @05334b> : 57                         ceq.i32
	<.main+7661 @05334c> : 06 2a 00 00                jz <.main+7703 @053376>
	test/lang/statementIf.ci:29: (38 bytes: <@053350> - <@053376>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7665 @053350> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7670 @053355> : 1c 1d 00 00 00             load.c32 29
	<.main+7675 @05335a> : 1c 0e 00 00 00             load.c32 14
	<.main+7680 @05335f> : 1c 07 00 00 00             load.c32 7
	<.main+7685 @053364> : 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+7690 @053369> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7695 @05336e> : 0a 18 00 00                load.sp(+24)
	<.main+7699 @053372> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@053376> - <@0533a4>): if (bool(t != 0))
	<.main+7703 @053376> : 10 00                      dup.x1 sp(0)
	<.main+7705 @053378> : 19                         load.z32
	<.main+7706 @053379> : 57                         ceq.i32
	<.main+7707 @05337a> : 05 2a 00 00                jnz <.main+7749 @0533a4>
	test/lang/statementIf.ci:33: (38 bytes: <@05337e> - <@0533a4>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7711 @05337e> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7716 @053383> : 1c 21 00 00 00             load.c32 33
	<.main+7721 @053388> : 1c 0e 00 00 00             load.c32 14
	<.main+7726 @05338d> : 1c 08 00 00 00             load.c32 8
	<.main+7731 @053392> : 1f ce c9 04 00             load.ref <@04c9ce> ;"t != 0"
	<.main+7736 @053397> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7741 @05339c> : 0a 18 00 00                load.sp(+24)
	<.main+7745 @0533a0> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@0533a4> - <@0533fc>): if (bool(t == 0))
	<.main+7749 @0533a4> : 10 00                      dup.x1 sp(0)
	<.main+7751 @0533a6> : 19                         load.z32
	<.main+7752 @0533a7> : 57                         ceq.i32
	<.main+7753 @0533a8> : 06 2e 00 00                jz <.main+7799 @0533d6>
	test/lang/statementIf.ci:37: (38 bytes: <@0533ac> - <@0533d2>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7757 @0533ac> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7762 @0533b1> : 1c 25 00 00 00             load.c32 37
	<.main+7767 @0533b6> : 1c 0e 00 00 00             load.c32 14
	<.main+7772 @0533bb> : 1c 09 00 00 00             load.c32 9
	<.main+7777 @0533c0> : 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+7782 @0533c5> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7787 @0533ca> : 0a 18 00 00                load.sp(+24)
	<.main+7791 @0533ce> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7795 @0533d2> : 04 2a 00 00                jmp <.main+7837 @0533fc>
	test/lang/statementIf.ci:40: (38 bytes: <@0533d6> - <@0533fc>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7799 @0533d6> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7804 @0533db> : 1c 28 00 00 00             load.c32 40
	<.main+7809 @0533e0> : 1c 0e 00 00 00             load.c32 14
	<.main+7814 @0533e5> : 1c 0a 00 00 00             load.c32 10
	<.main+7819 @0533ea> : 1f ce c9 04 00             load.ref <@04c9ce> ;"t != 0"
	<.main+7824 @0533ef> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7829 @0533f4> : 0a 18 00 00                load.sp(+24)
	<.main+7833 @0533f8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@0533fc> - <@053454>): if (bool(t != 0))
	<.main+7837 @0533fc> : 10 00                      dup.x1 sp(0)
	<.main+7839 @0533fe> : 19                         load.z32
	<.main+7840 @0533ff> : 57                         ceq.i32
	<.main+7841 @053400> : 05 2e 00 00                jnz <.main+7887 @05342e>
	test/lang/statementIf.ci:44: (38 bytes: <@053404> - <@05342a>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7845 @053404> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7850 @053409> : 1c 2c 00 00 00             load.c32 44
	<.main+7855 @05340e> : 1c 0e 00 00 00             load.c32 14
	<.main+7860 @053413> : 1c 0b 00 00 00             load.c32 11
	<.main+7865 @053418> : 1f ce c9 04 00             load.ref <@04c9ce> ;"t != 0"
	<.main+7870 @05341d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7875 @053422> : 0a 18 00 00                load.sp(+24)
	<.main+7879 @053426> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7883 @05342a> : 04 2a 00 00                jmp <.main+7925 @053454>
	test/lang/statementIf.ci:47: (38 bytes: <@05342e> - <@053454>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7887 @05342e> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7892 @053433> : 1c 2f 00 00 00             load.c32 47
	<.main+7897 @053438> : 1c 0e 00 00 00             load.c32 14
	<.main+7902 @05343d> : 1c 0c 00 00 00             load.c32 12
	<.main+7907 @053442> : 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+7912 @053447> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7917 @05344c> : 0a 18 00 00                load.sp(+24)
	<.main+7921 @053450> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@053454> - <@0535ba>): if (bool(t == 0))
	<.main+7925 @053454> : 10 00                      dup.x1 sp(0)
	<.main+7927 @053456> : 19                         load.z32
	<.main+7928 @053457> : 57                         ceq.i32
	<.main+7929 @053458> : 06 2e 00 00                jz <.main+7975 @053486>
	test/lang/statementIf.ci:51: (38 bytes: <@05345c> - <@053482>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7933 @05345c> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7938 @053461> : 1c 33 00 00 00             load.c32 51
	<.main+7943 @053466> : 1c 0e 00 00 00             load.c32 14
	<.main+7948 @05346b> : 1c 09 00 00 00             load.c32 9
	<.main+7953 @053470> : 1f c7 c9 04 00             load.ref <@04c9c7> ;"t == 0"
	<.main+7958 @053475> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7963 @05347a> : 0a 18 00 00                load.sp(+24)
	<.main+7967 @05347e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7971 @053482> : 04 38 01 00                jmp <.main+8283 @0535ba>
	test/lang/statementIf.ci:53: (308 bytes: <@053486> - <@0535ba>): if (bool(t == 1))
	<.main+7975 @053486> : 10 00                      dup.x1 sp(0)
	<.main+7977 @053488> : 1c 01 00 00 00             load.c32 1
	<.main+7982 @05348d> : 57                         ceq.i32
	<.main+7983 @05348e> : 06 2e 00 00                jz <.main+8029 @0534bc>
	test/lang/statementIf.ci:54: (38 bytes: <@053492> - <@0534b8>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7987 @053492> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+7992 @053497> : 1c 36 00 00 00             load.c32 54
	<.main+7997 @05349c> : 1c 0e 00 00 00             load.c32 14
	<.main+8002 @0534a1> : 1c 0a 00 00 00             load.c32 10
	<.main+8007 @0534a6> : 1f d5 c9 04 00             load.ref <@04c9d5> ;"t == 1"
	<.main+8012 @0534ab> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8017 @0534b0> : 0a 18 00 00                load.sp(+24)
	<.main+8021 @0534b4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8025 @0534b8> : 04 02 01 00                jmp <.main+8283 @0535ba>
	test/lang/statementIf.ci:56: (254 bytes: <@0534bc> - <@0535ba>): if (bool(t == 2))
	<.main+8029 @0534bc> : 10 00                      dup.x1 sp(0)
	<.main+8031 @0534be> : 1c 02 00 00 00             load.c32 2
	<.main+8036 @0534c3> : 57                         ceq.i32
	<.main+8037 @0534c4> : 06 2e 00 00                jz <.main+8083 @0534f2>
	test/lang/statementIf.ci:57: (38 bytes: <@0534c8> - <@0534ee>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+8041 @0534c8> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+8046 @0534cd> : 1c 39 00 00 00             load.c32 57
	<.main+8051 @0534d2> : 1c 0e 00 00 00             load.c32 14
	<.main+8056 @0534d7> : 1c 0a 00 00 00             load.c32 10
	<.main+8061 @0534dc> : 1f dc c9 04 00             load.ref <@04c9dc> ;"t == 2"
	<.main+8066 @0534e1> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8071 @0534e6> : 0a 18 00 00                load.sp(+24)
	<.main+8075 @0534ea> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8079 @0534ee> : 04 cc 00 00                jmp <.main+8283 @0535ba>
	test/lang/statementIf.ci:59: (200 bytes: <@0534f2> - <@0535ba>): if (bool(t == 3))
	<.main+8083 @0534f2> : 10 00                      dup.x1 sp(0)
	<.main+8085 @0534f4> : 1c 03 00 00 00             load.c32 3
	<.main+8090 @0534f9> : 57                         ceq.i32
	<.main+8091 @0534fa> : 06 2e 00 00                jz <.main+8137 @053528>
	test/lang/statementIf.ci:60: (38 bytes: <@0534fe> - <@053524>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8095 @0534fe> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+8100 @053503> : 1c 3c 00 00 00             load.c32 60
	<.main+8105 @053508> : 1c 0e 00 00 00             load.c32 14
	<.main+8110 @05350d> : 1c 0a 00 00 00             load.c32 10
	<.main+8115 @053512> : 1f e3 c9 04 00             load.ref <@04c9e3> ;"t == 3"
	<.main+8120 @053517> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8125 @05351c> : 0a 18 00 00                load.sp(+24)
	<.main+8129 @053520> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8133 @053524> : 04 96 00 00                jmp <.main+8283 @0535ba>
	test/lang/statementIf.ci:62: (146 bytes: <@053528> - <@0535ba>): if (bool(t == 4))
	<.main+8137 @053528> : 10 00                      dup.x1 sp(0)
	<.main+8139 @05352a> : 1c 04 00 00 00             load.c32 4
	<.main+8144 @05352f> : 57                         ceq.i32
	<.main+8145 @053530> : 06 2e 00 00                jz <.main+8191 @05355e>
	test/lang/statementIf.ci:63: (38 bytes: <@053534> - <@05355a>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8149 @053534> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+8154 @053539> : 1c 3f 00 00 00             load.c32 63
	<.main+8159 @05353e> : 1c 0e 00 00 00             load.c32 14
	<.main+8164 @053543> : 1c 0a 00 00 00             load.c32 10
	<.main+8169 @053548> : 1f ea c9 04 00             load.ref <@04c9ea> ;"t == 4"
	<.main+8174 @05354d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8179 @053552> : 0a 18 00 00                load.sp(+24)
	<.main+8183 @053556> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8187 @05355a> : 04 60 00 00                jmp <.main+8283 @0535ba>
	test/lang/statementIf.ci:65: (92 bytes: <@05355e> - <@0535ba>): if (bool(t == 5))
	<.main+8191 @05355e> : 10 00                      dup.x1 sp(0)
	<.main+8193 @053560> : 1c 05 00 00 00             load.c32 5
	<.main+8198 @053565> : 57                         ceq.i32
	<.main+8199 @053566> : 06 2e 00 00                jz <.main+8245 @053594>
	test/lang/statementIf.ci:66: (38 bytes: <@05356a> - <@053590>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8203 @05356a> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+8208 @05356f> : 1c 42 00 00 00             load.c32 66
	<.main+8213 @053574> : 1c 0e 00 00 00             load.c32 14
	<.main+8218 @053579> : 1c 0a 00 00 00             load.c32 10
	<.main+8223 @05357e> : 1f f1 c9 04 00             load.ref <@04c9f1> ;"t == 5"
	<.main+8228 @053583> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8233 @053588> : 0a 18 00 00                load.sp(+24)
	<.main+8237 @05358c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8241 @053590> : 04 2a 00 00                jmp <.main+8283 @0535ba>
	test/lang/statementIf.ci:69: (38 bytes: <@053594> - <@0535ba>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8245 @053594> : 1f a0 c9 04 00             load.ref <@04c9a0> ;"test/lang/statementIf.ci"
	<.main+8250 @053599> : 1c 45 00 00 00             load.c32 69
	<.main+8255 @05359e> : 1c 0e 00 00 00             load.c32 14
	<.main+8260 @0535a3> : 1c 0a 00 00 00             load.c32 10
	<.main+8265 @0535a8> : 1f f8 c9 04 00             load.ref <@04c9f8> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8270 @0535ad> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8275 @0535b2> : 0a 18 00 00                load.sp(+24)
	<.main+8279 @0535b6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@0535ba> - <@0535e9>): for ( ; ; )
	<.main+8283 @0535ba> : 04 2b 00 00                jmp <.main+8326 @0535e5>
	test/lang/statementFor.ci:4: (35 bytes: <@0535be> - <@0535e1>): debug("for ( ; ; )");
	<.main+8287 @0535be> : 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+8292 @0535c3> : 1c 04 00 00 00             load.c32 4
	<.main+8297 @0535c8> : 1c 0e 00 00 00             load.c32 14
	<.main+8302 @0535cd> : 19                         load.z32
	<.main+8303 @0535ce> : 1f fa ca 04 00             load.ref <@04cafa> ;"for ( ; ; )"
	<.main+8308 @0535d3> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+8313 @0535d8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8318 @0535dd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@0535e1> - <@0535e5>): break;
	<.main+8322 @0535e1> : 04 08 00 00                jmp <.main+8330 @0535e9>
	:: (4 bytes: <@0535e5> - <@0535e9>)
	<.main+8326 @0535e5> : 04 d9 ff ff                jmp <.main+8287 @0535be>
	test/lang/statementFor.ci:8: (59 bytes: <@0535e9> - <@053624>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8330 @0535e9> : 19                         load.z32
	<.main+8331 @0535ea> : 04 2a 00 00                jmp <.main+8373 @053614>
	test/lang/statementFor.ci:9: (34 bytes: <@0535ee> - <@053610>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8335 @0535ee> : 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+8340 @0535f3> : 1c 09 00 00 00             load.c32 9
	<.main+8345 @0535f8> : 1c 0e 00 00 00             load.c32 14
	<.main+8350 @0535fd> : 19                         load.z32
	<.main+8351 @0535fe> : 1f 06 cb 04 00             load.ref <@04cb06> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8356 @053603> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8361 @053608> : 0a 18 00 00                load.sp(+24)
	<.main+8365 @05360c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@053610> - <@053614>): int32(i := int32(i + 1))
	<.main+8369 @053610> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@053614> - <@053620>): bool(i < 2)
	<.main+8373 @053614> : 10 00                      dup.x1 sp(0)
	<.main+8375 @053616> : 1c 02 00 00 00             load.c32 2
	<.main+8380 @05361b> : 58                         clt.i32
	<.main+8381 @05361c> : 05 d2 ff ff                jnz <.main+8335 @0535ee>
	<.main+8385 @053620> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@053624> - <@053625>): forIdx: int32
	<.main+8389 @053624> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@053625> - <@05365e>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8390 @053625> : 19                         load.z32
	<.main+8391 @053626> : 13 01                      set.x1 sp(1)
	<.main+8393 @053628> : 04 2a 00 00                jmp <.main+8435 @053652>
	test/lang/statementFor.ci:14: (34 bytes: <@05362c> - <@05364e>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8397 @05362c> : 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+8402 @053631> : 1c 0e 00 00 00             load.c32 14
	<.main+8407 @053636> : 1c 0e 00 00 00             load.c32 14
	<.main+8412 @05363b> : 19                         load.z32
	<.main+8413 @05363c> : 1f 2c cb 04 00             load.ref <@04cb2c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8418 @053641> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8423 @053646> : 0a 18 00 00                load.sp(+24)
	<.main+8427 @05364a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@05364e> - <@053652>): int32(forIdx := int32(forIdx + 1))
	<.main+8431 @05364e> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@053652> - <@05365e>): bool(forIdx < 2)
	<.main+8435 @053652> : 10 00                      dup.x1 sp(0)
	<.main+8437 @053654> : 1c 02 00 00 00             load.c32 2
	<.main+8442 @053659> : 58                         clt.i32
	<.main+8443 @05365a> : 05 d2 ff ff                jnz <.main+8397 @05362c>
	test/lang/statementFor.ci:17: (75 bytes: <@05365e> - <@0536a9>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8447 @05365e> : 19                         load.z32
	<.main+8448 @05365f> : 04 3a 00 00                jmp <.main+8506 @053699>
	test/lang/statementFor.ci:18: (16 bytes: <@053663> - <@053673>): if (bool(i < 2))
	<.main+8452 @053663> : 10 00                      dup.x1 sp(0)
	<.main+8454 @053665> : 1c 02 00 00 00             load.c32 2
	<.main+8459 @05366a> : 58                         clt.i32
	<.main+8460 @05366b> : 06 08 00 00                jz <.main+8468 @053673>
	test/lang/statementFor.ci:19: (4 bytes: <@05366f> - <@053673>): continue;
	<.main+8464 @05366f> : 04 26 00 00                jmp <.main+8502 @053695>
	test/lang/statementFor.ci:21: (34 bytes: <@053673> - <@053695>): debug(void("for with continue", i));
	<.main+8468 @053673> : 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+8473 @053678> : 1c 15 00 00 00             load.c32 21
	<.main+8478 @05367d> : 1c 0e 00 00 00             load.c32 14
	<.main+8483 @053682> : 19                         load.z32
	<.main+8484 @053683> : 1f 56 cb 04 00             load.ref <@04cb56> ;"for with continue"
	<.main+8489 @053688> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8494 @05368d> : 0a 18 00 00                load.sp(+24)
	<.main+8498 @053691> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@053695> - <@053699>): int32(i := int32(i + 1))
	<.main+8502 @053695> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@053699> - <@0536a5>): bool(i < 7)
	<.main+8506 @053699> : 10 00                      dup.x1 sp(0)
	<.main+8508 @05369b> : 1c 07 00 00 00             load.c32 7
	<.main+8513 @0536a0> : 58                         clt.i32
	<.main+8514 @0536a1> : 05 c2 ff ff                jnz <.main+8452 @053663>
	<.main+8518 @0536a5> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@0536a9> - <@0536f4>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8522 @0536a9> : 19                         load.z32
	<.main+8523 @0536aa> : 04 3a 00 00                jmp <.main+8581 @0536e4>
	test/lang/statementFor.ci:25: (16 bytes: <@0536ae> - <@0536be>): if (bool(i > 2))
	<.main+8527 @0536ae> : 10 00                      dup.x1 sp(0)
	<.main+8529 @0536b0> : 1c 02 00 00 00             load.c32 2
	<.main+8534 @0536b5> : 59                         cgt.i32
	<.main+8535 @0536b6> : 06 08 00 00                jz <.main+8543 @0536be>
	test/lang/statementFor.ci:26: (4 bytes: <@0536ba> - <@0536be>): break;
	<.main+8539 @0536ba> : 04 36 00 00                jmp <.main+8593 @0536f0>
	test/lang/statementFor.ci:28: (34 bytes: <@0536be> - <@0536e0>): debug(void("for with break", i));
	<.main+8543 @0536be> : 1f e0 ca 04 00             load.ref <@04cae0> ;"test/lang/statementFor.ci"
	<.main+8548 @0536c3> : 1c 1c 00 00 00             load.c32 28
	<.main+8553 @0536c8> : 1c 0e 00 00 00             load.c32 14
	<.main+8558 @0536cd> : 19                         load.z32
	<.main+8559 @0536ce> : 1f 68 cb 04 00             load.ref <@04cb68> ;"for with break"
	<.main+8564 @0536d3> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8569 @0536d8> : 0a 18 00 00                load.sp(+24)
	<.main+8573 @0536dc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@0536e0> - <@0536e4>): int32(i := int32(i + 1))
	<.main+8577 @0536e0> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@0536e4> - <@0536f0>): bool(i < 7)
	<.main+8581 @0536e4> : 10 00                      dup.x1 sp(0)
	<.main+8583 @0536e6> : 1c 07 00 00 00             load.c32 7
	<.main+8588 @0536eb> : 58                         clt.i32
	<.main+8589 @0536ec> : 05 c2 ff ff                jnz <.main+8527 @0536ae>
	<.main+8593 @0536f0> : 09 fc ff ff                inc.sp(-4)
	test/stdc/test.math.ci:3: (20 bytes: <@0536f4> - <@053708>): testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+8597 @0536f4> : 1a                         load.z64
	<.main+8598 @0536f5> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+8607 @0536fe> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+8612 @053703> : 02                         call
	<.main+8613 @053704> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:4: (20 bytes: <@053708> - <@05371c>): testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+8617 @053708> : 1a                         load.z64
	<.main+8618 @053709> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+8627 @053712> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+8632 @053717> : 02                         call
	<.main+8633 @053718> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:5: (20 bytes: <@05371c> - <@053730>): testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+8637 @05371c> : 1a                         load.z64
	<.main+8638 @05371d> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+8647 @053726> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+8652 @05372b> : 02                         call
	<.main+8653 @05372c> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:6: (20 bytes: <@053730> - <@053744>): testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+8657 @053730> : 1a                         load.z64
	<.main+8658 @053731> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+8667 @05373a> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+8672 @05373f> : 02                         call
	<.main+8673 @053740> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:7: (20 bytes: <@053744> - <@053758>): testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+8677 @053744> : 1a                         load.z64
	<.main+8678 @053745> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+8687 @05374e> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+8692 @053753> : 02                         call
	<.main+8693 @053754> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:8: (20 bytes: <@053758> - <@05376c>): testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+8697 @053758> : 1a                         load.z64
	<.main+8698 @053759> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+8707 @053762> : 1f c8 02 05 00             load.ref <@0502c8> ;Math.floor(x: float64): float64
	<.main+8712 @053767> : 02                         call
	<.main+8713 @053768> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:10: (25 bytes: <@05376c> - <@053785>): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+8717 @05376c> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8726 @053775> : 11 00                      dup.x2 sp(0)
	<.main+8728 @053777> : 1a                         load.z64
	<.main+8729 @053778> : 89                         cgt.f64
	<.main+8730 @053779> : 11 01                      dup.x2 sp(1)
	<.main+8732 @05377b> : 1a                         load.z64
	<.main+8733 @05377c> : 88                         clt.f64
	<.main+8734 @05377d> : 52                         sub.i32
	<.main+8735 @05377e> : 13 02                      set.x1 sp(2)
	<.main+8737 @053780> : 09 fc ff ff                inc.sp(-4)
	<.main+8741 @053784> : 5d                         i32.2f64
	test/stdc/test.math.ci:11: (17 bytes: <@053785> - <@053796>): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+8742 @053785> : 1a                         load.z64
	<.main+8743 @053786> : 11 00                      dup.x2 sp(0)
	<.main+8745 @053788> : 1a                         load.z64
	<.main+8746 @053789> : 89                         cgt.f64
	<.main+8747 @05378a> : 11 01                      dup.x2 sp(1)
	<.main+8749 @05378c> : 1a                         load.z64
	<.main+8750 @05378d> : 88                         clt.f64
	<.main+8751 @05378e> : 52                         sub.i32
	<.main+8752 @05378f> : 13 02                      set.x1 sp(2)
	<.main+8754 @053791> : 09 fc ff ff                inc.sp(-4)
	<.main+8758 @053795> : 5d                         i32.2f64
	test/stdc/test.math.ci:12: (25 bytes: <@053796> - <@0537af>): testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+8759 @053796> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8768 @05379f> : 11 00                      dup.x2 sp(0)
	<.main+8770 @0537a1> : 1a                         load.z64
	<.main+8771 @0537a2> : 89                         cgt.f64
	<.main+8772 @0537a3> : 11 01                      dup.x2 sp(1)
	<.main+8774 @0537a5> : 1a                         load.z64
	<.main+8775 @0537a6> : 88                         clt.f64
	<.main+8776 @0537a7> : 52                         sub.i32
	<.main+8777 @0537a8> : 13 02                      set.x1 sp(2)
	<.main+8779 @0537aa> : 09 fc ff ff                inc.sp(-4)
	<.main+8783 @0537ae> : 5d                         i32.2f64
	test/stdc/test.math.ci:13: (17 bytes: <@0537af> - <@0537c0>): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+8784 @0537af> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8789 @0537b4> : 10 00                      dup.x1 sp(0)
	<.main+8791 @0537b6> : 19                         load.z32
	<.main+8792 @0537b7> : 79                         cgt.f32
	<.main+8793 @0537b8> : 10 01                      dup.x1 sp(1)
	<.main+8795 @0537ba> : 19                         load.z32
	<.main+8796 @0537bb> : 78                         clt.f32
	<.main+8797 @0537bc> : 52                         sub.i32
	<.main+8798 @0537bd> : 13 01                      set.x1 sp(1)
	<.main+8800 @0537bf> : 5d                         i32.2f64
	test/stdc/test.math.ci:14: (13 bytes: <@0537c0> - <@0537cd>): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+8801 @0537c0> : 19                         load.z32
	<.main+8802 @0537c1> : 10 00                      dup.x1 sp(0)
	<.main+8804 @0537c3> : 19                         load.z32
	<.main+8805 @0537c4> : 79                         cgt.f32
	<.main+8806 @0537c5> : 10 01                      dup.x1 sp(1)
	<.main+8808 @0537c7> : 19                         load.z32
	<.main+8809 @0537c8> : 78                         clt.f32
	<.main+8810 @0537c9> : 52                         sub.i32
	<.main+8811 @0537ca> : 13 01                      set.x1 sp(1)
	<.main+8813 @0537cc> : 5d                         i32.2f64
	test/stdc/test.math.ci:15: (17 bytes: <@0537cd> - <@0537de>): testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+8814 @0537cd> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8819 @0537d2> : 10 00                      dup.x1 sp(0)
	<.main+8821 @0537d4> : 19                         load.z32
	<.main+8822 @0537d5> : 79                         cgt.f32
	<.main+8823 @0537d6> : 10 01                      dup.x1 sp(1)
	<.main+8825 @0537d8> : 19                         load.z32
	<.main+8826 @0537d9> : 78                         clt.f32
	<.main+8827 @0537da> : 52                         sub.i32
	<.main+8828 @0537db> : 13 01                      set.x1 sp(1)
	<.main+8830 @0537dd> : 5d                         i32.2f64
	test/stdc/test.math.ci:17: (20 bytes: <@0537de> - <@0537f2>): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+8831 @0537de> : 1a                         load.z64
	<.main+8832 @0537df> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8841 @0537e8> : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+8846 @0537ed> : 02                         call
	<.main+8847 @0537ee> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:18: (11 bytes: <@0537f2> - <@0537fd>): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+8851 @0537f2> : 1b                         load.z128
	<.main+8852 @0537f3> : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+8857 @0537f8> : 02                         call
	<.main+8858 @0537f9> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:19: (20 bytes: <@0537fd> - <@053811>): testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+8862 @0537fd> : 1a                         load.z64
	<.main+8863 @0537fe> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8872 @053807> : 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+8877 @05380c> : 02                         call
	<.main+8878 @05380d> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:20: (17 bytes: <@053811> - <@053822>): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+8882 @053811> : 19                         load.z32
	<.main+8883 @053812> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8888 @053817> : 1f e0 02 05 00             load.ref <@0502e0> ;Math.abs(x: float32): float32
	<.main+8893 @05381c> : 02                         call
	<.main+8894 @05381d> : 09 fc ff ff                inc.sp(-4)
	<.main+8898 @053821> : 7d                         f32.2f64
	test/stdc/test.math.ci:21: (13 bytes: <@053822> - <@05382f>): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+8899 @053822> : 19                         load.z32
	<.main+8900 @053823> : 19                         load.z32
	<.main+8901 @053824> : 1f e0 02 05 00             load.ref <@0502e0> ;Math.abs(x: float32): float32
	<.main+8906 @053829> : 02                         call
	<.main+8907 @05382a> : 09 fc ff ff                inc.sp(-4)
	<.main+8911 @05382e> : 7d                         f32.2f64
	test/stdc/test.math.ci:22: (17 bytes: <@05382f> - <@053840>): testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+8912 @05382f> : 19                         load.z32
	<.main+8913 @053830> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8918 @053835> : 1f e0 02 05 00             load.ref <@0502e0> ;Math.abs(x: float32): float32
	<.main+8923 @05383a> : 02                         call
	<.main+8924 @05383b> : 09 fc ff ff                inc.sp(-4)
	<.main+8928 @05383f> : 7d                         f32.2f64
	test/stdc/test.math.ci:24: (22 bytes: <@053840> - <@053856>): testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8929 @053840> : 19                         load.z32
	<.main+8930 @053841> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8935 @053846> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8940 @05384b> : 1f 50 03 05 00             load.ref <@050350> ;Math.min(a: float32, b: float32): float32
	<.main+8945 @053850> : 02                         call
	<.main+8946 @053851> : 09 f8 ff ff                inc.sp(-8)
	<.main+8950 @053855> : 7d                         f32.2f64
	test/stdc/test.math.ci:25: (22 bytes: <@053856> - <@05386c>): testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8951 @053856> : 19                         load.z32
	<.main+8952 @053857> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8957 @05385c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8962 @053861> : 1f 80 03 05 00             load.ref <@050380> ;Math.max(a: float32, b: float32): float32
	<.main+8967 @053866> : 02                         call
	<.main+8968 @053867> : 09 f8 ff ff                inc.sp(-8)
	<.main+8972 @05386b> : 7d                         f32.2f64
	test/stdc/test.math.ci:26: (29 bytes: <@05386c> - <@053889>): testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8973 @05386c> : 1a                         load.z64
	<.main+8974 @05386d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+8983 @053876> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+8992 @05387f> : 1f 68 03 05 00             load.ref <@050368> ;Math.min(a: float64, b: float64): float64
	<.main+8997 @053884> : 02                         call
	<.main+8998 @053885> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:27: (29 bytes: <@053889> - <@0538a6>): testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9002 @053889> : 1a                         load.z64
	<.main+9003 @05388a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9012 @053893> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9021 @05389c> : 1f 98 03 05 00             load.ref <@050398> ;Math.max(a: float64, b: float64): float64
	<.main+9026 @0538a1> : 02                         call
	<.main+9027 @0538a2> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:29: (23 bytes: <@0538a6> - <@0538bd>): testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9031 @0538a6> : 19                         load.z32
	<.main+9032 @0538a7> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9037 @0538ac> : 19                         load.z32
	<.main+9038 @0538ad> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9043 @0538b2> : 1f b0 03 05 00             load.ref <@0503b0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9048 @0538b7> : 02                         call
	<.main+9049 @0538b8> : 09 f4 ff ff                inc.sp(-12)
	<.main+9053 @0538bc> : 7d                         f32.2f64
	test/stdc/test.math.ci:30: (30 bytes: <@0538bd> - <@0538db>): testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9054 @0538bd> : 1a                         load.z64
	<.main+9055 @0538be> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9064 @0538c7> : 1a                         load.z64
	<.main+9065 @0538c8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9074 @0538d1> : 1f d0 03 05 00             load.ref <@0503d0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9079 @0538d6> : 02                         call
	<.main+9080 @0538d7> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:32: (21 bytes: <@0538db> - <@0538f0>): testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9084 @0538db> : 19                         load.z32
	<.main+9085 @0538dc> : 10 00                      dup.x1 sp(0)
	<.main+9087 @0538de> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9092 @0538e3> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9097 @0538e8> : 10 03                      dup.x1 sp(3)
	<.main+9099 @0538ea> : 72                         sub.f32
	<.main+9100 @0538eb> : 73                         mul.f32
	<.main+9101 @0538ec> : 71                         add.f32
	<.main+9102 @0538ed> : 13 01                      set.x1 sp(1)
	<.main+9104 @0538ef> : 7d                         f32.2f64
	test/stdc/test.math.ci:33: (28 bytes: <@0538f0> - <@05390c>): testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9105 @0538f0> : 1a                         load.z64
	<.main+9106 @0538f1> : 11 00                      dup.x2 sp(0)
	<.main+9108 @0538f3> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9117 @0538fc> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9126 @053905> : 11 06                      dup.x2 sp(6)
	<.main+9128 @053907> : 82                         sub.f64
	<.main+9129 @053908> : 83                         mul.f64
	<.main+9130 @053909> : 81                         add.f64
	<.main+9131 @05390a> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:35: (60 bytes: <@05390c> - <@053948>): testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9133 @05390c> : 19                         load.z32
	<.main+9134 @05390d> : 19                         load.z32
	<.main+9135 @05390e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9140 @053913> : 10 02                      dup.x1 sp(2)
	<.main+9142 @053915> : 72                         sub.f32
	<.main+9143 @053916> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9148 @05391b> : 10 03                      dup.x1 sp(3)
	<.main+9150 @05391d> : 72                         sub.f32
	<.main+9151 @05391e> : 74                         div.f32
	<.main+9152 @05391f> : 19                         load.z32
	<.main+9153 @053920> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9158 @053925> : 1f b0 03 05 00             load.ref <@0503b0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9163 @05392a> : 02                         call
	<.main+9164 @05392b> : 09 f4 ff ff                inc.sp(-12)
	<.main+9168 @05392f> : 10 00                      dup.x1 sp(0)
	<.main+9170 @053931> : 10 01                      dup.x1 sp(1)
	<.main+9172 @053933> : 73                         mul.f32
	<.main+9173 @053934> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9178 @053939> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9183 @05393e> : 10 03                      dup.x1 sp(3)
	<.main+9185 @053940> : 73                         mul.f32
	<.main+9186 @053941> : 72                         sub.f32
	<.main+9187 @053942> : 73                         mul.f32
	<.main+9188 @053943> : 13 01                      set.x1 sp(1)
	<.main+9190 @053945> : 13 01                      set.x1 sp(1)
	<.main+9192 @053947> : 7d                         f32.2f64
	test/stdc/test.math.ci:36: (78 bytes: <@053948> - <@053996>): testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9193 @053948> : 1b                         load.z128
	<.main+9194 @053949> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9203 @053952> : 11 04                      dup.x2 sp(4)
	<.main+9205 @053954> : 82                         sub.f64
	<.main+9206 @053955> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9215 @05395e> : 11 06                      dup.x2 sp(6)
	<.main+9217 @053960> : 82                         sub.f64
	<.main+9218 @053961> : 84                         div.f64
	<.main+9219 @053962> : 1a                         load.z64
	<.main+9220 @053963> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9229 @05396c> : 1f d0 03 05 00             load.ref <@0503d0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9234 @053971> : 02                         call
	<.main+9235 @053972> : 09 e8 ff ff                inc.sp(-24)
	<.main+9239 @053976> : 11 00                      dup.x2 sp(0)
	<.main+9241 @053978> : 11 02                      dup.x2 sp(2)
	<.main+9243 @05397a> : 83                         mul.f64
	<.main+9244 @05397b> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9253 @053984> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9262 @05398d> : 11 06                      dup.x2 sp(6)
	<.main+9264 @05398f> : 83                         mul.f64
	<.main+9265 @053990> : 82                         sub.f64
	<.main+9266 @053991> : 83                         mul.f64
	<.main+9267 @053992> : 14 02                      set.x2 sp(2)
	<.main+9269 @053994> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:38: (21 bytes: <@053996> - <@0539ab>): testMathMin_nan: float64 := Math.min()
	<.main+9271 @053996> : 19                         load.z32
	<.main+9272 @053997> : 0a 04 00 00                load.sp(+4)
	<.main+9276 @05399b> : 1a                         load.z64
	<.main+9277 @05399c> : 11 02                      dup.x2 sp(2)
	<.main+9279 @05399e> : 1f f0 03 05 00             load.ref <@0503f0> ;Math.min(data: float64[]): float64
	<.main+9284 @0539a3> : 02                         call
	<.main+9285 @0539a4> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9288 @0539a7> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:39: (106 bytes: <@0539ab> - <@053a15>): testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9292 @0539ab> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9301 @0539b4> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9310 @0539bd> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9319 @0539c6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9328 @0539cf> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9337 @0539d8> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9346 @0539e1> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9355 @0539ea> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9364 @0539f3> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9373 @0539fc> : 1c 09 00 00 00             load.c32 9
	<.main+9378 @053a01> : 0a 04 00 00                load.sp(+4)
	<.main+9382 @053a05> : 1a                         load.z64
	<.main+9383 @053a06> : 11 02                      dup.x2 sp(2)
	<.main+9385 @053a08> : 1f f0 03 05 00             load.ref <@0503f0> ;Math.min(data: float64[]): float64
	<.main+9390 @053a0d> : 02                         call
	<.main+9391 @053a0e> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9394 @053a11> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:40: (21 bytes: <@053a15> - <@053a2a>): testMathMax_nan: float64 := Math.max()
	<.main+9398 @053a15> : 19                         load.z32
	<.main+9399 @053a16> : 0a 04 00 00                load.sp(+4)
	<.main+9403 @053a1a> : 1a                         load.z64
	<.main+9404 @053a1b> : 11 02                      dup.x2 sp(2)
	<.main+9406 @053a1d> : 1f 38 04 05 00             load.ref <@050438> ;Math.max(data: float64[]): float64
	<.main+9411 @053a22> : 02                         call
	<.main+9412 @053a23> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9415 @053a26> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:41: (106 bytes: <@053a2a> - <@053a94>): testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9419 @053a2a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9428 @053a33> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9437 @053a3c> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9446 @053a45> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9455 @053a4e> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9464 @053a57> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9473 @053a60> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9482 @053a69> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9491 @053a72> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9500 @053a7b> : 1c 09 00 00 00             load.c32 9
	<.main+9505 @053a80> : 0a 04 00 00                load.sp(+4)
	<.main+9509 @053a84> : 1a                         load.z64
	<.main+9510 @053a85> : 11 02                      dup.x2 sp(2)
	<.main+9512 @053a87> : 1f 38 04 05 00             load.ref <@050438> ;Math.max(data: float64[]): float64
	<.main+9517 @053a8c> : 02                         call
	<.main+9518 @053a8d> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9521 @053a90> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:43: (21 bytes: <@053a94> - <@053aa9>): testMathSum_0: float64 := Math.sum()
	<.main+9525 @053a94> : 19                         load.z32
	<.main+9526 @053a95> : 0a 04 00 00                load.sp(+4)
	<.main+9530 @053a99> : 1a                         load.z64
	<.main+9531 @053a9a> : 11 02                      dup.x2 sp(2)
	<.main+9533 @053a9c> : 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+9538 @053aa1> : 02                         call
	<.main+9539 @053aa2> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9542 @053aa5> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:44: (34 bytes: <@053aa9> - <@053acb>): testMathSum_1: float64 := Math.sum(1)
	<.main+9546 @053aa9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9555 @053ab2> : 1c 01 00 00 00             load.c32 1
	<.main+9560 @053ab7> : 0a 04 00 00                load.sp(+4)
	<.main+9564 @053abb> : 1a                         load.z64
	<.main+9565 @053abc> : 11 02                      dup.x2 sp(2)
	<.main+9567 @053abe> : 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+9572 @053ac3> : 02                         call
	<.main+9573 @053ac4> : 17 06 02                   mov.x2 sp(6, 2)
	<.main+9576 @053ac7> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:45: (43 bytes: <@053acb> - <@053af6>): testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+9580 @053acb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9589 @053ad4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9598 @053add> : 1c 02 00 00 00             load.c32 2
	<.main+9603 @053ae2> : 0a 04 00 00                load.sp(+4)
	<.main+9607 @053ae6> : 1a                         load.z64
	<.main+9608 @053ae7> : 11 02                      dup.x2 sp(2)
	<.main+9610 @053ae9> : 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+9615 @053aee> : 02                         call
	<.main+9616 @053aef> : 17 08 02                   mov.x2 sp(8, 2)
	<.main+9619 @053af2> : 09 e0 ff ff                inc.sp(-32)
	test/stdc/test.math.ci:46: (115 bytes: <@053af6> - <@053b69>): testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+9623 @053af6> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9632 @053aff> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9641 @053b08> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9650 @053b11> : 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+9659 @053b1a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9668 @053b23> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9677 @053b2c> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+9686 @053b35> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9695 @053b3e> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9704 @053b47> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9713 @053b50> : 1c 0a 00 00 00             load.c32 10
	<.main+9718 @053b55> : 0a 04 00 00                load.sp(+4)
	<.main+9722 @053b59> : 1a                         load.z64
	<.main+9723 @053b5a> : 11 02                      dup.x2 sp(2)
	<.main+9725 @053b5c> : 1f 80 04 05 00             load.ref <@050480> ;Math.sum(data: float64[]): float64
	<.main+9730 @053b61> : 02                         call
	<.main+9731 @053b62> : 17 18 02                   mov.x2 sp(24, 2)
	<.main+9734 @053b65> : 09 a0 ff ff                inc.sp(-96)
	test/stdc/test.math.ci:48: (9 bytes: <@053b69> - <@053b72>): testMathEval_x: float64 := 10
	<.main+9738 @053b69> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	test/stdc/test.math.ci:49: (23 bytes: <@053b72> - <@053b89>): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+9747 @053b72> : 19                         load.z32
	<.main+9748 @053b73> : 0a 04 00 00                load.sp(+4)
	<.main+9752 @053b77> : 1a                         load.z64
	<.main+9753 @053b78> : 11 04                      dup.x2 sp(4)
	<.main+9755 @053b7a> : 11 04                      dup.x2 sp(4)
	<.main+9757 @053b7c> : 1f a8 04 05 00             load.ref <@0504a8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9762 @053b81> : 02                         call
	<.main+9763 @053b82> : 17 06 04                   mov.x2 sp(6, 4)
	<.main+9766 @053b85> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:50: (9 bytes: <@053b89> - <@053b92>): testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+9770 @053b89> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	test/stdc/test.math.ci:51: (22 bytes: <@053b92> - <@053ba8>): testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+9779 @053b92> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9788 @053b9b> : 11 06                      dup.x2 sp(6)
	<.main+9790 @053b9d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9799 @053ba6> : 83                         mul.f64
	<.main+9800 @053ba7> : 81                         add.f64
	test/stdc/test.math.ci:52: (39 bytes: <@053ba8> - <@053bcf>): testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+9801 @053ba8> : 11 06                      dup.x2 sp(6)
	<.main+9803 @053baa> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9812 @053bb3> : 11 02                      dup.x2 sp(2)
	<.main+9814 @053bb5> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9823 @053bbe> : 11 06                      dup.x2 sp(6)
	<.main+9825 @053bc0> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9834 @053bc9> : 83                         mul.f64
	<.main+9835 @053bca> : 81                         add.f64
	<.main+9836 @053bcb> : 83                         mul.f64
	<.main+9837 @053bcc> : 81                         add.f64
	<.main+9838 @053bcd> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:53: (56 bytes: <@053bcf> - <@053c07>): testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9840 @053bcf> : 11 08                      dup.x2 sp(8)
	<.main+9842 @053bd1> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9851 @053bda> : 11 02                      dup.x2 sp(2)
	<.main+9853 @053bdc> : 11 04                      dup.x2 sp(4)
	<.main+9855 @053bde> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9864 @053be7> : 11 02                      dup.x2 sp(2)
	<.main+9866 @053be9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9875 @053bf2> : 11 06                      dup.x2 sp(6)
	<.main+9877 @053bf4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9886 @053bfd> : 83                         mul.f64
	<.main+9887 @053bfe> : 81                         add.f64
	<.main+9888 @053bff> : 83                         mul.f64
	<.main+9889 @053c00> : 81                         add.f64
	<.main+9890 @053c01> : 14 02                      set.x2 sp(2)
	<.main+9892 @053c03> : 83                         mul.f64
	<.main+9893 @053c04> : 81                         add.f64
	<.main+9894 @053c05> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:54: (72 bytes: <@053c07> - <@053c4f>): testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9896 @053c07> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9905 @053c10> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9914 @053c19> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9923 @053c22> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9932 @053c2b> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9941 @053c34> : 1c 05 00 00 00             load.c32 5
	<.main+9946 @053c39> : 0a 04 00 00                load.sp(+4)
	<.main+9950 @053c3d> : 1a                         load.z64
	<.main+9951 @053c3e> : 11 18                      dup.x2 sp(24)
	<.main+9953 @053c40> : 11 04                      dup.x2 sp(4)
	<.main+9955 @053c42> : 1f a8 04 05 00             load.ref <@0504a8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9960 @053c47> : 02                         call
	<.main+9961 @053c48> : 17 10 04                   mov.x2 sp(16, 4)
	<.main+9964 @053c4b> : 09 c0 ff ff                inc.sp(-64)
	test/stdc/test.math.ci:55: (81 bytes: <@053c4f> - <@053ca0>): testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9968 @053c4f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9977 @053c58> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9986 @053c61> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9995 @053c6a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10004 @053c73>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10013 @053c7c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10022 @053c85>: 1c 06 00 00 00             load.c32 6
	<.main+10027 @053c8a>: 0a 04 00 00                load.sp(+4)
	<.main+10031 @053c8e>: 1a                         load.z64
	<.main+10032 @053c8f>: 11 1c                      dup.x2 sp(28)
	<.main+10034 @053c91>: 11 04                      dup.x2 sp(4)
	<.main+10036 @053c93>: 1f a8 04 05 00             load.ref <@0504a8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10041 @053c98>: 02                         call
	<.main+10042 @053c99>: 17 12 04                   mov.x2 sp(18, 4)
	<.main+10045 @053c9c>: 09 b8 ff ff                inc.sp(-72)
	test/stdc/test.math.ci:57: (31 bytes: <@053ca0> - <@053cbf>): testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10049 @053ca0>: 1a                         load.z64
	<.main+10050 @053ca1>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10059 @053caa>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10068 @053cb3>: 84                         div.f64
	<.main+10069 @053cb4>: 19                         load.z32
	<.main+10070 @053cb5>: 1f 58 05 05 00             load.ref <@050558> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10075 @053cba>: 02                         call
	<.main+10076 @053cbb>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:58: (45 bytes: <@053cbf> - <@053cec>): testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10080 @053cbf>: 1b                         load.z128
	<.main+10081 @053cc0>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10090 @053cc9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10099 @053cd2>: 84                         div.f64
	<.main+10100 @053cd3>: 1f f8 02 05 00             load.ref <@0502f8> ;Math.abs(x: float64): float64
	<.main+10105 @053cd8>: 02                         call
	<.main+10106 @053cd9>: 09 f8 ff ff                inc.sp(-8)
	<.main+10110 @053cdd>: 1c 01 00 00 00             load.c32 1
	<.main+10115 @053ce2>: 1f 58 05 05 00             load.ref <@050558> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10120 @053ce7>: 02                         call
	<.main+10121 @053ce8>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:59: (30 bytes: <@053cec> - <@053d0a>): testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10125 @053cec>: 1a                         load.z64
	<.main+10126 @053ced>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10135 @053cf6>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10144 @053cff>: 84                         div.f64
	<.main+10145 @053d00>: 1f a8 06 05 00             load.ref <@0506a8> ;Math.tan(arg: float64): float64
	<.main+10150 @053d05>: 02                         call
	<.main+10151 @053d06>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:60: (30 bytes: <@053d0a> - <@053d28>): testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10155 @053d0a>: 1a                         load.z64
	<.main+10156 @053d0b>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10165 @053d14>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10174 @053d1d>: 84                         div.f64
	<.main+10175 @053d1e>: 1f 20 08 05 00             load.ref <@050820> ;Math.sinh(x: float64): float64
	<.main+10180 @053d23>: 02                         call
	<.main+10181 @053d24>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:61: (30 bytes: <@053d28> - <@053d46>): testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10185 @053d28>: 1a                         load.z64
	<.main+10186 @053d29>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10195 @053d32>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10204 @053d3b>: 84                         div.f64
	<.main+10205 @053d3c>: 1f 18 09 05 00             load.ref <@050918> ;Math.cosh(x: float64): float64
	<.main+10210 @053d41>: 02                         call
	<.main+10211 @053d42>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:63: (20 bytes: <@053d46> - <@053d5a>): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10215 @053d46>: 1a                         load.z64
	<.main+10216 @053d47>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10225 @053d50>: 1f 68 09 05 00             load.ref <@050968> ;Math.asin(x: float64): float64
	<.main+10230 @053d55>: 02                         call
	<.main+10231 @053d56>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:64: (40 bytes: <@053d5a> - <@053d82>): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10235 @053d5a>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10244 @053d63>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10253 @053d6c>: 84                         div.f64
	<.main+10254 @053d6d>: 1a                         load.z64
	<.main+10255 @053d6e>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10264 @053d77>: 1f 68 09 05 00             load.ref <@050968> ;Math.asin(x: float64): float64
	<.main+10269 @053d7c>: 02                         call
	<.main+10270 @053d7d>: 09 f8 ff ff                inc.sp(-8)
	<.main+10274 @053d81>: 82                         sub.f64
	test/stdc/test.math.ci:67: (28 bytes: <@053d82> - <@053d9e>): testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10275 @053d82>: 19                         load.z32
	<.main+10276 @053d83>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10281 @053d88>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10286 @053d8d>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10291 @053d92>: 1f d8 04 05 00             load.ref <@0504d8> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10296 @053d97>: 02                         call
	<.main+10297 @053d98>: 09 f4 ff ff                inc.sp(-12)
	<.main+10301 @053d9c>: 19                         load.z32
	<.main+10302 @053d9d>: 57                         ceq.i32
	test/stdc/test.math.ci:68: (40 bytes: <@053d9e> - <@053dc6>): testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10303 @053d9e>: 19                         load.z32
	<.main+10304 @053d9f>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10313 @053da8>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10322 @053db1>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10331 @053dba>: 1f 18 05 05 00             load.ref <@050518> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10336 @053dbf>: 02                         call
	<.main+10337 @053dc0>: 09 e8 ff ff                inc.sp(-24)
	<.main+10341 @053dc4>: 19                         load.z32
	<.main+10342 @053dc5>: 57                         ceq.i32
	test/stdc/test.math.ci:70: (29 bytes: <@053dc6> - <@053de3>): testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10343 @053dc6>: 1a                         load.z64
	<.main+10344 @053dc7>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10353 @053dd0>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10362 @053dd9>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10367 @053dde>: 02                         call
	<.main+10368 @053ddf>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:71: (20 bytes: <@053de3> - <@053df7>): testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+10372 @053de3>: 1b                         load.z128
	<.main+10373 @053de4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10382 @053ded>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10387 @053df2>: 02                         call
	<.main+10388 @053df3>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:72: (29 bytes: <@053df7> - <@053e14>): testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+10392 @053df7>: 1a                         load.z64
	<.main+10393 @053df8>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+10402 @053e01>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10411 @053e0a>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10416 @053e0f>: 02                         call
	<.main+10417 @053e10>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:74: (29 bytes: <@053e14> - <@053e31>): testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+10421 @053e14>: 1a                         load.z64
	<.main+10422 @053e15>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+10431 @053e1e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10440 @053e27>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10445 @053e2c>: 02                         call
	<.main+10446 @053e2d>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:75: (29 bytes: <@053e31> - <@053e4e>): testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+10450 @053e31>: 1a                         load.z64
	<.main+10451 @053e32>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10460 @053e3b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10469 @053e44>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10474 @053e49>: 02                         call
	<.main+10475 @053e4a>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:76: (29 bytes: <@053e4e> - <@053e6b>): testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+10479 @053e4e>: 1a                         load.z64
	<.main+10480 @053e4f>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+10489 @053e58>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10498 @053e61>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10503 @053e66>: 02                         call
	<.main+10504 @053e67>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:77: (29 bytes: <@053e6b> - <@053e88>): testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+10508 @053e6b>: 1a                         load.z64
	<.main+10509 @053e6c>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+10518 @053e75>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10527 @053e7e>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10532 @053e83>: 02                         call
	<.main+10533 @053e84>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:79: (29 bytes: <@053e88> - <@053ea5>): testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+10537 @053e88>: 1a                         load.z64
	<.main+10538 @053e89>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+10547 @053e92>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10556 @053e9b>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10561 @053ea0>: 02                         call
	<.main+10562 @053ea1>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:80: (29 bytes: <@053ea5> - <@053ec2>): testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+10566 @053ea5>: 1a                         load.z64
	<.main+10567 @053ea6>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10576 @053eaf>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10585 @053eb8>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10590 @053ebd>: 02                         call
	<.main+10591 @053ebe>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:81: (29 bytes: <@053ec2> - <@053edf>): testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+10595 @053ec2>: 1a                         load.z64
	<.main+10596 @053ec3>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+10605 @053ecc>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10614 @053ed5>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10619 @053eda>: 02                         call
	<.main+10620 @053edb>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:82: (29 bytes: <@053edf> - <@053efc>): testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+10624 @053edf>: 1a                         load.z64
	<.main+10625 @053ee0>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+10634 @053ee9>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10643 @053ef2>: 1f 30 03 05 00             load.ref <@050330> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10648 @053ef7>: 02                         call
	<.main+10649 @053ef8>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:84: (21 bytes: <@053efc> - <@053f11>): testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+10653 @053efc>: 19                         load.z32
	<.main+10654 @053efd>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10659 @053f02>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10664 @053f07>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10669 @053f0c>: 02                         call
	<.main+10670 @053f0d>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:85: (17 bytes: <@053f11> - <@053f22>): testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+10674 @053f11>: 19                         load.z32
	<.main+10675 @053f12>: 19                         load.z32
	<.main+10676 @053f13>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10681 @053f18>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10686 @053f1d>: 02                         call
	<.main+10687 @053f1e>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:86: (21 bytes: <@053f22> - <@053f37>): testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+10691 @053f22>: 19                         load.z32
	<.main+10692 @053f23>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+10697 @053f28>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10702 @053f2d>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10707 @053f32>: 02                         call
	<.main+10708 @053f33>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:88: (21 bytes: <@053f37> - <@053f4c>): testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+10712 @053f37>: 19                         load.z32
	<.main+10713 @053f38>: 7f 00 00 98 41             load.f32 19.000000
	<.main+10718 @053f3d>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10723 @053f42>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10728 @053f47>: 02                         call
	<.main+10729 @053f48>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:89: (21 bytes: <@053f4c> - <@053f61>): testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+10733 @053f4c>: 19                         load.z32
	<.main+10734 @053f4d>: 7f 00 00 10 41             load.f32 9.000000
	<.main+10739 @053f52>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10744 @053f57>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10749 @053f5c>: 02                         call
	<.main+10750 @053f5d>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:90: (21 bytes: <@053f61> - <@053f76>): testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+10754 @053f61>: 19                         load.z32
	<.main+10755 @053f62>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+10760 @053f67>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10765 @053f6c>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10770 @053f71>: 02                         call
	<.main+10771 @053f72>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:91: (21 bytes: <@053f76> - <@053f8b>): testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+10775 @053f76>: 19                         load.z32
	<.main+10776 @053f77>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+10781 @053f7c>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10786 @053f81>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10791 @053f86>: 02                         call
	<.main+10792 @053f87>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:93: (21 bytes: <@053f8b> - <@053fa0>): testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+10796 @053f8b>: 19                         load.z32
	<.main+10797 @053f8c>: 7f 00 00 90 41             load.f32 18.000000
	<.main+10802 @053f91>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10807 @053f96>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10812 @053f9b>: 02                         call
	<.main+10813 @053f9c>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:94: (21 bytes: <@053fa0> - <@053fb5>): testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+10817 @053fa0>: 19                         load.z32
	<.main+10818 @053fa1>: 7f 00 00 00 41             load.f32 8.000000
	<.main+10823 @053fa6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10828 @053fab>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10833 @053fb0>: 02                         call
	<.main+10834 @053fb1>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:95: (21 bytes: <@053fb5> - <@053fca>): testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+10838 @053fb5>: 19                         load.z32
	<.main+10839 @053fb6>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+10844 @053fbb>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10849 @053fc0>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10854 @053fc5>: 02                         call
	<.main+10855 @053fc6>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:96: (21 bytes: <@053fca> - <@053fdf>): testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+10859 @053fca>: 19                         load.z32
	<.main+10860 @053fcb>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+10865 @053fd0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10870 @053fd5>: 1f 10 03 05 00             load.ref <@050310> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10875 @053fda>: 02                         call
	<.main+10876 @053fdb>: 09 f8 ff ff                inc.sp(-8)
	<.main+10880 @053fdf>: 01 00 00 00                nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code
[ 246.04] > .main
[ 246.63]  > funAdd(x: int32, y: int32): int32
[ 246.65]  < return
[ 246.66]  > funAdd(x: int32, y: int32): int32
[ 246.67]  < return
[ 246.69]  > funMul(x: int32, y: int32): int32
[ 246.69]  < return
[ 246.71]  > funMul(x: int32, y: int32): int32
[ 246.72]  < return
[ 246.73]  > fib(n: uint32): uint32
[ 246.75]   > fib(n: uint32): uint32
[ 246.76]    > fib(n: uint32): uint32
[ 246.77]     > fib(n: uint32): uint32
[ 246.78]      > fib(n: uint32): uint32
[ 246.80]       > fib(n: uint32): uint32
[ 246.81]        > fib(n: uint32): uint32
[ 246.82]         > fib(n: uint32): uint32
[ 246.83]          > fib(n: uint32): uint32
[ 246.85]           > fib(n: uint32): uint32
[ 246.86]            > fib(n: uint32): uint32
[ 246.87]             > fib(n: uint32): uint32
[ 246.88]              > fib(n: uint32): uint32
[ 246.90]              < return
[ 246.91]              > fib(n: uint32): uint32
[ 246.92]              < return
[ 246.92]             < return
[ 246.93]             > fib(n: uint32): uint32
[ 246.94]             < return
[ 246.95]            < return
[ 246.96]            > fib(n: uint32): uint32
[ 246.97]             > fib(n: uint32): uint32
[ 246.98]             < return
[ 246.99]             > fib(n: uint32): uint32
[ 247.00]             < return
[ 247.01]            < return
[ 247.02]           < return
[ 247.03]           > fib(n: uint32): uint32
[ 247.04]            > fib(n: uint32): uint32
[ 247.06]             > fib(n: uint32): uint32
[ 247.07]             < return
[ 247.07]             > fib(n: uint32): uint32
[ 247.09]             < return
[ 247.09]            < return
[ 247.10]            > fib(n: uint32): uint32
[ 247.11]            < return
[ 247.12]           < return
[ 247.13]          < return
[ 247.14]          > fib(n: uint32): uint32
[ 247.15]           > fib(n: uint32): uint32
[ 247.16]            > fib(n: uint32): uint32
[ 247.18]             > fib(n: uint32): uint32
[ 247.19]             < return
[ 247.19]             > fib(n: uint32): uint32
[ 247.21]             < return
[ 247.21]            < return
[ 247.22]            > fib(n: uint32): uint32
[ 247.23]            < return
[ 247.24]           < return
[ 247.25]           > fib(n: uint32): uint32
[ 247.26]            > fib(n: uint32): uint32
[ 247.27]            < return
[ 247.28]            > fib(n: uint32): uint32
[ 247.29]            < return
[ 247.30]           < return
[ 247.31]          < return
[ 247.32]         < return
[ 247.33]         > fib(n: uint32): uint32
[ 247.34]          > fib(n: uint32): uint32
[ 247.35]           > fib(n: uint32): uint32
[ 247.36]            > fib(n: uint32): uint32
[ 247.38]             > fib(n: uint32): uint32
[ 247.39]             < return
[ 247.40]             > fib(n: uint32): uint32
[ 247.41]             < return
[ 247.42]            < return
[ 247.43]            > fib(n: uint32): uint32
[ 247.44]            < return
[ 247.44]           < return
[ 247.45]           > fib(n: uint32): uint32
[ 247.47]            > fib(n: uint32): uint32
[ 247.48]            < return
[ 247.49]            > fib(n: uint32): uint32
[ 247.50]            < return
[ 247.50]           < return
[ 247.51]          < return
[ 247.52]          > fib(n: uint32): uint32
[ 247.53]           > fib(n: uint32): uint32
[ 247.55]            > fib(n: uint32): uint32
[ 247.56]            < return
[ 247.57]            > fib(n: uint32): uint32
[ 247.58]            < return
[ 247.59]           < return
[ 247.59]           > fib(n: uint32): uint32
[ 247.60]           < return
[ 247.61]          < return
[ 247.62]         < return
[ 247.63]        < return
[ 247.64]        > fib(n: uint32): uint32
[ 247.65]         > fib(n: uint32): uint32
[ 247.66]          > fib(n: uint32): uint32
[ 247.67]           > fib(n: uint32): uint32
[ 247.69]            > fib(n: uint32): uint32
[ 247.70]             > fib(n: uint32): uint32
[ 247.71]             < return
[ 247.72]             > fib(n: uint32): uint32
[ 247.73]             < return
[ 247.74]            < return
[ 247.75]            > fib(n: uint32): uint32
[ 247.76]            < return
[ 247.76]           < return
[ 247.77]           > fib(n: uint32): uint32
[ 247.79]            > fib(n: uint32): uint32
[ 247.80]            < return
[ 247.81]            > fib(n: uint32): uint32
[ 247.82]            < return
[ 247.82]           < return
[ 247.83]          < return
[ 247.84]          > fib(n: uint32): uint32
[ 247.86]           > fib(n: uint32): uint32
[ 247.87]            > fib(n: uint32): uint32
[ 247.88]            < return
[ 247.89]            > fib(n: uint32): uint32
[ 247.90]            < return
[ 247.91]           < return
[ 247.92]           > fib(n: uint32): uint32
[ 247.93]           < return
[ 247.94]          < return
[ 247.94]         < return
[ 247.95]         > fib(n: uint32): uint32
[ 247.97]          > fib(n: uint32): uint32
[ 247.98]           > fib(n: uint32): uint32
[ 247.99]            > fib(n: uint32): uint32
[ 248.00]            < return
[ 248.01]            > fib(n: uint32): uint32
[ 248.02]            < return
[ 248.03]           < return
[ 248.04]           > fib(n: uint32): uint32
[ 248.05]           < return
[ 248.06]          < return
[ 248.07]          > fib(n: uint32): uint32
[ 248.08]           > fib(n: uint32): uint32
[ 248.09]           < return
[ 248.10]           > fib(n: uint32): uint32
[ 248.11]           < return
[ 248.12]          < return
[ 248.12]         < return
[ 248.13]        < return
[ 248.14]       < return
[ 248.15]       > fib(n: uint32): uint32
[ 248.16]        > fib(n: uint32): uint32
[ 248.18]         > fib(n: uint32): uint32
[ 248.19]          > fib(n: uint32): uint32
[ 248.20]           > fib(n: uint32): uint32
[ 248.21]            > fib(n: uint32): uint32
[ 248.23]             > fib(n: uint32): uint32
[ 248.24]             < return
[ 248.25]             > fib(n: uint32): uint32
[ 248.26]             < return
[ 248.26]            < return
[ 248.27]            > fib(n: uint32): uint32
[ 248.28]            < return
[ 248.29]           < return
[ 248.30]           > fib(n: uint32): uint32
[ 248.31]            > fib(n: uint32): uint32
[ 248.32]            < return
[ 248.34]            > fib(n: uint32): uint32
[ 248.35]            < return
[ 248.35]           < return
[ 248.36]          < return
[ 248.37]          > fib(n: uint32): uint32
[ 248.38]           > fib(n: uint32): uint32
[ 248.40]            > fib(n: uint32): uint32
[ 248.41]            < return
[ 248.42]            > fib(n: uint32): uint32
[ 248.43]            < return
[ 248.44]           < return
[ 248.44]           > fib(n: uint32): uint32
[ 248.46]           < return
[ 248.46]          < return
[ 248.47]         < return
[ 248.48]         > fib(n: uint32): uint32
[ 248.49]          > fib(n: uint32): uint32
[ 248.50]           > fib(n: uint32): uint32
[ 248.52]            > fib(n: uint32): uint32
[ 248.53]            < return
[ 248.54]            > fib(n: uint32): uint32
[ 248.55]            < return
[ 248.56]           < return
[ 248.56]           > fib(n: uint32): uint32
[ 248.58]           < return
[ 248.58]          < return
[ 248.59]          > fib(n: uint32): uint32
[ 248.60]           > fib(n: uint32): uint32
[ 248.62]           < return
[ 248.62]           > fib(n: uint32): uint32
[ 248.64]           < return
[ 248.64]          < return
[ 248.65]         < return
[ 248.66]        < return
[ 248.67]        > fib(n: uint32): uint32
[ 248.68]         > fib(n: uint32): uint32
[ 248.69]          > fib(n: uint32): uint32
[ 248.71]           > fib(n: uint32): uint32
[ 248.72]            > fib(n: uint32): uint32
[ 248.73]            < return
[ 248.74]            > fib(n: uint32): uint32
[ 248.75]            < return
[ 248.76]           < return
[ 248.77]           > fib(n: uint32): uint32
[ 248.78]           < return
[ 248.79]          < return
[ 248.79]          > fib(n: uint32): uint32
[ 248.81]           > fib(n: uint32): uint32
[ 248.82]           < return
[ 248.83]           > fib(n: uint32): uint32
[ 248.84]           < return
[ 248.85]          < return
[ 248.85]         < return
[ 248.86]         > fib(n: uint32): uint32
[ 248.88]          > fib(n: uint32): uint32
[ 248.89]           > fib(n: uint32): uint32
[ 248.90]           < return
[ 248.91]           > fib(n: uint32): uint32
[ 248.92]           < return
[ 248.93]          < return
[ 248.94]          > fib(n: uint32): uint32
[ 248.95]          < return
[ 248.95]         < return
[ 248.96]        < return
[ 248.97]       < return
[ 248.98]      < return
[ 248.99]      > fib(n: uint32): uint32
[ 249.00]       > fib(n: uint32): uint32
[ 249.01]        > fib(n: uint32): uint32
[ 249.03]         > fib(n: uint32): uint32
[ 249.04]          > fib(n: uint32): uint32
[ 249.05]           > fib(n: uint32): uint32
[ 249.07]            > fib(n: uint32): uint32
[ 249.09]             > fib(n: uint32): uint32
[ 249.11]             < return
[ 249.12]             > fib(n: uint32): uint32
[ 249.13]             < return
[ 249.13]            < return
[ 249.14]            > fib(n: uint32): uint32
[ 249.15]            < return
[ 249.16]           < return
[ 249.17]           > fib(n: uint32): uint32
[ 249.18]            > fib(n: uint32): uint32
[ 249.19]            < return
[ 249.20]            > fib(n: uint32): uint32
[ 249.22]            < return
[ 249.22]           < return
[ 249.23]          < return
[ 249.24]          > fib(n: uint32): uint32
[ 249.25]           > fib(n: uint32): uint32
[ 249.26]            > fib(n: uint32): uint32
[ 249.28]            < return
[ 249.28]            > fib(n: uint32): uint32
[ 249.29]            < return
[ 249.30]           < return
[ 249.31]           > fib(n: uint32): uint32
[ 249.32]           < return
[ 249.33]          < return
[ 249.34]         < return
[ 249.35]         > fib(n: uint32): uint32
[ 249.36]          > fib(n: uint32): uint32
[ 249.37]           > fib(n: uint32): uint32
[ 249.40]            > fib(n: uint32): uint32
[ 249.41]            < return
[ 249.41]            > fib(n: uint32): uint32
[ 249.42]            < return
[ 249.43]           < return
[ 249.45]           > fib(n: uint32): uint32
[ 249.46]           < return
[ 249.47]          < return
[ 249.48]          > fib(n: uint32): uint32
[ 249.49]           > fib(n: uint32): uint32
[ 249.50]           < return
[ 249.51]           > fib(n: uint32): uint32
[ 249.52]           < return
[ 249.53]          < return
[ 249.54]         < return
[ 249.54]        < return
[ 249.55]        > fib(n: uint32): uint32
[ 249.57]         > fib(n: uint32): uint32
[ 249.58]          > fib(n: uint32): uint32
[ 249.59]           > fib(n: uint32): uint32
[ 249.60]            > fib(n: uint32): uint32
[ 249.61]            < return
[ 249.62]            > fib(n: uint32): uint32
[ 249.63]            < return
[ 249.64]           < return
[ 249.65]           > fib(n: uint32): uint32
[ 249.66]           < return
[ 249.67]          < return
[ 249.68]          > fib(n: uint32): uint32
[ 249.69]           > fib(n: uint32): uint32
[ 249.70]           < return
[ 249.71]           > fib(n: uint32): uint32
[ 249.72]           < return
[ 249.73]          < return
[ 249.74]         < return
[ 249.75]         > fib(n: uint32): uint32
[ 249.76]          > fib(n: uint32): uint32
[ 249.77]           > fib(n: uint32): uint32
[ 249.78]           < return
[ 249.79]           > fib(n: uint32): uint32
[ 249.80]           < return
[ 249.81]          < return
[ 249.82]          > fib(n: uint32): uint32
[ 249.83]          < return
[ 249.84]         < return
[ 249.85]        < return
[ 249.85]       < return
[ 249.86]       > fib(n: uint32): uint32
[ 249.88]        > fib(n: uint32): uint32
[ 249.89]         > fib(n: uint32): uint32
[ 249.90]          > fib(n: uint32): uint32
[ 249.91]           > fib(n: uint32): uint32
[ 249.93]            > fib(n: uint32): uint32
[ 249.94]            < return
[ 249.94]            > fib(n: uint32): uint32
[ 249.96]            < return
[ 249.97]           < return
[ 249.98]           > fib(n: uint32): uint32
[ 249.99]           < return
[ 250.00]          < return
[ 250.01]          > fib(n: uint32): uint32
[ 250.02]           > fib(n: uint32): uint32
[ 250.03]           < return
[ 250.04]           > fib(n: uint32): uint32
[ 250.05]           < return
[ 250.06]          < return
[ 250.07]         < return
[ 250.07]         > fib(n: uint32): uint32
[ 250.09]          > fib(n: uint32): uint32
[ 250.10]           > fib(n: uint32): uint32
[ 250.11]           < return
[ 250.12]           > fib(n: uint32): uint32
[ 250.13]           < return
[ 250.14]          < return
[ 250.15]          > fib(n: uint32): uint32
[ 250.16]          < return
[ 250.17]         < return
[ 250.18]        < return
[ 250.18]        > fib(n: uint32): uint32
[ 250.20]         > fib(n: uint32): uint32
[ 250.21]          > fib(n: uint32): uint32
[ 250.22]           > fib(n: uint32): uint32
[ 250.23]           < return
[ 250.24]           > fib(n: uint32): uint32
[ 250.25]           < return
[ 250.26]          < return
[ 250.27]          > fib(n: uint32): uint32
[ 250.28]          < return
[ 250.29]         < return
[ 250.30]         > fib(n: uint32): uint32
[ 250.31]          > fib(n: uint32): uint32
[ 250.32]          < return
[ 250.33]          > fib(n: uint32): uint32
[ 250.34]          < return
[ 250.35]         < return
[ 250.35]        < return
[ 250.36]       < return
[ 250.37]      < return
[ 250.38]     < return
[ 250.39]     > fib(n: uint32): uint32
[ 250.40]      > fib(n: uint32): uint32
[ 250.41]       > fib(n: uint32): uint32
[ 250.43]        > fib(n: uint32): uint32
[ 250.44]         > fib(n: uint32): uint32
[ 250.45]          > fib(n: uint32): uint32
[ 250.46]           > fib(n: uint32): uint32
[ 250.47]            > fib(n: uint32): uint32
[ 250.49]             > fib(n: uint32): uint32
[ 250.50]             < return
[ 250.51]             > fib(n: uint32): uint32
[ 250.52]             < return
[ 250.53]            < return
[ 250.53]            > fib(n: uint32): uint32
[ 250.54]            < return
[ 250.55]           < return
[ 250.56]           > fib(n: uint32): uint32
[ 250.57]            > fib(n: uint32): uint32
[ 250.59]            < return
[ 250.59]            > fib(n: uint32): uint32
[ 250.60]            < return
[ 250.61]           < return
[ 250.62]          < return
[ 250.63]          > fib(n: uint32): uint32
[ 250.64]           > fib(n: uint32): uint32
[ 250.65]            > fib(n: uint32): uint32
[ 250.66]            < return
[ 250.67]            > fib(n: uint32): uint32
[ 250.69]            < return
[ 250.69]           < return
[ 250.70]           > fib(n: uint32): uint32
[ 250.71]           < return
[ 250.72]          < return
[ 250.73]         < return
[ 250.74]         > fib(n: uint32): uint32
[ 250.75]          > fib(n: uint32): uint32
[ 250.76]           > fib(n: uint32): uint32
[ 250.77]            > fib(n: uint32): uint32
[ 250.78]            < return
[ 250.79]            > fib(n: uint32): uint32
[ 250.81]            < return
[ 250.81]           < return
[ 250.82]           > fib(n: uint32): uint32
[ 250.83]           < return
[ 250.84]          < return
[ 250.85]          > fib(n: uint32): uint32
[ 250.86]           > fib(n: uint32): uint32
[ 250.87]           < return
[ 250.88]           > fib(n: uint32): uint32
[ 250.89]           < return
[ 250.90]          < return
[ 250.91]         < return
[ 250.92]        < return
[ 250.93]        > fib(n: uint32): uint32
[ 250.94]         > fib(n: uint32): uint32
[ 250.95]          > fib(n: uint32): uint32
[ 250.96]           > fib(n: uint32): uint32
[ 250.97]            > fib(n: uint32): uint32
[ 250.99]            < return
[ 250.99]            > fib(n: uint32): uint32
[ 251.00]            < return
[ 251.01]           < return
[ 251.02]           > fib(n: uint32): uint32
[ 251.03]           < return
[ 251.04]          < return
[ 251.05]          > fib(n: uint32): uint32
[ 251.06]           > fib(n: uint32): uint32
[ 251.07]           < return
[ 251.08]           > fib(n: uint32): uint32
[ 251.09]           < return
[ 251.10]          < return
[ 251.11]         < return
[ 251.12]         > fib(n: uint32): uint32
[ 251.13]          > fib(n: uint32): uint32
[ 251.14]           > fib(n: uint32): uint32
[ 251.15]           < return
[ 251.16]           > fib(n: uint32): uint32
[ 251.17]           < return
[ 251.18]          < return
[ 251.19]          > fib(n: uint32): uint32
[ 251.20]          < return
[ 251.21]         < return
[ 251.22]        < return
[ 251.22]       < return
[ 251.23]       > fib(n: uint32): uint32
[ 251.24]        > fib(n: uint32): uint32
[ 251.26]         > fib(n: uint32): uint32
[ 251.27]          > fib(n: uint32): uint32
[ 251.28]           > fib(n: uint32): uint32
[ 251.30]            > fib(n: uint32): uint32
[ 251.31]            < return
[ 251.32]            > fib(n: uint32): uint32
[ 251.33]            < return
[ 251.34]           < return
[ 251.34]           > fib(n: uint32): uint32
[ 251.35]           < return
[ 251.36]          < return
[ 251.37]          > fib(n: uint32): uint32
[ 251.38]           > fib(n: uint32): uint32
[ 251.40]           < return
[ 251.41]           > fib(n: uint32): uint32
[ 251.41]           < return
[ 251.42]          < return
[ 251.43]         < return
[ 251.44]         > fib(n: uint32): uint32
[ 251.45]          > fib(n: uint32): uint32
[ 251.47]           > fib(n: uint32): uint32
[ 251.48]           < return
[ 251.49]           > fib(n: uint32): uint32
[ 251.50]           < return
[ 251.50]          < return
[ 251.51]          > fib(n: uint32): uint32
[ 251.52]          < return
[ 251.53]         < return
[ 251.54]        < return
[ 251.55]        > fib(n: uint32): uint32
[ 251.56]         > fib(n: uint32): uint32
[ 251.57]          > fib(n: uint32): uint32
[ 251.59]           > fib(n: uint32): uint32
[ 251.60]           < return
[ 251.61]           > fib(n: uint32): uint32
[ 251.62]           < return
[ 251.62]          < return
[ 251.63]          > fib(n: uint32): uint32
[ 251.64]          < return
[ 251.65]         < return
[ 251.66]         > fib(n: uint32): uint32
[ 251.67]          > fib(n: uint32): uint32
[ 251.69]          < return
[ 251.69]          > fib(n: uint32): uint32
[ 251.71]          < return
[ 251.71]         < return
[ 251.72]        < return
[ 251.73]       < return
[ 251.74]      < return
[ 251.75]      > fib(n: uint32): uint32
[ 251.76]       > fib(n: uint32): uint32
[ 251.77]        > fib(n: uint32): uint32
[ 251.78]         > fib(n: uint32): uint32
[ 251.79]          > fib(n: uint32): uint32
[ 251.81]           > fib(n: uint32): uint32
[ 251.82]            > fib(n: uint32): uint32
[ 251.83]            < return
[ 251.85]            > fib(n: uint32): uint32
[ 251.87]            < return
[ 251.88]           < return
[ 251.89]           > fib(n: uint32): uint32
[ 251.90]           < return
[ 251.91]          < return
[ 251.91]          > fib(n: uint32): uint32
[ 251.93]           > fib(n: uint32): uint32
[ 251.94]           < return
[ 251.95]           > fib(n: uint32): uint32
[ 251.96]           < return
[ 251.97]          < return
[ 251.97]         < return
[ 251.98]         > fib(n: uint32): uint32
[ 252.00]          > fib(n: uint32): uint32
[ 252.01]           > fib(n: uint32): uint32
[ 252.02]           < return
[ 252.03]           > fib(n: uint32): uint32
[ 252.04]           < return
[ 252.05]          < return
[ 252.06]          > fib(n: uint32): uint32
[ 252.07]          < return
[ 252.07]         < return
[ 252.08]        < return
[ 252.09]        > fib(n: uint32): uint32
[ 252.10]         > fib(n: uint32): uint32
[ 252.12]          > fib(n: uint32): uint32
[ 252.13]           > fib(n: uint32): uint32
[ 252.14]           < return
[ 252.15]           > fib(n: uint32): uint32
[ 252.16]           < return
[ 252.18]          < return
[ 252.19]          > fib(n: uint32): uint32
[ 252.19]          < return
[ 252.20]         < return
[ 252.22]         > fib(n: uint32): uint32
[ 252.23]          > fib(n: uint32): uint32
[ 252.24]          < return
[ 252.25]          > fib(n: uint32): uint32
[ 252.26]          < return
[ 252.27]         < return
[ 252.28]        < return
[ 252.29]       < return
[ 252.30]       > fib(n: uint32): uint32
[ 252.31]        > fib(n: uint32): uint32
[ 252.32]         > fib(n: uint32): uint32
[ 252.33]          > fib(n: uint32): uint32
[ 252.35]           > fib(n: uint32): uint32
[ 252.36]           < return
[ 252.37]           > fib(n: uint32): uint32
[ 252.38]           < return
[ 252.38]          < return
[ 252.39]          > fib(n: uint32): uint32
[ 252.41]          < return
[ 252.41]         < return
[ 252.42]         > fib(n: uint32): uint32
[ 252.43]          > fib(n: uint32): uint32
[ 252.44]          < return
[ 252.45]          > fib(n: uint32): uint32
[ 252.47]          < return
[ 252.48]         < return
[ 252.48]        < return
[ 252.49]        > fib(n: uint32): uint32
[ 252.50]         > fib(n: uint32): uint32
[ 252.52]          > fib(n: uint32): uint32
[ 252.53]          < return
[ 252.54]          > fib(n: uint32): uint32
[ 252.55]          < return
[ 252.56]         < return
[ 252.56]         > fib(n: uint32): uint32
[ 252.57]         < return
[ 252.58]        < return
[ 252.59]       < return
[ 252.60]      < return
[ 252.61]     < return
[ 252.62]    < return
[ 252.62]    > fib(n: uint32): uint32
[ 252.64]     > fib(n: uint32): uint32
[ 252.65]      > fib(n: uint32): uint32
[ 252.66]       > fib(n: uint32): uint32
[ 252.67]        > fib(n: uint32): uint32
[ 252.69]         > fib(n: uint32): uint32
[ 252.70]          > fib(n: uint32): uint32
[ 252.71]           > fib(n: uint32): uint32
[ 252.72]            > fib(n: uint32): uint32
[ 252.74]             > fib(n: uint32): uint32
[ 252.75]             < return
[ 252.76]             > fib(n: uint32): uint32
[ 252.77]             < return
[ 252.78]            < return
[ 252.78]            > fib(n: uint32): uint32
[ 252.79]            < return
[ 252.80]           < return
[ 252.81]           > fib(n: uint32): uint32
[ 252.82]            > fib(n: uint32): uint32
[ 252.83]            < return
[ 252.84]            > fib(n: uint32): uint32
[ 252.85]            < return
[ 252.86]           < return
[ 252.87]          < return
[ 252.88]          > fib(n: uint32): uint32
[ 252.89]           > fib(n: uint32): uint32
[ 252.90]            > fib(n: uint32): uint32
[ 252.91]            < return
[ 252.92]            > fib(n: uint32): uint32
[ 252.94]            < return
[ 252.94]           < return
[ 252.95]           > fib(n: uint32): uint32
[ 252.96]           < return
[ 252.97]          < return
[ 252.98]         < return
[ 252.99]         > fib(n: uint32): uint32
[ 253.00]          > fib(n: uint32): uint32
[ 253.01]           > fib(n: uint32): uint32
[ 253.03]            > fib(n: uint32): uint32
[ 253.04]            < return
[ 253.04]            > fib(n: uint32): uint32
[ 253.06]            < return
[ 253.06]           < return
[ 253.07]           > fib(n: uint32): uint32
[ 253.08]           < return
[ 253.09]          < return
[ 253.10]          > fib(n: uint32): uint32
[ 253.11]           > fib(n: uint32): uint32
[ 253.12]           < return
[ 253.13]           > fib(n: uint32): uint32
[ 253.14]           < return
[ 253.15]          < return
[ 253.16]         < return
[ 253.17]        < return
[ 253.18]        > fib(n: uint32): uint32
[ 253.19]         > fib(n: uint32): uint32
[ 253.20]          > fib(n: uint32): uint32
[ 253.21]           > fib(n: uint32): uint32
[ 253.24]            > fib(n: uint32): uint32
[ 253.25]            < return
[ 253.26]            > fib(n: uint32): uint32
[ 253.28]            < return
[ 253.28]           < return
[ 253.29]           > fib(n: uint32): uint32
[ 253.30]           < return
[ 253.31]          < return
[ 253.32]          > fib(n: uint32): uint32
[ 253.33]           > fib(n: uint32): uint32
[ 253.34]           < return
[ 253.35]           > fib(n: uint32): uint32
[ 253.36]           < return
[ 253.37]          < return
[ 253.38]         < return
[ 253.39]         > fib(n: uint32): uint32
[ 253.40]          > fib(n: uint32): uint32
[ 253.41]           > fib(n: uint32): uint32
[ 253.42]           < return
[ 253.43]           > fib(n: uint32): uint32
[ 253.44]           < return
[ 253.45]          < return
[ 253.46]          > fib(n: uint32): uint32
[ 253.47]          < return
[ 253.48]         < return
[ 253.49]        < return
[ 253.50]       < return
[ 253.50]       > fib(n: uint32): uint32
[ 253.52]        > fib(n: uint32): uint32
[ 253.53]         > fib(n: uint32): uint32
[ 253.54]          > fib(n: uint32): uint32
[ 253.55]           > fib(n: uint32): uint32
[ 253.57]            > fib(n: uint32): uint32
[ 253.59]            < return
[ 253.59]            > fib(n: uint32): uint32
[ 253.60]            < return
[ 253.61]           < return
[ 253.62]           > fib(n: uint32): uint32
[ 253.64]           < return
[ 253.65]          < return
[ 253.66]          > fib(n: uint32): uint32
[ 253.67]           > fib(n: uint32): uint32
[ 253.68]           < return
[ 253.69]           > fib(n: uint32): uint32
[ 253.70]           < return
[ 253.71]          < return
[ 253.72]         < return
[ 253.73]         > fib(n: uint32): uint32
[ 253.74]          > fib(n: uint32): uint32
[ 253.75]           > fib(n: uint32): uint32
[ 253.76]           < return
[ 253.77]           > fib(n: uint32): uint32
[ 253.78]           < return
[ 253.79]          < return
[ 253.80]          > fib(n: uint32): uint32
[ 253.81]          < return
[ 253.82]         < return
[ 253.83]        < return
[ 253.84]        > fib(n: uint32): uint32
[ 253.85]         > fib(n: uint32): uint32
[ 253.86]          > fib(n: uint32): uint32
[ 253.87]           > fib(n: uint32): uint32
[ 253.88]           < return
[ 253.89]           > fib(n: uint32): uint32
[ 253.91]           < return
[ 253.91]          < return
[ 253.92]          > fib(n: uint32): uint32
[ 253.93]          < return
[ 253.94]         < return
[ 253.95]         > fib(n: uint32): uint32
[ 253.97]          > fib(n: uint32): uint32
[ 253.98]          < return
[ 253.99]          > fib(n: uint32): uint32
[ 254.00]          < return
[ 254.01]         < return
[ 254.01]        < return
[ 254.02]       < return
[ 254.03]      < return
[ 254.04]      > fib(n: uint32): uint32
[ 254.05]       > fib(n: uint32): uint32
[ 254.06]        > fib(n: uint32): uint32
[ 254.08]         > fib(n: uint32): uint32
[ 254.09]          > fib(n: uint32): uint32
[ 254.10]           > fib(n: uint32): uint32
[ 254.11]            > fib(n: uint32): uint32
[ 254.12]            < return
[ 254.13]            > fib(n: uint32): uint32
[ 254.14]            < return
[ 254.15]           < return
[ 254.16]           > fib(n: uint32): uint32
[ 254.17]           < return
[ 254.18]          < return
[ 254.19]          > fib(n: uint32): uint32
[ 254.20]           > fib(n: uint32): uint32
[ 254.21]           < return
[ 254.22]           > fib(n: uint32): uint32
[ 254.23]           < return
[ 254.24]          < return
[ 254.25]         < return
[ 254.26]         > fib(n: uint32): uint32
[ 254.27]          > fib(n: uint32): uint32
[ 254.28]           > fib(n: uint32): uint32
[ 254.29]           < return
[ 254.30]           > fib(n: uint32): uint32
[ 254.31]           < return
[ 254.32]          < return
[ 254.33]          > fib(n: uint32): uint32
[ 254.34]          < return
[ 254.35]         < return
[ 254.36]        < return
[ 254.37]        > fib(n: uint32): uint32
[ 254.38]         > fib(n: uint32): uint32
[ 254.39]          > fib(n: uint32): uint32
[ 254.40]           > fib(n: uint32): uint32
[ 254.41]           < return
[ 254.42]           > fib(n: uint32): uint32
[ 254.43]           < return
[ 254.44]          < return
[ 254.45]          > fib(n: uint32): uint32
[ 254.46]          < return
[ 254.47]         < return
[ 254.48]         > fib(n: uint32): uint32
[ 254.49]          > fib(n: uint32): uint32
[ 254.50]          < return
[ 254.51]          > fib(n: uint32): uint32
[ 254.52]          < return
[ 254.53]         < return
[ 254.54]        < return
[ 254.54]       < return
[ 254.55]       > fib(n: uint32): uint32
[ 254.56]        > fib(n: uint32): uint32
[ 254.58]         > fib(n: uint32): uint32
[ 254.59]          > fib(n: uint32): uint32
[ 254.60]           > fib(n: uint32): uint32
[ 254.61]           < return
[ 254.62]           > fib(n: uint32): uint32
[ 254.63]           < return
[ 254.64]          < return
[ 254.65]          > fib(n: uint32): uint32
[ 254.66]          < return
[ 254.67]         < return
[ 254.69]         > fib(n: uint32): uint32
[ 254.71]          > fib(n: uint32): uint32
[ 254.72]          < return
[ 254.73]          > fib(n: uint32): uint32
[ 254.74]          < return
[ 254.75]         < return
[ 254.75]        < return
[ 254.76]        > fib(n: uint32): uint32
[ 254.78]         > fib(n: uint32): uint32
[ 254.79]          > fib(n: uint32): uint32
[ 254.80]          < return
[ 254.81]          > fib(n: uint32): uint32
[ 254.82]          < return
[ 254.83]         < return
[ 254.84]         > fib(n: uint32): uint32
[ 254.85]         < return
[ 254.86]        < return
[ 254.87]       < return
[ 254.87]      < return
[ 254.88]     < return
[ 254.89]     > fib(n: uint32): uint32
[ 254.90]      > fib(n: uint32): uint32
[ 254.91]       > fib(n: uint32): uint32
[ 254.93]        > fib(n: uint32): uint32
[ 254.94]         > fib(n: uint32): uint32
[ 254.95]          > fib(n: uint32): uint32
[ 254.97]           > fib(n: uint32): uint32
[ 254.98]            > fib(n: uint32): uint32
[ 254.99]            < return
[ 255.01]            > fib(n: uint32): uint32
[ 255.02]            < return
[ 255.03]           < return
[ 255.03]           > fib(n: uint32): uint32
[ 255.04]           < return
[ 255.05]          < return
[ 255.07]          > fib(n: uint32): uint32
[ 255.08]           > fib(n: uint32): uint32
[ 255.09]           < return
[ 255.10]           > fib(n: uint32): uint32
[ 255.11]           < return
[ 255.12]          < return
[ 255.13]         < return
[ 255.14]         > fib(n: uint32): uint32
[ 255.15]          > fib(n: uint32): uint32
[ 255.16]           > fib(n: uint32): uint32
[ 255.17]           < return
[ 255.18]           > fib(n: uint32): uint32
[ 255.19]           < return
[ 255.20]          < return
[ 255.21]          > fib(n: uint32): uint32
[ 255.22]          < return
[ 255.23]         < return
[ 255.24]        < return
[ 255.24]        > fib(n: uint32): uint32
[ 255.26]         > fib(n: uint32): uint32
[ 255.27]          > fib(n: uint32): uint32
[ 255.28]           > fib(n: uint32): uint32
[ 255.29]           < return
[ 255.30]           > fib(n: uint32): uint32
[ 255.31]           < return
[ 255.32]          < return
[ 255.33]          > fib(n: uint32): uint32
[ 255.34]          < return
[ 255.35]         < return
[ 255.36]         > fib(n: uint32): uint32
[ 255.37]          > fib(n: uint32): uint32
[ 255.38]          < return
[ 255.39]          > fib(n: uint32): uint32
[ 255.40]          < return
[ 255.41]         < return
[ 255.41]        < return
[ 255.42]       < return
[ 255.43]       > fib(n: uint32): uint32
[ 255.44]        > fib(n: uint32): uint32
[ 255.46]         > fib(n: uint32): uint32
[ 255.47]          > fib(n: uint32): uint32
[ 255.48]           > fib(n: uint32): uint32
[ 255.49]           < return
[ 255.50]           > fib(n: uint32): uint32
[ 255.51]           < return
[ 255.52]          < return
[ 255.53]          > fib(n: uint32): uint32
[ 255.54]          < return
[ 255.55]         < return
[ 255.56]         > fib(n: uint32): uint32
[ 255.57]          > fib(n: uint32): uint32
[ 255.58]          < return
[ 255.59]          > fib(n: uint32): uint32
[ 255.60]          < return
[ 255.61]         < return
[ 255.62]        < return
[ 255.62]        > fib(n: uint32): uint32
[ 255.64]         > fib(n: uint32): uint32
[ 255.65]          > fib(n: uint32): uint32
[ 255.66]          < return
[ 255.67]          > fib(n: uint32): uint32
[ 255.68]          < return
[ 255.69]         < return
[ 255.70]         > fib(n: uint32): uint32
[ 255.71]         < return
[ 255.72]        < return
[ 255.72]       < return
[ 255.73]      < return
[ 255.74]      > fib(n: uint32): uint32
[ 255.75]       > fib(n: uint32): uint32
[ 255.76]        > fib(n: uint32): uint32
[ 255.78]         > fib(n: uint32): uint32
[ 255.79]          > fib(n: uint32): uint32
[ 255.80]           > fib(n: uint32): uint32
[ 255.81]           < return
[ 255.82]           > fib(n: uint32): uint32
[ 255.83]           < return
[ 255.84]          < return
[ 255.85]          > fib(n: uint32): uint32
[ 255.86]          < return
[ 255.87]         < return
[ 255.88]         > fib(n: uint32): uint32
[ 255.89]          > fib(n: uint32): uint32
[ 255.90]          < return
[ 255.91]          > fib(n: uint32): uint32
[ 255.92]          < return
[ 255.93]         < return
[ 255.94]        < return
[ 255.94]        > fib(n: uint32): uint32
[ 255.96]         > fib(n: uint32): uint32
[ 255.97]          > fib(n: uint32): uint32
[ 255.98]          < return
[ 255.99]          > fib(n: uint32): uint32
[ 256.00]          < return
[ 256.01]         < return
[ 256.02]         > fib(n: uint32): uint32
[ 256.03]         < return
[ 256.04]        < return
[ 256.05]       < return
[ 256.06]       > fib(n: uint32): uint32
[ 256.08]        > fib(n: uint32): uint32
[ 256.09]         > fib(n: uint32): uint32
[ 256.11]          > fib(n: uint32): uint32
[ 256.12]          < return
[ 256.13]          > fib(n: uint32): uint32
[ 256.14]          < return
[ 256.15]         < return
[ 256.16]         > fib(n: uint32): uint32
[ 256.17]         < return
[ 256.18]        < return
[ 256.19]        > fib(n: uint32): uint32
[ 256.20]         > fib(n: uint32): uint32
[ 256.21]         < return
[ 256.22]         > fib(n: uint32): uint32
[ 256.23]         < return
[ 256.24]        < return
[ 256.25]       < return
[ 256.25]      < return
[ 256.26]     < return
[ 256.27]    < return
[ 256.28]   < return
[ 256.29]   > fib(n: uint32): uint32
[ 256.30]    > fib(n: uint32): uint32
[ 256.31]     > fib(n: uint32): uint32
[ 256.32]      > fib(n: uint32): uint32
[ 256.34]       > fib(n: uint32): uint32
[ 256.35]        > fib(n: uint32): uint32
[ 256.36]         > fib(n: uint32): uint32
[ 256.37]          > fib(n: uint32): uint32
[ 256.39]           > fib(n: uint32): uint32
[ 256.41]            > fib(n: uint32): uint32
[ 256.42]             > fib(n: uint32): uint32
[ 256.43]             < return
[ 256.44]             > fib(n: uint32): uint32
[ 256.45]             < return
[ 256.46]            < return
[ 256.48]            > fib(n: uint32): uint32
[ 256.49]            < return
[ 256.49]           < return
[ 256.50]           > fib(n: uint32): uint32
[ 256.52]            > fib(n: uint32): uint32
[ 256.53]            < return
[ 256.54]            > fib(n: uint32): uint32
[ 256.55]            < return
[ 256.56]           < return
[ 256.56]          < return
[ 256.57]          > fib(n: uint32): uint32
[ 256.58]           > fib(n: uint32): uint32
[ 256.60]            > fib(n: uint32): uint32
[ 256.61]            < return
[ 256.62]            > fib(n: uint32): uint32
[ 256.63]            < return
[ 256.64]           < return
[ 256.64]           > fib(n: uint32): uint32
[ 256.65]           < return
[ 256.66]          < return
[ 256.67]         < return
[ 256.68]         > fib(n: uint32): uint32
[ 256.69]          > fib(n: uint32): uint32
[ 256.70]           > fib(n: uint32): uint32
[ 256.72]            > fib(n: uint32): uint32
[ 256.73]            < return
[ 256.74]            > fib(n: uint32): uint32
[ 256.75]            < return
[ 256.76]           < return
[ 256.76]           > fib(n: uint32): uint32
[ 256.77]           < return
[ 256.78]          < return
[ 256.79]          > fib(n: uint32): uint32
[ 256.81]           > fib(n: uint32): uint32
[ 256.81]           < return
[ 256.82]           > fib(n: uint32): uint32
[ 256.83]           < return
[ 256.84]          < return
[ 256.85]         < return
[ 256.86]        < return
[ 256.87]        > fib(n: uint32): uint32
[ 256.88]         > fib(n: uint32): uint32
[ 256.89]          > fib(n: uint32): uint32
[ 256.90]           > fib(n: uint32): uint32
[ 256.92]            > fib(n: uint32): uint32
[ 256.93]            < return
[ 256.94]            > fib(n: uint32): uint32
[ 256.95]            < return
[ 256.96]           < return
[ 256.96]           > fib(n: uint32): uint32
[ 256.98]           < return
[ 256.98]          < return
[ 256.99]          > fib(n: uint32): uint32
[ 257.00]           > fib(n: uint32): uint32
[ 257.02]           < return
[ 257.02]           > fib(n: uint32): uint32
[ 257.04]           < return
[ 257.04]          < return
[ 257.05]         < return
[ 257.06]         > fib(n: uint32): uint32
[ 257.07]          > fib(n: uint32): uint32
[ 257.09]           > fib(n: uint32): uint32
[ 257.10]           < return
[ 257.11]           > fib(n: uint32): uint32
[ 257.12]           < return
[ 257.12]          < return
[ 257.13]          > fib(n: uint32): uint32
[ 257.14]          < return
[ 257.15]         < return
[ 257.16]        < return
[ 257.17]       < return
[ 257.18]       > fib(n: uint32): uint32
[ 257.19]        > fib(n: uint32): uint32
[ 257.20]         > fib(n: uint32): uint32
[ 257.22]          > fib(n: uint32): uint32
[ 257.23]           > fib(n: uint32): uint32
[ 257.24]            > fib(n: uint32): uint32
[ 257.25]            < return
[ 257.26]            > fib(n: uint32): uint32
[ 257.27]            < return
[ 257.28]           < return
[ 257.29]           > fib(n: uint32): uint32
[ 257.30]           < return
[ 257.31]          < return
[ 257.32]          > fib(n: uint32): uint32
[ 257.33]           > fib(n: uint32): uint32
[ 257.34]           < return
[ 257.35]           > fib(n: uint32): uint32
[ 257.36]           < return
[ 257.37]          < return
[ 257.38]         < return
[ 257.38]         > fib(n: uint32): uint32
[ 257.40]          > fib(n: uint32): uint32
[ 257.41]           > fib(n: uint32): uint32
[ 257.43]           < return
[ 257.44]           > fib(n: uint32): uint32
[ 257.46]           < return
[ 257.47]          < return
[ 257.48]          > fib(n: uint32): uint32
[ 257.49]          < return
[ 257.50]         < return
[ 257.50]        < return
[ 257.51]        > fib(n: uint32): uint32
[ 257.53]         > fib(n: uint32): uint32
[ 257.54]          > fib(n: uint32): uint32
[ 257.55]           > fib(n: uint32): uint32
[ 257.56]           < return
[ 257.57]           > fib(n: uint32): uint32
[ 257.58]           < return
[ 257.59]          < return
[ 257.60]          > fib(n: uint32): uint32
[ 257.61]          < return
[ 257.62]         < return
[ 257.63]         > fib(n: uint32): uint32
[ 257.64]          > fib(n: uint32): uint32
[ 257.65]          < return
[ 257.66]          > fib(n: uint32): uint32
[ 257.67]          < return
[ 257.68]         < return
[ 257.69]        < return
[ 257.69]       < return
[ 257.70]      < return
[ 257.71]      > fib(n: uint32): uint32
[ 257.72]       > fib(n: uint32): uint32
[ 257.74]        > fib(n: uint32): uint32
[ 257.75]         > fib(n: uint32): uint32
[ 257.76]          > fib(n: uint32): uint32
[ 257.77]           > fib(n: uint32): uint32
[ 257.79]            > fib(n: uint32): uint32
[ 257.80]            < return
[ 257.81]            > fib(n: uint32): uint32
[ 257.82]            < return
[ 257.83]           < return
[ 257.83]           > fib(n: uint32): uint32
[ 257.85]           < return
[ 257.85]          < return
[ 257.86]          > fib(n: uint32): uint32
[ 257.88]           > fib(n: uint32): uint32
[ 257.89]           < return
[ 257.90]           > fib(n: uint32): uint32
[ 257.91]           < return
[ 257.92]          < return
[ 257.92]         < return
[ 257.93]         > fib(n: uint32): uint32
[ 257.94]          > fib(n: uint32): uint32
[ 257.96]           > fib(n: uint32): uint32
[ 257.97]           < return
[ 257.98]           > fib(n: uint32): uint32
[ 257.99]           < return
[ 258.00]          < return
[ 258.01]          > fib(n: uint32): uint32
[ 258.02]          < return
[ 258.03]         < return
[ 258.04]        < return
[ 258.05]        > fib(n: uint32): uint32
[ 258.06]         > fib(n: uint32): uint32
[ 258.07]          > fib(n: uint32): uint32
[ 258.08]           > fib(n: uint32): uint32
[ 258.09]           < return
[ 258.10]           > fib(n: uint32): uint32
[ 258.11]           < return
[ 258.12]          < return
[ 258.13]          > fib(n: uint32): uint32
[ 258.14]          < return
[ 258.15]         < return
[ 258.16]         > fib(n: uint32): uint32
[ 258.17]          > fib(n: uint32): uint32
[ 258.18]          < return
[ 258.19]          > fib(n: uint32): uint32
[ 258.20]          < return
[ 258.21]         < return
[ 258.22]        < return
[ 258.23]       < return
[ 258.23]       > fib(n: uint32): uint32
[ 258.25]        > fib(n: uint32): uint32
[ 258.26]         > fib(n: uint32): uint32
[ 258.27]          > fib(n: uint32): uint32
[ 258.29]           > fib(n: uint32): uint32
[ 258.30]           < return
[ 258.31]           > fib(n: uint32): uint32
[ 258.31]           < return
[ 258.32]          < return
[ 258.33]          > fib(n: uint32): uint32
[ 258.34]          < return
[ 258.36]         < return
[ 258.37]         > fib(n: uint32): uint32
[ 258.38]          > fib(n: uint32): uint32
[ 258.39]          < return
[ 258.40]          > fib(n: uint32): uint32
[ 258.41]          < return
[ 258.42]         < return
[ 258.43]        < return
[ 258.43]        > fib(n: uint32): uint32
[ 258.45]         > fib(n: uint32): uint32
[ 258.46]          > fib(n: uint32): uint32
[ 258.47]          < return
[ 258.48]          > fib(n: uint32): uint32
[ 258.49]          < return
[ 258.50]         < return
[ 258.51]         > fib(n: uint32): uint32
[ 258.52]         < return
[ 258.53]        < return
[ 258.53]       < return
[ 258.54]      < return
[ 258.55]     < return
[ 258.56]     > fib(n: uint32): uint32
[ 258.57]      > fib(n: uint32): uint32
[ 258.58]       > fib(n: uint32): uint32
[ 258.60]        > fib(n: uint32): uint32
[ 258.61]         > fib(n: uint32): uint32
[ 258.62]          > fib(n: uint32): uint32
[ 258.63]           > fib(n: uint32): uint32
[ 258.65]            > fib(n: uint32): uint32
[ 258.66]            < return
[ 258.67]            > fib(n: uint32): uint32
[ 258.68]            < return
[ 258.69]           < return
[ 258.69]           > fib(n: uint32): uint32
[ 258.70]           < return
[ 258.71]          < return
[ 258.72]          > fib(n: uint32): uint32
[ 258.73]           > fib(n: uint32): uint32
[ 258.75]           < return
[ 258.75]           > fib(n: uint32): uint32
[ 258.76]           < return
[ 258.77]          < return
[ 258.78]         < return
[ 258.79]         > fib(n: uint32): uint32
[ 258.80]          > fib(n: uint32): uint32
[ 258.81]           > fib(n: uint32): uint32
[ 258.83]           < return
[ 258.83]           > fib(n: uint32): uint32
[ 258.85]           < return
[ 258.85]          < return
[ 258.86]          > fib(n: uint32): uint32
[ 258.87]          < return
[ 258.88]         < return
[ 258.89]        < return
[ 258.90]        > fib(n: uint32): uint32
[ 258.91]         > fib(n: uint32): uint32
[ 258.92]          > fib(n: uint32): uint32
[ 258.94]           > fib(n: uint32): uint32
[ 258.95]           < return
[ 258.96]           > fib(n: uint32): uint32
[ 258.97]           < return
[ 258.98]          < return
[ 258.98]          > fib(n: uint32): uint32
[ 258.99]          < return
[ 259.00]         < return
[ 259.01]         > fib(n: uint32): uint32
[ 259.02]          > fib(n: uint32): uint32
[ 259.04]          < return
[ 259.04]          > fib(n: uint32): uint32
[ 259.06]          < return
[ 259.06]         < return
[ 259.07]        < return
[ 259.08]       < return
[ 259.09]       > fib(n: uint32): uint32
[ 259.10]        > fib(n: uint32): uint32
[ 259.11]         > fib(n: uint32): uint32
[ 259.12]          > fib(n: uint32): uint32
[ 259.14]           > fib(n: uint32): uint32
[ 259.15]           < return
[ 259.16]           > fib(n: uint32): uint32
[ 259.17]           < return
[ 259.18]          < return
[ 259.19]          > fib(n: uint32): uint32
[ 259.21]          < return
[ 259.21]         < return
[ 259.22]         > fib(n: uint32): uint32
[ 259.23]          > fib(n: uint32): uint32
[ 259.24]          < return
[ 259.25]          > fib(n: uint32): uint32
[ 259.26]          < return
[ 259.27]         < return
[ 259.28]        < return
[ 259.29]        > fib(n: uint32): uint32
[ 259.31]         > fib(n: uint32): uint32
[ 259.32]          > fib(n: uint32): uint32
[ 259.33]          < return
[ 259.34]          > fib(n: uint32): uint32
[ 259.35]          < return
[ 259.36]         < return
[ 259.37]         > fib(n: uint32): uint32
[ 259.38]         < return
[ 259.39]        < return
[ 259.40]       < return
[ 259.40]      < return
[ 259.41]      > fib(n: uint32): uint32
[ 259.43]       > fib(n: uint32): uint32
[ 259.44]        > fib(n: uint32): uint32
[ 259.45]         > fib(n: uint32): uint32
[ 259.46]          > fib(n: uint32): uint32
[ 259.48]           > fib(n: uint32): uint32
[ 259.49]           < return
[ 259.50]           > fib(n: uint32): uint32
[ 259.50]           < return
[ 259.51]          < return
[ 259.52]          > fib(n: uint32): uint32
[ 259.54]          < return
[ 259.55]         < return
[ 259.55]         > fib(n: uint32): uint32
[ 259.57]          > fib(n: uint32): uint32
[ 259.58]          < return
[ 259.59]          > fib(n: uint32): uint32
[ 259.60]          < return
[ 259.61]         < return
[ 259.61]        < return
[ 259.62]        > fib(n: uint32): uint32
[ 259.63]         > fib(n: uint32): uint32
[ 259.65]          > fib(n: uint32): uint32
[ 259.66]          < return
[ 259.67]          > fib(n: uint32): uint32
[ 259.69]          < return
[ 259.70]         < return
[ 259.71]         > fib(n: uint32): uint32
[ 259.73]         < return
[ 259.74]        < return
[ 259.75]       < return
[ 259.76]       > fib(n: uint32): uint32
[ 259.78]        > fib(n: uint32): uint32
[ 259.80]         > fib(n: uint32): uint32
[ 259.81]          > fib(n: uint32): uint32
[ 259.82]          < return
[ 259.83]          > fib(n: uint32): uint32
[ 259.84]          < return
[ 259.85]         < return
[ 259.86]         > fib(n: uint32): uint32
[ 259.88]         < return
[ 259.89]        < return
[ 259.90]        > fib(n: uint32): uint32
[ 259.92]         > fib(n: uint32): uint32
[ 259.93]         < return
[ 259.94]         > fib(n: uint32): uint32
[ 259.96]         < return
[ 259.97]        < return
[ 259.98]       < return
[ 259.99]      < return
[ 260.00]     < return
[ 260.00]    < return
[ 260.01]    > fib(n: uint32): uint32
[ 260.03]     > fib(n: uint32): uint32
[ 260.04]      > fib(n: uint32): uint32
[ 260.05]       > fib(n: uint32): uint32
[ 260.06]        > fib(n: uint32): uint32
[ 260.08]         > fib(n: uint32): uint32
[ 260.09]          > fib(n: uint32): uint32
[ 260.10]           > fib(n: uint32): uint32
[ 260.11]            > fib(n: uint32): uint32
[ 260.12]            < return
[ 260.13]            > fib(n: uint32): uint32
[ 260.14]            < return
[ 260.15]           < return
[ 260.16]           > fib(n: uint32): uint32
[ 260.17]           < return
[ 260.18]          < return
[ 260.19]          > fib(n: uint32): uint32
[ 260.20]           > fib(n: uint32): uint32
[ 260.21]           < return
[ 260.22]           > fib(n: uint32): uint32
[ 260.23]           < return
[ 260.24]          < return
[ 260.25]         < return
[ 260.26]         > fib(n: uint32): uint32
[ 260.27]          > fib(n: uint32): uint32
[ 260.28]           > fib(n: uint32): uint32
[ 260.29]           < return
[ 260.30]           > fib(n: uint32): uint32
[ 260.31]           < return
[ 260.32]          < return
[ 260.33]          > fib(n: uint32): uint32
[ 260.34]          < return
[ 260.35]         < return
[ 260.36]        < return
[ 260.37]        > fib(n: uint32): uint32
[ 260.38]         > fib(n: uint32): uint32
[ 260.40]          > fib(n: uint32): uint32
[ 260.42]           > fib(n: uint32): uint32
[ 260.44]           < return
[ 260.45]           > fib(n: uint32): uint32
[ 260.46]           < return
[ 260.47]          < return
[ 260.48]          > fib(n: uint32): uint32
[ 260.49]          < return
[ 260.50]         < return
[ 260.51]         > fib(n: uint32): uint32
[ 260.52]          > fib(n: uint32): uint32
[ 260.53]          < return
[ 260.54]          > fib(n: uint32): uint32
[ 260.55]          < return
[ 260.56]         < return
[ 260.57]        < return
[ 260.58]       < return
[ 260.58]       > fib(n: uint32): uint32
[ 260.60]        > fib(n: uint32): uint32
[ 260.61]         > fib(n: uint32): uint32
[ 260.62]          > fib(n: uint32): uint32
[ 260.63]           > fib(n: uint32): uint32
[ 260.65]           < return
[ 260.65]           > fib(n: uint32): uint32
[ 260.67]           < return
[ 260.67]          < return
[ 260.68]          > fib(n: uint32): uint32
[ 260.69]          < return
[ 260.70]         < return
[ 260.71]         > fib(n: uint32): uint32
[ 260.72]          > fib(n: uint32): uint32
[ 260.74]          < return
[ 260.76]          > fib(n: uint32): uint32
[ 260.77]          < return
[ 260.78]         < return
[ 260.79]        < return
[ 260.80]        > fib(n: uint32): uint32
[ 260.83]         > fib(n: uint32): uint32
[ 260.84]          > fib(n: uint32): uint32
[ 260.86]          < return
[ 260.87]          > fib(n: uint32): uint32
[ 260.88]          < return
[ 260.89]         < return
[ 260.90]         > fib(n: uint32): uint32
[ 260.91]         < return
[ 260.92]        < return
[ 260.92]       < return
[ 260.93]      < return
[ 260.94]      > fib(n: uint32): uint32
[ 260.95]       > fib(n: uint32): uint32
[ 260.97]        > fib(n: uint32): uint32
[ 260.98]         > fib(n: uint32): uint32
[ 260.99]          > fib(n: uint32): uint32
[ 261.00]           > fib(n: uint32): uint32
[ 261.01]           < return
[ 261.02]           > fib(n: uint32): uint32
[ 261.04]           < return
[ 261.04]          < return
[ 261.05]          > fib(n: uint32): uint32
[ 261.06]          < return
[ 261.07]         < return
[ 261.08]         > fib(n: uint32): uint32
[ 261.09]          > fib(n: uint32): uint32
[ 261.10]          < return
[ 261.11]          > fib(n: uint32): uint32
[ 261.12]          < return
[ 261.13]         < return
[ 261.14]        < return
[ 261.15]        > fib(n: uint32): uint32
[ 261.16]         > fib(n: uint32): uint32
[ 261.17]          > fib(n: uint32): uint32
[ 261.18]          < return
[ 261.19]          > fib(n: uint32): uint32
[ 261.20]          < return
[ 261.21]         < return
[ 261.22]         > fib(n: uint32): uint32
[ 261.23]         < return
[ 261.24]        < return
[ 261.25]       < return
[ 261.26]       > fib(n: uint32): uint32
[ 261.27]        > fib(n: uint32): uint32
[ 261.28]         > fib(n: uint32): uint32
[ 261.30]          > fib(n: uint32): uint32
[ 261.31]          < return
[ 261.31]          > fib(n: uint32): uint32
[ 261.33]          < return
[ 261.33]         < return
[ 261.34]         > fib(n: uint32): uint32
[ 261.35]         < return
[ 261.36]        < return
[ 261.37]        > fib(n: uint32): uint32
[ 261.38]         > fib(n: uint32): uint32
[ 261.39]         < return
[ 261.40]         > fib(n: uint32): uint32
[ 261.42]         < return
[ 261.42]        < return
[ 261.43]       < return
[ 261.44]      < return
[ 261.45]     < return
[ 261.46]     > fib(n: uint32): uint32
[ 261.47]      > fib(n: uint32): uint32
[ 261.48]       > fib(n: uint32): uint32
[ 261.49]        > fib(n: uint32): uint32
[ 261.51]         > fib(n: uint32): uint32
[ 261.52]          > fib(n: uint32): uint32
[ 261.53]           > fib(n: uint32): uint32
[ 261.54]           < return
[ 261.55]           > fib(n: uint32): uint32
[ 261.56]           < return
[ 261.57]          < return
[ 261.58]          > fib(n: uint32): uint32
[ 261.59]          < return
[ 261.60]         < return
[ 261.61]         > fib(n: uint32): uint32
[ 261.62]          > fib(n: uint32): uint32
[ 261.63]          < return
[ 261.64]          > fib(n: uint32): uint32
[ 261.65]          < return
[ 261.66]         < return
[ 261.67]        < return
[ 261.68]        > fib(n: uint32): uint32
[ 261.69]         > fib(n: uint32): uint32
[ 261.70]          > fib(n: uint32): uint32
[ 261.71]          < return
[ 261.72]          > fib(n: uint32): uint32
[ 261.73]          < return
[ 261.74]         < return
[ 261.75]         > fib(n: uint32): uint32
[ 261.76]         < return
[ 261.77]        < return
[ 261.78]       < return
[ 261.79]       > fib(n: uint32): uint32
[ 261.80]        > fib(n: uint32): uint32
[ 261.81]         > fib(n: uint32): uint32
[ 261.82]          > fib(n: uint32): uint32
[ 261.83]          < return
[ 261.85]          > fib(n: uint32): uint32
[ 261.86]          < return
[ 261.87]         < return
[ 261.87]         > fib(n: uint32): uint32
[ 261.88]         < return
[ 261.89]        < return
[ 261.90]        > fib(n: uint32): uint32
[ 261.91]         > fib(n: uint32): uint32
[ 261.93]         < return
[ 261.94]         > fib(n: uint32): uint32
[ 261.95]         < return
[ 261.96]        < return
[ 261.97]       < return
[ 261.98]      < return
[ 261.98]      > fib(n: uint32): uint32
[ 262.00]       > fib(n: uint32): uint32
[ 262.01]        > fib(n: uint32): uint32
[ 262.02]         > fib(n: uint32): uint32
[ 262.04]          > fib(n: uint32): uint32
[ 262.05]          < return
[ 262.06]          > fib(n: uint32): uint32
[ 262.07]          < return
[ 262.08]         < return
[ 262.08]         > fib(n: uint32): uint32
[ 262.10]         < return
[ 262.11]        < return
[ 262.11]        > fib(n: uint32): uint32
[ 262.13]         > fib(n: uint32): uint32
[ 262.14]         < return
[ 262.15]         > fib(n: uint32): uint32
[ 262.16]         < return
[ 262.17]        < return
[ 262.17]       < return
[ 262.18]       > fib(n: uint32): uint32
[ 262.19]        > fib(n: uint32): uint32
[ 262.21]         > fib(n: uint32): uint32
[ 262.22]         < return
[ 262.23]         > fib(n: uint32): uint32
[ 262.24]         < return
[ 262.25]        < return
[ 262.25]        > fib(n: uint32): uint32
[ 262.27]        < return
[ 262.27]       < return
[ 262.28]      < return
[ 262.29]     < return
[ 262.30]    < return
[ 262.31]   < return
[ 262.31]  < return
[ 262.36]  > typename.name(type: typename): .cstr
[ 262.37]  < return
[ 262.38]  > typename.file(type: typename): .cstr
[ 262.39]  < return
[ 262.40]  > typename.line(type: typename): int32
[ 262.41]  < return
[ 262.42]  > typename.base(type: typename): typename
[ 262.43]  < return
[ 262.44]  > typename.name(type: typename): .cstr
[ 262.45]  < return
[ 262.46]  > typename.file(type: typename): .cstr
[ 262.48]  < return
[ 262.48]  > typename.line(type: typename): int32
[ 262.49]  < return
[ 262.50]  > typename.base(type: typename): typename
[ 262.51]  < return
[ 262.53]  > typename.base(type: typename): typename
[ 262.54]  < return
[ 262.60]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 262.61]  < return
[ 262.62]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 262.63]  < return
[ 262.64]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 262.65]  < return
[ 262.66]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 262.67]  < return
[ 262.68]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 262.69]  < return
[ 262.70]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 262.71]  < return
[ 262.72]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 262.73]  < return
[ 262.74]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 262.75]  < return
[ 262.76]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 262.77]  < return
[ 262.78]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 262.79]  < return
[ 262.80]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 262.81]  < return
[ 262.82]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 262.83]  < return
[ 262.84]  > float64.sin(x: float64): float64
[ 262.86]  < return
[ 262.87]  > float64.cos(x: float64): float64
[ 262.89]  < return
[ 262.90]  > float64.tan(x: float64): float64
[ 262.91]  < return
[ 262.92]  > float64.log(x: float64): float64
[ 262.93]  < return
[ 262.94]  > float64.exp(x: float64): float64
[ 262.95]  < return
[ 262.96]  > float64.pow(x: float64, y: float64): float64
[ 262.97]  < return
[ 262.98]  > float64.sqrt(x: float64): float64
[ 262.99]  < return
[ 263.00]  > float64.atan2(x: float64, y: float64): float64
[ 263.01]  < return
[ 263.02]  > float32.sin(x: float32): float32
[ 263.03]  < return
[ 263.05]  > float32.cos(x: float32): float32
[ 263.05]  < return
[ 263.06]  > float32.tan(x: float32): float32
[ 263.08]  < return
[ 263.09]  > float32.log(x: float32): float32
[ 263.10]  < return
[ 263.11]  > float32.exp(x: float32): float32
[ 263.12]  < return
[ 263.13]  > float32.pow(x: float32, y: float32): float32
[ 263.14]  < return
[ 263.15]  > float32.sqrt(x: float32): float32
[ 263.15]  < return
[ 263.17]  > float32.atan2(x: float32, y: float32): float32
[ 263.18]  < return
[ 263.19]  > uint32.pop(value: int32): int32
[ 263.19]  < return
[ 263.20]  > uint32.swap(value: int32): int32
[ 263.21]  < return
[ 263.22]  > uint32.bsr(value: int32): int32
[ 263.23]  < return
[ 263.24]  > uint32.bsf(value: int32): int32
[ 263.25]  < return
[ 263.26]  > uint32.hib(value: int32): int32
[ 263.27]  < return
[ 263.28]  > uint32.lob(value: int32): int32
[ 263.28]  < return
[ 263.30]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 263.31]  < return
[ 263.32]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 263.33]  < return
[ 263.34]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 263.35]  < return
[ 263.36]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 263.37]  < return
[ 263.38]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.39]  < return
[ 263.40]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.41]  < return
[ 263.42]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.43]  < return
[ 263.44]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.45]  < return
[ 263.46]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 263.47]  < return
[ 263.48]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 263.49]  < return
[ 263.50]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.51]  < return
[ 263.52]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.53]  < return
[ 263.54]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.55]  < return
[ 263.56]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 263.57]  < return
[ 263.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 263.61]  < return
[ 263.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 263.65]  < return
[ 263.66]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 263.67]  < return
[ 263.68]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 263.69]  < return
[ 263.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 263.73]  < return
[ 263.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 263.76]  < return
[ 263.77]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 263.79]   > noError(ptr: pointer): void
[ 263.80]   < return
[ 263.80]   > halt(): void
[ 263.81]   < return
[ 263.82]  < return
[ 263.83]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 263.84]  < return
[ 263.85]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 263.86]   > stackOverflow(ptr: pointer): void
[ 263.87]    > stackOverflow(ptr: pointer): void
[ 263.88]     > stackOverflow(ptr: pointer): void
[ 263.89]      > stackOverflow(ptr: pointer): void
[ 263.90]       > stackOverflow(ptr: pointer): void
[ 263.92]        > stackOverflow(ptr: pointer): void
[ 263.93]         > stackOverflow(ptr: pointer): void
[ 263.94]          > stackOverflow(ptr: pointer): void
[ 263.95]           > stackOverflow(ptr: pointer): void
[ 263.96]            > stackOverflow(ptr: pointer): void
[ 263.97]             > stackOverflow(ptr: pointer): void
[ 263.98]              > stackOverflow(ptr: pointer): void
[ 263.99]               > stackOverflow(ptr: pointer): void
[ 264.00]                > stackOverflow(ptr: pointer): void
[ 264.01]                 > stackOverflow(ptr: pointer): void
[ 264.02]                  > stackOverflow(ptr: pointer): void
[ 264.04]                   > stackOverflow(ptr: pointer): void
[ 264.05]                    > stackOverflow(ptr: pointer): void
[ 264.06]                     > stackOverflow(ptr: pointer): void
[ 264.07]                      > stackOverflow(ptr: pointer): void
[ 264.08]                       > stackOverflow(ptr: pointer): void
[ 264.09]                        > stackOverflow(ptr: pointer): void
[ 264.10]                         > stackOverflow(ptr: pointer): void
[ 264.11]                          > stackOverflow(ptr: pointer): void
[ 264.12]                           > stackOverflow(ptr: pointer): void
[ 264.13]                            > stackOverflow(ptr: pointer): void
[ 264.15]                             > stackOverflow(ptr: pointer): void
[ 264.16]                              > stackOverflow(ptr: pointer): void
[ 264.17]                               > stackOverflow(ptr: pointer): void
[ 264.18]                                > stackOverflow(ptr: pointer): void
[ 264.19]                                 > stackOverflow(ptr: pointer): void
[ 264.20]                                  > stackOverflow(ptr: pointer): void
[ 264.21]                                   > stackOverflow(ptr: pointer): void
[ 264.23]                                    > stackOverflow(ptr: pointer): void
[ 264.24]                                     > stackOverflow(ptr: pointer): void
[ 264.25]                                      > stackOverflow(ptr: pointer): void
[ 264.26]                                       > stackOverflow(ptr: pointer): void
[ 264.28]                                        > stackOverflow(ptr: pointer): void
[ 264.29]                                         > stackOverflow(ptr: pointer): void
[ 264.30]                                          > stackOverflow(ptr: pointer): void
[ 264.31]                                           > stackOverflow(ptr: pointer): void
[ 264.32]                                            > stackOverflow(ptr: pointer): void
[ 264.33]                                             > stackOverflow(ptr: pointer): void
[ 264.34]                                              > stackOverflow(ptr: pointer): void
[ 264.36]                                               > stackOverflow(ptr: pointer): void
[ 264.37]                                                > stackOverflow(ptr: pointer): void
[ 264.38]                                                 > stackOverflow(ptr: pointer): void
[ 264.39]                                                  > stackOverflow(ptr: pointer): void
[ 264.40]                                                   > stackOverflow(ptr: pointer): void
[ 264.41]                                                    > stackOverflow(ptr: pointer): void
[ 264.42]                                                     > stackOverflow(ptr: pointer): void
[ 264.43]                                                      > stackOverflow(ptr: pointer): void
[ 264.44]                                                       > stackOverflow(ptr: pointer): void
[ 264.45]                                                        > stackOverflow(ptr: pointer): void
[ 264.46]                                                         > stackOverflow(ptr: pointer): void
[ 264.48]                                                          > stackOverflow(ptr: pointer): void
[ 264.49]                                                           > stackOverflow(ptr: pointer): void
[ 264.50]                                                            > stackOverflow(ptr: pointer): void
[ 264.51]                                                             > stackOverflow(ptr: pointer): void
[ 264.52]                                                              > stackOverflow(ptr: pointer): void
[ 264.53]                                                               > stackOverflow(ptr: pointer): void
[ 264.54]                                                                > stackOverflow(ptr: pointer): void
[ 264.55]                                                                 > stackOverflow(ptr: pointer): void
[ 264.56]                                                                  > stackOverflow(ptr: pointer): void
[ 264.57]                                                                  < return
[ 264.58]                                                                 < return
[ 264.59]                                                                < return
[ 264.60]                                                               < return
[ 264.60]                                                              < return
[ 264.61]                                                             < return
[ 264.62]                                                            < return
[ 264.62]                                                           < return
[ 264.63]                                                          < return
[ 264.64]                                                         < return
[ 264.65]                                                        < return
[ 264.65]                                                       < return
[ 264.66]                                                      < return
[ 264.67]                                                     < return
[ 264.68]                                                    < return
[ 264.68]                                                   < return
[ 264.69]                                                  < return
[ 264.70]                                                 < return
[ 264.70]                                                < return
[ 264.71]                                               < return
[ 264.72]                                              < return
[ 264.72]                                             < return
[ 264.73]                                            < return
[ 264.74]                                           < return
[ 264.74]                                          < return
[ 264.75]                                         < return
[ 264.76]                                        < return
[ 264.76]                                       < return
[ 264.77]                                      < return
[ 264.78]                                     < return
[ 264.79]                                    < return
[ 264.79]                                   < return
[ 264.80]                                  < return
[ 264.81]                                 < return
[ 264.81]                                < return
[ 264.82]                               < return
[ 264.83]                              < return
[ 264.83]                             < return
[ 264.84]                            < return
[ 264.85]                           < return
[ 264.86]                          < return
[ 264.86]                         < return
[ 264.87]                        < return
[ 264.88]                       < return
[ 264.88]                      < return
[ 264.89]                     < return
[ 264.90]                    < return
[ 264.90]                   < return
[ 264.91]                  < return
[ 264.92]                 < return
[ 264.92]                < return
[ 264.93]               < return
[ 264.94]              < return
[ 264.94]             < return
[ 264.95]            < return
[ 264.96]           < return
[ 264.96]          < return
[ 264.97]         < return
[ 264.98]        < return
[ 264.99]       < return
[ 264.99]      < return
[ 265.00]     < return
[ 265.01]    < return
[ 265.01]   < return
[ 265.02]  < return
[ 265.03]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 265.04]   > divisionByZero(args: pointer): void
[ 265.05]   < return
[ 265.06]  < return
[ 265.07]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 265.08]   > invalidInstruction(args: pointer): void
[ 265.09]   < return
[ 265.09]  < return
[ 265.10]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 265.11]   > invalidMemoryAccess(args: pointer): void
[ 265.12]   < return
[ 265.13]  < return
[ 265.14]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 265.15]   > abortExecution(args: pointer): void
[ 265.17]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 265.26]    < return
[ 265.27]   < return
[ 265.28]  < return
[ 265.41]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 265.42]  < return
[ 265.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 265.51]  < return
[ 265.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 265.60]  < return
[ 265.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 265.64]  < return
[ 265.66]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 265.69]  < return
[ 265.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 265.73]  < return
[ 265.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 265.77]  < return
[ 265.80]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 265.81]  < return
[ 265.82]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 265.83]  < return
[ 265.84]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 265.85]  < return
[ 265.87]  > lenSlice(values: int64[]): int32
[ 265.88]  < return
[ 265.89]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 265.90]  < return
[ 265.91]  > lenSlice(values: int64[]): int32
[ 265.92]  < return
[ 265.93]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 265.94]  < return
[ 265.96]  > lenSlice(values: int64[]): int32
[ 265.98]  < return
[ 265.99]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 266.00]  < return
[ 266.01]  > lenSlice(values: int64[]): int32
[ 266.02]  < return
[ 266.03]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 266.04]  < return
[ 266.05]  > lenSlice(values: int64[]): int32
[ 266.06]  < return
[ 266.07]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 266.08]  < return
[ 266.13]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.14]  < return
[ 266.16]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.18]  < return
[ 266.19]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.20]  < return
[ 266.22]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.23]  < return
[ 266.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.26]  < return
[ 266.28]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.29]  < return
[ 266.31]  > nthSlice(idx: int32, values: int64[]): int64
[ 266.32]  < return
[ 266.34]  > nthSlice(idx: int32, values: int64[]): int64
[ 266.35]  < return
[ 266.41]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.43]  < return
[ 266.44]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.45]  < return
[ 266.47]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.48]  < return
[ 266.50]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.51]  < return
[ 266.53]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.54]  < return
[ 266.56]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.57]  < return
[ 266.59]  > nthSlice(idx: int32, values: int64[]): int64
[ 266.60]  < return
[ 266.62]  > nthSlice(idx: int32, values: int64[]): int64
[ 266.63]  < return
[ 266.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.70]  < return
[ 266.72]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.73]  < return
[ 266.75]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.76]  < return
[ 266.78]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.79]  < return
[ 266.81]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.82]  < return
[ 266.84]  > nthArray(idx: int32, values: int64[*]): int64
[ 266.85]  < return
[ 266.87]  > nthSlice(idx: int32, values: int64[]): int64
[ 266.88]  < return
[ 266.90]  > nthSlice(idx: int32, values: int64[]): int64
[ 266.91]  < return
[ 266.97]  > nthFixed(idx: int32, values: int64[7]): int64
[ 266.98]  < return
[ 267.00]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.01]  < return
[ 267.03]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.04]  < return
[ 267.06]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.07]  < return
[ 267.09]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.10]  < return
[ 267.12]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.13]  < return
[ 267.15]  > nthSlice(idx: int32, values: int64[]): int64
[ 267.16]  < return
[ 267.18]  > nthSlice(idx: int32, values: int64[]): int64
[ 267.19]  < return
[ 267.25]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.26]  < return
[ 267.28]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.29]  < return
[ 267.31]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.32]  < return
[ 267.34]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.35]  < return
[ 267.37]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.38]  < return
[ 267.40]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.41]  < return
[ 267.43]  > nthSlice(idx: int32, values: int64[]): int64
[ 267.44]  < return
[ 267.45]  > nthSlice(idx: int32, values: int64[]): int64
[ 267.47]  < return
[ 267.53]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.54]  < return
[ 267.56]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.57]  < return
[ 267.59]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.60]  < return
[ 267.62]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.63]  < return
[ 267.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.66]  < return
[ 267.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.69]  < return
[ 267.70]  > nthSlice(idx: int32, values: int64[]): int64
[ 267.72]  < return
[ 267.74]  > nthSlice(idx: int32, values: int64[]): int64
[ 267.75]  < return
[ 267.81]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.82]  < return
[ 267.84]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.85]  < return
[ 267.87]  > nthFixed(idx: int32, values: int64[7]): int64
[ 267.88]  < return
[ 267.89]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.91]  < return
[ 267.93]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.94]  < return
[ 267.95]  > nthArray(idx: int32, values: int64[*]): int64
[ 267.97]  < return
[ 267.99]  > nthSlice(idx: int32, values: int64[]): int64
[ 268.00]  < return
[ 268.01]  > nthSlice(idx: int32, values: int64[]): int64
[ 268.03]  < return
[ 268.09]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 268.11]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(1)
	test/lang/method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 268.19]   < return
[ 268.20]  < return
[ 268.21]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 268.22]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(1)
	test/lang/method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 268.30]   < return
[ 268.31]  < return
[ 268.32]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 268.34]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:85: debug: extension.staticMethod
[ 268.35]   < return
[ 268.37]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 268.38]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(2)
	test/lang/method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:97: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 268.51]    < return
[ 268.52]   < return
[ 268.53]  < return
[ 268.55]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 268.56]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:91: debug: extension.virtualMethod
[ 268.57]   < return
[ 268.59]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 268.60]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(2)
	test/lang/method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:98: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 268.73]    < return
[ 268.74]   < return
[ 268.75]  < return
[ 268.76]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 268.77]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(3)
	test/lang/method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 268.86]   < return
[ 268.87]  < return
[ 268.88]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 268.89]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 268.97]   < return
[ 268.98]  < return
[ 268.99]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 269.01]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 269.09]   < return
[ 269.10]  < return
[ 270.31]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 270.33]  < return
[ 270.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 270.38]  < return
[ 270.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 270.42]  < return
[ 270.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 270.47]  < return
[ 270.50]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 270.53]  < return
[ 270.55]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 270.58]  < return
[ 270.60]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 270.63]  < return
[ 270.66]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 270.67]  < return
[ 270.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 270.73]  < return
[ 270.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 270.78]  < return
[ 270.82]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 270.85]  < return
[ 270.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 270.91]  < return
[ 270.99]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 271.01]  < return
[ 271.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 271.07]  < return
[ 271.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 271.15]  < return
[ 271.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 271.20]  < return
[ 271.24]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 271.27]  < return
[ 271.32]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 271.35]  < return
[ 271.38]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 271.40]  < return
[ 271.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 271.46]  < return
[ 271.49]  > Math.floor(x: float64): float64
[ 271.50]   > Math.modf(x: float64, intPart: float64): float64
[ 271.51]   < return
[ 271.52]  < return
[ 271.53]  > Math.floor(x: float64): float64
[ 271.54]   > Math.modf(x: float64, intPart: float64): float64
[ 271.55]   < return
[ 271.56]  < return
[ 271.57]  > Math.floor(x: float64): float64
[ 271.58]   > Math.modf(x: float64, intPart: float64): float64
[ 271.59]   < return
[ 271.60]  < return
[ 271.61]  > Math.floor(x: float64): float64
[ 271.62]   > Math.modf(x: float64, intPart: float64): float64
[ 271.63]    > Math.modf(x: float64, intPart: float64): float64
[ 271.64]    < return
[ 271.65]   < return
[ 271.66]  < return
[ 271.67]  > Math.floor(x: float64): float64
[ 271.68]   > Math.modf(x: float64, intPart: float64): float64
[ 271.69]    > Math.modf(x: float64, intPart: float64): float64
[ 271.70]    < return
[ 271.71]   < return
[ 271.71]  < return
[ 271.73]  > Math.floor(x: float64): float64
[ 271.74]   > Math.modf(x: float64, intPart: float64): float64
[ 271.75]    > Math.modf(x: float64, intPart: float64): float64
[ 271.76]    < return
[ 271.77]   < return
[ 271.77]  < return
[ 271.87]  > Math.abs(x: float64): float64
[ 271.88]  < return
[ 271.90]  > Math.abs(x: float64): float64
[ 271.90]  < return
[ 271.92]  > Math.abs(x: float64): float64
[ 271.93]  < return
[ 271.94]  > Math.abs(x: float32): float32
[ 271.95]  < return
[ 271.97]  > Math.abs(x: float32): float32
[ 271.98]  < return
[ 271.99]  > Math.abs(x: float32): float32
[ 272.00]  < return
[ 272.02]  > Math.min(a: float32, b: float32): float32
[ 272.02]  < return
[ 272.04]  > Math.max(a: float32, b: float32): float32
[ 272.05]  < return
[ 272.07]  > Math.min(a: float64, b: float64): float64
[ 272.08]  < return
[ 272.09]  > Math.max(a: float64, b: float64): float64
[ 272.10]  < return
[ 272.12]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 272.13]  < return
[ 272.15]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 272.16]  < return
[ 272.21]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 272.22]  < return
[ 272.26]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 272.27]  < return
[ 272.30]  > Math.min(data: float64[]): float64
[ 272.31]  < return
[ 272.34]  > Math.min(data: float64[]): float64
[ 272.39]  < return
[ 272.41]  > Math.max(data: float64[]): float64
[ 272.42]  < return
[ 272.45]  > Math.max(data: float64[]): float64
[ 272.50]  < return
[ 272.51]  > Math.sum(data: float64[]): float64
[ 272.53]  < return
[ 272.55]  > Math.sum(data: float64[]): float64
[ 272.57]  < return
[ 272.59]  > Math.sum(data: float64[]): float64
[ 272.61]  < return
[ 272.64]  > Math.sum(data: float64[]): float64
[ 272.69]  < return
[ 272.71]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 272.73]  < return
[ 272.80]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 272.84]  < return
[ 272.86]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 272.90]  < return
[ 272.92]  > Math.sinCos(arg: float64, quad: int32): float64
[ 272.95]  < return
[ 272.97]  > Math.abs(x: float64): float64
[ 272.98]  < return
[ 272.99]  > Math.sinCos(arg: float64, quad: int32): float64
[ 273.02]  < return
[ 273.04]  > Math.tan(arg: float64): float64
[ 273.05]   > Math.modf(x: float64, intPart: float64): float64
[ 273.06]   < return
[ 273.09]  < return
[ 273.11]  > Math.sinh(x: float64): float64
[ 273.12]   > float64.exp(x: float64): float64
[ 273.13]   < return
[ 273.14]   > float64.exp(x: float64): float64
[ 273.14]   < return
[ 273.15]  < return
[ 273.17]  > Math.cosh(x: float64): float64
[ 273.18]   > float64.exp(x: float64): float64
[ 273.19]   < return
[ 273.20]   > float64.exp(x: float64): float64
[ 273.21]   < return
[ 273.21]  < return
[ 273.23]  > Math.asin(x: float64): float64
[ 273.24]   > float64.sqrt(x: float64): float64
[ 273.25]   < return
[ 273.26]   > float64.atan2(x: float64, y: float64): float64
[ 273.27]   < return
[ 273.28]  < return
[ 273.30]  > Math.asin(x: float64): float64
[ 273.31]   > float64.sqrt(x: float64): float64
[ 273.32]   < return
[ 273.33]   > float64.atan2(x: float64, y: float64): float64
[ 273.33]   < return
[ 273.34]  < return
[ 273.36]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 273.37]  < return
[ 273.39]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 273.40]  < return
[ 273.42]  > Math.absMod(val: float64, mod: float64): float64
[ 273.43]  < return
[ 273.45]  > Math.absMod(val: float64, mod: float64): float64
[ 273.46]  < return
[ 273.47]  > Math.absMod(val: float64, mod: float64): float64
[ 273.48]  < return
[ 273.50]  > Math.absMod(val: float64, mod: float64): float64
[ 273.51]  < return
[ 273.52]  > Math.absMod(val: float64, mod: float64): float64
[ 273.53]  < return
[ 273.55]  > Math.absMod(val: float64, mod: float64): float64
[ 273.56]  < return
[ 273.57]  > Math.absMod(val: float64, mod: float64): float64
[ 273.58]  < return
[ 273.60]  > Math.absMod(val: float64, mod: float64): float64
[ 273.61]  < return
[ 273.63]  > Math.absMod(val: float64, mod: float64): float64
[ 273.63]  < return
[ 273.65]  > Math.absMod(val: float64, mod: float64): float64
[ 273.66]  < return
[ 273.68]  > Math.absMod(val: float64, mod: float64): float64
[ 273.69]  < return
[ 273.70]  > Math.absMod(val: float32, mod: float32): float32
[ 273.71]  < return
[ 273.73]  > Math.absMod(val: float32, mod: float32): float32
[ 273.74]  < return
[ 273.75]  > Math.absMod(val: float32, mod: float32): float32
[ 273.76]  < return
[ 273.78]  > Math.absMod(val: float32, mod: float32): float32
[ 273.79]  < return
[ 273.81]  > Math.absMod(val: float32, mod: float32): float32
[ 273.81]  < return
[ 273.83]  > Math.absMod(val: float32, mod: float32): float32
[ 273.84]  < return
[ 273.86]  > Math.absMod(val: float32, mod: float32): float32
[ 273.87]  < return
[ 273.88]  > Math.absMod(val: float32, mod: float32): float32
[ 273.89]  < return
[ 273.91]  > Math.absMod(val: float32, mod: float32): float32
[ 273.92]  < return
[ 273.93]  > Math.absMod(val: float32, mod: float32): float32
[ 273.94]  < return
[ 273.96]  > Math.absMod(val: float32, mod: float32): float32
[ 273.97]  < return
[ 273.99]  > halt(): void
[ 273.99]  < return
[ 274.00] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:59: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:75: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:27: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:40: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:52: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(225464)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(225160)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:57: globalFunction: function(<globalFunction>)
test/lang/method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:84: staticMethod: function(<staticMethod>)
test/lang/method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:38: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:39: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:40: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:43: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:44: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:45: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:46: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:48: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:49: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:50: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:51: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:52: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:67: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:68: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 344035(336.0 Kb)
memory[heap] @053fe3; size: 1228571(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 328208(320.5 Kb)
memory[code] @000000; size: 15489(15.1 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @053ff8; size: 1228528(1.2 Mb)

---------- Profile functions: 79/113, coverage: 69.91%
::[.005c20, .005c20): exec(2), time(0.015 ms): halt(): void
::[.005f68, .005f68): exec(3), time(0.028 ms): typename.base(type: typename): typename
::[.006168, .006168): exec(2), time(0.019 ms): typename.file(type: typename): .cstr
::[.006368, .006368): exec(2), time(0.018 ms): typename.line(type: typename): int32
::[.006568, .006568): exec(2), time(0.020 ms): typename.name(type: typename): .cstr
::[.006d00, .006d00): exec(40), time(1.661 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0075e0, .0075e0): exec(7), time(1.439 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007880, .007880): exec(8), time(0.072 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007bb8, .007bb8): exec(2), time(0.018 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007ef0, .007ef0): exec(2), time(0.019 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008220, .008220): exec(1), time(0.010 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0084c8, .0084c8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0086d0, .0086d0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008838, .008838): exec(0), time(0.000 ms): System.rand(): int32
::[.0089a0, .0089a0): exec(0), time(0.000 ms): System.time(): int32
::[.008b08, .008b08): exec(0), time(0.000 ms): System.clock(): int32
::[.008c70, .008c70): exec(0), time(0.000 ms): System.millis(): int64
::[.008e70, .008e70): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0091a8, .0091a8): exec(7), time(0.068 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.0094d8, .0094d8): exec(7), time(0.059 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0096d8, .0096d8): exec(1), time(0.009 ms): uint32.pop(value: int32): int32
::[.0098d8, .0098d8): exec(1), time(0.008 ms): uint32.swap(value: int32): int32
::[.009ad8, .009ad8): exec(1), time(0.008 ms): uint32.bsr(value: int32): int32
::[.009cd8, .009cd8): exec(1), time(0.009 ms): uint32.bsf(value: int32): int32
::[.009ed8, .009ed8): exec(1), time(0.009 ms): uint32.hib(value: int32): int32
::[.00a0d8, .00a0d8): exec(1), time(0.009 ms): uint32.lob(value: int32): int32
::[.00a400, .00a400): exec(1), time(0.009 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00a728, .00a728): exec(1), time(0.009 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00a928, .00a928): exec(1), time(0.011 ms): float32.sin(x: float32): float32
::[.00ab28, .00ab28): exec(1), time(0.009 ms): float32.cos(x: float32): float32
::[.00ad28, .00ad28): exec(1), time(0.011 ms): float32.tan(x: float32): float32
::[.00af28, .00af28): exec(1), time(0.008 ms): float32.log(x: float32): float32
::[.00b128, .00b128): exec(1), time(0.009 ms): float32.exp(x: float32): float32
::[.00b3c0, .00b3c0): exec(1), time(0.009 ms): float32.pow(x: float32, y: float32): float32
::[.00b5c0, .00b5c0): exec(1), time(0.008 ms): float32.sqrt(x: float32): float32
::[.00b858, .00b858): exec(1), time(0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00ba50, .00ba50): exec(1), time(0.022 ms): float64.sin(x: float64): float64
::[.00bc48, .00bc48): exec(1), time(0.014 ms): float64.cos(x: float64): float64
::[.00be40, .00be40): exec(1), time(0.009 ms): float64.tan(x: float64): float64
::[.00c038, .00c038): exec(1), time(0.013 ms): float64.log(x: float64): float64
::[.00c230, .00c230): exec(5), time(0.041 ms): float64.exp(x: float64): float64
::[.00c4c0, .00c4c0): exec(1), time(0.009 ms): float64.pow(x: float64, y: float64): float64
::[.00c6b8, .00c6b8): exec(3), time(0.023 ms): float64.sqrt(x: float64): float64
::[.00c948, .00c948): exec(3), time(0.027 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:75:[.050210, .05026e): exec(8), time(0.085 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.050270, .0502c6): exec(10), time(0.126 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.0502c8, .0502e0): exec(6), time(0.215-0.115 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.0502e0, .0502f2): exec(3), time(0.029 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.0502f8, .05030a): exec(4), time(0.040 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.050310, .05032b): exec(11), time(0.110 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.050330, .05034b): exec(11), time(0.112 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.050350, .050361): exec(1), time(0.009 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.050368, .050379): exec(1), time(0.009 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.050380, .050391): exec(1), time(0.010 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.050398, .0503a9): exec(1), time(0.010 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.0503b0, .0503ce): exec(2), time(0.022 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.0503d0, .0503ee): exec(2), time(0.023 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.0503f0, .050438): exec(2), time(0.060 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.050438, .050480): exec(2), time(0.061 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.050480, .0504a8): exec(4), time(0.110 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.0504a8, .0504d7): exec(3), time(0.088 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.0504d8, .050511): exec(1), time(0.012 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.050518, .050551): exec(1), time(0.012 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.050558, .0506a7): exec(2), time(0.063 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.0506a8, .05081b): exec(1), time(0.053-0.011 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.050820, .050911): exec(1), time(0.048-0.016 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.050918, .050963): exec(1), time(0.040-0.016 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.050968, .050a0e): exec(2), time(0.098-0.031 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:24:[.050a10, .050a17): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:31:[.050a18, .050a1f): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:83:[.050a20, .050a9b): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:114:[.050aa0, .050abf): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:132:[.050ac0, .050b24): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:4:[.050b28, .050b4e): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.050b50, .050b82): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.050b88, .050bba): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.050bc0, .050c09): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.050c10, .050c8e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.050c90, .050ccf): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.050cd0, .050d17): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.050d18, .050d3c): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.050d40, .050d4e): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.050d50, .050da4): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.050db8, .051049): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:207:[.051050, .051067): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:212:[.051068, .051099): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:222:[.0510b0, .0510c9): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:16:[.0510d0, .0510d7): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:28:[.0510d8, .0510e5): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:27:[.0510e8, .051119): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:40:[.051120, .051135): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:52:[.051138, .0512d9): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:4:[.0512e8, .0512e9): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.0512f0, .0512f8): exec(2), time(0.022 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.0512f8, .051300): exec(2), time(0.020 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.051300, .051336): exec(753), time(15.580 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.051338, .051339): exec(1), time(0.011 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.051340, .051358): exec(64-64), time(1.155 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.051358, .051364): exec(1-1), time(0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.051368, .0513ac): exec(1-1), time(0.121-0.095 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.0513b0, .0513bd): exec(1-1), time(0.012 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.0513c0, .0513c2): exec(1-1), time(0.010 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.0513c8, .0513cc): exec(5), time(0.059 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.0513d0, .0513dc): exec(21), time(0.276 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.0513e0, .0513ec): exec(21), time(0.272 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.0513f0, .0513fc): exec(14), time(0.185 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:10:[.051430, .051457): exec(3), time(0.361-0.300 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.051460, .051487): exec(4), time(0.457-0.375 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:47:[.051488, .0514af): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:57:[.0514b0, .0514d7): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:84:[.0514d8, .05151a): exec(1), time(0.207-0.172 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:90:[.051520, .05155f): exec(1), time(0.204-0.170 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.05155f, .053fe3): exec(1), time(27.963-21.537 ms): .main

---------- Profile statements: 886/1136, coverage: 77.99%
lib/stdlib.ci:77:[.050219, .05021a) exec(8), time(0.049-0.049 ms): <assertEq+9>
lib/stdlib.ci:76:[.050210, .05021a) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:80:[.05021e, .050229) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:81:[.050229, .050234) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:82:[.050234, .050237) exec(0), time(0.000 ms): <assertEq+36>
::[.050237, .050243) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:79:[.05021a, .050243) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:84:[.050243, .050269) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.050288, .050299) exec(3), time(0.055-0.055 ms): <modf+24>
lib/std/math.ci:26:[.050299, .0502a0) exec(3), time(0.002-0.002 ms): <modf+41>
lib/std/math.ci:27:[.0502a0, .0502a3) exec(3), time(0.018-0.018 ms): <modf+48>
lib/std/math.ci:24:[.050280, .0502a7) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.0502a7, .0502ab) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.0502ab, .0502af) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.050270, .0502af) exec(10-3), time(0.006-0.006 ms): <modf+0>
lib/std/math.ci:32:[.0502af, .0502bb) exec(7), time(0.006-0.006 ms): <modf+63>
lib/std/math.ci:33:[.0502bb, .0502c3) exec(7), time(0.004-0.004 ms): <modf+75>
lib/std/math.ci:34:[.0502c3, .0502c6) exec(7), time(0.042-0.042 ms): <modf+83>
lib/std/math.ci:48:[.0502c8, .0502c9) exec(6), time(0.005-0.005 ms): <floor+0>
lib/std/math.ci:49:[.0502c9, .0502dd) exec(6), time(0.155-0.155 ms): <floor+1>
lib/std/math.ci:50:[.0502dd, .0502e0) exec(6), time(0.037-0.037 ms): <floor+21>
lib/std/math.ci:79:[.0502e8, .0502ee) exec(1), time(0.007-0.007 ms): <abs+8>
lib/std/math.ci:78:[.0502e0, .0502ee) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.0502ee, .0502f2) exec(2), time(0.013-0.013 ms): <abs+14>
lib/std/math.ci:87:[.050300, .050306) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:86:[.0502f8, .050306) exec(4-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:89:[.050306, .05030a) exec(3), time(0.019-0.019 ms): <abs+14>
lib/std/math.ci:95:[.05031f, .050327) exec(4), time(0.027-0.027 ms): <absMod+15>
lib/std/math.ci:94:[.050310, .050327) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:97:[.050327, .05032b) exec(7), time(0.042-0.042 ms): <absMod+23>
lib/std/math.ci:103:[.05033f, .050347) exec(4), time(0.025-0.025 ms): <absMod+15>
lib/std/math.ci:102:[.050330, .050347) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:105:[.050347, .05034b) exec(7), time(0.045-0.045 ms): <absMod+23>
lib/std/math.ci:117:[.050359, .05035d) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:116:[.050350, .05035d) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.05035d, .050361) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.050371, .050375) exec(1), time(0.006-0.006 ms): <min+9>
lib/std/math.ci:124:[.050368, .050375) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.050375, .050379) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.050389, .05038d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.050380, .05038d) exec(1), time(0.000 ms): <max+0>
lib/std/math.ci:141:[.05038d, .050391) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:147:[.0503a1, .0503a5) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.050398, .0503a5) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.0503a5, .0503a9) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:161:[.0503b9, .0503bd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.0503b0, .0503bd) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:164:[.0503c6, .0503ca) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:163:[.0503bd, .0503ca) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:166:[.0503ca, .0503ce) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:172:[.0503d9, .0503dd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.0503d0, .0503dd) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:175:[.0503e6, .0503ea) exec(1), time(0.007-0.007 ms): <clamp+22>
lib/std/math.ci:174:[.0503dd, .0503ea) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:177:[.0503ea, .0503ee) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:203:[.0503f8, .0503fd) exec(1), time(0.006-0.006 ms): <min+8>
lib/std/math.ci:202:[.0503f0, .0503fd) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:205:[.0503fd, .050400) exec(1), time(0.000 ms): <min+13>
lib/std/math.ci:208:[.050419, .050424) exec(2), time(0.002-0.002 ms): <min+41>
lib/std/math.ci:207:[.050409, .050424) exec(8-2), time(0.004-0.004 ms): <min+25>
lib/std/math.ci:206:[.050424, .050428) exec(8), time(0.005-0.005 ms): <min+52>
lib/std/math.ci:206:[.050428, .050431) exec(9), time(0.008-0.008 ms): <min+56>
lib/std/math.ci:206:[.050400, .050435) exec(1), time(0.002-0.002 ms): <min+16>
lib/std/math.ci:211:[.050435, .050438) exec(1), time(0.006-0.006 ms): <min+69>
lib/std/math.ci:217:[.050440, .050445) exec(1), time(0.006-0.006 ms): <max+8>
lib/std/math.ci:216:[.050438, .050445) exec(2-1), time(0.000 ms): <max+0>
lib/std/math.ci:219:[.050445, .050448) exec(1), time(0.001-0.001 ms): <max+13>
lib/std/math.ci:222:[.050461, .05046c) exec(2), time(0.002-0.002 ms): <max+41>
lib/std/math.ci:221:[.050451, .05046c) exec(8-2), time(0.005-0.005 ms): <max+25>
lib/std/math.ci:220:[.05046c, .050470) exec(8), time(0.005-0.005 ms): <max+52>
lib/std/math.ci:220:[.050470, .050479) exec(9), time(0.007-0.007 ms): <max+56>
lib/std/math.ci:220:[.050448, .05047d) exec(1), time(0.002-0.002 ms): <max+16>
lib/std/math.ci:225:[.05047d, .050480) exec(1), time(0.006-0.006 ms): <max+69>
lib/std/math.ci:230:[.050480, .050481) exec(4), time(0.004-0.004 ms): <sum+0>
lib/std/math.ci:232:[.050486, .050494) exec(13), time(0.012-0.012 ms): <sum+6>
lib/std/math.ci:231:[.050494, .050498) exec(13), time(0.008-0.008 ms): <sum+20>
lib/std/math.ci:231:[.050498, .0504a1) exec(17), time(0.017-0.017 ms): <sum+24>
lib/std/math.ci:231:[.050481, .0504a5) exec(4), time(0.005-0.005 ms): <sum+1>
lib/std/math.ci:234:[.0504a5, .0504a8) exec(4), time(0.025-0.025 ms): <sum+37>
lib/std/math.ci:257:[.0504a8, .0504a9) exec(3), time(0.000 ms): <eval+0>
lib/std/math.ci:259:[.0504b3, .0504c4) exec(11), time(0.013-0.013 ms): <eval+11>
lib/std/math.ci:258:[.0504c4, .0504c8) exec(11), time(0.006-0.006 ms): <eval+28>
lib/std/math.ci:258:[.0504c8, .0504d0) exec(14), time(0.012-0.012 ms): <eval+32>
lib/std/math.ci:258:[.0504a9, .0504d4) exec(3), time(0.005-0.005 ms): <eval+1>
lib/std/math.ci:261:[.0504d4, .0504d7) exec(3), time(0.020-0.020 ms): <eval+44>
lib/std/math.ci:268:[.0504ed, .0504f5) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.0504e1, .0504f5) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:273:[.050505, .05050d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.0504f9, .05050d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.0504d8, .05050d) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:276:[.05050d, .050511) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:283:[.05052d, .050535) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.050521, .050535) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:288:[.050545, .05054d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.050539, .05054d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.050518, .05054d) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:291:[.05054d, .050551) exec(1), time(0.007-0.007 ms): <cmp+53>
lib/std/math.ci:309:[.050558, .05055a) exec(2), time(0.001-0.001 ms): <sinCos+0>
lib/std/math.ci:311:[.050562, .050563) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.050563, .05056b) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.05055a, .05056b) exec(2), time(0.001-0.001 ms): <sinCos+2>
lib/std/math.ci:315:[.05056b, .05056c) exec(2), time(0.002-0.002 ms): <sinCos+19>
lib/std/math.ci:316:[.05056c, .050584) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:318:[.050594, .050595) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.050595, .0505a7) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.0505a7, .0505ab) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.0505ab, .0505ac) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.0505ac, .0505ca) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.0505ca, .0505dc) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.0505e4, .0505e7) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:328:[.0505e7, .0505ef) exec(2), time(0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:329:[.0505ef, .0505f6) exec(2), time(0.001-0.001 ms): <sinCos+151>
lib/std/math.ci:330:[.0505f6, .0505fc) exec(2), time(0.002-0.002 ms): <sinCos+158>
lib/std/math.ci:317:[.050584, .050600) exec(2), time(0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:333:[.050608, .050616) exec(1), time(0.000 ms): <sinCos+176>
lib/std/math.ci:332:[.050600, .050616) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:336:[.050622, .050623) exec(1), time(0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:335:[.050616, .050623) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:339:[.050623, .050628) exec(2), time(0.002-0.002 ms): <sinCos+203>
lib/std/math.ci:340:[.050628, .050668) exec(2), time(0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:341:[.050668, .05069b) exec(2), time(0.004-0.004 ms): <sinCos+272>
lib/std/math.ci:342:[.05069b, .0506a7) exec(2), time(0.013-0.013 ms): <sinCos+323>
lib/std/math.ci:365:[.0506a8, .0506a9) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:366:[.0506a9, .0506aa) exec(1), time(0.000 ms): <tan+1>
lib/std/math.ci:369:[.0506b2, .0506b7) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.0506b7, .0506c1) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.0506aa, .0506c1) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:372:[.0506c1, .0506d9) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:374:[.0506d9, .0506da) exec(1), time(0.000 ms): <tan+49>
lib/std/math.ci:375:[.0506da, .0506ea) exec(1), time(0.018-0.018 ms): <tan+50>
lib/std/math.ci:376:[.0506ea, .0506f3) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:380:[.050707, .050715) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:381:[.050715, .05071f) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:384:[.05072f, .05073a) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.05073a, .050744) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.050754, .050762) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.050762, .05076d) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.050748, .05076d) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.050723, .05076d) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.0506fb, .05076d) exec(1), time(0.002-0.002 ms): <tan+83>
lib/std/math.ci:378:[.0506f3, .05076d) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.05076d, .050772) exec(1), time(0.001-0.001 ms): <tan+197>
lib/std/math.ci:393:[.050772, .0507b2) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:394:[.0507b2, .0507d9) exec(1), time(0.001-0.001 ms): <tan+266>
lib/std/math.ci:398:[.0507ea, .0507f3) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.0507e2, .0507f3) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:400:[.0507f3, .050801) exec(1), time(0.001-0.001 ms): <tan+331>
lib/std/math.ci:396:[.0507d9, .050801) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.05080a, .050814) exec(0), time(0.000 ms): <tan+354>
lib/std/math.ci:402:[.050801, .050814) exec(1), time(0.000 ms): <tan+345>
lib/std/math.ci:405:[.050814, .05081b) exec(1), time(0.007-0.007 ms): <tan+364>
lib/std/math.ci:421:[.050820, .050821) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:423:[.050829, .05082e) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.05082e, .050838) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.050821, .050838) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:428:[.050848, .05085f) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.050838, .05085f) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:431:[.05085f, .050860) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:433:[.050870, .05088a) exec(1), time(0.030-0.030 ms): <sinh+80>
lib/std/math.ci:436:[.05088e, .050893) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.050893, .0508c8) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.0508c8, .0508f3) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.050860, .0508f7) exec(1), time(0.031-0.031 ms): <sinh+64>
lib/std/math.ci:442:[.050900, .05090a) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.0508f7, .05090a) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:444:[.05090a, .050911) exec(1), time(0.006-0.006 ms): <sinh+234>
lib/std/math.ci:450:[.050920, .050925) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.050918, .050925) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:453:[.050935, .050948) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.050925, .050948) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:455:[.050948, .050963) exec(1), time(0.035-0.035 ms): <cosh+48>
lib/std/math.ci:466:[.050970, .050974) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.050968, .050974) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:469:[.050974, .050975) exec(2), time(0.002-0.002 ms): <asin+12>
lib/std/math.ci:471:[.05097d, .050987) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.050987, .05098c) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.050975, .05098c) exec(2), time(0.001-0.001 ms): <asin+13>
lib/std/math.ci:477:[.05099c, .0509a5) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.05098c, .0509a5) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:480:[.0509a5, .0509b8) exec(2), time(0.030-0.030 ms): <asin+61>
lib/std/math.ci:482:[.0509c8, .0509e6) exec(0), time(0.000 ms): <asin+96>
lib/std/math.ci:485:[.0509ea, .0509f4) exec(2), time(0.030-0.030 ms): <asin+130>
lib/std/math.ci:481:[.0509b8, .0509f4) exec(2-2), time(0.000 ms): <asin+80>
lib/std/math.ci:489:[.0509fd, .050a07) exec(0), time(0.000 ms): <asin+149>
lib/std/math.ci:488:[.0509f4, .050a07) exec(2), time(0.001-0.001 ms): <asin+140>
lib/std/math.ci:491:[.050a07, .050a0e) exec(2), time(0.013-0.013 ms): <asin+159>
::[.050a13, .050a16) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:25:[.050a10, .050a17) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:34:[.050a1b, .050a1e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:32:[.050a18, .050a1f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:88:[.050a3f, .050a44) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:89:[.050a44, .050a4c) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:92:[.050a59, .050a66) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:90:[.050a4c, .050a6b) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:87:[.050a20, .050a6f) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:95:[.050a6f, .050a74) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:96:[.050a74, .050a7c) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:99:[.050a89, .050a96) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:97:[.050a7c, .050a9b) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:115:[.050aa0, .050aab) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:118:[.050ab2, .050aba) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:116:[.050aab, .050abf) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:133:[.050ac0, .050ad7) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:134:[.050ad7, .050ae7) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:135:[.050ae7, .050af6) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:136:[.050af6, .050b09) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:139:[.050b14, .050b1f) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:137:[.050b09, .050b24) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:6:[.050b34, .050b38) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.050b28, .050b38) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.050b38, .050b39) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.050b3d, .050b41) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.050b41, .050b4b) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.050b39, .050b4b) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.050b4b, .050b4e) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.050b65, .050b68) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.050b55, .050b68) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.050b68, .050b6c) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.050b6c, .050b76) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.050b50, .050b7a) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.050b7a, .050b82) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.050b88, .050b8d) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.050ba2, .050ba5) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.050b92, .050ba5) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.050ba5, .050ba9) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.050ba9, .050bb3) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.050b8d, .050bb7) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.050bb7, .050bba) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.050bdf, .050bea) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.050bc5, .050bea) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.050bea, .050bee) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.050bee, .050bfa) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.050bc0, .050bfe) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.050bfe, .050c09) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.050c10, .050c1d) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.050c1d, .050c2a) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.050c33, .050c3e) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.050c2a, .050c3e) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.050c63, .050c6e) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.050c43, .050c6e) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.050c6e, .050c72) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.050c72, .050c7b) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.050c3e, .050c7f) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.050c7f, .050c8e) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.050c90, .050c91) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.050c96, .050cac) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.050cb8, .050cbc) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.050cac, .050cbc) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.050cbc, .050cc0) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.050cc0, .050cc8) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.050c91, .050ccc) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.050ccc, .050ccf) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.050cdf, .050cea) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.050cd0, .050cea) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.050cf9, .050d04) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.050cea, .050d04) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.050d04, .050d17) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.050d18, .050d3c) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.050d40, .050d4e) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.050d5e, .050d62) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.050d55, .050d62) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.050d62, .050d6e) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.050d6e, .050d76) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.050d76, .050d7a) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.050d7a, .050d84) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.050d50, .050d88) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.050d91, .050d99) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.050d88, .050d99) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.050d99, .050da0) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.050da0, .050da4) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.050db8, .050db9) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.050db9, .050dbd) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:150:[.050dbd, .050dc0) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:151:[.050dc0, .050df6) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:152:[.050df6, .050e2b) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:156:[.050e2f, .050e4a) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:155:[.050e4a, .050e51) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:155:[.050e51, .050e59) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:155:[.050e2b, .050e59) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:159:[.050e61, .050e76) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:158:[.050e59, .050e76) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:162:[.050e76, .050e80) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:164:[.050e80, .050e87) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:166:[.050e92, .050e9c) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:165:[.050e87, .050e9c) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:171:[.050ea7, .050eaf) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:175:[.050ecd, .050f01) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:176:[.050f01, .050f0c) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:177:[.050f0c, .050f14) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:174:[.050f14, .050f1c) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:174:[.050f1c, .050f24) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:174:[.050ec9, .050f24) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:172:[.050eaf, .050f24) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:180:[.050f24, .050f58) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:181:[.050f58, .050f63) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:182:[.050f63, .050f6b) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:170:[.050e9c, .050f6b) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:187:[.050f6f, .050fa3) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:188:[.050fa3, .050fae) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:189:[.050fae, .050fb6) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:186:[.050fb6, .050fbe) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:186:[.050fbe, .050fc6) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:186:[.050f6b, .050fc6) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:194:[.050fcb, .050fff) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:195:[.050fff, .051010) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:196:[.051010, .051018) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:193:[.051018, .05101c) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:193:[.05101c, .051025) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:193:[.050fc6, .051029) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:200:[.051032, .05103a) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:199:[.051029, .05103a) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:202:[.05103a, .051041) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:203:[.051041, .051049) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:208:[.051050, .051067) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:213:[.051068, .051069) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:215:[.051071, .051078) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:216:[.051078, .05107d) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:214:[.051069, .05107d) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:218:[.05107d, .051099) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:224:[.0510b0, .0510c9) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:19:[.0510d3, .0510d6) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:17:[.0510d0, .0510d7) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:29:[.0510db, .0510de) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:29:[.0510de, .0510e1) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:29:[.0510e1, .0510e4) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:29:[.0510d8, .0510e5) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:32:[.0510eb, .0510ee) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:32:[.0510ee, .0510f1) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:32:[.0510f1, .0510f4) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:33:[.0510f4, .0510f7) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:33:[.0510f7, .0510fa) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:33:[.0510fa, .0510fd) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:33:[.0510fd, .051100) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:34:[.051100, .051103) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:34:[.051103, .051106) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:34:[.051106, .051109) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:34:[.051109, .05110c) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:35:[.05110c, .05110f) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:35:[.05110f, .051112) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:35:[.051112, .051115) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:35:[.051115, .051118) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:31:[.0510e8, .051119) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:41:[.051125, .05112a) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:41:[.05112a, .05112f) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:41:[.05112f, .051134) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:41:[.051120, .051135) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:54:[.05113c, .051141) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:54:[.051141, .05114a) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:54:[.05114a, .051153) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:54:[.051153, .05115c) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:55:[.05115c, .051165) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:55:[.051165, .05116e) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:55:[.05116e, .051177) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:55:[.051177, .051180) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:56:[.051180, .051189) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:56:[.051189, .051192) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:56:[.051192, .05119b) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:56:[.05119b, .0511a4) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:57:[.0511a4, .0511ad) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:57:[.0511ad, .0511b6) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:57:[.0511b6, .0511bf) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:57:[.0511bf, .0511c8) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:53:[.051138, .0511c8) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:61:[.051208, .05124c) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:62:[.05124c, .051290) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:63:[.051290, .0512d4) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:59:[.0511c8, .0512d9) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:8:[.0512f0, .0512f8) exec(2), time(0.017-0.017 ms): <funAdd+0>
test/lang/function.ci:34:[.0512f8, .051300) exec(2), time(0.019-0.019 ms): <funMul+0>
test/lang/function.ci:40:[.05130c, .051310) exec(377), time(2.775-2.775 ms): <fib+12>
test/lang/function.ci:39:[.051300, .051310) exec(753-377), time(0.724-0.724 ms): <fib+0>
test/lang/function.ci:42:[.051310, .051336) exec(376-375), time(15.576-15.576 ms): <fib+16>
test/stdc/tryExec.ci:15:[.051340, .051344) exec(64-1), time(0.037-0.037 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.051344, .051353) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.051358, .05135f) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.05136c, .051373) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.051373, .05137a) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.05137a, .051381) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.051368, .051381) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.051381, .0513a7) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.0513b0, .0513b5) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.0513b5, .0513b8) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.0513c0, .0513c2) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.0513c8, .0513cc) exec(5), time(0.036-0.036 ms): <lenSlice+0>
test/lang/array.ci:104:[.0513d0, .0513dc) exec(21), time(0.197-0.197 ms): <nthFixed+0>
test/lang/array.ci:105:[.0513e0, .0513ec) exec(21), time(0.191-0.191 ms): <nthArray+0>
test/lang/array.ci:106:[.0513f0, .0513fc) exec(14), time(0.130-0.130 ms): <nthSlice+0>
test/lang/method.ci:11:[.051430, .051456) exec(3), time(0.330-0.330 ms): <staticMethod+0>
test/lang/method.ci:41:[.051460, .051486) exec(4), time(0.416-0.416 ms): <virtualMethod+0>
test/lang/method.ci:48:[.051488, .0514ae) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:58:[.0514b0, .0514d6) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:85:[.0514d8, .0514fb) exec(1), time(0.026-0.026 ms): <staticMethod+0>
test/lang/method.ci:87:[.051509, .051519) exec(1), time(0.166-0.166 ms): <staticMethod+49>
test/lang/method.ci:86:[.0514fb, .051519) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:91:[.051520, .051543) exec(1), time(0.026-0.026 ms): <virtualMethod+0>
test/lang/method.ci:93:[.051551, .05155e) exec(1), time(0.163-0.163 ms): <virtualMethod+49>
test/lang/method.ci:92:[.051543, .05155e) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.05155f, .05156d) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.05156d, .05157b) exec(1), time(0.001-0.001 ms): <.main+14>
::[.051584, .05158b) exec(1), time(0.002-0.002 ms): <.main+37>
::[.05158b, .051590) exec(1), time(0.001-0.001 ms): <.main+44>
::[.051590, .051595) exec(1), time(0.001-0.001 ms): <.main+49>
lib/std/string.ci:223:[.05157b, .051595) exec(1-1), time(0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.051595, .0515a2) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.0515a2, .0515a7) exec(1), time(0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.0515a7, .0515b0) exec(1), time(0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.0515b0, .0515b9) exec(1), time(0.001-0.001 ms): <.main+81>
test/lang/member.ci:47:[.0515c2, .0515cb) exec(1), time(0.001-0.001 ms): <.main+99>
test/lang/member.ci:47:[.0515b9, .0515cb) exec(1-1), time(0.000 ms): <.main+90>
test/lang/member.ci:50:[.0515d4, .0515dd) exec(1), time(0.001-0.001 ms): <.main+117>
test/lang/member.ci:50:[.0515cb, .0515dd) exec(1-1), time(0.000 ms): <.main+108>
test/lang/method.ci:18:[.0515dd, .0515e6) exec(1), time(0.001-0.001 ms): <.main+126>
test/lang/emit.ci:3:[.0515e6, .0515e7) exec(1), time(0.001-0.001 ms): <.main+135>
test/lang/emit.ci:4:[.0515e7, .0515e8) exec(1), time(0.001-0.001 ms): <.main+136>
test/lang/emit.ci:6:[.0515e8, .0515ed) exec(1), time(0.000 ms): <.main+137>
test/lang/emit.ci:7:[.0515ed, .0515f2) exec(1), time(0.001-0.001 ms): <.main+142>
test/lang/emit.ci:9:[.0515f2, .0515f7) exec(1), time(0.002-0.002 ms): <.main+147>
test/lang/emit.ci:10:[.0515f7, .051602) exec(1), time(0.001-0.001 ms): <.main+152>
test/lang/emit.ci:17:[.051602, .051607) exec(1), time(0.001-0.001 ms): <.main+163>
test/lang/emit.ci:18:[.051607, .05160d) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/emit.ci:19:[.05160d, .051617) exec(1), time(0.001-0.001 ms): <.main+174>
test/lang/emit.ci:20:[.051617, .051620) exec(1), time(0.000 ms): <.main+184>
test/lang/emit.ci:23:[.051620, .05162a) exec(1), time(0.001-0.001 ms): <.main+193>
test/lang/inlineMacros.ci:10:[.05162a, .05162f) exec(1), time(0.001-0.001 ms): <.main+203>
test/lang/inlineMacros.ci:11:[.05162f, .051634) exec(1), time(0.000 ms): <.main+208>
test/lang/inlineMacros.ci:12:[.051634, .051639) exec(1), time(0.000 ms): <.main+213>
test/lang/inlineMacros.ci:13:[.051639, .05163e) exec(1), time(0.001-0.001 ms): <.main+218>
test/lang/inlineMacros.ci:15:[.05163e, .05163f) exec(1), time(0.000 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.05163f, .051640) exec(1), time(0.001-0.001 ms): <.main+224>
test/lang/inlineMacros.ci:17:[.051640, .051641) exec(1), time(0.001-0.001 ms): <.main+225>
test/lang/inlineMacros.ci:19:[.051641, .051646) exec(1), time(0.000 ms): <.main+226>
test/lang/inlineMacros.ci:20:[.051646, .051648) exec(1), time(0.001-0.001 ms): <.main+231>
test/lang/inlineMacros.ci:21:[.051648, .051652) exec(1), time(0.002-0.002 ms): <.main+233>
test/lang/inlineMacros.ci:23:[.051652, .05165b) exec(1), time(0.001-0.001 ms): <.main+243>
test/lang/inlineMacros.ci:24:[.05165b, .051660) exec(1), time(0.001-0.001 ms): <.main+252>
test/lang/inlineMacros.ci:25:[.051660, .051671) exec(1), time(0.003-0.003 ms): <.main+257>
test/lang/inlineMacros.ci:27:[.051671, .051689) exec(1), time(0.003-0.003 ms): <.main+274>
test/lang/inlineMacros.ci:28:[.051689, .05169b) exec(1), time(0.004-0.004 ms): <.main+298>
test/lang/inlineMacros.ci:29:[.05169b, .0516b9) exec(1), time(0.004-0.004 ms): <.main+316>
test/lang/inlineMacros.ci:31:[.0516b9, .0516da) exec(1), time(0.006-0.006 ms): <.main+346>
test/lang/inlineMacros.ci:32:[.0516da, .0516f5) exec(1), time(0.005-0.005 ms): <.main+379>
test/lang/inlineMacros.ci:33:[.0516f5, .05171c) exec(1), time(0.008-0.008 ms): <.main+406>
test/lang/inlineMacros.ci:35:[.05171c, .05173d) exec(1), time(0.005-0.005 ms): <.main+445>
test/lang/inlineMacros.ci:36:[.05173d, .051758) exec(1), time(0.005-0.005 ms): <.main+478>
test/lang/inlineMacros.ci:37:[.051758, .05177f) exec(1), time(0.006-0.006 ms): <.main+505>
test/lang/inlineMacros.ci:41:[.05177f, .051794) exec(1), time(0.003-0.003 ms): <.main+544>
test/lang/inlineMacros.ci:42:[.051794, .0517a5) exec(1), time(0.002-0.002 ms): <.main+565>
test/lang/inlineMacros.ci:43:[.0517a5, .0517b0) exec(1), time(0.004-0.004 ms): <.main+582>
test/lang/inlineMacros.ci:44:[.0517b0, .0517bb) exec(1), time(0.004-0.004 ms): <.main+593>
test/lang/inlineMacros.ci:45:[.0517bb, .0517da) exec(1), time(0.006-0.006 ms): <.main+604>
test/lang/inlineMacros.ci:46:[.0517da, .0517f9) exec(1), time(0.007-0.007 ms): <.main+635>
test/lang/inlineMacros.ci:50:[.0517f9, .051837) exec(1), time(0.003-0.003 ms): <.main+666>
test/lang/inlineMacros.ci:51:[.051837, .051875) exec(1), time(0.008-0.008 ms): <.main+728>
test/lang/inlineMacros.ci:52:[.051875, .0518a7) exec(1), time(0.003-0.003 ms): <.main+790>
test/lang/inlineMacros.ci:53:[.0518a7, .0518d9) exec(1), time(0.009-0.009 ms): <.main+840>
test/lang/inlineMacros.ci:54:[.0518d9, .05191f) exec(1), time(0.004-0.004 ms): <.main+890>
test/lang/inlineMacros.ci:55:[.05191f, .051965) exec(1), time(0.010-0.010 ms): <.main+960>
test/lang/inlineMacros.ci:59:[.051965, .0519be) exec(1), time(0.014-0.014 ms): <.main+1030>
test/lang/inlineMacros.ci:60:[.0519be, .051a17) exec(1), time(0.015-0.015 ms): <.main+1119>
test/lang/inlineMacros.ci:61:[.051a17, .051a64) exec(1), time(0.015-0.015 ms): <.main+1208>
test/lang/inlineMacros.ci:62:[.051a64, .051ab1) exec(1), time(0.015-0.015 ms): <.main+1285>
test/lang/inlineMacros.ci:63:[.051ab1, .051b12) exec(1), time(0.018-0.018 ms): <.main+1362>
test/lang/inlineMacros.ci:64:[.051b12, .051b73) exec(1), time(0.018-0.018 ms): <.main+1459>
test/lang/inlineMacros.ci:68:[.051b73, .051bcc) exec(1), time(0.014-0.014 ms): <.main+1556>
test/lang/inlineMacros.ci:69:[.051bcc, .051c25) exec(1), time(0.015-0.015 ms): <.main+1645>
test/lang/inlineMacros.ci:70:[.051c25, .051c72) exec(1), time(0.014-0.014 ms): <.main+1734>
test/lang/inlineMacros.ci:71:[.051c72, .051cbf) exec(1), time(0.015-0.015 ms): <.main+1811>
test/lang/inlineMacros.ci:72:[.051cbf, .051d20) exec(1), time(0.017-0.017 ms): <.main+1888>
test/lang/inlineMacros.ci:73:[.051d20, .051d81) exec(1), time(0.018-0.018 ms): <.main+1985>
test/lang/overload.inline.ci:9:[.051d81, .051d86) exec(1), time(0.001-0.001 ms): <.main+2082>
test/lang/overload.inline.ci:10:[.051d86, .051d8b) exec(1), time(0.000 ms): <.main+2087>
test/lang/overload.inline.ci:11:[.051d8b, .051d90) exec(1), time(0.000 ms): <.main+2092>
test/lang/overload.inline.ci:12:[.051d90, .051d95) exec(1), time(0.001-0.001 ms): <.main+2097>
test/lang/overload.inline.ci:13:[.051d95, .051d9a) exec(1), time(0.000 ms): <.main+2102>
test/lang/overload.inline.ci:28:[.051d9a, .051da3) exec(1), time(0.000 ms): <.main+2107>
test/lang/overload.inline.ci:29:[.051da3, .051db9) exec(1), time(0.003-0.003 ms): <.main+2116>
test/lang/initByRef.ci:8:[.051db9, .051dbe) exec(1), time(0.001-0.001 ms): <.main+2138>
test/lang/initByRef.ci:9:[.051dbe, .051dc3) exec(1), time(0.001-0.001 ms): <.main+2143>
test/lang/initByRef.ci:10:[.051dc3, .051dcd) exec(1), time(0.001-0.001 ms): <.main+2148>
test/lang/initByRef.ci:12:[.051dcd, .051dd0) exec(1), time(0.001-0.001 ms): <.main+2158>
test/lang/initByRef.ci:13:[.051dd0, .051dd2) exec(1), time(0.001-0.001 ms): <.main+2161>
test/lang/initByRef.ci:14:[.051dd2, .051dd4) exec(1), time(0.001-0.001 ms): <.main+2163>
test/lang/initByRef.ci:16:[.051dd4, .051dd9) exec(1), time(0.000 ms): <.main+2165>
test/lang/initByRef.ci:17:[.051dd9, .051dde) exec(1), time(0.001-0.001 ms): <.main+2170>
test/lang/initByRef.ci:18:[.051dde, .051de8) exec(1), time(0.001-0.001 ms): <.main+2175>
test/lang/initByRef.ci:19:[.051de8, .051ded) exec(1), time(0.001-0.001 ms): <.main+2185>
test/lang/initByRef.ci:20:[.051ded, .051df2) exec(1), time(0.001-0.001 ms): <.main+2190>
test/lang/initByRef.ci:21:[.051df2, .051df7) exec(1), time(0.000 ms): <.main+2195>
test/lang/initByRef.ci:23:[.051df7, .051dfc) exec(1), time(0.001-0.001 ms): <.main+2200>
test/lang/initByRef.ci:24:[.051dfc, .051e06) exec(1), time(0.001-0.001 ms): <.main+2205>
test/lang/initByRef.ci:25:[.051e06, .051e0b) exec(1), time(0.001-0.001 ms): <.main+2215>
test/lang/initByRef.ci:27:[.051e0b, .051e0f) exec(1), time(0.001-0.001 ms): <.main+2220>
test/lang/initByRef.ci:28:[.051e0f, .051e11) exec(1), time(0.000 ms): <.main+2224>
test/lang/initByRef.ci:29:[.051e11, .051e13) exec(1), time(0.001-0.001 ms): <.main+2226>
test/lang/initByRef.ci:30:[.051e13, .051e15) exec(1), time(0.001-0.001 ms): <.main+2228>
test/lang/initByRef.ci:31:[.051e15, .051e17) exec(1), time(0.000 ms): <.main+2230>
test/lang/initByRef.ci:32:[.051e17, .051e19) exec(1), time(0.001-0.001 ms): <.main+2232>
test/lang/initByRef.ci:35:[.051e19, .051e1e) exec(1), time(0.001-0.001 ms): <.main+2234>
test/lang/initByRef.ci:36:[.051e1e, .051e23) exec(1), time(0.000 ms): <.main+2239>
test/lang/initByRef.ci:37:[.051e23, .051e28) exec(1), time(0.000 ms): <.main+2244>
test/lang/initByRef.ci:38:[.051e28, .051e2d) exec(1), time(0.001-0.001 ms): <.main+2249>
test/lang/initByRef.ci:39:[.051e2d, .051e32) exec(1), time(0.000 ms): <.main+2254>
test/lang/initByRef.ci:40:[.051e32, .051e37) exec(1), time(0.000 ms): <.main+2259>
test/lang/initByRef.ci:41:[.051e37, .051e3c) exec(1), time(0.001-0.001 ms): <.main+2264>
test/lang/initByRef.ci:42:[.051e3c, .051e41) exec(1), time(0.001-0.001 ms): <.main+2269>
test/lang/initByRef.ci:43:[.051e41, .051e46) exec(1), time(0.000 ms): <.main+2274>
test/lang/initByRef.ci:44:[.051e46, .051e4b) exec(1), time(0.001-0.001 ms): <.main+2279>
test/lang/initByRef.ci:45:[.051e4b, .051e50) exec(1), time(0.001-0.001 ms): <.main+2284>
test/lang/initByRef.ci:46:[.051e50, .051e55) exec(1), time(0.000 ms): <.main+2289>
test/lang/initByRef.ci:47:[.051e55, .051e5a) exec(1), time(0.001-0.001 ms): <.main+2294>
test/lang/initByRef.ci:48:[.051e5a, .051e5f) exec(1), time(0.001-0.001 ms): <.main+2299>
test/lang/initByRef.ci:49:[.051e5f, .051e64) exec(1), time(0.000 ms): <.main+2304>
test/lang/initByRef.ci:50:[.051e64, .051e69) exec(1), time(0.001-0.001 ms): <.main+2309>
test/lang/initByRef.ci:51:[.051e69, .051e6e) exec(1), time(0.001-0.001 ms): <.main+2314>
test/lang/initByRef.ci:52:[.051e6e, .051e73) exec(1), time(0.000 ms): <.main+2319>
test/lang/initByRef.ci:55:[.051e73, .051e7d) exec(1), time(0.001-0.001 ms): <.main+2324>
test/lang/initByRef.ci:56:[.051e7d, .051e87) exec(1), time(0.001-0.001 ms): <.main+2334>
test/lang/initByRef.ci:57:[.051e87, .051e91) exec(1), time(0.001-0.001 ms): <.main+2344>
test/lang/initByRef.ci:58:[.051e91, .051e9b) exec(1), time(0.001-0.001 ms): <.main+2354>
test/lang/initByRef.ci:59:[.051e9b, .051ea5) exec(1), time(0.001-0.001 ms): <.main+2364>
test/lang/initByRef.ci:60:[.051ea5, .051eaf) exec(1), time(0.001-0.001 ms): <.main+2374>
test/lang/initByRef.ci:61:[.051eaf, .051eb9) exec(1), time(0.001-0.001 ms): <.main+2384>
test/lang/initByRef.ci:62:[.051eb9, .051ec3) exec(1), time(0.001-0.001 ms): <.main+2394>
test/lang/initByRef.ci:63:[.051ec3, .051ecd) exec(1), time(0.002-0.002 ms): <.main+2404>
test/lang/initByRef.ci:64:[.051ecd, .051ed7) exec(1), time(0.001-0.001 ms): <.main+2414>
test/lang/initByRef.ci:65:[.051ed7, .051ee1) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/initByRef.ci:66:[.051ee1, .051eeb) exec(1), time(0.001-0.001 ms): <.main+2434>
test/lang/initByRef.ci:67:[.051eeb, .051ef5) exec(1), time(0.001-0.001 ms): <.main+2444>
test/lang/initByRef.ci:68:[.051ef5, .051eff) exec(1), time(0.002-0.002 ms): <.main+2454>
test/lang/initByRef.ci:69:[.051eff, .051f09) exec(1), time(0.001-0.001 ms): <.main+2464>
test/lang/initByRef.ci:70:[.051f09, .051f13) exec(1), time(0.001-0.001 ms): <.main+2474>
test/lang/initByRef.ci:71:[.051f13, .051f1d) exec(1), time(0.001-0.001 ms): <.main+2484>
test/lang/initByRef.ci:72:[.051f1d, .051f27) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:75:[.051f27, .051f2c) exec(1), time(0.001-0.001 ms): <.main+2504>
test/lang/initByRef.ci:76:[.051f2c, .051f31) exec(1), time(0.001-0.001 ms): <.main+2509>
test/lang/initByRef.ci:77:[.051f31, .051f36) exec(1), time(0.000 ms): <.main+2514>
test/lang/initByRef.ci:78:[.051f36, .051f3b) exec(1), time(0.001-0.001 ms): <.main+2519>
test/lang/initByRef.ci:79:[.051f3b, .051f40) exec(1), time(0.001-0.001 ms): <.main+2524>
test/lang/initByRef.ci:80:[.051f40, .051f45) exec(1), time(0.000 ms): <.main+2529>
test/lang/initByRef.ci:81:[.051f45, .051f4a) exec(1), time(0.000 ms): <.main+2534>
test/lang/initByRef.ci:82:[.051f4a, .051f4f) exec(1), time(0.001-0.001 ms): <.main+2539>
test/lang/initByRef.ci:83:[.051f4f, .051f54) exec(1), time(0.001-0.001 ms): <.main+2544>
test/lang/initByRef.ci:84:[.051f54, .051f59) exec(1), time(0.000 ms): <.main+2549>
test/lang/initByRef.ci:85:[.051f59, .051f5e) exec(1), time(0.001-0.001 ms): <.main+2554>
test/lang/initByRef.ci:86:[.051f5e, .051f63) exec(1), time(0.001-0.001 ms): <.main+2559>
test/lang/initByRef.ci:87:[.051f63, .051f68) exec(1), time(0.001-0.001 ms): <.main+2564>
test/lang/initByRef.ci:88:[.051f68, .051f6d) exec(1), time(0.000 ms): <.main+2569>
test/lang/initByRef.ci:89:[.051f6d, .051f72) exec(1), time(0.001-0.001 ms): <.main+2574>
test/lang/initByRef.ci:90:[.051f72, .051f77) exec(1), time(0.001-0.001 ms): <.main+2579>
test/lang/initByRef.ci:91:[.051f77, .051f7c) exec(1), time(0.001-0.001 ms): <.main+2584>
test/lang/initByRef.ci:92:[.051f7c, .051f81) exec(1), time(0.000 ms): <.main+2589>
test/lang/initByRef.ci:95:[.051f81, .051f86) exec(1), time(0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:96:[.051f86, .051f90) exec(1), time(0.001-0.001 ms): <.main+2599>
test/lang/initByRef.ci:97:[.051f90, .051f95) exec(1), time(0.000 ms): <.main+2609>
test/lang/initByRef.ci:99:[.051f95, .051f9a) exec(1), time(0.001-0.001 ms): <.main+2614>
test/lang/initByRef.ci:105:[.051f9a, .051fa1) exec(1), time(0.001-0.001 ms): <.main+2619>
test/lang/initByRef.ci:108:[.051fa1, .051fa3) exec(1), time(0.000 ms): <.main+2626>
test/lang/function.ci:12:[.051fa3, .051fb8) exec(1), time(0.024-0.024 ms): <.main+2628>
test/lang/function.ci:15:[.051fb8, .051fbd) exec(1), time(0.000 ms): <.main+2649>
test/lang/function.ci:18:[.051fbd, .051fcf) exec(1), time(0.022-0.022 ms): <.main+2654>
test/lang/function.ci:21:[.051fcf, .051fd4) exec(1), time(0.000 ms): <.main+2672>
test/lang/function.ci:24:[.051fd4, .051fe6) exec(1), time(0.021-0.021 ms): <.main+2677>
test/lang/function.ci:27:[.051fe6, .051fe8) exec(1), time(0.001-0.001 ms): <.main+2695>
test/lang/function.ci:30:[.051fe8, .051ffa) exec(1), time(0.023-0.023 ms): <.main+2697>
test/lang/function.ci:46:[.051ffa, .05200a) exec(1), time(15.590-15.590 ms): <.main+2715>
test/lang/reflect.ci:3:[.05200a, .05200e) exec(1), time(0.000 ms): <.main+2731>
test/lang/reflect.ci:4:[.05200e, .052012) exec(1), time(0.001-0.001 ms): <.main+2735>
test/lang/reflect.ci:5:[.052012, .052016) exec(1), time(0.001-0.001 ms): <.main+2739>
test/lang/reflect.ci:6:[.052016, .05201a) exec(1), time(0.000 ms): <.main+2743>
test/lang/reflect.ci:7:[.05201a, .05201e) exec(1), time(0.000 ms): <.main+2747>
test/lang/reflect.ci:8:[.05201e, .052022) exec(1), time(0.001-0.001 ms): <.main+2751>
test/lang/reflect.ci:9:[.052022, .052026) exec(1), time(0.001-0.001 ms): <.main+2755>
test/lang/reflect.ci:10:[.052026, .05202a) exec(1), time(0.000 ms): <.main+2759>
test/lang/reflect.ci:11:[.05202a, .05202e) exec(1), time(0.000 ms): <.main+2763>
test/lang/reflect.ci:12:[.05202e, .052032) exec(1), time(0.001-0.001 ms): <.main+2767>
test/lang/reflect.ci:13:[.052032, .052036) exec(1), time(0.001-0.001 ms): <.main+2771>
test/lang/reflect.ci:14:[.052036, .05203a) exec(1), time(0.000 ms): <.main+2775>
test/lang/reflect.ci:15:[.05203a, .05203e) exec(1), time(0.000 ms): <.main+2779>
test/lang/reflect.ci:16:[.05203e, .052042) exec(1), time(0.001-0.001 ms): <.main+2783>
test/lang/reflect.ci:17:[.052042, .052046) exec(1), time(0.001-0.001 ms): <.main+2787>
test/lang/reflect.ci:18:[.052046, .05204a) exec(1), time(0.000 ms): <.main+2791>
test/lang/reflect.ci:19:[.05204a, .05204e) exec(1), time(0.000 ms): <.main+2795>
test/lang/reflect.ci:20:[.05204e, .052052) exec(1), time(0.001-0.001 ms): <.main+2799>
test/lang/reflect.ci:30:[.052052, .052057) exec(1), time(0.001-0.001 ms): <.main+2803>
test/lang/reflect.ci:31:[.052057, .05205d) exec(1), time(0.019-0.019 ms): <.main+2808>
test/lang/reflect.ci:32:[.05205d, .052064) exec(1), time(0.002-0.002 ms): <.main+2814>
test/lang/reflect.ci:33:[.052064, .05206b) exec(1), time(0.002-0.002 ms): <.main+2821>
test/lang/reflect.ci:34:[.05206b, .052071) exec(1), time(0.017-0.017 ms): <.main+2828>
test/lang/reflect.ci:35:[.052071, .052077) exec(1), time(0.017-0.017 ms): <.main+2834>
test/lang/reflect.ci:37:[.052077, .05207d) exec(1), time(0.017-0.017 ms): <.main+2840>
test/lang/reflect.ci:38:[.05207d, .052083) exec(1), time(0.017-0.017 ms): <.main+2846>
test/lang/reflect.ci:39:[.052083, .05208a) exec(1), time(0.003-0.003 ms): <.main+2852>
test/lang/reflect.ci:40:[.05208a, .052091) exec(1), time(0.002-0.002 ms): <.main+2859>
test/lang/reflect.ci:41:[.052091, .052097) exec(1), time(0.017-0.017 ms): <.main+2866>
test/lang/reflect.ci:42:[.052097, .05209d) exec(1), time(0.018-0.018 ms): <.main+2872>
test/lang/reflect.ci:44:[.05209d, .0520a3) exec(1), time(0.018-0.018 ms): <.main+2878>
test/lang/reflect.ci:45:[.0520a3, .0520aa) exec(1), time(0.002-0.002 ms): <.main+2884>
test/lang/reflect.ci:46:[.0520aa, .0520b1) exec(1), time(0.002-0.002 ms): <.main+2891>
test/lang/reflect.ci:48:[.0520b1, .0520b7) exec(1), time(0.016-0.016 ms): <.main+2898>
test/lang/reflect.ci:49:[.0520b7, .0520be) exec(1), time(0.002-0.002 ms): <.main+2904>
test/lang/reflect.ci:50:[.0520be, .0520c5) exec(1), time(0.002-0.002 ms): <.main+2911>
test/stdc/number.ci:3:[.0520c5, .0520ce) exec(1), time(0.001-0.001 ms): <.main+2918>
test/stdc/number.ci:4:[.0520ce, .0520d7) exec(1), time(0.001-0.001 ms): <.main+2927>
test/stdc/number.ci:6:[.0520d7, .0520da) exec(1), time(0.001-0.001 ms): <.main+2936>
test/stdc/number.ci:7:[.0520da, .0520dd) exec(1), time(0.001-0.001 ms): <.main+2939>
test/stdc/number.ci:14:[.0520dd, .0520e4) exec(1), time(0.002-0.002 ms): <.main+2942>
test/stdc/number.ci:15:[.0520e4, .0520eb) exec(1), time(0.001-0.001 ms): <.main+2949>
test/stdc/number.ci:16:[.0520eb, .0520f2) exec(1), time(0.001-0.001 ms): <.main+2956>
test/stdc/number.ci:18:[.0520f2, .05210e) exec(1), time(0.013-0.013 ms): <.main+2963>
test/stdc/number.ci:19:[.05210e, .052128) exec(1), time(0.010-0.010 ms): <.main+2991>
test/stdc/number.ci:21:[.052128, .052138) exec(1), time(0.027-0.027 ms): <.main+3017>
test/stdc/number.ci:22:[.052138, .052148) exec(1), time(0.018-0.018 ms): <.main+3033>
test/stdc/number.ci:23:[.052148, .052154) exec(1), time(0.018-0.018 ms): <.main+3049>
test/stdc/number.ci:25:[.052154, .052164) exec(1), time(0.018-0.018 ms): <.main+3061>
test/stdc/number.ci:26:[.052164, .052174) exec(1), time(0.018-0.018 ms): <.main+3077>
test/stdc/number.ci:27:[.052174, .052180) exec(1), time(0.018-0.018 ms): <.main+3093>
test/stdc/number.ci:29:[.052180, .052190) exec(1), time(0.018-0.018 ms): <.main+3105>
test/stdc/number.ci:30:[.052190, .0521a0) exec(1), time(0.018-0.018 ms): <.main+3121>
test/stdc/number.ci:31:[.0521a0, .0521ac) exec(1), time(0.017-0.017 ms): <.main+3137>
test/stdc/number.ci:33:[.0521ac, .0521bc) exec(1), time(0.018-0.018 ms): <.main+3149>
test/stdc/number.ci:34:[.0521bc, .0521cc) exec(1), time(0.018-0.018 ms): <.main+3165>
test/stdc/number.ci:35:[.0521cc, .0521d8) exec(1), time(0.018-0.018 ms): <.main+3181>
test/stdc/number.ci:37:[.0521d8, .0521e8) exec(1), time(0.033-0.033 ms): <.main+3193>
test/stdc/number.ci:38:[.0521e8, .0521f8) exec(1), time(0.024-0.024 ms): <.main+3209>
test/stdc/number.ci:39:[.0521f8, .052208) exec(1), time(0.019-0.019 ms): <.main+3225>
test/stdc/number.ci:40:[.052208, .052214) exec(1), time(0.025-0.025 ms): <.main+3241>
test/stdc/number.ci:41:[.052214, .052221) exec(1), time(0.017-0.017 ms): <.main+3253>
test/stdc/number.ci:42:[.052221, .052233) exec(1), time(0.019-0.019 ms): <.main+3266>
test/stdc/number.ci:43:[.052233, .05223c) exec(1), time(0.018-0.018 ms): <.main+3284>
test/stdc/number.ci:44:[.05223c, .05224b) exec(1), time(0.020-0.020 ms): <.main+3293>
test/stdc/number.ci:46:[.05224b, .052257) exec(1), time(0.021-0.021 ms): <.main+3308>
test/stdc/number.ci:47:[.052257, .052263) exec(1), time(0.019-0.019 ms): <.main+3320>
test/stdc/number.ci:48:[.052263, .05226f) exec(1), time(0.021-0.021 ms): <.main+3332>
test/stdc/number.ci:49:[.05226f, .05227b) exec(1), time(0.020-0.020 ms): <.main+3344>
test/stdc/number.ci:50:[.05227b, .052284) exec(1), time(0.016-0.016 ms): <.main+3356>
test/stdc/number.ci:51:[.052284, .052292) exec(1), time(0.019-0.019 ms): <.main+3365>
test/stdc/number.ci:52:[.052292, .05229b) exec(1), time(0.018-0.018 ms): <.main+3379>
test/stdc/number.ci:53:[.05229b, .0522a6) exec(1), time(0.021-0.021 ms): <.main+3388>
test/stdc/number.ci:55:[.0522a6, .0522ac) exec(1), time(0.017-0.017 ms): <.main+3399>
test/stdc/number.ci:56:[.0522ac, .0522b2) exec(1), time(0.017-0.017 ms): <.main+3405>
test/stdc/number.ci:57:[.0522b2, .0522b8) exec(1), time(0.017-0.017 ms): <.main+3411>
test/stdc/number.ci:58:[.0522b8, .0522be) exec(1), time(0.017-0.017 ms): <.main+3417>
test/stdc/number.ci:59:[.0522be, .0522c4) exec(1), time(0.016-0.016 ms): <.main+3423>
test/stdc/number.ci:60:[.0522c4, .0522ca) exec(1), time(0.020-0.020 ms): <.main+3429>
test/stdc/number.ci:62:[.0522ca, .0522d6) exec(1), time(0.019-0.019 ms): <.main+3435>
test/stdc/number.ci:63:[.0522d6, .0522e2) exec(1), time(0.019-0.019 ms): <.main+3447>
test/stdc/number.ci:65:[.0522e2, .0522f0) exec(1), time(0.020-0.020 ms): <.main+3459>
test/stdc/number.ci:66:[.0522f0, .0522fe) exec(1), time(0.020-0.020 ms): <.main+3473>
test/stdc/memory.ci:7:[.0522fe, .05230c) exec(1), time(0.018-0.018 ms): <.main+3487>
test/stdc/memory.ci:8:[.05230c, .05231a) exec(1), time(0.018-0.018 ms): <.main+3501>
test/stdc/memory.ci:9:[.05231a, .052328) exec(1), time(0.017-0.017 ms): <.main+3515>
test/stdc/memory.ci:10:[.052328, .052336) exec(1), time(0.017-0.017 ms): <.main+3529>
test/stdc/memory.ci:13:[.052336, .052346) exec(1), time(0.020-0.020 ms): <.main+3543>
test/stdc/memory.ci:14:[.052346, .052357) exec(1), time(0.020-0.020 ms): <.main+3559>
test/stdc/memory.ci:17:[.052357, .052362) exec(1), time(0.019-0.019 ms): <.main+3576>
test/stdc/memory.ci:18:[.052362, .05236d) exec(1), time(0.018-0.018 ms): <.main+3587>
test/stdc/memory.ci:19:[.05236d, .052378) exec(1), time(0.018-0.018 ms): <.main+3598>
test/stdc/memory.ci:20:[.052378, .052383) exec(1), time(0.018-0.018 ms): <.main+3609>
test/stdc/memory.ci:23:[.052383, .05238c) exec(1), time(0.001-0.001 ms): <.main+3620>
test/stdc/memory.ci:24:[.05238c, .052395) exec(1), time(0.001-0.001 ms): <.main+3629>
test/stdc/memory.ci:26:[.052395, .0523b7) exec(1), time(0.037-0.037 ms): <.main+3638>
test/stdc/memory.ci:27:[.0523b7, .0523d9) exec(1), time(0.035-0.035 ms): <.main+3672>
test/stdc/memory.ci:29:[.0523d9, .0523ed) exec(1), time(0.020-0.020 ms): <.main+3706>
test/stdc/memory.ci:30:[.0523ed, .0523fe) exec(1), time(0.020-0.020 ms): <.main+3726>
test/stdc/memory.ci:32:[.0523fe, .052420) exec(1), time(0.036-0.036 ms): <.main+3743>
test/stdc/memory.ci:33:[.052420, .052442) exec(1), time(0.035-0.035 ms): <.main+3777>
test/stdc/tryExec.ci:46:[.052442, .052450) exec(1), time(0.052-0.052 ms): <.main+3811>
test/stdc/tryExec.ci:47:[.052450, .05245e) exec(1), time(0.021-0.021 ms): <.main+3825>
test/stdc/tryExec.ci:48:[.05245e, .05246c) exec(1), time(1.178-1.178 ms): <.main+3839>
test/stdc/tryExec.ci:49:[.05246c, .05247a) exec(1), time(0.035-0.035 ms): <.main+3853>
test/stdc/tryExec.ci:50:[.05247a, .052488) exec(1), time(0.034-0.034 ms): <.main+3867>
test/stdc/tryExec.ci:51:[.052488, .052496) exec(1), time(0.036-0.036 ms): <.main+3881>
test/stdc/tryExec.ci:52:[.052496, .0524a4) exec(1), time(0.145-0.145 ms): <.main+3895>
test/lang/array.ci:49:[.0524a4, .0524a8) exec(1), time(0.001-0.001 ms): <.main+3909>
test/lang/array.ci:50:[.0524a8, .0524ac) exec(1), time(0.001-0.001 ms): <.main+3913>
test/lang/array.ci:51:[.0524ac, .0524b0) exec(1), time(0.001-0.001 ms): <.main+3917>
test/lang/array.ci:55:[.0524b5, .0524c9) exec(7), time(0.043-0.043 ms): <.main+3926>
test/lang/array.ci:54:[.0524c9, .0524cd) exec(7), time(0.003-0.003 ms): <.main+3946>
test/lang/array.ci:54:[.0524cd, .0524d9) exec(8), time(0.024-0.024 ms): <.main+3950>
test/lang/array.ci:54:[.0524b0, .0524dd) exec(1), time(0.004-0.004 ms): <.main+3921>
test/lang/array.ci:59:[.0524dd, .0524e2) exec(1), time(0.001-0.001 ms): <.main+3966>
test/lang/array.ci:60:[.0524e2, .0524e8) exec(1), time(0.001-0.001 ms): <.main+3971>
test/lang/array.ci:63:[.0524e8, .0524ec) exec(1), time(0.000 ms): <.main+3977>
test/lang/array.ci:64:[.0524ec, .0524f5) exec(1), time(0.001-0.001 ms): <.main+3981>
test/lang/array.ci:67:[.0524f5, .0524f7) exec(1), time(0.001-0.001 ms): <.main+3990>
test/lang/array.ci:68:[.0524f7, .0524f9) exec(1), time(0.001-0.001 ms): <.main+3992>
test/lang/array.ci:71:[.0524f9, .0524fb) exec(1), time(0.001-0.001 ms): <.main+3994>
test/lang/array.ci:81:[.0524fb, .0524ff) exec(1), time(0.001-0.001 ms): <.main+3996>
test/lang/array.ci:82:[.0524ff, .052515) exec(1), time(0.021-0.021 ms): <.main+4000>
test/lang/array.ci:83:[.052515, .052537) exec(1), time(0.090-0.090 ms): <.main+4022>
test/lang/array.ci:84:[.052537, .052559) exec(1), time(0.085-0.085 ms): <.main+4056>
test/lang/array.ci:86:[.052559, .05255e) exec(1), time(0.000 ms): <.main+4090>
test/lang/array.ci:87:[.05255e, .05257e) exec(1), time(0.040-0.040 ms): <.main+4095>
test/lang/array.ci:88:[.05257e, .05259e) exec(1), time(0.040-0.040 ms): <.main+4127>
test/lang/array.ci:90:[.05259e, .0525a8) exec(1), time(0.001-0.001 ms): <.main+4159>
test/lang/array.ci:91:[.0525a8, .0525c8) exec(1), time(0.039-0.039 ms): <.main+4169>
test/lang/array.ci:92:[.0525c8, .0525e8) exec(1), time(0.039-0.039 ms): <.main+4201>
test/lang/array.ci:98:[.0525e8, .05261b) exec(1), time(0.004-0.004 ms): <.main+4233>
test/lang/array.ci:99:[.05261b, .05264e) exec(1), time(0.003-0.003 ms): <.main+4284>
test/lang/array.ci:101:[.05264e, .052689) exec(1), time(0.004-0.004 ms): <.main+4335>
test/lang/array.ci:108:[.052689, .0526a2) exec(1), time(0.021-0.021 ms): <.main+4394>
test/lang/array.ci:109:[.0526a2, .0526b8) exec(1), time(0.021-0.021 ms): <.main+4419>
test/lang/array.ci:110:[.0526b8, .0526ce) exec(1), time(0.023-0.023 ms): <.main+4441>
test/lang/array.ci:112:[.0526ce, .0526ee) exec(1), time(0.043-0.043 ms): <.main+4463>
test/lang/array.ci:113:[.0526ee, .05270b) exec(1), time(0.049-0.049 ms): <.main+4495>
test/lang/array.ci:114:[.05270b, .052733) exec(1), time(0.046-0.046 ms): <.main+4524>
test/lang/array.ci:115:[.052733, .052754) exec(1), time(0.043-0.043 ms): <.main+4564>
test/lang/array.ci:116:[.052754, .052775) exec(1), time(0.043-0.043 ms): <.main+4597>
test/lang/array.ci:119:[.05277a, .052783) exec(7), time(0.021-0.021 ms): <.main+4635>
test/lang/array.ci:120:[.052783, .0527c0) exec(7), time(0.045-0.045 ms): <.main+4644>
test/lang/array.ci:121:[.0527c0, .0527fb) exec(7), time(0.045-0.045 ms): <.main+4705>
test/lang/array.ci:122:[.0527fb, .052836) exec(7), time(0.044-0.044 ms): <.main+4764>
test/lang/array.ci:124:[.052836, .052879) exec(7), time(0.197-0.197 ms): <.main+4823>
test/lang/array.ci:125:[.052879, .0528ba) exec(7), time(0.197-0.197 ms): <.main+4890>
test/lang/array.ci:126:[.0528ba, .0528fb) exec(7), time(0.196-0.196 ms): <.main+4955>
test/lang/array.ci:128:[.0528fb, .05293e) exec(7), time(0.196-0.196 ms): <.main+5020>
test/lang/array.ci:129:[.05293e, .05297f) exec(7), time(0.198-0.198 ms): <.main+5087>
test/lang/array.ci:130:[.05297f, .0529c0) exec(7), time(0.195-0.195 ms): <.main+5152>
test/lang/array.ci:132:[.0529c0, .052a08) exec(7), time(0.203-0.203 ms): <.main+5217>
test/lang/array.ci:134:[.052a08, .052a49) exec(7), time(0.201-0.201 ms): <.main+5289>
test/lang/array.ci:136:[.052a49, .052a84) exec(7), time(0.043-0.043 ms): <.main+5354>
test/lang/array.ci:118:[.052a88, .052a8c) exec(7), time(0.004-0.004 ms): <.main+5417>
test/lang/array.ci:118:[.052a8c, .052a98) exec(8), time(0.024-0.024 ms): <.main+5421>
test/lang/array.ci:118:[.052775, .052a9c) exec(1), time(0.005-0.005 ms): <.main+4630>
test/lang/member.ci:54:[.052aa0, .052aa7) exec(1), time(0.001-0.001 ms): <.main+5441>
test/lang/member.ci:55:[.052aa7, .052aae) exec(1), time(0.002-0.002 ms): <.main+5448>
test/lang/member.ci:56:[.052aae, .052ab5) exec(1), time(0.002-0.002 ms): <.main+5455>
test/lang/member.ci:57:[.052ab5, .052abc) exec(1), time(0.001-0.001 ms): <.main+5462>
test/lang/member.ci:60:[.052abc, .052ac3) exec(1), time(0.001-0.001 ms): <.main+5469>
test/lang/member.ci:61:[.052ac3, .052aca) exec(1), time(0.001-0.001 ms): <.main+5476>
test/lang/member.ci:65:[.052aca, .052ad1) exec(1), time(0.002-0.002 ms): <.main+5483>
test/lang/member.ci:66:[.052ad1, .052ad8) exec(1), time(0.002-0.002 ms): <.main+5490>
test/lang/member.ci:53:[.052a9c, .052ad8) exec(1-1), time(0.000 ms): <.main+5437>
test/lang/method.ci:64:[.052adc, .052ae3) exec(1), time(0.002-0.002 ms): <.main+5501>
::[.052ae3, .052ae9) exec(1), time(0.002-0.002 ms): <.main+5508>
::[.052ae9, .052af0) exec(1), time(0.002-0.002 ms): <.main+5514>
test/lang/method.ci:62:[.052ad8, .052af0) exec(1-1), time(0.000 ms): <.main+5497>
test/lang/method.ci:78:[.052af0, .052b03) exec(1), time(0.115-0.115 ms): <.main+5521>
test/lang/method.ci:79:[.052b03, .052b13) exec(1), time(0.114-0.114 ms): <.main+5540>
test/lang/method.ci:97:[.052b13, .052b24) exec(1), time(0.218-0.218 ms): <.main+5556>
test/lang/method.ci:98:[.052b24, .052b35) exec(1), time(0.216-0.216 ms): <.main+5573>
test/lang/method.ci:101:[.052b35, .052b48) exec(1), time(0.114-0.114 ms): <.main+5590>
test/lang/method.ci:102:[.052b48, .052b5b) exec(1), time(0.113-0.113 ms): <.main+5609>
test/lang/method.ci:103:[.052b5b, .052b6b) exec(1), time(0.113-0.113 ms): <.main+5628>
test/lang/recUnion.ci:26:[.052b6f, .052b75) exec(1), time(0.002-0.002 ms): <.main+5648>
test/lang/recUnion.ci:26:[.052b75, .052b7b) exec(1), time(0.002-0.002 ms): <.main+5654>
test/lang/recUnion.ci:26:[.052b7b, .052b81) exec(1), time(0.003-0.003 ms): <.main+5660>
test/lang/recUnion.ci:26:[.052b6b, .052b81) exec(1-1), time(0.000 ms): <.main+5644>
test/lang/recUnion.ci:27:[.052b85, .052b8b) exec(1), time(0.002-0.002 ms): <.main+5670>
test/lang/recUnion.ci:27:[.052b8b, .052b95) exec(1), time(0.003-0.003 ms): <.main+5676>
test/lang/recUnion.ci:27:[.052b95, .052b9b) exec(1), time(0.002-0.002 ms): <.main+5686>
test/lang/recUnion.ci:27:[.052b81, .052b9b) exec(1-1), time(0.000 ms): <.main+5666>
test/lang/recUnion.ci:28:[.052b9f, .052ba9) exec(1), time(0.002-0.002 ms): <.main+5696>
test/lang/recUnion.ci:28:[.052ba9, .052bb3) exec(1), time(0.002-0.002 ms): <.main+5706>
test/lang/recUnion.ci:28:[.052bb3, .052bbd) exec(1), time(0.002-0.002 ms): <.main+5716>
test/lang/recUnion.ci:28:[.052b9b, .052bbd) exec(1-1), time(0.000 ms): <.main+5692>
test/lang/recUnion.ci:30:[.052bc1, .052bc8) exec(1), time(0.001-0.001 ms): <.main+5730>
test/lang/recUnion.ci:30:[.052bbd, .052bc8) exec(1-1), time(0.000 ms): <.main+5726>
test/lang/recUnion.ci:31:[.052bcc, .052bd2) exec(1), time(0.002-0.002 ms): <.main+5741>
test/lang/recUnion.ci:31:[.052bd2, .052bd8) exec(1), time(0.002-0.002 ms): <.main+5747>
test/lang/recUnion.ci:31:[.052bd8, .052be2) exec(1), time(0.002-0.002 ms): <.main+5753>
test/lang/recUnion.ci:31:[.052bc8, .052be2) exec(1-1), time(0.000 ms): <.main+5737>
test/lang/useOperator.ci:5:[.052be2, .052be7) exec(1), time(0.001-0.001 ms): <.main+5763>
test/lang/useOperator.ci:7:[.052be7, .052bec) exec(1), time(0.001-0.001 ms): <.main+5768>
test/lang/useOperator.ci:8:[.052bec, .052bf1) exec(1), time(0.001-0.001 ms): <.main+5773>
test/lang/useOperator.ci:17:[.052bf1, .052bfc) exec(1), time(0.004-0.004 ms): <.main+5778>
test/lang/useOperator.ci:18:[.052bfc, .052c07) exec(1), time(0.004-0.004 ms): <.main+5789>
test/lang/useOperator.ci:19:[.052c07, .052c12) exec(1), time(0.004-0.004 ms): <.main+5800>
test/lang/useOperator.ci:22:[.052c12, .052c18) exec(1), time(0.002-0.002 ms): <.main+5811>
test/lang/useOperator.ci:23:[.052c18, .052c23) exec(1), time(0.004-0.004 ms): <.main+5817>
test/lang/useOperator.ci:24:[.052c23, .052c2f) exec(1), time(0.005-0.005 ms): <.main+5828>
test/lang/useOperator.ci:25:[.052c2f, .052c3a) exec(1), time(0.004-0.004 ms): <.main+5840>
test/lang/useOperator.ci:26:[.052c3a, .052c46) exec(1), time(0.005-0.005 ms): <.main+5851>
test/lang/useOperator.ci:27:[.052c46, .052c51) exec(1), time(0.004-0.004 ms): <.main+5863>
test/lang/useOperator.ci:28:[.052c51, .052c5d) exec(1), time(0.005-0.005 ms): <.main+5874>
test/lang/useOperator.ci:30:[.052c5d, .052c62) exec(1), time(0.000 ms): <.main+5886>
test/lang/useOperator.ci:31:[.052c62, .052c67) exec(1), time(0.001-0.001 ms): <.main+5891>
test/lang/useOperator.ci:32:[.052c67, .052c6c) exec(1), time(0.002-0.002 ms): <.main+5896>
test/lang/useOperator.ci:33:[.052c6c, .052c72) exec(1), time(0.003-0.003 ms): <.main+5901>
test/lang/useOperator.ci:34:[.052c72, .052c78) exec(1), time(0.003-0.003 ms): <.main+5907>
test/lang/useOperator.ci:35:[.052c78, .052c83) exec(1), time(0.004-0.004 ms): <.main+5913>
test/lang/useOperator.ci:36:[.052c83, .052c8e) exec(1), time(0.004-0.004 ms): <.main+5924>
test/lang/useOperator.ci:37:[.052c8e, .052c99) exec(1), time(0.004-0.004 ms): <.main+5935>
test/lang/useOperator.ci:38:[.052c99, .052ca4) exec(1), time(0.004-0.004 ms): <.main+5946>
test/lang/useOperator.ci:39:[.052ca4, .052caf) exec(1), time(0.004-0.004 ms): <.main+5957>
test/lang/useOperator.ci:40:[.052caf, .052cba) exec(1), time(0.004-0.004 ms): <.main+5968>
test/lang/useOperator.ci:41:[.052cba, .052cc5) exec(1), time(0.005-0.005 ms): <.main+5979>
test/lang/useOperator.ci:42:[.052cc5, .052cd0) exec(1), time(0.004-0.004 ms): <.main+5990>
test/lang/useOperator.ci:43:[.052cd0, .052cd8) exec(1), time(0.003-0.003 ms): <.main+6001>
test/lang/useOperator.ci:44:[.052cd8, .052ce0) exec(1), time(0.003-0.003 ms): <.main+6009>
test/lang/useOperator.ci:45:[.052ce0, .052ce7) exec(1), time(0.004-0.004 ms): <.main+6017>
test/lang/useOperator.ci:46:[.052ce7, .052cf2) exec(1), time(0.004-0.004 ms): <.main+6024>
test/lang/useOperator.ci:47:[.052cf2, .052cfe) exec(1), time(0.005-0.005 ms): <.main+6035>
test/lang/useOperator.ci:48:[.052cfe, .052d09) exec(1), time(0.004-0.004 ms): <.main+6047>
test/lang/useOperator.ci:49:[.052d09, .052d15) exec(1), time(0.005-0.005 ms): <.main+6058>
test/lang/useOperator.ci:50:[.052d15, .052d20) exec(1), time(0.005-0.005 ms): <.main+6070>
test/lang/useOperator.ci:51:[.052d20, .052d2c) exec(1), time(0.005-0.005 ms): <.main+6081>
test/lang/useOperator.ci:53:[.052d2c, .052d31) exec(1), time(0.000 ms): <.main+6093>
test/lang/useOperator.ci:54:[.052d31, .052d36) exec(1), time(0.000 ms): <.main+6098>
test/lang/useOperator.ci:55:[.052d36, .052d3b) exec(1), time(0.001-0.001 ms): <.main+6103>
test/lang/useOperator.ci:56:[.052d3b, .052d41) exec(1), time(0.003-0.003 ms): <.main+6108>
test/lang/useOperator.ci:57:[.052d41, .052d47) exec(1), time(0.003-0.003 ms): <.main+6114>
test/lang/useOperator.ci:58:[.052d47, .052d52) exec(1), time(0.004-0.004 ms): <.main+6120>
test/lang/useOperator.ci:59:[.052d52, .052d5d) exec(1), time(0.004-0.004 ms): <.main+6131>
test/lang/useOperator.ci:60:[.052d5d, .052d68) exec(1), time(0.004-0.004 ms): <.main+6142>
test/lang/useOperator.ci:61:[.052d68, .052d73) exec(1), time(0.005-0.005 ms): <.main+6153>
test/lang/useOperator.ci:62:[.052d73, .052d7e) exec(1), time(0.004-0.004 ms): <.main+6164>
test/lang/useOperator.ci:63:[.052d7e, .052d89) exec(1), time(0.004-0.004 ms): <.main+6175>
test/lang/useOperator.ci:64:[.052d89, .052d94) exec(1), time(0.004-0.004 ms): <.main+6186>
test/lang/useOperator.ci:65:[.052d94, .052d9f) exec(1), time(0.005-0.005 ms): <.main+6197>
test/lang/useOperator.ci:66:[.052d9f, .052da7) exec(1), time(0.003-0.003 ms): <.main+6208>
test/lang/useOperator.ci:67:[.052da7, .052daf) exec(1), time(0.003-0.003 ms): <.main+6216>
test/lang/useOperator.ci:68:[.052daf, .052db6) exec(1), time(0.003-0.003 ms): <.main+6224>
test/lang/useOperator.ci:69:[.052db6, .052dc1) exec(1), time(0.004-0.004 ms): <.main+6231>
test/lang/useOperator.ci:70:[.052dc1, .052dcd) exec(1), time(0.006-0.006 ms): <.main+6242>
test/lang/useOperator.ci:71:[.052dcd, .052dd8) exec(1), time(0.004-0.004 ms): <.main+6254>
test/lang/useOperator.ci:72:[.052dd8, .052de4) exec(1), time(0.005-0.005 ms): <.main+6265>
test/lang/useOperator.ci:73:[.052de4, .052def) exec(1), time(0.005-0.005 ms): <.main+6277>
test/lang/useOperator.ci:74:[.052def, .052dfb) exec(1), time(0.005-0.005 ms): <.main+6288>
test/lang/useOperator.ci:76:[.052dfb, .052e00) exec(1), time(0.001-0.001 ms): <.main+6300>
test/lang/useOperator.ci:77:[.052e00, .052e05) exec(1), time(0.001-0.001 ms): <.main+6305>
test/lang/useOperator.ci:78:[.052e05, .052e0a) exec(1), time(0.002-0.002 ms): <.main+6310>
test/lang/useOperator.ci:79:[.052e0a, .052e10) exec(1), time(0.002-0.002 ms): <.main+6315>
test/lang/useOperator.ci:80:[.052e10, .052e16) exec(1), time(0.002-0.002 ms): <.main+6321>
test/lang/useOperator.ci:81:[.052e16, .052e21) exec(1), time(0.004-0.004 ms): <.main+6327>
test/lang/useOperator.ci:82:[.052e21, .052e2c) exec(1), time(0.004-0.004 ms): <.main+6338>
test/lang/useOperator.ci:83:[.052e2c, .052e37) exec(1), time(0.005-0.005 ms): <.main+6349>
test/lang/useOperator.ci:84:[.052e37, .052e42) exec(1), time(0.005-0.005 ms): <.main+6360>
test/lang/useOperator.ci:85:[.052e42, .052e4d) exec(1), time(0.005-0.005 ms): <.main+6371>
test/lang/useOperator.ci:86:[.052e4d, .052e58) exec(1), time(0.005-0.005 ms): <.main+6382>
test/lang/useOperator.ci:87:[.052e58, .052e63) exec(1), time(0.004-0.004 ms): <.main+6393>
test/lang/useOperator.ci:88:[.052e63, .052e6e) exec(1), time(0.004-0.004 ms): <.main+6404>
test/lang/useOperator.ci:89:[.052e6e, .052e76) exec(1), time(0.003-0.003 ms): <.main+6415>
test/lang/useOperator.ci:90:[.052e76, .052e7e) exec(1), time(0.003-0.003 ms): <.main+6423>
test/lang/useOperator.ci:91:[.052e7e, .052e85) exec(1), time(0.003-0.003 ms): <.main+6431>
test/lang/useOperator.ci:92:[.052e85, .052e90) exec(1), time(0.004-0.004 ms): <.main+6438>
test/lang/useOperator.ci:93:[.052e90, .052e9c) exec(1), time(0.006-0.006 ms): <.main+6449>
test/lang/useOperator.ci:94:[.052e9c, .052ea7) exec(1), time(0.005-0.005 ms): <.main+6461>
test/lang/useOperator.ci:95:[.052ea7, .052eb3) exec(1), time(0.006-0.006 ms): <.main+6472>
test/lang/useOperator.ci:96:[.052eb3, .052ebe) exec(1), time(0.005-0.005 ms): <.main+6484>
test/lang/useOperator.ci:97:[.052ebe, .052eca) exec(1), time(0.005-0.005 ms): <.main+6495>
test/lang/useOperator.ci:99:[.052eca, .052ecf) exec(1), time(0.001-0.001 ms): <.main+6507>
test/lang/useOperator.ci:100:[.052ecf, .052ed4) exec(1), time(0.001-0.001 ms): <.main+6512>
test/lang/useOperator.ci:101:[.052ed4, .052ed9) exec(1), time(0.002-0.002 ms): <.main+6517>
test/lang/useOperator.ci:102:[.052ed9, .052edf) exec(1), time(0.003-0.003 ms): <.main+6522>
test/lang/useOperator.ci:103:[.052edf, .052ee5) exec(1), time(0.003-0.003 ms): <.main+6528>
test/lang/useOperator.ci:104:[.052ee5, .052ef0) exec(1), time(0.005-0.005 ms): <.main+6534>
test/lang/useOperator.ci:105:[.052ef0, .052efb) exec(1), time(0.005-0.005 ms): <.main+6545>
test/lang/useOperator.ci:106:[.052efb, .052f06) exec(1), time(0.005-0.005 ms): <.main+6556>
test/lang/useOperator.ci:107:[.052f06, .052f11) exec(1), time(0.005-0.005 ms): <.main+6567>
test/lang/useOperator.ci:108:[.052f11, .052f1c) exec(1), time(0.004-0.004 ms): <.main+6578>
test/lang/useOperator.ci:109:[.052f1c, .052f27) exec(1), time(0.004-0.004 ms): <.main+6589>
test/lang/useOperator.ci:110:[.052f27, .052f32) exec(1), time(0.004-0.004 ms): <.main+6600>
test/lang/useOperator.ci:111:[.052f32, .052f3d) exec(1), time(0.004-0.004 ms): <.main+6611>
test/lang/useOperator.ci:112:[.052f3d, .052f45) exec(1), time(0.004-0.004 ms): <.main+6622>
test/lang/useOperator.ci:113:[.052f45, .052f4d) exec(1), time(0.004-0.004 ms): <.main+6630>
test/lang/useOperator.ci:114:[.052f4d, .052f54) exec(1), time(0.004-0.004 ms): <.main+6638>
test/lang/useOperator.ci:115:[.052f54, .052f5f) exec(1), time(0.005-0.005 ms): <.main+6645>
test/lang/useOperator.ci:116:[.052f5f, .052f6b) exec(1), time(0.006-0.006 ms): <.main+6656>
test/lang/useOperator.ci:117:[.052f6b, .052f76) exec(1), time(0.005-0.005 ms): <.main+6668>
test/lang/useOperator.ci:118:[.052f76, .052f82) exec(1), time(0.006-0.006 ms): <.main+6679>
test/lang/useOperator.ci:119:[.052f82, .052f8d) exec(1), time(0.005-0.005 ms): <.main+6691>
test/lang/useOperator.ci:120:[.052f8d, .052f99) exec(1), time(0.006-0.006 ms): <.main+6702>
test/lang/useOperator.ci:122:[.052f99, .052f9e) exec(1), time(0.001-0.001 ms): <.main+6714>
test/lang/useOperator.ci:123:[.052f9e, .052fa3) exec(1), time(0.001-0.001 ms): <.main+6719>
test/lang/useOperator.ci:124:[.052fa3, .052fa8) exec(1), time(0.002-0.002 ms): <.main+6724>
test/lang/useOperator.ci:125:[.052fa8, .052fae) exec(1), time(0.002-0.002 ms): <.main+6729>
test/lang/useOperator.ci:126:[.052fae, .052fb4) exec(1), time(0.002-0.002 ms): <.main+6735>
test/lang/useOperator.ci:127:[.052fb4, .052fbf) exec(1), time(0.004-0.004 ms): <.main+6741>
test/lang/useOperator.ci:128:[.052fbf, .052fca) exec(1), time(0.004-0.004 ms): <.main+6752>
test/lang/useOperator.ci:129:[.052fca, .052fd5) exec(1), time(0.004-0.004 ms): <.main+6763>
test/lang/useOperator.ci:130:[.052fd5, .052fe0) exec(1), time(0.005-0.005 ms): <.main+6774>
test/lang/useOperator.ci:131:[.052fe0, .052feb) exec(1), time(0.005-0.005 ms): <.main+6785>
test/lang/useOperator.ci:132:[.052feb, .052ff6) exec(1), time(0.005-0.005 ms): <.main+6796>
test/lang/useOperator.ci:133:[.052ff6, .053001) exec(1), time(0.005-0.005 ms): <.main+6807>
test/lang/useOperator.ci:134:[.053001, .05300c) exec(1), time(0.005-0.005 ms): <.main+6818>
test/lang/useOperator.ci:135:[.05300c, .053014) exec(1), time(0.003-0.003 ms): <.main+6829>
test/lang/useOperator.ci:136:[.053014, .05301c) exec(1), time(0.003-0.003 ms): <.main+6837>
test/lang/useOperator.ci:137:[.05301c, .053023) exec(1), time(0.004-0.004 ms): <.main+6845>
test/lang/useOperator.ci:138:[.053023, .05302e) exec(1), time(0.005-0.005 ms): <.main+6852>
test/lang/useOperator.ci:139:[.05302e, .05303a) exec(1), time(0.006-0.006 ms): <.main+6863>
test/lang/useOperator.ci:140:[.05303a, .053045) exec(1), time(0.004-0.004 ms): <.main+6875>
test/lang/useOperator.ci:141:[.053045, .053051) exec(1), time(0.005-0.005 ms): <.main+6886>
test/lang/useOperator.ci:142:[.053051, .05305c) exec(1), time(0.004-0.004 ms): <.main+6898>
test/lang/useOperator.ci:143:[.05305c, .053068) exec(1), time(0.006-0.006 ms): <.main+6909>
test/lang/useOperator.ci:145:[.053068, .05306d) exec(1), time(0.001-0.001 ms): <.main+6921>
test/lang/useOperator.ci:146:[.05306d, .053072) exec(1), time(0.001-0.001 ms): <.main+6926>
test/lang/useOperator.ci:147:[.053072, .053074) exec(1), time(0.001-0.001 ms): <.main+6931>
test/lang/useOperator.ci:148:[.053074, .053077) exec(1), time(0.001-0.001 ms): <.main+6933>
test/lang/useOperator.ci:149:[.053077, .05307a) exec(1), time(0.001-0.001 ms): <.main+6936>
test/lang/useOperator.ci:150:[.05307a, .05307f) exec(1), time(0.003-0.003 ms): <.main+6939>
test/lang/useOperator.ci:151:[.05307f, .053084) exec(1), time(0.003-0.003 ms): <.main+6944>
test/lang/useOperator.ci:152:[.053084, .053089) exec(1), time(0.003-0.003 ms): <.main+6949>
test/lang/useOperator.ci:153:[.053089, .05308e) exec(1), time(0.002-0.002 ms): <.main+6954>
test/lang/useOperator.ci:154:[.05308e, .053093) exec(1), time(0.002-0.002 ms): <.main+6959>
test/lang/useOperator.ci:155:[.053093, .053098) exec(1), time(0.002-0.002 ms): <.main+6964>
test/lang/useOperator.ci:156:[.053098, .05309d) exec(1), time(0.003-0.003 ms): <.main+6969>
test/lang/useOperator.ci:157:[.05309d, .0530a2) exec(1), time(0.003-0.003 ms): <.main+6974>
test/lang/useOperator.ci:158:[.0530a2, .0530a7) exec(1), time(0.003-0.003 ms): <.main+6979>
test/lang/useOperator.ci:159:[.0530a7, .0530ac) exec(1), time(0.002-0.002 ms): <.main+6984>
test/lang/useOperator.ci:160:[.0530ac, .0530b0) exec(1), time(0.002-0.002 ms): <.main+6989>
test/lang/useOperator.ci:161:[.0530b0, .0530b5) exec(1), time(0.003-0.003 ms): <.main+6993>
test/lang/useOperator.ci:162:[.0530b5, .0530bb) exec(1), time(0.004-0.004 ms): <.main+6998>
test/lang/useOperator.ci:163:[.0530bb, .0530c0) exec(1), time(0.003-0.003 ms): <.main+7004>
test/lang/useOperator.ci:164:[.0530c0, .0530c6) exec(1), time(0.003-0.003 ms): <.main+7009>
test/lang/useOperator.ci:165:[.0530c6, .0530cb) exec(1), time(0.003-0.003 ms): <.main+7015>
test/lang/useOperator.ci:166:[.0530cb, .0530d1) exec(1), time(0.004-0.004 ms): <.main+7020>
test/lang/useOperator.ci:168:[.0530d1, .0530d6) exec(1), time(0.001-0.001 ms): <.main+7026>
test/lang/useOperator.ci:169:[.0530d6, .0530db) exec(1), time(0.000 ms): <.main+7031>
test/lang/useOperator.ci:170:[.0530db, .0530dd) exec(1), time(0.000 ms): <.main+7036>
test/lang/useOperator.ci:171:[.0530dd, .0530e0) exec(1), time(0.001-0.001 ms): <.main+7038>
test/lang/useOperator.ci:172:[.0530e0, .0530e3) exec(1), time(0.002-0.002 ms): <.main+7041>
test/lang/useOperator.ci:173:[.0530e3, .0530e8) exec(1), time(0.003-0.003 ms): <.main+7044>
test/lang/useOperator.ci:174:[.0530e8, .0530ed) exec(1), time(0.003-0.003 ms): <.main+7049>
test/lang/useOperator.ci:175:[.0530ed, .0530f2) exec(1), time(0.002-0.002 ms): <.main+7054>
test/lang/useOperator.ci:176:[.0530f2, .0530f7) exec(1), time(0.003-0.003 ms): <.main+7059>
test/lang/useOperator.ci:177:[.0530f7, .0530fc) exec(1), time(0.003-0.003 ms): <.main+7064>
test/lang/useOperator.ci:178:[.0530fc, .053101) exec(1), time(0.002-0.002 ms): <.main+7069>
test/lang/useOperator.ci:179:[.053101, .053106) exec(1), time(0.002-0.002 ms): <.main+7074>
test/lang/useOperator.ci:180:[.053106, .05310b) exec(1), time(0.003-0.003 ms): <.main+7079>
test/lang/useOperator.ci:181:[.05310b, .053110) exec(1), time(0.003-0.003 ms): <.main+7084>
test/lang/useOperator.ci:182:[.053110, .053115) exec(1), time(0.002-0.002 ms): <.main+7089>
test/lang/useOperator.ci:183:[.053115, .053119) exec(1), time(0.003-0.003 ms): <.main+7094>
test/lang/useOperator.ci:184:[.053119, .05311e) exec(1), time(0.003-0.003 ms): <.main+7098>
test/lang/useOperator.ci:185:[.05311e, .053124) exec(1), time(0.007-0.007 ms): <.main+7103>
test/lang/useOperator.ci:186:[.053124, .053129) exec(1), time(0.003-0.003 ms): <.main+7109>
test/lang/useOperator.ci:187:[.053129, .05312f) exec(1), time(0.004-0.004 ms): <.main+7114>
test/lang/useOperator.ci:188:[.05312f, .053134) exec(1), time(0.002-0.002 ms): <.main+7120>
test/lang/useOperator.ci:189:[.053134, .05313a) exec(1), time(0.004-0.004 ms): <.main+7125>
test/lang/useOperator.ci:191:[.05313a, .053143) exec(1), time(0.001-0.001 ms): <.main+7131>
test/lang/useOperator.ci:192:[.053143, .05314c) exec(1), time(0.001-0.001 ms): <.main+7140>
test/lang/useOperator.ci:193:[.05314c, .05314e) exec(1), time(0.000 ms): <.main+7149>
test/lang/useOperator.ci:194:[.05314e, .053151) exec(1), time(0.001-0.001 ms): <.main+7151>
test/lang/useOperator.ci:195:[.053151, .053154) exec(1), time(0.002-0.002 ms): <.main+7154>
test/lang/useOperator.ci:196:[.053154, .053159) exec(1), time(0.003-0.003 ms): <.main+7157>
test/lang/useOperator.ci:197:[.053159, .05315e) exec(1), time(0.003-0.003 ms): <.main+7162>
test/lang/useOperator.ci:198:[.05315e, .053163) exec(1), time(0.002-0.002 ms): <.main+7167>
test/lang/useOperator.ci:199:[.053163, .053168) exec(1), time(0.003-0.003 ms): <.main+7172>
test/lang/useOperator.ci:200:[.053168, .05316d) exec(1), time(0.003-0.003 ms): <.main+7177>
test/lang/useOperator.ci:201:[.05316d, .053172) exec(1), time(0.002-0.002 ms): <.main+7182>
test/lang/useOperator.ci:202:[.053172, .053177) exec(1), time(0.003-0.003 ms): <.main+7187>
test/lang/useOperator.ci:203:[.053177, .05317c) exec(1), time(0.003-0.003 ms): <.main+7192>
test/lang/useOperator.ci:204:[.05317c, .053181) exec(1), time(0.003-0.003 ms): <.main+7197>
test/lang/useOperator.ci:205:[.053181, .053186) exec(1), time(0.002-0.002 ms): <.main+7202>
test/lang/useOperator.ci:206:[.053186, .05318a) exec(1), time(0.003-0.003 ms): <.main+7207>
test/lang/useOperator.ci:207:[.05318a, .05318f) exec(1), time(0.003-0.003 ms): <.main+7211>
test/lang/useOperator.ci:208:[.05318f, .053195) exec(1), time(0.003-0.003 ms): <.main+7216>
test/lang/useOperator.ci:209:[.053195, .05319a) exec(1), time(0.003-0.003 ms): <.main+7222>
test/lang/useOperator.ci:210:[.05319a, .0531a0) exec(1), time(0.004-0.004 ms): <.main+7227>
test/lang/useOperator.ci:211:[.0531a0, .0531a5) exec(1), time(0.002-0.002 ms): <.main+7233>
test/lang/useOperator.ci:212:[.0531a5, .0531ab) exec(1), time(0.004-0.004 ms): <.main+7238>
test/lang/useOperator.ci:214:[.0531ab, .0531b4) exec(1), time(0.001-0.001 ms): <.main+7244>
test/lang/useOperator.ci:215:[.0531b4, .0531bd) exec(1), time(0.001-0.001 ms): <.main+7253>
test/lang/useOperator.ci:216:[.0531bd, .0531bf) exec(1), time(0.000 ms): <.main+7262>
test/lang/useOperator.ci:217:[.0531bf, .0531c2) exec(1), time(0.001-0.001 ms): <.main+7264>
test/lang/useOperator.ci:218:[.0531c2, .0531c5) exec(1), time(0.002-0.002 ms): <.main+7267>
test/lang/useOperator.ci:219:[.0531c5, .0531ca) exec(1), time(0.003-0.003 ms): <.main+7270>
test/lang/useOperator.ci:220:[.0531ca, .0531cf) exec(1), time(0.003-0.003 ms): <.main+7275>
test/lang/useOperator.ci:221:[.0531cf, .0531d4) exec(1), time(0.003-0.003 ms): <.main+7280>
test/lang/useOperator.ci:222:[.0531d4, .0531d9) exec(1), time(0.003-0.003 ms): <.main+7285>
test/lang/useOperator.ci:223:[.0531d9, .0531de) exec(1), time(0.003-0.003 ms): <.main+7290>
test/lang/useOperator.ci:224:[.0531de, .0531e3) exec(1), time(0.003-0.003 ms): <.main+7295>
test/lang/useOperator.ci:225:[.0531e3, .0531e8) exec(1), time(0.003-0.003 ms): <.main+7300>
test/lang/useOperator.ci:226:[.0531e8, .0531ed) exec(1), time(0.002-0.002 ms): <.main+7305>
test/lang/useOperator.ci:227:[.0531ed, .0531f2) exec(1), time(0.003-0.003 ms): <.main+7310>
test/lang/useOperator.ci:228:[.0531f2, .0531f7) exec(1), time(0.003-0.003 ms): <.main+7315>
test/lang/useOperator.ci:229:[.0531f7, .0531fb) exec(1), time(0.002-0.002 ms): <.main+7320>
test/lang/useOperator.ci:230:[.0531fb, .053200) exec(1), time(0.003-0.003 ms): <.main+7324>
test/lang/useOperator.ci:231:[.053200, .053206) exec(1), time(0.003-0.003 ms): <.main+7329>
test/lang/useOperator.ci:232:[.053206, .05320b) exec(1), time(0.003-0.003 ms): <.main+7335>
test/lang/useOperator.ci:233:[.05320b, .053211) exec(1), time(0.004-0.004 ms): <.main+7340>
test/lang/useOperator.ci:234:[.053211, .053216) exec(1), time(0.003-0.003 ms): <.main+7346>
test/lang/useOperator.ci:235:[.053216, .05321c) exec(1), time(0.004-0.004 ms): <.main+7351>
test/lang/useOperator.ci:237:[.05321c, .053221) exec(1), time(0.000 ms): <.main+7357>
test/lang/useOperator.ci:238:[.053221, .053226) exec(1), time(0.000 ms): <.main+7362>
test/lang/useOperator.ci:239:[.053226, .053228) exec(1), time(0.001-0.001 ms): <.main+7367>
test/lang/useOperator.ci:240:[.053228, .05322b) exec(1), time(0.002-0.002 ms): <.main+7369>
test/lang/useOperator.ci:242:[.05322b, .053230) exec(1), time(0.003-0.003 ms): <.main+7372>
test/lang/useOperator.ci:243:[.053230, .053235) exec(1), time(0.003-0.003 ms): <.main+7377>
test/lang/useOperator.ci:244:[.053235, .05323a) exec(1), time(0.003-0.003 ms): <.main+7382>
test/lang/useOperator.ci:245:[.05323a, .05323f) exec(1), time(0.003-0.003 ms): <.main+7387>
test/lang/useOperator.ci:246:[.05323f, .053244) exec(1), time(0.003-0.003 ms): <.main+7392>
test/lang/useOperator.ci:252:[.053244, .053248) exec(1), time(0.003-0.003 ms): <.main+7397>
test/lang/useOperator.ci:253:[.053248, .05324d) exec(1), time(0.003-0.003 ms): <.main+7401>
test/lang/useOperator.ci:254:[.05324d, .053253) exec(1), time(0.004-0.004 ms): <.main+7406>
test/lang/useOperator.ci:255:[.053253, .053258) exec(1), time(0.003-0.003 ms): <.main+7412>
test/lang/useOperator.ci:256:[.053258, .05325e) exec(1), time(0.004-0.004 ms): <.main+7417>
test/lang/useOperator.ci:257:[.05325e, .053263) exec(1), time(0.003-0.003 ms): <.main+7423>
test/lang/useOperator.ci:258:[.053263, .053269) exec(1), time(0.004-0.004 ms): <.main+7428>
test/lang/useOperator.ci:260:[.053269, .053272) exec(1), time(0.001-0.001 ms): <.main+7434>
test/lang/useOperator.ci:261:[.053272, .05327b) exec(1), time(0.001-0.001 ms): <.main+7443>
test/lang/useOperator.ci:262:[.05327b, .05327d) exec(1), time(0.000 ms): <.main+7452>
test/lang/useOperator.ci:263:[.05327d, .053280) exec(1), time(0.001-0.001 ms): <.main+7454>
test/lang/useOperator.ci:265:[.053280, .053285) exec(1), time(0.003-0.003 ms): <.main+7457>
test/lang/useOperator.ci:266:[.053285, .05328a) exec(1), time(0.002-0.002 ms): <.main+7462>
test/lang/useOperator.ci:267:[.05328a, .05328f) exec(1), time(0.003-0.003 ms): <.main+7467>
test/lang/useOperator.ci:268:[.05328f, .053294) exec(1), time(0.003-0.003 ms): <.main+7472>
test/lang/useOperator.ci:269:[.053294, .053299) exec(1), time(0.003-0.003 ms): <.main+7477>
test/lang/useOperator.ci:275:[.053299, .05329d) exec(1), time(0.003-0.003 ms): <.main+7482>
test/lang/useOperator.ci:276:[.05329d, .0532a2) exec(1), time(0.003-0.003 ms): <.main+7486>
test/lang/useOperator.ci:277:[.0532a2, .0532a8) exec(1), time(0.004-0.004 ms): <.main+7491>
test/lang/useOperator.ci:278:[.0532a8, .0532ad) exec(1), time(0.003-0.003 ms): <.main+7497>
test/lang/useOperator.ci:279:[.0532ad, .0532b3) exec(1), time(0.004-0.004 ms): <.main+7502>
test/lang/useOperator.ci:280:[.0532b3, .0532b8) exec(1), time(0.002-0.002 ms): <.main+7508>
test/lang/useOperator.ci:281:[.0532b8, .0532be) exec(1), time(0.004-0.004 ms): <.main+7513>
test/lang/useOperator.ci:283:[.0532be, .0532c3) exec(1), time(0.000 ms): <.main+7519>
test/lang/useOperator.ci:284:[.0532c3, .0532c7) exec(1), time(0.001-0.001 ms): <.main+7524>
test/lang/useOperator.ci:299:[.0532c7, .0532cc) exec(1), time(0.003-0.003 ms): <.main+7528>
test/lang/useOperator.ci:300:[.0532cc, .0532d2) exec(1), time(0.004-0.004 ms): <.main+7533>
test/lang/statementIf.ci:4:[.0532d2, .0532f9) exec(1), time(0.039-0.039 ms): <.main+7539>
test/lang/statementIf.ci:12:[.0532f9, .053320) exec(1), time(0.039-0.039 ms): <.main+7578>
test/lang/statementIf.ci:22:[.053320, .053347) exec(1), time(0.038-0.038 ms): <.main+7617>
test/lang/statementIf.ci:26:[.053347, .053348) exec(1), time(0.001-0.001 ms): <.main+7656>
test/lang/statementIf.ci:29:[.053350, .053376) exec(1), time(0.044-0.044 ms): <.main+7665>
test/lang/statementIf.ci:28:[.053348, .053376) exec(1-1), time(0.000 ms): <.main+7657>
test/lang/statementIf.ci:33:[.05337e, .0533a4) exec(0), time(0.000 ms): <.main+7711>
test/lang/statementIf.ci:32:[.053376, .0533a4) exec(1), time(0.004-0.004 ms): <.main+7703>
test/lang/statementIf.ci:37:[.0533ac, .0533d2) exec(1), time(0.044-0.044 ms): <.main+7757>
test/lang/statementIf.ci:40:[.0533d6, .0533fc) exec(0), time(0.000 ms): <.main+7799>
test/lang/statementIf.ci:36:[.0533a4, .0533fc) exec(1), time(0.046-0.046 ms): <.main+7749>
test/lang/statementIf.ci:44:[.053404, .05342a) exec(0), time(0.000 ms): <.main+7845>
test/lang/statementIf.ci:47:[.05342e, .053454) exec(1), time(0.046-0.046 ms): <.main+7887>
test/lang/statementIf.ci:43:[.0533fc, .053454) exec(1-1), time(0.000 ms): <.main+7837>
test/lang/statementIf.ci:51:[.05345c, .053482) exec(1), time(0.044-0.044 ms): <.main+7933>
test/lang/statementIf.ci:54:[.053492, .0534b8) exec(0), time(0.000 ms): <.main+7987>
test/lang/statementIf.ci:57:[.0534c8, .0534ee) exec(0), time(0.000 ms): <.main+8041>
test/lang/statementIf.ci:60:[.0534fe, .053524) exec(0), time(0.000 ms): <.main+8095>
test/lang/statementIf.ci:63:[.053534, .05355a) exec(0), time(0.000 ms): <.main+8149>
test/lang/statementIf.ci:66:[.05356a, .053590) exec(0), time(0.000 ms): <.main+8203>
test/lang/statementIf.ci:69:[.053594, .0535ba) exec(0), time(0.000 ms): <.main+8245>
test/lang/statementIf.ci:65:[.05355e, .0535ba) exec(0), time(0.000 ms): <.main+8191>
test/lang/statementIf.ci:62:[.053528, .0535ba) exec(0), time(0.000 ms): <.main+8137>
test/lang/statementIf.ci:59:[.0534f2, .0535ba) exec(0), time(0.000 ms): <.main+8083>
test/lang/statementIf.ci:56:[.0534bc, .0535ba) exec(0), time(0.000 ms): <.main+8029>
test/lang/statementIf.ci:53:[.053486, .0535ba) exec(0), time(0.000 ms): <.main+7975>
test/lang/statementIf.ci:50:[.053454, .0535ba) exec(1), time(0.046-0.046 ms): <.main+7925>
test/lang/statementFor.ci:4:[.0535be, .0535e1) exec(1), time(0.034-0.034 ms): <.main+8287>
test/lang/statementFor.ci:5:[.0535e1, .0535e5) exec(1), time(0.000 ms): <.main+8322>
::[.0535e5, .0535e9) exec(1), time(0.000 ms): <.main+8326>
test/lang/statementFor.ci:3:[.0535ba, .0535e9) exec(1-1), time(0.000 ms): <.main+8283>
test/lang/statementFor.ci:9:[.0535ee, .053610) exec(2), time(0.078-0.078 ms): <.main+8335>
test/lang/statementFor.ci:8:[.053610, .053614) exec(2), time(0.002-0.002 ms): <.main+8369>
test/lang/statementFor.ci:8:[.053614, .053620) exec(3), time(0.012-0.012 ms): <.main+8373>
test/lang/statementFor.ci:8:[.0535e9, .053624) exec(1), time(0.006-0.006 ms): <.main+8330>
test/lang/statementFor.ci:12:[.053624, .053625) exec(1), time(0.001-0.001 ms): <.main+8389>
test/lang/statementFor.ci:14:[.05362c, .05364e) exec(2), time(0.098-0.098 ms): <.main+8397>
test/lang/statementFor.ci:13:[.05364e, .053652) exec(2), time(0.001-0.001 ms): <.main+8431>
test/lang/statementFor.ci:13:[.053652, .05365e) exec(3), time(0.014-0.014 ms): <.main+8435>
test/lang/statementFor.ci:13:[.053625, .05365e) exec(1-1), time(0.000 ms): <.main+8390>
test/lang/statementFor.ci:19:[.05366f, .053673) exec(2), time(0.002-0.002 ms): <.main+8464>
test/lang/statementFor.ci:18:[.053663, .053673) exec(7-2), time(0.022-0.022 ms): <.main+8452>
test/lang/statementFor.ci:21:[.053673, .053695) exec(5), time(0.229-0.229 ms): <.main+8468>
test/lang/statementFor.ci:17:[.053695, .053699) exec(7), time(0.003-0.003 ms): <.main+8502>
test/lang/statementFor.ci:17:[.053699, .0536a5) exec(8), time(0.034-0.034 ms): <.main+8506>
test/lang/statementFor.ci:17:[.05365e, .0536a9) exec(1), time(0.006-0.006 ms): <.main+8447>
test/lang/statementFor.ci:26:[.0536ba, .0536be) exec(1), time(0.000 ms): <.main+8539>
test/lang/statementFor.ci:25:[.0536ae, .0536be) exec(4-1), time(0.015-0.015 ms): <.main+8527>
test/lang/statementFor.ci:28:[.0536be, .0536e0) exec(3), time(0.128-0.128 ms): <.main+8543>
test/lang/statementFor.ci:24:[.0536e0, .0536e4) exec(3), time(0.002-0.002 ms): <.main+8577>
test/lang/statementFor.ci:24:[.0536e4, .0536f0) exec(4), time(0.017-0.017 ms): <.main+8581>
test/lang/statementFor.ci:24:[.0536a9, .0536f4) exec(1), time(0.002-0.002 ms): <.main+8522>
test/stdc/test.math.ci:3:[.0536f4, .053708) exec(1), time(0.040-0.040 ms): <.main+8597>
test/stdc/test.math.ci:4:[.053708, .05371c) exec(1), time(0.039-0.039 ms): <.main+8617>
test/stdc/test.math.ci:5:[.05371c, .053730) exec(1), time(0.039-0.039 ms): <.main+8637>
test/stdc/test.math.ci:6:[.053730, .053744) exec(1), time(0.056-0.056 ms): <.main+8657>
test/stdc/test.math.ci:7:[.053744, .053758) exec(1), time(0.055-0.055 ms): <.main+8677>
test/stdc/test.math.ci:8:[.053758, .05376c) exec(1), time(0.059-0.059 ms): <.main+8697>
test/stdc/test.math.ci:10:[.05376c, .053785) exec(1), time(0.013-0.013 ms): <.main+8717>
test/stdc/test.math.ci:11:[.053785, .053796) exec(1), time(0.013-0.013 ms): <.main+8742>
test/stdc/test.math.ci:12:[.053796, .0537af) exec(1), time(0.012-0.012 ms): <.main+8759>
test/stdc/test.math.ci:13:[.0537af, .0537c0) exec(1), time(0.012-0.012 ms): <.main+8784>
test/stdc/test.math.ci:14:[.0537c0, .0537cd) exec(1), time(0.012-0.012 ms): <.main+8801>
test/stdc/test.math.ci:15:[.0537cd, .0537de) exec(1), time(0.011-0.011 ms): <.main+8814>
test/stdc/test.math.ci:17:[.0537de, .0537f2) exec(1), time(0.022-0.022 ms): <.main+8831>
test/stdc/test.math.ci:18:[.0537f2, .0537fd) exec(1), time(0.020-0.020 ms): <.main+8851>
test/stdc/test.math.ci:19:[.0537fd, .053811) exec(1), time(0.021-0.021 ms): <.main+8862>
test/stdc/test.math.ci:20:[.053811, .053822) exec(1), time(0.023-0.023 ms): <.main+8882>
test/stdc/test.math.ci:21:[.053822, .05382f) exec(1), time(0.023-0.023 ms): <.main+8899>
test/stdc/test.math.ci:22:[.05382f, .053840) exec(1), time(0.023-0.023 ms): <.main+8912>
test/stdc/test.math.ci:24:[.053840, .053856) exec(1), time(0.023-0.023 ms): <.main+8929>
test/stdc/test.math.ci:25:[.053856, .05386c) exec(1), time(0.025-0.025 ms): <.main+8951>
test/stdc/test.math.ci:26:[.05386c, .053889) exec(1), time(0.023-0.023 ms): <.main+8973>
test/stdc/test.math.ci:27:[.053889, .0538a6) exec(1), time(0.023-0.023 ms): <.main+9002>
test/stdc/test.math.ci:29:[.0538a6, .0538bd) exec(1), time(0.027-0.027 ms): <.main+9031>
test/stdc/test.math.ci:30:[.0538bd, .0538db) exec(1), time(0.026-0.026 ms): <.main+9054>
test/stdc/test.math.ci:32:[.0538db, .0538f0) exec(1), time(0.011-0.011 ms): <.main+9084>
test/stdc/test.math.ci:33:[.0538f0, .05390c) exec(1), time(0.011-0.011 ms): <.main+9105>
test/stdc/test.math.ci:35:[.05390c, .053948) exec(1), time(0.049-0.049 ms): <.main+9133>
test/stdc/test.math.ci:36:[.053948, .053996) exec(1), time(0.047-0.047 ms): <.main+9193>
test/stdc/test.math.ci:38:[.053996, .0539ab) exec(1), time(0.027-0.027 ms): <.main+9271>
test/stdc/test.math.ci:39:[.0539ab, .053a15) exec(1), time(0.076-0.076 ms): <.main+9292>
test/stdc/test.math.ci:40:[.053a15, .053a2a) exec(1), time(0.028-0.028 ms): <.main+9398>
test/stdc/test.math.ci:41:[.053a2a, .053a94) exec(1), time(0.076-0.076 ms): <.main+9419>
test/stdc/test.math.ci:43:[.053a94, .053aa9) exec(1), time(0.030-0.030 ms): <.main+9525>
test/stdc/test.math.ci:44:[.053aa9, .053acb) exec(1), time(0.036-0.036 ms): <.main+9546>
test/stdc/test.math.ci:45:[.053acb, .053af6) exec(1), time(0.041-0.041 ms): <.main+9580>
test/stdc/test.math.ci:46:[.053af6, .053b69) exec(1), time(0.082-0.082 ms): <.main+9623>
test/stdc/test.math.ci:48:[.053b69, .053b72) exec(1), time(0.001-0.001 ms): <.main+9738>
test/stdc/test.math.ci:49:[.053b72, .053b89) exec(1), time(0.031-0.031 ms): <.main+9747>
test/stdc/test.math.ci:50:[.053b89, .053b92) exec(1), time(0.001-0.001 ms): <.main+9770>
test/stdc/test.math.ci:51:[.053b92, .053ba8) exec(1), time(0.006-0.006 ms): <.main+9779>
test/stdc/test.math.ci:52:[.053ba8, .053bcf) exec(1), time(0.013-0.013 ms): <.main+9801>
test/stdc/test.math.ci:53:[.053bcf, .053c07) exec(1), time(0.021-0.021 ms): <.main+9840>
test/stdc/test.math.ci:54:[.053c07, .053c4f) exec(1), time(0.059-0.059 ms): <.main+9896>
test/stdc/test.math.ci:55:[.053c4f, .053ca0) exec(1), time(0.064-0.064 ms): <.main+9968>
test/stdc/test.math.ci:57:[.053ca0, .053cbf) exec(1), time(0.048-0.048 ms): <.main+10049>
test/stdc/test.math.ci:58:[.053cbf, .053cec) exec(1), time(0.068-0.068 ms): <.main+10080>
test/stdc/test.math.ci:59:[.053cec, .053d0a) exec(1), time(0.068-0.068 ms): <.main+10125>
test/stdc/test.math.ci:60:[.053d0a, .053d28) exec(1), time(0.062-0.062 ms): <.main+10155>
test/stdc/test.math.ci:61:[.053d28, .053d46) exec(1), time(0.055-0.055 ms): <.main+10185>
test/stdc/test.math.ci:63:[.053d46, .053d5a) exec(1), time(0.062-0.062 ms): <.main+10215>
test/stdc/test.math.ci:64:[.053d5a, .053d82) exec(1), time(0.066-0.066 ms): <.main+10235>
test/stdc/test.math.ci:67:[.053d82, .053d9e) exec(1), time(0.030-0.030 ms): <.main+10275>
test/stdc/test.math.ci:68:[.053d9e, .053dc6) exec(1), time(0.029-0.029 ms): <.main+10303>
test/stdc/test.math.ci:70:[.053dc6, .053de3) exec(1), time(0.024-0.024 ms): <.main+10343>
test/stdc/test.math.ci:71:[.053de3, .053df7) exec(1), time(0.022-0.022 ms): <.main+10372>
test/stdc/test.math.ci:72:[.053df7, .053e14) exec(1), time(0.024-0.024 ms): <.main+10392>
test/stdc/test.math.ci:74:[.053e14, .053e31) exec(1), time(0.024-0.024 ms): <.main+10421>
test/stdc/test.math.ci:75:[.053e31, .053e4e) exec(1), time(0.024-0.024 ms): <.main+10450>
test/stdc/test.math.ci:76:[.053e4e, .053e6b) exec(1), time(0.023-0.023 ms): <.main+10479>
test/stdc/test.math.ci:77:[.053e6b, .053e88) exec(1), time(0.024-0.024 ms): <.main+10508>
test/stdc/test.math.ci:79:[.053e88, .053ea5) exec(1), time(0.023-0.023 ms): <.main+10537>
test/stdc/test.math.ci:80:[.053ea5, .053ec2) exec(1), time(0.024-0.024 ms): <.main+10566>
test/stdc/test.math.ci:81:[.053ec2, .053edf) exec(1), time(0.025-0.025 ms): <.main+10595>
test/stdc/test.math.ci:82:[.053edf, .053efc) exec(1), time(0.024-0.024 ms): <.main+10624>
test/stdc/test.math.ci:84:[.053efc, .053f11) exec(1), time(0.023-0.023 ms): <.main+10653>
test/stdc/test.math.ci:85:[.053f11, .053f22) exec(1), time(0.024-0.024 ms): <.main+10674>
test/stdc/test.math.ci:86:[.053f22, .053f37) exec(1), time(0.023-0.023 ms): <.main+10691>
test/stdc/test.math.ci:88:[.053f37, .053f4c) exec(1), time(0.024-0.024 ms): <.main+10712>
test/stdc/test.math.ci:89:[.053f4c, .053f61) exec(1), time(0.024-0.024 ms): <.main+10733>
test/stdc/test.math.ci:90:[.053f61, .053f76) exec(1), time(0.023-0.023 ms): <.main+10754>
test/stdc/test.math.ci:91:[.053f76, .053f8b) exec(1), time(0.023-0.023 ms): <.main+10775>
test/stdc/test.math.ci:93:[.053f8b, .053fa0) exec(1), time(0.024-0.024 ms): <.main+10796>
test/stdc/test.math.ci:94:[.053fa0, .053fb5) exec(1), time(0.023-0.023 ms): <.main+10817>
test/stdc/test.math.ci:95:[.053fb5, .053fca) exec(1), time(0.029-0.029 ms): <.main+10838>
test/stdc/test.math.ci:96:[.053fca, .053fdf) exec(1), time(0.026-0.026 ms): <.main+10859>

---------- Exitcode: 0, time: 27.971 ms
