
---------- Compile: `cmplStd/stdlib.ci`

---------- Library: `bin/lnx.gcc/libFile.so`

---------- Library: `bin/lnx.gcc/libGfx.so`

---------- Generate: byte-code
cmplGfx/gfxlib.ci:219: warn: accessing static member using instance variable `show.Closure.updateCamera(this: Closure): void`/ show.Closure
cmplGfx/gfxlib.ci:234: warn: accessing static member using instance variable `Camera.rotate(camera: Camera, orbit: vec4f, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:235: warn: accessing static member using instance variable `Camera.rotate(camera: Camera, orbit: vec4f, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:236: warn: accessing static member using instance variable `show.Closure.updateCamera(this: Closure): void`/ show.Closure
cmplGfx/gfxlib.ci:240: warn: accessing static member using instance variable `Camera.rotate(camera: Camera, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:241: warn: accessing static member using instance variable `Camera.rotate(camera: Camera, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:242: warn: accessing static member using instance variable `show.Closure.updateCamera(this: Closure): void`/ show.Closure
cmplGfx/gfxlib.ci:246: warn: accessing static member using instance variable `Camera.move(camera: Camera, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:247: warn: accessing static member using instance variable `show.Closure.updateCamera(this: Closure): void`/ show.Closure
cmplGfx/gfxlib.ci:251: warn: accessing static member using instance variable `Camera.move(camera: Camera, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:252: warn: accessing static member using instance variable `Camera.move(camera: Camera, direction: vec4f, amount: float32): void`/ Camera
cmplGfx/gfxlib.ci:253: warn: accessing static member using instance variable `show.Closure.updateCamera(this: Closure): void`/ show.Closure
cmplGfx/gfxlib.ci:289: warn: accessing static member using instance variable `show.Closure.updateCamera(this: Closure): void`/ show.Closure

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, cast: const variable)
.field offset: int32 (size: 4, cast: const variable)
.field base: function (size: 0, cast: static const inline)
.field file: function (size: 0, cast: static const inline)
.field line: function (size: 0, cast: static const inline)
.field name: function (size: 0, cast: static const inline)
.field size: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:17: referenced as `typename`
	cmplGfx/gfxlib.ci:12: referenced as `typename`
	cmplGfx/gfxlib.ci:7: referenced as `typename`
	cmplGfx/lib/color.ci:258: referenced as `typename`
	cmplStd/stdlib.ci:39: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	internal usages: 11
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(2)
.usages:
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(3)
.usages:
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(4)
.usages:
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(5)
.usages:
}
typename.size(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'size'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(6)
.usages:
	cmplStd/stdlib.ci:37: referenced as `size`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
.usages:
	cmplGfx/gfxlib.ci:161: referenced as `void`
	cmplGfx/gfxlib.ci:149: referenced as `void`
	cmplGfx/gfxlib.ci:70: referenced as `void`
	cmplGfx/gfxlib.ci:37: referenced as `void`
	cmplGfx/gfxlib.ci:26: referenced as `void`
	cmplGfx/lib/camera.ci:125: referenced as `void`
	cmplGfx/lib/camera.ci:112: referenced as `void`
	cmplGfx/lib/camera.ci:107: referenced as `void`
	cmplGfx/lib/image.ci:202: referenced as `void`
	cmplGfx/lib/image.ci:168: referenced as `void`
	cmplGfx/lib/color.ci:233: referenced as `void`
	cmplGfx/lib/color.ci:216: referenced as `void`
	cmplStd/lib/debug.ci:61: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	internal usages: 49
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:73: referenced as `bool`
	cmplGfx/lib/image.ci:120: referenced as `bool`
	cmplGfx/lib/image.ci:32: referenced as `bool`
	cmplGfx/lib/image.ci:31: referenced as `bool`
	cmplGfx/lib/color.ci:233: referenced as `bool`
	cmplStd/lib/string.ci:121: referenced as `bool`
	cmplStd/lib/string.ci:46: referenced as `bool`
	cmplStd/lib/string.ci:36: referenced as `bool`
	cmplStd/lib/math.ci:456: referenced as `bool`
	cmplStd/lib/math.ci:408: referenced as `bool`
	cmplStd/lib/math.ci:353: referenced as `bool`
	cmplStd/lib/math.ci:352: referenced as `bool`
	cmplStd/lib/debug.ci:45: referenced as `bool`
	cmplStd/lib/debug.ci:43: referenced as `bool`
	cmplStd/lib/debug.ci:41: referenced as `bool`
	cmplStd/stdlib.ci:3: referenced as `bool`
	internal usages: 7
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:261: referenced as `char`
	cmplGfx/gfxlib.ci:116: referenced as `char`
	cmplGfx/gfxlib.ci:94: referenced as `char`
	cmplGfx/lib/mesh.ci:2: referenced as `char`
	cmplGfx/lib/image.ci:105: referenced as `char`
	cmplGfx/lib/image.ci:102: referenced as `char`
	cmplGfx/lib/image.ci:94: referenced as `char`
	cmplGfx/lib/image.ci:91: referenced as `char`
	cmplGfx/lib/image.ci:83: referenced as `char`
	cmplStd/lib/string.ci:269: referenced as `char`
	cmplStd/lib/string.ci:266: referenced as `char`
	cmplStd/lib/string.ci:255: referenced as `char`
	cmplStd/lib/string.ci:241: referenced as `char`
	cmplStd/lib/string.ci:238: referenced as `char`
	cmplStd/lib/string.ci:236: referenced as `char`
	cmplStd/lib/string.ci:234: referenced as `char`
	cmplStd/lib/string.ci:232: referenced as `char`
	cmplStd/lib/string.ci:230: referenced as `char`
	cmplStd/lib/string.ci:228: referenced as `char`
	cmplStd/lib/string.ci:226: referenced as `char`
	cmplStd/lib/string.ci:224: referenced as `char`
	cmplStd/lib/string.ci:181: referenced as `char`
	cmplStd/lib/string.ci:156: referenced as `char`
	cmplStd/lib/string.ci:153: referenced as `char`
	cmplStd/lib/string.ci:152: referenced as `char`
	cmplStd/lib/string.ci:151: referenced as `char`
	cmplStd/lib/string.ci:151: referenced as `char`
	cmplStd/lib/string.ci:134: referenced as `char`
	cmplStd/lib/string.ci:134: referenced as `char`
	cmplStd/lib/string.ci:127: referenced as `char`
	cmplStd/lib/string.ci:105: referenced as `char`
	cmplStd/lib/string.ci:105: referenced as `char`
	cmplStd/lib/string.ci:102: referenced as `char`
	cmplStd/lib/string.ci:102: referenced as `char`
	cmplStd/lib/string.ci:100: referenced as `char`
	cmplStd/lib/string.ci:100: referenced as `char`
	cmplStd/lib/string.ci:98: referenced as `char`
	cmplStd/lib/string.ci:98: referenced as `char`
	cmplStd/lib/string.ci:96: referenced as `char`
	cmplStd/lib/string.ci:96: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:4: referenced as `char`
	cmplStd/lib/debug.ci:61: referenced as `char`
	cmplStd/lib/debug.ci:43: referenced as `char`
	cmplStd/lib/debug.ci:41: referenced as `char`
	cmplStd/lib/debug.ci:36: referenced as `char`
	cmplStd/lib/debug.ci:34: referenced as `char`
	cmplStd/lib/debug.ci:31: referenced as `char`
	cmplStd/lib/debug.ci:29: referenced as `char`
	cmplStd/lib/debug.ci:26: referenced as `char`
	cmplStd/lib/debug.ci:24: referenced as `char`
	cmplStd/lib/debug.ci:21: referenced as `char`
	cmplStd/lib/debug.ci:19: referenced as `char`
	cmplStd/lib/debug.ci:16: referenced as `char`
	cmplStd/lib/debug.ci:14: referenced as `char`
	cmplStd/lib/debug.ci:11: referenced as `char`
	cmplStd/lib/debug.ci:9: referenced as `char`
	cmplStd/lib/debug.ci:6: referenced as `char`
	cmplStd/lib/debug.ci:4: referenced as `char`
	internal usages: 19
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	cmplStd/lib/string.ci:238: referenced as `int8`
	cmplStd/stdlib.ci:25: referenced as `int8`
	cmplStd/stdlib.ci:13: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	cmplStd/lib/string.ci:236: referenced as `int16`
	cmplStd/stdlib.ci:28: referenced as `int16`
	cmplStd/stdlib.ci:16: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:262: referenced as `int`
	cmplGfx/gfxlib.ci:259: referenced as `int`
	cmplGfx/gfxlib.ci:230: referenced as `int`
	cmplGfx/gfxlib.ci:229: referenced as `int`
	cmplGfx/gfxlib.ci:181: referenced as `int`
	cmplGfx/gfxlib.ci:180: referenced as `int`
	cmplGfx/gfxlib.ci:179: referenced as `int`
	cmplGfx/gfxlib.ci:179: referenced as `int`
	cmplGfx/gfxlib.ci:179: referenced as `int`
	cmplGfx/gfxlib.ci:179: referenced as `int`
	cmplGfx/gfxlib.ci:179: referenced as `int`
	cmplGfx/gfxlib.ci:168: referenced as `int`
	cmplGfx/gfxlib.ci:167: referenced as `int`
	cmplGfx/gfxlib.ci:167: referenced as `int32`
	cmplGfx/gfxlib.ci:167: referenced as `int`
	cmplGfx/gfxlib.ci:155: referenced as `int`
	cmplGfx/gfxlib.ci:153: referenced as `int32`
	cmplGfx/gfxlib.ci:152: referenced as `int32`
	cmplGfx/gfxlib.ci:149: referenced as `int`
	cmplGfx/gfxlib.ci:149: referenced as `int`
	cmplGfx/gfxlib.ci:82: referenced as `int`
	cmplGfx/gfxlib.ci:82: referenced as `int`
	cmplGfx/gfxlib.ci:82: referenced as `int`
	cmplGfx/gfxlib.ci:82: referenced as `int`
	cmplGfx/gfxlib.ci:82: referenced as `int`
	cmplGfx/gfxlib.ci:77: referenced as `int32`
	cmplGfx/gfxlib.ci:70: referenced as `int`
	cmplGfx/gfxlib.ci:70: referenced as `int`
	cmplGfx/gfxlib.ci:70: referenced as `int`
	cmplGfx/gfxlib.ci:44: referenced as `int`
	cmplGfx/gfxlib.ci:44: referenced as `int`
	cmplGfx/gfxlib.ci:44: referenced as `int`
	cmplGfx/gfxlib.ci:44: referenced as `int`
	cmplGfx/gfxlib.ci:44: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:30: referenced as `int`
	cmplGfx/gfxlib.ci:26: referenced as `int`
	cmplGfx/gfxlib.ci:26: referenced as `int`
	cmplGfx/gfxlib.ci:26: referenced as `int`
	cmplGfx/gfxlib.ci:26: referenced as `int`
	cmplGfx/gfxlib.ci:26: referenced as `int`
	cmplGfx/lib/image.ci:223: referenced as `int`
	cmplGfx/lib/image.ci:222: referenced as `int`
	cmplGfx/lib/image.ci:221: referenced as `int`
	cmplGfx/lib/image.ci:220: referenced as `int`
	cmplGfx/lib/image.ci:202: referenced as `int`
	cmplGfx/lib/image.ci:202: referenced as `int`
	cmplGfx/lib/image.ci:194: referenced as `int`
	cmplGfx/lib/image.ci:192: referenced as `int`
	cmplGfx/lib/image.ci:160: referenced as `int`
	cmplGfx/lib/image.ci:138: referenced as `int`
	cmplGfx/lib/image.ci:133: referenced as `int`
	cmplGfx/lib/image.ci:114: referenced as `int`
	cmplGfx/lib/image.ci:108: referenced as `int32`
	cmplGfx/lib/image.ci:108: referenced as `int32`
	cmplGfx/lib/image.ci:105: referenced as `int`
	cmplGfx/lib/image.ci:105: referenced as `int`
	cmplGfx/lib/image.ci:105: referenced as `int`
	cmplGfx/lib/image.ci:102: referenced as `int`
	cmplGfx/lib/image.ci:102: referenced as `int`
	cmplGfx/lib/image.ci:102: referenced as `int`
	cmplGfx/lib/image.ci:102: referenced as `int`
	cmplGfx/lib/image.ci:94: referenced as `int`
	cmplGfx/lib/image.ci:94: referenced as `int`
	cmplGfx/lib/image.ci:94: referenced as `int`
	cmplGfx/lib/image.ci:94: referenced as `int`
	cmplGfx/lib/image.ci:83: referenced as `int`
	cmplGfx/lib/image.ci:29: referenced as `int`
	cmplGfx/lib/image.ci:28: referenced as `int`
	cmplGfx/lib/image.ci:13: referenced as `int`
	cmplGfx/lib/image.ci:12: referenced as `int`
	cmplGfx/lib/image.ci:12: referenced as `int`
	cmplGfx/lib/image.ci:12: referenced as `int`
	cmplGfx/lib/image.ci:2: referenced as `int`
	cmplGfx/lib/image.ci:2: referenced as `int`
	cmplGfx/lib/image.ci:2: referenced as `int`
	cmplGfx/lib/color.hsv.ci:13: referenced as `int`
	cmplGfx/lib/color.hsv.ci:13: referenced as `int`
	cmplGfx/lib/color.ci:252: referenced as `int`
	cmplGfx/lib/color.ci:248: referenced as `int`
	cmplGfx/lib/color.ci:247: referenced as `int`
	cmplGfx/lib/color.ci:246: referenced as `int`
	cmplGfx/lib/color.ci:237: referenced as `int`
	cmplGfx/lib/color.ci:236: referenced as `int`
	cmplGfx/lib/color.ci:235: referenced as `int`
	cmplGfx/lib/color.ci:234: referenced as `int`
	cmplGfx/lib/color.ci:233: referenced as `int`
	cmplGfx/lib/color.ci:233: referenced as `int`
	cmplGfx/lib/color.ci:227: referenced as `int32`
	cmplGfx/lib/color.ci:226: referenced as `int32`
	cmplGfx/lib/color.ci:225: referenced as `int32`
	cmplGfx/lib/color.ci:224: referenced as `int32`
	cmplGfx/lib/color.ci:221: referenced as `int`
	cmplGfx/lib/color.ci:220: referenced as `int`
	cmplGfx/lib/color.ci:219: referenced as `int`
	cmplGfx/lib/color.ci:217: referenced as `int32`
	cmplGfx/lib/color.ci:199: referenced as `int`
	cmplGfx/lib/color.ci:180: referenced as `int`
	cmplGfx/lib/color.ci:179: referenced as `int`
	cmplGfx/lib/color.ci:178: referenced as `int`
	cmplGfx/lib/color.ci:177: referenced as `int`
	cmplGfx/lib/color.ci:176: referenced as `int`
	cmplGfx/lib/color.ci:171: referenced as `int32`
	cmplGfx/lib/color.ci:168: referenced as `int32`
	cmplGfx/lib/color.ci:166: referenced as `int32`
	cmplGfx/lib/color.ci:164: referenced as `int32`
	cmplGfx/lib/color.ci:162: referenced as `int32`
	cmplGfx/lib/color.ci:158: referenced as `int32`
	cmplGfx/lib/color.ci:158: referenced as `int32`
	cmplGfx/lib/color.ci:158: referenced as `int32`
	cmplGfx/lib/color.ci:158: referenced as `int32`
	cmplGfx/lib/color.ci:156: referenced as `int32`
	cmplGfx/lib/color.ci:156: referenced as `int32`
	cmplGfx/lib/color.ci:156: referenced as `int32`
	cmplGfx/lib/color.ci:156: referenced as `int32`
	cmplGfx/lib/color.ci:152: referenced as `int32`
	cmplGfx/lib/color.ci:152: referenced as `int32`
	cmplGfx/lib/color.ci:152: referenced as `int32`
	cmplGfx/lib/color.ci:152: referenced as `int32`
	cmplGfx/lib/color.ci:150: referenced as `int32`
	cmplGfx/lib/color.ci:150: referenced as `int32`
	cmplGfx/lib/color.ci:150: referenced as `int32`
	cmplGfx/lib/color.ci:148: referenced as `int32`
	cmplGfx/lib/color.ci:148: referenced as `int32`
	cmplGfx/lib/color.ci:148: referenced as `int32`
	cmplGfx/lib/color.ci:144: referenced as `int32`
	cmplGfx/lib/color.ci:144: referenced as `int32`
	cmplGfx/lib/color.ci:144: referenced as `int32`
	cmplGfx/lib/color.ci:135: referenced as `int32`
	cmplGfx/lib/color.ci:133: referenced as `int32`
	cmplGfx/lib/color.ci:129: referenced as `int32`
	cmplGfx/lib/color.ci:109: referenced as `int32`
	cmplStd/lib/string.ci:269: referenced as `int`
	cmplStd/lib/string.ci:269: referenced as `int`
	cmplStd/lib/string.ci:269: referenced as `int`
	cmplStd/lib/string.ci:266: referenced as `int`
	cmplStd/lib/string.ci:241: referenced as `int`
	cmplStd/lib/string.ci:241: referenced as `int`
	cmplStd/lib/string.ci:238: referenced as `int`
	cmplStd/lib/string.ci:236: referenced as `int`
	cmplStd/lib/string.ci:234: referenced as `int32`
	cmplStd/lib/string.ci:234: referenced as `int`
	cmplStd/lib/string.ci:232: referenced as `int`
	cmplStd/lib/string.ci:230: referenced as `int`
	cmplStd/lib/string.ci:228: referenced as `int`
	cmplStd/lib/string.ci:226: referenced as `int`
	cmplStd/lib/string.ci:224: referenced as `int`
	cmplStd/lib/string.ci:210: referenced as `int`
	cmplStd/lib/string.ci:179: referenced as `int`
	cmplStd/lib/string.ci:164: referenced as `int`
	cmplStd/lib/string.ci:155: referenced as `int`
	cmplStd/lib/string.ci:151: referenced as `int`
	cmplStd/lib/string.ci:151: referenced as `int`
	cmplStd/lib/string.ci:135: referenced as `int`
	cmplStd/lib/string.ci:134: referenced as `int`
	cmplStd/lib/string.ci:134: referenced as `int`
	cmplStd/lib/string.ci:130: referenced as `int`
	cmplStd/lib/string.ci:124: referenced as `int`
	cmplStd/lib/string.ci:93: referenced as `int`
	cmplStd/lib/string.ci:93: referenced as `int`
	cmplStd/lib/string.ci:88: referenced as `int`
	cmplStd/lib/string.ci:73: referenced as `int`
	cmplStd/lib/string.ci:63: referenced as `int`
	cmplStd/lib/string.ci:62: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:52: referenced as `int`
	cmplStd/lib/string.ci:48: referenced as `int`
	cmplStd/lib/string.ci:47: referenced as `int`
	cmplStd/lib/string.ci:46: referenced as `int`
	cmplStd/lib/string.ci:37: referenced as `int`
	cmplStd/lib/string.ci:36: referenced as `int`
	cmplStd/lib/string.ci:27: referenced as `int`
	cmplStd/lib/string.ci:26: referenced as `int`
	cmplStd/lib/string.ci:25: referenced as `int`
	cmplStd/lib/string.ci:16: referenced as `int`
	cmplStd/lib/string.ci:15: referenced as `int`
	cmplStd/lib/string.ci:8: referenced as `int`
	cmplStd/lib/string.ci:4: referenced as `int`
	cmplStd/lib/math.ci:363: referenced as `int`
	cmplStd/lib/math.ci:363: referenced as `int`
	cmplStd/lib/math.ci:314: referenced as `int`
	cmplStd/lib/math.ci:282: referenced as `int`
	cmplStd/lib/math.ci:267: referenced as `int`
	cmplStd/lib/math.ci:252: referenced as `int`
	cmplStd/lib/math.ci:245: referenced as `int`
	cmplStd/lib/math.ci:219: referenced as `int`
	cmplStd/lib/math.ci:208: referenced as `int`
	cmplStd/lib/math.ci:194: referenced as `int`
	cmplStd/lib/math.ci:129: referenced as `int32`
	cmplStd/lib/math.ci:129: referenced as `int32`
	cmplStd/lib/math.ci:111: referenced as `int32`
	cmplStd/lib/math.ci:111: referenced as `int32`
	cmplStd/lib/math.ci:93: referenced as `int32`
	cmplStd/lib/math.ci:74: referenced as `int`
	cmplStd/lib/math.ci:74: referenced as `int`
	cmplStd/lib/math.ci:71: referenced as `int`
	cmplStd/lib/math.ci:71: referenced as `int`
	cmplStd/lib/math.ci:63: referenced as `int32`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/stdlib.ci:31: referenced as `int32`
	cmplStd/stdlib.ci:19: referenced as `int32`
	internal usages: 156
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	cmplGfx/gfxlib.ci:272: referenced as `int64`
	cmplGfx/gfxlib.ci:154: referenced as `int64`
	cmplGfx/gfxlib.ci:95: referenced as `int64`
	cmplGfx/gfxlib.ci:71: referenced as `int64`
	cmplStd/lib/string.ci:261: referenced as `int64`
	cmplStd/lib/string.ci:257: referenced as `int64`
	cmplStd/lib/string.ci:232: referenced as `int64`
	cmplStd/lib/math.ci:132: referenced as `int64`
	cmplStd/lib/math.ci:132: referenced as `int64`
	cmplStd/lib/math.ci:114: referenced as `int64`
	cmplStd/lib/math.ci:114: referenced as `int64`
	cmplStd/lib/math.ci:96: referenced as `int64`
	cmplStd/lib/math.ci:64: referenced as `int64`
	cmplStd/stdlib.ci:34: referenced as `int64`
	cmplStd/stdlib.ci:22: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	cmplGfx/lib/color.ci:16: referenced as `uint8`
	cmplGfx/lib/color.ci:13: referenced as `uint8`
	cmplGfx/lib/color.ci:10: referenced as `uint8`
	cmplGfx/lib/color.ci:7: referenced as `uint8`
	cmplStd/lib/string.ci:230: referenced as `uint8`
	cmplStd/stdlib.ci:25: referenced as `uint8`
	cmplStd/stdlib.ci:13: referenced as `uint8`
	cmplStd/stdlib.ci:8: referenced as `uint8`
	internal usages: 6
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	cmplStd/lib/string.ci:228: referenced as `uint16`
	cmplStd/stdlib.ci:28: referenced as `uint16`
	cmplStd/stdlib.ci:16: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.field pop: function (size: 0, cast: static const inline)
.field swap: function (size: 0, cast: static const inline)
.field bsr: function (size: 0, cast: static const inline)
.field bsf: function (size: 0, cast: static const inline)
.field hib: function (size: 0, cast: static const inline)
.field lob: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplGfx/lib/image.ci:165: referenced as `uint32`
	cmplGfx/lib/image.ci:163: referenced as `uint32`
	cmplGfx/lib/image.ci:160: referenced as `uint32`
	cmplGfx/lib/image.ci:158: referenced as `uint32`
	cmplGfx/lib/image.ci:156: referenced as `uint32`
	cmplGfx/lib/color.ci:233: referenced as `uint32`
	cmplGfx/lib/color.ci:217: referenced as `uint32`
	cmplGfx/lib/color.ci:217: referenced as `uint32`
	cmplGfx/lib/color.ci:216: referenced as `uint32`
	cmplGfx/lib/color.ci:174: referenced as `uint32`
	cmplGfx/lib/color.ci:154: referenced as `uint32`
	cmplGfx/lib/color.ci:154: referenced as `uint32`
	cmplGfx/lib/color.ci:154: referenced as `uint32`
	cmplGfx/lib/color.ci:154: referenced as `uint32`
	cmplGfx/lib/color.ci:146: referenced as `uint32`
	cmplGfx/lib/color.ci:146: referenced as `uint32`
	cmplGfx/lib/color.ci:146: referenced as `uint32`
	cmplGfx/lib/color.ci:141: referenced as `uint32`
	cmplGfx/lib/color.ci:141: referenced as `uint32`
	cmplGfx/lib/color.ci:141: referenced as `uint32`
	cmplGfx/lib/color.ci:141: referenced as `uint32`
	cmplGfx/lib/color.ci:141: referenced as `uint32`
	cmplGfx/lib/color.ci:139: referenced as `uint32`
	cmplGfx/lib/color.ci:139: referenced as `uint32`
	cmplGfx/lib/color.ci:139: referenced as `uint32`
	cmplGfx/lib/color.ci:139: referenced as `uint32`
	cmplGfx/lib/color.ci:131: referenced as `uint32`
	cmplGfx/lib/color.ci:127: referenced as `uint32`
	cmplGfx/lib/color.ci:119: referenced as `uint32`
	cmplGfx/lib/color.ci:119: referenced as `uint32`
	cmplGfx/lib/color.ci:109: referenced as `uint32`
	cmplGfx/lib/color.ci:105: referenced as `uint32`
	cmplGfx/lib/color.ci:103: referenced as `uint32`
	cmplGfx/lib/color.ci:103: referenced as `uint32`
	cmplGfx/lib/color.ci:4: referenced as `uint32`
	cmplStd/lib/string.ci:226: referenced as `uint32`
	cmplStd/lib/math.ci:135: referenced as `uint32`
	cmplStd/lib/math.ci:135: referenced as `uint32`
	cmplStd/lib/math.ci:117: referenced as `uint32`
	cmplStd/lib/math.ci:117: referenced as `uint32`
	cmplStd/lib/math.ci:99: referenced as `uint32`
	cmplStd/lib/math.ci:65: referenced as `uint32`
	cmplStd/stdlib.ci:31: referenced as `uint32`
	cmplStd/stdlib.ci:19: referenced as `uint32`
	internal usages: 6
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(23)
.usages:
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(24)
.usages:
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(25)
.usages:
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(26)
.usages:
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(27)
.usages:
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(28)
.usages:
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(29)
.usages:
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.value: nfc(30)
.usages:
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplStd/lib/string.ci:261: referenced as `uint64`
	cmplStd/lib/string.ci:257: referenced as `uint64`
	cmplStd/lib/string.ci:238: referenced as `uint64`
	cmplStd/lib/string.ci:236: referenced as `uint64`
	cmplStd/lib/string.ci:234: referenced as `uint64`
	cmplStd/lib/string.ci:232: referenced as `uint64`
	cmplStd/lib/string.ci:230: referenced as `uint64`
	cmplStd/lib/string.ci:228: referenced as `uint64`
	cmplStd/lib/string.ci:226: referenced as `uint64`
	cmplStd/lib/string.ci:224: referenced as `uint64`
	cmplStd/lib/string.ci:224: referenced as `uint64`
	cmplStd/lib/string.ci:151: referenced as `uint64`
	cmplStd/lib/math.ci:138: referenced as `uint64`
	cmplStd/lib/math.ci:138: referenced as `uint64`
	cmplStd/lib/math.ci:120: referenced as `uint64`
	cmplStd/lib/math.ci:120: referenced as `uint64`
	cmplStd/lib/math.ci:102: referenced as `uint64`
	cmplStd/lib/math.ci:66: referenced as `uint64`
	cmplStd/stdlib.ci:34: referenced as `uint64`
	cmplStd/stdlib.ci:22: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(31)
.usages:
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.value: nfc(32)
.usages:
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplGfx/gfxlib.ci:285: referenced as `float32`
	cmplGfx/gfxlib.ci:182: referenced as `float32`
	cmplGfx/gfxlib.ci:149: referenced as `float32`
	cmplGfx/gfxlib.ci:140: referenced as `float32`
	cmplGfx/gfxlib.ci:129: referenced as `float32`
	cmplGfx/gfxlib.ci:129: referenced as `float32`
	cmplGfx/gfxlib.ci:112: referenced as `float32`
	cmplGfx/gfxlib.ci:96: referenced as `float32`
	cmplGfx/gfxlib.ci:78: referenced as `float32`
	cmplGfx/gfxlib.ci:76: referenced as `float32`
	cmplGfx/lib/camera.ci:133: referenced as `float`
	cmplGfx/lib/camera.ci:125: referenced as `float32`
	cmplGfx/lib/camera.ci:112: referenced as `float32`
	cmplGfx/lib/camera.ci:107: referenced as `float32`
	cmplGfx/lib/camera.ci:69: referenced as `float`
	cmplGfx/lib/camera.ci:46: referenced as `float`
	cmplGfx/lib/camera.ci:45: referenced as `float`
	cmplGfx/lib/camera.ci:44: referenced as `float`
	cmplGfx/lib/camera.ci:43: referenced as `float`
	cmplGfx/lib/camera.ci:42: referenced as `float`
	cmplGfx/lib/camera.ci:41: referenced as `float`
	cmplGfx/lib/camera.ci:38: referenced as `float`
	cmplGfx/lib/camera.ci:37: referenced as `float`
	cmplGfx/lib/camera.ci:36: referenced as `float`
	cmplGfx/lib/camera.ci:35: referenced as `float`
	cmplGfx/lib/camera.ci:23: referenced as `float32`
	cmplGfx/lib/camera.ci:10: referenced as `float32`
	cmplGfx/lib/camera.ci:9: referenced as `float32`
	cmplGfx/lib/camera.ci:8: referenced as `float32`
	cmplGfx/lib/camera.ci:8: referenced as `float32`
	cmplGfx/lib/camera.ci:8: referenced as `float32`
	cmplGfx/lib/camera.ci:8: referenced as `float32`
	cmplGfx/lib/image.ci:181: referenced as `float32`
	cmplGfx/lib/image.ci:180: referenced as `float32`
	cmplGfx/lib/image.ci:168: referenced as `float32`
	cmplGfx/lib/image.ci:168: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:97: referenced as `float`
	cmplGfx/lib/color.hsl.ci:89: referenced as `float`
	cmplGfx/lib/color.hsl.ci:69: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:35: referenced as `float`
	cmplGfx/lib/color.hsl.ci:33: referenced as `float`
	cmplGfx/lib/color.hsl.ci:32: referenced as `float`
	cmplGfx/lib/color.hsl.ci:31: referenced as `float`
	cmplGfx/lib/color.hsl.ci:24: referenced as `float`
	cmplGfx/lib/color.hsl.ci:12: referenced as `float`
	cmplGfx/lib/color.hsl.ci:9: referenced as `float`
	cmplGfx/lib/color.hsl.ci:8: referenced as `float`
	cmplGfx/lib/color.hsl.ci:7: referenced as `float`
	cmplGfx/lib/color.hsl.ci:6: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:6: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:6: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:5: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:5: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:4: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:4: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:19: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:18: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:17: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:16: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:14: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:5: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:4: referenced as `float32`
	cmplGfx/lib/color.hsv.ci:3: referenced as `float32`
	cmplGfx/lib/color.ci:156: referenced as `float32`
	cmplGfx/lib/color.ci:156: referenced as `float32`
	cmplGfx/lib/color.ci:156: referenced as `float32`
	cmplGfx/lib/color.ci:156: referenced as `float32`
	cmplGfx/lib/color.ci:148: referenced as `float32`
	cmplGfx/lib/color.ci:148: referenced as `float32`
	cmplGfx/lib/color.ci:148: referenced as `float32`
	cmplGfx/lib/color.ci:133: referenced as `float32`
	cmplStd/lib/string.ci:266: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:137: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:132: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:179: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:141: referenced as `float32`
	cmplStd/lib/math.ci:141: referenced as `float32`
	cmplStd/lib/math.ci:123: referenced as `float32`
	cmplStd/lib/math.ci:123: referenced as `float32`
	cmplStd/lib/math.ci:105: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:71: referenced as `float32`
	cmplStd/stdlib.ci:9: referenced as `float32`
	internal usages: 66
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(33)
.usages:
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(34)
.usages:
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(35)
.usages:
	cmplGfx/lib/camera.ci:23: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(36)
.usages:
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(37)
.usages:
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(38)
.usages:
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.value: nfc(39)
.usages:
	cmplStd/lib/math/Vector4f.ci:126: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(40)
.usages:
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.value: 0
.usages:
	cmplGfx/lib/camera.ci:37: referenced as `float64`
	cmplGfx/lib/camera.ci:36: referenced as `float64`
	cmplGfx/lib/image.ci:94: referenced as `float64`
	cmplGfx/lib/image.ci:62: referenced as `float64`
	cmplGfx/lib/image.ci:54: referenced as `float64`
	cmplGfx/lib/image.ci:47: referenced as `float64`
	cmplGfx/lib/image.ci:44: referenced as `float64`
	cmplGfx/lib/image.ci:36: referenced as `float64`
	cmplGfx/lib/image.ci:36: referenced as `float64`
	cmplGfx/lib/image.ci:35: referenced as `float64`
	cmplGfx/lib/image.ci:35: referenced as `float64`
	cmplGfx/lib/image.ci:25: referenced as `float64`
	cmplGfx/lib/image.ci:12: referenced as `float64`
	cmplGfx/lib/color.ci:158: referenced as `float64`
	cmplGfx/lib/color.ci:158: referenced as `float64`
	cmplGfx/lib/color.ci:158: referenced as `float64`
	cmplGfx/lib/color.ci:158: referenced as `float64`
	cmplGfx/lib/color.ci:150: referenced as `float64`
	cmplGfx/lib/color.ci:150: referenced as `float64`
	cmplGfx/lib/color.ci:150: referenced as `float64`
	cmplGfx/lib/color.ci:135: referenced as `float64`
	cmplStd/lib/string.ci:266: referenced as `float64`
	cmplStd/lib/string.ci:260: referenced as `float64`
	cmplStd/lib/string.ci:256: referenced as `float64`
	cmplStd/lib/string.ci:241: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:146: referenced as `float64`
	cmplStd/lib/math/Complex.ci:142: referenced as `float64`
	cmplStd/lib/math/Complex.ci:141: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:137: referenced as `float64`
	cmplStd/lib/math/Complex.ci:136: referenced as `float64`
	cmplStd/lib/math/Complex.ci:132: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:118: referenced as `float64`
	cmplStd/lib/math/Complex.ci:114: referenced as `float64`
	cmplStd/lib/math/Complex.ci:112: referenced as `float64`
	cmplStd/lib/math/Complex.ci:109: referenced as `float64`
	cmplStd/lib/math/Complex.ci:107: referenced as `float64`
	cmplStd/lib/math/Complex.ci:99: referenced as `float64`
	cmplStd/lib/math/Complex.ci:98: referenced as `float64`
	cmplStd/lib/math/Complex.ci:92: referenced as `float64`
	cmplStd/lib/math/Complex.ci:91: referenced as `float64`
	cmplStd/lib/math/Complex.ci:83: referenced as `float64`
	cmplStd/lib/math/Complex.ci:81: referenced as `float64`
	cmplStd/lib/math/Complex.ci:73: referenced as `float64`
	cmplStd/lib/math/Complex.ci:71: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:64: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:24: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math.ci:512: referenced as `float64`
	cmplStd/lib/math.ci:512: referenced as `float64`
	cmplStd/lib/math.ci:509: referenced as `float64`
	cmplStd/lib/math.ci:509: referenced as `float64`
	cmplStd/lib/math.ci:485: referenced as `float64`
	cmplStd/lib/math.ci:472: referenced as `float64`
	cmplStd/lib/math.ci:469: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:450: referenced as `float64`
	cmplStd/lib/math.ci:450: referenced as `float64`
	cmplStd/lib/math.ci:442: referenced as `float64`
	cmplStd/lib/math.ci:442: referenced as `float64`
	cmplStd/lib/math.ci:440: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:423: referenced as `float64`
	cmplStd/lib/math.ci:420: referenced as `float64`
	cmplStd/lib/math.ci:420: referenced as `float64`
	cmplStd/lib/math.ci:418: referenced as `float64`
	cmplStd/lib/math.ci:415: referenced as `float64`
	cmplStd/lib/math.ci:398: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:380: referenced as `float64`
	cmplStd/lib/math.ci:379: referenced as `float64`
	cmplStd/lib/math.ci:362: referenced as `float64`
	cmplStd/lib/math.ci:361: referenced as `float64`
	cmplStd/lib/math.ci:340: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:336: referenced as `float64`
	cmplStd/lib/math.ci:333: referenced as `float64`
	cmplStd/lib/math.ci:328: referenced as `float64`
	cmplStd/lib/math.ci:327: referenced as `float64`
	cmplStd/lib/math.ci:326: referenced as `float64`
	cmplStd/lib/math.ci:309: referenced as `float64`
	cmplStd/lib/math.ci:305: referenced as `float64`
	cmplStd/lib/math.ci:302: referenced as `float64`
	cmplStd/lib/math.ci:296: referenced as `float64`
	cmplStd/lib/math.ci:283: referenced as `float64`
	cmplStd/lib/math.ci:282: referenced as `float64`
	cmplStd/lib/math.ci:282: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:244: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:231: referenced as `float64`
	cmplStd/lib/math.ci:231: referenced as `float64`
	cmplStd/lib/math.ci:226: referenced as `float64`
	cmplStd/lib/math.ci:226: referenced as `float64`
	cmplStd/lib/math.ci:218: referenced as `float64`
	cmplStd/lib/math.ci:217: referenced as `float64`
	cmplStd/lib/math.ci:217: referenced as `float64`
	cmplStd/lib/math.ci:207: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:193: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:180: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:144: referenced as `float64`
	cmplStd/lib/math.ci:144: referenced as `float64`
	cmplStd/lib/math.ci:126: referenced as `float64`
	cmplStd/lib/math.ci:126: referenced as `float64`
	cmplStd/lib/math.ci:108: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:74: referenced as `float64`
	cmplStd/lib/math.ci:57: referenced as `float64`
	cmplStd/lib/math.ci:54: referenced as `float64`
	cmplStd/lib/math.ci:48: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:32: referenced as `float64`
	cmplStd/lib/math.ci:25: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:5: referenced as `float64`
	cmplStd/stdlib.ci:10: referenced as `float64`
	internal usages: 19
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(41)
.usages:
	cmplGfx/lib/camera.ci:36: referenced as `sin`
	cmplStd/lib/math/Complex.ci:187: referenced as `sin`
	cmplStd/lib/math/Complex.ci:151: referenced as `sin`
	cmplStd/lib/math/Complex.ci:149: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:129: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(42)
.usages:
	cmplGfx/lib/camera.ci:37: referenced as `cos`
	cmplStd/lib/math/Complex.ci:187: referenced as `cos`
	cmplStd/lib/math/Complex.ci:151: referenced as `cos`
	cmplStd/lib/math/Complex.ci:149: referenced as `cos`
	cmplStd/lib/math/Complex.ci:141: referenced as `cos`
	cmplStd/lib/math/Complex.ci:129: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(43)
.usages:
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(44)
.usages:
	cmplStd/lib/math/Complex.ci:138: referenced as `log`
	cmplStd/lib/math/Complex.ci:132: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(45)
.usages:
	cmplStd/lib/math/Complex.ci:139: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math.ci:442: referenced as `exp`
	cmplStd/lib/math.ci:442: referenced as `exp`
	cmplStd/lib/math.ci:440: referenced as `exp`
	cmplStd/lib/math.ci:420: referenced as `exp`
	cmplStd/lib/math.ci:420: referenced as `exp`
	cmplStd/lib/math.ci:415: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(46)
.usages:
	cmplStd/lib/string.ci:260: referenced as `pow`
	cmplStd/lib/math/Complex.ci:139: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.value: nfc(47)
.usages:
	cmplStd/lib/math/Complex.ci:112: referenced as `sqrt`
	cmplStd/lib/math.ci:467: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: nfc(48)
.usages:
	cmplStd/lib/math/Complex.ci:114: referenced as `atan2`
	cmplStd/lib/math.ci:472: referenced as `atan2`
	cmplStd/lib/math.ci:469: referenced as `atan2`
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0, cast: static const inline)
.field fill: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/lib/image.ci:111: referenced as `pointer`
	internal usages: 17
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param ptr: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(12)
.usages:
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param value: uint8 (size: 4, cast: variable(u32))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(13)
.usages:
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(14)
.usages:
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(15)
.usages:
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
.field as: function (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/debug.ci:65: referenced as `variant`
	cmplStd/lib/debug.ci:56: referenced as `variant`
	cmplStd/lib/debug.ci:53: referenced as `variant`
	cmplStd/lib/debug.ci:50: referenced as `variant`
	cmplStd/lib/debug.ci:41: referenced as `variant`
	cmplStd/lib/debug.ci:34: referenced as `variant`
	cmplStd/lib/debug.ci:29: referenced as `variant`
	cmplStd/lib/debug.ci:24: referenced as `variant`
	cmplStd/lib/debug.ci:19: referenced as `variant`
	cmplStd/lib/debug.ci:14: referenced as `variant`
	cmplStd/lib/debug.ci:9: referenced as `variant`
	cmplStd/lib/debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, cast: inline)
.param var: variant (size: 8, cast: variable(var))
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
.usages:
	cmplStd/stdlib.ci:39: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.usages:
	internal usages: 2
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: object
.param .result: void (size: 0, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.param type: typename (size: 4, cast: variable(ref))
.value: nfc(9)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
.usages:
	cmplGfx/gfxlib.ci:132: referenced as `null`
	cmplGfx/gfxlib.ci:131: referenced as `null`
	cmplGfx/gfxlib.ci:114: referenced as `null`
	cmplGfx/gfxlib.ci:114: referenced as `null`
	cmplGfx/gfxlib.ci:113: referenced as `null`
	cmplGfx/gfxlib.ci:97: referenced as `null`
	cmplGfx/gfxlib.ci:55: referenced as `null`
	cmplGfx/gfxlib.ci:51: referenced as `null`
	cmplGfx/gfxlib.ci:28: referenced as `null`
	cmplGfx/gfxlib.ci:28: referenced as `null`
	cmplGfx/gfxlib.ci:27: referenced as `null`
	cmplGfx/gfxlib.ci:23: referenced as `null`
	cmplGfx/gfxlib.ci:23: referenced as `null`
	cmplGfx/gfxlib.ci:18: referenced as `null`
	cmplGfx/gfxlib.ci:17: referenced as `null`
	cmplGfx/gfxlib.ci:13: referenced as `null`
	cmplGfx/gfxlib.ci:12: referenced as `null`
	cmplGfx/gfxlib.ci:8: referenced as `null`
	cmplGfx/gfxlib.ci:7: referenced as `null`
	cmplGfx/lib/image.ci:207: referenced as `null`
	cmplGfx/lib/image.ci:206: referenced as `null`
	cmplGfx/lib/image.ci:205: referenced as `null`
	cmplGfx/lib/image.ci:204: referenced as `null`
	cmplGfx/lib/image.ci:173: referenced as `null`
	cmplGfx/lib/image.ci:172: referenced as `null`
	cmplGfx/lib/image.ci:171: referenced as `null`
	cmplGfx/lib/image.ci:170: referenced as `null`
	cmplGfx/lib/image.ci:114: referenced as `null`
	cmplGfx/lib/image.ci:77: referenced as `null`
	cmplGfx/lib/image.ci:77: referenced as `null`
	cmplGfx/lib/image.ci:7: referenced as `null`
	cmplGfx/lib/color.ci:258: referenced as `null`
	cmplStd/lib/string.ci:5: referenced as `null`
	cmplStd/lib/debug.ci:74: referenced as `null`
	cmplStd/lib/debug.ci:56: referenced as `null`
	cmplStd/lib/debug.ci:38: referenced as `null`
	cmplStd/lib/debug.ci:36: referenced as `null`
	cmplStd/lib/debug.ci:31: referenced as `null`
	cmplStd/lib/debug.ci:26: referenced as `null`
	cmplStd/lib/debug.ci:21: referenced as `null`
	cmplStd/lib/debug.ci:16: referenced as `null`
	cmplStd/lib/debug.ci:11: referenced as `null`
	cmplStd/lib/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0, cast: static const inline)
.field not: bool (size: 0, cast: static const inline)
.field set: void (size: 0, cast: static const inline)
.field ret: void (size: 0, cast: static const inline)
.field call: void (size: 0, cast: static const inline)
.field p4x: typename (size: 16, cast: static const typename(val))
.field dup: typename (size: 0, cast: static const typename(void))
.field load: typename (size: 0, cast: static const typename(void))
.field store: typename (size: 0, cast: static const typename(void))
.field cmt: typename (size: 0, cast: static const typename(void))
.field and: typename (size: 0, cast: static const typename(void))
.field or: typename (size: 0, cast: static const typename(void))
.field xor: typename (size: 0, cast: static const typename(void))
.field shl: typename (size: 0, cast: static const typename(void))
.field shr: typename (size: 0, cast: static const typename(void))
.field neg: typename (size: 0, cast: static const typename(void))
.field add: typename (size: 0, cast: static const typename(void))
.field sub: typename (size: 0, cast: static const typename(void))
.field mul: typename (size: 0, cast: static const typename(void))
.field div: typename (size: 0, cast: static const typename(void))
.field mod: typename (size: 0, cast: static const typename(void))
.field ceq: typename (size: 0, cast: static const typename(void))
.field clt: typename (size: 0, cast: static const typename(void))
.field cgt: typename (size: 0, cast: static const typename(void))
.field min: typename (size: 0, cast: static const typename(void))
.field max: typename (size: 0, cast: static const typename(void))
.field swz: typename (size: 0, cast: static const typename(void))
.usages:
	cmplGfx/lib/color.ci:105: referenced as `emit`
	cmplGfx/lib/color.ci:103: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:76: referenced as `emit`
	cmplStd/lib/math/Complex.ci:69: referenced as `emit`
	cmplStd/lib/math/Complex.ci:62: referenced as `emit`
	cmplStd/lib/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, cast: static const inline)
.field dp4: float32 (size: 0, cast: static const inline)
.field dph: float32 (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:112: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:116: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, cast: static const inline)
.field x2: int64 (size: 0, cast: static const inline)
.field x4: emit.p4x (size: 0, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, cast: static const inline)
.field z64: int64 (size: 0, cast: static const inline)
.field z128: emit.p4x (size: 0, cast: static const inline)
.field i8: int32 (size: 0, cast: static const inline)
.field i16: int32 (size: 0, cast: static const inline)
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field i128: emit.p4x (size: 0, cast: static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0, cast: static const inline)
.field i16: void (size: 0, cast: static const inline)
.field i32: void (size: 0, cast: static const inline)
.field i64: void (size: 0, cast: static const inline)
.field i128: void (size: 0, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:77: referenced as `add`
	cmplStd/lib/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:78: referenced as `sub`
	cmplStd/lib/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:78: referenced as `mul`
	cmplStd/lib/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:78: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint32 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.field p4f: bool (size: 0, cast: static const inline)
.field p2d: bool (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `swz`
	cmplStd/lib/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `x2`
	cmplStd/lib/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0, cast: inline)
.value: nfc(0)
.usages:
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0, cast: static const i64)
.field error: int64 (size: 0, cast: static const i64)
.field warn: int64 (size: 0, cast: static const i64)
.field info: int64 (size: 0, cast: static const i64)
.field debug: int64 (size: 0, cast: static const i64)
.field verbose: int64 (size: 0, cast: static const i64)
.field noTrace: int64 (size: 0, cast: static const i64)
.field defTrace: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param file: char[*] (size: 4, cast: const variable(ref))
.param line: int32 (size: 4, cast: variable(i32))
.param level: int32 (size: 4, cast: variable(i32))
.param trace: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: const variable(ref))
.param inspect: variant (size: 8, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(10)
.usages:
	cmplGfx/gfxlib.ci:18: referenced as `raise`
	cmplGfx/gfxlib.ci:18: referenced as `raise`
	cmplGfx/gfxlib.ci:18: referenced as `raise`
	cmplGfx/gfxlib.ci:13: referenced as `raise`
	cmplGfx/gfxlib.ci:13: referenced as `raise`
	cmplGfx/gfxlib.ci:13: referenced as `raise`
	cmplGfx/gfxlib.ci:8: referenced as `raise`
	cmplGfx/gfxlib.ci:8: referenced as `raise`
	cmplGfx/gfxlib.ci:8: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/stdlib.ci:39: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	cmplStd/lib/debug.ci:71: referenced as `abort`
	cmplStd/lib/debug.ci:38: referenced as `abort`
	cmplStd/lib/debug.ci:36: referenced as `abort`
	cmplStd/lib/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	cmplStd/lib/debug.ci:31: referenced as `error`
	cmplStd/lib/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	cmplStd/lib/debug.ci:26: referenced as `warn`
	cmplStd/lib/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	cmplStd/lib/debug.ci:21: referenced as `info`
	cmplStd/lib/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	cmplGfx/gfxlib.ci:18: referenced as `debug`
	cmplGfx/gfxlib.ci:13: referenced as `debug`
	cmplGfx/gfxlib.ci:8: referenced as `debug`
	cmplStd/lib/debug.ci:16: referenced as `debug`
	cmplStd/lib/debug.ci:14: referenced as `debug`
	cmplStd/lib/debug.ci:11: referenced as `debug`
	cmplStd/lib/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	cmplStd/lib/debug.ci:6: referenced as `verbose`
	cmplStd/lib/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	cmplGfx/gfxlib.ci:18: referenced as `noTrace`
	cmplGfx/gfxlib.ci:13: referenced as `noTrace`
	cmplGfx/gfxlib.ci:8: referenced as `noTrace`
	cmplStd/lib/debug.ci:26: referenced as `noTrace`
	cmplStd/lib/debug.ci:24: referenced as `noTrace`
	cmplStd/lib/debug.ci:21: referenced as `noTrace`
	cmplStd/lib/debug.ci:19: referenced as `noTrace`
	cmplStd/lib/debug.ci:11: referenced as `noTrace`
	cmplStd/lib/debug.ci:9: referenced as `noTrace`
	cmplStd/lib/debug.ci:6: referenced as `noTrace`
	cmplStd/lib/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	cmplStd/lib/debug.ci:71: referenced as `defTrace`
	cmplStd/lib/debug.ci:38: referenced as `defTrace`
	cmplStd/lib/debug.ci:36: referenced as `defTrace`
	cmplStd/lib/debug.ci:34: referenced as `defTrace`
	cmplStd/lib/debug.ci:31: referenced as `defTrace`
	cmplStd/lib/debug.ci:29: referenced as `defTrace`
	cmplStd/lib/debug.ci:16: referenced as `defTrace`
	cmplStd/lib/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4, cast: inline)
.param args: pointer (size: 4, cast: variable(ref))
.param action: function (size: 4, cast: variable(ref))
.value: nfc(11)
.usages:
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'System'
.field exit: function (size: 0, cast: static const inline)
.field srand: function (size: 0, cast: static const inline)
.field rand: function (size: 0, cast: static const inline)
.field time: function (size: 0, cast: static const inline)
.field clock: function (size: 0, cast: static const inline)
.field millis: function (size: 0, cast: static const inline)
.field sleep: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:272: referenced as `System`
	cmplGfx/gfxlib.ci:112: referenced as `System`
	cmplGfx/gfxlib.ci:98: referenced as `System`
	cmplGfx/gfxlib.ci:95: referenced as `System`
	cmplGfx/gfxlib.ci:71: referenced as `System`
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0, cast: inline)
.param code: int32 (size: 4, cast: variable(i32))
.value: nfc(16)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0, cast: inline)
.param seed: int32 (size: 4, cast: variable(i32))
.value: nfc(17)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(18)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(19)
.usages:
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.value: nfc(20)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, cast: inline)
.value: nfc(21)
.usages:
	cmplGfx/gfxlib.ci:272: referenced as `millis`
	cmplGfx/gfxlib.ci:112: referenced as `millis`
	cmplGfx/gfxlib.ci:98: referenced as `millis`
	cmplGfx/gfxlib.ci:95: referenced as `millis`
	cmplGfx/gfxlib.ci:71: referenced as `millis`
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0, cast: inline)
.param millis: int64 (size: 8, cast: variable(i64))
.value: nfc(22)
.usages:
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.name: 'true'
.file: 'cmplStd/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	cmplGfx/gfxlib.ci:73: referenced as `true`
	cmplGfx/lib/image.ci:152: referenced as `true`
	cmplStd/lib/string.ci:57: referenced as `true`
	cmplStd/lib/string.ci:42: referenced as `true`
	cmplStd/lib/math.ci:458: referenced as `true`
	cmplStd/lib/math.ci:411: referenced as `true`
	cmplStd/lib/math.ci:372: referenced as `true`
	cmplStd/lib/math.ci:368: referenced as `true`
	cmplStd/lib/math.ci:357: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.name: 'false'
.file: 'cmplStd/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	cmplGfx/lib/image.ci:150: referenced as `false`
	cmplGfx/lib/image.ci:147: referenced as `false`
	cmplStd/lib/string.ci:249: referenced as `false`
	cmplStd/lib/string.ci:121: referenced as `false`
	cmplStd/lib/string.ci:54: referenced as `false`
	cmplStd/lib/string.ci:50: referenced as `false`
	cmplStd/lib/string.ci:39: referenced as `false`
	cmplStd/lib/math.ci:456: referenced as `false`
	cmplStd/lib/math.ci:408: referenced as `false`
	cmplStd/lib/math.ci:353: referenced as `false`
	cmplStd/lib/math.ci:352: referenced as `false`
}
byte: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'byte'
.file: 'cmplStd/stdlib.ci:8'
.value: uint8
.usages:
}
float: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'float'
.file: 'cmplStd/stdlib.ci:9'
.value: float32
.usages:
}
double: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'double'
.file: 'cmplStd/stdlib.ci:10'
.value: float64
.usages:
}
signed(value: uint8): int8: function {
.kind: inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/stdlib.ci:13'
.param .result: int8 (size: 1, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
signed(value: uint16): int16: function {
.kind: inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/stdlib.ci:16'
.param .result: int16 (size: 2, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
signed(value: uint32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/stdlib.ci:19'
.param .result: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math.ci:227: referenced as `signed`
}
signed(value: uint64): int64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/stdlib.ci:22'
.param .result: int64 (size: 8, cast: i64)
.param value: uint64 (size: 8, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
unsigned(value: int8): uint8: function {
.kind: inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:25'
.param .result: uint8 (size: 1, cast: u32)
.param value: int8 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
unsigned(value: int16): uint16: function {
.kind: inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:28'
.param .result: uint16 (size: 2, cast: u32)
.param value: int16 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
unsigned(value: int32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:31'
.param .result: uint32 (size: 4, cast: u32)
.param value: int32 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
unsigned(value: int64): uint64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:34'
.param .result: uint64 (size: 8, cast: u64)
.param value: int64 (size: 8, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'cmplStd/stdlib.ci:37'
.param .result: int32 (size: 4, cast: i32)
.param type: typename (size: 4, cast: ref)
.doc: 'Returns the size of the given type'
.value: typename.size(type)
.usages:
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:4'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, inspect)
.usages:
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:6'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, null)
.usages:
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:9'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, inspect)
.usages:
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:11'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, null)
.usages:
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:14'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, inspect)
.usages:
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `trace`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:16'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, null)
.usages:
	cmplGfx/gfxlib.ci:106: referenced as `trace`
	cmplGfx/gfxlib.ci:84: referenced as `trace`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'cmplStd/lib/debug.ci:19'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, inspect)
.usages:
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'cmplStd/lib/debug.ci:21'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, null)
.usages:
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:24'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, inspect)
.usages:
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:26'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, null)
.usages:
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'cmplStd/lib/debug.ci:29'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, inspect)
.usages:
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'cmplStd/lib/debug.ci:31'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, null)
.usages:
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:34'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, inspect)
.usages:
	cmplGfx/lib/mesh.ci:9: referenced as `abort`
	cmplStd/lib/debug.ci:41: referenced as `abort`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:36'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, null)
.usages:
	cmplStd/lib/debug.ci:45: referenced as `abort`
	cmplStd/lib/debug.ci:43: referenced as `abort`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:38'
.param .result: void (size: 0, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
.usages:
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:41'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: const ref)
.param inspect: variant (size: 8, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message, inspect))
.usages:
	cmplStd/lib/string.ci:169: referenced as `assert`
	cmplStd/lib/string.ci:168: referenced as `assert`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:43'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:45'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	cmplStd/lib/string.ci:211: referenced as `assert`
	cmplStd/lib/string.ci:204: referenced as `assert`
	cmplStd/lib/string.ci:197: referenced as `assert`
	cmplStd/lib/string.ci:192: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'NotEquals'
.file: 'cmplStd/lib/debug.ci:48'
.field expected: variant (size: 8, cast: const variable(var))
.field returned: variant (size: 8, cast: const variable(var))
.field extras: variant[] (size: 8, cast: const variable(arr))
.doc: '@public'
.usages:
	cmplStd/lib/debug.ci:66: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'cmplStd/lib/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/debug.ci:67: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'cmplStd/lib/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/debug.ci:68: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.name: 'extras'
.file: 'cmplStd/lib/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	cmplStd/lib/debug.ci:69: referenced as `extras`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 103
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:61'
.param .result: void (size: 0, cast: variable(void))
.param expected: int32 (size: 4, cast: variable(i32))
.param returned: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (returned == expected) {
		return;
	}
	extras: variant[1] := {
		extras[0] := (message);
	};
	details: NotEquals := {
		details.expected := (expected);
		details.returned := (returned);
		details.extras := (extras);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (103 bytes)
	cmplStd/lib/debug.ci:62: (10 bytes): if (returned == expected)
	<assertEq>  : dup.x32 sp(2)
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: ceq.i32
	<assertEq+?>: jz +5
	cmplStd/lib/debug.ci:63: (1 byte): return;
	<assertEq+?>: ret
	cmplStd/lib/debug.ci:65: (13 bytes): extras: variant[1] := {...}
	<assertEq+?>: inc.sp(+8)
	cmplStd/lib/debug.ci:65: (9 bytes): extras[0] := (message);
	<assertEq+?>: load.ref <?>
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: set.x64 sp(2)
	cmplStd/lib/debug.ci:66: (37 bytes): details: NotEquals := {...}
	<assertEq+?>: inc.sp(+24)
	cmplStd/lib/debug.ci:67: (11 bytes): details.expected := (expected);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+48)
	<assertEq+?>: set.x64 sp(2)
	cmplStd/lib/debug.ci:68: (11 bytes): details.returned := (returned);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+44)
	<assertEq+?>: set.x64 sp(4)
	cmplStd/lib/debug.ci:69: (11 bytes): details.extras := (extras);
	<assertEq+?>: load.c32 1
	<assertEq+?>: load.sp(+28)
	<assertEq+?>: set.x64 sp(6)
	cmplStd/lib/debug.ci:71: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>: load.ref <?> ;"cmplStd/lib/debug.ci"
	<assertEq+?>: load.c32 71
	<assertEq+?>: load.c32 -2
	<assertEq+?>: load.c32 128
	<assertEq+?>: load.ref <?> ;"assertion failed"
	<assertEq+?>: load.ref <?> ;NotEquals
	<assertEq+?>: load.sp(+24)
	<assertEq+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>: inc.sp(-32)
	<assertEq+?>: ret
.usages:
	cmplStd/lib/debug.ci:74: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:74'
.param .result: void (size: 0, cast: void)
.param expected: int32 (size: 4, cast: i32)
.param returned: int32 (size: 4, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(expected, returned, null)
.usages:
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'cmplStd/lib/math.ci:2'
.field pi: float64 (size: 0, cast: static const val)
.field e: float64 (size: 0, cast: static const val)
.field ln2: float64 (size: 0, cast: static const val)
.field log2E: float64 (size: 0, cast: static const val)
.field ln10: float64 (size: 0, cast: static const val)
.field log10E: float64 (size: 0, cast: static const val)
.field phi: float64 (size: 0, cast: static const val)
.field sqrt2: float64 (size: 0, cast: static const val)
.field sqrtE: float64 (size: 0, cast: static const val)
.field sqrtPi: float64 (size: 0, cast: static const val)
.field sqrtPhi: float64 (size: 0, cast: static const val)
.field nan: float64 (size: 0, cast: static const val)
.field inf: float64 (size: 0, cast: static const val)
.field modf: function (size: 86, cast: static function)
.field floor: function (size: 24, cast: static function)
.field ceil: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field absMod: function (size: 27, cast: static function)
.field absMod: function (size: 27, cast: static function)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field clamp: function (size: 30, cast: static function)
.field clamp: function (size: 30, cast: static function)
.field lerp: function (size: 0, cast: static inline)
.field lerp: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field smooth: function (size: 0, cast: static inline)
.field min: function (size: 79, cast: static function)
.field max: function (size: 79, cast: static function)
.field sum: function (size: 40, cast: static function)
.field mean: function (size: 20, cast: static function)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 47, cast: static function)
.field cmp: function (size: 57, cast: static function)
.field cmp: function (size: 57, cast: static function)
.field sinCos: function (size: 335, cast: static function)
.field sin: function (size: 0, cast: static inline)
.field cos: function (size: 0, cast: static inline)
.field tan: function (size: 378, cast: static function)
.field sinh: function (size: 241, cast: static function)
.field cosh: function (size: 75, cast: static function)
.field asin: function (size: 173, cast: static function)
.field acos: function (size: 0, cast: static inline)
.field radians: function (size: 0, cast: static inline)
.field degrees: function (size: 0, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplGfx/lib/camera.ci:23: referenced as `Math`
	cmplGfx/lib/image.ci:105: referenced as `Math`
	cmplGfx/lib/image.ci:102: referenced as `Math`
	cmplGfx/lib/image.ci:40: referenced as `Math`
	cmplGfx/lib/image.ci:38: referenced as `Math`
	cmplStd/lib/string.ci:256: referenced as `Math`
	cmplStd/lib/string.ci:256: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'pi'
.file: 'cmplStd/lib/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/lib/math.ci:512: referenced as `pi`
	cmplStd/lib/math.ci:509: referenced as `pi`
	cmplStd/lib/math.ci:485: referenced as `pi`
	cmplStd/lib/math.ci:469: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'e'
.file: 'cmplStd/lib/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'ln2'
.file: 'cmplStd/lib/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'log2E'
.file: 'cmplStd/lib/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'ln10'
.file: 'cmplStd/lib/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'log10E'
.file: 'cmplStd/lib/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'phi'
.file: 'cmplStd/lib/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrt2'
.file: 'cmplStd/lib/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtE'
.file: 'cmplStd/lib/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtPi'
.file: 'cmplStd/lib/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'nan'
.file: 'cmplStd/lib/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/math.ci:464: referenced as `nan`
	cmplStd/lib/math.ci:385: referenced as `nan`
	cmplStd/lib/math.ci:205: referenced as `nan`
	cmplStd/lib/math.ci:191: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'inf'
.file: 'cmplStd/lib/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	cmplGfx/lib/image.ci:105: referenced as `inf`
	cmplGfx/lib/image.ci:102: referenced as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 86
.name: 'modf'
.file: 'cmplStd/lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param intPart: float64 (size: 4, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := -modf(-x, &intPart);
			intPart := -intPart;
			return .result := result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (86 bytes)
	cmplStd/lib/math.ci:23: (63 bytes): if (x < (1))
	<modf>  : dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: clt.f64
	<modf+?>: jz +51
	cmplStd/lib/math.ci:24: (39 bytes): if (x < (0))
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.z64
	<modf+?>: clt.f64
	<modf+?>: jz +35
	cmplStd/lib/math.ci:25: (17 bytes): result: float64 := -modf(-x, &intPart)
	<modf+?>: load.z64
	<modf+?>: dup.x64 sp(4)
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>: call
	<modf+?>: inc.sp(-12)
	<modf+?>: neg.f64
	cmplStd/lib/math.ci:26: (7 bytes): intPart := -intPart;
	<modf+?>: dup.x32 sp(3)
	<modf+?>: load.i64
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	cmplStd/lib/math.ci:27: (3 bytes): return .result := result;
	<modf+?>: set.x64 sp(6)
	<modf+?>: ret
	<modf+?>: inc.sp(-8)
	cmplStd/lib/math.ci:29: (4 bytes): intPart := (0);
	<modf+?>: load.z64
	<modf+?>: dup.x32 sp(3)
	<modf+?>: store.i64
	cmplStd/lib/math.ci:30: (4 bytes): return .result := x;
	<modf+?>: mov.x64 sp(4, 2)
	<modf+?>: ret
	cmplStd/lib/math.ci:32: (12 bytes): result: float64 := x % (1)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: mod.f64
	cmplStd/lib/math.ci:33: (8 bytes): intPart := x - result;
	<modf+?>: dup.x64 sp(4)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: sub.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	cmplStd/lib/math.ci:34: (3 bytes): return .result := result;
	<modf+?>: set.x64 sp(6)
	<modf+?>: ret
.usages:
	cmplStd/lib/string.ci:256: referenced as `modf`
	cmplStd/lib/math.ci:362: referenced as `modf`
	cmplStd/lib/math.ci:310: referenced as `modf`
	cmplStd/lib/math.ci:306: referenced as `modf`
	cmplStd/lib/math.ci:49: referenced as `modf`
	cmplStd/lib/math.ci:25: referenced as `modf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 24
.name: 'floor'
.file: 'cmplStd/lib/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(x, &result);
	return .result := result;
}
.instructions: (24 bytes)
	cmplStd/lib/math.ci:48: (1 byte): result: float64
	<floor>  : load.z128
	cmplStd/lib/math.ci:49: (20 bytes): modf(x, &result);
	<floor+?>: dup.x64 sp(5)
	<floor+?>: load.sp(+16)
	<floor+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<floor+?>: call
	<floor+?>: inc.sp(-12)
	<floor+?>: inc.sp(-8)
	cmplStd/lib/math.ci:50: (3 bytes): return .result := result;
	<floor+?>: set.x64 sp(5)
	<floor+?>: ret
.usages:
	cmplStd/lib/math.ci:57: referenced as `floor`
	cmplStd/lib/math.ci:54: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'cmplStd/lib/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'cmplStd/lib/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
}
Math.sign(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math.ci:63'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.value: x != 0 ? x < 0 ? -1 : 1 : 0
.usages:
}
Math.sign(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: variable(i64))
.value: x != (0) ? x < (0) ? -1 : 1 : 0
.usages:
}
Math.sign(x: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math.ci:65'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: uint32 (size: 4, cast: u32)
.value: x > (0) ? 1 : 0
.usages:
}
Math.sign(x: uint64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math.ci:66'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: uint64 (size: 8, cast: u64)
.value: x > (0) ? 1 : 0
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math.ci:71'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math.ci:74'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param val: float32 (size: 4, cast: variable(f32))
.param mod: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	cmplStd/lib/math.ci:78: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: mod.f32
	<absMod+?>: dup.x32 sp(0)
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: load.z32
	<absMod+?>: clt.f32
	<absMod+?>: jz +12
	cmplStd/lib/math.ci:79: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: add.f32
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: ret
	cmplStd/lib/math.ci:81: (4 bytes): return .result := val;
	<absMod+?>: mov.x32 sp(3, 2)
	<absMod+?>: ret
.usages:
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param val: float64 (size: 8, cast: variable(f64))
.param mod: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	cmplStd/lib/math.ci:86: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: mod.f64
	<absMod+?>: dup.x64 sp(0)
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: load.z64
	<absMod+?>: clt.f64
	<absMod+?>: jz +12
	cmplStd/lib/math.ci:87: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: add.f64
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: ret
	cmplStd/lib/math.ci:89: (4 bytes): return .result := val;
	<absMod+?>: mov.x64 sp(5, 3)
	<absMod+?>: ret
.usages:
}
Math.abs(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math.ci:93'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the absolute value of the input'
.value: x < 0 ? -x : x
.usages:
}
Math.abs(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math.ci:96'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param x: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
}
Math.abs(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math.ci:99'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param x: uint32 (size: 4, cast: u32)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math.ci:102'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param x: uint64 (size: 8, cast: u64)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math.ci:105'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
}
Math.abs(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math.ci:108'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
	cmplStd/lib/string.ci:256: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math.ci:336: referenced as `abs`
}
Math.min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math.ci:111'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
}
Math.min(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math.ci:114'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param a: int64 (size: 8, cast: variable(i64))
.param b: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
}
Math.min(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math.ci:117'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: variable(u32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
}
Math.min(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math.ci:120'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param a: uint64 (size: 8, cast: variable(u64))
.param b: uint64 (size: 8, cast: variable(u64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
}
Math.min(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math.ci:123'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
}
Math.min(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math.ci:126'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplGfx/lib/image.ci:40: referenced as `min`
}
Math.max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math.ci:129'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
}
Math.max(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math.ci:132'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param a: int64 (size: 8, cast: variable(i64))
.param b: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
}
Math.max(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math.ci:135'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: variable(u32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
}
Math.max(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math.ci:138'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param a: uint64 (size: 8, cast: variable(u64))
.param b: uint64 (size: 8, cast: variable(u64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
}
Math.max(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math.ci:141'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
}
Math.max(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math.ci:144'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplGfx/lib/image.ci:38: referenced as `max`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:147'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	cmplStd/lib/math.ci:148: (13 bytes): if (t < a)
	<clamp>  : dup.x32 sp(3)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: clt.f32
	<clamp+?>: jz +8
	cmplStd/lib/math.ci:149: (4 bytes): return .result := a;
	<clamp+?>: mov.x32 sp(4, 2)
	<clamp+?>: ret
	cmplStd/lib/math.ci:151: (13 bytes): if (t > b)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: cgt.f32
	<clamp+?>: jz +8
	cmplStd/lib/math.ci:152: (4 bytes): return .result := b;
	<clamp+?>: mov.x32 sp(4, 1)
	<clamp+?>: ret
	cmplStd/lib/math.ci:154: (4 bytes): return .result := t;
	<clamp+?>: mov.x32 sp(4, 3)
	<clamp+?>: ret
.usages:
	cmplStd/lib/math.ci:183: referenced as `clamp`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 30
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:158'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (30 bytes)
	cmplStd/lib/math.ci:159: (13 bytes): if (t < a)
	<clamp>  : dup.x64 sp(5)
	<clamp+?>: dup.x64 sp(5)
	<clamp+?>: clt.f64
	<clamp+?>: jz +8
	cmplStd/lib/math.ci:160: (4 bytes): return .result := a;
	<clamp+?>: mov.x64 sp(7, 3)
	<clamp+?>: ret
	cmplStd/lib/math.ci:162: (13 bytes): if (t > b)
	<clamp+?>: dup.x64 sp(5)
	<clamp+?>: dup.x64 sp(3)
	<clamp+?>: cgt.f64
	<clamp+?>: jz +8
	cmplStd/lib/math.ci:163: (4 bytes): return .result := b;
	<clamp+?>: mov.x64 sp(7, 1)
	<clamp+?>: ret
	cmplStd/lib/math.ci:165: (4 bytes): return .result := t;
	<clamp+?>: mov.x64 sp(7, 5)
	<clamp+?>: ret
.usages:
	cmplStd/lib/math.ci:186: referenced as `clamp`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:174'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:177'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:179'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: variable(f32))
.value: t * t * ((3) - (2) * t)
.usages:
	cmplStd/lib/math.ci:183: referenced as `smooth`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:180'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: variable(f64))
.value: t * t * ((3) - (2) * t)
.usages:
	cmplStd/lib/math.ci:186: referenced as `smooth`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:183'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp((t - a) / (b - a), float32(0), float32(1)))
.usages:
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:186'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp((t - a) / (b - a), float64(0), float64(1)))
.usages:
}
Math.min(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.name: 'min'
.file: 'cmplStd/lib/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result > data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	cmplStd/lib/math.ci:190: (20 bytes): if (data.length == (0))
	<min>  : dup.x32 sp(2)
	<min+?>: load.z32
	<min+?>: ceq.i32
	<min+?>: jz +16
	cmplStd/lib/math.ci:191: (12 bytes): return .result := nan;
	<min+?>: load.f64 -nan
	<min+?>: set.x64 sp(5)
	<min+?>: ret
	cmplStd/lib/math.ci:193: (3 bytes): result: float64 := data[0]
	<min+?>: dup.x32 sp(1)
	<min+?>: load.i64
	cmplStd/lib/math.ci:194: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+?>: load.c32 1
	<min+?>: jmp +35
	cmplStd/lib/math.ci:195: (27 bytes): if (result > data[i])
	<min+?>: dup.x64 sp(1)
	<min+?>: dup.x32 sp(6)
	<min+?>: dup.x32 sp(3)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: cgt.f64
	<min+?>: jz +15
	cmplStd/lib/math.ci:196: (11 bytes): result := data[i];
	<min+?>: dup.x32 sp(4)
	<min+?>: dup.x32 sp(1)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:194: (4 bytes): i := i + 1
	<min+?>: inc.i32(+1)
	cmplStd/lib/math.ci:194: (9 bytes): i < (data.length)
	<min+?>: dup.x32 sp(0)
	<min+?>: dup.x32 sp(6)
	<min+?>: clt.i32
	<min+?>: jnz -36
	<min+?>: inc.sp(-4)
	cmplStd/lib/math.ci:199: (3 bytes): return .result := result;
	<min+?>: set.x64 sp(5)
	<min+?>: ret
.usages:
}
Math.max(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.name: 'max'
.file: 'cmplStd/lib/math.ci:203'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (data.length == (0)) {
		return .result := nan;
	}
	result: float64 := data[0];
	for (i: int32 := 1; i < (data.length); i := i + 1) {
		if (result < data[i]) {
			result := data[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	cmplStd/lib/math.ci:204: (20 bytes): if (data.length == (0))
	<max>  : dup.x32 sp(2)
	<max+?>: load.z32
	<max+?>: ceq.i32
	<max+?>: jz +16
	cmplStd/lib/math.ci:205: (12 bytes): return .result := nan;
	<max+?>: load.f64 -nan
	<max+?>: set.x64 sp(5)
	<max+?>: ret
	cmplStd/lib/math.ci:207: (3 bytes): result: float64 := data[0]
	<max+?>: dup.x32 sp(1)
	<max+?>: load.i64
	cmplStd/lib/math.ci:208: (53 bytes): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+?>: load.c32 1
	<max+?>: jmp +35
	cmplStd/lib/math.ci:209: (27 bytes): if (result < data[i])
	<max+?>: dup.x64 sp(1)
	<max+?>: dup.x32 sp(6)
	<max+?>: dup.x32 sp(3)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: clt.f64
	<max+?>: jz +15
	cmplStd/lib/math.ci:210: (11 bytes): result := data[i];
	<max+?>: dup.x32 sp(4)
	<max+?>: dup.x32 sp(1)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:208: (4 bytes): i := i + 1
	<max+?>: inc.i32(+1)
	cmplStd/lib/math.ci:208: (9 bytes): i < (data.length)
	<max+?>: dup.x32 sp(0)
	<max+?>: dup.x32 sp(6)
	<max+?>: clt.i32
	<max+?>: jnz -36
	<max+?>: inc.sp(-4)
	cmplStd/lib/math.ci:213: (3 bytes): return .result := result;
	<max+?>: set.x64 sp(5)
	<max+?>: ret
.usages:
}
Math.sum(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.name: 'sum'
.file: 'cmplStd/lib/math.ci:217'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; i < (data.length); i := i + 1) {
		result := result + data[i];
	}
	return .result := result;
}
.instructions: (40 bytes)
	cmplStd/lib/math.ci:218: (1 byte): result: float64 := 0
	<sum>  : load.z128
	cmplStd/lib/math.ci:219: (36 bytes): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+?>: i64.2i32
	<sum+?>: jmp +22
	cmplStd/lib/math.ci:220: (14 bytes): result := result + data[i];
	<sum+?>: dup.x64 sp(1)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: dup.x32 sp(3)
	<sum+?>: mad.u32 8
	<sum+?>: load.i64
	<sum+?>: add.f64
	<sum+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:219: (4 bytes): i := i + 1
	<sum+?>: inc.i32(+1)
	cmplStd/lib/math.ci:219: (9 bytes): i < (data.length)
	<sum+?>: dup.x32 sp(0)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: clt.i32
	<sum+?>: jnz -23
	<sum+?>: inc.sp(-4)
	cmplStd/lib/math.ci:222: (3 bytes): return .result := result;
	<sum+?>: set.x64 sp(5)
	<sum+?>: ret
.usages:
	cmplStd/lib/math.ci:227: referenced as `sum`
}
Math.mean(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.name: 'mean'
.file: 'cmplStd/lib/math.ci:226'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param data: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return .result := sum(...data) / (signed(data.length));
}
.instructions: (20 bytes)
	cmplStd/lib/math.ci:227: (20 bytes): return .result := sum(...data) / (signed(data.length));
	<mean>  : load.z64
	<mean+?>: dup.x64 sp(3)
	<mean+?>: load.ref <?> ;Math.sum(data: float64[]): float64
	<mean+?>: call
	<mean+?>: inc.sp(-8)
	<mean+?>: dup.x32 sp(4)
	<mean+?>: i32.2f64
	<mean+?>: div.f64
	<mean+?>: set.x64 sp(5)
	<mean+?>: ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math.ci:231'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math.ci:234'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * a1)
.usages:
	cmplStd/lib/math.ci:237: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math.ci:237'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * eval(x, a1, a2))
.usages:
	cmplStd/lib/math.ci:240: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math.ci:240'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0 + x * eval(x, a1, a2, a3))
.usages:
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.name: 'eval'
.file: 'cmplStd/lib/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param polynomial: float64[] (size: 8, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
		result := result * x + polynomial[i];
	}
	return .result := result;
}
.instructions: (47 bytes)
	cmplStd/lib/math.ci:244: (1 byte): result: float64 := 0
	<eval>  : load.z64
	cmplStd/lib/math.ci:245: (43 bytes): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.i32(-1)
	<eval+?>: jmp +25
	cmplStd/lib/math.ci:246: (17 bytes): result := result * x + polynomial[i];
	<eval+?>: dup.x64 sp(1)
	<eval+?>: dup.x64 sp(8)
	<eval+?>: mul.f64
	<eval+?>: dup.x32 sp(6)
	<eval+?>: dup.x32 sp(3)
	<eval+?>: mad.u32 8
	<eval+?>: load.i64
	<eval+?>: add.f64
	<eval+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:245: (4 bytes): i := i - 1
	<eval+?>: inc.i32(-1)
	cmplStd/lib/math.ci:245: (8 bytes): i >= 0
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz -25
	<eval+?>: inc.sp(-4)
	cmplStd/lib/math.ci:248: (3 bytes): return .result := result;
	<eval+?>: set.x64 sp(7)
	<eval+?>: ret
.usages:
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:252'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.param eps: float32 (size: 4, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else if (eps < (a - b)) {
		return .result := +1;
	}
	return .result := 0;
}
.instructions: (57 bytes)
	cmplStd/lib/math.ci:253: (53 bytes): if (a < b)
	<cmp>  : dup.x32 sp(3)
	<cmp+?>: dup.x32 sp(3)
	<cmp+?>: clt.f32
	<cmp+?>: jz +28
	cmplStd/lib/math.ci:254: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x32 sp(1)
	<cmp+?>: dup.x32 sp(3)
	<cmp+?>: dup.x32 sp(5)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	cmplStd/lib/math.ci:255: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x32 sp(5)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	cmplStd/lib/math.ci:259: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x32 sp(1)
	<cmp+?>: dup.x32 sp(4)
	<cmp+?>: dup.x32 sp(4)
	<cmp+?>: sub.f32
	<cmp+?>: clt.f32
	<cmp+?>: jz +12
	cmplStd/lib/math.ci:260: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x32 sp(5)
	<cmp+?>: ret
	cmplStd/lib/math.ci:263: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x32 sp(5)
	<cmp+?>: ret
.usages:
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:267'
.owner: Math
.param .result: int32 (size: 4, cast: variable(i32))
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.param eps: float64 (size: 8, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else if (eps < (a - b)) {
		return .result := +1;
	}
	return .result := 0;
}
.instructions: (57 bytes)
	cmplStd/lib/math.ci:268: (53 bytes): if (a < b)
	<cmp>  : dup.x64 sp(5)
	<cmp+?>: dup.x64 sp(5)
	<cmp+?>: clt.f64
	<cmp+?>: jz +28
	cmplStd/lib/math.ci:269: (20 bytes): if (eps < (b - a))
	<cmp+?>: dup.x64 sp(1)
	<cmp+?>: dup.x64 sp(5)
	<cmp+?>: dup.x64 sp(9)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	cmplStd/lib/math.ci:270: (8 bytes): return .result := -1;
	<cmp+?>: load.c32 -1
	<cmp+?>: set.x32 sp(8)
	<cmp+?>: ret
	<cmp+?>: jmp +24
	cmplStd/lib/math.ci:274: (20 bytes): if (eps < (a - b))
	<cmp+?>: dup.x64 sp(1)
	<cmp+?>: dup.x64 sp(7)
	<cmp+?>: dup.x64 sp(7)
	<cmp+?>: sub.f64
	<cmp+?>: clt.f64
	<cmp+?>: jz +12
	cmplStd/lib/math.ci:275: (8 bytes): return .result := +1;
	<cmp+?>: load.c32 1
	<cmp+?>: set.x32 sp(8)
	<cmp+?>: ret
	cmplStd/lib/math.ci:278: (4 bytes): return .result := 0;
	<cmp+?>: load.z32
	<cmp+?>: set.x32 sp(8)
	<cmp+?>: ret
.usages:
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 335
.name: 'sinCos'
.file: 'cmplStd/lib/math.ci:282'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.param quad: int32 (size: 4, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (1) / PIO2;
	if (x > (32764)) {
		e: float64;
		y := modf(x, &e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, &f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
	temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
	return .result := temp1 / temp2;
}
.instructions: (335 bytes)
	cmplStd/lib/math.ci:296: (2 bytes): x: float64 := arg
	<sinCos>  : dup.x64 sp(2)
	cmplStd/lib/math.ci:297: (17 bytes): if (x < (0))
	<sinCos+?>: dup.x64 sp(0)
	<sinCos+?>: load.z64
	<sinCos+?>: clt.f64
	<sinCos+?>: jz +13
	cmplStd/lib/math.ci:298: (1 byte): x := -x;
	<sinCos+?>: neg.f64
	cmplStd/lib/math.ci:299: (8 bytes): quad := quad + 2;
	<sinCos+?>: dup.x32 sp(3)
	<sinCos+?>: inc.i32(+2)
	<sinCos+?>: set.x32 sp(4)
	cmplStd/lib/math.ci:302: (1 byte): y: float64
	<sinCos+?>: load.z64
	cmplStd/lib/math.ci:303: (24 bytes): x := x * (1) / PIO2;
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: load.f64 1.570796
	<sinCos+?>: div.f64
	<sinCos+?>: mul.f64
	<sinCos+?>: set.x64 sp(4)
	cmplStd/lib/math.ci:304: (124 bytes): if (x > (32764))
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 32764.000000
	<sinCos+?>: cgt.f64
	<sinCos+?>: jz +84
	cmplStd/lib/math.ci:305: (1 byte): e: float64
	<sinCos+?>: load.z128
	cmplStd/lib/math.ci:306: (18 bytes): y := modf(x, &e);
	<sinCos+?>: dup.x64 sp(6)
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: set.x64 sp(4)
	cmplStd/lib/math.ci:307: (4 bytes): e := e + (quad);
	<sinCos+?>: dup.x32 sp(7)
	<sinCos+?>: i32.2f64
	<sinCos+?>: add.f64
	cmplStd/lib/math.ci:309: (1 byte): f: float64
	<sinCos+?>: load.z128
	cmplStd/lib/math.ci:310: (30 bytes): modf(0.250000 * e, &f);
	<sinCos+?>: load.f64 0.250000
	<sinCos+?>: dup.x64 sp(6)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.sp(+16)
	<sinCos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>: call
	<sinCos+?>: inc.sp(-12)
	<sinCos+?>: inc.sp(-8)
	cmplStd/lib/math.ci:311: (18 bytes): quad := (e - (4) * f);
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 4.000000
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: sub.f64
	<sinCos+?>: f64.2i32
	<sinCos+?>: set.x32 sp(10)
	<sinCos+?>: inc.sp(-16)
	<sinCos+?>: jmp +32
	cmplStd/lib/math.ci:314: (3 bytes): k: int32 := x
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: f64.2i32
	cmplStd/lib/math.ci:315: (8 bytes): y := x - (k);
	<sinCos+?>: dup.x64 sp(3)
	<sinCos+?>: dup.x32 sp(2)
	<sinCos+?>: i32.2f64
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:316: (7 bytes): quad := quad + k;
	<sinCos+?>: dup.x32 sp(6)
	<sinCos+?>: dup.x32 sp(1)
	<sinCos+?>: add.i32
	<sinCos+?>: set.x32 sp(7)
	cmplStd/lib/math.ci:317: (6 bytes): quad := quad & 3;
	<sinCos+?>: dup.x32 sp(6)
	<sinCos+?>: b32.and 0x03
	<sinCos+?>: set.x32 sp(7)
	<sinCos+?>: inc.sp(-4)
	cmplStd/lib/math.ci:319: (22 bytes): if (quad & 1)
	<sinCos+?>: dup.x32 sp(5)
	<sinCos+?>: b32.and 0x01
	<sinCos+?>: jz +18
	cmplStd/lib/math.ci:320: (14 bytes): y := (1) - y;
	<sinCos+?>: load.f64 1.000000
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: sub.f64
	<sinCos+?>: set.x64 sp(2)
	cmplStd/lib/math.ci:322: (13 bytes): if (quad > 1)
	<sinCos+?>: dup.x32 sp(5)
	<sinCos+?>: load.c32 1
	<sinCos+?>: cgt.i32
	<sinCos+?>: jz +5
	cmplStd/lib/math.ci:323: (1 byte): y := -y;
	<sinCos+?>: neg.f64
	cmplStd/lib/math.ci:326: (5 bytes): ysq: float64 := y * y
	<sinCos+?>: dup.x64 sp(0)
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	cmplStd/lib/math.ci:327: (64 bytes): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+?>: load.f64 145.968841
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -13847.272500
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 440103.053538
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 -4942908.100903
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 13578840.978774
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	cmplStd/lib/math.ci:328: (51 bytes): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: load.f64 132.653491
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 9463.096102
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 408179.225234
	<sinCos+?>: add.f64
	<sinCos+?>: dup.x64 sp(4)
	<sinCos+?>: mul.f64
	<sinCos+?>: load.f64 8644558.652923
	<sinCos+?>: add.f64
	cmplStd/lib/math.ci:329: (12 bytes): return .result := temp1 / temp2;
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: dup.x64 sp(2)
	<sinCos+?>: div.f64
	<sinCos+?>: set.x64 sp(16)
	<sinCos+?>: inc.sp(-40)
	<sinCos+?>: ret
.usages:
	cmplStd/lib/math.ci:336: referenced as `sinCos`
	cmplStd/lib/math.ci:333: referenced as `sinCos`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'cmplStd/lib/math.ci:333'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(arg, 0)
.usages:
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'cmplStd/lib/math.ci:336'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param arg: float64 (size: 8, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(abs(arg), 1)
.usages:
}
Math.tan(arg: float64): float64: function {
.kind: static function
.base: `function`
.size: 378
.name: 'tan'
.file: 'cmplStd/lib/math.ci:339'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (arg < (0)) {
		arg := -arg;
		negate := true;
	}
	arg := (2) * arg / PIO2;
	e: float64;
	x: float64 := modf(arg, &e);
	i: int32 := int32(e) % 4;
	if (i == 0) ;
	else if (i == 1) {
		x := (1) - x;
		complement := true;
	}
	else if (i == 2) {
		negate := !negate;
		complement := true;
	}
	else if (i == 3) {
		x := (1) - x;
		negate := !negate;
	}
	xsq: float64 := x * x;
	result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
	result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	if (complement) {
		if (result == (0)) {
			return .result := nan;
		}
		result := (1) / result;
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (378 bytes)
	cmplStd/lib/math.ci:352: (1 byte): complement: bool := false
	<tan>  : load.z32
	cmplStd/lib/math.ci:353: (1 byte): negate: bool := false
	<tan+?>: load.z32
	cmplStd/lib/math.ci:355: (23 bytes): if (arg < (0))
	<tan+?>: dup.x64 sp(3)
	<tan+?>: load.z64
	<tan+?>: clt.f64
	<tan+?>: jz +19
	cmplStd/lib/math.ci:356: (5 bytes): arg := -arg;
	<tan+?>: dup.x64 sp(3)
	<tan+?>: neg.f64
	<tan+?>: set.x64 sp(5)
	cmplStd/lib/math.ci:357: (10 bytes): negate := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+4)
	<tan+?>: store.i8
	cmplStd/lib/math.ci:359: (24 bytes): arg := (2) * arg / PIO2;
	<tan+?>: load.f64 2.000000
	<tan+?>: dup.x64 sp(5)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1.570796
	<tan+?>: div.f64
	<tan+?>: set.x64 sp(5)
	cmplStd/lib/math.ci:361: (1 byte): e: float64
	<tan+?>: load.z128
	cmplStd/lib/math.ci:362: (16 bytes): x: float64 := modf(arg, &e)
	<tan+?>: dup.x64 sp(7)
	<tan+?>: load.sp(+16)
	<tan+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<tan+?>: call
	<tan+?>: inc.sp(-12)
	cmplStd/lib/math.ci:363: (9 bytes): i: int32 := int32(e) % 4
	<tan+?>: dup.x64 sp(2)
	<tan+?>: f64.2i32
	<tan+?>: load.c32 4
	<tan+?>: mod.i32
	cmplStd/lib/math.ci:365: (122 bytes): if (i == 0)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.z32
	<tan+?>: ceq.i32
	<tan+?>: jnz +118
	cmplStd/lib/math.ci:366: (114 bytes): if (i == 1)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.c32 1
	<tan+?>: ceq.i32
	<tan+?>: jz +32
	cmplStd/lib/math.ci:367: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x64 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:368: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +78
	cmplStd/lib/math.ci:370: (74 bytes): if (i == 2)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.c32 2
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	cmplStd/lib/math.ci:371: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	cmplStd/lib/math.ci:372: (10 bytes): complement := true;
	<tan+?>: load.c32 1
	<tan+?>: load.sp(+28)
	<tan+?>: store.i8
	<tan+?>: jmp +41
	cmplStd/lib/math.ci:374: (37 bytes): if (i == 3)
	<tan+?>: dup.x32 sp(0)
	<tan+?>: load.c32 3
	<tan+?>: ceq.i32
	<tan+?>: jz +29
	cmplStd/lib/math.ci:375: (14 bytes): x := (1) - x;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x64 sp(3)
	<tan+?>: sub.f64
	<tan+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:376: (11 bytes): negate := !negate;
	<tan+?>: load.sp(+20)
	<tan+?>: load.i8
	<tan+?>: not.b32
	<tan+?>: load.sp(+24)
	<tan+?>: store.i8
	cmplStd/lib/math.ci:379: (5 bytes): xsq: float64 := x * x
	<tan+?>: dup.x64 sp(1)
	<tan+?>: dup.x64 sp(3)
	<tan+?>: mul.f64
	cmplStd/lib/math.ci:380: (64 bytes): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+?>: load.f64 0.000034
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 0.034226
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -15.506857
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 1055.970902
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(2)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -13068.202648
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(5)
	<tan+?>: mul.f64
	cmplStd/lib/math.ci:381: (39 bytes): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+?>: dup.x64 sp(2)
	<tan+?>: load.f64 -155.503316
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 4765.751363
	<tan+?>: add.f64
	<tan+?>: dup.x64 sp(4)
	<tan+?>: mul.f64
	<tan+?>: load.f64 -16638.952389
	<tan+?>: add.f64
	<tan+?>: div.f64
	cmplStd/lib/math.ci:383: (47 bytes): if (complement)
	<tan+?>: load.sp(+40)
	<tan+?>: load.i8
	<tan+?>: jz +42
	cmplStd/lib/math.ci:384: (24 bytes): if (result == (0))
	<tan+?>: dup.x64 sp(0)
	<tan+?>: load.z64
	<tan+?>: ceq.f64
	<tan+?>: jz +20
	cmplStd/lib/math.ci:385: (16 bytes): return .result := nan;
	<tan+?>: load.f64 -nan
	<tan+?>: set.x64 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	cmplStd/lib/math.ci:387: (14 bytes): result := (1) / result;
	<tan+?>: load.f64 1.000000
	<tan+?>: dup.x64 sp(2)
	<tan+?>: div.f64
	<tan+?>: set.x64 sp(2)
	cmplStd/lib/math.ci:389: (19 bytes): if (negate)
	<tan+?>: load.sp(+36)
	<tan+?>: load.i8
	<tan+?>: jz +14
	cmplStd/lib/math.ci:390: (10 bytes): return .result := -result;
	<tan+?>: dup.x64 sp(0)
	<tan+?>: neg.f64
	<tan+?>: set.x64 sp(16)
	<tan+?>: inc.sp(-44)
	<tan+?>: ret
	cmplStd/lib/math.ci:392: (7 bytes): return .result := result;
	<tan+?>: set.x64 sp(14)
	<tan+?>: inc.sp(-36)
	<tan+?>: ret
.usages:
}
Math.sinh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 241
.name: 'sinh'
.file: 'cmplStd/lib/math.ci:396'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (x < (0)) {
		x := -x;
		negate := true;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	result: float64;
	if (x > 0.500000) {
		result := (float64.exp(x) - float64.exp(-x)) / (2);
	}
	else {
		sq: float64 := x * x;
		result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (241 bytes)
	cmplStd/lib/math.ci:408: (1 byte): negate: bool := false
	<sinh>  : load.z32
	cmplStd/lib/math.ci:409: (23 bytes): if (x < (0))
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.z64
	<sinh+?>: clt.f64
	<sinh+?>: jz +19
	cmplStd/lib/math.ci:410: (5 bytes): x := -x;
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: neg.f64
	<sinh+?>: set.x64 sp(4)
	cmplStd/lib/math.ci:411: (10 bytes): negate := true;
	<sinh+?>: load.c32 1
	<sinh+?>: load.sp(+4)
	<sinh+?>: store.i8
	cmplStd/lib/math.ci:414: (39 bytes): if (x > (21))
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.f64 21.000000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +27
	cmplStd/lib/math.ci:415: (23 bytes): return .result := float64.exp(x) / (2);
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: nfc(45) ;float64.exp(x: float64): float64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x64 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
	cmplStd/lib/math.ci:418: (1 byte): result: float64
	<sinh+?>: load.z64
	cmplStd/lib/math.ci:419: (151 bytes): if (x > 0.500000)
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: load.f64 0.500000
	<sinh+?>: cgt.f64
	<sinh+?>: jz +34
	cmplStd/lib/math.ci:420: (26 bytes): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: nfc(45) ;float64.exp(x: float64): float64
	<sinh+?>: dup.x64 sp(6)
	<sinh+?>: neg.f64
	<sinh+?>: nfc(45) ;float64.exp(x: float64): float64
	<sinh+?>: sub.f64
	<sinh+?>: load.f64 2.000000
	<sinh+?>: div.f64
	<sinh+?>: set.x64 sp(2)
	<sinh+?>: jmp +109
	cmplStd/lib/math.ci:423: (5 bytes): sq: float64 := x * x
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: dup.x64 sp(6)
	<sinh+?>: mul.f64
	cmplStd/lib/math.ci:424: (53 bytes): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+?>: load.f64 -26.305632
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -2894.211356
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -89912.720220
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(8)
	<sinh+?>: mul.f64
	<sinh+?>: set.x64 sp(4)
	cmplStd/lib/math.ci:425: (43 bytes): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.f64 -173.678954
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 15215.173788
	<sinh+?>: add.f64
	<sinh+?>: dup.x64 sp(4)
	<sinh+?>: mul.f64
	<sinh+?>: load.f64 -630767.364050
	<sinh+?>: add.f64
	<sinh+?>: div.f64
	<sinh+?>: set.x64 sp(4)
	<sinh+?>: inc.sp(-8)
	cmplStd/lib/math.ci:428: (19 bytes): if (negate)
	<sinh+?>: load.sp(+8)
	<sinh+?>: load.i8
	<sinh+?>: jz +14
	cmplStd/lib/math.ci:429: (10 bytes): return .result := -result;
	<sinh+?>: dup.x64 sp(0)
	<sinh+?>: neg.f64
	<sinh+?>: set.x64 sp(8)
	<sinh+?>: inc.sp(-12)
	<sinh+?>: ret
	cmplStd/lib/math.ci:431: (7 bytes): return .result := result;
	<sinh+?>: set.x64 sp(6)
	<sinh+?>: inc.sp(-4)
	<sinh+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:151: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:149: referenced as `sinh`
}
Math.cosh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 75
.name: 'cosh'
.file: 'cmplStd/lib/math.ci:435'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (x < (0)) {
		x := -x;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	return .result := (float64.exp(x) + float64.exp(-x)) / (2);
}
.instructions: (75 bytes)
	cmplStd/lib/math.ci:436: (13 bytes): if (x < (0))
	<cosh>  : dup.x64 sp(1)
	<cosh+?>: load.z64
	<cosh+?>: clt.f64
	<cosh+?>: jz +9
	cmplStd/lib/math.ci:437: (5 bytes): x := -x;
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: neg.f64
	<cosh+?>: set.x64 sp(3)
	cmplStd/lib/math.ci:439: (35 bytes): if (x > (21))
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: load.f64 21.000000
	<cosh+?>: cgt.f64
	<cosh+?>: jz +23
	cmplStd/lib/math.ci:440: (19 bytes): return .result := float64.exp(x) / (2);
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: nfc(45) ;float64.exp(x: float64): float64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x64 sp(5)
	<cosh+?>: ret
	cmplStd/lib/math.ci:442: (27 bytes): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+?>: dup.x64 sp(1)
	<cosh+?>: nfc(45) ;float64.exp(x: float64): float64
	<cosh+?>: dup.x64 sp(3)
	<cosh+?>: neg.f64
	<cosh+?>: nfc(45) ;float64.exp(x: float64): float64
	<cosh+?>: add.f64
	<cosh+?>: load.f64 2.000000
	<cosh+?>: div.f64
	<cosh+?>: set.x64 sp(5)
	<cosh+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:151: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:149: referenced as `cosh`
}
Math.asin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 173
.name: 'asin'
.file: 'cmplStd/lib/math.ci:450'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(±0) = ±0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (x == (0)) {
		return .result := x;
	}
	negate: bool := false;
	if (x < (0)) {
		negate := true;
		x := -x;
	}
	if (x > (1)) {
		return .result := nan;
	}
	result: float64 := float64.sqrt((1) - x * x);
	if (x > 0.700000) {
		result := pi / (2) - float64.atan2(result, x);
	}
	else {
		result := float64.atan2(x, result);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (173 bytes)
	cmplStd/lib/math.ci:451: (12 bytes): if (x == (0))
	<asin>  : dup.x64 sp(1)
	<asin+?>: load.z64
	<asin+?>: ceq.f64
	<asin+?>: jz +8
	cmplStd/lib/math.ci:453: (4 bytes): return .result := x;
	<asin+?>: mov.x64 sp(3, 1)
	<asin+?>: ret
	cmplStd/lib/math.ci:456: (1 byte): negate: bool := false
	<asin+?>: load.z32
	cmplStd/lib/math.ci:457: (23 bytes): if (x < (0))
	<asin+?>: dup.x64 sp(2)
	<asin+?>: load.z64
	<asin+?>: clt.f64
	<asin+?>: jz +19
	cmplStd/lib/math.ci:458: (10 bytes): negate := true;
	<asin+?>: load.c32 1
	<asin+?>: load.sp(+4)
	<asin+?>: store.i8
	cmplStd/lib/math.ci:459: (5 bytes): x := -x;
	<asin+?>: dup.x64 sp(2)
	<asin+?>: neg.f64
	<asin+?>: set.x64 sp(4)
	cmplStd/lib/math.ci:462: (32 bytes): if (x > (1))
	<asin+?>: dup.x64 sp(2)
	<asin+?>: load.f64 1.000000
	<asin+?>: cgt.f64
	<asin+?>: jz +20
	cmplStd/lib/math.ci:464: (16 bytes): return .result := nan;
	<asin+?>: load.f64 -nan
	<asin+?>: set.x64 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
	cmplStd/lib/math.ci:467: (19 bytes): result: float64 := float64.sqrt((1) - x * x)
	<asin+?>: load.f64 1.000000
	<asin+?>: dup.x64 sp(4)
	<asin+?>: dup.x64 sp(6)
	<asin+?>: mul.f64
	<asin+?>: sub.f64
	<asin+?>: nfc(47) ;float64.sqrt(x: float64): float64
	cmplStd/lib/math.ci:468: (60 bytes): if (x > 0.700000)
	<asin+?>: dup.x64 sp(4)
	<asin+?>: load.f64 0.700000
	<asin+?>: cgt.f64
	<asin+?>: jz +38
	cmplStd/lib/math.ci:469: (30 bytes): result := pi / (2) - float64.atan2(result, x);
	<asin+?>: load.f64 3.141593
	<asin+?>: load.f64 2.000000
	<asin+?>: div.f64
	<asin+?>: dup.x64 sp(2)
	<asin+?>: dup.x64 sp(8)
	<asin+?>: nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: sub.f64
	<asin+?>: set.x64 sp(2)
	<asin+?>: jmp +14
	cmplStd/lib/math.ci:472: (10 bytes): result := float64.atan2(x, result);
	<asin+?>: dup.x64 sp(4)
	<asin+?>: dup.x64 sp(2)
	<asin+?>: nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>: set.x64 sp(2)
	cmplStd/lib/math.ci:475: (19 bytes): if (negate)
	<asin+?>: load.sp(+8)
	<asin+?>: load.i8
	<asin+?>: jz +14
	cmplStd/lib/math.ci:476: (10 bytes): return .result := -result;
	<asin+?>: dup.x64 sp(0)
	<asin+?>: neg.f64
	<asin+?>: set.x64 sp(8)
	<asin+?>: inc.sp(-12)
	<asin+?>: ret
	cmplStd/lib/math.ci:478: (7 bytes): return .result := result;
	<asin+?>: set.x64 sp(6)
	<asin+?>: inc.sp(-4)
	<asin+?>: ret
.usages:
	cmplStd/lib/math.ci:485: referenced as `asin`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'cmplStd/lib/math.ci:485'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (pi / (2) - asin(x))
.usages:
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'radians'
.file: 'cmplStd/lib/math.ci:509'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param degrees: float64 (size: 8, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(degrees * pi / (180))
.usages:
	cmplGfx/lib/camera.ci:23: referenced as `radians`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'degrees'
.file: 'cmplStd/lib/math.ci:512'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param radians: float64 (size: 8, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(radians * (180) / pi)
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:184: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:182: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:180: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:178: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:175: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:173: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:171: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:169: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:166: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:164: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:114: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:112: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:31: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:24: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:141: referenced as `re`
	cmplStd/lib/math/Complex.ci:139: referenced as `re`
	cmplStd/lib/math/Complex.ci:138: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:126: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:114: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:102: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:99: referenced as `re`
	cmplStd/lib/math/Complex.ci:98: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:95: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:92: referenced as `re`
	cmplStd/lib/math/Complex.ci:91: referenced as `re`
	cmplStd/lib/math/Complex.ci:90: referenced as `re`
	cmplStd/lib/math/Complex.ci:83: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:73: referenced as `re`
	cmplStd/lib/math/Complex.ci:71: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:64: referenced as `re`
	cmplStd/lib/math/Complex.ci:33: referenced as `re`
	cmplStd/lib/math/Complex.ci:26: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:139: referenced as `im`
	cmplStd/lib/math/Complex.ci:138: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:126: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:114: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:101: referenced as `im`
	cmplStd/lib/math/Complex.ci:99: referenced as `im`
	cmplStd/lib/math/Complex.ci:98: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:94: referenced as `im`
	cmplStd/lib/math/Complex.ci:92: referenced as `im`
	cmplStd/lib/math/Complex.ci:91: referenced as `im`
	cmplStd/lib/math/Complex.ci:90: referenced as `im`
	cmplStd/lib/math/Complex.ci:83: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:73: referenced as `im`
	cmplStd/lib/math/Complex.ci:71: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:64: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	internal usages: 1
}
Complex(re: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:24'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := {
			.result.re := re;
			.result.im := (0);
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Complex.ci:25: (7 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:26: (3 bytes): .result.re := re;
	<Complex>  : mov.x64 sp(3, 1)
	:: (3 bytes): .result.im := (0);
	<Complex+?>: load.z64
	<Complex+?>: set.x64 sp(7)
	<Complex+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:31'
.param .result: Complex (size: 16, cast: variable(val))
.param re: float64 (size: 8, cast: variable(f64))
.param im: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := {
			.result.re := re;
			.result.im := im;
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Complex.ci:32: (7 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:33: (3 bytes): .result.re := re;
	<Complex>  : mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:34: (3 bytes): .result.im := im;
	<Complex+?>: mov.x64 sp(7, 1)
	<Complex+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:59'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(struct(a), neg.p2d))
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:171: referenced as `neg`
	cmplStd/lib/math/Complex.ci:169: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:62'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: Complex (size: 16, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(struct(a), struct(b), add.p2d))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:64'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: Complex(a.re + b, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `add`
	cmplStd/lib/math/Complex.ci:173: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:66'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a + b.re, b.im)
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:69'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: Complex (size: 16, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(struct(a), struct(b), sub.p2d))
.usages:
	cmplStd/lib/math/Complex.ci:169: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:71'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: Complex(a.re - b, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `sub`
	cmplStd/lib/math/Complex.ci:173: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:73'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a - b.re, b.im)
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(struct(a), struct(b), swz.x2, mul.p2d, add.f64, struct(a), struct(b), mul.p2d, swz.x2, sub.f64))
.usages:
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: Complex(a.re * b, a.im * b)
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:83'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: variable(f64))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a * b.re, a * b.im)
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 139
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:86'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (139 bytes)
	cmplStd/lib/math/Complex.ci:90: (95 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div>  : dup.x64 sp(1)
	<div+?>: dup.x64 sp(0)
	<div+?>: load.z64
	<div+?>: clt.f64
	<div+?>: jz +11
	<div+?>: dup.x64 sp(0)
	<div+?>: neg.f64
	<div+?>: jmp +6
	<div+?>: dup.x64 sp(0)
	<div+?>: set.x64 sp(2)
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(0)
	<div+?>: load.z64
	<div+?>: clt.f64
	<div+?>: jz +11
	<div+?>: dup.x64 sp(0)
	<div+?>: neg.f64
	<div+?>: jmp +6
	<div+?>: dup.x64 sp(0)
	<div+?>: set.x64 sp(2)
	<div+?>: clt.f64
	<div+?>: jnz +52
	cmplStd/lib/math/Complex.ci:91: (5 bytes): r: float64 := b.im / b.re
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(3)
	<div+?>: div.f64
	cmplStd/lib/math/Complex.ci:92: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(9)
	<div+?>: mul.f64
	<div+?>: add.f64
	cmplStd/lib/math/Complex.ci:93: (31 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:94: (13 bytes): .result.re := (a.re + r * a.im) / den;
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(15)
	<div+?>: mul.f64
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:95: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(13)
	<div+?>: mul.f64
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
	<div+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:98: (5 bytes): r: float64 := b.re / b.im
	<div+?>: dup.x64 sp(1)
	<div+?>: dup.x64 sp(5)
	<div+?>: div.f64
	cmplStd/lib/math/Complex.ci:99: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(7)
	<div+?>: mul.f64
	<div+?>: add.f64
	cmplStd/lib/math/Complex.ci:100: (31 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:101: (13 bytes): .result.re := (a.re * r + a.im) / den;
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(13)
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:102: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(11)
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `div`
	cmplStd/lib/math/Complex.ci:173: referenced as `div`
	cmplStd/lib/math/Complex.ci:166: referenced as `div`
	cmplStd/lib/math/Complex.ci:164: referenced as `div`
	cmplStd/lib/math/Complex.ci:109: referenced as `div`
	cmplStd/lib/math/Complex.ci:107: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:107'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: div(a, Complex(b))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `div`
	cmplStd/lib/math/Complex.ci:169: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:109'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: val)
.doc: '@public'
.value: div(Complex(a), b)
.usages:
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:112'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(a.re * a.re + a.im * a.im)
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `abs`
	cmplStd/lib/math/Complex.ci:136: referenced as `abs`
	cmplStd/lib/math/Complex.ci:132: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:114'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: float64.atan2(a.re, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `arg`
	cmplStd/lib/math/Complex.ci:137: referenced as `arg`
	cmplStd/lib/math/Complex.ci:132: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:117'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := a.re * a.re + a.im * a.im;
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (31 bytes)
	cmplStd/lib/math/Complex.ci:118: (11 bytes): d: float64 := a.re * a.re + a.im * a.im
	<inv>  : dup.x64 sp(1)
	<inv+?>: dup.x64 sp(3)
	<inv+?>: mul.f64
	<inv+?>: dup.x64 sp(5)
	<inv+?>: dup.x64 sp(7)
	<inv+?>: mul.f64
	<inv+?>: add.f64
	cmplStd/lib/math/Complex.ci:119: (20 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:120: (7 bytes): .result.re := +a.re / d;
	<inv+?>: dup.x64 sp(3)
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:121: (8 bytes): .result.im := -a.im / d;
	<inv+?>: dup.x64 sp(5)
	<inv+?>: neg.f64
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(11)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `inv`
	cmplStd/lib/math/Complex.ci:182: referenced as `inv`
	cmplStd/lib/math/Complex.ci:180: referenced as `inv`
	cmplStd/lib/math/Complex.ci:178: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(a.re, -a.im)
.usages:
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:132'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.log(abs(a)), arg(a))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 100
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * float64.log(r);
	v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
	return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
}
.instructions: (100 bytes)
	cmplStd/lib/math/Complex.ci:136: (23 bytes): r: float64 := abs(a)
	<pow>  : dup.x128 sp(5)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(4)
	<pow+?>: dup.x64 sp(6)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	<pow+?>: nfc(47) ;float64.sqrt(x: float64): float64
	<pow+?>: set.x64 sp(4)
	<pow+?>: inc.sp(-8)
	cmplStd/lib/math/Complex.ci:137: (16 bytes): t: float64 := arg(a)
	<pow+?>: dup.x128 sp(7)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<pow+?>: set.x64 sp(4)
	<pow+?>: inc.sp(-8)
	cmplStd/lib/math/Complex.ci:138: (15 bytes): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: dup.x64 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(9)
	<pow+?>: dup.x64 sp(6)
	<pow+?>: nfc(44) ;float64.log(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: add.f64
	cmplStd/lib/math/Complex.ci:139: (19 bytes): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: dup.x64 sp(9)
	<pow+?>: nfc(46) ;float64.pow(x: float64, y: float64): float64
	<pow+?>: dup.x64 sp(11)
	<pow+?>: neg.f64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: mul.f64
	<pow+?>: nfc(45) ;float64.exp(x: float64): float64
	<pow+?>: mul.f64
	cmplStd/lib/math/Complex.ci:140: (27 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:141: (11 bytes): .result.re := v * float64.cos(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: nfc(42) ;float64.cos(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:142: (11 bytes): .result.im := v * float64.sin(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: nfc(41) ;float64.sin(x: float64): float64
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(21)
	<pow+?>: inc.sp(-32)
	<pow+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:146'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: '@public'
.value: pow(a, Complex(b))
.usages:
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:149'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:180: referenced as `sin`
	cmplStd/lib/math/Complex.ci:166: referenced as `sin`
	cmplStd/lib/math/Complex.ci:164: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:151'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:178: referenced as `cos`
	cmplStd/lib/math/Complex.ci:166: referenced as `cos`
	cmplStd/lib/math/Complex.ci:164: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:164'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sin(a), cos(a))
.usages:
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:166'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(cos(a), sin(a))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:169'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sub(exp(a), exp(neg(a))), 2)
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:171'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(add(exp(a), exp(neg(a))), 2)
.usages:
	cmplStd/lib/math/Complex.ci:182: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:173'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
.usages:
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:175'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
.usages:
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:178'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:180'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:182'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:184'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:187'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:189'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: '@public'
.value: Complex(abs(x), arg(x))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, cast: variable(val))
.field x: float32 (size: 0, cast: inline)
.field y: float32 (size: 0, cast: inline)
.field z: float32 (size: 0, cast: inline)
.field w: float32 (size: 0, cast: inline)
.field data: float32[4] (size: 16, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplGfx/gfxlib.ci:217: referenced as `vec4f`
	cmplGfx/gfxlib.ci:216: referenced as `vec4f`
	cmplGfx/gfxlib.ci:215: referenced as `vec4f`
	cmplGfx/gfxlib.ci:79: referenced as `vec4f`
	cmplGfx/gfxlib.ci:79: referenced as `vec4f`
	cmplGfx/gfxlib.ci:70: referenced as `vec4f`
	cmplGfx/gfxlib.ci:70: referenced as `vec4f`
	cmplGfx/lib/camera.ci:125: referenced as `vec4f`
	cmplGfx/lib/camera.ci:125: referenced as `vec4f`
	cmplGfx/lib/camera.ci:112: referenced as `vec4f`
	cmplGfx/lib/camera.ci:107: referenced as `vec4f`
	cmplGfx/lib/camera.ci:82: referenced as `vec4f`
	cmplGfx/lib/camera.ci:81: referenced as `vec4f`
	cmplGfx/lib/camera.ci:80: referenced as `vec4f`
	cmplGfx/lib/camera.ci:80: referenced as `vec4f`
	cmplGfx/lib/camera.ci:80: referenced as `vec4f`
	cmplGfx/lib/camera.ci:70: referenced as `vec4f`
	cmplGfx/lib/camera.ci:69: referenced as `vec4f`
	cmplGfx/lib/camera.ci:39: referenced as `vec4f`
	cmplGfx/lib/camera.ci:35: referenced as `vec4f`
	cmplGfx/lib/camera.ci:5: referenced as `vec4f`
	cmplGfx/lib/camera.ci:4: referenced as `vec4f`
	cmplGfx/lib/camera.ci:3: referenced as `vec4f`
	cmplGfx/lib/camera.ci:2: referenced as `vec4f`
	cmplGfx/lib/image.ci:186: referenced as `vec4f`
	cmplGfx/lib/image.ci:168: referenced as `vec4f`
	cmplGfx/lib/image.ci:168: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:61: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:61: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:3: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:3: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:2: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:2: referenced as `vec4f`
	cmplGfx/lib/color.ci:267: referenced as `vec4f`
	cmplGfx/lib/color.ci:264: referenced as `vec4f`
	cmplGfx/lib/color.ci:258: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
	internal usages: 4
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:141'
.owner: vec4f
.field x: float32 (size: 4, cast: variable(f32))
.field y: float32 (size: 4, cast: variable(f32))
.field z: float32 (size: 4, cast: variable(f32))
.field w: float32 (size: 4, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplGfx/gfxlib.ci:217: referenced as `x`
	cmplGfx/gfxlib.ci:216: referenced as `x`
	cmplGfx/gfxlib.ci:215: referenced as `x`
	cmplGfx/lib/camera.ci:72: referenced as `x`
	cmplGfx/lib/camera.ci:60: referenced as `x`
	cmplGfx/lib/camera.ci:56: referenced as `x`
	cmplGfx/lib/camera.ci:45: referenced as `x`
	cmplGfx/lib/camera.ci:44: referenced as `x`
	cmplGfx/lib/camera.ci:41: referenced as `x`
	cmplGfx/lib/camera.ci:41: referenced as `x`
	cmplGfx/lib/image.ci:195: referenced as `x`
	cmplGfx/lib/image.ci:187: referenced as `x`
	cmplGfx/lib/image.ci:74: referenced as `x`
	cmplGfx/lib/image.ci:73: referenced as `x`
	cmplGfx/lib/image.ci:72: referenced as `x`
	cmplGfx/lib/image.ci:71: referenced as `x`
	cmplGfx/lib/color.hsl.ci:99: referenced as `x`
	cmplGfx/lib/color.hsl.ci:101: referenced as `x`
	cmplGfx/lib/color.hsl.ci:100: referenced as `x`
	cmplGfx/lib/color.hsl.ci:99: referenced as `x`
	cmplGfx/lib/color.hsl.ci:54: referenced as `x`
	cmplGfx/lib/color.hsl.ci:36: referenced as `x`
	cmplGfx/lib/color.hsl.ci:31: referenced as `x`
	cmplGfx/lib/color.hsl.ci:17: referenced as `x`
	cmplGfx/lib/color.hsl.ci:8: referenced as `x`
	cmplGfx/lib/color.hsl.ci:7: referenced as `x`
	cmplGfx/lib/color.hsv.ci:3: referenced as `x`
	cmplGfx/lib/color.ci:267: referenced as `x`
	cmplGfx/lib/color.ci:264: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplGfx/gfxlib.ci:217: referenced as `y`
	cmplGfx/gfxlib.ci:216: referenced as `y`
	cmplGfx/gfxlib.ci:215: referenced as `y`
	cmplGfx/lib/camera.ci:73: referenced as `y`
	cmplGfx/lib/camera.ci:59: referenced as `y`
	cmplGfx/lib/camera.ci:51: referenced as `y`
	cmplGfx/lib/camera.ci:46: referenced as `y`
	cmplGfx/lib/camera.ci:44: referenced as `y`
	cmplGfx/lib/camera.ci:42: referenced as `y`
	cmplGfx/lib/camera.ci:42: referenced as `y`
	cmplGfx/lib/image.ci:193: referenced as `y`
	cmplGfx/lib/image.ci:188: referenced as `y`
	cmplGfx/lib/image.ci:74: referenced as `y`
	cmplGfx/lib/image.ci:73: referenced as `y`
	cmplGfx/lib/image.ci:72: referenced as `y`
	cmplGfx/lib/image.ci:71: referenced as `y`
	cmplGfx/lib/color.hsl.ci:100: referenced as `y`
	cmplGfx/lib/color.hsl.ci:94: referenced as `y`
	cmplGfx/lib/color.hsl.ci:94: referenced as `y`
	cmplGfx/lib/color.hsl.ci:91: referenced as `y`
	cmplGfx/lib/color.hsl.ci:85: referenced as `y`
	cmplGfx/lib/color.hsl.ci:55: referenced as `y`
	cmplGfx/lib/color.hsl.ci:39: referenced as `y`
	cmplGfx/lib/color.hsl.ci:32: referenced as `y`
	cmplGfx/lib/color.hsl.ci:18: referenced as `y`
	cmplGfx/lib/color.hsl.ci:8: referenced as `y`
	cmplGfx/lib/color.hsl.ci:7: referenced as `y`
	cmplGfx/lib/color.hsv.ci:4: referenced as `y`
	cmplGfx/lib/color.ci:267: referenced as `y`
	cmplGfx/lib/color.ci:264: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplGfx/gfxlib.ci:217: referenced as `z`
	cmplGfx/gfxlib.ci:216: referenced as `z`
	cmplGfx/gfxlib.ci:215: referenced as `z`
	cmplGfx/lib/camera.ci:74: referenced as `z`
	cmplGfx/lib/camera.ci:54: referenced as `z`
	cmplGfx/lib/camera.ci:50: referenced as `z`
	cmplGfx/lib/camera.ci:46: referenced as `z`
	cmplGfx/lib/camera.ci:45: referenced as `z`
	cmplGfx/lib/camera.ci:43: referenced as `z`
	cmplGfx/lib/camera.ci:43: referenced as `z`
	cmplGfx/lib/image.ci:189: referenced as `z`
	cmplGfx/lib/image.ci:74: referenced as `z`
	cmplGfx/lib/image.ci:73: referenced as `z`
	cmplGfx/lib/image.ci:72: referenced as `z`
	cmplGfx/lib/image.ci:71: referenced as `z`
	cmplGfx/lib/color.hsl.ci:101: referenced as `z`
	cmplGfx/lib/color.hsl.ci:97: referenced as `z`
	cmplGfx/lib/color.hsl.ci:94: referenced as `z`
	cmplGfx/lib/color.hsl.ci:94: referenced as `z`
	cmplGfx/lib/color.hsl.ci:91: referenced as `z`
	cmplGfx/lib/color.hsl.ci:90: referenced as `z`
	cmplGfx/lib/color.hsl.ci:86: referenced as `z`
	cmplGfx/lib/color.hsl.ci:56: referenced as `z`
	cmplGfx/lib/color.hsl.ci:42: referenced as `z`
	cmplGfx/lib/color.hsl.ci:33: referenced as `z`
	cmplGfx/lib/color.hsl.ci:19: referenced as `z`
	cmplGfx/lib/color.hsl.ci:8: referenced as `z`
	cmplGfx/lib/color.hsl.ci:7: referenced as `z`
	cmplGfx/lib/color.hsv.ci:5: referenced as `z`
	cmplGfx/lib/color.ci:267: referenced as `z`
	cmplGfx/lib/color.ci:264: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplGfx/gfxlib.ci:217: referenced as `w`
	cmplGfx/gfxlib.ci:216: referenced as `w`
	cmplGfx/gfxlib.ci:215: referenced as `w`
	cmplGfx/lib/camera.ci:75: referenced as `w`
	cmplGfx/lib/image.ci:190: referenced as `w`
	cmplGfx/lib/image.ci:74: referenced as `w`
	cmplGfx/lib/image.ci:73: referenced as `w`
	cmplGfx/lib/image.ci:72: referenced as `w`
	cmplGfx/lib/image.ci:71: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	cmplGfx/gfxlib.ci:163: referenced as `data`
	cmplGfx/gfxlib.ci:163: referenced as `data`
	cmplGfx/gfxlib.ci:163: referenced as `data`
	cmplGfx/gfxlib.ci:163: referenced as `data`
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(struct(w), struct(z), struct(y), struct(x)))
.usages:
	cmplGfx/lib/camera.ci:97: referenced as `vec4f`
	cmplGfx/lib/camera.ci:75: referenced as `vec4f`
	cmplGfx/lib/camera.ci:74: referenced as `vec4f`
	cmplGfx/lib/camera.ci:73: referenced as `vec4f`
	cmplGfx/lib/camera.ci:72: referenced as `vec4f`
	cmplGfx/lib/camera.ci:64: referenced as `vec4f`
	cmplGfx/lib/camera.ci:30: referenced as `vec4f`
	cmplGfx/lib/camera.ci:29: referenced as `vec4f`
	cmplGfx/lib/camera.ci:28: referenced as `vec4f`
	cmplGfx/lib/camera.ci:27: referenced as `vec4f`
	cmplGfx/lib/camera.ci:18: referenced as `vec4f`
	cmplGfx/lib/camera.ci:17: referenced as `vec4f`
	cmplGfx/lib/camera.ci:16: referenced as `vec4f`
	cmplGfx/lib/camera.ci:15: referenced as `vec4f`
	cmplGfx/lib/camera.ci:5: referenced as `vec4f`
	cmplGfx/lib/camera.ci:4: referenced as `vec4f`
	cmplGfx/lib/camera.ci:3: referenced as `vec4f`
	cmplGfx/lib/camera.ci:2: referenced as `vec4f`
	cmplGfx/lib/color.ci:261: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(x, y, z, 1.000000)
.usages:
	cmplGfx/gfxlib.ci:286: referenced as `vec4f`
	cmplGfx/gfxlib.ci:286: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:36: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:34: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:31: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:28: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:25: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:22: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(x, y, 0.000000, 1.000000)
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, cast: val)
.param xyz: vec4f (size: 16, cast: variable(val))
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(xyz.x, xyz.y, xyz.z, w)
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, cast: val)
.param val: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(val, val, val, val)
.usages:
	cmplGfx/gfxlib.ci:286: referenced as `vec4f`
	cmplGfx/gfxlib.ci:235: referenced as `vec4f`
	cmplGfx/gfxlib.ci:234: referenced as `vec4f`
	cmplGfx/lib/camera.ci:70: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:86: referenced as `vec4f`
	cmplGfx/lib/color.hsv.ci:8: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(struct(rhs), neg.p4f))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), add.p4f))
.usages:
	cmplGfx/lib/camera.ci:108: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), sub.p4f))
.usages:
	cmplGfx/lib/camera.ci:133: referenced as `sub`
	cmplGfx/lib/camera.ci:81: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), mul.p4f))
.usages:
	cmplGfx/lib/camera.ci:70: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), div.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:128: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(vec4f(a), b)
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(a, vec4f(b))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(vec4f(a), b)
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(a, vec4f(b))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(vec4f(a), b)
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(a, vec4f(b))
.usages:
	cmplGfx/lib/camera.ci:108: referenced as `mul`
	cmplGfx/lib/camera.ci:39: referenced as `mul`
}
div(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(vec4f(a), b)
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(a, vec4f(b))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), min.p4f))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:102'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), max.p4f))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, cast: val)
.param vec: vec4f (size: 16, cast: val)
.param min: vec4f (size: 16, cast: val)
.param max: vec4f (size: 16, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(max(vec, min), max)
.usages:
	cmplStd/lib/math/Vector4f.ci:108: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, cast: val)
.param vec: vec4f (size: 16, cast: val)
.param min: float32 (size: 4, cast: f32)
.param max: float32 (size: 4, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(vec, vec4f(min), vec4f(max))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:112'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp3))
.usages:
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:116'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dph))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:120'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp4))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 4, cast: const variable(ref))
.param b: vec4f (size: 4, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
.usages:
	cmplGfx/lib/camera.ci:121: referenced as `cross`
	cmplGfx/lib/camera.ci:87: referenced as `cross`
	cmplGfx/lib/camera.ci:82: referenced as `cross`
}
length(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:126'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 16, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(v, v))
.usages:
	cmplGfx/lib/camera.ci:133: referenced as `length`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:128'
.param .result: vec4f (size: 16, cast: val)
.param v: vec4f (size: 4, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(v, vec4f(length(v)))
.usages:
	cmplGfx/lib/camera.ci:120: referenced as `normalize`
	cmplGfx/lib/camera.ci:119: referenced as `normalize`
	cmplGfx/lib/camera.ci:82: referenced as `normalize`
	cmplGfx/lib/camera.ci:81: referenced as `normalize`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 4, cast: const variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32((((v.w * x + v.z) * x + v.y) * x) + v.x)
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, cast: variable(val))
.field data: float32[16] (size: 64, cast: variable(val))
.field v: vec4f[4] (size: 64, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field x: vec4f (size: 0, cast: inline)
.field y: vec4f (size: 0, cast: inline)
.field z: vec4f (size: 0, cast: inline)
.field w: vec4f (size: 0, cast: inline)
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field xx: float32 (size: 0, cast: inline)
.field xy: float32 (size: 0, cast: inline)
.field xz: float32 (size: 0, cast: inline)
.field xw: float32 (size: 0, cast: inline)
.field yx: float32 (size: 0, cast: inline)
.field yy: float32 (size: 0, cast: inline)
.field yz: float32 (size: 0, cast: inline)
.field yw: float32 (size: 0, cast: inline)
.field zx: float32 (size: 0, cast: inline)
.field zy: float32 (size: 0, cast: inline)
.field zz: float32 (size: 0, cast: inline)
.field zw: float32 (size: 0, cast: inline)
.field wx: float32 (size: 0, cast: inline)
.field wy: float32 (size: 0, cast: inline)
.field wz: float32 (size: 0, cast: inline)
.field ww: float32 (size: 0, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplGfx/gfxlib.ci:157: referenced as `mat4f`
	cmplGfx/lib/camera.ci:134: referenced as `mat4f`
	cmplGfx/lib/camera.ci:118: referenced as `mat4f`
	cmplGfx/lib/camera.ci:102: referenced as `mat4f`
	cmplGfx/lib/camera.ci:102: referenced as `mat4f`
	cmplGfx/lib/camera.ci:92: referenced as `mat4f`
	cmplGfx/lib/camera.ci:69: referenced as `mat4f`
	cmplGfx/lib/camera.ci:35: referenced as `mat4f`
	cmplGfx/lib/camera.ci:8: referenced as `mat4f`
	cmplGfx/lib/image.ci:70: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	cmplGfx/gfxlib.ci:163: referenced as `data`
	cmplGfx/lib/image.ci:77: referenced as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field x: vec4f (size: 16, cast: variable(val))
.field y: vec4f (size: 16, cast: variable(val))
.field z: vec4f (size: 16, cast: variable(val))
.field w: vec4f (size: 16, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:94: referenced as `x`
	cmplGfx/lib/camera.ci:72: referenced as `x`
	cmplGfx/lib/camera.ci:27: referenced as `x`
	cmplGfx/lib/camera.ci:15: referenced as `x`
	cmplGfx/lib/image.ci:71: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:95: referenced as `y`
	cmplGfx/lib/camera.ci:73: referenced as `y`
	cmplGfx/lib/camera.ci:28: referenced as `y`
	cmplGfx/lib/camera.ci:16: referenced as `y`
	cmplGfx/lib/image.ci:72: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:96: referenced as `z`
	cmplGfx/lib/camera.ci:74: referenced as `z`
	cmplGfx/lib/camera.ci:29: referenced as `z`
	cmplGfx/lib/camera.ci:17: referenced as `z`
	cmplGfx/lib/image.ci:73: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:97: referenced as `w`
	cmplGfx/lib/camera.ci:75: referenced as `w`
	cmplGfx/lib/camera.ci:64: referenced as `w`
	cmplGfx/lib/camera.ci:30: referenced as `w`
	cmplGfx/lib/camera.ci:18: referenced as `w`
	cmplGfx/lib/image.ci:74: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field xx: float32 (size: 4, cast: variable(f32))
.field xy: float32 (size: 4, cast: variable(f32))
.field xz: float32 (size: 4, cast: variable(f32))
.field xw: float32 (size: 4, cast: variable(f32))
.field yx: float32 (size: 4, cast: variable(f32))
.field yy: float32 (size: 4, cast: variable(f32))
.field yz: float32 (size: 4, cast: variable(f32))
.field yw: float32 (size: 4, cast: variable(f32))
.field zx: float32 (size: 4, cast: variable(f32))
.field zy: float32 (size: 4, cast: variable(f32))
.field zz: float32 (size: 4, cast: variable(f32))
.field zw: float32 (size: 4, cast: variable(f32))
.field wx: float32 (size: 4, cast: variable(f32))
.field wy: float32 (size: 4, cast: variable(f32))
.field wz: float32 (size: 4, cast: variable(f32))
.field ww: float32 (size: 4, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:49: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:50: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:51: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:142: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:52: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:54: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:55: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:56: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:147: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:57: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:59: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:60: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:61: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:152: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplGfx/lib/camera.ci:62: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, cast: variable(val))
.param xx: float32 (size: 4, cast: variable(f32))
.param xy: float32 (size: 4, cast: variable(f32))
.param xz: float32 (size: 4, cast: variable(f32))
.param xw: float32 (size: 4, cast: variable(f32))
.param yx: float32 (size: 4, cast: variable(f32))
.param yy: float32 (size: 4, cast: variable(f32))
.param yz: float32 (size: 4, cast: variable(f32))
.param yw: float32 (size: 4, cast: variable(f32))
.param zx: float32 (size: 4, cast: variable(f32))
.param zy: float32 (size: 4, cast: variable(f32))
.param zz: float32 (size: 4, cast: variable(f32))
.param zw: float32 (size: 4, cast: variable(f32))
.param wx: float32 (size: 4, cast: variable(f32))
.param wy: float32 (size: 4, cast: variable(f32))
.param wz: float32 (size: 4, cast: variable(f32))
.param ww: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return .result := {
			.result.xx := xx;
			.result.xy := xy;
			.result.xz := xz;
			.result.xw := xw;
			.result.yx := yx;
			.result.yy := yy;
			.result.yz := yz;
			.result.yw := yw;
			.result.zx := zx;
			.result.zy := zy;
			.result.zz := zz;
			.result.zw := zw;
			.result.wx := wx;
			.result.wy := wy;
			.result.wz := wz;
			.result.ww := ww;
		};
}
.instructions: (49 bytes)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xx := xx;
	<mat4f>  : mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xy := xy;
	<mat4f+?>: mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xz := xz;
	<mat4f+?>: mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xw := xw;
	<mat4f+?>: mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yx := yx;
	<mat4f+?>: mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yy := yy;
	<mat4f+?>: mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yz := yz;
	<mat4f+?>: mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yw := yw;
	<mat4f+?>: mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zx := zx;
	<mat4f+?>: mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zy := zy;
	<mat4f+?>: mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zz := zz;
	<mat4f+?>: mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zw := zw;
	<mat4f+?>: mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wx := wx;
	<mat4f+?>: mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wy := wy;
	<mat4f+?>: mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wz := wz;
	<mat4f+?>: mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.ww := ww;
	<mat4f+?>: mov.x32 sp(32, 1)
	<mat4f+?>: ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, cast: variable(val))
.param x: vec4f (size: 4, cast: const variable(ref))
.param y: vec4f (size: 4, cast: const variable(ref))
.param z: vec4f (size: 4, cast: const variable(ref))
.param w: vec4f (size: 4, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (21 bytes)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.x := x;
	<mat4f>  : dup.x32 sp(4)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.y := y;
	<mat4f+?>: dup.x32 sp(3)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.z := z;
	<mat4f+?>: dup.x32 sp(2)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.w := w;
	<mat4f+?>: dup.x32 sp(1)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(21)
	<mat4f+?>: ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000)
.usages:
	cmplGfx/lib/camera.ci:120: referenced as `dp3`
	cmplGfx/lib/camera.ci:119: referenced as `dp3`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
.usages:
	cmplGfx/lib/camera.ci:135: referenced as `dph`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, cast: variable(val))
.param mat: mat4f (size: 64, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return .result := {
			.result.xx := mat.xx;
			.result.xy := mat.yx;
			.result.xz := mat.zx;
			.result.xw := mat.wx;
			.result.yx := mat.xy;
			.result.yy := mat.yy;
			.result.yz := mat.zy;
			.result.yw := mat.wy;
			.result.zx := mat.xz;
			.result.zy := mat.yz;
			.result.zz := mat.zz;
			.result.zw := mat.wz;
			.result.wx := mat.xw;
			.result.wy := mat.yw;
			.result.wz := mat.zw;
			.result.ww := mat.ww;
		};
}
.instructions: (49 bytes)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xx := mat.xx;
	<transpose>  : mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xy := mat.yx;
	<transpose+?>: mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xz := mat.zx;
	<transpose+?>: mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xw := mat.wx;
	<transpose+?>: mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yx := mat.xy;
	<transpose+?>: mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yy := mat.yy;
	<transpose+?>: mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yz := mat.zy;
	<transpose+?>: mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yw := mat.wy;
	<transpose+?>: mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zx := mat.xz;
	<transpose+?>: mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zy := mat.yz;
	<transpose+?>: mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zz := mat.zz;
	<transpose+?>: mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zw := mat.wz;
	<transpose+?>: mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wx := mat.xw;
	<transpose+?>: mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wy := mat.yw;
	<transpose+?>: mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wz := mat.zw;
	<transpose+?>: mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.ww := mat.ww;
	<transpose+?>: mov.x32 sp(32, 16)
	<transpose+?>: ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 245
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, cast: variable(val))
.param lhs: mat4f (size: 4, cast: const variable(ref))
.param rhs: mat4f (size: 4, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (245 bytes)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes): transposed: mat4f := transpose(rhs)
	<mul>  : inc.sp(+64)
	<mul+?>: dup.x32 sp(17)
	<mul+?>: load.sp(-60)
	<mul+?>: copy.mem -64
	<mul+?>: inc.sp(+64)
	<mul+?>: load.ref <?> ;transpose(mat: mat4f): mat4f
	<mul+?>: call
	<mul+?>: inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (217 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (50 bytes): .result.x := dp4(transposed, lhs.x);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (54 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+16)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (54 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+32)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (54 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+48)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: set.x128 sp(2)
	<mul+?>: set.x128 sp(35)
	<mul+?>: inc.sp(-64)
	<mul+?>: ret
.usages:
	cmplGfx/lib/camera.ci:103: referenced as `mul`
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 454
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, cast: variable(val))
.param center: vec4f (size: 4, cast: const variable(ref))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if ((len) < 0.000000) {
		trace("invalid direction of rotation", direction);
		return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
	}
	x: float32 := direction.x / len;
	y: float32 := direction.y / len;
	z: float32 := direction.z / len;
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := x * x;
	xy: float32 := x * y;
	xz: float32 := x * z;
	yy: float32 := y * y;
	yz: float32 := y * z;
	zz: float32 := z * z;
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := (1) - c;
	return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (454 bytes)
	cmplStd/lib/math/Matrix4f.ci:112: (18 bytes): len: float32 := length(direction)
	<rotation>  : dup.x32 sp(2)
	<rotation+?>: load.i128
	<rotation+?>: dup.x128 sp(0)
	<rotation+?>: dup.x128 sp(4)
	<rotation+?>: dp3.v4f
	<rotation+?>: nfc(39) ;float32.sqrt(x: float32): float32
	<rotation+?>: set.x32 sp(4)
	<rotation+?>: inc.sp(-12)
	cmplStd/lib/math/Matrix4f.ci:113: (82 bytes): if ((len) < 0.000000)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: f32.2f64
	<rotation+?>: load.f64 0.000000
	<rotation+?>: clt.f64
	<rotation+?>: jz +69
	cmplStd/lib/math/Matrix4f.ci:114: (36 bytes): trace("invalid direction of rotation", direction);
	<rotation+?>: load.ref <?> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+?>: load.c32 114
	<rotation+?>: load.c32 14
	<rotation+?>: load.c32 128
	<rotation+?>: load.ref <?> ;"invalid direction of rotation"
	<rotation+?>: load.ref <?> ;vec4f
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/math/Matrix4f.ci:115: (29 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes): .result.x := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes): .result.y := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:118: (6 bytes): .result.z := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:119: (6 bytes): .result.w := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(21)
	<rotation+?>: inc.sp(-4)
	<rotation+?>: ret
	cmplStd/lib/math/Matrix4f.ci:122: (6 bytes): x: float32 := direction.x / len
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (10 bytes): y: float32 := direction.y / len
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:124: (10 bytes): z: float32 := direction.z / len
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:125: (3 bytes): cx: float32 := center.x
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (7 bytes): cy: float32 := center.y
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:127: (7 bytes): cz: float32 := center.z
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes): xx: float32 := x * x
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes): xy: float32 := x * y
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes): xz: float32 := x * z
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes): yy: float32 := y * y
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:132: (5 bytes): yz: float32 := y * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (5 bytes): zz: float32 := z * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:135: (6 bytes): s: float32 := float32.sin(angle)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: nfc(33) ;float32.sin(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:136: (6 bytes): c: float32 := float32.cos(angle)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: nfc(34) ;float32.cos(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:137: (8 bytes): k: float32 := (1) - c
	<rotation+?>: load.f32 1.000000
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:139: (261 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes): .result.xx := xx + (yy + zz) * c;
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:141: (13 bytes): .result.xy := xy * k - z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:142: (13 bytes): .result.xz := xz * k + y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:143: (43 bytes): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes): .result.yx := xy * k + z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:146: (13 bytes): .result.yy := yy + (xx + zz) * c;
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:147: (13 bytes): .result.yz := yz * k - x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:148: (43 bytes): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes): .result.zx := xz * k - y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:151: (13 bytes): .result.zy := yz * k + x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:152: (13 bytes): .result.zz := zz + (xx + yy) * c;
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:153: (43 bytes): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:155: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(36)
	<rotation+?>: inc.sp(-64)
	<rotation+?>: ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `rotation`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, cast: val)
.param direction: vec4f (size: 4, cast: const ref)
.param angle: float32 (size: 4, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(vec4f(0), direction, angle)
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:163'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return .result := {
			.result.xx := (1);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := direction.x * amount;
			.result.yx := (0);
			.result.yy := (1);
			.result.yz := (0);
			.result.yw := direction.y * amount;
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := (1);
			.result.zw := direction.z * amount;
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
}
.instructions: (88 bytes)
	cmplStd/lib/math/Matrix4f.ci:164: (88 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:165: (7 bytes): .result.xx := (1);
	<translation>  : load.f32 1.000000
	<translation+?>: set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes): .result.xy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes): .result.xz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:165: (8 bytes): .result.xw := direction.x * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes): .result.yx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:166: (7 bytes): .result.yy := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes): .result.yz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:166: (12 bytes): .result.yw := direction.y * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+4)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes): .result.zx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes): .result.zy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:167: (7 bytes): .result.zz := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:167: (12 bytes): .result.zw := direction.z * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+8)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes): .result.wx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes): .result.wy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes): .result.wz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:168: (7 bytes): .result.ww := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(19)
	<translation+?>: ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:173'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
	return .result := {
			.result.xx := rcp(direction.x * amount);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := (0);
			.result.yx := (0);
			.result.yy := rcp(direction.y * amount);
			.result.yz := (0);
			.result.yw := (0);
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := rcp(direction.z * amount);
			.result.zw := (0);
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
}
.instructions: (217 bytes)
	cmplStd/lib/math/Matrix4f.ci:175: (217 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:176: (55 bytes): .result.xx := rcp(direction.x * amount);
	<scale>  : dup.x32 sp(2)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes): .result.xy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes): .result.xz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes): .result.xw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes): .result.yx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:177: (59 bytes): .result.yy := rcp(direction.y * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+4)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes): .result.yz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes): .result.yw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes): .result.zx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes): .result.zy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:178: (59 bytes): .result.zz := rcp(direction.z * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+8)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes): .result.zw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes): .result.wx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes): .result.wy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes): .result.wz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:179: (7 bytes): .result.ww := (1);
	<scale+?>: load.f32 1.000000
	<scale+?>: set.x32 sp(19)
	<scale+?>: ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, cast: variable(val))
.field x: float64 (size: 0, cast: inline)
.field y: float64 (size: 0, cast: inline)
.field data: float64[2] (size: 16, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, cast: variable(f64))
.field y: float64 (size: 8, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, cast: variable(val))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes): .result.x := x;
	<vec2d>  : mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes): .result.y := y;
	<vec2d+?>: mov.x64 sp(7, 1)
	<vec2d+?>: ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(struct(a), struct(b), add.p2d))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(struct(a), struct(b), sub.p2d))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(struct(a), struct(b), mul.p2d))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(struct(a), struct(b), div.p2d))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(struct(a), struct(b), min.p2d))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(struct(a), struct(b), max.p2d))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(struct(a), struct(b), ceq.p2d))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, cast: f64)
.param a: vec2d (size: 4, cast: const variable(ref))
.param b: vec2d (size: 4, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: a.x * b.x + a.y * b.y
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.name: 'length'
.file: 'cmplStd/lib/string.ci:4'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (38 bytes)
	cmplStd/lib/string.ci:5: (16 bytes): if ((str) == null)
	<length>  : dup.x32 sp(1)
	<length+?>: load.ref <?> ;null
	<length+?>: ceq.i32
	<length+?>: jz +8
	cmplStd/lib/string.ci:6: (4 bytes): return .result := 0;
	<length+?>: load.z32
	<length+?>: set.x32 sp(3)
	<length+?>: ret
	cmplStd/lib/string.ci:8: (1 byte): result: int32 := 0
	<length+?>: load.z32
	cmplStd/lib/string.ci:9: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>: jmp +8
	cmplStd/lib/string.ci:9: (4 bytes): result := result + 1
	<length+?>: inc.i32(+1)
	cmplStd/lib/string.ci:9: (10 bytes): str[result]
	<length+?>: dup.x32 sp(2)
	<length+?>: dup.x32 sp(1)
	<length+?>: add.i32
	<length+?>: load.i8
	<length+?>: jnz -10
	cmplStd/lib/string.ci:11: (3 bytes): return .result := result;
	<length+?>: set.x32 sp(3)
	<length+?>: ret
.usages:
	cmplStd/lib/string.ci:48: referenced as `length`
	cmplStd/lib/string.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.name: 'indexOf'
.file: 'cmplStd/lib/string.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (50 bytes)
	cmplStd/lib/string.ci:16: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf>  : load.z32
	<indexOf+?>: jmp +27
	cmplStd/lib/string.ci:17: (19 bytes): if (str[i] == chr)
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: load.sp(+12)
	<indexOf+?>: load.i8
	<indexOf+?>: ceq.i32
	<indexOf+?>: jz +7
	cmplStd/lib/string.ci:18: (3 bytes): return .result := i;
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
	cmplStd/lib/string.ci:16: (4 bytes): i := i + 1
	<indexOf+?>: inc.i32(+1)
	cmplStd/lib/string.ci:16: (10 bytes): str[i]
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.i8
	<indexOf+?>: jnz -29
	<indexOf+?>: inc.sp(-4)
	cmplStd/lib/string.ci:21: (8 bytes): return .result := -1;
	<indexOf+?>: load.c32 -1
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
.usages:
	cmplStd/lib/string.ci:105: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.name: 'lastIndexOf'
.file: 'cmplStd/lib/string.ci:25'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (50 bytes)
	cmplStd/lib/string.ci:26: (5 bytes): result: int32 := -1
	<lastIndexOf>  : load.c32 -1
	cmplStd/lib/string.ci:27: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>: load.z32
	<lastIndexOf+?>: jmp +27
	cmplStd/lib/string.ci:28: (19 bytes): if (str[i] == chr)
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: load.sp(+16)
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: ceq.i32
	<lastIndexOf+?>: jz +7
	cmplStd/lib/string.ci:29: (3 bytes): result := i;
	<lastIndexOf+?>: mov.x32 sp(1, 0)
	cmplStd/lib/string.ci:27: (4 bytes): i := i + 1
	<lastIndexOf+?>: inc.i32(+1)
	cmplStd/lib/string.ci:27: (10 bytes): str[i]
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.i8
	<lastIndexOf+?>: jnz -29
	<lastIndexOf+?>: inc.sp(-4)
	cmplStd/lib/string.ci:32: (3 bytes): return .result := result;
	<lastIndexOf+?>: set.x32 sp(4)
	<lastIndexOf+?>: ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:36'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	cmplStd/lib/string.ci:37: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith>  : load.z32
	<startsWith+?>: jmp +45
	cmplStd/lib/string.ci:38: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>: load.z32
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(2)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: call
	<startsWith+?>: inc.sp(-8)
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jnz +15
	cmplStd/lib/string.ci:39: (11 bytes): return .result := false;
	<startsWith+?>: load.z32
	<startsWith+?>: load.sp(+24)
	<startsWith+?>: store.i8
	<startsWith+?>: inc.sp(-4)
	<startsWith+?>: ret
	cmplStd/lib/string.ci:37: (4 bytes): i := i + 1
	<startsWith+?>: inc.i32(+1)
	cmplStd/lib/string.ci:37: (12 bytes): (with[i]) != 0
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: dup.x32 sp(1)
	<startsWith+?>: add.i32
	<startsWith+?>: load.i8
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jz -49
	<startsWith+?>: inc.sp(-4)
	cmplStd/lib/string.ci:42: (11 bytes): return .result := true;
	<startsWith+?>: load.c32 1
	<startsWith+?>: load.sp(+20)
	<startsWith+?>: store.i8
	<startsWith+?>: ret
.usages:
	cmplStd/lib/string.ci:96: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:46'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (126 bytes)
	cmplStd/lib/string.ci:47: (13 bytes): withLen: int32 := length(with)
	<endsWith>  : load.z32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/string.ci:48: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/string.ci:49: (20 bytes): if (strLen < withLen)
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(2)
	<endsWith+?>: clt.i32
	<endsWith+?>: jz +15
	cmplStd/lib/string.ci:50: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
	cmplStd/lib/string.ci:52: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>: load.z32
	<endsWith+?>: jmp +51
	cmplStd/lib/string.ci:53: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: sub.i32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: load.i8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: load.z32
	<endsWith+?>: ceq.i32
	<endsWith+?>: jnz +15
	cmplStd/lib/string.ci:54: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+32)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-12)
	<endsWith+?>: ret
	cmplStd/lib/string.ci:52: (4 bytes): i := i + 1
	<endsWith+?>: inc.i32(+1)
	cmplStd/lib/string.ci:52: (9 bytes): i < withLen
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: clt.i32
	<endsWith+?>: jnz -52
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/string.ci:57: (15 bytes): return .result := true;
	<endsWith+?>: load.c32 1
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
.usages:
	cmplGfx/lib/mesh.ci:6: referenced as `endsWith`
	cmplGfx/lib/mesh.ci:3: referenced as `endsWith`
	cmplGfx/lib/image.ci:84: referenced as `endsWith`
	cmplStd/lib/string.ci:98: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.name: 'compare'
.file: 'cmplStd/lib/string.ci:61'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if the two strings are equal, less or greater, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (63 bytes)
	cmplStd/lib/string.ci:62: (1 byte): result: int32 := 0
	<compare>  : load.z32
	cmplStd/lib/string.ci:63: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>: load.z32
	<compare+?>: jmp +46
	cmplStd/lib/string.ci:64: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>: load.z32
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(2)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(3)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: call
	<compare+?>: inc.sp(-8)
	<compare+?>: set.x32 sp(2)
	cmplStd/lib/string.ci:65: (16 bytes): if ((str[i]) == 0)
	<compare+?>: dup.x32 sp(5)
	<compare+?>: dup.x32 sp(1)
	<compare+?>: add.i32
	<compare+?>: load.i8
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jz +8
	cmplStd/lib/string.ci:66: (4 bytes): break;
	<compare+?>: jmp +16
	cmplStd/lib/string.ci:63: (4 bytes): i := i + 1
	<compare+?>: inc.i32(+1)
	cmplStd/lib/string.ci:63: (8 bytes): result == 0
	<compare+?>: dup.x32 sp(1)
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jnz -46
	<compare+?>: inc.sp(-4)
	cmplStd/lib/string.ci:69: (3 bytes): return .result := result;
	<compare+?>: set.x32 sp(5)
	<compare+?>: ret
.usages:
	cmplStd/lib/string.ci:102: referenced as `compare`
	cmplStd/lib/string.ci:100: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/string.ci:73'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (chr < 'A') {
			return .result := chr;
		}
		if (chr > 'Z') {
			return .result := chr;
		}
		return .result := chr - 'A' + 'a';
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	cmplStd/lib/string.ci:84: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp>  : load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.i8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: sub.i32
	<ignCaseCmp+?>: set.x32 sp(4)
	<ignCaseCmp+?>: ret
.usages:
	cmplGfx/lib/mesh.ci:6: referenced as `ignCaseCmp`
	cmplGfx/lib/mesh.ci:3: referenced as `ignCaseCmp`
	cmplGfx/lib/image.ci:84: referenced as `ignCaseCmp`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'cmplStd/lib/string.ci:88'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	cmplStd/lib/string.ci:89: (14 bytes): return .result := chr - with;
	<caseCmp>  : load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: load.sp(+8)
	<caseCmp+?>: load.i8
	<caseCmp+?>: sub.i32
	<caseCmp+?>: set.x32 sp(4)
	<caseCmp+?>: ret
.usages:
	cmplStd/lib/string.ci:102: referenced as `caseCmp`
	cmplStd/lib/string.ci:100: referenced as `caseCmp`
	cmplStd/lib/string.ci:98: referenced as `caseCmp`
	cmplStd/lib/string.ci:96: referenced as `caseCmp`
}
toHex(value: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toHex'
.file: 'cmplStd/lib/string.ci:93'
.param .result: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.doc: 'convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character'
.value: int32("0123456789abcdef"[value & 15])
.usages:
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:96'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if a string begins with a specified string, using case-sensitive comparison'
.value: startsWith(str, with, caseCmp)
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:98'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if a string ends in a specified string, using case-sensitive comparison'
.value: endsWith(str, with, caseCmp)
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'cmplStd/lib/string.ci:100'
.param .result: int32 (size: 4, cast: i32)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if the two strings are equal, less or greater, using case-sensitive comparison'
.value: compare(str, with, caseCmp)
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'equals'
.file: 'cmplStd/lib/string.ci:102'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if the two strings are equal, using case-sensitive comparison'
.value: compare(str, with, caseCmp) == 0
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'cmplStd/lib/string.ci:105'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param chr: char (size: 4, cast: i32)
.doc: 'Check if a string contains the given character'
.value: indexOf(str, chr) >= 0
.usages:
	cmplStd/lib/string.ci:189: referenced as `contains`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'cmplStd/lib/string.ci:119'
.field showSign: bool (size: 1, cast: const variable(bool))
.field precision: int32 (size: 4, cast: const variable(i32))
.field padChr: char (size: 1, cast: const variable(i32))
.field padLen: int32 (size: 4, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	cmplStd/lib/string.ci:270: referenced as `FormatFlags`
	cmplStd/lib/string.ci:266: referenced as `FormatFlags`
	cmplStd/lib/string.ci:248: referenced as `FormatFlags`
	cmplStd/lib/string.ci:242: referenced as `FormatFlags`
	cmplStd/lib/string.ci:241: referenced as `FormatFlags`
	cmplStd/lib/string.ci:238: referenced as `FormatFlags`
	cmplStd/lib/string.ci:236: referenced as `FormatFlags`
	cmplStd/lib/string.ci:234: referenced as `FormatFlags`
	cmplStd/lib/string.ci:232: referenced as `FormatFlags`
	cmplStd/lib/string.ci:230: referenced as `FormatFlags`
	cmplStd/lib/string.ci:228: referenced as `FormatFlags`
	cmplStd/lib/string.ci:226: referenced as `FormatFlags`
	cmplStd/lib/string.ci:224: referenced as `FormatFlags`
	cmplStd/lib/string.ci:151: referenced as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'showSign'
.file: 'cmplStd/lib/string.ci:121'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	cmplStd/lib/string.ci:249: referenced as `showSign`
	cmplStd/lib/string.ci:243: referenced as `showSign`
	cmplStd/lib/string.ci:243: referenced as `showSign`
	cmplStd/lib/string.ci:158: referenced as `showSign`
	internal usages: 1
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'cmplStd/lib/string.ci:124'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	cmplStd/lib/string.ci:260: referenced as `precision`
	cmplStd/lib/string.ci:250: referenced as `precision`
	cmplStd/lib/string.ci:252: referenced as `precision`
	cmplStd/lib/string.ci:244: referenced as `precision`
	cmplStd/lib/string.ci:246: referenced as `precision`
	cmplStd/lib/string.ci:164: referenced as `precision`
	internal usages: 1
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'cmplStd/lib/string.ci:127'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	cmplStd/lib/string.ci:251: referenced as `padChr`
	cmplStd/lib/string.ci:245: referenced as `padChr`
	cmplStd/lib/string.ci:245: referenced as `padChr`
	cmplStd/lib/string.ci:181: referenced as `padChr`
	internal usages: 1
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padLen'
.file: 'cmplStd/lib/string.ci:130'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/string.ci:252: referenced as `padLen`
	cmplStd/lib/string.ci:246: referenced as `padLen`
	cmplStd/lib/string.ci:246: referenced as `padLen`
	cmplStd/lib/string.ci:179: referenced as `padLen`
	internal usages: 1
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 84
.name: 'append'
.file: 'cmplStd/lib/string.ci:134'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: char[*] (size: 4, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (84 bytes)
	cmplStd/lib/string.ci:135: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append>  : load.z32
	<append+?>: jmp +41
	cmplStd/lib/string.ci:136: (13 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(3)
	<append+?>: dup.x32 sp(6)
	<append+?>: clt.i32
	<append+?>: jnz +8
	cmplStd/lib/string.ci:137: (4 bytes): break;
	<append+?>: jmp +38
	cmplStd/lib/string.ci:139: (12 bytes): output[pos] := value[i];
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x32 sp(5)
	<append+?>: dup.x32 sp(5)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:140: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(3)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(4)
	cmplStd/lib/string.ci:135: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	cmplStd/lib/string.ci:135: (10 bytes): value[i]
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: jnz -43
	<append+?>: inc.sp(-4)
	cmplStd/lib/string.ci:143: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/string.ci:144: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(4)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(3)
	cmplStd/lib/string.ci:146: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(4)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:147: (4 bytes): return .result := pos;
	<append+?>: mov.x32 sp(5, 2)
	<append+?>: ret
.usages:
	cmplGfx/gfxlib.ci:268: referenced as `append`
	cmplGfx/gfxlib.ci:266: referenced as `append`
	cmplGfx/gfxlib.ci:264: referenced as `append`
	cmplGfx/gfxlib.ci:262: referenced as `append`
	cmplGfx/gfxlib.ci:117: referenced as `append`
	cmplGfx/gfxlib.ci:98: referenced as `append`
	cmplStd/lib/string.ci:259: referenced as `append`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 707
.name: 'append'
.file: 'cmplStd/lib/string.ci:151'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param sign: char (size: 4, cast: variable(i32))
.param value: uint64 (size: 8, cast: variable(u64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	if (format.showSign) {
		if ((sign) == 0) {
			sign := '+';
		}
	}
	radix: int32 := format.precision;
	if (radix == 0) {
		radix := 10;
	}
	assert(radix > 1, "radix is too small", radix);
	assert(radix < (radixDigits.length), "radix is too big", radix);
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.padLen - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if ((sign) != 0) {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (707 bytes)
	cmplStd/lib/string.ci:155: (1 byte): len: int32 := 0
	<append>  : load.z32
	cmplStd/lib/string.ci:156: (4 bytes): digits: char[80] := {...}
	<append+?>: inc.sp(+80)
	cmplStd/lib/string.ci:158: (28 bytes): if (format.showSign)
	<append+?>: dup.x32 sp(22)
	<append+?>: load.i8
	<append+?>: jz +25
	cmplStd/lib/string.ci:159: (21 bytes): if ((sign) == 0)
	<append+?>: load.sp(+100)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	cmplStd/lib/string.ci:160: (10 bytes): sign := '+';
	<append+?>: load.c32 43
	<append+?>: load.sp(+104)
	<append+?>: store.i8
	cmplStd/lib/string.ci:164: (7 bytes): radix: int32 := format.precision
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	cmplStd/lib/string.ci:165: (15 bytes): if (radix == 0)
	<append+?>: dup.x32 sp(0)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +11
	cmplStd/lib/string.ci:166: (7 bytes): radix := 10;
	<append+?>: load.c32 10
	<append+?>: set.x32 sp(1)
	cmplStd/lib/string.ci:168: (54 bytes): assert(radix > 1, "radix is too small", radix);
	<append+?>: dup.x32 sp(0)
	<append+?>: load.c32 1
	<append+?>: cgt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"cmplStd/lib/string.ci"
	<append+?>: load.c32 168
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too small"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:169: (53 bytes): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+?>: dup.x32 sp(0)
	<append+?>: load.m32 <?> ;append.radixDigits+4
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +42
	<append+?>: load.ref <?> ;"cmplStd/lib/string.ci"
	<append+?>: load.c32 169
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too big"
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+24)
	<append+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:172: (49 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>: jmp +41
	cmplStd/lib/string.ci:173: (29 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>: load.m32 <?> ;append.radixDigits
	<append+?>: dup.x64 sp(25)
	<append+?>: dup.x32 sp(3)
	<append+?>: i32.2i64
	<append+?>: mod.u64
	<append+?>: i64.2i32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: load.sp(+8)
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:172: (8 bytes): value := value / (radix)
	<append+?>: dup.x64 sp(24)
	<append+?>: dup.x32 sp(2)
	<append+?>: i32.2i64
	<append+?>: div.u64
	<append+?>: set.x64 sp(26)
	cmplStd/lib/string.ci:172: (8 bytes): value > (0)
	<append+?>: dup.x64 sp(24)
	<append+?>: load.z64
	<append+?>: cgt.u64
	<append+?>: jnz -41
	cmplStd/lib/string.ci:175: (29 bytes): if (len == 0)
	<append+?>: dup.x32 sp(21)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +25
	cmplStd/lib/string.ci:176: (21 bytes): digits[len := len + 1] := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+8)
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(25)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:179: (10 bytes): maxLen: int32 := format.padLen - len
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+12)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(22)
	<append+?>: sub.i32
	cmplStd/lib/string.ci:181: (7 bytes): padChr: char := format.padChr
	<append+?>: dup.x32 sp(24)
	<append+?>: inc.i32(+8)
	<append+?>: load.i8
	cmplStd/lib/string.ci:182: (21 bytes): if (padChr == '')
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	cmplStd/lib/string.ci:183: (10 bytes): padChr := ' ';
	<append+?>: load.c32 32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/string.ci:187: (207 bytes): if ((sign) != 0)
	<append+?>: load.sp(+112)
	<append+?>: load.i8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jnz +200
	cmplStd/lib/string.ci:188: (8 bytes): maxLen := maxLen - 1;
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/string.ci:189: (117 bytes): if (contains(whiteSpace, padChr))
	<append+?>: load.z32
	<append+?>: load.m32 <?> ;append.whiteSpace
	<append+?>: load.sp(+8)
	<append+?>: load.i8
	<append+?>: load.ref <?> ;indexOf(str: char[*], chr: char): int32
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jnz +95
	cmplStd/lib/string.ci:191: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	cmplStd/lib/string.ci:192: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"cmplStd/lib/string.ci"
	<append+?>: load.c32 192
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:193: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:194: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	cmplStd/lib/string.ci:191: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/string.ci:191: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	cmplStd/lib/string.ci:197: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"cmplStd/lib/string.ci"
	<append+?>: load.c32 197
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:198: (11 bytes): output[pos] := sign;
	<append+?>: load.sp(+112)
	<append+?>: load.i8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:199: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	cmplStd/lib/string.ci:203: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +83
	cmplStd/lib/string.ci:204: (52 bytes): assert(pos < (output.length));
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"cmplStd/lib/string.ci"
	<append+?>: load.c32 204
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:205: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.i8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:206: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	cmplStd/lib/string.ci:203: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/string.ci:203: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -83
	cmplStd/lib/string.ci:210: (99 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +85
	cmplStd/lib/string.ci:211: (52 bytes): assert(i < (output.length));
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +43
	<append+?>: load.ref <?> ;"cmplStd/lib/string.ci"
	<append+?>: load.c32 211
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: load.ref <?> ;pointer
	<append+?>: load.ref <?> ;null
	<append+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:212: (17 bytes): output[pos] := digits[len - i];
	<append+?>: load.sp(+16)
	<append+?>: dup.x32 sp(25)
	<append+?>: dup.x32 sp(2)
	<append+?>: sub.i32
	<append+?>: add.i32
	<append+?>: load.i8
	<append+?>: dup.x32 sp(32)
	<append+?>: dup.x32 sp(32)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:213: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(30)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(31)
	cmplStd/lib/string.ci:210: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	cmplStd/lib/string.ci:210: (9 bytes): i < len
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(25)
	<append+?>: clt.i32
	<append+?>: jnz -86
	<append+?>: inc.sp(-4)
	cmplStd/lib/string.ci:216: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(29)
	<append+?>: dup.x32 sp(32)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/string.ci:217: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(31)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(30)
	cmplStd/lib/string.ci:219: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/string.ci:220: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(32, 29)
	<append+?>: inc.sp(-96)
	<append+?>: ret
.usages:
	cmplStd/lib/string.ci:261: referenced as `append`
	cmplStd/lib/string.ci:257: referenced as `append`
	cmplStd/lib/string.ci:238: referenced as `append`
	cmplStd/lib/string.ci:236: referenced as `append`
	cmplStd/lib/string.ci:234: referenced as `append`
	cmplStd/lib/string.ci:232: referenced as `append`
	cmplStd/lib/string.ci:230: referenced as `append`
	cmplStd/lib/string.ci:228: referenced as `append`
	cmplStd/lib/string.ci:226: referenced as `append`
	cmplStd/lib/string.ci:224: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:224'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint64 (size: 8, cast: u64)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:226'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:228'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:230'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 0, uint64(value), format)
.usages:
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:232'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int64 (size: 8, cast: variable(i64))
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, value < (0) ? ('-') : 0, uint64(value < (0) ? -value : value), format)
.usages:
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:234'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, value < 0 ? ('-') : 0, uint64(value < 0 ? -value : value), format)
.usages:
	cmplStd/lib/string.ci:271: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:236'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int16 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format)
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:238'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int8 (size: 4, cast: variable(i32))
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format)
.usages:
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 236
.name: 'append'
.file: 'cmplStd/lib/string.ci:241'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: float64 (size: 8, cast: variable(f64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		formatInt.showSign := format.showSign;
		formatInt.precision := 0;
		formatInt.padChr := format.padChr;
		formatInt.padLen := format.padLen - format.precision;
	};
	formatDec: FormatFlags := {
		formatDec.showSign := false;
		formatDec.precision := 0;
		formatDec.padChr := '0';
		formatDec.padLen := format.precision;
	};
	sign: char := value < (0) ? ('-') : 0;
	fract: float64 := Math.modf(Math.abs(value), &value);
	pos := append(output, pos, sign, uint64(int64(value)), formatInt);
	pos := append(output, pos, ".");
	fract := fract * float64.pow(10, format.precision);
	pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
	return .result := pos;
}
.instructions: (236 bytes)
	cmplStd/lib/string.ci:242: (44 bytes): formatInt: FormatFlags := {...}
	<append>  : inc.sp(+16)
	cmplStd/lib/string.ci:243: (8 bytes): formatInt.showSign := format.showSign;
	<append+?>: dup.x32 sp(5)
	<append+?>: load.i8
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/string.ci:244: (3 bytes): formatInt.precision := 0;
	<append+?>: load.z32
	<append+?>: set.x32 sp(2)
	cmplStd/lib/string.ci:245: (12 bytes): formatInt.padChr := format.padChr;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+8)
	<append+?>: load.i8
	<append+?>: load.sp(+12)
	<append+?>: store.i8
	cmplStd/lib/string.ci:246: (17 bytes): formatInt.padLen := format.padLen - format.precision;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+12)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(6)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: sub.i32
	<append+?>: set.x32 sp(4)
	cmplStd/lib/string.ci:248: (32 bytes): formatDec: FormatFlags := {...}
	<append+?>: inc.sp(+16)
	cmplStd/lib/string.ci:249: (6 bytes): formatDec.showSign := false;
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/string.ci:250: (3 bytes): formatDec.precision := 0;
	<append+?>: load.z32
	<append+?>: set.x32 sp(2)
	cmplStd/lib/string.ci:251: (10 bytes): formatDec.padChr := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+12)
	<append+?>: store.i8
	cmplStd/lib/string.ci:252: (9 bytes): formatDec.padLen := format.precision;
	<append+?>: dup.x32 sp(9)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: set.x32 sp(4)
	cmplStd/lib/string.ci:255: (18 bytes): sign: char := value < (0) ? ('-') : 0
	<append+?>: dup.x64 sp(10)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +13
	<append+?>: load.c32 45
	<append+?>: jmp +5
	<append+?>: load.z32
	cmplStd/lib/string.ci:256: (36 bytes): fract: float64 := Math.modf(Math.abs(value), &value)
	<append+?>: load.z64
	<append+?>: dup.x64 sp(13)
	<append+?>: dup.x64 sp(0)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +11
	<append+?>: dup.x64 sp(0)
	<append+?>: neg.f64
	<append+?>: jmp +6
	<append+?>: dup.x64 sp(0)
	<append+?>: set.x64 sp(2)
	<append+?>: load.sp(+60)
	<append+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-12)
	cmplStd/lib/string.ci:257: (29 bytes): pos := append(output, pos, sign, uint64(int64(value)), formatInt);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(17)
	<append+?>: dup.x32 sp(18)
	<append+?>: load.sp(+24)
	<append+?>: load.i8
	<append+?>: dup.x64 sp(18)
	<append+?>: f64.2i64
	<append+?>: load.sp(+56)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(16)
	cmplStd/lib/string.ci:259: (22 bytes): pos := append(output, pos, ".");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(17)
	<append+?>: dup.x32 sp(18)
	<append+?>: load.ref <?> ;"."
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(16)
	cmplStd/lib/string.ci:260: (22 bytes): fract := fract * float64.pow(10, format.precision);
	<append+?>: load.f64 10.000000
	<append+?>: dup.x32 sp(14)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: i32.2f64
	<append+?>: nfc(46) ;float64.pow(x: float64, y: float64): float64
	<append+?>: mul.f64
	cmplStd/lib/string.ci:261: (25 bytes): pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(17)
	<append+?>: dup.x32 sp(18)
	<append+?>: load.z32
	<append+?>: dup.x64 sp(5)
	<append+?>: f64.2i64
	<append+?>: load.sp(+40)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(16)
	cmplStd/lib/string.ci:262: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(18, 15)
	<append+?>: inc.sp(-44)
	<append+?>: ret
.usages:
	cmplStd/lib/string.ci:266: referenced as `append`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/string.ci:266'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: float32 (size: 4, cast: f32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, float64(value), format)
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.name: 'append'
.file: 'cmplStd/lib/string.ci:269'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		format.showSign := false;
		format.precision := 0;
		format.padChr := (0);
		format.padLen := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (63 bytes)
	cmplStd/lib/string.ci:271: (63 bytes): return .result := append(output, pos, value, format);
	<append>  : dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: dup.x64 sp(5)
	<append+?>: dup.x32 sp(6)
	<append+?>: dup.x32 sp(4)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jz +13
	<append+?>: load.c32 45
	<append+?>: jmp +5
	<append+?>: load.z32
	<append+?>: dup.x32 sp(5)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jz +11
	<append+?>: dup.x32 sp(5)
	<append+?>: neg.i32
	<append+?>: jmp +6
	<append+?>: dup.x32 sp(5)
	<append+?>: i32.2i64
	<append+?>: load.ref <?> ;append.format
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(1)
	<append+?>: set.x32 sp(6)
	<append+?>: ret
.usages:
	cmplGfx/gfxlib.ci:269: referenced as `append`
	cmplGfx/gfxlib.ci:267: referenced as `append`
	cmplGfx/gfxlib.ci:265: referenced as `append`
	cmplGfx/gfxlib.ci:263: referenced as `append`
	cmplGfx/gfxlib.ci:117: referenced as `append`
	cmplGfx/gfxlib.ci:98: referenced as `append`
}
File: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'File'
.field open: function (size: 0, cast: static const inline)
.field create: function (size: 0, cast: static const inline)
.field append: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field peek: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field readLine: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field flush: function (size: 0, cast: static const inline)
.field close: function (size: 0, cast: static const inline)
.field in: File (size: 0, cast: static const inline)
.field out: File (size: 0, cast: static const inline)
.field err: File (size: 0, cast: static const inline)
.field log: File (size: 0, cast: static const inline)
.usages:
	internal usages: 16
}
File.open(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(49)
.usages:
}
File.create(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(50)
.usages:
}
File.append(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'append'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(51)
.usages:
}
File.read(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(52)
.usages:
}
File.peek(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'peek'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(53)
.usages:
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(54)
.usages:
}
File.readLine(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'readLine'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.value: nfc(55)
.usages:
}
File.write(file: File, byte: uint8): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param byte: uint8 (size: 4, cast: variable(u32))
.value: nfc(56)
.usages:
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: const variable(arr))
.value: nfc(57)
.usages:
}
File.write(file: File, buff: uint8[], size: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: const variable(arr))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(58)
.usages:
}
File.flush(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'flush'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(59)
.usages:
}
File.close(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'close'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.value: nfc(60)
.usages:
}
File.in: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'in'
.owner: File
.value: nfc(61)
.usages:
}
File.out: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'out'
.owner: File
.value: nfc(62)
.usages:
}
File.err: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'err'
.owner: File
.value: nfc(63)
.usages:
}
File.log: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'log'
.owner: File
.value: nfc(64)
.usages:
}
Rect: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Rect'
.field x: int32 (size: 4, cast: variable(i32))
.field y: int32 (size: 4, cast: variable(i32))
.field w: int32 (size: 4, cast: variable(i32))
.field h: int32 (size: 4, cast: variable(i32))
.usages:
	cmplGfx/lib/image.ci:203: referenced as `Rect`
	cmplGfx/lib/image.ci:202: referenced as `Rect`
	cmplGfx/lib/image.ci:169: referenced as `Rect`
	cmplGfx/lib/image.ci:168: referenced as `Rect`
	cmplGfx/lib/image.ci:165: referenced as `Rect`
	cmplGfx/lib/image.ci:163: referenced as `Rect`
	cmplGfx/lib/image.ci:160: referenced as `Rect`
	cmplGfx/lib/image.ci:158: referenced as `Rect`
	cmplGfx/lib/image.ci:120: referenced as `Rect`
	cmplGfx/lib/image.ci:117: referenced as `Rect`
	cmplGfx/lib/image.ci:114: referenced as `Rect`
	cmplGfx/lib/image.ci:114: referenced as `Rect`
	cmplGfx/lib/image.ci:111: referenced as `Rect`
	internal usages: 13
}
Rect.x: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x'
.owner: Rect
.usages:
	cmplGfx/lib/image.ci:204: referenced as `x`
	cmplGfx/lib/image.ci:204: referenced as `x`
	cmplGfx/lib/image.ci:194: referenced as `x`
	cmplGfx/lib/image.ci:194: referenced as `x`
	cmplGfx/lib/image.ci:170: referenced as `x`
	cmplGfx/lib/image.ci:170: referenced as `x`
	cmplGfx/lib/image.ci:165: referenced as `x`
	cmplGfx/lib/image.ci:165: referenced as `x`
	cmplGfx/lib/image.ci:163: referenced as `x`
	cmplGfx/lib/image.ci:163: referenced as `x`
	cmplGfx/lib/image.ci:160: referenced as `x`
	cmplGfx/lib/image.ci:160: referenced as `x`
	cmplGfx/lib/image.ci:158: referenced as `x`
	cmplGfx/lib/image.ci:158: referenced as `x`
	cmplGfx/lib/image.ci:143: referenced as `x`
	cmplGfx/lib/image.ci:126: referenced as `x`
	cmplGfx/lib/image.ci:125: referenced as `x`
	cmplGfx/lib/image.ci:122: referenced as `x`
}
Rect.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.owner: Rect
.usages:
	cmplGfx/lib/image.ci:205: referenced as `y`
	cmplGfx/lib/image.ci:205: referenced as `y`
	cmplGfx/lib/image.ci:192: referenced as `y`
	cmplGfx/lib/image.ci:192: referenced as `y`
	cmplGfx/lib/image.ci:171: referenced as `y`
	cmplGfx/lib/image.ci:171: referenced as `y`
	cmplGfx/lib/image.ci:165: referenced as `y`
	cmplGfx/lib/image.ci:165: referenced as `y`
	cmplGfx/lib/image.ci:163: referenced as `y`
	cmplGfx/lib/image.ci:163: referenced as `y`
	cmplGfx/lib/image.ci:160: referenced as `y`
	cmplGfx/lib/image.ci:160: referenced as `y`
	cmplGfx/lib/image.ci:158: referenced as `y`
	cmplGfx/lib/image.ci:158: referenced as `y`
	cmplGfx/lib/image.ci:144: referenced as `y`
	cmplGfx/lib/image.ci:130: referenced as `y`
	cmplGfx/lib/image.ci:129: referenced as `y`
	cmplGfx/lib/image.ci:123: referenced as `y`
}
Rect.w: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'w'
.owner: Rect
.usages:
	cmplGfx/lib/image.ci:223: referenced as `w`
	cmplGfx/lib/image.ci:215: referenced as `w`
	cmplGfx/lib/image.ci:206: referenced as `w`
	cmplGfx/lib/image.ci:206: referenced as `w`
	cmplGfx/lib/image.ci:194: referenced as `w`
	cmplGfx/lib/image.ci:172: referenced as `w`
	cmplGfx/lib/image.ci:172: referenced as `w`
	cmplGfx/lib/image.ci:165: referenced as `w`
	cmplGfx/lib/image.ci:163: referenced as `w`
	cmplGfx/lib/image.ci:160: referenced as `w`
	cmplGfx/lib/image.ci:158: referenced as `w`
	cmplGfx/lib/image.ci:146: referenced as `w`
	cmplGfx/lib/image.ci:143: referenced as `w`
	cmplGfx/lib/image.ci:135: referenced as `w`
	cmplGfx/lib/image.ci:134: referenced as `w`
	cmplGfx/lib/image.ci:122: referenced as `w`
}
Rect.h: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'h'
.owner: Rect
.usages:
	cmplGfx/lib/image.ci:222: referenced as `h`
	cmplGfx/lib/image.ci:218: referenced as `h`
	cmplGfx/lib/image.ci:207: referenced as `h`
	cmplGfx/lib/image.ci:207: referenced as `h`
	cmplGfx/lib/image.ci:192: referenced as `h`
	cmplGfx/lib/image.ci:173: referenced as `h`
	cmplGfx/lib/image.ci:173: referenced as `h`
	cmplGfx/lib/image.ci:165: referenced as `h`
	cmplGfx/lib/image.ci:163: referenced as `h`
	cmplGfx/lib/image.ci:160: referenced as `h`
	cmplGfx/lib/image.ci:158: referenced as `h`
	cmplGfx/lib/image.ci:149: referenced as `h`
	cmplGfx/lib/image.ci:144: referenced as `h`
	cmplGfx/lib/image.ci:140: referenced as `h`
	cmplGfx/lib/image.ci:139: referenced as `h`
	cmplGfx/lib/image.ci:123: referenced as `h`
}
Image: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Image'
.print: '%a'
.field create: function (size: 0, cast: static const inline)
.field create3d: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field slice: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openBmp: function (size: 0, cast: static const inline)
.field openPng: function (size: 0, cast: static const inline)
.field openJpg: function (size: 0, cast: static const inline)
.field openImg: function (size: 0, cast: static const inline)
.field openTtf: function (size: 0, cast: static const inline)
.field openFnt: function (size: 0, cast: static const inline)
.field saveBmp: function (size: 0, cast: static const inline)
.field width: function (size: 0, cast: static const inline)
.field height: function (size: 0, cast: static const inline)
.field depth: function (size: 0, cast: static const inline)
.field get: function (size: 0, cast: static const inline)
.field set: function (size: 0, cast: static const inline)
.field tex: function (size: 0, cast: static const inline)
.field drawRect: function (size: 0, cast: static const inline)
.field fillRect: function (size: 0, cast: static const inline)
.field drawOval: function (size: 0, cast: static const inline)
.field fillOval: function (size: 0, cast: static const inline)
.field drawLine: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field drawBezier: function (size: 0, cast: static const inline)
.field clipText: function (size: 0, cast: static const inline)
.field drawText: function (size: 0, cast: static const inline)
.field drawText: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field blend: function (size: 0, cast: static const inline)
.field transform: function (size: 0, cast: static const inline)
.field blur: function (size: 0, cast: static const inline)
.field colorMap: function (size: 0, cast: static const inline)
.field colorMat: function (size: 0, cast: static const inline)
.field calcHueHist: function (size: 0, cast: static const inline)
.field calcLumHist: function (size: 0, cast: static const inline)
.field calcRgbHist: function (size: 0, cast: static const inline)
.field drawMesh: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:284: referenced as `Image`
	cmplGfx/gfxlib.ci:156: referenced as `Image`
	cmplGfx/gfxlib.ci:130: referenced as `Image`
	cmplGfx/gfxlib.ci:75: referenced as `Image`
	cmplGfx/gfxlib.ci:74: referenced as `Image`
	cmplGfx/gfxlib.ci:41: referenced as `Image`
	cmplGfx/gfxlib.ci:40: referenced as `Image`
	cmplGfx/gfxlib.ci:39: referenced as `Image`
	cmplGfx/gfxlib.ci:37: referenced as `Image`
	cmplGfx/gfxlib.ci:37: referenced as `Image`
	cmplGfx/gfxlib.ci:26: referenced as `Image`
	cmplGfx/gfxlib.ci:23: referenced as `Image`
	cmplGfx/gfxlib.ci:17: referenced as `Image`
	cmplGfx/gfxlib.ci:12: referenced as `Image`
	cmplGfx/gfxlib.ci:7: referenced as `Image`
	cmplGfx/lib/image.ci:202: referenced as `Image`
	cmplGfx/lib/image.ci:202: referenced as `Image`
	cmplGfx/lib/image.ci:168: referenced as `Image`
	cmplGfx/lib/image.ci:165: referenced as `Image`
	cmplGfx/lib/image.ci:163: referenced as `Image`
	cmplGfx/lib/image.ci:160: referenced as `Image`
	cmplGfx/lib/image.ci:158: referenced as `Image`
	cmplGfx/lib/image.ci:156: referenced as `Image`
	cmplGfx/lib/image.ci:120: referenced as `Image`
	cmplGfx/lib/image.ci:117: referenced as `Image`
	cmplGfx/lib/image.ci:117: referenced as `Image`
	cmplGfx/lib/image.ci:114: referenced as `Image`
	cmplGfx/lib/image.ci:114: referenced as `Image`
	cmplGfx/lib/image.ci:114: referenced as `Image`
	cmplGfx/lib/image.ci:111: referenced as `Image`
	cmplGfx/lib/image.ci:111: referenced as `Image`
	cmplGfx/lib/image.ci:108: referenced as `Image`
	cmplGfx/lib/image.ci:108: referenced as `Image`
	cmplGfx/lib/image.ci:96: referenced as `Image`
	cmplGfx/lib/image.ci:95: referenced as `Image`
	cmplGfx/lib/image.ci:94: referenced as `Image`
	cmplGfx/lib/image.ci:87: referenced as `Image`
	cmplGfx/lib/image.ci:85: referenced as `Image`
	cmplGfx/lib/image.ci:83: referenced as `Image`
	cmplGfx/lib/image.ci:26: referenced as `Image`
	cmplGfx/lib/image.ci:12: referenced as `Image`
	cmplGfx/lib/image.ci:12: referenced as `Image`
	cmplGfx/lib/image.ci:6: referenced as `Image`
	cmplGfx/lib/image.ci:6: referenced as `Image`
	cmplGfx/lib/image.ci:5: referenced as `Image`
	cmplGfx/lib/image.ci:5: referenced as `Image`
	cmplGfx/lib/image.ci:2: referenced as `Image`
	internal usages: 50
}
Image.create(width: int32, height: int32, depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(83)
.usages:
	cmplGfx/lib/image.ci:6: referenced as `create`
	cmplGfx/lib/image.ci:2: referenced as `create`
}
Image.create3d(width: int32, height: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create3d'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.value: nfc(84)
.usages:
	cmplGfx/gfxlib.ci:284: referenced as `create3d`
}
Image.recycle(recycle: Image, width: int32, height: int32, depth: int32, flags: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param recycle: Image (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(85)
.usages:
}
Image.slice(image: Image, recycle: Image, rect: Rect): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'slice'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param recycle: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: const variable(ref))
.value: nfc(86)
.usages:
	cmplGfx/lib/image.ci:117: referenced as `slice`
}
Image.destroy(image: Image): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.value: nfc(87)
.usages:
	cmplGfx/gfxlib.ci:291: referenced as `destroy`
	cmplGfx/gfxlib.ci:145: referenced as `destroy`
	cmplGfx/gfxlib.ci:144: referenced as `destroy`
	cmplGfx/gfxlib.ci:133: referenced as `destroy`
	cmplGfx/lib/image.ci:97: referenced as `destroy`
	cmplGfx/lib/image.ci:78: referenced as `destroy`
}
Image.openBmp(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openBmp'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(88)
.usages:
	cmplGfx/lib/image.ci:85: referenced as `openBmp`
}
Image.openPng(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openPng'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(89)
.usages:
}
Image.openJpg(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openJpg'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(90)
.usages:
}
Image.openImg(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openImg'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.value: nfc(91)
.usages:
	cmplGfx/lib/image.ci:87: referenced as `openImg`
}
Image.openTtf(path: char[*], height: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openTtf'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param height: int32 (size: 4, cast: variable(i32))
.value: nfc(92)
.usages:
}
Image.openFnt(path: char[*]): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openFnt'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(93)
.usages:
}
Image.saveBmp(image: Image, path: char[*], flags: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveBmp'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param path: char[*] (size: 4, cast: const variable(ref))
.param flags: int32 (size: 4, cast: variable(i32))
.value: nfc(94)
.usages:
	cmplGfx/gfxlib.ci:108: referenced as `saveBmp`
	cmplGfx/gfxlib.ci:107: referenced as `saveBmp`
}
Image.width(image: Image): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'width'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.value: nfc(95)
.usages:
	cmplGfx/lib/image.ci:220: referenced as `width`
	cmplGfx/lib/image.ci:206: referenced as `width`
	cmplGfx/lib/image.ci:180: referenced as `width`
	cmplGfx/lib/image.ci:172: referenced as `width`
	cmplGfx/lib/image.ci:133: referenced as `width`
	cmplGfx/lib/image.ci:59: referenced as `width`
	cmplGfx/lib/image.ci:56: referenced as `width`
	cmplGfx/lib/image.ci:44: referenced as `width`
	cmplGfx/lib/image.ci:35: referenced as `width`
	cmplGfx/lib/image.ci:6: referenced as `width`
}
Image.height(image: Image): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'height'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.value: nfc(96)
.usages:
	cmplGfx/lib/image.ci:221: referenced as `height`
	cmplGfx/lib/image.ci:207: referenced as `height`
	cmplGfx/lib/image.ci:181: referenced as `height`
	cmplGfx/lib/image.ci:173: referenced as `height`
	cmplGfx/lib/image.ci:138: referenced as `height`
	cmplGfx/lib/image.ci:67: referenced as `height`
	cmplGfx/lib/image.ci:64: referenced as `height`
	cmplGfx/lib/image.ci:47: referenced as `height`
	cmplGfx/lib/image.ci:36: referenced as `height`
	cmplGfx/lib/image.ci:6: referenced as `height`
}
Image.depth(image: Image): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'depth'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.value: nfc(97)
.usages:
	cmplGfx/lib/image.ci:117: referenced as `depth`
	cmplGfx/lib/image.ci:26: referenced as `depth`
	cmplGfx/lib/image.ci:6: referenced as `depth`
}
Image.get(image: Image, x: int32, y: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'get'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.value: nfc(98)
.usages:
}
Image.set(image: Image, x: int32, y: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'set'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.value: nfc(99)
.usages:
	cmplGfx/lib/image.ci:108: referenced as `set`
}
Image.tex(image: Image, x: float32, y: float32): vec4f: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tex'
.owner: Image
.param .result: vec4f (size: 16, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.value: nfc(100)
.usages:
}
Image.drawRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawRect'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(101)
.usages:
	cmplGfx/lib/image.ci:163: referenced as `drawRect`
}
Image.fillRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillRect'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(102)
.usages:
	cmplGfx/lib/image.ci:165: referenced as `fillRect`
	cmplGfx/lib/image.ci:160: referenced as `fillRect`
	cmplGfx/lib/image.ci:158: referenced as `fillRect`
	cmplGfx/lib/image.ci:156: referenced as `fillRect`
}
Image.drawOval(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawOval'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(103)
.usages:
}
Image.fillOval(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillOval'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(104)
.usages:
}
Image.drawLine(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawLine'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(105)
.usages:
}
Image.drawBezier(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(106)
.usages:
}
Image.drawBezier(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawBezier'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param x4: int32 (size: 4, cast: variable(i32))
.param y4: int32 (size: 4, cast: variable(i32))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(107)
.usages:
}
Image.clipText(font: Image, rect: Rect, text: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clipText'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param font: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: const variable(ref))
.value: nfc(108)
.usages:
}
Image.drawText(image: Image, x: int32, y: int32, font: Image, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param font: Image (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: const variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(109)
.usages:
}
Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param font: Image (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: const variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.value: nfc(110)
.usages:
}
Image.copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.value: nfc(111)
.usages:
	cmplGfx/gfxlib.ci:55: referenced as `copy`
	cmplGfx/gfxlib.ci:51: referenced as `copy`
	cmplGfx/lib/image.ci:224: referenced as `copy`
	cmplGfx/lib/image.ci:7: referenced as `copy`
}
Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, alpha: int32, dstAlpha: bool, blend(base: vec4f, with: vec4f): vec4f): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blend'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: const variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param alpha: int32 (size: 4, cast: variable(i32))
.param dstAlpha: bool (size: 4, cast: variable(bool))
.param blend: function (size: 4, cast: variable(ref))
.value: nfc(112)
.usages:
	cmplGfx/gfxlib.ci:12: referenced as `blend`
}
Image.transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'transform'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: const variable(ref))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param interpolate: int32 (size: 4, cast: variable(i32))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.value: nfc(113)
.usages:
	cmplGfx/gfxlib.ci:17: referenced as `transform`
	cmplGfx/lib/image.ci:114: referenced as `transform`
	cmplGfx/lib/image.ci:77: referenced as `transform`
}
Image.blur(image: Image, radius: int32, sigma: float64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blur'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param radius: int32 (size: 4, cast: variable(i32))
.param sigma: float64 (size: 8, cast: variable(f64))
.value: nfc(114)
.usages:
	cmplGfx/gfxlib.ci:7: referenced as `blur`
}
Image.colorMap(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMap'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: const variable(ref))
.value: nfc(115)
.usages:
	cmplGfx/lib/image.ci:111: referenced as `colorMap`
}
Image.colorMat(image: Image, roi: Rect, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMat'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.value: nfc(116)
.usages:
}
Image.calcHueHist(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcHueHist'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.value: nfc(117)
.usages:
}
Image.calcLumHist(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcLumHist'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.value: nfc(118)
.usages:
}
Image.calcRgbHist(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcRgbHist'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.value: nfc(119)
.usages:
}
Image.drawMesh(image: Image, mesh: Mesh, mode: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawMesh'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param mesh: Mesh (size: 4, cast: variable(ref))
.param mode: int32 (size: 4, cast: variable(i32))
.value: nfc(120)
.usages:
	cmplGfx/gfxlib.ci:259: referenced as `drawMesh`
}
Mesh: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 176
.name: 'Mesh'
.field create: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openObj: function (size: 0, cast: static const inline)
.field open3ds: function (size: 0, cast: static const inline)
.field saveObj: function (size: 0, cast: static const inline)
.field normalize: function (size: 0, cast: static const inline)
.field addVertex: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field setVertex: function (size: 0, cast: static const inline)
.field setNormal: function (size: 0, cast: static const inline)
.field setTexture: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field shine: function (size: 0, cast: static const inline)
.field texture: function (size: 0, cast: static const inline)
.field clearDepth: int64 (size: 0, cast: static const i64)
.field clearColor: int64 (size: 0, cast: static const i64)
.field cullBack: int64 (size: 0, cast: static const i64)
.field cullFront: int64 (size: 0, cast: static const i64)
.field drawPlot: int64 (size: 0, cast: static const i64)
.field drawWire: int64 (size: 0, cast: static const i64)
.field drawFill: int64 (size: 0, cast: static const i64)
.field drawMode: int64 (size: 0, cast: static const i64)
.field useTexture: int64 (size: 0, cast: static const i64)
.field useLights: int64 (size: 0, cast: static const i64)
.field vertices: int64 (size: 8, cast: const variable(i64))
.field triangles: int64 (size: 8, cast: const variable(i64))
.field segments: int64 (size: 8, cast: const variable(i64))
.usages:
	cmplGfx/gfxlib.ci:283: referenced as `Mesh`
	cmplGfx/gfxlib.ci:283: referenced as `Mesh`
	cmplGfx/gfxlib.ci:283: referenced as `Mesh`
	cmplGfx/gfxlib.ci:283: referenced as `Mesh`
	cmplGfx/gfxlib.ci:283: referenced as `Mesh`
	cmplGfx/gfxlib.ci:212: referenced as `Mesh`
	cmplGfx/gfxlib.ci:209: referenced as `Mesh`
	cmplGfx/gfxlib.ci:209: referenced as `Mesh`
	cmplGfx/gfxlib.ci:206: referenced as `Mesh`
	cmplGfx/gfxlib.ci:191: referenced as `Mesh`
	cmplGfx/gfxlib.ci:159: referenced as `Mesh`
	cmplGfx/gfxlib.ci:149: referenced as `Mesh`
	cmplGfx/lib/mesh.ci:7: referenced as `Mesh`
	cmplGfx/lib/mesh.ci:4: referenced as `Mesh`
	cmplGfx/lib/mesh.ci:2: referenced as `Mesh`
	internal usages: 20
}
Mesh.create(size: int32): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(65)
.usages:
}
Mesh.recycle(recycle: Mesh, size: int32): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param recycle: Mesh (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.value: nfc(66)
.usages:
}
Mesh.destroy(mesh: Mesh): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.value: nfc(67)
.usages:
}
Mesh.openObj(path: char[*]): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openObj'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(68)
.usages:
	cmplGfx/lib/mesh.ci:4: referenced as `openObj`
}
Mesh.open3ds(path: char[*]): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open3ds'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(69)
.usages:
	cmplGfx/lib/mesh.ci:7: referenced as `open3ds`
}
Mesh.saveObj(mesh: Mesh, path: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveObj'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: const variable(ref))
.value: nfc(70)
.usages:
}
Mesh.normalize(mesh: Mesh, tolerance: float32, center: float32[3], resize: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'normalize'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param tolerance: float32 (size: 4, cast: variable(f32))
.param center: float32[3] (size: 4, cast: variable(ref))
.param resize: float32[3] (size: 4, cast: variable(ref))
.value: nfc(71)
.usages:
}
Mesh.addVertex(mesh: Mesh, x: float32, y: float32, z: float32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addVertex'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(72)
.usages:
}
Mesh.addFace(mesh: Mesh, v1: int32, v2: int32, v3: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.value: nfc(73)
.usages:
}
Mesh.addFace(mesh: Mesh, v1: int32, v2: int32, v3: int32, v4: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.param v4: int32 (size: 4, cast: variable(i32))
.value: nfc(74)
.usages:
}
Mesh.setVertex(mesh: Mesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setVertex'
.owner: Mesh
.param .result: bool (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(75)
.usages:
}
Mesh.setNormal(mesh: Mesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setNormal'
.owner: Mesh
.param .result: bool (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(76)
.usages:
}
Mesh.setTexture(mesh: Mesh, idx: int32, s: float32, t: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTexture'
.owner: Mesh
.param .result: bool (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param s: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.value: nfc(77)
.usages:
}
Mesh.ambient(mesh: Mesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(78)
.usages:
}
Mesh.diffuse(mesh: Mesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(79)
.usages:
}
Mesh.specular(mesh: Mesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(80)
.usages:
}
Mesh.shine(mesh: Mesh, value: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'shine'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.value: nfc(81)
.usages:
}
Mesh.texture(mesh: Mesh, texture: Image): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'texture'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param texture: Image (size: 8, cast: variable(val))
.value: nfc(82)
.usages:
}
Mesh.clearDepth: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearDepth'
.owner: Mesh
.value: 8
.usages:
	cmplGfx/gfxlib.ci:283: referenced as `clearDepth`
}
Mesh.clearColor: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'clearColor'
.owner: Mesh
.value: 4
.usages:
	cmplGfx/gfxlib.ci:283: referenced as `clearColor`
}
Mesh.cullBack: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullBack'
.owner: Mesh
.value: 16
.usages:
	cmplGfx/gfxlib.ci:283: referenced as `cullBack`
	cmplGfx/gfxlib.ci:209: referenced as `cullBack`
}
Mesh.cullFront: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullFront'
.owner: Mesh
.value: 32
.usages:
	cmplGfx/gfxlib.ci:209: referenced as `cullFront`
}
Mesh.drawPlot: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawPlot'
.owner: Mesh
.value: 1
}
Mesh.drawWire: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawWire'
.owner: Mesh
.value: 2
}
Mesh.drawFill: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawFill'
.owner: Mesh
.value: 3
.usages:
	cmplGfx/gfxlib.ci:283: referenced as `drawFill`
}
Mesh.drawMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawMode'
.owner: Mesh
.value: 3
.usages:
	cmplGfx/gfxlib.ci:212: referenced as `drawMode`
}
Mesh.useTexture: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useTexture'
.owner: Mesh
.value: 64
.usages:
	cmplGfx/gfxlib.ci:206: referenced as `useTexture`
}
Mesh.useLights: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useLights'
.owner: Mesh
.value: 128
.usages:
	cmplGfx/gfxlib.ci:283: referenced as `useLights`
	cmplGfx/gfxlib.ci:191: referenced as `useLights`
}
Mesh.vertices: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'vertices'
.owner: Mesh
.usages:
	cmplGfx/gfxlib.ci:263: referenced as `vertices`
}
Mesh.triangles: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'triangles'
.owner: Mesh
.usages:
	cmplGfx/gfxlib.ci:265: referenced as `triangles`
}
Mesh.segments: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'segments'
.owner: Mesh
}
gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'gradient'
.field Linear: int64 (size: 0, cast: static const i64)
.field Radial: int64 (size: 0, cast: static const i64)
.field Square: int64 (size: 0, cast: static const i64)
.field Spiral: int64 (size: 0, cast: static const i64)
.field Conical: int64 (size: 0, cast: static const i64)
.field MaskLinear: int64 (size: 0, cast: static const i64)
.field MaskRadial: int64 (size: 0, cast: static const i64)
.field MaskSquare: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param type: int32 (size: 4, cast: variable(i32))
.param repeat: bool (size: 4, cast: variable(bool))
.param colors: uint32[] (size: 8, cast: variable(arr))
.value: nfc(121)
.usages:
}
gradient.Linear: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Linear'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 0
}
gradient.Radial: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Radial'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 1
}
gradient.Square: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Square'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 2
}
gradient.Spiral: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Spiral'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 4
}
gradient.Conical: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Conical'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 3
}
gradient.MaskLinear: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MaskLinear'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 16
}
gradient.MaskRadial: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MaskRadial'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 17
}
gradient.MaskSquare: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MaskSquare'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.value: 18
}
camera(proj: float32[16], position: float32[4], forward: float32[4], right: float32[4], up: float32[4]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'camera'
.param .result: void (size: 0, cast: inline)
.param proj: float32[16] (size: 4, cast: const variable(ref))
.param position: float32[4] (size: 4, cast: const variable(ref))
.param forward: float32[4] (size: 4, cast: const variable(ref))
.param right: float32[4] (size: 4, cast: const variable(ref))
.param up: float32[4] (size: 4, cast: const variable(ref))
.value: nfc(122)
.usages:
	cmplGfx/gfxlib.ci:163: referenced as `camera`
}
lights: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'lights'
.field enabled: function (size: 0, cast: static const inline)
.field enable: function (size: 0, cast: static const inline)
.field position: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field attenuation: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:203: referenced as `lights`
	cmplGfx/gfxlib.ci:203: referenced as `lights`
	cmplGfx/gfxlib.ci:200: referenced as `lights`
	cmplGfx/gfxlib.ci:200: referenced as `lights`
	cmplGfx/gfxlib.ci:197: referenced as `lights`
	cmplGfx/gfxlib.ci:197: referenced as `lights`
	cmplGfx/gfxlib.ci:194: referenced as `lights`
	cmplGfx/gfxlib.ci:194: referenced as `lights`
}
lights.enabled(light: int32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enabled'
.owner: lights
.param .result: bool (size: 4, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.value: nfc(123)
.usages:
	cmplGfx/gfxlib.ci:203: referenced as `enabled`
	cmplGfx/gfxlib.ci:200: referenced as `enabled`
	cmplGfx/gfxlib.ci:197: referenced as `enabled`
	cmplGfx/gfxlib.ci:194: referenced as `enabled`
}
lights.enable(light: int32, on: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enable'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param on: bool (size: 4, cast: variable(bool))
.value: nfc(124)
.usages:
	cmplGfx/gfxlib.ci:203: referenced as `enable`
	cmplGfx/gfxlib.ci:200: referenced as `enable`
	cmplGfx/gfxlib.ci:197: referenced as `enable`
	cmplGfx/gfxlib.ci:194: referenced as `enable`
}
lights.position(light: int32, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'position'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.value: nfc(125)
.usages:
}
lights.ambient(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(126)
.usages:
}
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(127)
.usages:
}
lights.specular(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.value: nfc(128)
.usages:
}
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'attenuation'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param constant: float32 (size: 4, cast: variable(f32))
.param linear: float32 (size: 4, cast: variable(f32))
.param quadratic: float32 (size: 4, cast: variable(f32))
.value: nfc(129)
.usages:
}
Gui: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Gui'
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field FINGER_PRESS: int64 (size: 0, cast: static const i64)
.field FINGER_MOTION: int64 (size: 0, cast: static const i64)
.field FINGER_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_INIT: int64 (size: 0, cast: static const i64)
.field WINDOW_DRAW: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_MASK_ALT: int64 (size: 0, cast: static const i64)
.field showWindow: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
.field font: Image (size: 0, cast: static const inline)
.usages:
	cmplGfx/gfxlib.ci:290: referenced as `Gui`
	cmplGfx/gfxlib.ci:270: referenced as `Gui`
	cmplGfx/gfxlib.ci:227: referenced as `Gui`
	cmplGfx/gfxlib.ci:222: referenced as `Gui`
	cmplGfx/gfxlib.ci:186: referenced as `Gui`
	cmplGfx/gfxlib.ci:184: referenced as `Gui`
	cmplGfx/gfxlib.ci:183: referenced as `Gui`
	cmplGfx/gfxlib.ci:143: referenced as `Gui`
	cmplGfx/gfxlib.ci:118: referenced as `Gui`
	cmplGfx/gfxlib.ci:99: referenced as `Gui`
	cmplGfx/gfxlib.ci:92: referenced as `Gui`
	cmplGfx/gfxlib.ci:87: referenced as `Gui`
	cmplGfx/gfxlib.ci:83: referenced as `Gui`
	cmplGfx/gfxlib.ci:66: referenced as `Gui`
	cmplGfx/gfxlib.ci:54: referenced as `Gui`
	cmplGfx/gfxlib.ci:50: referenced as `Gui`
	cmplGfx/gfxlib.ci:45: referenced as `Gui`
	cmplGfx/gfxlib.ci:33: referenced as `Gui`
	cmplGfx/gfxlib.ci:28: referenced as `Gui`
	cmplGfx/gfxlib.ci:23: referenced as `Gui`
}
Gui.KEY_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_PRESS'
.owner: Gui
.value: 1
.usages:
	cmplGfx/gfxlib.ci:186: referenced as `KEY_PRESS`
	cmplGfx/gfxlib.ci:87: referenced as `KEY_PRESS`
	cmplGfx/gfxlib.ci:45: referenced as `KEY_PRESS`
}
Gui.KEY_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_RELEASE'
.owner: Gui
.value: 2
.usages:
	cmplGfx/gfxlib.ci:92: referenced as `KEY_RELEASE`
}
Gui.MOUSE_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_PRESS'
.owner: Gui
.value: 3
.usages:
	cmplGfx/gfxlib.ci:222: referenced as `MOUSE_PRESS`
	cmplGfx/gfxlib.ci:50: referenced as `MOUSE_PRESS`
}
Gui.MOUSE_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_MOTION'
.owner: Gui
.value: 4
.usages:
	cmplGfx/gfxlib.ci:227: referenced as `MOUSE_MOTION`
	cmplGfx/gfxlib.ci:184: referenced as `MOUSE_MOTION`
}
Gui.MOUSE_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_RELEASE'
.owner: Gui
.value: 5
.usages:
	cmplGfx/gfxlib.ci:54: referenced as `MOUSE_RELEASE`
}
Gui.FINGER_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_PRESS'
.owner: Gui
.value: 6
}
Gui.FINGER_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_MOTION'
.owner: Gui
.value: 7
.usages:
	cmplGfx/gfxlib.ci:183: referenced as `FINGER_MOTION`
}
Gui.FINGER_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_RELEASE'
.owner: Gui
.value: 8
}
Gui.EVENT_TIMEOUT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'EVENT_TIMEOUT'
.owner: Gui
.value: 10
}
Gui.WINDOW_INIT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_INIT'
.owner: Gui
.value: 100
}
Gui.WINDOW_DRAW: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_DRAW'
.owner: Gui
.value: 101
}
Gui.WINDOW_CLOSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CLOSE'
.owner: Gui
.value: 102
.usages:
	cmplGfx/gfxlib.ci:83: referenced as `WINDOW_CLOSE`
}
Gui.WINDOW_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_ENTER'
.owner: Gui
.value: 103
}
Gui.WINDOW_LEAVE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_LEAVE'
.owner: Gui
.value: 104
}
Gui.KEY_MASK_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_SHIFT'
.owner: Gui
.value: 1
}
Gui.KEY_MASK_CTRL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_CTRL'
.owner: Gui
.value: 2
}
Gui.KEY_MASK_ALT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_ALT'
.owner: Gui
.value: 4
}
Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'showWindow'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param surf: Image (size: 8, cast: variable(val))
.param closure: pointer (size: 4, cast: variable(ref))
.param onEvent: function (size: 4, cast: variable(ref))
.value: nfc(130)
.usages:
	cmplGfx/gfxlib.ci:290: referenced as `showWindow`
	cmplGfx/gfxlib.ci:143: referenced as `showWindow`
	cmplGfx/gfxlib.ci:66: referenced as `showWindow`
	cmplGfx/gfxlib.ci:33: referenced as `showWindow`
	cmplGfx/gfxlib.ci:28: referenced as `showWindow`
	cmplGfx/gfxlib.ci:23: referenced as `showWindow`
}
Gui.setTitle(title: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTitle'
.owner: Gui
.param .result: void (size: 0, cast: inline)
.param title: char[*] (size: 4, cast: const variable(ref))
.value: nfc(131)
.usages:
	cmplGfx/gfxlib.ci:270: referenced as `setTitle`
	cmplGfx/gfxlib.ci:118: referenced as `setTitle`
	cmplGfx/gfxlib.ci:99: referenced as `setTitle`
}
Gui.font: Image {
.kind: static const inline
.base: `Image`
.size: 0
.name: 'font'
.owner: Gui
.value: nfc(132)
.usages:
}
argb: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:2'
.field v: uint32 (size: 4, cast: variable(u32))
.field <?>: argb.<?> (size: 4, cast: variable(val))
.field b: uint8 (size: 0, cast: inline)
.field g: uint8 (size: 0, cast: inline)
.field r: uint8 (size: 0, cast: inline)
.field a: uint8 (size: 0, cast: inline)
.doc: 'an 32 bit argb color'
.usages:
	cmplGfx/lib/image.ci:111: referenced as `argb`
	cmplGfx/lib/image.ci:108: referenced as `argb`
	cmplGfx/lib/color.ci:261: referenced as `argb`
	cmplGfx/lib/color.ci:223: referenced as `argb`
	cmplGfx/lib/color.ci:222: referenced as `argb`
	cmplGfx/lib/color.ci:216: referenced as `argb`
	cmplGfx/lib/color.ci:174: referenced as `argb`
	cmplGfx/lib/color.ci:171: referenced as `argb`
	cmplGfx/lib/color.ci:168: referenced as `argb`
	cmplGfx/lib/color.ci:166: referenced as `argb`
	cmplGfx/lib/color.ci:164: referenced as `argb`
	cmplGfx/lib/color.ci:162: referenced as `argb`
	cmplGfx/lib/color.ci:105: referenced as `argb`
	cmplGfx/lib/color.ci:103: referenced as `argb`
}
argb.v: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'v'
.file: 'cmplGfx/lib/color.ci:4'
.owner: argb
.doc: 'value of color'
.usages:
}
argb.<?>: argb.<?> {
.kind: variable(val)
.base: `argb.<?>`
.size: 4
.name: '<?>'
.file: 'cmplGfx/lib/color.ci:272'
.owner: argb
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.field a: uint8 (size: 1, cast: variable(u32))
.usages:
}
argb.<?>.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'cmplGfx/lib/color.ci:7'
.owner: argb.<?>
.doc: 'blue component'
.usages:
}
argb.<?>.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'cmplGfx/lib/color.ci:10'
.owner: argb.<?>
.doc: 'green component'
.usages:
}
argb.<?>.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'cmplGfx/lib/color.ci:13'
.owner: argb.<?>
.doc: 'red component'
.usages:
}
argb.<?>.a: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'a'
.file: 'cmplGfx/lib/color.ci:16'
.owner: argb.<?>
.doc: 'alpha component'
.usages:
}
argb.b: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'b'
.file: 'cmplGfx/lib/color.ci:7'
.owner: argb
.doc: 'blue component'
.value: b: uint8
}
argb.g: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'g'
.file: 'cmplGfx/lib/color.ci:10'
.owner: argb
.doc: 'green component'
.value: g: uint8
}
argb.r: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'r'
.file: 'cmplGfx/lib/color.ci:13'
.owner: argb
.doc: 'red component'
.value: r: uint8
}
argb.a: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'a'
.file: 'cmplGfx/lib/color.ci:16'
.owner: argb
.doc: 'alpha component'
.value: a: uint8
}
argb(argb: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:103'
.param .result: argb (size: 4, cast: val)
.param argb: uint32 (size: 4, cast: u32)
.doc: 'cast unsigned integer to argb value'
.value: argb(emit(uint32(argb)))
.usages:
	cmplGfx/lib/color.ci:141: referenced as `argb`
	cmplGfx/lib/color.ci:139: referenced as `argb`
	cmplGfx/lib/color.ci:127: referenced as `argb`
}
uint32(value: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'uint32'
.file: 'cmplGfx/lib/color.ci:105'
.param .result: uint32 (size: 4, cast: u32)
.param value: argb (size: 4, cast: val)
.doc: 'cast argb value to unsigned integer'
.value: uint32(emit(struct(value)))
.usages:
	cmplGfx/lib/image.ci:108: referenced as `uint32`
	cmplGfx/lib/color.ci:168: referenced as `uint32`
	cmplGfx/lib/color.ci:166: referenced as `uint32`
	cmplGfx/lib/color.ci:164: referenced as `uint32`
	cmplGfx/lib/color.ci:162: referenced as `uint32`
}
clamp_s8(c: int32): uint32: function {
.kind: static function
.base: `function`
.size: 36
.name: 'clamp_s8'
.file: 'cmplGfx/lib/color.ci:109'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: int32 (size: 4, cast: variable(i32))
.doc: 'clamp signed gray or color component to fit in 8 bits (0 ... 255)'
.value: {
	if (c < 0) {
		return .result := 0;
	}
	if (c > 255) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (36 bytes)
	cmplGfx/lib/color.ci:110: (12 bytes): if (c < 0)
	<clamp_s8>  : dup.x32 sp(1)
	<clamp_s8+?>: load.z32
	<clamp_s8+?>: clt.i32
	<clamp_s8+?>: jz +8
	cmplGfx/lib/color.ci:111: (4 bytes): return .result := 0;
	<clamp_s8+?>: load.z32
	<clamp_s8+?>: set.x32 sp(3)
	<clamp_s8+?>: ret
	cmplGfx/lib/color.ci:113: (20 bytes): if (c > 255)
	<clamp_s8+?>: dup.x32 sp(1)
	<clamp_s8+?>: load.c32 255
	<clamp_s8+?>: cgt.i32
	<clamp_s8+?>: jz +12
	cmplGfx/lib/color.ci:114: (8 bytes): return .result := 255;
	<clamp_s8+?>: load.c32 255
	<clamp_s8+?>: set.x32 sp(3)
	<clamp_s8+?>: ret
	cmplGfx/lib/color.ci:116: (4 bytes): return .result := c;
	<clamp_s8+?>: mov.x32 sp(2, 1)
	<clamp_s8+?>: ret
.usages:
	cmplGfx/lib/color.ci:238: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:152: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:152: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:152: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:152: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:144: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:144: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:144: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:131: referenced as `clamp_s8`
	cmplGfx/lib/color.ci:129: referenced as `clamp_s8`
}
clamp_u8(c: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 24
.name: 'clamp_u8'
.file: 'cmplGfx/lib/color.ci:119'
.param .result: uint32 (size: 4, cast: variable(u32))
.param c: uint32 (size: 4, cast: variable(u32))
.doc: 'clamp unsigned gray or color component to fit in 8 bits (0 ... 255)'
.value: {
	if (c > (255)) {
		return .result := 255;
	}
	return .result := c;
}
.instructions: (24 bytes)
	cmplGfx/lib/color.ci:120: (20 bytes): if (c > (255))
	<clamp_u8>  : dup.x32 sp(1)
	<clamp_u8+?>: load.c32 255
	<clamp_u8+?>: cgt.u32
	<clamp_u8+?>: jz +12
	cmplGfx/lib/color.ci:121: (8 bytes): return .result := 255;
	<clamp_u8+?>: load.c32 255
	<clamp_u8+?>: set.x32 sp(3)
	<clamp_u8+?>: ret
	cmplGfx/lib/color.ci:123: (4 bytes): return .result := c;
	<clamp_u8+?>: mov.x32 sp(2, 1)
	<clamp_u8+?>: ret
.usages:
	cmplGfx/lib/color.ci:235: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:154: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:154: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:154: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:154: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:146: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:146: referenced as `clamp_u8`
	cmplGfx/lib/color.ci:146: referenced as `clamp_u8`
}
_gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_gray'
.file: 'cmplGfx/lib/color.ci:127'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: variable(u32))
.value: argb((((c << 8) | c) << 8) | c)
.usages:
	cmplGfx/lib/color.ci:131: referenced as `_gray`
	cmplGfx/lib/color.ci:129: referenced as `_gray`
}
gray(c: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:129'
.param .result: argb (size: 4, cast: val)
.param c: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: _gray(clamp_s8(c))
.usages:
	cmplGfx/lib/color.ci:135: referenced as `gray`
	cmplGfx/lib/color.ci:133: referenced as `gray`
}
gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:131'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: _gray(clamp_s8(c))
.usages:
}
gray(c: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:133'
.param .result: argb (size: 4, cast: val)
.param c: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
}
gray(c: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:135'
.param .result: argb (size: 4, cast: val)
.param c: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
}
_argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_argb'
.file: 'cmplGfx/lib/color.ci:139'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct an argb color from the given components'
.value: argb(uint32((((r << 8) | g) << 8) | b))
.usages:
	cmplGfx/lib/color.ci:146: referenced as `_argb`
	cmplGfx/lib/color.ci:144: referenced as `_argb`
}
_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: '_argb'
.file: 'cmplGfx/lib/color.ci:141'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct an argb color from the given components'
.value: argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b))
.usages:
	cmplGfx/lib/color.ci:154: referenced as `_argb`
	cmplGfx/lib/color.ci:152: referenced as `_argb`
}
argb(r: int32, g: int32, b: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:144'
.param .result: argb (size: 4, cast: val)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(clamp_s8(r), clamp_s8(g), clamp_s8(b))
.usages:
	cmplGfx/lib/color.ci:150: referenced as `argb`
	cmplGfx/lib/color.ci:148: referenced as `argb`
}
argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:146'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(clamp_u8(r), clamp_u8(g), clamp_u8(b))
.usages:
}
argb(r: float32, g: float32, b: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:148'
.param .result: argb (size: 4, cast: val)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
	cmplGfx/lib/color.ci:264: referenced as `argb`
}
argb(r: float64, g: float64, b: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:150'
.param .result: argb (size: 4, cast: val)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
}
argb(a: int32, r: int32, g: int32, b: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:152'
.param .result: argb (size: 4, cast: val)
.param a: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(clamp_s8(a), clamp_s8(r), clamp_s8(g), clamp_s8(b))
.usages:
	cmplGfx/lib/color.ci:158: referenced as `argb`
	cmplGfx/lib/color.ci:156: referenced as `argb`
}
argb(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:154'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: _argb(clamp_u8(a), clamp_u8(r), clamp_u8(g), clamp_u8(b))
.usages:
}
argb(a: float32, r: float32, g: float32, b: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:156'
.param .result: argb (size: 4, cast: val)
.param a: float32 (size: 4, cast: f32)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
}
argb(a: float64, r: float64, g: float64, b: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:158'
.param .result: argb (size: 4, cast: val)
.param a: float64 (size: 8, cast: f64)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
}
ach(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ach'
.file: 'cmplGfx/lib/color.ci:162'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Alpha channel of the color'
.value: int32((uint32(color) >> 24) & (255))
.usages:
	cmplGfx/lib/color.ci:261: referenced as `ach`
	cmplGfx/lib/color.ci:224: referenced as `ach`
	cmplGfx/lib/color.ci:224: referenced as `ach`
}
rch(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rch'
.file: 'cmplGfx/lib/color.ci:164'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Red channel of the color'
.value: int32((uint32(color) >> 16) & (255))
.usages:
	cmplGfx/lib/color.ci:261: referenced as `rch`
	cmplGfx/lib/color.ci:225: referenced as `rch`
	cmplGfx/lib/color.ci:225: referenced as `rch`
	cmplGfx/lib/color.ci:176: referenced as `rch`
	cmplGfx/lib/color.ci:171: referenced as `rch`
}
gch(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gch'
.file: 'cmplGfx/lib/color.ci:166'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Green channel of the color'
.value: int32((uint32(color) >> 8) & (255))
.usages:
	cmplGfx/lib/color.ci:261: referenced as `gch`
	cmplGfx/lib/color.ci:226: referenced as `gch`
	cmplGfx/lib/color.ci:226: referenced as `gch`
	cmplGfx/lib/color.ci:177: referenced as `gch`
	cmplGfx/lib/color.ci:171: referenced as `gch`
}
bch(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'bch'
.file: 'cmplGfx/lib/color.ci:168'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Blue channel of the color'
.value: int32(uint32(color) & (255))
.usages:
	cmplGfx/lib/color.ci:261: referenced as `bch`
	cmplGfx/lib/color.ci:227: referenced as `bch`
	cmplGfx/lib/color.ci:227: referenced as `bch`
	cmplGfx/lib/color.ci:178: referenced as `bch`
	cmplGfx/lib/color.ci:171: referenced as `bch`
}
lum(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/color.ci:171'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: variable(val))
.doc: 'get the luminosity of the color (0.299 * color.r + 0.587 * color.g + 0.114 * color.b)'
.value: int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16)
.usages:
}
hue(rgb: argb): uint32: function {
.kind: static function
.base: `function`
.size: 205
.name: 'hue'
.file: 'cmplGfx/lib/color.ci:174'
.param .result: uint32 (size: 4, cast: variable(u32))
.param rgb: argb (size: 4, cast: variable(val))
.doc: 'get the hue of the color'
.value: {
	r: int32 := rch(rgb);
	g: int32 := gch(rgb);
	b: int32 := bch(rgb);
	min: int32 := r;
	max: int32 := r;
	if (min > g) {
		min := g;
	}
	if (min > b) {
		min := b;
	}
	if (max < g) {
		max := g;
	}
	if (max < b) {
		max := b;
	}
	if (max == min) {
		return .result := 0;
	}
	hue: int32 := 0;
	if (max == r) {
		hue := ((g - b) * 60) / (max - min);
	}
	else if (max == g) {
		hue := ((b - r) * 60) / (max - min) + 120;
	}
	else if (max == b) {
		hue := ((r - g) * 60) / (max - min) + 240;
	}
	if (hue < 0) {
		hue := hue + 360;
	}
	return .result := hue;
}
.instructions: (205 bytes)
	cmplGfx/lib/color.ci:176: (6 bytes): r: int32 := rch(rgb)
	<hue>  : dup.x32 sp(1)
	<hue+?>: b32.shr 0x10
	<hue+?>: b32.and 0xff
	cmplGfx/lib/color.ci:177: (6 bytes): g: int32 := gch(rgb)
	<hue+?>: dup.x32 sp(2)
	<hue+?>: b32.shr 0x08
	<hue+?>: b32.and 0xff
	cmplGfx/lib/color.ci:178: (4 bytes): b: int32 := bch(rgb)
	<hue+?>: dup.x32 sp(3)
	<hue+?>: b32.and 0xff
	cmplGfx/lib/color.ci:179: (2 bytes): min: int32 := r
	<hue+?>: dup.x32 sp(2)
	cmplGfx/lib/color.ci:180: (2 bytes): max: int32 := r
	<hue+?>: dup.x32 sp(3)
	cmplGfx/lib/color.ci:182: (12 bytes): if (min > g)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: cgt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:183: (3 bytes): min := g;
	<hue+?>: mov.x32 sp(1, 3)
	cmplGfx/lib/color.ci:185: (12 bytes): if (min > b)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(3)
	<hue+?>: cgt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:186: (3 bytes): min := b;
	<hue+?>: mov.x32 sp(1, 2)
	cmplGfx/lib/color.ci:188: (12 bytes): if (max < g)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: clt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:189: (3 bytes): max := g;
	<hue+?>: mov.x32 sp(0, 3)
	cmplGfx/lib/color.ci:191: (12 bytes): if (max < b)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: dup.x32 sp(3)
	<hue+?>: clt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:192: (3 bytes): max := b;
	<hue+?>: mov.x32 sp(0, 2)
	cmplGfx/lib/color.ci:195: (17 bytes): if (max == min)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: dup.x32 sp(2)
	<hue+?>: ceq.i32
	<hue+?>: jz +12
	cmplGfx/lib/color.ci:196: (8 bytes): return .result := 0;
	<hue+?>: load.z32
	<hue+?>: set.x32 sp(8)
	<hue+?>: inc.sp(-20)
	<hue+?>: ret
	cmplGfx/lib/color.ci:199: (1 byte): hue: int32 := 0
	<hue+?>: load.z32
	cmplGfx/lib/color.ci:200: (100 bytes): if (max == r)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(6)
	<hue+?>: ceq.i32
	<hue+?>: jz +27
	cmplGfx/lib/color.ci:201: (19 bytes): hue := ((g - b) * 60) / (max - min);
	<hue+?>: dup.x32 sp(4)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: load.c32 60
	<hue+?>: mul.i32
	<hue+?>: dup.x32 sp(2)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: div.i32
	<hue+?>: set.x32 sp(1)
	<hue+?>: jmp +72
	cmplGfx/lib/color.ci:203: (68 bytes): if (max == g)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(5)
	<hue+?>: ceq.i32
	<hue+?>: jz +31
	cmplGfx/lib/color.ci:204: (23 bytes): hue := ((b - r) * 60) / (max - min) + 120;
	<hue+?>: dup.x32 sp(3)
	<hue+?>: dup.x32 sp(6)
	<hue+?>: sub.i32
	<hue+?>: load.c32 60
	<hue+?>: mul.i32
	<hue+?>: dup.x32 sp(2)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: div.i32
	<hue+?>: inc.i32(+120)
	<hue+?>: set.x32 sp(1)
	<hue+?>: jmp +36
	cmplGfx/lib/color.ci:206: (32 bytes): if (max == b)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: ceq.i32
	<hue+?>: jz +27
	cmplGfx/lib/color.ci:207: (23 bytes): hue := ((r - g) * 60) / (max - min) + 240;
	<hue+?>: dup.x32 sp(5)
	<hue+?>: dup.x32 sp(5)
	<hue+?>: sub.i32
	<hue+?>: load.c32 60
	<hue+?>: mul.i32
	<hue+?>: dup.x32 sp(2)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: div.i32
	<hue+?>: inc.i32(+240)
	<hue+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:209: (12 bytes): if (hue < 0)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: load.z32
	<hue+?>: clt.i32
	<hue+?>: jz +8
	cmplGfx/lib/color.ci:210: (4 bytes): hue := hue + 360;
	<hue+?>: inc.i32(+360)
	cmplGfx/lib/color.ci:212: (7 bytes): return .result := hue;
	<hue+?>: set.x32 sp(8)
	<hue+?>: inc.sp(-20)
	<hue+?>: ret
.usages:
}
lerpLut(lut: uint32[], colors: argb[]): void: function {
.kind: static function
.base: `function`
.size: 223
.name: 'lerpLut'
.file: 'cmplGfx/lib/color.ci:216'
.param .result: void (size: 0, cast: variable(void))
.param lut: uint32[] (size: 8, cast: variable(arr))
.param colors: argb[] (size: 8, cast: variable(arr))
.doc: 'linear interpolate a lookup-table with the given colors'
.value: {
	lrp(t: int32, x: uint32, y: uint32): uint32 := x + ((t * ((y - x + (1))) >> 16));
	dt: int32 := (colors.length - (1) << 16) / (lut.length - (1));
	for (i: int32 := 0; i < (lut.length); i := i + 1) {
		t: int32 := i * dt;
		c1: argb := colors[t >> 16];
		c2: argb := colors[(t >> 16) + 1];
		a: int32 := lrp(t & 65535, ach(c1), ach(c2));
		r: int32 := lrp(t & 65535, rch(c1), rch(c2));
		g: int32 := lrp(t & 65535, gch(c1), gch(c2));
		b: int32 := lrp(t & 65535, bch(c1), bch(c2));
		lut[i] := (a << 24 | r << 16 | g << 8 | b);
	}
}
.instructions: (223 bytes)
	cmplGfx/lib/color.ci:219: (15 bytes): dt: int32 := (colors.length - (1) << 16) / (lut.length - (1))
	<lerpLut>  : dup.x32 sp(2)
	<lerpLut+?>: inc.i32(-1)
	<lerpLut+?>: b32.shl 0x10
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: inc.i32(-1)
	<lerpLut+?>: div.u32
	cmplGfx/lib/color.ci:220: (203 bytes): for (i: int32 := 0; i < (lut.length); i := i + 1)
	<lerpLut+?>: load.z32
	<lerpLut+?>: jmp +189
	cmplGfx/lib/color.ci:221: (5 bytes): t: int32 := i * dt
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: mul.i32
	cmplGfx/lib/color.ci:222: (11 bytes): c1: argb := colors[t >> 16]
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: load.i32
	cmplGfx/lib/color.ci:223: (15 bytes): c2: argb := colors[(t >> 16) + 1]
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: load.i32
	cmplGfx/lib/color.ci:224: (31 bytes): a: int32 := lrp(t & 65535, ach(c1), ach(c2))
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: b32.shr 0x18
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shr 0x18
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:225: (31 bytes): r: int32 := lrp(t & 65535, rch(c1), rch(c2))
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.shr 0x10
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: b32.shr 0x10
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:226: (31 bytes): g: int32 := lrp(t & 65535, gch(c1), gch(c2))
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shr 0x08
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(6)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: b32.shr 0x08
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:227: (27 bytes): b: int32 := lrp(t & 65535, bch(c1), bch(c2))
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(7)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(6)
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:228: (26 bytes): lut[i] := (a << 24 | r << 16 | g << 8 | b);
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shl 0x18
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shl 0x10
	<lerpLut+?>: or.b32
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.shl 0x08
	<lerpLut+?>: or.b32
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: or.b32
	<lerpLut+?>: dup.x32 sp(13)
	<lerpLut+?>: dup.x32 sp(9)
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: store.i32
	<lerpLut+?>: inc.sp(-28)
	cmplGfx/lib/color.ci:220: (4 bytes): i := i + 1
	<lerpLut+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:220: (9 bytes): i < (lut.length)
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(7)
	<lerpLut+?>: clt.i32
	<lerpLut+?>: jnz -190
	<lerpLut+?>: inc.sp(-4)
	<lerpLut+?>: inc.sp(-4)
	<lerpLut+?>: ret
.usages:
}
alphaLut(lut: uint32[], hardness: int32, alpha: int32, reflect: bool): void: function {
.kind: static function
.base: `function`
.size: 347
.name: 'alphaLut'
.file: 'cmplGfx/lib/color.ci:233'
.param .result: void (size: 0, cast: variable(void))
.param lut: uint32[] (size: 8, cast: variable(arr))
.param hardness: int32 (size: 4, cast: variable(i32))
.param alpha: int32 (size: 4, cast: variable(i32))
.param reflect: bool (size: 4, cast: variable(bool))
.doc: 'linear interpolate a alpha lookup-table with the given colors'
.value: {
	mid: int32 := hardness <= 0 ? -1 : 255;
	div: int32 := 256 - (clamp_u8(hardness < 0 ? -hardness : hardness));
	for (i: int32 := 0; i < (lut.length); i := i + 1) {
		t: int32 := i * 255 / ((lut.length - (1)));
		lut[i] := clamp_s8((t - mid) * 255 / div + mid);
		if (alpha < 0) {
			lut[i] := (255 - (255 - (lut[i])) * -alpha / 255);
		}
		else {
			lut[i] := (255 - (lut[i] * (alpha) / (255)));
		}
	}
	if (reflect) {
		end: int32 := lut.length - (1);
		mid: int32 := lut.length / (2);
		for (i: int32 := end; i >= mid; i := i - 1) {
			lut[i] := lut[end];
			end := end - 2;
		}
		for (i: int32 := 0; i < mid; i := i + 1) {
			lut[i] := lut[lut.length - (i) - (1)];
		}
	}
}
.instructions: (347 bytes)
	cmplGfx/lib/color.ci:234: (22 bytes): mid: int32 := hardness <= 0 ? -1 : 255
	<alphaLut>  : dup.x32 sp(3)
	<alphaLut+?>: load.z32
	<alphaLut+?>: cgt.i32
	<alphaLut+?>: jnz +13
	<alphaLut+?>: load.c32 -1
	<alphaLut+?>: jmp +9
	<alphaLut+?>: load.c32 255
	cmplGfx/lib/color.ci:235: (34 bytes): div: int32 := 256 - (clamp_u8(hardness < 0 ? -hardness : hardness))
	<alphaLut+?>: load.c32 256
	<alphaLut+?>: load.z32
	<alphaLut+?>: dup.x32 sp(6)
	<alphaLut+?>: load.z32
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz +11
	<alphaLut+?>: dup.x32 sp(6)
	<alphaLut+?>: neg.i32
	<alphaLut+?>: jmp +6
	<alphaLut+?>: dup.x32 sp(6)
	<alphaLut+?>: load.ref <?> ;clamp_u8(c: uint32): uint32
	<alphaLut+?>: call
	<alphaLut+?>: inc.sp(-4)
	<alphaLut+?>: sub.i32
	cmplGfx/lib/color.ci:236: (163 bytes): for (i: int32 := 0; i < (lut.length); i := i + 1)
	<alphaLut+?>: load.z32
	<alphaLut+?>: jmp +149
	cmplGfx/lib/color.ci:237: (15 bytes): t: int32 := i * 255 / ((lut.length - (1)))
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: mul.i32
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: inc.i32(-1)
	<alphaLut+?>: div.i32
	cmplGfx/lib/color.ci:238: (37 bytes): lut[i] := clamp_s8((t - mid) * 255 / div + mid);
	<alphaLut+?>: load.z32
	<alphaLut+?>: dup.x32 sp(1)
	<alphaLut+?>: dup.x32 sp(5)
	<alphaLut+?>: sub.i32
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: mul.i32
	<alphaLut+?>: dup.x32 sp(4)
	<alphaLut+?>: div.i32
	<alphaLut+?>: dup.x32 sp(5)
	<alphaLut+?>: add.i32
	<alphaLut+?>: load.ref <?> ;clamp_s8(c: int32): uint32
	<alphaLut+?>: call
	<alphaLut+?>: inc.sp(-4)
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	cmplGfx/lib/color.ci:239: (85 bytes): if (alpha < 0)
	<alphaLut+?>: dup.x32 sp(6)
	<alphaLut+?>: load.z32
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz +48
	cmplGfx/lib/color.ci:240: (40 bytes): lut[i] := (255 - (255 - (lut[i])) * -alpha / 255);
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: dup.x32 sp(10)
	<alphaLut+?>: dup.x32 sp(4)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: sub.i32
	<alphaLut+?>: dup.x32 sp(8)
	<alphaLut+?>: neg.i32
	<alphaLut+?>: mul.i32
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: div.i32
	<alphaLut+?>: sub.i32
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	<alphaLut+?>: jmp +37
	cmplGfx/lib/color.ci:242: (33 bytes): lut[i] := (255 - (lut[i] * (alpha) / (255)));
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: dup.x32 sp(8)
	<alphaLut+?>: mul.u32
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: div.u32
	<alphaLut+?>: sub.i32
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	<alphaLut+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:236: (4 bytes): i := i + 1
	<alphaLut+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:236: (9 bytes): i < (lut.length)
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jnz -150
	<alphaLut+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:245: (123 bytes): if (reflect)
	<alphaLut+?>: load.sp(+12)
	<alphaLut+?>: load.i8
	<alphaLut+?>: jz +118
	cmplGfx/lib/color.ci:246: (6 bytes): end: int32 := lut.length - (1)
	<alphaLut+?>: dup.x32 sp(7)
	<alphaLut+?>: inc.i32(-1)
	cmplGfx/lib/color.ci:247: (8 bytes): mid: int32 := lut.length / (2)
	<alphaLut+?>: dup.x32 sp(8)
	<alphaLut+?>: load.c32 2
	<alphaLut+?>: div.u32
	cmplGfx/lib/color.ci:248: (49 bytes): for (i: int32 := end; i >= mid; i := i - 1)
	<alphaLut+?>: dup.x32 sp(1)
	<alphaLut+?>: jmp +34
	cmplGfx/lib/color.ci:249: (18 bytes): lut[i] := lut[end];
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: dup.x32 sp(10)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	cmplGfx/lib/color.ci:250: (8 bytes): end := end - 2;
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: inc.i32(-2)
	<alphaLut+?>: set.x32 sp(3)
	cmplGfx/lib/color.ci:248: (4 bytes): i := i - 1
	<alphaLut+?>: inc.i32(-1)
	cmplGfx/lib/color.ci:248: (9 bytes): i >= mid
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz -35
	<alphaLut+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:252: (47 bytes): for (i: int32 := 0; i < mid; i := i + 1)
	<alphaLut+?>: load.z32
	<alphaLut+?>: jmp +33
	cmplGfx/lib/color.ci:253: (25 bytes): lut[i] := lut[lut.length - (i) - (1)];
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(11)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: sub.i32
	<alphaLut+?>: inc.i32(-1)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: dup.x32 sp(10)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	cmplGfx/lib/color.ci:252: (4 bytes): i := i + 1
	<alphaLut+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:252: (9 bytes): i < mid
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jnz -34
	<alphaLut+?>: inc.sp(-4)
	<alphaLut+?>: inc.sp(-8)
	<alphaLut+?>: inc.sp(-8)
	<alphaLut+?>: ret
.usages:
}
vec4f(rgb: argb): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplGfx/lib/color.ci:261'
.param .result: vec4f (size: 16, cast: val)
.param rgb: argb (size: 4, cast: variable(val))
.doc: 'convert an argb color to a floating point vector'
.value: vec4f((rch(rgb)) / 255.000000, (gch(rgb)) / 255.000000, (bch(rgb)) / 255.000000, (ach(rgb)) / 255.000000)
.usages:
}
argb(vec: vec4f): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:264'
.param .result: argb (size: 4, cast: val)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'convert a floating point vector to an argb color'
.value: argb(vec.x, vec.y, vec.z)
.usages:
	cmplGfx/lib/image.ci:196: referenced as `argb`
}
lum(vec: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/color.ci:267'
.param .result: float32 (size: 4, cast: f32)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'calculate the luminosity of a color'
.value: 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z
.usages:
}
hsv2rgb(hsv: vec4f): vec4f: function {
.kind: static function
.base: `function`
.size: 270
.name: 'hsv2rgb'
.file: 'cmplGfx/lib/color.hsv.ci:2'
.param .result: vec4f (size: 16, cast: variable(val))
.param hsv: vec4f (size: 16, cast: variable(val))
.doc: 'convert from hsv color space to rgb color space'
.value: {
	h: float32 := hsv.x;
	s: float32 := hsv.y;
	v: float32 := hsv.z;
	if (s == (0)) {
		return .result := vec4f(v);
	}
	h := h * (360 / 60);
	i: int32 := int32(h);
	f: float32 := h - (i);
	u: float32 := v;
	p: float32 := v * ((1) - s);
	q: float32 := v * ((1) - s * f);
	t: float32 := v * ((1) - s * ((1) - f));
	if (i == 0) {
		return .result := vec4f(u, t, p);
	}
	if (i == 1) {
		return .result := vec4f(q, u, p);
	}
	if (i == 2) {
		return .result := vec4f(p, u, t);
	}
	if (i == 3) {
		return .result := vec4f(p, q, u);
	}
	if (i == 4) {
		return .result := vec4f(t, p, u);
	}
	return .result := vec4f(u, p, q);
}
.instructions: (270 bytes)
	cmplGfx/lib/color.hsv.ci:3: (2 bytes): h: float32 := hsv.x
	<hsv2rgb>  : dup.x32 sp(1)
	cmplGfx/lib/color.hsv.ci:4: (2 bytes): s: float32 := hsv.y
	<hsv2rgb+?>: dup.x32 sp(3)
	cmplGfx/lib/color.hsv.ci:5: (2 bytes): v: float32 := hsv.z
	<hsv2rgb+?>: dup.x32 sp(5)
	cmplGfx/lib/color.hsv.ci:7: (27 bytes): if (s == (0))
	<hsv2rgb+?>: dup.x32 sp(1)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.f32
	<hsv2rgb+?>: jz +23
	cmplGfx/lib/color.hsv.ci:8: (19 bytes): return .result := vec4f(v);
	<hsv2rgb+?>: dup.x32 sp(0)
	<hsv2rgb+?>: dup.x32 sp(0)
	<hsv2rgb+?>: dup.x32 sp(1)
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: set.x128 sp(1)
	<hsv2rgb+?>: set.x128 sp(12)
	<hsv2rgb+?>: inc.sp(-12)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.hsv.ci:11: (17 bytes): h := h * (360 / 60);
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: load.c32 360
	<hsv2rgb+?>: load.c32 60
	<hsv2rgb+?>: div.i32
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: set.x32 sp(3)
	cmplGfx/lib/color.hsv.ci:13: (3 bytes): i: int32 := int32(h)
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: f32.2i32
	cmplGfx/lib/color.hsv.ci:14: (6 bytes): f: float32 := h - (i)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: dup.x32 sp(1)
	<hsv2rgb+?>: i32.2f32
	<hsv2rgb+?>: sub.f32
	cmplGfx/lib/color.hsv.ci:16: (2 bytes): u: float32 := v
	<hsv2rgb+?>: dup.x32 sp(2)
	cmplGfx/lib/color.hsv.ci:17: (11 bytes): p: float32 := v * ((1) - s)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/lib/color.hsv.ci:18: (14 bytes): q: float32 := v * ((1) - s * f)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/lib/color.hsv.ci:19: (20 bytes): t: float32 := v * ((1) - s * ((1) - f))
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(8)
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(7)
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	<hsv2rgb+?>: sub.f32
	<hsv2rgb+?>: mul.f32
	cmplGfx/lib/color.hsv.ci:21: (26 bytes): if (i == 0)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.z32
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +22
	cmplGfx/lib/color.hsv.ci:22: (18 bytes): return .result := vec4f(u, t, p);
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.hsv.ci:24: (30 bytes): if (i == 1)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 1
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +22
	cmplGfx/lib/color.hsv.ci:25: (18 bytes): return .result := vec4f(q, u, p);
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.hsv.ci:27: (30 bytes): if (i == 2)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 2
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +22
	cmplGfx/lib/color.hsv.ci:28: (18 bytes): return .result := vec4f(p, u, t);
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(1)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.hsv.ci:30: (30 bytes): if (i == 3)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 3
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +22
	cmplGfx/lib/color.hsv.ci:31: (18 bytes): return .result := vec4f(p, q, u);
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.hsv.ci:33: (30 bytes): if (i == 4)
	<hsv2rgb+?>: dup.x32 sp(5)
	<hsv2rgb+?>: load.c32 4
	<hsv2rgb+?>: ceq.i32
	<hsv2rgb+?>: jz +22
	cmplGfx/lib/color.hsv.ci:34: (18 bytes): return .result := vec4f(t, p, u);
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: dup.x32 sp(3)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
	cmplGfx/lib/color.hsv.ci:36: (18 bytes): return .result := vec4f(u, p, q);
	<hsv2rgb+?>: load.f32 1.000000
	<hsv2rgb+?>: dup.x32 sp(2)
	<hsv2rgb+?>: dup.x32 sp(4)
	<hsv2rgb+?>: dup.x32 sp(6)
	<hsv2rgb+?>: set.x128 sp(18)
	<hsv2rgb+?>: inc.sp(-36)
	<hsv2rgb+?>: ret
.usages:
}
rgb2hsl(rgb: vec4f): vec4f: function {
.kind: static function
.base: `function`
.size: 544
.name: 'rgb2hsl'
.file: 'cmplGfx/lib/color.hsl.ci:3'
.param .result: vec4f (size: 16, cast: variable(val))
.param rgb: vec4f (size: 16, cast: variable(val))
.doc: 'Convert color from Rgb color space to Hsl color space'
.value: {
	min(x: float32, y: float32): float32 := x < y ? x : y;
	max(x: float32, y: float32): float32 := x > y ? x : y;
	clamp(value: float32, min: float32, max: float32): float32 := min(max(value, min), max);
	fmin: float32 := min(min(rgb.x, rgb.y), rgb.z);
	fmax: float32 := max(max(rgb.x, rgb.y), rgb.z);
	delta: float32 := fmax - fmin;
	lum: float32 := (fmax + fmin) / (2);
	if (delta == (0)) {
		return .result := {
			.result.x := (0);
			.result.y := (0);
			.result.z := lum;
		};
	}
	sat: float32;
	if (lum < 0.500000) {
		sat := delta / (fmax + fmin);
	}
	else {
		sat := delta / ((2) - fmax - fmin);
	}
	deltaR: float32 := (((fmax - rgb.x) / (6)) + (delta / (2))) / delta;
	deltaG: float32 := (((fmax - rgb.y) / (6)) + (delta / (2))) / delta;
	deltaB: float32 := (((fmax - rgb.z) / (6)) + (delta / (2))) / delta;
	hue: float32;
	if (rgb.x == fmax) {
		hue := deltaB - deltaG;
	}
	else if (rgb.y == fmax) {
		hue := ((1) / 3.000000) + deltaR - deltaB;
	}
	else if (rgb.z == fmax) {
		hue := ((2) / 3.000000) + deltaG - deltaR;
	}
	if (hue < (0)) {
		hue := hue + (1);
	}
	else if (hue > (1)) {
		hue := hue - (1);
	}
	return .result := {
			.result.x := clamp(hue, 0, 1);
			.result.y := clamp(sat, 0, 1);
			.result.z := clamp(lum, 0, 1);
		};
}
.instructions: (544 bytes)
	cmplGfx/lib/color.hsl.ci:7: (52 bytes): fmin: float32 := min(min(rgb.x, rgb.y), rgb.z)
	<rgb2hsl>  : dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	cmplGfx/lib/color.hsl.ci:8: (52 bytes): fmax: float32 := max(max(rgb.x, rgb.y), rgb.z)
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	cmplGfx/lib/color.hsl.ci:9: (5 bytes): delta: float32 := fmax - fmin
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: sub.f32
	cmplGfx/lib/color.hsl.ci:12: (11 bytes): lum: float32 := (fmax + fmin) / (2)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:14: (22 bytes): if (delta == (0))
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +18
	cmplGfx/lib/color.hsl.ci:16: (14 bytes): return .result := {...};
	cmplGfx/lib/color.hsl.ci:17: (3 bytes): .result.x := (0);
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: set.x32 sp(10)
	cmplGfx/lib/color.hsl.ci:18: (3 bytes): .result.y := (0);
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: set.x32 sp(11)
	cmplGfx/lib/color.hsl.ci:19: (3 bytes): .result.z := lum;
	<rgb2hsl+?>: mov.x32 sp(11, 0)
	<rgb2hsl+?>: inc.sp(-16)
	<rgb2hsl+?>: ret
	cmplGfx/lib/color.hsl.ci:24: (1 byte): sat: float32
	<rgb2hsl+?>: load.z32
	cmplGfx/lib/color.hsl.ci:25: (42 bytes): if (lum < 0.500000)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: load.f32 0.500000
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +18
	cmplGfx/lib/color.hsl.ci:26: (10 bytes): sat := delta / (fmax + fmin);
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(6)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: set.x32 sp(1)
	<rgb2hsl+?>: jmp +20
	cmplGfx/lib/color.hsl.ci:28: (16 bytes): sat := delta / ((2) - fmax - fmin);
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: dup.x32 sp(6)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: set.x32 sp(1)
	cmplGfx/lib/color.hsl.ci:31: (23 bytes): deltaR: float32 := (((fmax - rgb.x) / (6)) + (delta / (2))) / delta
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: dup.x32 sp(7)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: load.f32 6.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:32: (23 bytes): deltaG: float32 := (((fmax - rgb.y) / (6)) + (delta / (2))) / delta
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(9)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: load.f32 6.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:33: (23 bytes): deltaB: float32 := (((fmax - rgb.z) / (6)) + (delta / (2))) / delta
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: dup.x32 sp(11)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: load.f32 6.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:35: (1 byte): hue: float32
	<rgb2hsl+?>: load.z32
	cmplGfx/lib/color.hsl.ci:36: (80 bytes): if (rgb.x == fmax)
	<rgb2hsl+?>: dup.x32 sp(10)
	<rgb2hsl+?>: dup.x32 sp(8)
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +15
	cmplGfx/lib/color.hsl.ci:37: (7 bytes): hue := deltaB - deltaG;
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: set.x32 sp(1)
	<rgb2hsl+?>: jmp +64
	cmplGfx/lib/color.hsl.ci:39: (60 bytes): if (rgb.y == fmax)
	<rgb2hsl+?>: dup.x32 sp(11)
	<rgb2hsl+?>: dup.x32 sp(8)
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +27
	cmplGfx/lib/color.hsl.ci:40: (19 bytes): hue := ((1) / 3.000000) + deltaR - deltaB;
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: load.f32 3.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: set.x32 sp(1)
	<rgb2hsl+?>: jmp +32
	cmplGfx/lib/color.hsl.ci:42: (28 bytes): if (rgb.z == fmax)
	<rgb2hsl+?>: dup.x32 sp(12)
	<rgb2hsl+?>: dup.x32 sp(8)
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +23
	cmplGfx/lib/color.hsl.ci:43: (19 bytes): hue := ((2) / 3.000000) + deltaG - deltaR;
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: load.f32 3.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: set.x32 sp(1)
	cmplGfx/lib/color.hsl.ci:46: (36 bytes): if (hue < (0))
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +14
	cmplGfx/lib/color.hsl.ci:47: (6 bytes): hue := hue + (1);
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: jmp +22
	cmplGfx/lib/color.hsl.ci:49: (18 bytes): if (hue > (1))
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	cmplGfx/lib/color.hsl.ci:50: (6 bytes): hue := hue - (1);
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: sub.f32
	cmplGfx/lib/color.hsl.ci:53: (173 bytes): return .result := {...};
	cmplGfx/lib/color.hsl.ci:54: (56 bytes): .result.x := clamp(hue, 0, 1);
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: set.x32 sp(15)
	cmplGfx/lib/color.hsl.ci:55: (56 bytes): .result.y := clamp(sat, 0, 1);
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: set.x32 sp(16)
	cmplGfx/lib/color.hsl.ci:56: (56 bytes): .result.z := clamp(lum, 0, 1);
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: set.x32 sp(2)
	<rgb2hsl+?>: inc.sp(-4)
	<rgb2hsl+?>: set.x32 sp(17)
	<rgb2hsl+?>: inc.sp(-36)
	<rgb2hsl+?>: ret
.usages:
}
hsl2rgb(hsl: vec4f): vec4f: function {
.kind: static function
.base: `function`
.size: 163
.name: 'hsl2rgb'
.file: 'cmplGfx/lib/color.hsl.ci:61'
.param .result: vec4f (size: 16, cast: variable(val))
.param hsl: vec4f (size: 16, cast: variable(val))
.doc: 'Convert color from Hsl color space to Rgb color space'
.value: {
	static hue2rgb(f1: float32, f2: float32, hue: float32): float32 := {
		if (hue < (0)) {
			hue := hue + (1);
		}
		else if (hue > (1)) {
			hue := hue - (1);
		}
		res: float32;
		if (((6) * hue) < (1)) {
			res := f1 + (f2 - f1) * (6) * hue;
		}
		else if (((2) * hue) < (1)) {
			res := f2;
		}
		else if (((3) * hue) < (2)) {
			res := f1 + (f2 - f1) * (((2) / 3.000000) - hue) * (6);
		}
		else {
			res := f1;
		}
		return .result := res;
	};
	if (hsl.y == (0)) {
		return .result := vec4f(hsl.z);
	}
	f2: float32;
	if (hsl.z < 0.500000) {
		f2 := hsl.z * ((1) + hsl.y);
	}
	else {
		f2 := (hsl.z + hsl.y) - (hsl.y * hsl.z);
	}
	f1: float32 := (2) * hsl.z - f2;
	return .result := {
			.result.x := hue2rgb(f1, f2, hsl.x + ((1) / 3.000000));
			.result.y := hue2rgb(f1, f2, hsl.x);
			.result.z := hue2rgb(f1, f2, hsl.x - ((1) / 3.000000));
		};
}
.instructions: (163 bytes)
	cmplGfx/lib/color.hsl.ci:85: (23 bytes): if (hsl.y == (0))
	<hsl2rgb>  : dup.x32 sp(2)
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: ceq.f32
	<hsl2rgb+?>: jz +19
	cmplGfx/lib/color.hsl.ci:86: (15 bytes): return .result := vec4f(hsl.z);
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(0)
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(2)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: set.x128 sp(1)
	<hsl2rgb+?>: set.x128 sp(9)
	<hsl2rgb+?>: ret
	cmplGfx/lib/color.hsl.ci:89: (1 byte): f2: float32
	<hsl2rgb+?>: load.z32
	cmplGfx/lib/color.hsl.ci:90: (42 bytes): if (hsl.z < 0.500000)
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: load.f32 0.500000
	<hsl2rgb+?>: clt.f32
	<hsl2rgb+?>: jz +21
	cmplGfx/lib/color.hsl.ci:91: (13 bytes): f2 := hsl.z * ((1) + hsl.y);
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: load.f32 1.000000
	<hsl2rgb+?>: dup.x32 sp(5)
	<hsl2rgb+?>: add.f32
	<hsl2rgb+?>: mul.f32
	<hsl2rgb+?>: set.x32 sp(1)
	<hsl2rgb+?>: jmp +17
	cmplGfx/lib/color.hsl.ci:94: (13 bytes): f2 := (hsl.z + hsl.y) - (hsl.y * hsl.z);
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: add.f32
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: mul.f32
	<hsl2rgb+?>: sub.f32
	<hsl2rgb+?>: set.x32 sp(1)
	cmplGfx/lib/color.hsl.ci:97: (11 bytes): f1: float32 := (2) * hsl.z - f2
	<hsl2rgb+?>: load.f32 2.000000
	<hsl2rgb+?>: dup.x32 sp(5)
	<hsl2rgb+?>: mul.f32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: sub.f32
	cmplGfx/lib/color.hsl.ci:98: (86 bytes): return .result := {...};
	cmplGfx/lib/color.hsl.ci:99: (31 bytes): .result.x := hue2rgb(f1, f2, hsl.x + ((1) / 3.000000));
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: load.f32 1.000000
	<hsl2rgb+?>: load.f32 3.000000
	<hsl2rgb+?>: div.f32
	<hsl2rgb+?>: add.f32
	<hsl2rgb+?>: load.ref <?> ;hsl2rgb.hue2rgb(f1: float32, f2: float32, hue: float32): float32
	<hsl2rgb+?>: call
	<hsl2rgb+?>: inc.sp(-12)
	<hsl2rgb+?>: set.x32 sp(8)
	cmplGfx/lib/color.hsl.ci:100: (19 bytes): .result.y := hue2rgb(f1, f2, hsl.x);
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: load.ref <?> ;hsl2rgb.hue2rgb(f1: float32, f2: float32, hue: float32): float32
	<hsl2rgb+?>: call
	<hsl2rgb+?>: inc.sp(-12)
	<hsl2rgb+?>: set.x32 sp(9)
	cmplGfx/lib/color.hsl.ci:101: (31 bytes): .result.z := hue2rgb(f1, f2, hsl.x - ((1) / 3.000000));
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: load.f32 1.000000
	<hsl2rgb+?>: load.f32 3.000000
	<hsl2rgb+?>: div.f32
	<hsl2rgb+?>: sub.f32
	<hsl2rgb+?>: load.ref <?> ;hsl2rgb.hue2rgb(f1: float32, f2: float32, hue: float32): float32
	<hsl2rgb+?>: call
	<hsl2rgb+?>: inc.sp(-12)
	<hsl2rgb+?>: set.x32 sp(10)
	<hsl2rgb+?>: inc.sp(-8)
	<hsl2rgb+?>: ret
.usages:
}
Image(width: int32, height: int32, depth: int32): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:2'
.param .result: Image (size: 8, cast: val)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create an image with the given with, height and depth'
.value: Image.create(width, height, depth)
.usages:
	cmplGfx/gfxlib.ci:139: referenced as `Image`
	cmplGfx/gfxlib.ci:138: referenced as `Image`
	cmplGfx/gfxlib.ci:130: referenced as `Image`
	cmplGfx/lib/image.ci:117: referenced as `Image`
	cmplGfx/lib/image.ci:26: referenced as `Image`
}
Image(copy: Image): Image: function {
.kind: static function
.base: `function`
.size: 40
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:5'
.param .result: Image (size: 8, cast: variable(val))
.param copy: Image (size: 8, cast: variable(val))
.doc: 'Create an image by copying another one'
.value: {
	result: Image := Image.create(copy.width(copy), copy.height(copy), copy.depth(copy));
	result.copy(result, 0, 0, copy, null);
	return .result := result;
}
.instructions: (40 bytes)
	cmplGfx/lib/image.ci:6: (22 bytes): result: Image := Image.create(copy.width(copy), copy.height(copy), copy.depth(copy))
	<Image>  : dup.x64 sp(1)
	<Image+?>: nfc(95) ;Image.width(image: Image): int32
	<Image+?>: dup.x64 sp(2)
	<Image+?>: nfc(96) ;Image.height(image: Image): int32
	<Image+?>: dup.x64 sp(3)
	<Image+?>: nfc(97) ;Image.depth(image: Image): int32
	<Image+?>: nfc(83) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/image.ci:7: (15 bytes): result.copy(result, 0, 0, copy, null);
	<Image+?>: dup.x64 sp(0)
	<Image+?>: load.z32
	<Image+?>: load.z32
	<Image+?>: dup.x64 sp(7)
	<Image+?>: load.ref <?> ;null
	<Image+?>: nfc(111) ;Image.copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void
	cmplGfx/lib/image.ci:8: (3 bytes): return .result := result;
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
.usages:
	cmplGfx/gfxlib.ci:62: referenced as `Image`
}
Image(image: Image, width: int32, height: int32, align: int32, maxScale: float64): Image: function {
.kind: static function
.base: `function`
.size: 565
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:12'
.param .result: Image (size: 8, cast: variable(val))
.param image: Image (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param align: int32 (size: 4, cast: variable(i32))
.param maxScale: float64 (size: 8, cast: variable(f64))
.doc: 'Create an image by copying another one using a custom width and height'
.value: {
	scale: float64 := 1;
	result: Image := Image(width, height, image.depth(image));
	alignVertical: int32 := align & fitVertical;
	alignHorizontal: int32 := align & fitHorizontal;
	fitWidth: bool := alignVertical == fitVertical;
	fitHeight: bool := alignHorizontal == fitHorizontal;
	if (fitWidth && fitHeight) {
		widthScale: float64 := (width) / float64(image.width(image));
		heightScale: float64 := (height) / float64(image.height(image));
		if (align & fill) {
			scale := Math.max(widthScale, heightScale);
		}
		else {
			scale := Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale := (width) / float64(image.width(image));
	}
	else if (fitHeight) {
		scale := (height) / float64(image.height(image));
	}
	if (scale > maxScale) {
		scale := maxScale;
	}
	tx: float64 := 0;
	if (fitWidth || alignVertical == center) {
		tx := ((width) - (image.width(image)) * scale) / (2);
	}
	else if (alignVertical == right) {
		tx := ((width) - (image.width(image)) * scale);
	}
	ty: float64 := 0;
	if (fitHeight || alignHorizontal == center) {
		ty := ((height) - (image.height(image)) * scale) / (2);
	}
	else if (alignHorizontal == bottom) {
		ty := ((height) - (image.height(image)) * scale);
	}
	mat: mat4f := {
		mat.x.x := ((1) / scale);
		mat.x.y := (0);
		mat.x.z := (0);
		mat.x.w := (-tx / scale);
		mat.y.x := (0);
		mat.y.y := ((1) / scale);
		mat.y.z := (0);
		mat.y.w := (-ty / scale);
		mat.z.x := (0);
		mat.z.y := (0);
		mat.z.z := ((1) / scale);
		mat.z.w := (0);
		mat.w.x := (0);
		mat.w.y := (0);
		mat.w.z := (0);
		mat.w.w := (1);
	};
	result.transform(result, null, image, null, (align & highRes) ? 1 : 0, mat.data);
	image.destroy(image);
	return .result := result;
}
.instructions: (565 bytes)
	cmplGfx/lib/image.ci:25: (9 bytes): scale: float64 := 1
	<Image>  : load.f64 1.000000
	cmplGfx/lib/image.ci:26: (14 bytes): result: Image := Image(width, height, image.depth(image))
	<Image+?>: dup.x32 sp(7)
	<Image+?>: dup.x32 sp(7)
	<Image+?>: dup.x64 sp(10)
	<Image+?>: nfc(97) ;Image.depth(image: Image): int32
	<Image+?>: nfc(83) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/image.ci:28: (4 bytes): alignVertical: int32 := align & fitVertical
	<Image+?>: dup.x32 sp(7)
	<Image+?>: b32.and 0x03
	cmplGfx/lib/image.ci:29: (8 bytes): alignHorizontal: int32 := align & fitHorizontal
	<Image+?>: dup.x32 sp(8)
	<Image+?>: load.c32 12
	<Image+?>: and.b32
	cmplGfx/lib/image.ci:31: (8 bytes): fitWidth: bool := alignVertical == fitVertical
	<Image+?>: dup.x32 sp(1)
	<Image+?>: load.c32 3
	<Image+?>: ceq.i32
	cmplGfx/lib/image.ci:32: (8 bytes): fitHeight: bool := alignHorizontal == fitHorizontal
	<Image+?>: dup.x32 sp(1)
	<Image+?>: load.c32 12
	<Image+?>: ceq.i32
	cmplGfx/lib/image.ci:34: (176 bytes): if (fitWidth && fitHeight)
	<Image+?>: load.sp(+4)
	<Image+?>: load.i8
	<Image+?>: dup.x32 sp(0)
	<Image+?>: jz +13
	<Image+?>: inc.sp(-4)
	<Image+?>: load.sp(+0)
	<Image+?>: load.i8
	<Image+?>: jz +108
	cmplGfx/lib/image.ci:35: (11 bytes): widthScale: float64 := (width) / float64(image.width(image))
	<Image+?>: dup.x32 sp(13)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(16)
	<Image+?>: nfc(95) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	cmplGfx/lib/image.ci:36: (11 bytes): heightScale: float64 := (height) / float64(image.height(image))
	<Image+?>: dup.x32 sp(14)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(18)
	<Image+?>: nfc(96) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	cmplGfx/lib/image.ci:37: (74 bytes): if (align & fill)
	<Image+?>: dup.x32 sp(15)
	<Image+?>: load.c32 16
	<Image+?>: and.b32
	<Image+?>: jz +37
	cmplGfx/lib/image.ci:38: (29 bytes): scale := Math.max(widthScale, heightScale);
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: cgt.f64
	<Image+?>: jz +10
	<Image+?>: dup.x64 sp(2)
	<Image+?>: jmp +6
	<Image+?>: dup.x64 sp(0)
	<Image+?>: set.x64 sp(4)
	<Image+?>: inc.sp(-8)
	<Image+?>: set.x64 sp(12)
	<Image+?>: jmp +33
	cmplGfx/lib/image.ci:40: (29 bytes): scale := Math.min(widthScale, heightScale);
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: clt.f64
	<Image+?>: jz +10
	<Image+?>: dup.x64 sp(2)
	<Image+?>: jmp +6
	<Image+?>: dup.x64 sp(0)
	<Image+?>: set.x64 sp(4)
	<Image+?>: inc.sp(-8)
	<Image+?>: set.x64 sp(12)
	<Image+?>: inc.sp(-16)
	<Image+?>: jmp +52
	cmplGfx/lib/image.ci:43: (48 bytes): if (fitWidth)
	<Image+?>: load.sp(+4)
	<Image+?>: load.i8
	<Image+?>: jz +21
	cmplGfx/lib/image.ci:44: (13 bytes): scale := (width) / float64(image.width(image));
	<Image+?>: dup.x32 sp(13)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(16)
	<Image+?>: nfc(95) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(8)
	<Image+?>: jmp +26
	cmplGfx/lib/image.ci:46: (22 bytes): if (fitHeight)
	<Image+?>: load.sp(+0)
	<Image+?>: load.i8
	<Image+?>: jz +17
	cmplGfx/lib/image.ci:47: (13 bytes): scale := (height) / float64(image.height(image));
	<Image+?>: dup.x32 sp(12)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(16)
	<Image+?>: nfc(96) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(8)
	cmplGfx/lib/image.ci:49: (12 bytes): if (scale > maxScale)
	<Image+?>: dup.x64 sp(6)
	<Image+?>: dup.x64 sp(11)
	<Image+?>: cgt.f64
	<Image+?>: jz +7
	cmplGfx/lib/image.ci:50: (3 bytes): scale := maxScale;
	<Image+?>: mov.x64 sp(6, 9)
	cmplGfx/lib/image.ci:54: (1 byte): tx: float64 := 0
	<Image+?>: load.z64
	cmplGfx/lib/image.ci:55: (81 bytes): if (fitWidth || alignVertical == center)
	<Image+?>: load.sp(+12)
	<Image+?>: load.i8
	<Image+?>: dup.x32 sp(0)
	<Image+?>: jnz +12
	<Image+?>: inc.sp(-4)
	<Image+?>: dup.x32 sp(5)
	<Image+?>: load.z32
	<Image+?>: ceq.i32
	<Image+?>: jz +34
	cmplGfx/lib/image.ci:56: (26 bytes): tx := ((width) - (image.width(image)) * scale) / (2);
	<Image+?>: dup.x32 sp(15)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(18)
	<Image+?>: nfc(95) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(12)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: load.f64 2.000000
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(2)
	<Image+?>: jmp +32
	cmplGfx/lib/image.ci:58: (28 bytes): if (alignVertical == right)
	<Image+?>: dup.x32 sp(5)
	<Image+?>: load.c32 2
	<Image+?>: ceq.i32
	<Image+?>: jz +20
	cmplGfx/lib/image.ci:59: (16 bytes): tx := ((width) - (image.width(image)) * scale);
	<Image+?>: dup.x32 sp(15)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(18)
	<Image+?>: nfc(95) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(12)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: set.x64 sp(2)
	cmplGfx/lib/image.ci:62: (1 byte): ty: float64 := 0
	<Image+?>: load.z64
	cmplGfx/lib/image.ci:63: (81 bytes): if (fitHeight || alignHorizontal == center)
	<Image+?>: load.sp(+16)
	<Image+?>: load.i8
	<Image+?>: dup.x32 sp(0)
	<Image+?>: jnz +12
	<Image+?>: inc.sp(-4)
	<Image+?>: dup.x32 sp(6)
	<Image+?>: load.z32
	<Image+?>: ceq.i32
	<Image+?>: jz +34
	cmplGfx/lib/image.ci:64: (26 bytes): ty := ((height) - (image.height(image)) * scale) / (2);
	<Image+?>: dup.x32 sp(16)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(20)
	<Image+?>: nfc(96) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(14)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: load.f64 2.000000
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(2)
	<Image+?>: jmp +32
	cmplGfx/lib/image.ci:66: (28 bytes): if (alignHorizontal == bottom)
	<Image+?>: dup.x32 sp(6)
	<Image+?>: load.c32 8
	<Image+?>: ceq.i32
	<Image+?>: jz +20
	cmplGfx/lib/image.ci:67: (16 bytes): ty := ((height) - (image.height(image)) * scale);
	<Image+?>: dup.x32 sp(16)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(20)
	<Image+?>: nfc(96) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(14)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: set.x64 sp(2)
	cmplGfx/lib/image.ci:70: (104 bytes): mat: mat4f := {...}
	<Image+?>: inc.sp(+64)
	cmplGfx/lib/image.ci:71: (15 bytes): mat.x.x := ((1) / scale);
	<Image+?>: load.f64 1.000000
	<Image+?>: dup.x64 sp(28)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(1)
	cmplGfx/lib/image.ci:71: (3 bytes): mat.x.y := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(2)
	cmplGfx/lib/image.ci:71: (3 bytes): mat.x.z := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(3)
	cmplGfx/lib/image.ci:71: (9 bytes): mat.x.w := (-tx / scale);
	<Image+?>: dup.x64 sp(18)
	<Image+?>: neg.f64
	<Image+?>: dup.x64 sp(28)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(4)
	cmplGfx/lib/image.ci:72: (3 bytes): mat.y.x := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(5)
	cmplGfx/lib/image.ci:72: (15 bytes): mat.y.y := ((1) / scale);
	<Image+?>: load.f64 1.000000
	<Image+?>: dup.x64 sp(28)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(6)
	cmplGfx/lib/image.ci:72: (3 bytes): mat.y.z := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(7)
	cmplGfx/lib/image.ci:72: (9 bytes): mat.y.w := (-ty / scale);
	<Image+?>: dup.x64 sp(16)
	<Image+?>: neg.f64
	<Image+?>: dup.x64 sp(28)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(8)
	cmplGfx/lib/image.ci:73: (3 bytes): mat.z.x := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(9)
	cmplGfx/lib/image.ci:73: (3 bytes): mat.z.y := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(10)
	cmplGfx/lib/image.ci:73: (15 bytes): mat.z.z := ((1) / scale);
	<Image+?>: load.f64 1.000000
	<Image+?>: dup.x64 sp(28)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(11)
	cmplGfx/lib/image.ci:73: (3 bytes): mat.z.w := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(12)
	cmplGfx/lib/image.ci:74: (3 bytes): mat.w.x := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(13)
	cmplGfx/lib/image.ci:74: (3 bytes): mat.w.y := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(14)
	cmplGfx/lib/image.ci:74: (3 bytes): mat.w.z := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(15)
	cmplGfx/lib/image.ci:74: (7 bytes): mat.w.w := (1);
	<Image+?>: load.f32 1.000000
	<Image+?>: set.x32 sp(16)
	cmplGfx/lib/image.ci:77: (44 bytes): result.transform(result, null, image, null, (align & highRes) ? 1 : 0, mat.data);
	<Image+?>: dup.x64 sp(24)
	<Image+?>: load.ref <?> ;null
	<Image+?>: dup.x64 sp(37)
	<Image+?>: load.ref <?> ;null
	<Image+?>: dup.x32 sp(37)
	<Image+?>: load.c32 32
	<Image+?>: and.b32
	<Image+?>: jz +13
	<Image+?>: load.c32 1
	<Image+?>: jmp +5
	<Image+?>: load.z32
	<Image+?>: load.sp(+28)
	<Image+?>: nfc(113) ;Image.transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: float32[16]): void
	cmplGfx/lib/image.ci:78: (6 bytes): image.destroy(image);
	<Image+?>: dup.x64 sp(34)
	<Image+?>: nfc(87) ;Image.destroy(image: Image): void
	cmplGfx/lib/image.ci:79: (8 bytes): return .result := result;
	<Image+?>: mov.x64 sp(36, 24)
	<Image+?>: inc.sp(-112)
	<Image+?>: ret
.usages:
	cmplGfx/lib/image.ci:96: referenced as `Image`
}
Image(fileName: char[*], depth: int32): Image: function {
.kind: static function
.base: `function`
.size: 49
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:83'
.param .result: Image (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: 'Create an image by opening an image file'
.value: {
	if (endsWith(fileName, ".bmp", ignCaseCmp)) {
		return .result := Image.openBmp(fileName, depth);
	}
	return .result := Image.openImg(fileName, depth);
}
.instructions: (49 bytes)
	cmplGfx/lib/image.ci:84: (38 bytes): if (endsWith(fileName, ".bmp", ignCaseCmp))
	<Image>  : load.z32
	<Image+?>: dup.x32 sp(3)
	<Image+?>: load.ref <?> ;".bmp"
	<Image+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Image+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Image+?>: call
	<Image+?>: inc.sp(-12)
	<Image+?>: jz +15
	cmplGfx/lib/image.ci:85: (11 bytes): return .result := Image.openBmp(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(88) ;Image.openBmp(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
	cmplGfx/lib/image.ci:87: (11 bytes): return .result := Image.openImg(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(91) ;Image.openImg(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
.usages:
	cmplGfx/lib/image.ci:95: referenced as `Image`
	cmplGfx/lib/image.ci:91: referenced as `Image`
}
Image(fileName: char[*]): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:91'
.param .result: Image (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: const ref)
.doc: 'Create an image by opening an image file'
.value: Image(fileName, 32)
.usages:
}
Image(fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): Image: function {
.kind: static function
.base: `function`
.size: 55
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:94'
.param .result: Image (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: const variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param align: int32 (size: 4, cast: variable(i32))
.param maxScale: float64 (size: 8, cast: variable(f64))
.doc: 'Create an image by opening an image file with custom width and height'
.value: {
	image: Image := Image(fileName, depth);
	result: Image := Image(image, width, height, align, maxScale);
	image.destroy(image);
	return .result := result;
}
.instructions: (55 bytes)
	cmplGfx/lib/image.ci:95: (18 bytes): image: Image := Image(fileName, depth)
	<Image>  : inc.sp(+8)
	<Image+?>: dup.x32 sp(9)
	<Image+?>: dup.x32 sp(7)
	<Image+?>: load.ref <?> ;Image(fileName: char[*], depth: int32): Image
	<Image+?>: call
	<Image+?>: inc.sp(-8)
	cmplGfx/lib/image.ci:96: (24 bytes): result: Image := Image(image, width, height, align, maxScale)
	<Image+?>: inc.sp(+8)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x32 sp(12)
	<Image+?>: dup.x32 sp(12)
	<Image+?>: dup.x32 sp(11)
	<Image+?>: dup.x64 sp(10)
	<Image+?>: load.ref <?> ;Image(image: Image, width: int32, height: int32, align: int32, maxScale: float64): Image
	<Image+?>: call
	<Image+?>: inc.sp(-28)
	cmplGfx/lib/image.ci:97: (6 bytes): image.destroy(image);
	<Image+?>: dup.x64 sp(2)
	<Image+?>: nfc(87) ;Image.destroy(image: Image): void
	cmplGfx/lib/image.ci:98: (7 bytes): return .result := result;
	<Image+?>: set.x64 sp(12)
	<Image+?>: inc.sp(-8)
	<Image+?>: ret
.usages:
	cmplGfx/lib/image.ci:105: referenced as `Image`
	cmplGfx/lib/image.ci:102: referenced as `Image`
}
Image(fileName: char[*], width: int32, height: int32, depth: int32, align: int32): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:102'
.param .result: Image (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: const ref)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.param align: int32 (size: 4, cast: i32)
.doc: 'Create an image by opening an image file with custom width and height'
.value: Image(fileName, width, height, depth, align, Math.inf)
.usages:
}
Image(fileName: char[*], width: int32, height: int32, depth: int32): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:105'
.param .result: Image (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: const ref)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create an image by opening an image file with custom width and height'
.value: Image(fileName, width, height, depth, -1, Math.inf)
.usages:
}
set(image: Image, x: int32, y: int32, color: argb): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'set'
.file: 'cmplGfx/lib/image.ci:108'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x: int32 (size: 4, cast: i32)
.param y: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'Set the the color of a pixel at the given position'
.value: Image.set(image, x, y, uint32(color))
.usages:
	cmplGfx/lib/image.ci:196: referenced as `set`
}
colorMap(image: Image, roi: Rect, lut: argb[256]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'colorMap'
.file: 'cmplGfx/lib/image.ci:111'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param roi: Rect (size: 4, cast: const ref)
.param lut: argb[256] (size: 4, cast: const ref)
.doc: 'apply the 2d lookup table to the image'
.value: Image.colorMap(image, roi, pointer(lut))
.usages:
}
resize(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'resize'
.file: 'cmplGfx/lib/image.ci:114'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param rect: Rect (size: 4, cast: const ref)
.param src: Image (size: 8, cast: const val)
.param roi: Rect (size: 4, cast: const ref)
.param interpolate: int32 (size: 4, cast: i32)
.doc: '@public'
.value: Image.transform(image, rect, src, roi, interpolate, null)
.usages:
	cmplGfx/gfxlib.ci:114: referenced as `resize`
}
slice(image: Image, rect: Rect): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'slice'
.file: 'cmplGfx/lib/image.ci:117'
.param .result: Image (size: 8, cast: val)
.param image: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: const ref)
.doc: '@public'
.value: Image.slice(Image(0, 0, image.depth(image)), image, rect)
.usages:
}
clip(src: Image, roi: Rect): bool: function {
.kind: static function
.base: `function`
.size: 235
.name: 'clip'
.file: 'cmplGfx/lib/image.ci:120'
.param .result: bool (size: 4, cast: variable(bool))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	roi.w := roi.w + roi.x;
	roi.h := roi.h + roi.y;
	if (roi.x < 0) {
		roi.x := 0;
	}
	if (roi.y < 0) {
		roi.y := 0;
	}
	width: int32 := src.width(src);
	if (roi.w > width) {
		roi.w := width;
	}
	height: int32 := src.height(src);
	if (roi.h > height) {
		roi.h := height;
	}
	roi.w := roi.w - roi.x;
	roi.h := roi.h - roi.y;
	if (roi.w <= 0) {
		return .result := false;
	}
	if (roi.h <= 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (235 bytes)
	cmplGfx/lib/image.ci:122: (18 bytes): roi.w := roi.w + roi.x;
	<clip>  : dup.x32 sp(1)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:123: (22 bytes): roi.h := roi.h + roi.y;
	<clip+?>: dup.x32 sp(1)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: add.i32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:125: (13 bytes): if (roi.x < 0)
	<clip+?>: dup.x32 sp(1)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +8
	cmplGfx/lib/image.ci:126: (4 bytes): roi.x := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:129: (21 bytes): if (roi.y < 0)
	<clip+?>: dup.x32 sp(1)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +12
	cmplGfx/lib/image.ci:130: (8 bytes): roi.y := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:133: (6 bytes): width: int32 := src.width(src)
	<clip+?>: dup.x64 sp(2)
	<clip+?>: nfc(95) ;Image.width(image: Image): int32
	cmplGfx/lib/image.ci:134: (23 bytes): if (roi.w > width)
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/lib/image.ci:135: (9 bytes): roi.w := width;
	<clip+?>: dup.x32 sp(0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:138: (6 bytes): height: int32 := src.height(src)
	<clip+?>: dup.x64 sp(3)
	<clip+?>: nfc(96) ;Image.height(image: Image): int32
	cmplGfx/lib/image.ci:139: (23 bytes): if (roi.h > height)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/lib/image.ci:140: (9 bytes): roi.h := height;
	<clip+?>: dup.x32 sp(0)
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:143: (18 bytes): roi.w := roi.w - roi.x;
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:144: (22 bytes): roi.h := roi.h - roi.y;
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: sub.i32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:146: (24 bytes): if (roi.w <= 0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	cmplGfx/lib/image.ci:147: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	cmplGfx/lib/image.ci:149: (24 bytes): if (roi.h <= 0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: cgt.i32
	<clip+?>: jnz +15
	cmplGfx/lib/image.ci:150: (11 bytes): return .result := false;
	<clip+?>: load.z32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
	cmplGfx/lib/image.ci:152: (15 bytes): return .result := true;
	<clip+?>: load.c32 1
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
.usages:
	cmplGfx/lib/image.ci:210: referenced as `clip`
	cmplGfx/lib/image.ci:176: referenced as `clip`
}
fill(image: Image, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'cmplGfx/lib/image.ci:156'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill the entire image with the given color'
.value: image.fillRect(image, 0, 0, 65536, 65536, color)
.usages:
}
fill(image: Image, roi: Rect, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'cmplGfx/lib/image.ci:158'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill the given region of the image with the given color'
.value: image.fillRect(image, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color)
.usages:
}
fill(image: Image, roi: Rect, pad: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fill'
.file: 'cmplGfx/lib/image.ci:160'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param roi: Rect (size: 4, cast: const variable(ref))
.param pad: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill the given region and padding of the image with the given color'
.value: image.fillRect(image, roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, color)
.usages:
}
drawRect(image: Image, roi: Rect, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'drawRect'
.file: 'cmplGfx/lib/image.ci:163'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: u32)
.doc: '@public'
.value: image.drawRect(image, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color)
.usages:
}
fillRect(image: Image, roi: Rect, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fillRect'
.file: 'cmplGfx/lib/image.ci:165'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: u32)
.doc: '@public'
.value: image.fillRect(image, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color)
.usages:
}
eval(image: Image, roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void: function {
.kind: static function
.base: `function`
.size: 371
.name: 'eval'
.file: 'cmplGfx/lib/image.ci:168'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param aspect: float32 (size: 4, cast: variable(f32))
.param time: float32 (size: 4, cast: variable(f32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Fill the surface by evaluating the given function for each pixel'
.value: {
	rect: Rect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : image.width(image);
		rect.h := (roi) != null ? roi.h : image.height(image);
	};
	if (!clip(image, &rect)) {
		return;
	}
	w: float32 := image.width(image);
	h: float32 := image.height(image);
	if (aspect == (0)) {
		aspect := w / h;
	}
	h := h * aspect;
	in: vec4f := {
		in.x := (0);
		in.y := (0);
		in.z := (0);
		in.w := time;
	};
	for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
		in.y := (y) / h;
		for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
			in.x := (x) / w;
			set(image, x, y, argb(eval(in)));
		}
	}
}
.instructions: (371 bytes)
	cmplGfx/lib/image.ci:169: (114 bytes): rect: Rect := {...}
	<eval>  : inc.sp(+16)
	cmplGfx/lib/image.ci:170: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +11
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(1)
	cmplGfx/lib/image.ci:171: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(2)
	cmplGfx/lib/image.ci:172: (31 bytes): rect.w := (roi) != null ? roi.w : image.width(image);
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(95) ;Image.width(image: Image): int32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.ci:173: (31 bytes): rect.h := (roi) != null ? roi.h : image.height(image);
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+12)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(96) ;Image.height(image: Image): int32
	<eval+?>: set.x32 sp(4)
	cmplGfx/lib/image.ci:176: (26 bytes): if (!clip(image, &rect))
	<eval+?>: load.z32
	<eval+?>: dup.x64 sp(10)
	<eval+?>: load.sp(+12)
	<eval+?>: load.ref <?> ;clip(src: Image, roi: Rect): bool
	<eval+?>: call
	<eval+?>: inc.sp(-12)
	<eval+?>: jnz +9
	cmplGfx/lib/image.ci:177: (5 bytes): return;
	<eval+?>: inc.sp(-16)
	<eval+?>: ret
	cmplGfx/lib/image.ci:180: (7 bytes): w: float32 := image.width(image)
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(95) ;Image.width(image: Image): int32
	<eval+?>: i32.2f32
	cmplGfx/lib/image.ci:181: (7 bytes): h: float32 := image.height(image)
	<eval+?>: dup.x64 sp(10)
	<eval+?>: nfc(96) ;Image.height(image: Image): int32
	<eval+?>: i32.2f32
	cmplGfx/lib/image.ci:182: (15 bytes): if (aspect == (0))
	<eval+?>: dup.x32 sp(9)
	<eval+?>: load.z32
	<eval+?>: ceq.f32
	<eval+?>: jz +11
	cmplGfx/lib/image.ci:183: (7 bytes): aspect := w / h;
	<eval+?>: dup.x32 sp(1)
	<eval+?>: dup.x32 sp(1)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(10)
	cmplGfx/lib/image.ci:185: (3 bytes): h := h * aspect;
	<eval+?>: dup.x32 sp(9)
	<eval+?>: mul.f32
	cmplGfx/lib/image.ci:186: (16 bytes): in: vec4f := {...}
	<eval+?>: inc.sp(+16)
	cmplGfx/lib/image.ci:187: (3 bytes): in.x := (0);
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(1)
	cmplGfx/lib/image.ci:188: (3 bytes): in.y := (0);
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(2)
	cmplGfx/lib/image.ci:189: (3 bytes): in.z := (0);
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.ci:190: (3 bytes): in.w := time;
	<eval+?>: mov.x32 sp(3, 12)
	cmplGfx/lib/image.ci:192: (178 bytes): for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1)
	<eval+?>: dup.x32 sp(7)
	<eval+?>: jmp +160
	cmplGfx/lib/image.ci:193: (8 bytes): in.y := (y) / h;
	<eval+?>: dup.x32 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x32 sp(6)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.ci:194: (144 bytes): for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1)
	<eval+?>: dup.x32 sp(7)
	<eval+?>: jmp +126
	cmplGfx/lib/image.ci:195: (8 bytes): in.x := (x) / w;
	<eval+?>: dup.x32 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x32 sp(8)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.ci:196: (110 bytes): set(image, x, y, argb(eval(in)));
	<eval+?>: dup.x64 sp(17)
	<eval+?>: dup.x32 sp(2)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.sp(+16)
	<eval+?>: dup.x128 sp(10)
	<eval+?>: dup.x32 sp(25)
	<eval+?>: call
	<eval+?>: inc.sp(-16)
	<eval+?>: load.sp(+0)
	<eval+?>: load.z32
	<eval+?>: dup.x32 sp(1)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;clamp_s8(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: b32.shl 0x08
	<eval+?>: load.z32
	<eval+?>: dup.x32 sp(2)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;clamp_s8(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: b32.shl 0x08
	<eval+?>: load.z32
	<eval+?>: dup.x32 sp(2)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: load.ref <?> ;clamp_s8(c: int32): uint32
	<eval+?>: call
	<eval+?>: inc.sp(-4)
	<eval+?>: or.b32
	<eval+?>: set.x32 sp(5)
	<eval+?>: inc.sp(-16)
	<eval+?>: nfc(99) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.ci:194: (4 bytes): x := x + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/lib/image.ci:194: (12 bytes): x < rect.x + rect.w
	<eval+?>: dup.x32 sp(0)
	<eval+?>: dup.x32 sp(9)
	<eval+?>: dup.x32 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -130
	<eval+?>: inc.sp(-4)
	cmplGfx/lib/image.ci:192: (4 bytes): y := y + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/lib/image.ci:192: (12 bytes): y < rect.y + rect.h
	<eval+?>: dup.x32 sp(0)
	<eval+?>: dup.x32 sp(9)
	<eval+?>: dup.x32 sp(12)
	<eval+?>: add.i32
	<eval+?>: clt.i32
	<eval+?>: jnz -164
	<eval+?>: inc.sp(-4)
	<eval+?>: inc.sp(-40)
	<eval+?>: ret
.usages:
	cmplGfx/gfxlib.ci:131: referenced as `eval`
	cmplGfx/gfxlib.ci:113: referenced as `eval`
	cmplGfx/gfxlib.ci:97: referenced as `eval`
}
tile(image: Image, x: int32, y: int32, src: Image, roi: Rect): void: function {
.kind: static function
.base: `function`
.size: 251
.name: 'tile'
.file: 'cmplGfx/lib/image.ci:202'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	rect: Rect := {
		rect.x := (roi) != null ? roi.x : 0;
		rect.y := (roi) != null ? roi.y : 0;
		rect.w := (roi) != null ? roi.w : src.width(src);
		rect.h := (roi) != null ? roi.h : src.height(src);
	};
	if (!clip(src, &rect)) {
		return;
	}
	if (x < 0) {
		x := -(-x % rect.w);
	}
	if (y < 0) {
		y := -(-y % rect.h);
	}
	width: int32 := image.width(image);
	height: int32 := image.height(image);
	for (j: int32 := y; j < height; j := j + rect.h) {
		for (i: int32 := x; i < width; i := i + rect.w) {
			image.copy(image, i, j, src, rect);
		}
	}
}
.instructions: (251 bytes)
	cmplGfx/lib/image.ci:203: (114 bytes): rect: Rect := {...}
	<tile>  : inc.sp(+16)
	cmplGfx/lib/image.ci:204: (22 bytes): rect.x := (roi) != null ? roi.x : 0;
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +11
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x32 sp(1)
	cmplGfx/lib/image.ci:205: (26 bytes): rect.y := (roi) != null ? roi.y : 0;
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x32 sp(2)
	cmplGfx/lib/image.ci:206: (31 bytes): rect.w := (roi) != null ? roi.w : src.width(src);
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x64 sp(6)
	<tile+?>: nfc(95) ;Image.width(image: Image): int32
	<tile+?>: set.x32 sp(3)
	cmplGfx/lib/image.ci:207: (31 bytes): rect.h := (roi) != null ? roi.h : src.height(src);
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x64 sp(6)
	<tile+?>: nfc(96) ;Image.height(image: Image): int32
	<tile+?>: set.x32 sp(4)
	cmplGfx/lib/image.ci:210: (26 bytes): if (!clip(src, &rect))
	<tile+?>: load.z32
	<tile+?>: dup.x64 sp(7)
	<tile+?>: load.sp(+12)
	<tile+?>: load.ref <?> ;clip(src: Image, roi: Rect): bool
	<tile+?>: call
	<tile+?>: inc.sp(-12)
	<tile+?>: jnz +9
	cmplGfx/lib/image.ci:211: (5 bytes): return;
	<tile+?>: inc.sp(-16)
	<tile+?>: ret
	cmplGfx/lib/image.ci:214: (17 bytes): if (x < 0)
	<tile+?>: dup.x32 sp(9)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	cmplGfx/lib/image.ci:215: (9 bytes): x := -(-x % rect.w);
	<tile+?>: dup.x32 sp(9)
	<tile+?>: neg.i32
	<tile+?>: dup.x32 sp(3)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x32 sp(10)
	cmplGfx/lib/image.ci:217: (17 bytes): if (y < 0)
	<tile+?>: dup.x32 sp(8)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +13
	cmplGfx/lib/image.ci:218: (9 bytes): y := -(-y % rect.h);
	<tile+?>: dup.x32 sp(8)
	<tile+?>: neg.i32
	<tile+?>: dup.x32 sp(4)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x32 sp(9)
	cmplGfx/lib/image.ci:220: (6 bytes): width: int32 := image.width(image)
	<tile+?>: dup.x64 sp(10)
	<tile+?>: nfc(95) ;Image.width(image: Image): int32
	cmplGfx/lib/image.ci:221: (6 bytes): height: int32 := image.height(image)
	<tile+?>: dup.x64 sp(11)
	<tile+?>: nfc(96) ;Image.height(image: Image): int32
	cmplGfx/lib/image.ci:222: (60 bytes): for (j: int32 := y; j < height; j := j + rect.h)
	<tile+?>: dup.x32 sp(10)
	<tile+?>: jmp +45
	cmplGfx/lib/image.ci:223: (38 bytes): for (i: int32 := x; i < width; i := i + rect.w)
	<tile+?>: dup.x32 sp(12)
	<tile+?>: jmp +23
	cmplGfx/lib/image.ci:224: (16 bytes): image.copy(image, i, j, src, rect);
	<tile+?>: dup.x64 sp(14)
	<tile+?>: dup.x32 sp(2)
	<tile+?>: dup.x32 sp(4)
	<tile+?>: dup.x64 sp(14)
	<tile+?>: load.sp(+40)
	<tile+?>: nfc(111) ;Image.copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void
	cmplGfx/lib/image.ci:223: (3 bytes): i := i + rect.w
	<tile+?>: dup.x32 sp(6)
	<tile+?>: add.i32
	cmplGfx/lib/image.ci:223: (9 bytes): i < width
	<tile+?>: dup.x32 sp(0)
	<tile+?>: dup.x32 sp(4)
	<tile+?>: clt.i32
	<tile+?>: jnz -24
	<tile+?>: inc.sp(-4)
	cmplGfx/lib/image.ci:222: (3 bytes): j := j + rect.h
	<tile+?>: dup.x32 sp(6)
	<tile+?>: add.i32
	cmplGfx/lib/image.ci:222: (9 bytes): j < height
	<tile+?>: dup.x32 sp(0)
	<tile+?>: dup.x32 sp(2)
	<tile+?>: clt.i32
	<tile+?>: jnz -46
	<tile+?>: inc.sp(-4)
	<tile+?>: inc.sp(-24)
	<tile+?>: ret
.usages:
}
Mesh(fileName: char[*]): Mesh: function {
.kind: static function
.base: `function`
.size: 109
.name: 'Mesh'
.file: 'cmplGfx/lib/mesh.ci:2'
.param .result: Mesh (size: 4, cast: variable(ref))
.param fileName: char[*] (size: 4, cast: const variable(ref))
.doc: 'Create a mesh by opening a file'
.value: {
	if (endsWith(fileName, ".obj", ignCaseCmp)) {
		return .result := Mesh.openObj(fileName);
	}
	if (endsWith(fileName, ".3ds", ignCaseCmp)) {
		return .result := Mesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
.instructions: (109 bytes)
	cmplGfx/lib/mesh.ci:3: (36 bytes): if (endsWith(fileName, ".obj", ignCaseCmp))
	<Mesh>  : load.z32
	<Mesh+?>: dup.x32 sp(2)
	<Mesh+?>: load.ref <?> ;".obj"
	<Mesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Mesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Mesh+?>: call
	<Mesh+?>: inc.sp(-12)
	<Mesh+?>: jz +13
	cmplGfx/lib/mesh.ci:4: (9 bytes): return .result := Mesh.openObj(fileName);
	<Mesh+?>: dup.x32 sp(1)
	<Mesh+?>: nfc(68) ;Mesh.openObj(path: char[*]): Mesh
	<Mesh+?>: set.x32 sp(3)
	<Mesh+?>: ret
	cmplGfx/lib/mesh.ci:6: (36 bytes): if (endsWith(fileName, ".3ds", ignCaseCmp))
	<Mesh+?>: load.z32
	<Mesh+?>: dup.x32 sp(2)
	<Mesh+?>: load.ref <?> ;".3ds"
	<Mesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Mesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Mesh+?>: call
	<Mesh+?>: inc.sp(-12)
	<Mesh+?>: jz +13
	cmplGfx/lib/mesh.ci:7: (9 bytes): return .result := Mesh.open3ds(fileName);
	<Mesh+?>: dup.x32 sp(1)
	<Mesh+?>: nfc(69) ;Mesh.open3ds(path: char[*]): Mesh
	<Mesh+?>: set.x32 sp(3)
	<Mesh+?>: ret
	cmplGfx/lib/mesh.ci:9: (36 bytes): abort("unknown file extension", fileName);
	<Mesh+?>: load.ref <?> ;"cmplGfx/lib/mesh.ci"
	<Mesh+?>: load.c32 9
	<Mesh+?>: load.c32 -2
	<Mesh+?>: load.c32 128
	<Mesh+?>: load.ref <?> ;"unknown file extension"
	<Mesh+?>: load.ref <?>
	<Mesh+?>: dup.x32 sp(7)
	<Mesh+?>: nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<Mesh+?>: ret
.usages:
}
Camera: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'Camera'
.file: 'cmplGfx/lib/camera.ci:1'
.field position: vec4f (size: 16, cast: variable(val))
.field forward: vec4f (size: 16, cast: variable(val))
.field right: vec4f (size: 16, cast: variable(val))
.field up: vec4f (size: 16, cast: variable(val))
.field projection: function (size: 178, cast: static function)
.field rotation: function (size: 189, cast: static function)
.field translation: function (size: 60, cast: static function)
.field lookAt: function (size: 289, cast: static function)
.field matrix: function (size: 38, cast: static function)
.field matrix: function (size: 85, cast: static function)
.field move: function (size: 23, cast: static function)
.field rotate: function (size: 325, cast: static function)
.field rotate: function (size: 128, cast: static function)
.usages:
	cmplGfx/gfxlib.ci:286: referenced as `Camera`
	cmplGfx/gfxlib.ci:285: referenced as `Camera`
	cmplGfx/gfxlib.ci:228: referenced as `Camera`
	cmplGfx/gfxlib.ci:218: referenced as `Camera`
	cmplGfx/gfxlib.ci:162: referenced as `Camera`
	cmplGfx/gfxlib.ci:158: referenced as `Camera`
	cmplGfx/lib/camera.ci:125: referenced as `Camera`
	cmplGfx/lib/camera.ci:112: referenced as `Camera`
	cmplGfx/lib/camera.ci:107: referenced as `Camera`
	cmplGfx/lib/camera.ci:102: referenced as `Camera`
	cmplGfx/lib/camera.ci:92: referenced as `Camera`
	cmplGfx/lib/camera.ci:80: referenced as `Camera`
}
Camera.position: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'position'
.file: 'cmplGfx/lib/camera.ci:2'
.owner: Camera
.value: vec4f(0, 0, 0, 1)
.usages:
	cmplGfx/gfxlib.ci:163: referenced as `position`
	cmplGfx/lib/camera.ci:135: referenced as `position`
	cmplGfx/lib/camera.ci:133: referenced as `position`
	cmplGfx/lib/camera.ci:108: referenced as `position`
	cmplGfx/lib/camera.ci:108: referenced as `position`
	cmplGfx/lib/camera.ci:84: referenced as `position`
}
Camera.forward: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'forward'
.file: 'cmplGfx/lib/camera.ci:3'
.owner: Camera
.value: vec4f(0, 0, 0, 1)
.usages:
	cmplGfx/gfxlib.ci:246: referenced as `forward`
	cmplGfx/gfxlib.ci:163: referenced as `forward`
	cmplGfx/lib/camera.ci:134: referenced as `forward`
	cmplGfx/lib/camera.ci:121: referenced as `forward`
	cmplGfx/lib/camera.ci:119: referenced as `forward`
	cmplGfx/lib/camera.ci:119: referenced as `forward`
	cmplGfx/lib/camera.ci:94: referenced as `forward`
	cmplGfx/lib/camera.ci:85: referenced as `forward`
}
Camera.right: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'right'
.file: 'cmplGfx/lib/camera.ci:4'
.owner: Camera
.value: vec4f(0, 0, 0, 1)
.usages:
	cmplGfx/gfxlib.ci:251: referenced as `right`
	cmplGfx/gfxlib.ci:241: referenced as `right`
	cmplGfx/gfxlib.ci:235: referenced as `right`
	cmplGfx/gfxlib.ci:163: referenced as `right`
	cmplGfx/lib/camera.ci:121: referenced as `right`
	cmplGfx/lib/camera.ci:120: referenced as `right`
	cmplGfx/lib/camera.ci:120: referenced as `right`
	cmplGfx/lib/camera.ci:95: referenced as `right`
	cmplGfx/lib/camera.ci:86: referenced as `right`
}
Camera.up: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'up'
.file: 'cmplGfx/lib/camera.ci:5'
.owner: Camera
.value: vec4f(0, 1, 0, 1)
.usages:
	cmplGfx/gfxlib.ci:252: referenced as `up`
	cmplGfx/gfxlib.ci:240: referenced as `up`
	cmplGfx/gfxlib.ci:234: referenced as `up`
	cmplGfx/gfxlib.ci:163: referenced as `up`
	cmplGfx/lib/camera.ci:121: referenced as `up`
	cmplGfx/lib/camera.ci:96: referenced as `up`
	cmplGfx/lib/camera.ci:87: referenced as `up`
}
Camera.projection(fov: float32, asp: float32, n: float32, f: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 178
.name: 'projection'
.file: 'cmplGfx/lib/camera.ci:8'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param fov: float32 (size: 4, cast: variable(f32))
.param asp: float32 (size: 4, cast: variable(f32))
.param n: float32 (size: 4, cast: variable(f32))
.param f: float32 (size: 4, cast: variable(f32))
.doc: 'create an orthographic or perspective projection matrix'
.value: {
	bot: float32 := 1;
	nf: float32 := n - f;
	if (fov == (0)) {
		return .result := {
			.result.x := vec4f((1) / asp, 0, 0, 0);
			.result.y := vec4f(0, (1) / bot, 0, 0);
			.result.z := vec4f(0, 0, (2) / nf, -(f + n) / nf);
			.result.w := vec4f(0, 0, 0, 1);
		};
	}
	bot := float32.tan(Math.radians(fov));
	asp := asp * bot;
	return .result := {
			.result.x := vec4f(n / asp, 0, 0, 0);
			.result.y := vec4f(0, n / bot, 0, 0);
			.result.z := vec4f(0, 0, (n + f) / nf, (-2) * n * f / nf);
			.result.w := vec4f(0, 0, 1, 0);
		};
}
.instructions: (178 bytes)
	cmplGfx/lib/camera.ci:9: (5 bytes): bot: float32 := 1
	<projection>  : load.f32 1.000000
	cmplGfx/lib/camera.ci:10: (5 bytes): nf: float32 := n - f
	<projection+?>: dup.x32 sp(3)
	<projection+?>: dup.x32 sp(3)
	<projection+?>: sub.f32
	cmplGfx/lib/camera.ci:12: (70 bytes): if (fov == (0))
	<projection+?>: dup.x32 sp(6)
	<projection+?>: load.z32
	<projection+?>: ceq.f32
	<projection+?>: jz +66
	cmplGfx/lib/camera.ci:14: (62 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:15: (13 bytes): .result.x := vec4f((1) / asp, 0, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.f32 1.000000
	<projection+?>: dup.x32 sp(9)
	<projection+?>: div.f32
	<projection+?>: set.x128 sp(11)
	cmplGfx/lib/camera.ci:16: (13 bytes): .result.y := vec4f(0, (1) / bot, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.f32 1.000000
	<projection+?>: dup.x32 sp(4)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(15)
	cmplGfx/lib/camera.ci:17: (21 bytes): .result.z := vec4f(0, 0, (2) / nf, -(f + n) / nf);
	<projection+?>: dup.x32 sp(3)
	<projection+?>: dup.x32 sp(5)
	<projection+?>: add.f32
	<projection+?>: neg.f32
	<projection+?>: dup.x32 sp(1)
	<projection+?>: div.f32
	<projection+?>: load.f32 2.000000
	<projection+?>: dup.x32 sp(2)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(19)
	cmplGfx/lib/camera.ci:18: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<projection+?>: load.f32 1.000000
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(23)
	<projection+?>: inc.sp(-8)
	<projection+?>: ret
	cmplGfx/lib/camera.ci:23: (30 bytes): bot := float32.tan(Math.radians(fov));
	<projection+?>: dup.x32 sp(6)
	<projection+?>: f32.2f64
	<projection+?>: load.f64 3.141593
	<projection+?>: mul.f64
	<projection+?>: load.f64 180.000000
	<projection+?>: div.f64
	<projection+?>: f64.2f32
	<projection+?>: nfc(35) ;float32.tan(x: float32): float32
	<projection+?>: set.x32 sp(2)
	cmplGfx/lib/camera.ci:24: (7 bytes): asp := asp * bot;
	<projection+?>: dup.x32 sp(5)
	<projection+?>: dup.x32 sp(2)
	<projection+?>: mul.f32
	<projection+?>: set.x32 sp(6)
	cmplGfx/lib/camera.ci:26: (61 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:27: (10 bytes): .result.x := vec4f(n / asp, 0, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: dup.x32 sp(7)
	<projection+?>: dup.x32 sp(9)
	<projection+?>: div.f32
	<projection+?>: set.x128 sp(11)
	cmplGfx/lib/camera.ci:28: (10 bytes): .result.y := vec4f(0, n / bot, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: dup.x32 sp(6)
	<projection+?>: dup.x32 sp(4)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(15)
	cmplGfx/lib/camera.ci:29: (26 bytes): .result.z := vec4f(0, 0, (n + f) / nf, (-2) * n * f / nf);
	<projection+?>: load.f32 -2.000000
	<projection+?>: dup.x32 sp(5)
	<projection+?>: mul.f32
	<projection+?>: dup.x32 sp(4)
	<projection+?>: mul.f32
	<projection+?>: dup.x32 sp(1)
	<projection+?>: div.f32
	<projection+?>: dup.x32 sp(5)
	<projection+?>: dup.x32 sp(5)
	<projection+?>: add.f32
	<projection+?>: dup.x32 sp(2)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(19)
	cmplGfx/lib/camera.ci:30: (10 bytes): .result.w := vec4f(0, 0, 1, 0);
	<projection+?>: load.z32
	<projection+?>: load.f32 1.000000
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(23)
	<projection+?>: inc.sp(-8)
	<projection+?>: ret
.usages:
	cmplGfx/gfxlib.ci:285: referenced as `projection`
}
Camera.rotation(dir: vec4f, ang: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 189
.name: 'rotation'
.file: 'cmplGfx/lib/camera.ci:35'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param dir: vec4f (size: 16, cast: variable(val))
.param ang: float32 (size: 4, cast: variable(f32))
.value: {
	sin_t: float32 := float64.sin(ang);
	cos_t: float32 := float64.cos(ang);
	one_c: float32 := 1.000000 - (cos_t);
	tmp: vec4f := mul(dir, sin_t);
	xx: float32 := dir.x * dir.x;
	yy: float32 := dir.y * dir.y;
	zz: float32 := dir.z * dir.z;
	xy: float32 := dir.x * dir.y;
	xz: float32 := dir.x * dir.z;
	yz: float32 := dir.y * dir.z;
	return .result := {
			.result.xx := one_c * xx + cos_t;
			.result.xy := one_c * xy - tmp.z;
			.result.xz := one_c * xz + tmp.y;
			.result.xw := (0);
			.result.yx := one_c * xy + tmp.z;
			.result.yy := one_c * yy + cos_t;
			.result.yz := one_c * yz - tmp.x;
			.result.yw := (0);
			.result.zx := one_c * xz - tmp.y;
			.result.zy := one_c * yz + tmp.x;
			.result.zz := one_c * zz + cos_t;
			.result.zw := (0);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
}
.instructions: (189 bytes)
	cmplGfx/lib/camera.ci:36: (8 bytes): sin_t: float32 := float64.sin(ang)
	<rotation>  : dup.x32 sp(1)
	<rotation+?>: f32.2f64
	<rotation+?>: nfc(41) ;float64.sin(x: float64): float64
	<rotation+?>: f64.2f32
	cmplGfx/lib/camera.ci:37: (8 bytes): cos_t: float32 := float64.cos(ang)
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: f32.2f64
	<rotation+?>: nfc(42) ;float64.cos(x: float64): float64
	<rotation+?>: f64.2f32
	cmplGfx/lib/camera.ci:38: (14 bytes): one_c: float32 := 1.000000 - (cos_t)
	<rotation+?>: load.f64 1.000000
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: f32.2f64
	<rotation+?>: sub.f64
	<rotation+?>: f64.2f32
	cmplGfx/lib/camera.ci:39: (15 bytes): tmp: vec4f := mul(dir, sin_t)
	<rotation+?>: dup.x128 sp(5)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: set.x128 sp(1)
	<rotation+?>: mul.v4f
	cmplGfx/lib/camera.ci:41: (5 bytes): xx: float32 := dir.x * dir.x
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: mul.f32
	cmplGfx/lib/camera.ci:42: (5 bytes): yy: float32 := dir.y * dir.y
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: mul.f32
	cmplGfx/lib/camera.ci:43: (5 bytes): zz: float32 := dir.z * dir.z
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: mul.f32
	cmplGfx/lib/camera.ci:44: (5 bytes): xy: float32 := dir.x * dir.y
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: mul.f32
	cmplGfx/lib/camera.ci:45: (5 bytes): xz: float32 := dir.x * dir.z
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	cmplGfx/lib/camera.ci:46: (5 bytes): yz: float32 := dir.y * dir.z
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	cmplGfx/lib/camera.ci:48: (114 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:49: (10 bytes): .result.xx := one_c * xx + cos_t;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(20)
	cmplGfx/lib/camera.ci:50: (10 bytes): .result.xy := one_c * xy - tmp.z;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(21)
	cmplGfx/lib/camera.ci:51: (10 bytes): .result.xz := one_c * xz + tmp.y;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(22)
	cmplGfx/lib/camera.ci:52: (3 bytes): .result.xw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(23)
	cmplGfx/lib/camera.ci:54: (10 bytes): .result.yx := one_c * xy + tmp.z;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(24)
	cmplGfx/lib/camera.ci:55: (10 bytes): .result.yy := one_c * yy + cos_t;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(25)
	cmplGfx/lib/camera.ci:56: (10 bytes): .result.yz := one_c * yz - tmp.x;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(26)
	cmplGfx/lib/camera.ci:57: (3 bytes): .result.yw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(27)
	cmplGfx/lib/camera.ci:59: (10 bytes): .result.zx := one_c * xz - tmp.y;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(28)
	cmplGfx/lib/camera.ci:60: (10 bytes): .result.zy := one_c * yz + tmp.x;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(29)
	cmplGfx/lib/camera.ci:61: (10 bytes): .result.zz := one_c * zz + cos_t;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(30)
	cmplGfx/lib/camera.ci:62: (3 bytes): .result.zw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(31)
	cmplGfx/lib/camera.ci:64: (10 bytes): .result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(35)
	<rotation+?>: inc.sp(-52)
	<rotation+?>: ret
.usages:
	cmplGfx/lib/camera.ci:118: referenced as `rotation`
}
Camera.translation(dir: vec4f, cnt: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 60
.name: 'translation'
.file: 'cmplGfx/lib/camera.ci:69'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param dir: vec4f (size: 16, cast: variable(val))
.param cnt: float32 (size: 4, cast: variable(f32))
.value: {
	tmp: vec4f := mul(dir, vec4f(cnt));
	return .result := {
			.result.x := vec4f(1, 0, 0, tmp.x);
			.result.y := vec4f(0, 1, 0, tmp.y);
			.result.z := vec4f(0, 0, 1, tmp.z);
			.result.w := vec4f(0, 0, 0, tmp.w);
		};
}
.instructions: (60 bytes)
	cmplGfx/lib/camera.ci:70: (15 bytes): tmp: vec4f := mul(dir, vec4f(cnt))
	<translation>  : dup.x128 sp(2)
	<translation+?>: dup.x32 sp(5)
	<translation+?>: dup.x32 sp(0)
	<translation+?>: dup.x32 sp(1)
	<translation+?>: dup.x32 sp(2)
	<translation+?>: dup.x32 sp(3)
	<translation+?>: set.x128 sp(1)
	<translation+?>: mul.v4f
	cmplGfx/lib/camera.ci:71: (45 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:72: (11 bytes): .result.x := vec4f(1, 0, 0, tmp.x);
	<translation+?>: dup.x32 sp(0)
	<translation+?>: load.z32
	<translation+?>: load.z32
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x128 sp(14)
	cmplGfx/lib/camera.ci:73: (11 bytes): .result.y := vec4f(0, 1, 0, tmp.y);
	<translation+?>: dup.x32 sp(1)
	<translation+?>: load.z32
	<translation+?>: load.f32 1.000000
	<translation+?>: load.z32
	<translation+?>: set.x128 sp(18)
	cmplGfx/lib/camera.ci:74: (11 bytes): .result.z := vec4f(0, 0, 1, tmp.z);
	<translation+?>: dup.x32 sp(2)
	<translation+?>: load.f32 1.000000
	<translation+?>: load.z32
	<translation+?>: load.z32
	<translation+?>: set.x128 sp(22)
	cmplGfx/lib/camera.ci:75: (7 bytes): .result.w := vec4f(0, 0, 0, tmp.w);
	<translation+?>: dup.x32 sp(3)
	<translation+?>: load.z32
	<translation+?>: load.z32
	<translation+?>: load.z32
	<translation+?>: set.x128 sp(26)
	<translation+?>: inc.sp(-16)
	<translation+?>: ret
.usages:
	cmplGfx/lib/camera.ci:134: referenced as `translation`
}
Camera.lookAt(position: vec4f, target: vec4f, up: vec4f): Camera: function {
.kind: static function
.base: `function`
.size: 289
.name: 'lookAt'
.file: 'cmplGfx/lib/camera.ci:80'
.owner: Camera
.param .result: Camera (size: 64, cast: variable(val))
.param position: vec4f (size: 16, cast: variable(val))
.param target: vec4f (size: 16, cast: variable(val))
.param up: vec4f (size: 16, cast: variable(val))
.doc: 'Create a camera at the given `position` looking at the given `target`'
.value: {
	forward: vec4f := normalize(sub(target, position));
	right: vec4f := normalize(cross(up, forward));
	return .result := {
			.result.position := position;
			.result.forward := forward;
			.result.right := right;
			.result.up := cross(forward, right);
		};
}
.instructions: (289 bytes)
	cmplGfx/lib/camera.ci:81: (47 bytes): forward: vec4f := normalize(sub(target, position))
	<lookAt>  : dup.x128 sp(9)
	<lookAt+?>: dup.x128 sp(17)
	<lookAt+?>: sub.v4f
	<lookAt+?>: load.sp(+0)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: load.i128
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i128
	<lookAt+?>: dup.x128 sp(0)
	<lookAt+?>: dup.x128 sp(4)
	<lookAt+?>: dp3.v4f
	<lookAt+?>: nfc(39) ;float32.sqrt(x: float32): float32
	<lookAt+?>: set.x32 sp(4)
	<lookAt+?>: inc.sp(-12)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: dup.x32 sp(1)
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: set.x128 sp(1)
	<lookAt+?>: div.v4f
	<lookAt+?>: set.x128 sp(5)
	<lookAt+?>: inc.sp(-4)
	cmplGfx/lib/camera.ci:82: (134 bytes): right: vec4f := normalize(cross(up, forward))
	<lookAt+?>: load.sp(+36)
	<lookAt+?>: load.sp(+4)
	<lookAt+?>: load.f32 1.000000
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: set.x128 sp(2)
	<lookAt+?>: load.sp(+0)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: load.i128
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i128
	<lookAt+?>: dup.x128 sp(0)
	<lookAt+?>: dup.x128 sp(4)
	<lookAt+?>: dp3.v4f
	<lookAt+?>: nfc(39) ;float32.sqrt(x: float32): float32
	<lookAt+?>: set.x32 sp(4)
	<lookAt+?>: inc.sp(-12)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: dup.x32 sp(1)
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: set.x128 sp(1)
	<lookAt+?>: div.v4f
	<lookAt+?>: set.x128 sp(5)
	<lookAt+?>: inc.sp(-4)
	cmplGfx/lib/camera.ci:83: (108 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:84: (3 bytes): .result.position := position;
	<lookAt+?>: mov.x128 sp(9, 21)
	cmplGfx/lib/camera.ci:85: (3 bytes): .result.forward := forward;
	<lookAt+?>: mov.x128 sp(13, 4)
	cmplGfx/lib/camera.ci:86: (3 bytes): .result.right := right;
	<lookAt+?>: mov.x128 sp(17, 0)
	cmplGfx/lib/camera.ci:87: (94 bytes): .result.up := cross(forward, right);
	<lookAt+?>: load.sp(+16)
	<lookAt+?>: load.sp(+4)
	<lookAt+?>: load.f32 1.000000
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: set.x128 sp(2)
	<lookAt+?>: set.x128 sp(25)
	<lookAt+?>: inc.sp(-32)
	<lookAt+?>: ret
.usages:
	cmplGfx/gfxlib.ci:286: referenced as `lookAt`
	cmplGfx/gfxlib.ci:218: referenced as `lookAt`
}
Camera.matrix(camera: Camera): mat4f: function {
.kind: static function
.base: `function`
.size: 38
.name: 'matrix'
.file: 'cmplGfx/lib/camera.ci:92'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param camera: Camera (size: 4, cast: const variable(ref))
.doc: 'get the matrix of the camera, which can be multiplied with the projection matrix'
.value: {
	return .result := {
			.result.x := camera.forward;
			.result.y := camera.right;
			.result.z := camera.up;
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (38 bytes)
	cmplGfx/lib/camera.ci:93: (38 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:94: (9 bytes): .result.x := camera.forward;
	<matrix>  : dup.x32 sp(1)
	<matrix+?>: inc.i32(+16)
	<matrix+?>: load.i128
	<matrix+?>: set.x128 sp(6)
	cmplGfx/lib/camera.ci:95: (9 bytes): .result.y := camera.right;
	<matrix+?>: dup.x32 sp(1)
	<matrix+?>: inc.i32(+32)
	<matrix+?>: load.i128
	<matrix+?>: set.x128 sp(10)
	cmplGfx/lib/camera.ci:96: (9 bytes): .result.z := camera.up;
	<matrix+?>: dup.x32 sp(1)
	<matrix+?>: inc.i32(+48)
	<matrix+?>: load.i128
	<matrix+?>: set.x128 sp(14)
	cmplGfx/lib/camera.ci:97: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<matrix+?>: load.f32 1.000000
	<matrix+?>: load.z32
	<matrix+?>: load.z32
	<matrix+?>: load.z32
	<matrix+?>: set.x128 sp(18)
	<matrix+?>: ret
.usages:
	cmplGfx/lib/camera.ci:103: referenced as `matrix`
}
Camera.matrix(projection: mat4f, camera: Camera): mat4f: function {
.kind: static function
.base: `function`
.size: 85
.name: 'matrix'
.file: 'cmplGfx/lib/camera.ci:102'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param projection: mat4f (size: 4, cast: const variable(ref))
.param camera: Camera (size: 4, cast: const variable(ref))
.doc: 'get the matrix of the camera multiplied with the projection matrix'
.value: {
	return .result := mul(projection, matrix(camera));
}
.instructions: (85 bytes)
	cmplGfx/lib/camera.ci:103: (85 bytes): return .result := mul(projection, matrix(camera));
	<matrix>  : inc.sp(+64)
	<matrix+?>: dup.x32 sp(17)
	<matrix+?>: load.ref <?> ;Camera.matrix(camera: Camera): mat4f
	<matrix+?>: call
	<matrix+?>: inc.sp(-4)
	<matrix+?>: inc.sp(+64)
	<matrix+?>: dup.x32 sp(34)
	<matrix+?>: load.sp(+68)
	<matrix+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<matrix+?>: call
	<matrix+?>: load.sp(+8)
	<matrix+?>: load.sp(-60)
	<matrix+?>: copy.mem -64
	<matrix+?>: inc.sp(+64)
	<matrix+?>: load.sp(+136)
	<matrix+?>: load.sp(+4)
	<matrix+?>: copy.mem 64
	<matrix+?>: inc.sp(-64)
	<matrix+?>: inc.sp(-72)
	<matrix+?>: load.sp(+76)
	<matrix+?>: load.sp(+4)
	<matrix+?>: copy.mem 64
	<matrix+?>: inc.sp(-64)
	<matrix+?>: ret
.usages:
}
Camera.move(camera: Camera, direction: vec4f, amount: float32): void: function {
.kind: static function
.base: `function`
.size: 23
.name: 'move'
.file: 'cmplGfx/lib/camera.ci:107'
.owner: Camera
.param .result: void (size: 0, cast: variable(void))
.param camera: Camera (size: 4, cast: variable(ref))
.param direction: vec4f (size: 16, cast: variable(val))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Move the camera in the given `direction` with the given `amount`'
.value: {
	camera.position := add(camera.position, mul(direction, amount));
}
.instructions: (23 bytes)
	cmplGfx/lib/camera.ci:108: (22 bytes): camera.position := add(camera.position, mul(direction, amount));
	<move>  : dup.x32 sp(6)
	<move+?>: load.i128
	<move+?>: dup.x128 sp(6)
	<move+?>: dup.x32 sp(9)
	<move+?>: dup.x32 sp(0)
	<move+?>: dup.x32 sp(1)
	<move+?>: dup.x32 sp(2)
	<move+?>: dup.x32 sp(3)
	<move+?>: set.x128 sp(1)
	<move+?>: mul.v4f
	<move+?>: add.v4f
	<move+?>: dup.x32 sp(10)
	<move+?>: store.i128
	<move+?>: ret
.usages:
	cmplGfx/gfxlib.ci:252: referenced as `move`
	cmplGfx/gfxlib.ci:251: referenced as `move`
	cmplGfx/gfxlib.ci:246: referenced as `move`
}
Camera.rotate(camera: Camera, direction: vec4f, amount: float32): void: function {
.kind: static function
.base: `function`
.size: 325
.name: 'rotate'
.file: 'cmplGfx/lib/camera.ci:112'
.owner: Camera
.param .result: void (size: 0, cast: variable(void))
.param camera: Camera (size: 4, cast: variable(ref))
.param direction: vec4f (size: 16, cast: variable(val))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Rotate the camera in the given `direction` with the given `amount`'
.value: {
	if (amount == (0)) {
		return;
	}
	matrix: mat4f := rotation(direction, amount);
	camera.forward := normalize(dp3(matrix, camera.forward));
	camera.right := normalize(dp3(matrix, camera.right));
	camera.up := cross(camera.forward, camera.right);
}
.instructions: (325 bytes)
	cmplGfx/lib/camera.ci:113: (9 bytes): if (amount == (0))
	<rotate>  : dup.x32 sp(1)
	<rotate+?>: load.z32
	<rotate+?>: ceq.f32
	<rotate+?>: jz +5
	cmplGfx/lib/camera.ci:114: (1 byte): return;
	<rotate+?>: ret
	cmplGfx/lib/camera.ci:118: (18 bytes): matrix: mat4f := rotation(direction, amount)
	<rotate+?>: inc.sp(+64)
	<rotate+?>: dup.x128 sp(18)
	<rotate+?>: dup.x32 sp(21)
	<rotate+?>: load.ref <?> ;Camera.rotation(dir: vec4f, ang: float32): mat4f
	<rotate+?>: call
	<rotate+?>: inc.sp(-20)
	cmplGfx/lib/camera.ci:119: (95 bytes): camera.forward := normalize(dp3(matrix, camera.forward));
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(23)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.f32 1.000000
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(7)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: set.x128 sp(2)
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x128 sp(0)
	<rotate+?>: dup.x128 sp(4)
	<rotate+?>: dp3.v4f
	<rotate+?>: nfc(39) ;float32.sqrt(x: float32): float32
	<rotate+?>: set.x32 sp(4)
	<rotate+?>: inc.sp(-12)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: dup.x32 sp(1)
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: set.x128 sp(1)
	<rotate+?>: div.v4f
	<rotate+?>: set.x128 sp(5)
	<rotate+?>: inc.sp(-4)
	<rotate+?>: dup.x32 sp(26)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: store.i128
	cmplGfx/lib/camera.ci:120: (95 bytes): camera.right := normalize(dp3(matrix, camera.right));
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(23)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.f32 1.000000
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(7)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: set.x128 sp(2)
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x128 sp(0)
	<rotate+?>: dup.x128 sp(4)
	<rotate+?>: dp3.v4f
	<rotate+?>: nfc(39) ;float32.sqrt(x: float32): float32
	<rotate+?>: set.x32 sp(4)
	<rotate+?>: inc.sp(-12)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: dup.x32 sp(1)
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: set.x128 sp(1)
	<rotate+?>: div.v4f
	<rotate+?>: set.x128 sp(5)
	<rotate+?>: inc.sp(-4)
	<rotate+?>: dup.x32 sp(26)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: store.i128
	cmplGfx/lib/camera.ci:121: (103 bytes): camera.up := cross(camera.forward, camera.right);
	<rotate+?>: dup.x32 sp(22)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: dup.x32 sp(23)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.f32 1.000000
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: sub.f32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: sub.f32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: sub.f32
	<rotate+?>: set.x128 sp(2)
	<rotate+?>: dup.x32 sp(26)
	<rotate+?>: inc.i32(+48)
	<rotate+?>: store.i128
	<rotate+?>: inc.sp(-64)
	<rotate+?>: ret
.usages:
	cmplGfx/gfxlib.ci:241: referenced as `rotate`
	cmplGfx/gfxlib.ci:240: referenced as `rotate`
	cmplGfx/lib/camera.ci:130: referenced as `rotate`
}
Camera.rotate(camera: Camera, orbit: vec4f, direction: vec4f, amount: float32): void: function {
.kind: static function
.base: `function`
.size: 128
.name: 'rotate'
.file: 'cmplGfx/lib/camera.ci:125'
.owner: Camera
.param .result: void (size: 0, cast: variable(void))
.param camera: Camera (size: 4, cast: variable(ref))
.param orbit: vec4f (size: 16, cast: variable(val))
.param direction: vec4f (size: 16, cast: variable(val))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Rotate the camera around the `orbit` in the given `direction` with the given `amount`'
.value: {
	if (amount == (0)) {
		return;
	}
	rotate(&camera, direction, amount);
	dist: float32 := length(sub(orbit, camera.position));
	matrix: mat4f := translation(camera.forward, -dist);
	camera.position := dph(matrix, orbit);
}
.instructions: (128 bytes)
	cmplGfx/lib/camera.ci:126: (9 bytes): if (amount == (0))
	<rotate>  : dup.x32 sp(1)
	<rotate+?>: load.z32
	<rotate+?>: ceq.f32
	<rotate+?>: jz +5
	cmplGfx/lib/camera.ci:127: (1 byte): return;
	<rotate+?>: ret
	cmplGfx/lib/camera.ci:130: (16 bytes): rotate(&camera, direction, amount);
	<rotate+?>: dup.x32 sp(10)
	<rotate+?>: dup.x128 sp(3)
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.ref <?> ;Camera.rotate(camera: Camera, direction: vec4f, amount: float32): void
	<rotate+?>: call
	<rotate+?>: inc.sp(-24)
	cmplGfx/lib/camera.ci:133: (21 bytes): dist: float32 := length(sub(orbit, camera.position))
	<rotate+?>: dup.x128 sp(6)
	<rotate+?>: dup.x32 sp(14)
	<rotate+?>: load.i128
	<rotate+?>: sub.v4f
	<rotate+?>: dup.x128 sp(0)
	<rotate+?>: dup.x128 sp(4)
	<rotate+?>: dp3.v4f
	<rotate+?>: nfc(39) ;float32.sqrt(x: float32): float32
	<rotate+?>: set.x32 sp(4)
	<rotate+?>: inc.sp(-12)
	cmplGfx/lib/camera.ci:134: (24 bytes): matrix: mat4f := translation(camera.forward, -dist)
	<rotate+?>: inc.sp(+64)
	<rotate+?>: dup.x32 sp(27)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(20)
	<rotate+?>: neg.f32
	<rotate+?>: load.ref <?> ;Camera.translation(dir: vec4f, cnt: float32): mat4f
	<rotate+?>: call
	<rotate+?>: inc.sp(-20)
	cmplGfx/lib/camera.ci:135: (53 bytes): camera.position := dph(matrix, orbit);
	<rotate+?>: load.sp(+0)
	<rotate+?>: load.sp(+96)
	<rotate+?>: dup.x32 sp(1)
	<rotate+?>: inc.i32(+48)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(7)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: set.x128 sp(2)
	<rotate+?>: dup.x32 sp(31)
	<rotate+?>: store.i128
	<rotate+?>: inc.sp(-68)
	<rotate+?>: ret
.usages:
	cmplGfx/gfxlib.ci:235: referenced as `rotate`
	cmplGfx/gfxlib.ci:234: referenced as `rotate`
}
show(surf: Image): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:23'
.param .result: void (size: 0, cast: void)
.param surf: Image (size: 8, cast: val)
.doc: 'Show the surface in a window'
.value: Gui.showWindow(surf, null, null)
.usages:
}
show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void: function {
.kind: static function
.base: `function`
.size: 43
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:26'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param onEvent: function (size: 4, cast: variable(ref))
.doc: 'Show the surface in a window'
.value: {
	if ((onEvent) == null) {
		return .result := Gui.showWindow(image, null, null);
	}
	static delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		return .result := onEvent(action, button, ex, ey);
	};
	Gui.showWindow(image, onEvent, delegate);
}
.instructions: (43 bytes)
	cmplGfx/gfxlib.ci:27: (29 bytes): if ((onEvent) == null)
	<show>  : dup.x32 sp(1)
	<show+?>: load.ref <?> ;null
	<show+?>: ceq.i32
	<show+?>: jz +21
	cmplGfx/gfxlib.ci:28: (17 bytes): return .result := Gui.showWindow(image, null, null);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;null
	<show+?>: nfc(130) ;Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
	cmplGfx/gfxlib.ci:33: (13 bytes): Gui.showWindow(image, onEvent, delegate);
	<show+?>: dup.x64 sp(2)
	<show+?>: dup.x32 sp(3)
	<show+?>: load.ref <?> ;show.delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(130) ;Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
.usages:
	cmplGfx/gfxlib.ci:132: referenced as `show`
}
showDiff(image1: Image, image2: Image): void: function {
.kind: static function
.base: `function`
.size: 48
.name: 'showDiff'
.file: 'cmplGfx/gfxlib.ci:37'
.param .result: void (size: 0, cast: variable(void))
.param image1: Image (size: 8, cast: variable(val))
.param image2: Image (size: 8, cast: variable(val))
.doc: 'Show the surfaces in a window clicking on the window toggles the shown surface'
.value: {
	static const Closure: struct {
		offs: Image;
		image1: Image;
		image2: Image;
	};
	static onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.MOUSE_PRESS) {
			closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
			return .result := 0;
		}
		if ((action) == Gui.MOUSE_RELEASE) {
			closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
			return .result := 0;
		}
		return .result := 0;
	};
	closure: Closure := {
		closure.offs := Image(image1);
		closure.image1 := image1;
		closure.image2 := image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}
.instructions: (48 bytes)
	cmplGfx/gfxlib.ci:61: (28 bytes): closure: Closure := {...}
	<showDiff>  : inc.sp(+24)
	cmplGfx/gfxlib.ci:62: (18 bytes): closure.offs := Image(image1);
	<showDiff+?>: inc.sp(+8)
	<showDiff+?>: dup.x64 sp(11)
	<showDiff+?>: load.ref <?> ;Image(copy: Image): Image
	<showDiff+?>: call
	<showDiff+?>: inc.sp(-8)
	<showDiff+?>: set.x64 sp(2)
	cmplGfx/gfxlib.ci:63: (3 bytes): closure.image1 := image1;
	<showDiff+?>: mov.x64 sp(2, 9)
	cmplGfx/gfxlib.ci:64: (3 bytes): closure.image2 := image2;
	<showDiff+?>: mov.x64 sp(4, 7)
	cmplGfx/gfxlib.ci:66: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<showDiff+?>: dup.x64 sp(0)
	<showDiff+?>: load.sp(+8)
	<showDiff+?>: load.ref <?> ;showDiff.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<showDiff+?>: nfc(130) ;Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<showDiff+?>: inc.sp(-24)
	<showDiff+?>: ret
.usages:
}
show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void: function {
.kind: static function
.base: `function`
.size: 176
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:70'
.param .result: void (size: 0, cast: variable(void))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param animationResolution: int32 (size: 4, cast: variable(i32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Show or animate the the procedural image generated by the `eval` function'
.value: {
	static const start: int64 := System.millis();
	static const Closure: struct {
		lerp: bool := true;
		const offs: Image;
		const thumb: Image;
		const aspect: float32;
		fpsCount: int32 := 0;
		fpsTime: float32 := 0;
		const eval(in: vec4f): vec4f;
	};
	static onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return .result := 0;
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
		}
		if ((action) == Gui.KEY_RELEASE) {
			if (button == (' ')) {
				text: char[256] := {
				};
				now: int64 := System.millis();
				time: float32 := ((now - start)) / 1000.000000;
				eval(closure.offs, null, closure.aspect, time, closure.eval);
				append(text, append(text, 0, "Millis: "), System.millis() - now);
				Gui.setTitle(text);
				return .result := 0;
			}
			if (button == ('\t')) {
				closure.lerp := !closure.lerp;
			}
			if (button == ('S')) {
				trace("dumping screen");
				closure.offs.saveBmp(closure.offs, "out/offs.bmp", 0);
				closure.thumb.saveBmp(closure.thumb, "out/thumb.bmp", 0);
			}
		}
		time: float32 := ((System.millis() - start)) / 1000.000000;
		eval(closure.thumb, null, closure.aspect, time, closure.eval);
		resize(closure.offs, null, closure.thumb, null, closure.lerp ? 1 : 0);
		if (time > closure.fpsTime) {
			text: char[256] := {
			};
			append(text, append(text, 0, "Fps: "), closure.fpsCount);
			Gui.setTitle(text);
			closure.fpsTime := time + (1);
			closure.fpsCount := 0;
		}
		closure.fpsCount := closure.fpsCount + 1;
		return .result := 1;
	};
	if (animationResolution == 0) {
		aspect: float32 := (width) / float32(height);
		image: Image := Image(width, height, 32);
		eval(image, null, aspect, 0.000000, eval);
		show(image, null);
		image.destroy(image);
		return;
	}
	closure: Closure := {
		closure.offs := Image(width, height, 32);
		closure.thumb := Image(animationResolution, animationResolution, 32);
		closure.aspect := (width) / float32(height);
		closure.eval := eval;
		closure.lerp := true;
		closure.fpsCount := 0;
		closure.fpsTime := (0);
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy(closure.thumb);
	closure.offs.destroy(closure.offs);
}
.instructions: (176 bytes)
	cmplGfx/gfxlib.ci:128: (82 bytes): if (animationResolution == 0)
	<show>  : dup.x32 sp(2)
	<show+?>: load.z32
	<show+?>: ceq.i32
	<show+?>: jz +78
	cmplGfx/gfxlib.ci:129: (7 bytes): aspect: float32 := (width) / float32(height)
	<show+?>: dup.x32 sp(4)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(4)
	<show+?>: i32.2f32
	<show+?>: div.f32
	cmplGfx/gfxlib.ci:130: (13 bytes): image: Image := Image(width, height, 32)
	<show+?>: dup.x32 sp(5)
	<show+?>: dup.x32 sp(5)
	<show+?>: load.c32 32
	<show+?>: nfc(83) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/gfxlib.ci:131: (22 bytes): eval(image, null, aspect, 0.000000, eval);
	<show+?>: dup.x64 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: dup.x32 sp(5)
	<show+?>: load.z32
	<show+?>: dup.x32 sp(9)
	<show+?>: load.ref <?> ;eval(image: Image, roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void
	<show+?>: call
	<show+?>: inc.sp(-24)
	cmplGfx/gfxlib.ci:132: (17 bytes): show(image, null);
	<show+?>: dup.x64 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void
	<show+?>: call
	<show+?>: inc.sp(-12)
	cmplGfx/gfxlib.ci:133: (6 bytes): image.destroy(image);
	<show+?>: dup.x64 sp(0)
	<show+?>: nfc(87) ;Image.destroy(image: Image): void
	cmplGfx/gfxlib.ci:134: (5 bytes): return;
	<show+?>: inc.sp(-12)
	<show+?>: ret
	<show+?>: inc.sp(-12)
	cmplGfx/gfxlib.ci:137: (62 bytes): closure: Closure := {...}
	<show+?>: inc.sp(+40)
	cmplGfx/gfxlib.ci:138: (15 bytes): closure.offs := Image(width, height, 32);
	<show+?>: dup.x32 sp(14)
	<show+?>: dup.x32 sp(14)
	<show+?>: load.c32 32
	<show+?>: nfc(83) ;Image.create(width: int32, height: int32, depth: int32): Image
	<show+?>: set.x64 sp(4)
	cmplGfx/gfxlib.ci:139: (15 bytes): closure.thumb := Image(animationResolution, animationResolution, 32);
	<show+?>: dup.x32 sp(12)
	<show+?>: dup.x32 sp(13)
	<show+?>: load.c32 32
	<show+?>: nfc(83) ;Image.create(width: int32, height: int32, depth: int32): Image
	<show+?>: set.x64 sp(6)
	cmplGfx/gfxlib.ci:140: (9 bytes): closure.aspect := (width) / float32(height);
	<show+?>: dup.x32 sp(14)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(14)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: set.x32 sp(7)
	cmplGfx/gfxlib.ci:141: (3 bytes): closure.eval := eval;
	<show+?>: mov.x32 sp(9, 11)
	:: (10 bytes): closure.lerp := true;
	<show+?>: load.c32 1
	<show+?>: load.sp(+4)
	<show+?>: store.i8
	:: (3 bytes): closure.fpsCount := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(8)
	:: (3 bytes): closure.fpsTime := (0);
	<show+?>: load.z32
	<show+?>: set.x32 sp(9)
	cmplGfx/gfxlib.ci:143: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(130) ;Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/gfxlib.ci:144: (6 bytes): closure.thumb.destroy(closure.thumb);
	<show+?>: dup.x64 sp(4)
	<show+?>: nfc(87) ;Image.destroy(image: Image): void
	cmplGfx/gfxlib.ci:145: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x64 sp(2)
	<show+?>: nfc(87) ;Image.destroy(image: Image): void
	<show+?>: inc.sp(-40)
	<show+?>: ret
.usages:
}
show(mesh: Mesh, w: int32, h: int32, fovy: float32): void: function {
.kind: static function
.base: `function`
.size: 234
.name: 'show'
.file: 'cmplGfx/gfxlib.ci:149'
.param .result: void (size: 0, cast: variable(void))
.param mesh: Mesh (size: 4, cast: variable(ref))
.param w: int32 (size: 4, cast: variable(i32))
.param h: int32 (size: 4, cast: variable(i32))
.param fovy: float32 (size: 4, cast: variable(f32))
.doc: 'Show the mesh in a window'
.value: {
	static const Closure: struct {
		fpsCount: int32 := 0;
		fpsShow: int32 := 0;
		fpsTime: int64 := 0;
		mode: int32;
		offs: Image;
		proj: mat4f;
		cam: Camera;
		mesh: Mesh;
		static updateCamera(const this: Closure): void := {
			camera: Camera := this.cam;
			camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		};
	};
	static next(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		next := next + (mask & -mask);
		next := next & mask;
		return .result := next | (x & ~mask);
	};
	static onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		static ox: int32 := 0;
		static oy: int32 := 0;
		static const speed: float32 := (1) / 100.000000;
		if ((action) == Gui.FINGER_MOTION) {
			action := (Gui.MOUSE_MOTION);
		}
		if ((action) == Gui.KEY_PRESS) {
			if (button == 27) {
				return .result := -1;
			}
			else if (button == ('l')) {
				closure.mode := ((closure.mode) ^ Mesh.useLights);
			}
			else if (button == ('0')) {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == ('1')) {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == ('2')) {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == ('3')) {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == ('t')) {
				closure.mode := ((closure.mode) ^ Mesh.useTexture);
			}
			else if (button == ('/')) {
				closure.mode := next(closure.mode, Mesh.cullBack | Mesh.cullFront);
			}
			else if (button == ('\t')) {
				closure.mode := next(closure.mode, Mesh.drawMode);
			}
			else if (button == ('\r')) {
				eye: vec4f := {
					eye.x := (0);
					eye.y := (0);
					eye.z := (2);
					eye.w := (1);
				};
				at: vec4f := {
					at.x := (0);
					at.y := (0);
					at.z := (0);
					at.w := (1);
				};
				up: vec4f := {
					up.x := (0);
					up.y := (1);
					up.z := (0);
					up.w := (1);
				};
				closure.cam := Camera.lookAt(eye, at, up);
				closure.updateCamera(closure);
			}
		}
		else if ((action) == Gui.MOUSE_PRESS) {
			ox := ex;
			oy := ey;
			return .result := 0;
		}
		else if ((action) == Gui.MOUSE_MOTION) {
			camera: Camera := closure.cam;
			dx: int32 := ex - ox;
			dy: int32 := ey - oy;
			if (button == 1) {
				camera.rotate(camera, vec4f(0), camera.up, (dx) * speed);
				camera.rotate(camera, vec4f(0), camera.right, (dy) * speed);
				closure.updateCamera(closure);
			}
			else if (button == 2) {
				camera.rotate(camera, camera.up, (-dx) * speed);
				camera.rotate(camera, camera.right, (-dy) * speed);
				closure.updateCamera(closure);
			}
			else if (button == 3) {
				camera.move(camera, camera.forward, (dy) * speed);
				closure.updateCamera(closure);
			}
			else if (button == 4) {
				camera.move(camera, camera.right, (-dx) * speed);
				camera.move(camera, camera.up, (dy) * speed);
				closure.updateCamera(closure);
			}
			ox := ex;
			oy := ey;
		}
		rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
		text: char[256] := {
		};
		pos: int32 := append(text, 0, "Vertices: ");
		pos := append(text, pos, closure.mesh.vertices);
		pos := append(text, pos, ", Triangles: ");
		pos := append(text, pos, closure.mesh.triangles);
		pos := append(text, pos, "/");
		pos := append(text, pos, rendered);
		pos := append(text, pos, ", Fps: ");
		pos := append(text, pos, closure.fpsShow);
		Gui.setTitle(text);
		time: int64 := System.millis();
		if (time > closure.fpsTime) {
			closure.fpsTime := time + (1000);
			closure.fpsShow := closure.fpsCount;
			closure.fpsCount := 0;
		}
		closure.fpsCount := closure.fpsCount + 1;
		return .result := 0;
	};
	closure: Closure := {
		closure.mode := (Mesh.clearDepth | Mesh.clearColor | Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
		closure.offs := Image.create3d(w, h);
		closure.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
		closure.cam := Camera.lookAt(vec4f(0, 0, 2), vec4f(0), vec4f(0, 1, 0));
		closure.mesh := mesh;
		closure.fpsCount := 0;
		closure.fpsShow := 0;
		closure.fpsTime := (0);
	};
	closure.updateCamera(closure);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy(closure.offs);
}
.instructions: (234 bytes)
	cmplGfx/gfxlib.ci:282: (194 bytes): closure: Closure := {...}
	<show>  : inc.sp(+168)
	cmplGfx/gfxlib.ci:283: (52 bytes): closure.mode := (Mesh.clearDepth | Mesh.clearColor | Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
	<show+?>: load.c64 8
	<show+?>: load.c64 4
	<show+?>: or.b64
	<show+?>: load.c64 128
	<show+?>: or.b64
	<show+?>: load.c64 16
	<show+?>: or.b64
	<show+?>: load.c64 3
	<show+?>: or.b64
	<show+?>: i64.2i32
	<show+?>: set.x32 sp(5)
	cmplGfx/gfxlib.ci:284: (10 bytes): closure.offs := Image.create3d(w, h);
	<show+?>: dup.x32 sp(45)
	<show+?>: dup.x32 sp(45)
	<show+?>: nfc(84) ;Image.create3d(width: int32, height: int32): Image
	<show+?>: set.x64 sp(8)
	cmplGfx/gfxlib.ci:285: (49 bytes): closure.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
	<show+?>: inc.sp(+64)
	<show+?>: dup.x32 sp(59)
	<show+?>: dup.x32 sp(62)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(62)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: load.f32 1.000000
	<show+?>: load.f32 100.000000
	<show+?>: load.ref <?> ;Camera.projection(fov: float32, asp: float32, n: float32, f: float32): mat4f
	<show+?>: call
	<show+?>: inc.sp(-16)
	<show+?>: load.sp(+96)
	<show+?>: load.sp(+4)
	<show+?>: copy.mem 64
	<show+?>: inc.sp(-64)
	cmplGfx/gfxlib.ci:286: (67 bytes): closure.cam := Camera.lookAt(vec4f(0, 0, 2), vec4f(0), vec4f(0, 1, 0));
	<show+?>: inc.sp(+64)
	<show+?>: load.f32 1.000000
	<show+?>: load.f32 2.000000
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: set.x128 sp(16)
	<show+?>: load.z32
	<show+?>: dup.x32 sp(0)
	<show+?>: dup.x32 sp(1)
	<show+?>: dup.x32 sp(2)
	<show+?>: dup.x32 sp(3)
	<show+?>: set.x128 sp(1)
	<show+?>: set.x128 sp(12)
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: set.x128 sp(8)
	<show+?>: load.ref <?> ;Camera.lookAt(position: vec4f, target: vec4f, up: vec4f): Camera
	<show+?>: call
	<show+?>: load.sp(+160)
	<show+?>: load.sp(+4)
	<show+?>: copy.mem 64
	<show+?>: inc.sp(-64)
	cmplGfx/gfxlib.ci:287: (3 bytes): closure.mesh := mesh;
	<show+?>: mov.x32 sp(40, 46)
	:: (3 bytes): closure.fpsCount := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(1)
	:: (3 bytes): closure.fpsShow := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(2)
	:: (3 bytes): closure.fpsTime := (0);
	<show+?>: load.z64
	<show+?>: set.x64 sp(4)
	cmplGfx/gfxlib.ci:289: (14 bytes): closure.updateCamera(closure);
	<show+?>: load.sp(+0)
	<show+?>: load.ref <?> ;show.Closure.updateCamera(this: Closure): void
	<show+?>: call
	<show+?>: inc.sp(-4)
	cmplGfx/gfxlib.ci:290: (15 bytes): Gui.showWindow(closure.offs, closure, onEvent);
	<show+?>: dup.x64 sp(6)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;show.onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(130) ;Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/gfxlib.ci:291: (6 bytes): closure.offs.destroy(closure.offs);
	<show+?>: dup.x64 sp(6)
	<show+?>: nfc(87) ;Image.destroy(image: Image): void
	<show+?>: inc.sp(-168)
	<show+?>: ret
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 89
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, cast: static const typename(ref))
.field void: typename (size: 0, cast: static const typename(void))
.field bool: typename (size: 1, cast: static const typename(bool))
.field char: typename (size: 1, cast: static const typename(i32))
.field int8: typename (size: 1, cast: static const typename(i32))
.field int16: typename (size: 2, cast: static const typename(i32))
.field int32: typename (size: 4, cast: static const typename(i32))
.field int64: typename (size: 8, cast: static const typename(i64))
.field uint8: typename (size: 1, cast: static const typename(u32))
.field uint16: typename (size: 2, cast: static const typename(u32))
.field uint32: typename (size: 4, cast: static const typename(u32))
.field uint64: typename (size: 8, cast: static const typename(u64))
.field float32: typename (size: 4, cast: static const typename(f32))
.field float64: typename (size: 8, cast: static const typename(f64))
.field pointer: typename (size: 4, cast: static const typename(ref))
.field variant: typename (size: 8, cast: static const typename(var))
.field function: typename (size: 4, cast: static const typename(ref))
.field object: typename (size: 4, cast: static const typename(ref))
.field null: pointer (size: 0, cast: static const inline)
.field int: typename (size: 0, cast: static const inline)
.field .cstr: char (size: 4, cast: static const typename(arr))
.field emit: function (size: 0, cast: static const typename(void))
.field halt: function (size: 0, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, cast: static const i64)
.field RAND_MAX: int64 (size: 0, cast: static const i64)
.field raise: function (size: 0, cast: static const inline)
.field tryExec: function (size: 0, cast: static const inline)
.field System: typename (size: 0, cast: static const typename(void))
.field true: bool (size: 0, cast: static const val)
.field false: bool (size: 0, cast: static const val)
.field byte: typename (size: 0, cast: inline)
.field float: typename (size: 0, cast: inline)
.field double: typename (size: 0, cast: inline)
.field signed: function (size: 0, cast: inline)
.field signed: function (size: 0, cast: inline)
.field signed: function (size: 0, cast: inline)
.field signed: function (size: 0, cast: inline)
.field unsigned: function (size: 0, cast: inline)
.field unsigned: function (size: 0, cast: inline)
.field unsigned: function (size: 0, cast: inline)
.field unsigned: function (size: 0, cast: inline)
.field sizeof: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field NotEquals: typename (size: 24, cast: static const typename(val))
.field assertEq: function (size: 103, cast: static function)
.field assertEq: function (size: 0, cast: inline)
.field Math: typename (size: 0, cast: static const typename(void))
.field Complex: typename (size: 16, cast: static const typename(val))
.field Complex: function (size: 7, cast: static function)
.field Complex: function (size: 7, cast: static function)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 139, cast: static function)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field arg: function (size: 0, cast: inline)
.field inv: function (size: 31, cast: static function)
.field conj: function (size: 0, cast: inline)
.field exp: function (size: 0, cast: inline)
.field log: function (size: 0, cast: inline)
.field pow: function (size: 100, cast: static function)
.field pow: function (size: 0, cast: inline)
.field sin: function (size: 0, cast: inline)
.field cos: function (size: 0, cast: inline)
.field tan: function (size: 0, cast: inline)
.field cot: function (size: 0, cast: inline)
.field sinh: function (size: 0, cast: inline)
.field cosh: function (size: 0, cast: inline)
.field tanh: function (size: 0, cast: inline)
.field coth: function (size: 0, cast: inline)
.field sec: function (size: 0, cast: inline)
.field csc: function (size: 0, cast: inline)
.field sech: function (size: 0, cast: inline)
.field csch: function (size: 0, cast: inline)
.field toCartesian: function (size: 0, cast: inline)
.field toPolar: function (size: 0, cast: inline)
.field vec4f: typename (size: 16, cast: static const typename(val))
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field clamp: function (size: 0, cast: inline)
.field clamp: function (size: 0, cast: inline)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field cross: function (size: 0, cast: inline)
.field length: function (size: 0, cast: inline)
.field normalize: function (size: 0, cast: inline)
.field eval: function (size: 0, cast: inline)
.field mat4f: typename (size: 64, cast: static const typename(val))
.field mat4f: function (size: 49, cast: static function)
.field mat4f: function (size: 21, cast: static function)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field transpose: function (size: 49, cast: static function)
.field mul: function (size: 245, cast: static function)
.field rotation: function (size: 454, cast: static function)
.field rotation: function (size: 0, cast: inline)
.field translation: function (size: 88, cast: static function)
.field scale: function (size: 217, cast: static function)
.field vec2d: typename (size: 16, cast: static const typename(val))
.field vec2d: function (size: 7, cast: static function)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field ceq: function (size: 0, cast: inline)
.field dot: function (size: 0, cast: inline)
.field length: function (size: 38, cast: static function)
.field indexOf: function (size: 50, cast: static function)
.field lastIndexOf: function (size: 50, cast: static function)
.field startsWith: function (size: 73, cast: static function)
.field endsWith: function (size: 126, cast: static function)
.field compare: function (size: 63, cast: static function)
.field ignCaseCmp: function (size: 36, cast: static function)
.field caseCmp: function (size: 14, cast: static function)
.field toHex: function (size: 0, cast: inline)
.field startsWith: function (size: 0, cast: inline)
.field endsWith: function (size: 0, cast: inline)
.field compare: function (size: 0, cast: inline)
.field equals: function (size: 0, cast: inline)
.field contains: function (size: 0, cast: inline)
.field FormatFlags: typename (size: 16, cast: static const typename(val))
.field append: function (size: 84, cast: static function)
.field append: function (size: 707, cast: static function)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 236, cast: static function)
.field append: function (size: 0, cast: inline)
.field append: function (size: 63, cast: static function)
.field File: typename (size: 8, cast: static const typename(val))
.field Rect: typename (size: 16, cast: static const typename(val))
.field Image: typename (size: 8, cast: static const typename(val))
.field Mesh: typename (size: 176, cast: static const typename(ref))
.field gradient: function (size: 0, cast: static const inline)
.field camera: function (size: 0, cast: static const inline)
.field lights: typename (size: 0, cast: static const typename(void))
.field Gui: typename (size: 0, cast: static const typename(void))
.field argb: typename (size: 4, cast: static const typename(val))
.field argb: function (size: 0, cast: inline)
.field uint32: function (size: 0, cast: inline)
.field clamp_s8: function (size: 36, cast: static function)
.field clamp_u8: function (size: 24, cast: static function)
.field _gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field _argb: function (size: 0, cast: inline)
.field _argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field ach: function (size: 0, cast: inline)
.field rch: function (size: 0, cast: inline)
.field gch: function (size: 0, cast: inline)
.field bch: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field hue: function (size: 205, cast: static function)
.field lerpLut: function (size: 223, cast: static function)
.field alphaLut: function (size: 347, cast: static function)
.field vec4f: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field hsv2rgb: function (size: 270, cast: static function)
.field rgb2hsl: function (size: 544, cast: static function)
.field hsl2rgb: function (size: 163, cast: static function)
.field Image: function (size: 0, cast: inline)
.field Image: function (size: 40, cast: static function)
.field Image: function (size: 565, cast: static function)
.field Image: function (size: 49, cast: static function)
.field Image: function (size: 0, cast: inline)
.field Image: function (size: 55, cast: static function)
.field Image: function (size: 0, cast: inline)
.field Image: function (size: 0, cast: inline)
.field set: function (size: 0, cast: inline)
.field colorMap: function (size: 0, cast: inline)
.field resize: function (size: 0, cast: inline)
.field slice: function (size: 0, cast: inline)
.field clip: function (size: 235, cast: static function)
.field fill: function (size: 0, cast: inline)
.field fill: function (size: 0, cast: inline)
.field fill: function (size: 0, cast: inline)
.field drawRect: function (size: 0, cast: inline)
.field fillRect: function (size: 0, cast: inline)
.field eval: function (size: 371, cast: static function)
.field tile: function (size: 251, cast: static function)
.field Mesh: function (size: 109, cast: static function)
.field Camera: typename (size: 64, cast: static const typename(val))
.field show: function (size: 0, cast: inline)
.field show: function (size: 43, cast: static function)
.field showDiff: function (size: 48, cast: static function)
.field show: function (size: 176, cast: static function)
.field show: function (size: 234, cast: static function)
.field .main: function (size: 89, cast: static function)
.value: {
	{
		byte: typename := uint8;
		float: typename := float32;
		double: typename := float64;
		signed(value: uint8): int8 := int8(value);
		signed(value: uint16): int16 := int16(value);
		signed(value: uint32): int32 := int32(value);
		signed(value: uint64): int64 := int64(value);
		unsigned(value: int8): uint8 := uint8(value);
		unsigned(value: int16): uint16 := uint16(value);
		unsigned(value: int32): uint32 := uint32(value);
		unsigned(value: int64): uint64 := uint64(value);
		sizeof(type: typename): int32 := typename.size(type);
		static if (typename(raise) == function) {
			verbose(const message: char[*], const inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(const message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			debug(const message: char[*], const inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(const message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			trace(const message: char[*], const inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(const message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			info(const message: char[*], const inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(const message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(const message: char[*], const inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(const message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(const message: char[*], const inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(const message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(const message: char[*], const inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(const message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[] := null;
			};
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				extras: variant[1] := {
					extras[0] := (message);
				};
				details: NotEquals := {
					details.expected := (expected);
					details.returned := (returned);
					details.extras := (extras);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := -modf(-x, &intPart);
						intPart := -intPart;
						return .result := result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static floor(x: float64): float64 := {
				result: float64;
				modf(x, &result);
				return .result := result;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static sign(x: int32): int32 := x != 0 ? x < 0 ? -1 : 1 : 0;
			static sign(x: int64): int32 := x != (0) ? x < (0) ? -1 : 1 : 0;
			static sign(x: uint32): int32 := x > (0) ? 1 : 0;
			static sign(x: uint64): int32 := x > (0) ? 1 : 0;
			static sign(x: float32): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: float64): int32 := int32(x > (0)) - int32(x < (0));
			static absMod(val: float32, mod: float32): float32 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static absMod(val: float64, mod: float64): float64 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static abs(x: int32): int32 := x < 0 ? -x : x;
			static abs(x: int64): int64 := x < (0) ? -x : x;
			static abs(x: uint32): uint32 := x;
			static abs(x: uint64): uint64 := x;
			static abs(x: float32): float32 := x < (0) ? -x : x;
			static abs(x: float64): float64 := x < (0) ? -x : x;
			static min(a: int32, b: int32): int32 := a < b ? a : b;
			static min(a: int64, b: int64): int64 := a < b ? a : b;
			static min(a: uint32, b: uint32): uint32 := a < b ? a : b;
			static min(a: uint64, b: uint64): uint64 := a < b ? a : b;
			static min(a: float32, b: float32): float32 := a < b ? a : b;
			static min(a: float64, b: float64): float64 := a < b ? a : b;
			static max(a: int32, b: int32): int32 := a > b ? a : b;
			static max(a: int64, b: int64): int64 := a > b ? a : b;
			static max(a: uint32, b: uint32): uint32 := a > b ? a : b;
			static max(a: uint64, b: uint64): uint64 := a > b ? a : b;
			static max(a: float32, b: float32): float32 := a > b ? a : b;
			static max(a: float64, b: float64): float64 := a > b ? a : b;
			static clamp(t: float32, a: float32, b: float32): float32 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static clamp(t: float64, a: float64, b: float64): float64 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static lerp(t: float32, a: float32, b: float32): float32 := a + t * (b - a);
			static lerp(t: float64, a: float64, b: float64): float64 := a + t * (b - a);
			static smooth(t: float32): float32 := t * t * ((3) - (2) * t);
			static smooth(t: float64): float64 := t * t * ((3) - (2) * t);
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp((t - a) / (b - a), float32(0), float32(1)));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp((t - a) / (b - a), float64(0), float64(1)));
			static min(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result > data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static max(data: float64[]): float64 := {
				if (data.length == (0)) {
					return .result := nan;
				}
				result: float64 := data[0];
				for (i: int32 := 1; i < (data.length); i := i + 1) {
					if (result < data[i]) {
						result := data[i];
					}
				}
				return .result := result;
			};
			static sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; i < (data.length); i := i + 1) {
					result := result + data[i];
				}
				return .result := result;
			};
			static mean(data: float64[]): float64 := {
				return .result := sum(...data) / (signed(data.length));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (a0 + x * a1);
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (a0 + x * eval(x, a1, a2));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (a0 + x * eval(x, a1, a2, a3));
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
					result := result * x + polynomial[i];
				}
				return .result := result;
			};
			static cmp(a: float32, b: float32, eps: float32): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else if (eps < (a - b)) {
					return .result := +1;
				}
				return .result := 0;
			};
			static cmp(a: float64, b: float64, eps: float64): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else if (eps < (a - b)) {
					return .result := +1;
				}
				return .result := 0;
			};
			static sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (1) / PIO2;
				if (x > (32764)) {
					e: float64;
					y := modf(x, &e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, &f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
				temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
				return .result := temp1 / temp2;
			};
			static sin(arg: float64): float64 := sinCos(arg, 0);
			static cos(arg: float64): float64 := sinCos(abs(arg), 1);
			static tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (arg < (0)) {
					arg := -arg;
					negate := true;
				}
				arg := (2) * arg / PIO2;
				e: float64;
				x: float64 := modf(arg, &e);
				i: int32 := int32(e) % 4;
				if (i == 0) ;
				else if (i == 1) {
					x := (1) - x;
					complement := true;
				}
				else if (i == 2) {
					negate := !negate;
					complement := true;
				}
				else if (i == 3) {
					x := (1) - x;
					negate := !negate;
				}
				xsq: float64 := x * x;
				result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
				result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
				if (complement) {
					if (result == (0)) {
						return .result := nan;
					}
					result := (1) / result;
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static sinh(x: float64): float64 := {
				negate: bool := false;
				if (x < (0)) {
					x := -x;
					negate := true;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				result: float64;
				if (x > 0.500000) {
					result := (float64.exp(x) - float64.exp(-x)) / (2);
				}
				else {
					sq: float64 := x * x;
					result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
					result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static cosh(x: float64): float64 := {
				if (x < (0)) {
					x := -x;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				return .result := (float64.exp(x) + float64.exp(-x)) / (2);
			};
			static asin(x: float64): float64 := {
				if (x == (0)) {
					return .result := x;
				}
				negate: bool := false;
				if (x < (0)) {
					negate := true;
					x := -x;
				}
				if (x > (1)) {
					return .result := nan;
				}
				result: float64 := float64.sqrt((1) - x * x);
				if (x > 0.700000) {
					result := pi / (2) - float64.atan2(result, x);
				}
				else {
					result := float64.atan2(x, result);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static acos(x: float64): float64 := (pi / (2) - asin(x));
			static radians(degrees: float64): float64 := float64(degrees * pi / (180));
			static degrees(radians: float64): float64 := float64(radians * (180) / pi);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(re: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := (0);
		};
		};
		static Complex(re: float64, im: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := im;
		};
		};
		neg(a: Complex): Complex := Complex(emit(struct(a), neg.p2d));
		add(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), add.p2d));
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), sub.p2d));
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), swz.x2, mul.p2d, add.f64, struct(a), struct(b), mul.p2d, swz.x2, sub.f64));
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := float64.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := float64.atan2(a.re, a.im);
		static inv(a: Complex): Complex := {
			d: float64 := a.re * a.re + a.im * a.im;
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));
		log(a: Complex): Complex := Complex(float64.log(abs(a)), arg(a));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * float64.log(r);
			v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
			return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(struct(w), struct(z), struct(y), struct(x)));
		vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(x, y, z, 1.000000);
		vec4f(x: float32, y: float32): vec4f := vec4f(x, y, 0.000000, 1.000000);
		vec4f(xyz: vec4f, w: float32): vec4f := vec4f(xyz.x, xyz.y, xyz.z, w);
		vec4f(val: float32): vec4f := vec4f(val, val, val, val);
		neg(rhs: vec4f): vec4f := vec4f(emit(struct(rhs), neg.p4f));
		add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), add.p4f));
		sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
		mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
		div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), div.p4f));
		add(a: float32, b: vec4f): vec4f := add(vec4f(a), b);
		add(a: vec4f, b: float32): vec4f := add(a, vec4f(b));
		sub(a: float32, b: vec4f): vec4f := sub(vec4f(a), b);
		sub(a: vec4f, b: float32): vec4f := sub(a, vec4f(b));
		mul(a: float32, b: vec4f): vec4f := mul(vec4f(a), b);
		mul(a: vec4f, b: float32): vec4f := mul(a, vec4f(b));
		div(a: float32, b: vec4f): vec4f := div(vec4f(a), b);
		div(a: vec4f, b: float32): vec4f := div(a, vec4f(b));
		min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), min.p4f));
		max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), max.p4f));
		clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(max(vec, min), max);
		clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(vec, vec4f(min), vec4f(max));
		dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp3));
		dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dph));
		dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp4));
		cross(const a: vec4f, const b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
		length(v: vec4f): float32 := float32.sqrt(dp3(v, v));
		normalize(const v: vec4f): vec4f := div(v, vec4f(length(v)));
		eval(const v: vec4f, x: float32): float32 := float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return .result := {
			.result.xx := xx;
			.result.xy := xy;
			.result.xz := xz;
			.result.xw := xw;
			.result.yx := yx;
			.result.yy := yy;
			.result.yz := yz;
			.result.yw := yw;
			.result.zx := zx;
			.result.zy := zy;
			.result.zz := zz;
			.result.zw := zw;
			.result.wx := wx;
			.result.wy := wy;
			.result.wz := wz;
			.result.ww := ww;
		};
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
		};
		dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000);
		dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
		dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
		static transpose(const mat: mat4f): mat4f := {
			return .result := {
			.result.xx := mat.xx;
			.result.xy := mat.yx;
			.result.xz := mat.zx;
			.result.xw := mat.wx;
			.result.yx := mat.xy;
			.result.yy := mat.yy;
			.result.yz := mat.zy;
			.result.yw := mat.wy;
			.result.zx := mat.xz;
			.result.zy := mat.yz;
			.result.zz := mat.zz;
			.result.zw := mat.wz;
			.result.wx := mat.xw;
			.result.wy := mat.yw;
			.result.wz := mat.zw;
			.result.ww := mat.ww;
		};
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if ((len) < 0.000000) {
				trace("invalid direction of rotation", direction);
				return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
			}
			x: float32 := direction.x / len;
			y: float32 := direction.y / len;
			z: float32 := direction.z / len;
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := x * x;
			xy: float32 := x * y;
			xz: float32 := x * z;
			yy: float32 := y * y;
			yz: float32 := y * z;
			zz: float32 := z * z;
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := (1) - c;
			return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
		};
		rotation(const direction: vec4f, angle: float32): mat4f := rotation(vec4f(0), direction, angle);
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return .result := {
			.result.xx := (1);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := direction.x * amount;
			.result.yx := (0);
			.result.yy := (1);
			.result.yz := (0);
			.result.yw := direction.y * amount;
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := (1);
			.result.zw := direction.z * amount;
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
			return .result := {
			.result.xx := rcp(direction.x * amount);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := (0);
			.result.yx := (0);
			.result.yy := rcp(direction.y * amount);
			.result.yz := (0);
			.result.yw := (0);
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := rcp(direction.z * amount);
			.result.zw := (0);
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return .result := {
			.result.x := x;
			.result.y := y;
		};
		};
		add(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), add.p2d));
		sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), sub.p2d));
		mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), mul.p2d));
		div(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), div.p2d));
		min(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), min.p2d));
		max(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), max.p2d));
		ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), ceq.p2d));
		dot(const a: vec2d, const b: vec2d): float64 := a.x * b.x + a.y * b.y;
		static length(const str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (chr < 'A') {
					return .result := chr;
				}
				if (chr > 'Z') {
					return .result := chr;
				}
				return .result := chr - 'A' + 'a';
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		toHex(value: int32): int32 := int32("0123456789abcdef"[value & 15]);
		startsWith(const str: char[*], const with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(const str: char[*], const with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(const str: char[*], const with: char[*]): int32 := compare(str, with, caseCmp);
		equals(const str: char[*], const with: char[*]): bool := compare(str, with, caseCmp) == 0;
		contains(const str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			if (format.showSign) {
				if ((sign) == 0) {
					sign := '+';
				}
			}
			radix: int32 := format.precision;
			if (radix == 0) {
				radix := 10;
			}
			assert(radix > 1, "radix is too small", radix);
			assert(radix < (radixDigits.length), "radix is too big", radix);
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.padLen - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if ((sign) != 0) {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(output, pos, 0, uint64(value), format);
		append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(output, pos, value < (0) ? ('-') : 0, uint64(value < (0) ? -value : value), format);
		append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(output, pos, value < 0 ? ('-') : 0, uint64(value < 0 ? -value : value), format);
		append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format);
		append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(output, pos, (value) < 0 ? ('-') : 0, uint64((value) < 0 ? -value : value), format);
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				formatInt.showSign := format.showSign;
				formatInt.precision := 0;
				formatInt.padChr := format.padChr;
				formatInt.padLen := format.padLen - format.precision;
			};
			formatDec: FormatFlags := {
				formatDec.showSign := false;
				formatDec.precision := 0;
				formatDec.padChr := '0';
				formatDec.padLen := format.precision;
			};
			sign: char := value < (0) ? ('-') : 0;
			fract: float64 := Math.modf(Math.abs(value), &value);
			pos := append(output, pos, sign, uint64(int64(value)), formatInt);
			pos := append(output, pos, ".");
			fract := fract * float64.pow(10, format.precision);
			pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
			return .result := pos;
		};
		append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(output, pos, float64(value), format);
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				format.showSign := false;
				format.precision := 0;
				format.padChr := (0);
				format.padLen := 0;
			};
			return .result := append(output, pos, value, format);
		};
	}
	{
		static const Rect: struct {
			x: int32;
			y: int32;
			w: int32;
			h: int32;
		};
	}
	{
		static const argb: struct {
			v: uint32;
			<?>: <?>;
			b: uint8 := b: uint8;
			g: uint8 := g: uint8;
			r: uint8 := r: uint8;
			a: uint8 := a: uint8;
		};
		argb(argb: uint32): argb := argb(emit(uint32(argb)));
		uint32(value: argb): uint32 := uint32(emit(struct(value)));
		static clamp_s8(c: int32): uint32 := {
			if (c < 0) {
				return .result := 0;
			}
			if (c > 255) {
				return .result := 255;
			}
			return .result := c;
		};
		static clamp_u8(c: uint32): uint32 := {
			if (c > (255)) {
				return .result := 255;
			}
			return .result := c;
		};
		_gray(c: uint32): argb := argb((((c << 8) | c) << 8) | c);
		gray(c: int32): argb := _gray(clamp_s8(c));
		gray(c: uint32): argb := _gray(clamp_s8(c));
		gray(c: float32): argb := gray(int32(c * (255)));
		gray(c: float64): argb := gray(int32(c * (255)));
		_argb(r: uint32, g: uint32, b: uint32): argb := argb(uint32((((r << 8) | g) << 8) | b));
		_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb := argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));
		argb(r: int32, g: int32, b: int32): argb := _argb(clamp_s8(r), clamp_s8(g), clamp_s8(b));
		argb(r: uint32, g: uint32, b: uint32): argb := _argb(clamp_u8(r), clamp_u8(g), clamp_u8(b));
		argb(r: float32, g: float32, b: float32): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(r: float64, g: float64, b: float64): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(a: int32, r: int32, g: int32, b: int32): argb := _argb(clamp_s8(a), clamp_s8(r), clamp_s8(g), clamp_s8(b));
		argb(a: uint32, r: uint32, g: uint32, b: uint32): argb := _argb(clamp_u8(a), clamp_u8(r), clamp_u8(g), clamp_u8(b));
		argb(a: float32, r: float32, g: float32, b: float32): argb := argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(a: float64, r: float64, g: float64, b: float64): argb := argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)));
		ach(color: argb): int32 := int32((uint32(color) >> 24) & (255));
		rch(color: argb): int32 := int32((uint32(color) >> 16) & (255));
		gch(color: argb): int32 := int32((uint32(color) >> 8) & (255));
		bch(color: argb): int32 := int32(uint32(color) & (255));
		lum(color: argb): int32 := int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16);
		static hue(rgb: argb): uint32 := {
			r: int32 := rch(rgb);
			g: int32 := gch(rgb);
			b: int32 := bch(rgb);
			min: int32 := r;
			max: int32 := r;
			if (min > g) {
				min := g;
			}
			if (min > b) {
				min := b;
			}
			if (max < g) {
				max := g;
			}
			if (max < b) {
				max := b;
			}
			if (max == min) {
				return .result := 0;
			}
			hue: int32 := 0;
			if (max == r) {
				hue := ((g - b) * 60) / (max - min);
			}
			else if (max == g) {
				hue := ((b - r) * 60) / (max - min) + 120;
			}
			else if (max == b) {
				hue := ((r - g) * 60) / (max - min) + 240;
			}
			if (hue < 0) {
				hue := hue + 360;
			}
			return .result := hue;
		};
		static lerpLut(lut: uint32[], colors: argb[]): void := {
			lrp(t: int32, x: uint32, y: uint32): uint32 := x + ((t * ((y - x + (1))) >> 16));
			dt: int32 := (colors.length - (1) << 16) / (lut.length - (1));
			for (i: int32 := 0; i < (lut.length); i := i + 1) {
				t: int32 := i * dt;
				c1: argb := colors[t >> 16];
				c2: argb := colors[(t >> 16) + 1];
				a: int32 := lrp(t & 65535, ach(c1), ach(c2));
				r: int32 := lrp(t & 65535, rch(c1), rch(c2));
				g: int32 := lrp(t & 65535, gch(c1), gch(c2));
				b: int32 := lrp(t & 65535, bch(c1), bch(c2));
				lut[i] := (a << 24 | r << 16 | g << 8 | b);
			}
		};
		static alphaLut(lut: uint32[], hardness: int32, alpha: int32, reflect: bool): void := {
			mid: int32 := hardness <= 0 ? -1 : 255;
			div: int32 := 256 - (clamp_u8(hardness < 0 ? -hardness : hardness));
			for (i: int32 := 0; i < (lut.length); i := i + 1) {
				t: int32 := i * 255 / ((lut.length - (1)));
				lut[i] := clamp_s8((t - mid) * 255 / div + mid);
				if (alpha < 0) {
					lut[i] := (255 - (255 - (lut[i])) * -alpha / 255);
				}
				else {
					lut[i] := (255 - (lut[i] * (alpha) / (255)));
				}
			}
			if (reflect) {
				end: int32 := lut.length - (1);
				mid: int32 := lut.length / (2);
				for (i: int32 := end; i >= mid; i := i - 1) {
					lut[i] := lut[end];
					end := end - 2;
				}
				for (i: int32 := 0; i < mid; i := i + 1) {
					lut[i] := lut[lut.length - (i) - (1)];
				}
			}
		};
		static if ((typename(vec4f)) != null) {
			vec4f(rgb: argb): vec4f := vec4f((rch(rgb)) / 255.000000, (gch(rgb)) / 255.000000, (bch(rgb)) / 255.000000, (ach(rgb)) / 255.000000);
			argb(const vec: vec4f): argb := argb(vec.x, vec.y, vec.z);
			lum(const vec: vec4f): float32 := 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z;
		}
		static hsv2rgb(hsv: vec4f): vec4f := {
			h: float32 := hsv.x;
			s: float32 := hsv.y;
			v: float32 := hsv.z;
			if (s == (0)) {
				return .result := vec4f(v);
			}
			h := h * (360 / 60);
			i: int32 := int32(h);
			f: float32 := h - (i);
			u: float32 := v;
			p: float32 := v * ((1) - s);
			q: float32 := v * ((1) - s * f);
			t: float32 := v * ((1) - s * ((1) - f));
			if (i == 0) {
				return .result := vec4f(u, t, p);
			}
			if (i == 1) {
				return .result := vec4f(q, u, p);
			}
			if (i == 2) {
				return .result := vec4f(p, u, t);
			}
			if (i == 3) {
				return .result := vec4f(p, q, u);
			}
			if (i == 4) {
				return .result := vec4f(t, p, u);
			}
			return .result := vec4f(u, p, q);
		};
		static rgb2hsl(rgb: vec4f): vec4f := {
			min(x: float32, y: float32): float32 := x < y ? x : y;
			max(x: float32, y: float32): float32 := x > y ? x : y;
			clamp(value: float32, min: float32, max: float32): float32 := min(max(value, min), max);
			fmin: float32 := min(min(rgb.x, rgb.y), rgb.z);
			fmax: float32 := max(max(rgb.x, rgb.y), rgb.z);
			delta: float32 := fmax - fmin;
			lum: float32 := (fmax + fmin) / (2);
			if (delta == (0)) {
				return .result := {
			.result.x := (0);
			.result.y := (0);
			.result.z := lum;
		};
			}
			sat: float32;
			if (lum < 0.500000) {
				sat := delta / (fmax + fmin);
			}
			else {
				sat := delta / ((2) - fmax - fmin);
			}
			deltaR: float32 := (((fmax - rgb.x) / (6)) + (delta / (2))) / delta;
			deltaG: float32 := (((fmax - rgb.y) / (6)) + (delta / (2))) / delta;
			deltaB: float32 := (((fmax - rgb.z) / (6)) + (delta / (2))) / delta;
			hue: float32;
			if (rgb.x == fmax) {
				hue := deltaB - deltaG;
			}
			else if (rgb.y == fmax) {
				hue := ((1) / 3.000000) + deltaR - deltaB;
			}
			else if (rgb.z == fmax) {
				hue := ((2) / 3.000000) + deltaG - deltaR;
			}
			if (hue < (0)) {
				hue := hue + (1);
			}
			else if (hue > (1)) {
				hue := hue - (1);
			}
			return .result := {
			.result.x := clamp(hue, 0, 1);
			.result.y := clamp(sat, 0, 1);
			.result.z := clamp(lum, 0, 1);
		};
		};
		static hsl2rgb(hsl: vec4f): vec4f := {
			static hue2rgb(f1: float32, f2: float32, hue: float32): float32 := {
				if (hue < (0)) {
					hue := hue + (1);
				}
				else if (hue > (1)) {
					hue := hue - (1);
				}
				res: float32;
				if (((6) * hue) < (1)) {
					res := f1 + (f2 - f1) * (6) * hue;
				}
				else if (((2) * hue) < (1)) {
					res := f2;
				}
				else if (((3) * hue) < (2)) {
					res := f1 + (f2 - f1) * (((2) / 3.000000) - hue) * (6);
				}
				else {
					res := f1;
				}
				return .result := res;
			};
			if (hsl.y == (0)) {
				return .result := vec4f(hsl.z);
			}
			f2: float32;
			if (hsl.z < 0.500000) {
				f2 := hsl.z * ((1) + hsl.y);
			}
			else {
				f2 := (hsl.z + hsl.y) - (hsl.y * hsl.z);
			}
			f1: float32 := (2) * hsl.z - f2;
			return .result := {
			.result.x := hue2rgb(f1, f2, hsl.x + ((1) / 3.000000));
			.result.y := hue2rgb(f1, f2, hsl.x);
			.result.z := hue2rgb(f1, f2, hsl.x - ((1) / 3.000000));
		};
		};
		Image(width: int32, height: int32, depth: int32): Image := Image.create(width, height, depth);
		static Image(copy: Image): Image := {
			result: Image := Image.create(copy.width(copy), copy.height(copy), copy.depth(copy));
			result.copy(result, 0, 0, copy, null);
			return .result := result;
		};
		static Image(image: Image, width: int32, height: int32, align: int32, maxScale: float64): Image := {
			scale: float64 := 1;
			result: Image := Image(width, height, image.depth(image));
			alignVertical: int32 := align & fitVertical;
			alignHorizontal: int32 := align & fitHorizontal;
			fitWidth: bool := alignVertical == fitVertical;
			fitHeight: bool := alignHorizontal == fitHorizontal;
			if (fitWidth && fitHeight) {
				widthScale: float64 := (width) / float64(image.width(image));
				heightScale: float64 := (height) / float64(image.height(image));
				if (align & fill) {
					scale := Math.max(widthScale, heightScale);
				}
				else {
					scale := Math.min(widthScale, heightScale);
				}
			}
			else if (fitWidth) {
				scale := (width) / float64(image.width(image));
			}
			else if (fitHeight) {
				scale := (height) / float64(image.height(image));
			}
			if (scale > maxScale) {
				scale := maxScale;
			}
			tx: float64 := 0;
			if (fitWidth || alignVertical == center) {
				tx := ((width) - (image.width(image)) * scale) / (2);
			}
			else if (alignVertical == right) {
				tx := ((width) - (image.width(image)) * scale);
			}
			ty: float64 := 0;
			if (fitHeight || alignHorizontal == center) {
				ty := ((height) - (image.height(image)) * scale) / (2);
			}
			else if (alignHorizontal == bottom) {
				ty := ((height) - (image.height(image)) * scale);
			}
			mat: mat4f := {
				mat.x.x := ((1) / scale);
				mat.x.y := (0);
				mat.x.z := (0);
				mat.x.w := (-tx / scale);
				mat.y.x := (0);
				mat.y.y := ((1) / scale);
				mat.y.z := (0);
				mat.y.w := (-ty / scale);
				mat.z.x := (0);
				mat.z.y := (0);
				mat.z.z := ((1) / scale);
				mat.z.w := (0);
				mat.w.x := (0);
				mat.w.y := (0);
				mat.w.z := (0);
				mat.w.w := (1);
			};
			result.transform(result, null, image, null, (align & highRes) ? 1 : 0, mat.data);
			image.destroy(image);
			return .result := result;
		};
		static Image(const fileName: char[*], depth: int32): Image := {
			if (endsWith(fileName, ".bmp", ignCaseCmp)) {
				return .result := Image.openBmp(fileName, depth);
			}
			return .result := Image.openImg(fileName, depth);
		};
		Image(const fileName: char[*]): Image := Image(fileName, 32);
		static Image(const fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): Image := {
			image: Image := Image(fileName, depth);
			result: Image := Image(image, width, height, align, maxScale);
			image.destroy(image);
			return .result := result;
		};
		Image(const fileName: char[*], width: int32, height: int32, depth: int32, align: int32): Image := Image(fileName, width, height, depth, align, Math.inf);
		Image(const fileName: char[*], width: int32, height: int32, depth: int32): Image := Image(fileName, width, height, depth, -1, Math.inf);
		set(image: Image, x: int32, y: int32, color: argb): void := Image.set(image, x, y, uint32(color));
		colorMap(image: Image, const roi: Rect, const lut: argb[256]): void := Image.colorMap(image, roi, pointer(lut));
		resize(image: Image, const rect: Rect, const src: Image, const roi: Rect, interpolate: int32): void := Image.transform(image, rect, src, roi, interpolate, null);
		slice(image: Image, const rect: Rect): Image := Image.slice(Image(0, 0, image.depth(image)), image, rect);
		static clip(src: Image, roi: Rect): bool := {
			roi.w := roi.w + roi.x;
			roi.h := roi.h + roi.y;
			if (roi.x < 0) {
				roi.x := 0;
			}
			if (roi.y < 0) {
				roi.y := 0;
			}
			width: int32 := src.width(src);
			if (roi.w > width) {
				roi.w := width;
			}
			height: int32 := src.height(src);
			if (roi.h > height) {
				roi.h := height;
			}
			roi.w := roi.w - roi.x;
			roi.h := roi.h - roi.y;
			if (roi.w <= 0) {
				return .result := false;
			}
			if (roi.h <= 0) {
				return .result := false;
			}
			return .result := true;
		};
		fill(image: Image, color: uint32): void := image.fillRect(image, 0, 0, 65536, 65536, color);
		fill(image: Image, const roi: Rect, color: uint32): void := image.fillRect(image, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
		fill(image: Image, const roi: Rect, pad: int32, color: uint32): void := image.fillRect(image, roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, color);
		drawRect(image: Image, const roi: Rect, color: uint32): void := image.drawRect(image, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
		fillRect(image: Image, const roi: Rect, color: uint32): void := image.fillRect(image, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
		static eval(image: Image, const roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void := {
			rect: Rect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : image.width(image);
				rect.h := (roi) != null ? roi.h : image.height(image);
			};
			if (!clip(image, &rect)) {
				return;
			}
			w: float32 := image.width(image);
			h: float32 := image.height(image);
			if (aspect == (0)) {
				aspect := w / h;
			}
			h := h * aspect;
			in: vec4f := {
				in.x := (0);
				in.y := (0);
				in.z := (0);
				in.w := time;
			};
			for (y: int32 := rect.y; y < rect.y + rect.h; y := y + 1) {
				in.y := (y) / h;
				for (x: int32 := rect.x; x < rect.x + rect.w; x := x + 1) {
					in.x := (x) / w;
					set(image, x, y, argb(eval(in)));
				}
			}
		};
		static tile(image: Image, x: int32, y: int32, src: Image, const roi: Rect): void := {
			rect: Rect := {
				rect.x := (roi) != null ? roi.x : 0;
				rect.y := (roi) != null ? roi.y : 0;
				rect.w := (roi) != null ? roi.w : src.width(src);
				rect.h := (roi) != null ? roi.h : src.height(src);
			};
			if (!clip(src, &rect)) {
				return;
			}
			if (x < 0) {
				x := -(-x % rect.w);
			}
			if (y < 0) {
				y := -(-y % rect.h);
			}
			width: int32 := image.width(image);
			height: int32 := image.height(image);
			for (j: int32 := y; j < height; j := j + rect.h) {
				for (i: int32 := x; i < width; i := i + rect.w) {
					image.copy(image, i, j, src, rect);
				}
			}
		};
		static Mesh(const fileName: char[*]): Mesh := {
			if (endsWith(fileName, ".obj", ignCaseCmp)) {
				return .result := Mesh.openObj(fileName);
			}
			if (endsWith(fileName, ".3ds", ignCaseCmp)) {
				return .result := Mesh.open3ds(fileName);
			}
			abort("unknown file extension", fileName);
		};
		static const Camera: struct {
			position: vec4f := vec4f(0, 0, 0, 1);
			forward: vec4f := vec4f(0, 0, 0, 1);
			right: vec4f := vec4f(0, 0, 0, 1);
			up: vec4f := vec4f(0, 1, 0, 1);
			static projection(fov: float32, asp: float32, n: float32, f: float32): mat4f := {
				bot: float32 := 1;
				nf: float32 := n - f;
				if (fov == (0)) {
					return .result := {
			.result.x := vec4f((1) / asp, 0, 0, 0);
			.result.y := vec4f(0, (1) / bot, 0, 0);
			.result.z := vec4f(0, 0, (2) / nf, -(f + n) / nf);
			.result.w := vec4f(0, 0, 0, 1);
		};
				}
				bot := float32.tan(Math.radians(fov));
				asp := asp * bot;
				return .result := {
			.result.x := vec4f(n / asp, 0, 0, 0);
			.result.y := vec4f(0, n / bot, 0, 0);
			.result.z := vec4f(0, 0, (n + f) / nf, (-2) * n * f / nf);
			.result.w := vec4f(0, 0, 1, 0);
		};
			};
			static rotation(dir: vec4f, ang: float32): mat4f := {
				sin_t: float32 := float64.sin(ang);
				cos_t: float32 := float64.cos(ang);
				one_c: float32 := 1.000000 - (cos_t);
				tmp: vec4f := mul(dir, sin_t);
				xx: float32 := dir.x * dir.x;
				yy: float32 := dir.y * dir.y;
				zz: float32 := dir.z * dir.z;
				xy: float32 := dir.x * dir.y;
				xz: float32 := dir.x * dir.z;
				yz: float32 := dir.y * dir.z;
				return .result := {
			.result.xx := one_c * xx + cos_t;
			.result.xy := one_c * xy - tmp.z;
			.result.xz := one_c * xz + tmp.y;
			.result.xw := (0);
			.result.yx := one_c * xy + tmp.z;
			.result.yy := one_c * yy + cos_t;
			.result.yz := one_c * yz - tmp.x;
			.result.yw := (0);
			.result.zx := one_c * xz - tmp.y;
			.result.zy := one_c * yz + tmp.x;
			.result.zz := one_c * zz + cos_t;
			.result.zw := (0);
			.result.w := vec4f(0.000000, 0.000000, 0.000000, 1.000000);
		};
			};
			static translation(dir: vec4f, cnt: float32): mat4f := {
				tmp: vec4f := mul(dir, vec4f(cnt));
				return .result := {
			.result.x := vec4f(1, 0, 0, tmp.x);
			.result.y := vec4f(0, 1, 0, tmp.y);
			.result.z := vec4f(0, 0, 1, tmp.z);
			.result.w := vec4f(0, 0, 0, tmp.w);
		};
			};
			static lookAt(position: vec4f, target: vec4f, up: vec4f): Camera := {
				forward: vec4f := normalize(sub(target, position));
				right: vec4f := normalize(cross(up, forward));
				return .result := {
			.result.position := position;
			.result.forward := forward;
			.result.right := right;
			.result.up := cross(forward, right);
		};
			};
			static matrix(const camera: Camera): mat4f := {
				return .result := {
			.result.x := camera.forward;
			.result.y := camera.right;
			.result.z := camera.up;
			.result.w := vec4f(0, 0, 0, 1);
		};
			};
			static matrix(const projection: mat4f, const camera: Camera): mat4f := {
				return .result := mul(projection, matrix(camera));
			};
			static move(camera: Camera, direction: vec4f, amount: float32): void := {
				camera.position := add(camera.position, mul(direction, amount));
			};
			static rotate(camera: Camera, direction: vec4f, amount: float32): void := {
				if (amount == (0)) {
					return;
				}
				matrix: mat4f := rotation(direction, amount);
				camera.forward := normalize(dp3(matrix, camera.forward));
				camera.right := normalize(dp3(matrix, camera.right));
				camera.up := cross(camera.forward, camera.right);
			};
			static rotate(camera: Camera, orbit: vec4f, direction: vec4f, amount: float32): void := {
				if (amount == (0)) {
					return;
				}
				rotate(&camera, direction, amount);
				dist: float32 := length(sub(orbit, camera.position));
				matrix: mat4f := translation(camera.forward, -dist);
				camera.position := dph(matrix, orbit);
			};
		};
		static if ((typename(Image.blur)) == null) {
			raise(raise.debug, raise.noTrace, "emulated/blur.ci", null);
		}
		static if ((typename(Image.blend)) == null) {
			raise(raise.debug, raise.noTrace, "emulated/blend.ci", null);
		}
		static if ((typename(Image.transform)) == null) {
			raise(raise.debug, raise.noTrace, "emulated/transform.ci", null);
		}
		show(surf: Image): void := Gui.showWindow(surf, null, null);
		static show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
			if ((onEvent) == null) {
				return .result := Gui.showWindow(image, null, null);
			}
			static delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				return .result := onEvent(action, button, ex, ey);
			};
			Gui.showWindow(image, onEvent, delegate);
		};
		static showDiff(image1: Image, image2: Image): void := {
			static const Closure: struct {
				offs: Image;
				image1: Image;
				image2: Image;
			};
			static onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.MOUSE_PRESS) {
					closure.offs.copy(closure.offs, 0, 0, closure.image2, null);
					return .result := 0;
				}
				if ((action) == Gui.MOUSE_RELEASE) {
					closure.offs.copy(closure.offs, 0, 0, closure.image1, null);
					return .result := 0;
				}
				return .result := 0;
			};
			closure: Closure := {
				closure.offs := Image(image1);
				closure.image1 := image1;
				closure.image2 := image2;
			};
			Gui.showWindow(closure.offs, closure, onEvent);
		};
		static show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void := {
			static const start: int64 := System.millis();
			static const Closure: struct {
				lerp: bool := true;
				const offs: Image;
				const thumb: Image;
				const aspect: float32;
				fpsCount: int32 := 0;
				fpsTime: float32 := 0;
				const eval(in: vec4f): vec4f;
			};
			static onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				if ((action) == Gui.WINDOW_CLOSE) {
					trace("closing ...");
					return .result := 0;
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
				}
				if ((action) == Gui.KEY_RELEASE) {
					if (button == (' ')) {
						text: char[256] := {
						};
						now: int64 := System.millis();
						time: float32 := ((now - start)) / 1000.000000;
						eval(closure.offs, null, closure.aspect, time, closure.eval);
						append(text, append(text, 0, "Millis: "), System.millis() - now);
						Gui.setTitle(text);
						return .result := 0;
					}
					if (button == ('\t')) {
						closure.lerp := !closure.lerp;
					}
					if (button == ('S')) {
						trace("dumping screen");
						closure.offs.saveBmp(closure.offs, "out/offs.bmp", 0);
						closure.thumb.saveBmp(closure.thumb, "out/thumb.bmp", 0);
					}
				}
				time: float32 := ((System.millis() - start)) / 1000.000000;
				eval(closure.thumb, null, closure.aspect, time, closure.eval);
				resize(closure.offs, null, closure.thumb, null, closure.lerp ? 1 : 0);
				if (time > closure.fpsTime) {
					text: char[256] := {
					};
					append(text, append(text, 0, "Fps: "), closure.fpsCount);
					Gui.setTitle(text);
					closure.fpsTime := time + (1);
					closure.fpsCount := 0;
				}
				closure.fpsCount := closure.fpsCount + 1;
				return .result := 1;
			};
			if (animationResolution == 0) {
				aspect: float32 := (width) / float32(height);
				image: Image := Image(width, height, 32);
				eval(image, null, aspect, 0.000000, eval);
				show(image, null);
				image.destroy(image);
				return;
			}
			closure: Closure := {
				closure.offs := Image(width, height, 32);
				closure.thumb := Image(animationResolution, animationResolution, 32);
				closure.aspect := (width) / float32(height);
				closure.eval := eval;
				closure.lerp := true;
				closure.fpsCount := 0;
				closure.fpsTime := (0);
			};
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.thumb.destroy(closure.thumb);
			closure.offs.destroy(closure.offs);
		};
		static show(mesh: Mesh, w: int32, h: int32, fovy: float32): void := {
			static const Closure: struct {
				fpsCount: int32 := 0;
				fpsShow: int32 := 0;
				fpsTime: int64 := 0;
				mode: int32;
				offs: Image;
				proj: mat4f;
				cam: Camera;
				mesh: Mesh;
				static updateCamera(const this: Closure): void := {
					camera: Camera := this.cam;
					camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
				};
			};
			static next(x: int32, mask: int32): int32 := {
				next: int32 := x & mask;
				next := next + (mask & -mask);
				next := next & mask;
				return .result := next | (x & ~mask);
			};
			static onEvent(closure: Closure, action: int32, button: int32, ex: int32, ey: int32): int32 := {
				static ox: int32 := 0;
				static oy: int32 := 0;
				static const speed: float32 := (1) / 100.000000;
				if ((action) == Gui.FINGER_MOTION) {
					action := (Gui.MOUSE_MOTION);
				}
				if ((action) == Gui.KEY_PRESS) {
					if (button == 27) {
						return .result := -1;
					}
					else if (button == ('l')) {
						closure.mode := ((closure.mode) ^ Mesh.useLights);
					}
					else if (button == ('0')) {
						lights.enable(0, !lights.enabled(0));
					}
					else if (button == ('1')) {
						lights.enable(1, !lights.enabled(1));
					}
					else if (button == ('2')) {
						lights.enable(2, !lights.enabled(2));
					}
					else if (button == ('3')) {
						lights.enable(3, !lights.enabled(3));
					}
					else if (button == ('t')) {
						closure.mode := ((closure.mode) ^ Mesh.useTexture);
					}
					else if (button == ('/')) {
						closure.mode := next(closure.mode, Mesh.cullBack | Mesh.cullFront);
					}
					else if (button == ('\t')) {
						closure.mode := next(closure.mode, Mesh.drawMode);
					}
					else if (button == ('\r')) {
						eye: vec4f := {
							eye.x := (0);
							eye.y := (0);
							eye.z := (2);
							eye.w := (1);
						};
						at: vec4f := {
							at.x := (0);
							at.y := (0);
							at.z := (0);
							at.w := (1);
						};
						up: vec4f := {
							up.x := (0);
							up.y := (1);
							up.z := (0);
							up.w := (1);
						};
						closure.cam := Camera.lookAt(eye, at, up);
						closure.updateCamera(closure);
					}
				}
				else if ((action) == Gui.MOUSE_PRESS) {
					ox := ex;
					oy := ey;
					return .result := 0;
				}
				else if ((action) == Gui.MOUSE_MOTION) {
					camera: Camera := closure.cam;
					dx: int32 := ex - ox;
					dy: int32 := ey - oy;
					if (button == 1) {
						camera.rotate(camera, vec4f(0), camera.up, (dx) * speed);
						camera.rotate(camera, vec4f(0), camera.right, (dy) * speed);
						closure.updateCamera(closure);
					}
					else if (button == 2) {
						camera.rotate(camera, camera.up, (-dx) * speed);
						camera.rotate(camera, camera.right, (-dy) * speed);
						closure.updateCamera(closure);
					}
					else if (button == 3) {
						camera.move(camera, camera.forward, (dy) * speed);
						closure.updateCamera(closure);
					}
					else if (button == 4) {
						camera.move(camera, camera.right, (-dx) * speed);
						camera.move(camera, camera.up, (dy) * speed);
						closure.updateCamera(closure);
					}
					ox := ex;
					oy := ey;
				}
				rendered: int32 := closure.offs.drawMesh(closure.offs, closure.mesh, closure.mode);
				text: char[256] := {
				};
				pos: int32 := append(text, 0, "Vertices: ");
				pos := append(text, pos, closure.mesh.vertices);
				pos := append(text, pos, ", Triangles: ");
				pos := append(text, pos, closure.mesh.triangles);
				pos := append(text, pos, "/");
				pos := append(text, pos, rendered);
				pos := append(text, pos, ", Fps: ");
				pos := append(text, pos, closure.fpsShow);
				Gui.setTitle(text);
				time: int64 := System.millis();
				if (time > closure.fpsTime) {
					closure.fpsTime := time + (1000);
					closure.fpsShow := closure.fpsCount;
					closure.fpsCount := 0;
				}
				closure.fpsCount := closure.fpsCount + 1;
				return .result := 0;
			};
			closure: Closure := {
				closure.mode := (Mesh.clearDepth | Mesh.clearColor | Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
				closure.offs := Image.create3d(w, h);
				closure.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
				closure.cam := Camera.lookAt(vec4f(0, 0, 2), vec4f(0), vec4f(0, 1, 0));
				closure.mesh := mesh;
				closure.fpsCount := 0;
				closure.fpsShow := 0;
				closure.fpsTime := (0);
			};
			closure.updateCamera(closure);
			Gui.showWindow(closure.offs, closure, onEvent);
			closure.offs.destroy(closure.offs);
		};
	}
}
.instructions: (89 bytes)
	cmplStd/lib/string.ci:152: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main>  : load.c32 4
	<.main+?>: load.ref <?> ;" \t\n\r"
	<.main+?>: store.m64 <?> ;append.whiteSpace
	cmplStd/lib/string.ci:153: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: load.c32 36
	<.main+?>: load.ref <?> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: store.m64 <?> ;append.radixDigits
	cmplStd/lib/string.ci:270: (24 bytes): static const format: FormatFlags := {...}
	:: (7 bytes): format.showSign := false;
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format
	<.main+?>: store.i8
	:: (5 bytes): format.precision := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+4
	:: (7 bytes): format.padChr := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format+8
	<.main+?>: store.i8
	:: (5 bytes): format.padLen := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+12
	cmplGfx/gfxlib.ci:71: (8 bytes): static const start: int64 := System.millis()
	<.main+?>: nfc(21) ;System.millis(): int64
	<.main+?>: store.m64 <?> ;show.start
	cmplGfx/gfxlib.ci:180: (5 bytes): static ox: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.ox
	cmplGfx/gfxlib.ci:181: (5 bytes): static oy: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;show.onEvent.oy
	cmplGfx/gfxlib.ci:182: (15 bytes): static const speed: float32 := (1) / 100.000000
	<.main+?>: load.f32 1.000000
	<.main+?>: load.f32 100.000000
	<.main+?>: div.f32
	<.main+?>: store.m32 <?> ;show.onEvent.speed
	<.main+?>: nfc(0) ;halt(): void
}

---------- Execute: byte-code

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
cmplStd/lib/debug.ci:48: NotEquals: typename(<NotEquals>)
cmplStd/lib/debug.ci:61: assertEq: function(<assertEq>)
cmplStd/lib/math.ci:22: Math.modf: function(<Math.modf>)
cmplStd/lib/math.ci:47: Math.floor: function(<Math.floor>)
cmplStd/lib/math.ci:77: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:85: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:147: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:158: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:189: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:203: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:217: Math.sum: function(<Math.sum>)
cmplStd/lib/math.ci:226: Math.mean: function(<Math.mean>)
cmplStd/lib/math.ci:243: Math.eval: function(<Math.eval>)
cmplStd/lib/math.ci:252: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:267: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:282: Math.sinCos: function(<Math.sinCos>)
cmplStd/lib/math.ci:339: Math.tan: function(<Math.tan>)
cmplStd/lib/math.ci:396: Math.sinh: function(<Math.sinh>)
cmplStd/lib/math.ci:435: Math.cosh: function(<Math.cosh>)
cmplStd/lib/math.ci:450: Math.asin: function(<Math.asin>)
cmplStd/lib/math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:24: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:31: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:86: div: function(<div>)
cmplStd/lib/math/Complex.ci:117: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:135: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:111: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:163: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:173: scale: function(<scale>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/string.ci:4: length: function(<length>)
cmplStd/lib/string.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/string.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/string.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/string.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/string.ci:61: compare: function(<compare>)
cmplStd/lib/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/string.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/string.ci:119: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/string.ci:134: append: function(<append>)
cmplStd/lib/string.ci:151: append: function(<append>)
cmplStd/lib/string.ci:241: append: function(<append>)
cmplStd/lib/string.ci:269: append: function(<append>)
File: typename(<File>)
Rect: typename(<Rect>)
Image: typename(<Image>)
Mesh: typename(<Mesh>)
lights: typename(<lights>)
Gui: typename(<Gui>)
cmplGfx/lib/color.ci:2: argb: typename(<argb>)
cmplGfx/lib/color.ci:109: clamp_s8: function(<clamp_s8>)
cmplGfx/lib/color.ci:119: clamp_u8: function(<clamp_u8>)
cmplGfx/lib/color.ci:174: hue: function(<hue>)
cmplGfx/lib/color.ci:216: lerpLut: function(<lerpLut>)
cmplGfx/lib/color.ci:233: alphaLut: function(<alphaLut>)
cmplGfx/lib/color.hsv.ci:2: hsv2rgb: function(<hsv2rgb>)
cmplGfx/lib/color.hsl.ci:3: rgb2hsl: function(<rgb2hsl>)
cmplGfx/lib/color.hsl.ci:61: hsl2rgb: function(<hsl2rgb>)
cmplGfx/lib/image.ci:5: Image: function(<Image>)
cmplGfx/lib/image.ci:12: Image: function(<Image>)
cmplGfx/lib/image.ci:83: Image: function(<Image>)
cmplGfx/lib/image.ci:94: Image: function(<Image>)
cmplGfx/lib/image.ci:120: clip: function(<clip>)
cmplGfx/lib/image.ci:168: eval: function(<eval>)
cmplGfx/lib/image.ci:202: tile: function(<tile>)
cmplGfx/lib/mesh.ci:2: Mesh: function(<Mesh>)
cmplGfx/lib/camera.ci:8: Camera.projection: function(<Camera.projection>)
cmplGfx/lib/camera.ci:35: Camera.rotation: function(<Camera.rotation>)
cmplGfx/lib/camera.ci:69: Camera.translation: function(<Camera.translation>)
cmplGfx/lib/camera.ci:80: Camera.lookAt: function(<Camera.lookAt>)
cmplGfx/lib/camera.ci:92: Camera.matrix: function(<Camera.matrix>)
cmplGfx/lib/camera.ci:102: Camera.matrix: function(<Camera.matrix>)
cmplGfx/lib/camera.ci:107: Camera.move: function(<Camera.move>)
cmplGfx/lib/camera.ci:112: Camera.rotate: function(<Camera.rotate>)
cmplGfx/lib/camera.ci:125: Camera.rotate: function(<Camera.rotate>)
cmplGfx/lib/camera.ci:1: Camera: typename(<Camera>)
cmplGfx/gfxlib.ci:26: show: function(<show>)
cmplGfx/gfxlib.ci:37: showDiff: function(<showDiff>)
cmplGfx/gfxlib.ci:70: show: function(<show>)
cmplGfx/gfxlib.ci:149: show: function(<show>)

---------- Memory usage:
memory[all] @000000; size: 4194016(4.0 Mb)
memory[used] @000000; size: 433339(423.2 Kb)
memory[heap] @069cbb; size: 2712125(2.6 Mb)
memory[stack] @1fff40; size: 1048504(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 420400(410.5 Kb)
memory[code] @000000; size: 12613(12.3 Kb)
memory[data] @000000; size: 52(52.0 bytes)

---------- heap memory:
memory[free] @069cd0; size: 2712080(2.6 Mb)

---------- Exitcode: 0, time: 0.000 ms
