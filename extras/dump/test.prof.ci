
---------- Compile: `cmplStd/stdlib.ci`
warn: variable `args` hides previous declaration
cmplStd/stdlib.ci:40: debug: inline file: `cmplStd/lib/debug.ci`
cmplStd/lib/debug.ci:65: warn: adding implicit cast variant(message: char[*])
cmplStd/lib/debug.ci:67: warn: adding implicit cast variant(expected: int32)
cmplStd/lib/debug.ci:68: warn: adding implicit cast variant(returned: int32)
cmplStd/lib/debug.ci:69: warn: adding implicit cast variant[](extras: variant[1])
cmplStd/stdlib.ci:43: debug: inline file: `cmplStd/lib/math.ci`
cmplStd/lib/math.ci:17: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:18: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:23: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:24: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:29: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:32: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:64: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:64: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:65: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:66: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math.ci:71: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:71: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:74: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:74: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:78: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:86: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:96: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:105: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:108: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:179: warn: adding implicit cast float32(2: int32)
cmplStd/lib/math.ci:179: warn: adding implicit cast float32(3: int32)
cmplStd/lib/math.ci:180: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:180: warn: adding implicit cast float64(3: int32)
cmplStd/lib/math.ci:190: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:194: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:204: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:208: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:219: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:227: warn: adding implicit cast float64(signed(data.length): int32)
cmplStd/lib/math.ci:245: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math.ci:297: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:303: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:304: warn: adding implicit cast float64(32764: int32)
cmplStd/lib/math.ci:307: warn: adding implicit cast float64(quad: int32)
cmplStd/lib/math.ci:311: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math.ci:311: warn: adding implicit cast int32(e - (4) * f: float64)
cmplStd/lib/math.ci:315: warn: adding implicit cast float64(k: int32)
cmplStd/lib/math.ci:320: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:355: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:359: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:367: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:375: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:384: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:387: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:409: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:414: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:415: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:420: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:436: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:439: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:440: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:442: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:451: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:457: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:462: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:467: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:469: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:485: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:509: warn: adding implicit cast float64(180: int32)
cmplStd/lib/math.ci:512: warn: adding implicit cast float64(180: int32)
cmplStd/stdlib.ci:46: debug: inline file: `cmplStd/lib/math/Complex.ci`
cmplStd/lib/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
cmplStd/lib/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
cmplStd/stdlib.ci:47: debug: inline file: `cmplStd/lib/math/Vector4f.ci`
cmplStd/stdlib.ci:48: debug: inline file: `cmplStd/lib/math/Matrix4f.ci`
cmplStd/lib/math/Matrix4f.ci:113: warn: adding implicit cast float64(len: float32)
cmplStd/lib/math/Matrix4f.ci:137: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(1: int32)
cmplStd/stdlib.ci:49: debug: inline file: `cmplStd/lib/math/Vector2d.ci`
cmplStd/stdlib.ci:54: debug: inline file: `cmplStd/lib/string.ci`
cmplStd/lib/string.ci:5: warn: adding implicit cast pointer(str: char[*])
cmplStd/lib/string.ci:37: warn: adding implicit cast int32(with[i]: char)
cmplStd/lib/string.ci:65: warn: adding implicit cast int32(str[i]: char)
cmplStd/lib/string.ci:117: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
cmplStd/lib/string.ci:123: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
cmplStd/lib/string.ci:129: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:136: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:137: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/string.ci:137: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/string.ci:139: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:152: warn: adding implicit cast int32(sign: char)
cmplStd/lib/string.ci:162: warn: adding implicit cast int32(radixDigits.length: uint32)
cmplStd/lib/string.ci:165: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/string.ci:165: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/string.ci:166: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/string.ci:180: warn: adding implicit cast int32(sign: char)
cmplStd/lib/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:190: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:197: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:204: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:209: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:210: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/string.ci:210: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/string.ci:212: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:225: warn: adding implicit cast int64(0: int32)
cmplStd/lib/string.ci:225: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:225: warn: adding implicit cast int64(0: int32)
cmplStd/lib/string.ci:227: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32(value: int16)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32(value: int16)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32(value: int8)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32(value: int8)
cmplStd/lib/string.ci:248: warn: adding implicit cast float64(0: int32)
cmplStd/lib/string.ci:248: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.showSign := false
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.precision := 0
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/string.ci:120: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.padLen := 0

---------- Compile: `cmplStd/test/test.ci`
cmplStd/test/test.ci:9: debug: inline file: `cmplStd/test/lang/emit.ci`
cmplStd/test/test.ci:10: debug: inline file: `cmplStd/test/lang/inlineMacros.ci`
cmplStd/test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
cmplStd/test/test.ci:11: debug: inline file: `cmplStd/test/lang/overload.inline.ci`
cmplStd/test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
cmplStd/test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
cmplStd/test/test.ci:14: debug: inline file: `cmplStd/test/std/number.ci`
cmplStd/test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
cmplStd/test/test.ci:15: debug: inline file: `cmplStd/test/std/memory.ci`
cmplStd/test/test.ci:16: debug: inline file: `cmplStd/test/std/tryExec.ci`
cmplStd/test/std/tryExec.ci:25: warn: variable `abortExecution.NotEquals` hides previous declaration
cmplStd/lib/debug.ci:48: warn: previously defined as `NotEquals`
cmplStd/test/std/tryExec.ci:25: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
cmplStd/test/std/tryExec.ci:31: warn: adding implicit cast char[*]("assertion failed": .cstr)
cmplStd/test/test.ci:20: debug: inline file: `cmplStd/test/lang/init.reference.ci`
cmplStd/test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:21: debug: inline file: `cmplStd/test/lang/init.variable.ci`
cmplStd/test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
cmplStd/test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:41: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/test.ci:24: debug: inline file: `cmplStd/test/lang/function.ci`
cmplStd/test/lang/function.ci:33: warn: Overwriting forward function: funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
cmplStd/test/test.ci:25: debug: inline file: `cmplStd/test/lang/reflect.ci`
cmplStd/test/test.ci:29: debug: inline file: `cmplStd/test/lang/init.member.ci`
cmplStd/test/lang/init.member.ci:81: warn: ignoring nested comment
cmplStd/test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
cmplStd/test/test.ci:30: debug: inline file: `cmplStd/test/lang/init.method.ci`
cmplStd/test/lang/init.method.ci:40: warn: Creating virtual method for: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47: warn: Overwriting forward function: RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
cmplStd/test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/test.ci:31: debug: inline file: `cmplStd/test/lang/init.array.ci`
cmplStd/test/lang/init.array.ci:2: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(42: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(43: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(44: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(45: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(46: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(47: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(48: int32)
cmplStd/test/lang/init.array.ci:34: warn: adding implicit cast char(0: int32)
cmplStd/test/lang/init.array.ci:48: warn: adding implicit cast uint32(0: int32)
cmplStd/test/lang/init.array.ci:49: warn: adding implicit cast int64(42: int32)
cmplStd/test/lang/init.array.ci:56: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:57: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:58: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:62: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:63: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:64: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:66: warn: adding implicit cast int32(length: uint32)
cmplStd/test/test.ci:33: debug: inline file: `cmplStd/test/lang/recUnion.ci`
cmplStd/test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
cmplStd/test/test.ci:34: debug: inline file: `cmplStd/test/lang/recPacking.ci`
cmplStd/test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
cmplStd/test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
cmplStd/test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
cmplStd/test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
cmplStd/test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
cmplStd/test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
cmplStd/test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
cmplStd/test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
cmplStd/test/test.ci:41: debug: inline file: `cmplStd/test/lang/useOperator.ci`
cmplStd/test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
cmplStd/test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
cmplStd/test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
cmplStd/test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
cmplStd/test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
cmplStd/test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
cmplStd/test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
cmplStd/test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
cmplStd/test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
cmplStd/test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
cmplStd/test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
cmplStd/test/test.ci:45: debug: inline file: `cmplStd/test/lang/stmt.if.ci`
cmplStd/test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:46: debug: inline file: `cmplStd/test/lang/stmt.for.ci`
cmplStd/test/test.ci:49: debug: inline file: `cmplStd/test/std/test.math.ci`
cmplStd/test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
cmplStd/lib/math.ci:48: warn: using default type initializer: Math.floor.result := 0
cmplStd/lib/math.ci:302: warn: using default type initializer: Math.sinCos.y := 0
cmplStd/lib/math.ci:305: warn: using default type initializer: e := 0
cmplStd/lib/math.ci:309: warn: using default type initializer: f := 0
cmplStd/lib/math.ci:361: warn: using default type initializer: Math.tan.e := 0
cmplStd/lib/math.ci:418: warn: using default type initializer: Math.sinh.result := 0
cmplStd/lib/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
cmplStd/test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0
cmplStd/test/lang/init.method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006500>, cast: static const inline)
.field file: function (size: 0, offs: <@006718>, cast: static const inline)
.field line: function (size: 0, offs: <@006930>, cast: static const inline)
.field name: function (size: 0, offs: <@006b48>, cast: static const inline)
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `typename`
	cmplStd/test/lang/init.array.ci:2: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:42: referenced as `typename`
	cmplStd/test/lang/reflect.ci:41: referenced as `typename`
	cmplStd/test/lang/reflect.ci:38: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:35: referenced as `typename`
	cmplStd/test/lang/reflect.ci:34: referenced as `typename`
	cmplStd/test/lang/reflect.ci:31: referenced as `typename`
	cmplStd/test/lang/reflect.ci:30: referenced as `typename`
	cmplStd/test/lang/reflect.ci:18: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:92: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:91: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:90: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:89: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:87: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:86: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:85: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:84: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:83: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:82: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:81: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:80: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:79: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:78: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:77: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:76: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:75: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:68: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:48: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:32: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:25: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:19: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:3: referenced as `typename`
	cmplStd/stdlib.ci:39: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	internal usages: 10
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `size`
	cmplStd/test/lang/reflect.ci:46: referenced as `size`
	cmplStd/stdlib.ci:37: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:49: referenced as `offset`
	cmplStd/test/lang/reflect.ci:45: referenced as `offset`
	cmplStd/test/lang/reflect.ci:39: referenced as `offset`
	cmplStd/test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006500>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `base`
	cmplStd/test/lang/reflect.ci:44: referenced as `base`
	cmplStd/test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006718>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	cmplStd/test/lang/reflect.ci:41: referenced as `file`
	cmplStd/test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006930>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	cmplStd/test/lang/reflect.ci:42: referenced as `line`
	cmplStd/test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b48>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	cmplStd/test/lang/reflect.ci:38: referenced as `name`
	cmplStd/test/lang/reflect.ci:31: referenced as `name`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b8>
.name: 'void'
.usages:
	cmplStd/test/lang/init.method.ci:90: referenced as `void`
	cmplStd/test/lang/init.method.ci:84: referenced as `void`
	cmplStd/test/lang/init.method.ci:57: referenced as `void`
	cmplStd/test/lang/init.method.ci:47: referenced as `void`
	cmplStd/test/lang/init.method.ci:40: referenced as `void`
	cmplStd/test/lang/init.method.ci:32: referenced as `void`
	cmplStd/test/lang/init.method.ci:25: referenced as `void`
	cmplStd/test/lang/init.method.ci:18: referenced as `void`
	cmplStd/test/lang/init.method.ci:10: referenced as `void`
	cmplStd/test/lang/reflect.ci:3: referenced as `void`
	cmplStd/test/lang/function.ci:4: referenced as `void`
	cmplStd/test/lang/init.reference.ci:75: referenced as `void`
	cmplStd/test/lang/init.reference.ci:55: referenced as `void`
	cmplStd/test/lang/init.reference.ci:35: referenced as `void`
	cmplStd/test/std/tryExec.ci:43: referenced as `void`
	cmplStd/test/std/tryExec.ci:38: referenced as `void`
	cmplStd/test/std/tryExec.ci:24: referenced as `void`
	cmplStd/test/std/tryExec.ci:20: referenced as `void`
	cmplStd/test/std/tryExec.ci:14: referenced as `void`
	cmplStd/test/std/tryExec.ci:11: referenced as `void`
	cmplStd/lib/debug.ci:61: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000160>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `bool`
	cmplStd/test/std/test.math.ci:67: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:300: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:299: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:281: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:280: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:279: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:278: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:277: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:276: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:275: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:258: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:257: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:256: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:255: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:254: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:253: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:252: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:235: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:234: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:233: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:232: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:231: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:230: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:229: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:212: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:211: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:210: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:209: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:208: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:207: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:206: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:189: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:188: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:187: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:186: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:185: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:184: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:183: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:166: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:165: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:164: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:163: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:162: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:161: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:160: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:143: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:142: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:141: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:140: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:139: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:138: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:137: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:120: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:119: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:118: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:117: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:116: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:115: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:114: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:97: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:96: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:95: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:94: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:93: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:92: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:91: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:74: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:73: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:72: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:71: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:70: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:69: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:68: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:51: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:50: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:49: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:48: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:47: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:46: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:45: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:28: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:27: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:26: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:25: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:24: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:23: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:22: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:19: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:18: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:17: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:8: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:7: referenced as `bool`
	cmplStd/test/lang/reflect.ci:4: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:76: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:56: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:36: referenced as `bool`
	cmplStd/lib/string.ci:114: referenced as `bool`
	cmplStd/lib/string.ci:46: referenced as `bool`
	cmplStd/lib/string.ci:36: referenced as `bool`
	cmplStd/lib/math.ci:456: referenced as `bool`
	cmplStd/lib/math.ci:408: referenced as `bool`
	cmplStd/lib/math.ci:353: referenced as `bool`
	cmplStd/lib/math.ci:352: referenced as `bool`
	cmplStd/lib/debug.ci:45: referenced as `bool`
	cmplStd/lib/debug.ci:43: referenced as `bool`
	cmplStd/lib/debug.ci:41: referenced as `bool`
	cmplStd/stdlib.ci:3: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000208>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:44: referenced as `char`
	cmplStd/test/lang/useOperator.ci:43: referenced as `char`
	cmplStd/test/lang/useOperator.ci:42: referenced as `char`
	cmplStd/test/lang/useOperator.ci:41: referenced as `char`
	cmplStd/test/lang/useOperator.ci:40: referenced as `char`
	cmplStd/test/lang/useOperator.ci:39: referenced as `char`
	cmplStd/test/lang/useOperator.ci:38: referenced as `char`
	cmplStd/test/lang/useOperator.ci:37: referenced as `char`
	cmplStd/test/lang/useOperator.ci:36: referenced as `char`
	cmplStd/test/lang/useOperator.ci:35: referenced as `char`
	cmplStd/test/lang/useOperator.ci:34: referenced as `char`
	cmplStd/test/lang/useOperator.ci:33: referenced as `char`
	cmplStd/test/lang/useOperator.ci:32: referenced as `char`
	cmplStd/test/lang/useOperator.ci:31: referenced as `char`
	cmplStd/test/lang/useOperator.ci:30: referenced as `char`
	cmplStd/test/lang/init.array.ci:40: referenced as `char`
	cmplStd/test/lang/init.array.ci:37: referenced as `char`
	cmplStd/test/lang/init.array.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:41: referenced as `char`
	cmplStd/test/lang/reflect.ci:38: referenced as `char`
	cmplStd/test/lang/reflect.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:31: referenced as `char`
	cmplStd/test/lang/reflect.ci:5: referenced as `char`
	cmplStd/test/lang/init.reference.ci:77: referenced as `char`
	cmplStd/test/lang/init.reference.ci:57: referenced as `char`
	cmplStd/test/lang/init.reference.ci:37: referenced as `char`
	cmplStd/test/std/tryExec.ci:26: referenced as `char`
	cmplStd/test/lang/emit.ci:29: referenced as `char`
	cmplStd/lib/string.ci:262: referenced as `char`
	cmplStd/lib/string.ci:259: referenced as `char`
	cmplStd/lib/string.ci:248: referenced as `char`
	cmplStd/lib/string.ci:234: referenced as `char`
	cmplStd/lib/string.ci:231: referenced as `char`
	cmplStd/lib/string.ci:229: referenced as `char`
	cmplStd/lib/string.ci:227: referenced as `char`
	cmplStd/lib/string.ci:225: referenced as `char`
	cmplStd/lib/string.ci:223: referenced as `char`
	cmplStd/lib/string.ci:221: referenced as `char`
	cmplStd/lib/string.ci:219: referenced as `char`
	cmplStd/lib/string.ci:217: referenced as `char`
	cmplStd/lib/string.ci:174: referenced as `char`
	cmplStd/lib/string.ci:149: referenced as `char`
	cmplStd/lib/string.ci:146: referenced as `char`
	cmplStd/lib/string.ci:145: referenced as `char`
	cmplStd/lib/string.ci:144: referenced as `char`
	cmplStd/lib/string.ci:144: referenced as `char`
	cmplStd/lib/string.ci:127: referenced as `char`
	cmplStd/lib/string.ci:127: referenced as `char`
	cmplStd/lib/string.ci:120: referenced as `char`
	cmplStd/lib/string.ci:98: referenced as `char`
	cmplStd/lib/string.ci:98: referenced as `char`
	cmplStd/lib/string.ci:95: referenced as `char`
	cmplStd/lib/string.ci:95: referenced as `char`
	cmplStd/lib/string.ci:94: referenced as `char`
	cmplStd/lib/string.ci:94: referenced as `char`
	cmplStd/lib/string.ci:93: referenced as `char`
	cmplStd/lib/string.ci:93: referenced as `char`
	cmplStd/lib/string.ci:92: referenced as `char`
	cmplStd/lib/string.ci:92: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:4: referenced as `char`
	cmplStd/lib/debug.ci:61: referenced as `char`
	cmplStd/lib/debug.ci:43: referenced as `char`
	cmplStd/lib/debug.ci:41: referenced as `char`
	cmplStd/lib/debug.ci:36: referenced as `char`
	cmplStd/lib/debug.ci:34: referenced as `char`
	cmplStd/lib/debug.ci:31: referenced as `char`
	cmplStd/lib/debug.ci:29: referenced as `char`
	cmplStd/lib/debug.ci:26: referenced as `char`
	cmplStd/lib/debug.ci:24: referenced as `char`
	cmplStd/lib/debug.ci:21: referenced as `char`
	cmplStd/lib/debug.ci:19: referenced as `char`
	cmplStd/lib/debug.ci:16: referenced as `char`
	cmplStd/lib/debug.ci:14: referenced as `char`
	cmplStd/lib/debug.ci:11: referenced as `char`
	cmplStd/lib/debug.ci:9: referenced as `char`
	cmplStd/lib/debug.ci:6: referenced as `char`
	cmplStd/lib/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0002b0>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:67: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:66: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:65: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:64: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:63: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:62: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:61: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:60: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:59: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:58: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:57: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:56: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:55: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:54: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:53: referenced as `int8`
	cmplStd/test/lang/reflect.ci:6: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:78: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:58: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:38: referenced as `int8`
	cmplStd/lib/string.ci:231: referenced as `int8`
	cmplStd/stdlib.ci:25: referenced as `int8`
	cmplStd/stdlib.ci:13: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000358>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:113: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:112: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:111: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:110: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:109: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:108: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:107: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:106: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:105: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:104: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:103: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:102: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:101: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:100: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:99: referenced as `int16`
	cmplStd/test/lang/reflect.ci:7: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:79: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:59: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:39: referenced as `int16`
	cmplStd/lib/string.ci:229: referenced as `int16`
	cmplStd/stdlib.ci:28: referenced as `int16`
	cmplStd/stdlib.ci:16: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000400>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/stmt.for.ci:24: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:17: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:12: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:8: referenced as `int`
	cmplStd/test/lang/stmt.if.ci:26: referenced as `int`
	cmplStd/test/lang/useOperator.ci:159: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:158: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:157: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:156: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:155: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:154: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:153: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:152: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:151: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:150: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:149: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:148: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:147: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:146: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:145: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:5: referenced as `int32`
	cmplStd/test/lang/init.array.ci:66: referenced as `int`
	cmplStd/test/lang/init.array.ci:54: referenced as `int`
	cmplStd/test/lang/init.array.ci:53: referenced as `int`
	cmplStd/test/lang/init.array.ci:52: referenced as `int`
	cmplStd/test/lang/init.array.ci:51: referenced as `int`
	cmplStd/test/lang/init.array.ci:3: referenced as `int32`
	cmplStd/test/lang/init.method.ci:90: referenced as `int`
	cmplStd/test/lang/init.method.ci:84: referenced as `int`
	cmplStd/test/lang/init.method.ci:57: referenced as `int`
	cmplStd/test/lang/init.method.ci:47: referenced as `int`
	cmplStd/test/lang/init.method.ci:40: referenced as `int`
	cmplStd/test/lang/init.method.ci:32: referenced as `int`
	cmplStd/test/lang/init.method.ci:25: referenced as `int`
	cmplStd/test/lang/init.method.ci:18: referenced as `int`
	cmplStd/test/lang/init.method.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:40: referenced as `int`
	cmplStd/test/lang/init.member.ci:37: referenced as `int`
	cmplStd/test/lang/init.member.ci:34: referenced as `int`
	cmplStd/test/lang/init.member.ci:19: referenced as `int`
	cmplStd/test/lang/init.member.ci:16: referenced as `int`
	cmplStd/test/lang/init.member.ci:13: referenced as `int`
	cmplStd/test/lang/init.member.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:6: referenced as `int`
	cmplStd/test/lang/init.member.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:50: referenced as `int`
	cmplStd/test/lang/reflect.ci:49: referenced as `int`
	cmplStd/test/lang/reflect.ci:46: referenced as `int`
	cmplStd/test/lang/reflect.ci:45: referenced as `int`
	cmplStd/test/lang/reflect.ci:42: referenced as `int`
	cmplStd/test/lang/reflect.ci:40: referenced as `int`
	cmplStd/test/lang/reflect.ci:39: referenced as `int`
	cmplStd/test/lang/reflect.ci:35: referenced as `int`
	cmplStd/test/lang/reflect.ci:33: referenced as `int`
	cmplStd/test/lang/reflect.ci:32: referenced as `int`
	cmplStd/test/lang/reflect.ci:27: referenced as `int32`
	cmplStd/test/lang/reflect.ci:20: referenced as `int`
	cmplStd/test/lang/reflect.ci:19: referenced as `int`
	cmplStd/test/lang/reflect.ci:18: referenced as `int`
	cmplStd/test/lang/reflect.ci:17: referenced as `int`
	cmplStd/test/lang/reflect.ci:16: referenced as `int`
	cmplStd/test/lang/reflect.ci:15: referenced as `int`
	cmplStd/test/lang/reflect.ci:14: referenced as `int`
	cmplStd/test/lang/reflect.ci:13: referenced as `int`
	cmplStd/test/lang/reflect.ci:12: referenced as `int`
	cmplStd/test/lang/reflect.ci:11: referenced as `int`
	cmplStd/test/lang/reflect.ci:10: referenced as `int`
	cmplStd/test/lang/reflect.ci:9: referenced as `int`
	cmplStd/test/lang/reflect.ci:8: referenced as `int32`
	cmplStd/test/lang/reflect.ci:8: referenced as `int`
	cmplStd/test/lang/reflect.ci:7: referenced as `int`
	cmplStd/test/lang/reflect.ci:6: referenced as `int`
	cmplStd/test/lang/reflect.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:4: referenced as `int`
	cmplStd/test/lang/reflect.ci:3: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:30: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:24: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:18: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:12: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:3: referenced as `int`
	cmplStd/test/lang/init.reference.ci:80: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:60: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:40: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:4: referenced as `int32`
	cmplStd/test/std/tryExec.ci:53: referenced as `int`
	cmplStd/test/std/tryExec.ci:52: referenced as `int`
	cmplStd/test/std/tryExec.ci:51: referenced as `int`
	cmplStd/test/std/tryExec.ci:50: referenced as `int`
	cmplStd/test/std/tryExec.ci:49: referenced as `int`
	cmplStd/test/std/tryExec.ci:48: referenced as `int`
	cmplStd/test/std/tryExec.ci:47: referenced as `int`
	cmplStd/test/std/tryExec.ci:40: referenced as `int`
	cmplStd/test/std/tryExec.ci:39: referenced as `int32`
	cmplStd/test/std/tryExec.ci:28: referenced as `int`
	cmplStd/test/std/tryExec.ci:27: referenced as `int`
	cmplStd/test/std/tryExec.ci:21: referenced as `int`
	cmplStd/test/std/memory.ci:4: referenced as `int`
	cmplStd/test/std/memory.ci:3: referenced as `int`
	cmplStd/test/std/number.ci:66: referenced as `int32`
	cmplStd/test/std/number.ci:65: referenced as `int32`
	cmplStd/test/std/number.ci:63: referenced as `int32`
	cmplStd/test/std/number.ci:62: referenced as `int32`
	cmplStd/test/std/number.ci:60: referenced as `int32`
	cmplStd/test/std/number.ci:59: referenced as `int32`
	cmplStd/test/std/number.ci:58: referenced as `int32`
	cmplStd/test/std/number.ci:57: referenced as `int32`
	cmplStd/test/std/number.ci:55: referenced as `int32`
	cmplStd/test/std/number.ci:35: referenced as `int32`
	cmplStd/test/std/number.ci:34: referenced as `int32`
	cmplStd/test/std/number.ci:33: referenced as `int32`
	cmplStd/test/std/number.ci:31: referenced as `int32`
	cmplStd/test/std/number.ci:30: referenced as `int32`
	cmplStd/test/std/number.ci:29: referenced as `int32`
	cmplStd/test/std/number.ci:27: referenced as `int32`
	cmplStd/test/std/number.ci:26: referenced as `int32`
	cmplStd/test/std/number.ci:25: referenced as `int32`
	cmplStd/test/std/number.ci:23: referenced as `int32`
	cmplStd/test/std/number.ci:22: referenced as `int32`
	cmplStd/test/std/number.ci:21: referenced as `int32`
	cmplStd/test/std/number.ci:19: referenced as `int32`
	cmplStd/test/std/number.ci:18: referenced as `int32`
	cmplStd/test/std/number.ci:16: referenced as `int`
	cmplStd/test/std/number.ci:15: referenced as `int`
	cmplStd/test/std/number.ci:14: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:5: referenced as `int32`
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:13: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:12: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:11: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:10: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/emit.ci:29: referenced as `int`
	cmplStd/test/lang/emit.ci:25: referenced as `int32`
	cmplStd/test/lang/emit.ci:23: referenced as `int32`
	cmplStd/test/lang/emit.ci:19: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:7: referenced as `int32`
	cmplStd/test/lang/emit.ci:6: referenced as `int32`
	cmplStd/test/lang/emit.ci:3: referenced as `int32`
	cmplStd/lib/string.ci:262: referenced as `int`
	cmplStd/lib/string.ci:262: referenced as `int`
	cmplStd/lib/string.ci:262: referenced as `int`
	cmplStd/lib/string.ci:259: referenced as `int`
	cmplStd/lib/string.ci:234: referenced as `int`
	cmplStd/lib/string.ci:234: referenced as `int`
	cmplStd/lib/string.ci:231: referenced as `int`
	cmplStd/lib/string.ci:229: referenced as `int`
	cmplStd/lib/string.ci:227: referenced as `int32`
	cmplStd/lib/string.ci:227: referenced as `int`
	cmplStd/lib/string.ci:225: referenced as `int`
	cmplStd/lib/string.ci:223: referenced as `int`
	cmplStd/lib/string.ci:221: referenced as `int`
	cmplStd/lib/string.ci:219: referenced as `int`
	cmplStd/lib/string.ci:217: referenced as `int`
	cmplStd/lib/string.ci:203: referenced as `int`
	cmplStd/lib/string.ci:172: referenced as `int`
	cmplStd/lib/string.ci:157: referenced as `int`
	cmplStd/lib/string.ci:148: referenced as `int`
	cmplStd/lib/string.ci:144: referenced as `int`
	cmplStd/lib/string.ci:144: referenced as `int`
	cmplStd/lib/string.ci:128: referenced as `int`
	cmplStd/lib/string.ci:127: referenced as `int`
	cmplStd/lib/string.ci:127: referenced as `int`
	cmplStd/lib/string.ci:123: referenced as `int`
	cmplStd/lib/string.ci:117: referenced as `int`
	cmplStd/lib/string.ci:88: referenced as `int`
	cmplStd/lib/string.ci:73: referenced as `int`
	cmplStd/lib/string.ci:63: referenced as `int`
	cmplStd/lib/string.ci:62: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:52: referenced as `int`
	cmplStd/lib/string.ci:48: referenced as `int`
	cmplStd/lib/string.ci:47: referenced as `int`
	cmplStd/lib/string.ci:46: referenced as `int`
	cmplStd/lib/string.ci:37: referenced as `int`
	cmplStd/lib/string.ci:36: referenced as `int`
	cmplStd/lib/string.ci:27: referenced as `int`
	cmplStd/lib/string.ci:26: referenced as `int`
	cmplStd/lib/string.ci:25: referenced as `int`
	cmplStd/lib/string.ci:16: referenced as `int`
	cmplStd/lib/string.ci:15: referenced as `int`
	cmplStd/lib/string.ci:8: referenced as `int`
	cmplStd/lib/string.ci:4: referenced as `int`
	cmplStd/lib/math.ci:363: referenced as `int`
	cmplStd/lib/math.ci:363: referenced as `int`
	cmplStd/lib/math.ci:314: referenced as `int`
	cmplStd/lib/math.ci:282: referenced as `int`
	cmplStd/lib/math.ci:267: referenced as `int`
	cmplStd/lib/math.ci:252: referenced as `int`
	cmplStd/lib/math.ci:245: referenced as `int`
	cmplStd/lib/math.ci:219: referenced as `int`
	cmplStd/lib/math.ci:208: referenced as `int`
	cmplStd/lib/math.ci:194: referenced as `int`
	cmplStd/lib/math.ci:129: referenced as `int32`
	cmplStd/lib/math.ci:129: referenced as `int32`
	cmplStd/lib/math.ci:111: referenced as `int32`
	cmplStd/lib/math.ci:111: referenced as `int32`
	cmplStd/lib/math.ci:93: referenced as `int32`
	cmplStd/lib/math.ci:74: referenced as `int`
	cmplStd/lib/math.ci:74: referenced as `int`
	cmplStd/lib/math.ci:71: referenced as `int`
	cmplStd/lib/math.ci:71: referenced as `int`
	cmplStd/lib/math.ci:63: referenced as `int32`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/stdlib.ci:37: referenced as `int`
	cmplStd/stdlib.ci:31: referenced as `int32`
	cmplStd/stdlib.ci:19: referenced as `int32`
	internal usages: 38
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@0004a8>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `integer`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `integer`
	cmplStd/test/lang/useOperator.ci:205: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:204: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:203: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:202: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:201: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:200: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:199: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:198: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:197: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:196: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:195: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:194: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:193: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:192: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:191: referenced as `int64`
	cmplStd/test/lang/init.array.ci:67: referenced as `integer`
	cmplStd/test/lang/init.array.ci:54: referenced as `integer`
	cmplStd/test/lang/init.array.ci:54: referenced as `integer`
	cmplStd/test/lang/init.array.ci:53: referenced as `integer`
	cmplStd/test/lang/init.array.ci:53: referenced as `integer`
	cmplStd/test/lang/init.array.ci:52: referenced as `integer`
	cmplStd/test/lang/init.array.ci:52: referenced as `integer`
	cmplStd/test/lang/init.array.ci:51: referenced as `integer`
	cmplStd/test/lang/init.array.ci:30: referenced as `integer`
	cmplStd/test/lang/init.array.ci:27: referenced as `integer`
	cmplStd/test/lang/init.array.ci:26: referenced as `integer`
	cmplStd/test/lang/init.array.ci:23: referenced as `integer`
	cmplStd/test/lang/init.array.ci:22: referenced as `integer`
	cmplStd/test/lang/init.array.ci:19: referenced as `integer`
	cmplStd/test/lang/init.array.ci:18: referenced as `integer`
	cmplStd/test/lang/init.array.ci:11: referenced as `integer`
	cmplStd/test/lang/init.array.ci:2: referenced as `integer`
	cmplStd/test/lang/reflect.ci:23: referenced as `int64`
	cmplStd/test/lang/reflect.ci:9: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:81: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:61: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:41: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:29: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:28: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:27: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:25: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:24: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:16: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:14: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:13: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:12: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:8: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:7: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:3: referenced as `integer`
	cmplStd/test/std/memory.ci:30: referenced as `int64`
	cmplStd/test/std/memory.ci:29: referenced as `int64`
	cmplStd/test/std/memory.ci:24: referenced as `int64`
	cmplStd/test/std/memory.ci:23: referenced as `int64`
	cmplStd/test/lang/emit.ci:26: referenced as `int64`
	cmplStd/test/lang/emit.ci:24: referenced as `int64`
	cmplStd/test/lang/emit.ci:21: referenced as `int64`
	cmplStd/test/lang/emit.ci:4: referenced as `int64`
	cmplStd/test/test.ci:5: referenced as `int64`
	cmplStd/lib/string.ci:254: referenced as `int64`
	cmplStd/lib/string.ci:250: referenced as `int64`
	cmplStd/lib/string.ci:225: referenced as `int64`
	cmplStd/lib/math.ci:132: referenced as `int64`
	cmplStd/lib/math.ci:132: referenced as `int64`
	cmplStd/lib/math.ci:114: referenced as `int64`
	cmplStd/lib/math.ci:114: referenced as `int64`
	cmplStd/lib/math.ci:96: referenced as `int64`
	cmplStd/lib/math.ci:64: referenced as `int64`
	cmplStd/stdlib.ci:34: referenced as `int64`
	cmplStd/stdlib.ci:22: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000550>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:90: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:89: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:88: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:87: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:86: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:85: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:84: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:83: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:82: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:81: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:80: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:79: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:78: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:77: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:76: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:57: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:55: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:53: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:47: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:45: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:43: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:37: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:35: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:33: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:27: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:25: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:23: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:17: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:15: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:13: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:7: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:5: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:3: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:12: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:11: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:10: referenced as `uint8`
	cmplStd/test/lang/reflect.ci:10: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:82: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:62: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:42: referenced as `uint8`
	cmplStd/test/std/tryExec.ci:16: referenced as `byte`
	cmplStd/lib/string.ci:223: referenced as `uint8`
	cmplStd/stdlib.ci:25: referenced as `uint8`
	cmplStd/stdlib.ci:13: referenced as `uint8`
	cmplStd/stdlib.ci:8: referenced as `uint8`
	internal usages: 1
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005f8>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:136: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:135: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:134: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:133: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:132: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:131: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:130: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:129: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:128: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:127: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:126: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:125: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:124: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:123: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:122: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:58: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:48: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:38: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:28: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:18: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:8: referenced as `uint16`
	cmplStd/test/lang/reflect.ci:11: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:83: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:63: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:43: referenced as `uint16`
	cmplStd/lib/string.ci:221: referenced as `uint16`
	cmplStd/stdlib.ci:28: referenced as `uint16`
	cmplStd/stdlib.ci:16: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0006a0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@009f48>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a2a0>, cast: static const inline)
.field pop: function (size: 0, offs: <@00a4b8>, cast: static const inline)
.field swap: function (size: 0, offs: <@00a6d0>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00a8e8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00ab00>, cast: static const inline)
.field hib: function (size: 0, offs: <@00ad18>, cast: static const inline)
.field lob: function (size: 0, offs: <@00af30>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:182: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:181: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:180: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:179: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:178: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:177: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:176: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:175: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:174: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:173: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:172: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:171: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:170: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:169: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:168: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:56: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:46: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:36: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:26: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:16: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:6: referenced as `uint32`
	cmplStd/test/lang/recUnion.ci:17: referenced as `uint32`
	cmplStd/test/lang/reflect.ci:12: referenced as `uint32`
	cmplStd/test/lang/function.ci:46: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:84: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:64: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:44: referenced as `uint32`
	cmplStd/test/std/number.ci:63: referenced as `uint32`
	cmplStd/test/std/number.ci:62: referenced as `uint32`
	cmplStd/test/std/number.ci:60: referenced as `uint32`
	cmplStd/test/std/number.ci:59: referenced as `uint32`
	cmplStd/test/std/number.ci:58: referenced as `uint32`
	cmplStd/test/std/number.ci:57: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:55: referenced as `uint32`
	cmplStd/test/std/number.ci:35: referenced as `uint32`
	cmplStd/test/std/number.ci:34: referenced as `uint32`
	cmplStd/test/std/number.ci:33: referenced as `uint32`
	cmplStd/test/std/number.ci:31: referenced as `uint32`
	cmplStd/test/std/number.ci:30: referenced as `uint32`
	cmplStd/test/std/number.ci:29: referenced as `uint32`
	cmplStd/test/std/number.ci:27: referenced as `uint32`
	cmplStd/test/std/number.ci:26: referenced as `uint32`
	cmplStd/test/std/number.ci:25: referenced as `uint32`
	cmplStd/test/std/number.ci:23: referenced as `uint32`
	cmplStd/test/std/number.ci:22: referenced as `uint32`
	cmplStd/test/std/number.ci:21: referenced as `uint32`
	cmplStd/lib/string.ci:219: referenced as `uint32`
	cmplStd/lib/math.ci:135: referenced as `uint32`
	cmplStd/lib/math.ci:135: referenced as `uint32`
	cmplStd/lib/math.ci:117: referenced as `uint32`
	cmplStd/lib/math.ci:117: referenced as `uint32`
	cmplStd/lib/math.ci:99: referenced as `uint32`
	cmplStd/lib/math.ci:65: referenced as `uint32`
	cmplStd/stdlib.ci:31: referenced as `uint32`
	cmplStd/stdlib.ci:19: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009f48>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(21)
.usages:
	cmplStd/test/std/number.ci:62: referenced as `zxt`
	cmplStd/test/std/number.ci:31: referenced as `zxt`
	cmplStd/test/std/number.ci:30: referenced as `zxt`
	cmplStd/test/std/number.ci:29: referenced as `zxt`
	cmplStd/test/std/number.ci:23: referenced as `zxt`
	cmplStd/test/std/number.ci:22: referenced as `zxt`
	cmplStd/test/std/number.ci:21: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a2a0>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(22)
.usages:
	cmplStd/test/std/number.ci:63: referenced as `sxt`
	cmplStd/test/std/number.ci:35: referenced as `sxt`
	cmplStd/test/std/number.ci:34: referenced as `sxt`
	cmplStd/test/std/number.ci:33: referenced as `sxt`
	cmplStd/test/std/number.ci:27: referenced as `sxt`
	cmplStd/test/std/number.ci:26: referenced as `sxt`
	cmplStd/test/std/number.ci:25: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a4b8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	cmplStd/test/std/number.ci:55: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a6d0>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	cmplStd/test/std/number.ci:56: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a8e8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	cmplStd/test/std/number.ci:57: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab00>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	cmplStd/test/std/number.ci:58: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad18>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	cmplStd/test/std/number.ci:59: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af30>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	cmplStd/test/std/number.ci:60: referenced as `lob`
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000748>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00b280>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00b5d0>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:228: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:227: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:226: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:225: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:224: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:223: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:222: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:221: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:220: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:219: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:218: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:217: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:216: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:215: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:214: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:54: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:44: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:34: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:24: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:14: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:4: referenced as `uint64`
	cmplStd/test/lang/reflect.ci:13: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:85: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:65: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:45: referenced as `uint64`
	cmplStd/test/std/number.ci:66: referenced as `uint64`
	cmplStd/test/std/number.ci:65: referenced as `uint64`
	cmplStd/lib/string.ci:254: referenced as `uint64`
	cmplStd/lib/string.ci:250: referenced as `uint64`
	cmplStd/lib/string.ci:231: referenced as `uint64`
	cmplStd/lib/string.ci:229: referenced as `uint64`
	cmplStd/lib/string.ci:227: referenced as `uint64`
	cmplStd/lib/string.ci:225: referenced as `uint64`
	cmplStd/lib/string.ci:223: referenced as `uint64`
	cmplStd/lib/string.ci:221: referenced as `uint64`
	cmplStd/lib/string.ci:219: referenced as `uint64`
	cmplStd/lib/string.ci:217: referenced as `uint64`
	cmplStd/lib/string.ci:217: referenced as `uint64`
	cmplStd/lib/string.ci:144: referenced as `uint64`
	cmplStd/lib/math.ci:138: referenced as `uint64`
	cmplStd/lib/math.ci:138: referenced as `uint64`
	cmplStd/lib/math.ci:120: referenced as `uint64`
	cmplStd/lib/math.ci:120: referenced as `uint64`
	cmplStd/lib/math.ci:102: referenced as `uint64`
	cmplStd/lib/math.ci:66: referenced as `uint64`
	cmplStd/stdlib.ci:34: referenced as `uint64`
	cmplStd/stdlib.ci:22: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b280>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(29)
.usages:
	cmplStd/test/std/number.ci:65: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5d0>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(30)
.usages:
	cmplStd/test/std/number.ci:66: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00b7e8>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ba00>, cast: static const inline)
.field tan: function (size: 0, offs: <@00bc18>, cast: static const inline)
.field log: function (size: 0, offs: <@00be30>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c048>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c300>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c518>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c7d0>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `float32`
	cmplStd/test/std/test.math.ci:95: referenced as `float32`
	cmplStd/test/std/test.math.ci:94: referenced as `float32`
	cmplStd/test/std/test.math.ci:93: referenced as `float32`
	cmplStd/test/std/test.math.ci:91: referenced as `float32`
	cmplStd/test/std/test.math.ci:90: referenced as `float32`
	cmplStd/test/std/test.math.ci:89: referenced as `float32`
	cmplStd/test/std/test.math.ci:88: referenced as `float32`
	cmplStd/test/std/test.math.ci:86: referenced as `float32`
	cmplStd/test/std/test.math.ci:85: referenced as `float32`
	cmplStd/test/std/test.math.ci:84: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:246: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:245: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:244: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:243: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:242: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:240: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:239: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:238: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:237: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:5: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:4: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:3: referenced as `float32`
	cmplStd/test/lang/reflect.ci:14: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:86: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:66: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:7: referenced as `float32`
	cmplStd/test/std/number.ci:6: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:13: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:12: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:11: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:10: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:9: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:6: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/lib/string.ci:259: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:137: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:132: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:179: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:141: referenced as `float32`
	cmplStd/lib/math.ci:141: referenced as `float32`
	cmplStd/lib/math.ci:123: referenced as `float32`
	cmplStd/lib/math.ci:123: referenced as `float32`
	cmplStd/lib/math.ci:105: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:71: referenced as `float32`
	cmplStd/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b7e8>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	cmplStd/test/std/number.ci:46: referenced as `sin`
	cmplStd/test/lang/emit.ci:16: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba00>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	cmplStd/test/std/number.ci:47: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc18>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	cmplStd/test/std/number.ci:48: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be30>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	cmplStd/test/std/number.ci:49: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c048>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	cmplStd/test/std/number.ci:50: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c300>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(36)
.usages:
	cmplStd/test/std/number.ci:51: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c518>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(37)
.usages:
	cmplStd/test/std/number.ci:52: referenced as `sqrt`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c7d0>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(38)
.usages:
	cmplStd/test/std/number.ci:53: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000898>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00c9e0>, cast: static const inline)
.field cos: function (size: 0, offs: <@00cbf0>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ce00>, cast: static const inline)
.field log: function (size: 0, offs: <@00d010>, cast: static const inline)
.field exp: function (size: 0, offs: <@00d220>, cast: static const inline)
.field pow: function (size: 0, offs: <@00d4d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00d6e0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00d990>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `float64`
	cmplStd/test/std/test.math.ci:81: referenced as `float64`
	cmplStd/test/std/test.math.ci:80: referenced as `float64`
	cmplStd/test/std/test.math.ci:79: referenced as `float64`
	cmplStd/test/std/test.math.ci:77: referenced as `float64`
	cmplStd/test/std/test.math.ci:76: referenced as `float64`
	cmplStd/test/std/test.math.ci:75: referenced as `float64`
	cmplStd/test/std/test.math.ci:74: referenced as `float64`
	cmplStd/test/std/test.math.ci:72: referenced as `float64`
	cmplStd/test/std/test.math.ci:71: referenced as `float64`
	cmplStd/test/std/test.math.ci:70: referenced as `float64`
	cmplStd/test/std/test.math.ci:64: referenced as `float64`
	cmplStd/test/std/test.math.ci:63: referenced as `float64`
	cmplStd/test/std/test.math.ci:61: referenced as `float64`
	cmplStd/test/std/test.math.ci:60: referenced as `float64`
	cmplStd/test/std/test.math.ci:59: referenced as `float64`
	cmplStd/test/std/test.math.ci:58: referenced as `float64`
	cmplStd/test/std/test.math.ci:57: referenced as `float64`
	cmplStd/test/std/test.math.ci:55: referenced as `float64`
	cmplStd/test/std/test.math.ci:54: referenced as `float64`
	cmplStd/test/std/test.math.ci:53: referenced as `float64`
	cmplStd/test/std/test.math.ci:52: referenced as `float64`
	cmplStd/test/std/test.math.ci:51: referenced as `float64`
	cmplStd/test/std/test.math.ci:50: referenced as `float64`
	cmplStd/test/std/test.math.ci:49: referenced as `float64`
	cmplStd/test/std/test.math.ci:48: referenced as `float64`
	cmplStd/test/std/test.math.ci:46: referenced as `float64`
	cmplStd/test/std/test.math.ci:45: referenced as `float64`
	cmplStd/test/std/test.math.ci:44: referenced as `float64`
	cmplStd/test/std/test.math.ci:43: referenced as `float64`
	cmplStd/test/std/test.math.ci:41: referenced as `float64`
	cmplStd/test/std/test.math.ci:40: referenced as `float64`
	cmplStd/test/std/test.math.ci:39: referenced as `float64`
	cmplStd/test/std/test.math.ci:38: referenced as `float64`
	cmplStd/test/std/test.math.ci:36: referenced as `float64`
	cmplStd/test/std/test.math.ci:35: referenced as `float64`
	cmplStd/test/std/test.math.ci:33: referenced as `float64`
	cmplStd/test/std/test.math.ci:32: referenced as `float64`
	cmplStd/test/std/test.math.ci:30: referenced as `float64`
	cmplStd/test/std/test.math.ci:29: referenced as `float64`
	cmplStd/test/std/test.math.ci:27: referenced as `float64`
	cmplStd/test/std/test.math.ci:26: referenced as `float64`
	cmplStd/test/std/test.math.ci:25: referenced as `float64`
	cmplStd/test/std/test.math.ci:24: referenced as `float64`
	cmplStd/test/std/test.math.ci:22: referenced as `float64`
	cmplStd/test/std/test.math.ci:21: referenced as `float64`
	cmplStd/test/std/test.math.ci:20: referenced as `float64`
	cmplStd/test/std/test.math.ci:19: referenced as `float64`
	cmplStd/test/std/test.math.ci:18: referenced as `float64`
	cmplStd/test/std/test.math.ci:17: referenced as `float64`
	cmplStd/test/std/test.math.ci:15: referenced as `float64`
	cmplStd/test/std/test.math.ci:14: referenced as `float64`
	cmplStd/test/std/test.math.ci:13: referenced as `float64`
	cmplStd/test/std/test.math.ci:12: referenced as `float64`
	cmplStd/test/std/test.math.ci:11: referenced as `float64`
	cmplStd/test/std/test.math.ci:10: referenced as `float64`
	cmplStd/test/std/test.math.ci:8: referenced as `float64`
	cmplStd/test/std/test.math.ci:7: referenced as `float64`
	cmplStd/test/std/test.math.ci:6: referenced as `float64`
	cmplStd/test/std/test.math.ci:5: referenced as `float64`
	cmplStd/test/std/test.math.ci:4: referenced as `float64`
	cmplStd/test/std/test.math.ci:3: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:269: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:268: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:267: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:266: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:265: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:263: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:262: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:261: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:260: referenced as `float64`
	cmplStd/test/lang/reflect.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:14: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:11: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:10: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:87: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:67: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:47: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:4: referenced as `float64`
	cmplStd/test/std/number.ci:3: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:16: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:15: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/lib/string.ci:259: referenced as `float64`
	cmplStd/lib/string.ci:253: referenced as `float64`
	cmplStd/lib/string.ci:249: referenced as `float64`
	cmplStd/lib/string.ci:234: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:146: referenced as `float64`
	cmplStd/lib/math/Complex.ci:142: referenced as `float64`
	cmplStd/lib/math/Complex.ci:141: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:137: referenced as `float64`
	cmplStd/lib/math/Complex.ci:136: referenced as `float64`
	cmplStd/lib/math/Complex.ci:132: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:118: referenced as `float64`
	cmplStd/lib/math/Complex.ci:114: referenced as `float64`
	cmplStd/lib/math/Complex.ci:112: referenced as `float64`
	cmplStd/lib/math/Complex.ci:109: referenced as `float64`
	cmplStd/lib/math/Complex.ci:107: referenced as `float64`
	cmplStd/lib/math/Complex.ci:99: referenced as `float64`
	cmplStd/lib/math/Complex.ci:98: referenced as `float64`
	cmplStd/lib/math/Complex.ci:92: referenced as `float64`
	cmplStd/lib/math/Complex.ci:91: referenced as `float64`
	cmplStd/lib/math/Complex.ci:83: referenced as `float64`
	cmplStd/lib/math/Complex.ci:81: referenced as `float64`
	cmplStd/lib/math/Complex.ci:73: referenced as `float64`
	cmplStd/lib/math/Complex.ci:71: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:64: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:24: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math.ci:512: referenced as `float64`
	cmplStd/lib/math.ci:512: referenced as `float64`
	cmplStd/lib/math.ci:509: referenced as `float64`
	cmplStd/lib/math.ci:509: referenced as `float64`
	cmplStd/lib/math.ci:485: referenced as `float64`
	cmplStd/lib/math.ci:472: referenced as `float64`
	cmplStd/lib/math.ci:469: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:450: referenced as `float64`
	cmplStd/lib/math.ci:450: referenced as `float64`
	cmplStd/lib/math.ci:442: referenced as `float64`
	cmplStd/lib/math.ci:442: referenced as `float64`
	cmplStd/lib/math.ci:440: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:423: referenced as `float64`
	cmplStd/lib/math.ci:420: referenced as `float64`
	cmplStd/lib/math.ci:420: referenced as `float64`
	cmplStd/lib/math.ci:418: referenced as `float64`
	cmplStd/lib/math.ci:415: referenced as `float64`
	cmplStd/lib/math.ci:398: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:380: referenced as `float64`
	cmplStd/lib/math.ci:379: referenced as `float64`
	cmplStd/lib/math.ci:362: referenced as `float64`
	cmplStd/lib/math.ci:361: referenced as `float64`
	cmplStd/lib/math.ci:340: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:336: referenced as `float64`
	cmplStd/lib/math.ci:333: referenced as `float64`
	cmplStd/lib/math.ci:328: referenced as `float64`
	cmplStd/lib/math.ci:327: referenced as `float64`
	cmplStd/lib/math.ci:326: referenced as `float64`
	cmplStd/lib/math.ci:309: referenced as `float64`
	cmplStd/lib/math.ci:305: referenced as `float64`
	cmplStd/lib/math.ci:302: referenced as `float64`
	cmplStd/lib/math.ci:296: referenced as `float64`
	cmplStd/lib/math.ci:283: referenced as `float64`
	cmplStd/lib/math.ci:282: referenced as `float64`
	cmplStd/lib/math.ci:282: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:244: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:231: referenced as `float64`
	cmplStd/lib/math.ci:231: referenced as `float64`
	cmplStd/lib/math.ci:226: referenced as `float64`
	cmplStd/lib/math.ci:226: referenced as `float64`
	cmplStd/lib/math.ci:218: referenced as `float64`
	cmplStd/lib/math.ci:217: referenced as `float64`
	cmplStd/lib/math.ci:217: referenced as `float64`
	cmplStd/lib/math.ci:207: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:193: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:180: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:144: referenced as `float64`
	cmplStd/lib/math.ci:144: referenced as `float64`
	cmplStd/lib/math.ci:126: referenced as `float64`
	cmplStd/lib/math.ci:126: referenced as `float64`
	cmplStd/lib/math.ci:108: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:74: referenced as `float64`
	cmplStd/lib/math.ci:57: referenced as `float64`
	cmplStd/lib/math.ci:54: referenced as `float64`
	cmplStd/lib/math.ci:48: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:32: referenced as `float64`
	cmplStd/lib/math.ci:25: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:5: referenced as `float64`
	cmplStd/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c9e0>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	cmplStd/test/std/number.ci:37: referenced as `sin`
	cmplStd/lib/math/Complex.ci:187: referenced as `sin`
	cmplStd/lib/math/Complex.ci:151: referenced as `sin`
	cmplStd/lib/math/Complex.ci:149: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:129: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cbf0>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	cmplStd/test/std/number.ci:38: referenced as `cos`
	cmplStd/lib/math/Complex.ci:187: referenced as `cos`
	cmplStd/lib/math/Complex.ci:151: referenced as `cos`
	cmplStd/lib/math/Complex.ci:149: referenced as `cos`
	cmplStd/lib/math/Complex.ci:141: referenced as `cos`
	cmplStd/lib/math/Complex.ci:129: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ce00>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	cmplStd/test/std/number.ci:39: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d010>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	cmplStd/test/std/number.ci:40: referenced as `log`
	cmplStd/lib/math/Complex.ci:138: referenced as `log`
	cmplStd/lib/math/Complex.ci:132: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d220>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	cmplStd/test/std/number.ci:41: referenced as `exp`
	cmplStd/lib/math/Complex.ci:139: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math.ci:442: referenced as `exp`
	cmplStd/lib/math.ci:442: referenced as `exp`
	cmplStd/lib/math.ci:440: referenced as `exp`
	cmplStd/lib/math.ci:420: referenced as `exp`
	cmplStd/lib/math.ci:420: referenced as `exp`
	cmplStd/lib/math.ci:415: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d4d0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(44)
.usages:
	cmplStd/test/std/number.ci:42: referenced as `pow`
	cmplStd/lib/string.ci:253: referenced as `pow`
	cmplStd/lib/math/Complex.ci:139: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d6e0>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(45)
.usages:
	cmplStd/test/std/number.ci:43: referenced as `sqrt`
	cmplStd/lib/math/Complex.ci:112: referenced as `sqrt`
	cmplStd/lib/math.ci:467: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d990>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(46)
.usages:
	cmplStd/test/std/number.ci:44: referenced as `atan2`
	cmplStd/lib/math/Complex.ci:114: referenced as `atan2`
	cmplStd/lib/math.ci:472: referenced as `atan2`
	cmplStd/lib/math.ci:469: referenced as `atan2`
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000940>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@0084f0>, cast: static const inline)
.field fill: function (size: 0, offs: <@008850>, cast: static const inline)
.field copy: function (size: 0, offs: <@008bb0>, cast: static const inline)
.field move: function (size: 0, offs: <@008f08>, cast: static const inline)
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:283: referenced as `pointer`
	cmplStd/test/lang/reflect.ci:16: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:108: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:90: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:70: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:52: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:51: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:49: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:48: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:47: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:46: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:45: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:44: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:43: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:42: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:41: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:40: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:39: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:38: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:37: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:36: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:35: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:30: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:17: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:9: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:43: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:38: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:24: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:20: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:14: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:11: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:14: referenced as `pointer`
	cmplStd/test/std/memory.ci:13: referenced as `pointer`
	cmplStd/test/std/memory.ci:10: referenced as `pointer`
	cmplStd/test/std/memory.ci:9: referenced as `pointer`
	cmplStd/test/std/memory.ci:8: referenced as `pointer`
	cmplStd/test/std/memory.ci:7: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:4: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/emit.ci:29: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0084f0>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(10)
.usages:
	cmplStd/test/std/memory.ci:5: referenced as `alloc`
	cmplStd/test/std/memory.ci:4: referenced as `alloc`
	cmplStd/test/std/memory.ci:3: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008850>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: uint8 (size: 4, offs: <+8>, cast: variable(u32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(11)
.usages:
	cmplStd/test/std/memory.ci:30: referenced as `fill`
	cmplStd/test/std/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008bb0>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	cmplStd/test/std/memory.ci:14: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f08>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(13)
.usages:
	cmplStd/test/std/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@0009e8>
.name: 'variant'
.field as: function (size: 0, offs: <@006198>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:17: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:105: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:91: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:72: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:70: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:69: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:68: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:67: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:66: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:65: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:64: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:63: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:62: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:61: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:60: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:59: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:58: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:57: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:56: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:55: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:51: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:31: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:24: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:18: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:10: referenced as `variant`
	cmplStd/lib/debug.ci:65: referenced as `variant`
	cmplStd/lib/debug.ci:56: referenced as `variant`
	cmplStd/lib/debug.ci:53: referenced as `variant`
	cmplStd/lib/debug.ci:50: referenced as `variant`
	cmplStd/lib/debug.ci:41: referenced as `variant`
	cmplStd/lib/debug.ci:34: referenced as `variant`
	cmplStd/lib/debug.ci:29: referenced as `variant`
	cmplStd/lib/debug.ci:24: referenced as `variant`
	cmplStd/lib/debug.ci:19: referenced as `variant`
	cmplStd/lib/debug.ci:14: referenced as `variant`
	cmplStd/lib/debug.ci:9: referenced as `variant`
	cmplStd/lib/debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006198>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a90>
.name: 'function'
.usages:
	cmplStd/test/lang/reflect.ci:19: referenced as `function`
	cmplStd/test/lang/init.reference.ci:89: referenced as `function`
	cmplStd/test/lang/init.reference.ci:69: referenced as `function`
	cmplStd/test/lang/init.reference.ci:49: referenced as `function`
	cmplStd/test/lang/init.reference.ci:20: referenced as `function`
	cmplStd/stdlib.ci:39: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000b40>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/recUnion.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:20: referenced as `object`
	cmplStd/test/lang/init.variable.ci:41: referenced as `object`
	cmplStd/test/lang/init.variable.ci:13: referenced as `object`
	cmplStd/test/lang/init.reference.ci:92: referenced as `object`
	cmplStd/test/lang/init.reference.ci:72: referenced as `object`
	cmplStd/test/lang/init.reference.ci:52: referenced as `object`
	cmplStd/test/lang/init.reference.ci:21: referenced as `object`
	internal usages: 1
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	cmplStd/test/lang/stmt.if.ci:73: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `null`
	cmplStd/test/lang/useOperator.ci:283: referenced as `null`
	cmplStd/test/lang/init.array.ci:60: referenced as `null`
	cmplStd/test/lang/init.array.ci:19: referenced as `null`
	cmplStd/test/lang/init.array.ci:18: referenced as `null`
	cmplStd/test/lang/init.array.ci:2: referenced as `null`
	cmplStd/test/lang/init.method.ci:92: referenced as `null`
	cmplStd/test/lang/init.method.ci:86: referenced as `null`
	cmplStd/test/lang/init.reference.ci:21: referenced as `null`
	cmplStd/test/lang/init.reference.ci:20: referenced as `null`
	cmplStd/test/lang/init.reference.ci:19: referenced as `null`
	cmplStd/test/lang/init.reference.ci:18: referenced as `null`
	cmplStd/test/lang/init.reference.ci:17: referenced as `null`
	cmplStd/test/lang/init.reference.ci:16: referenced as `null`
	cmplStd/test/lang/init.reference.ci:3: referenced as `null`
	cmplStd/test/std/tryExec.ci:53: referenced as `null`
	cmplStd/test/std/tryExec.ci:52: referenced as `null`
	cmplStd/test/std/tryExec.ci:51: referenced as `null`
	cmplStd/test/std/tryExec.ci:50: referenced as `null`
	cmplStd/test/std/tryExec.ci:49: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:47: referenced as `null`
	cmplStd/test/std/tryExec.ci:39: referenced as `null`
	cmplStd/test/std/memory.ci:4: referenced as `null`
	cmplStd/lib/string.ci:5: referenced as `null`
	cmplStd/lib/debug.ci:74: referenced as `null`
	cmplStd/lib/debug.ci:56: referenced as `null`
	cmplStd/lib/debug.ci:38: referenced as `null`
	cmplStd/lib/debug.ci:36: referenced as `null`
	cmplStd/lib/debug.ci:31: referenced as `null`
	cmplStd/lib/debug.ci:26: referenced as `null`
	cmplStd/lib/debug.ci:21: referenced as `null`
	cmplStd/lib/debug.ci:16: referenced as `null`
	cmplStd/lib/debug.ci:11: referenced as `null`
	cmplStd/lib/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000de0>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000e88>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001278>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001320>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0015c0>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001ba8>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001f70>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@002168>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@002350>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002538>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002720>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002908>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002c30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@0030b8>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003520>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@003988>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f30>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044d8>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004940>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004da8>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005210>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005678>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005860>, cast: static const typename(void))
.field swz: typename (size: 0, offs: <@005a48>, cast: static const typename(void))
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:29: referenced as `emit`
	cmplStd/test/lang/emit.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:19: referenced as `emit`
	cmplStd/test/lang/emit.ci:16: referenced as `emit`
	cmplStd/test/lang/emit.ci:13: referenced as `emit`
	cmplStd/test/lang/emit.ci:10: referenced as `emit`
	cmplStd/test/lang/emit.ci:4: referenced as `emit`
	cmplStd/test/lang/emit.ci:3: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:76: referenced as `emit`
	cmplStd/lib/math/Complex.ci:69: referenced as `emit`
	cmplStd/lib/math/Complex.ci:62: referenced as `emit`
	cmplStd/lib/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001278>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:112: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:116: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001320>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0015c0>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `load`
	cmplStd/test/lang/emit.ci:4: referenced as `load`
	cmplStd/test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `z32`
	cmplStd/test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	cmplStd/test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001ba8>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f70>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002168>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002350>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002538>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002720>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002908>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002c30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0030b8>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `add`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:77: referenced as `add`
	cmplStd/lib/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003520>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:78: referenced as `sub`
	cmplStd/lib/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003988>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:78: referenced as `mul`
	cmplStd/lib/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:78: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f30>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `div`
	cmplStd/test/lang/emit.ci:13: referenced as `div`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	cmplStd/test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044d8>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004940>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004da8>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005210>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005678>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005860>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005a48>
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `swz`
	cmplStd/lib/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `x2`
	cmplStd/lib/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ed8>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0078e0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(8)
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/stdlib.ci:39: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	cmplStd/lib/debug.ci:71: referenced as `abort`
	cmplStd/lib/debug.ci:38: referenced as `abort`
	cmplStd/lib/debug.ci:36: referenced as `abort`
	cmplStd/lib/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	cmplStd/lib/debug.ci:31: referenced as `error`
	cmplStd/lib/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	cmplStd/lib/debug.ci:26: referenced as `warn`
	cmplStd/lib/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	cmplStd/lib/debug.ci:21: referenced as `info`
	cmplStd/lib/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `debug`
	cmplStd/lib/debug.ci:16: referenced as `debug`
	cmplStd/lib/debug.ci:14: referenced as `debug`
	cmplStd/lib/debug.ci:11: referenced as `debug`
	cmplStd/lib/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	cmplStd/lib/debug.ci:6: referenced as `verbose`
	cmplStd/lib/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	cmplStd/lib/debug.ci:26: referenced as `noTrace`
	cmplStd/lib/debug.ci:24: referenced as `noTrace`
	cmplStd/lib/debug.ci:21: referenced as `noTrace`
	cmplStd/lib/debug.ci:19: referenced as `noTrace`
	cmplStd/lib/debug.ci:11: referenced as `noTrace`
	cmplStd/lib/debug.ci:9: referenced as `noTrace`
	cmplStd/lib/debug.ci:6: referenced as `noTrace`
	cmplStd/lib/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	cmplStd/lib/debug.ci:71: referenced as `defTrace`
	cmplStd/lib/debug.ci:38: referenced as `defTrace`
	cmplStd/lib/debug.ci:36: referenced as `defTrace`
	cmplStd/lib/debug.ci:34: referenced as `defTrace`
	cmplStd/lib/debug.ci:31: referenced as `defTrace`
	cmplStd/lib/debug.ci:29: referenced as `defTrace`
	cmplStd/lib/debug.ci:16: referenced as `defTrace`
	cmplStd/lib/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008230>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:52: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:51: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:50: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:49: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:48: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:47: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008f38>
.name: 'System'
.field exit: function (size: 0, offs: <@0091d0>, cast: static const inline)
.field srand: function (size: 0, offs: <@0093f0>, cast: static const inline)
.field rand: function (size: 0, offs: <@009568>, cast: static const inline)
.field time: function (size: 0, offs: <@0096e0>, cast: static const inline)
.field clock: function (size: 0, offs: <@009858>, cast: static const inline)
.field millis: function (size: 0, offs: <@0099d0>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009be8>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0091d0>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(14)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093f0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(15)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009568>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(16)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096e0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009858>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(18)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0099d0>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(19)
.usages:
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009be8>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(20)
.usages:
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.file: 'cmplStd/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	cmplStd/test/lang/useOperator.ci:7: referenced as `true`
	cmplStd/lib/string.ci:57: referenced as `true`
	cmplStd/lib/string.ci:42: referenced as `true`
	cmplStd/lib/math.ci:458: referenced as `true`
	cmplStd/lib/math.ci:411: referenced as `true`
	cmplStd/lib/math.ci:372: referenced as `true`
	cmplStd/lib/math.ci:368: referenced as `true`
	cmplStd/lib/math.ci:357: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.file: 'cmplStd/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:8: referenced as `false`
	cmplStd/lib/string.ci:242: referenced as `false`
	cmplStd/lib/string.ci:114: referenced as `false`
	cmplStd/lib/string.ci:54: referenced as `false`
	cmplStd/lib/string.ci:50: referenced as `false`
	cmplStd/lib/string.ci:39: referenced as `false`
	cmplStd/lib/math.ci:456: referenced as `false`
	cmplStd/lib/math.ci:408: referenced as `false`
	cmplStd/lib/math.ci:353: referenced as `false`
	cmplStd/lib/math.ci:352: referenced as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'cmplStd/stdlib.ci:8'
.value: uint8
.usages:
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'cmplStd/stdlib.ci:9'
.value: float32
.usages:
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'cmplStd/stdlib.ci:10'
.value: float64
.usages:
}
signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:13'
.param .result: int8 (size: 1, offs: <+0>, cast: i32)
.param value: uint8 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:16'
.param .result: int16 (size: 2, offs: <+0>, cast: i32)
.param value: uint16 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math.ci:227: referenced as `signed`
}
signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:22'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:25'
.param .result: uint8 (size: 1, offs: <+0>, cast: u32)
.param value: int8 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:28'
.param .result: uint16 (size: 2, offs: <+0>, cast: u32)
.param value: int16 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:31'
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param value: int32 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:34'
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param value: int64 (size: 8, offs: <+8>, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'cmplStd/stdlib.ci:37'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	cmplStd/test/lang/reflect.ci:40: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:33: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:20: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:19: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:18: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:17: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:16: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:15: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:14: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:13: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:12: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:11: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:10: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:9: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:8: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:7: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:6: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:5: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:4: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:3: referenced as `sizeof`
	cmplStd/test/std/memory.ci:30: referenced as `sizeof`
	cmplStd/test/std/memory.ci:29: referenced as `sizeof`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	cmplStd/test/lang/stmt.for.ci:28: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:21: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:14: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:9: referenced as `debug`
	cmplStd/test/lang/init.array.ci:41: referenced as `debug`
	cmplStd/test/lang/init.array.ci:38: referenced as `debug`
	cmplStd/test/lang/init.array.ci:35: referenced as `debug`
	cmplStd/test/std/memory.ci:33: referenced as `debug`
	cmplStd/test/std/memory.ci:32: referenced as `debug`
	cmplStd/test/std/memory.ci:27: referenced as `debug`
	cmplStd/test/std/memory.ci:26: referenced as `debug`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.for.ci:4: referenced as `debug`
	cmplStd/test/lang/init.method.ci:91: referenced as `debug`
	cmplStd/test/lang/init.method.ci:85: referenced as `debug`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/lang/init.method.ci:58: referenced as `trace`
	cmplStd/test/lang/init.method.ci:48: referenced as `trace`
	cmplStd/test/lang/init.method.ci:41: referenced as `trace`
	cmplStd/test/lang/init.method.ci:11: referenced as `trace`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `trace`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.if.ci:78: referenced as `error`
	cmplStd/test/lang/stmt.if.ci:74: referenced as `error`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/std/tryExec.ci:35: referenced as `abort`
	cmplStd/lib/debug.ci:41: referenced as `abort`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	cmplStd/lib/debug.ci:45: referenced as `abort`
	cmplStd/lib/debug.ci:43: referenced as `abort`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	cmplStd/lib/string.ci:162: referenced as `assert`
	cmplStd/lib/string.ci:161: referenced as `assert`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	cmplStd/test/lang/init.array.ci:84: referenced as `assert`
	cmplStd/test/lang/init.array.ci:82: referenced as `assert`
	cmplStd/test/lang/init.array.ci:80: referenced as `assert`
	cmplStd/test/lang/init.array.ci:78: referenced as `assert`
	cmplStd/test/lang/init.array.ci:77: referenced as `assert`
	cmplStd/test/lang/init.array.ci:76: referenced as `assert`
	cmplStd/test/lang/init.array.ci:74: referenced as `assert`
	cmplStd/test/lang/init.array.ci:73: referenced as `assert`
	cmplStd/test/lang/init.array.ci:72: referenced as `assert`
	cmplStd/test/lang/init.array.ci:70: referenced as `assert`
	cmplStd/test/lang/init.array.ci:69: referenced as `assert`
	cmplStd/test/lang/init.array.ci:68: referenced as `assert`
	cmplStd/test/lang/init.array.ci:49: referenced as `assert`
	cmplStd/test/lang/init.array.ci:48: referenced as `assert`
	cmplStd/lib/string.ci:204: referenced as `assert`
	cmplStd/lib/string.ci:197: referenced as `assert`
	cmplStd/lib/string.ci:190: referenced as `assert`
	cmplStd/lib/string.ci:185: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@012348>
.name: 'NotEquals'
.file: 'cmplStd/lib/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field extras: variant[] (size: 8, offs: <+16>, cast: const variable(arr))
.doc: '@public'
.usages:
	cmplStd/lib/debug.ci:66: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'cmplStd/lib/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/debug.ci:67: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'cmplStd/lib/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/debug.ci:68: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.offset: <+16>
.name: 'extras'
.file: 'cmplStd/lib/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	cmplStd/lib/debug.ci:69: referenced as `extras`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 103
.offset: <@061078>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:61'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	extras: variant[1] := {
		void(extras[0] := (message));
	};
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.extras := (extras));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (103 bytes: <assertEq @061078> - <assertEq+103 @0610df>)
	cmplStd/lib/debug.ci:62: (10 bytes: <assertEq @061078> - <assertEq+10 @061082>): if (returned == expected)
	<assertEq @061078>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @06107a>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @06107c>    : 57                         ceq.i32
	<assertEq+5 @06107d>    : 06 05 00 00                jz <assertEq+10 @061082>
	cmplStd/lib/debug.ci:63: (1 byte: <assertEq+9 @061081> - <assertEq+10 @061082>): return;
	<assertEq+9 @061081>    : 03                         ret
	cmplStd/lib/debug.ci:65: (13 bytes: <assertEq+10 @061082> - <assertEq+23 @06108f>): extras: variant[1] := {...}
	<assertEq+10 @061082>   : 09 08 00 00                inc.sp(+8)
	cmplStd/lib/debug.ci:65: (9 bytes: <assertEq+14 @061086> - <assertEq+23 @06108f>): extras[0] := (message);
	<assertEq+14 @061086>   : 1f 48 28 01 00             load.ref <@012848>
	<assertEq+19 @06108b>   : 10 04                      dup.x32 sp(4)
	<assertEq+21 @06108d>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:66: (37 bytes: <assertEq+23 @06108f> - <assertEq+60 @0610b4>): details: NotEquals := {...}
	<assertEq+23 @06108f>   : 09 18 00 00                inc.sp(+24)
	cmplStd/lib/debug.ci:67: (11 bytes: <assertEq+27 @061093> - <assertEq+38 @06109e>): details.expected := (expected);
	<assertEq+27 @061093>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+32 @061098>   : 0a 30 00 00                load.sp(+48)
	<assertEq+36 @06109c>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:68: (11 bytes: <assertEq+38 @06109e> - <assertEq+49 @0610a9>): details.returned := (returned);
	<assertEq+38 @06109e>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+43 @0610a3>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+47 @0610a7>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/debug.ci:69: (11 bytes: <assertEq+49 @0610a9> - <assertEq+60 @0610b4>): details.extras := (extras);
	<assertEq+49 @0610a9>   : 1c 01 00 00 00             load.c32 1
	<assertEq+54 @0610ae>   : 0a 1c 00 00                load.sp(+28)
	<assertEq+58 @0610b2>   : 14 06                      set.x64 sp(6)
	cmplStd/lib/debug.ci:71: (38 bytes: <assertEq+60 @0610b4> - <assertEq+98 @0610da>): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+60 @0610b4>   : 1f f0 ee 00 00             load.ref <@00eef0> ;"cmplStd/lib/debug.ci"
	<assertEq+65 @0610b9>   : 1c 47 00 00 00             load.c32 71
	<assertEq+70 @0610be>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+75 @0610c3>   : 1c 80 00 00 00             load.c32 128
	<assertEq+80 @0610c8>   : 1f d0 f1 00 00             load.ref <@00f1d0> ;"assertion failed"
	<assertEq+85 @0610cd>   : 1f 48 23 01 00             load.ref <@012348> ;NotEquals
	<assertEq+90 @0610d2>   : 0a 18 00 00                load.sp(+24)
	<assertEq+94 @0610d6>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+98 @0610da>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+102 @0610de>  : 03                         ret
.usages:
	cmplStd/lib/debug.ci:74: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:74'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	cmplStd/test/lang/init.array.ci:64: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:63: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:62: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:61: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:60: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:58: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:57: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:56: referenced as `assertEq`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0135e0>
.name: 'Math'
.file: 'cmplStd/lib/math.ci:2'
.field pi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field e: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 0, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 0, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@0610e0>, cast: static function)
.field floor: function (size: 24, offs: <@061138>, cast: static function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field absMod: function (size: 27, offs: <@061150>, cast: static function)
.field absMod: function (size: 27, offs: <@061170>, cast: static function)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 30, offs: <@061190>, cast: static function)
.field clamp: function (size: 30, offs: <@0611b0>, cast: static function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@0611d0>, cast: static function)
.field max: function (size: 79, offs: <@061220>, cast: static function)
.field sum: function (size: 40, offs: <@061270>, cast: static function)
.field mean: function (size: 20, offs: <@061298>, cast: static function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@0612b0>, cast: static function)
.field cmp: function (size: 57, offs: <@0612e0>, cast: static function)
.field cmp: function (size: 57, offs: <@061320>, cast: static function)
.field sinCos: function (size: 335, offs: <@061360>, cast: static function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@0614b0>, cast: static function)
.field sinh: function (size: 241, offs: <@061630>, cast: static function)
.field cosh: function (size: 75, offs: <@061728>, cast: static function)
.field asin: function (size: 173, offs: <@061778>, cast: static function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `Math`
	cmplStd/test/std/test.math.ci:95: referenced as `Math`
	cmplStd/test/std/test.math.ci:94: referenced as `Math`
	cmplStd/test/std/test.math.ci:93: referenced as `Math`
	cmplStd/test/std/test.math.ci:91: referenced as `Math`
	cmplStd/test/std/test.math.ci:90: referenced as `Math`
	cmplStd/test/std/test.math.ci:89: referenced as `Math`
	cmplStd/test/std/test.math.ci:88: referenced as `Math`
	cmplStd/test/std/test.math.ci:86: referenced as `Math`
	cmplStd/test/std/test.math.ci:85: referenced as `Math`
	cmplStd/test/std/test.math.ci:84: referenced as `Math`
	cmplStd/test/std/test.math.ci:82: referenced as `Math`
	cmplStd/test/std/test.math.ci:81: referenced as `Math`
	cmplStd/test/std/test.math.ci:80: referenced as `Math`
	cmplStd/test/std/test.math.ci:79: referenced as `Math`
	cmplStd/test/std/test.math.ci:77: referenced as `Math`
	cmplStd/test/std/test.math.ci:76: referenced as `Math`
	cmplStd/test/std/test.math.ci:75: referenced as `Math`
	cmplStd/test/std/test.math.ci:74: referenced as `Math`
	cmplStd/test/std/test.math.ci:72: referenced as `Math`
	cmplStd/test/std/test.math.ci:71: referenced as `Math`
	cmplStd/test/std/test.math.ci:70: referenced as `Math`
	cmplStd/test/std/test.math.ci:68: referenced as `Math`
	cmplStd/test/std/test.math.ci:67: referenced as `Math`
	cmplStd/test/std/test.math.ci:64: referenced as `Math`
	cmplStd/test/std/test.math.ci:63: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:55: referenced as `Math`
	cmplStd/test/std/test.math.ci:54: referenced as `Math`
	cmplStd/test/std/test.math.ci:53: referenced as `Math`
	cmplStd/test/std/test.math.ci:52: referenced as `Math`
	cmplStd/test/std/test.math.ci:51: referenced as `Math`
	cmplStd/test/std/test.math.ci:50: referenced as `Math`
	cmplStd/test/std/test.math.ci:49: referenced as `Math`
	cmplStd/test/std/test.math.ci:46: referenced as `Math`
	cmplStd/test/std/test.math.ci:45: referenced as `Math`
	cmplStd/test/std/test.math.ci:44: referenced as `Math`
	cmplStd/test/std/test.math.ci:43: referenced as `Math`
	cmplStd/test/std/test.math.ci:41: referenced as `Math`
	cmplStd/test/std/test.math.ci:40: referenced as `Math`
	cmplStd/test/std/test.math.ci:39: referenced as `Math`
	cmplStd/test/std/test.math.ci:38: referenced as `Math`
	cmplStd/test/std/test.math.ci:36: referenced as `Math`
	cmplStd/test/std/test.math.ci:35: referenced as `Math`
	cmplStd/test/std/test.math.ci:33: referenced as `Math`
	cmplStd/test/std/test.math.ci:32: referenced as `Math`
	cmplStd/test/std/test.math.ci:30: referenced as `Math`
	cmplStd/test/std/test.math.ci:29: referenced as `Math`
	cmplStd/test/std/test.math.ci:27: referenced as `Math`
	cmplStd/test/std/test.math.ci:26: referenced as `Math`
	cmplStd/test/std/test.math.ci:25: referenced as `Math`
	cmplStd/test/std/test.math.ci:24: referenced as `Math`
	cmplStd/test/std/test.math.ci:22: referenced as `Math`
	cmplStd/test/std/test.math.ci:21: referenced as `Math`
	cmplStd/test/std/test.math.ci:20: referenced as `Math`
	cmplStd/test/std/test.math.ci:19: referenced as `Math`
	cmplStd/test/std/test.math.ci:18: referenced as `Math`
	cmplStd/test/std/test.math.ci:17: referenced as `Math`
	cmplStd/test/std/test.math.ci:15: referenced as `Math`
	cmplStd/test/std/test.math.ci:14: referenced as `Math`
	cmplStd/test/std/test.math.ci:13: referenced as `Math`
	cmplStd/test/std/test.math.ci:12: referenced as `Math`
	cmplStd/test/std/test.math.ci:11: referenced as `Math`
	cmplStd/test/std/test.math.ci:10: referenced as `Math`
	cmplStd/test/std/test.math.ci:8: referenced as `Math`
	cmplStd/test/std/test.math.ci:7: referenced as `Math`
	cmplStd/test/std/test.math.ci:6: referenced as `Math`
	cmplStd/test/std/test.math.ci:5: referenced as `Math`
	cmplStd/test/std/test.math.ci:4: referenced as `Math`
	cmplStd/test/std/test.math.ci:3: referenced as `Math`
	cmplStd/lib/string.ci:249: referenced as `Math`
	cmplStd/lib/string.ci:249: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'pi'
.file: 'cmplStd/lib/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `pi`
	cmplStd/test/std/test.math.ci:60: referenced as `pi`
	cmplStd/test/std/test.math.ci:59: referenced as `pi`
	cmplStd/test/std/test.math.ci:58: referenced as `pi`
	cmplStd/test/std/test.math.ci:57: referenced as `pi`
	cmplStd/lib/math.ci:512: referenced as `pi`
	cmplStd/lib/math.ci:509: referenced as `pi`
	cmplStd/lib/math.ci:485: referenced as `pi`
	cmplStd/lib/math.ci:469: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'e'
.file: 'cmplStd/lib/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln2'
.file: 'cmplStd/lib/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log2E'
.file: 'cmplStd/lib/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln10'
.file: 'cmplStd/lib/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log10E'
.file: 'cmplStd/lib/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'phi'
.file: 'cmplStd/lib/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrt2'
.file: 'cmplStd/lib/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtE'
.file: 'cmplStd/lib/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPi'
.file: 'cmplStd/lib/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'nan'
.file: 'cmplStd/lib/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/math.ci:464: referenced as `nan`
	cmplStd/lib/math.ci:385: referenced as `nan`
	cmplStd/lib/math.ci:205: referenced as `nan`
	cmplStd/lib/math.ci:191: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'inf'
.file: 'cmplStd/lib/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 86
.offset: <@0610e0>
.name: 'modf'
.file: 'cmplStd/lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <modf @0610e0> - <modf+86 @061136>)
	cmplStd/lib/math.ci:23: (63 bytes: <modf @0610e0> - <modf+63 @06111f>): if (x < (1))
	<modf @0610e0>      : 11 02                      dup.x64 sp(2)
	<modf+2 @0610e2>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @0610eb>   : 88                         clt.f64
	<modf+12 @0610ec>   : 06 33 00 00                jz <modf+63 @06111f>
	cmplStd/lib/math.ci:24: (39 bytes: <modf+16 @0610f0> - <modf+55 @061117>): if (x < (0))
	<modf+16 @0610f0>   : 11 02                      dup.x64 sp(2)
	<modf+18 @0610f2>   : 1a                         load.z64
	<modf+19 @0610f3>   : 88                         clt.f64
	<modf+20 @0610f4>   : 06 23 00 00                jz <modf+55 @061117>
	cmplStd/lib/math.ci:25: (17 bytes: <modf+24 @0610f8> - <modf+41 @061109>): result: float64 := -modf(-x, &intPart)
	<modf+24 @0610f8>   : 1a                         load.z64
	<modf+25 @0610f9>   : 11 04                      dup.x64 sp(4)
	<modf+27 @0610fb>   : 80                         neg.f64
	<modf+28 @0610fc>   : 10 05                      dup.x32 sp(5)
	<modf+30 @0610fe>   : 1f e0 10 06 00             load.ref <@0610e0> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @061103>   : 02                         call
	<modf+36 @061104>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @061108>   : 80                         neg.f64
	cmplStd/lib/math.ci:26: (7 bytes: <modf+41 @061109> - <modf+48 @061110>): intPart := -intPart;
	<modf+41 @061109>   : 10 03                      dup.x32 sp(3)
	<modf+43 @06110b>   : 29                         load.i64
	<modf+44 @06110c>   : 80                         neg.f64
	<modf+45 @06110d>   : 10 05                      dup.x32 sp(5)
	<modf+47 @06110f>   : 2e                         store.i64
	cmplStd/lib/math.ci:27: (3 bytes: <modf+48 @061110> - <modf+51 @061113>): return .result := result;
	<modf+48 @061110>   : 14 06                      set.x64 sp(6)
	<modf+50 @061112>   : 03                         ret
	<modf+51 @061113>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:29: (4 bytes: <modf+55 @061117> - <modf+59 @06111b>): intPart := (0);
	<modf+55 @061117>   : 1a                         load.z64
	<modf+56 @061118>   : 10 03                      dup.x32 sp(3)
	<modf+58 @06111a>   : 2e                         store.i64
	cmplStd/lib/math.ci:30: (4 bytes: <modf+59 @06111b> - <modf+63 @06111f>): return .result := x;
	<modf+59 @06111b>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @06111e>   : 03                         ret
	cmplStd/lib/math.ci:32: (12 bytes: <modf+63 @06111f> - <modf+75 @06112b>): result: float64 := x % (1)
	<modf+63 @06111f>   : 11 02                      dup.x64 sp(2)
	<modf+65 @061121>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @06112a>   : 85                         mod.f64
	cmplStd/lib/math.ci:33: (8 bytes: <modf+75 @06112b> - <modf+83 @061133>): intPart := x - result;
	<modf+75 @06112b>   : 11 04                      dup.x64 sp(4)
	<modf+77 @06112d>   : 11 02                      dup.x64 sp(2)
	<modf+79 @06112f>   : 82                         sub.f64
	<modf+80 @061130>   : 10 05                      dup.x32 sp(5)
	<modf+82 @061132>   : 2e                         store.i64
	cmplStd/lib/math.ci:34: (3 bytes: <modf+83 @061133> - <modf+86 @061136>): return .result := result;
	<modf+83 @061133>   : 14 06                      set.x64 sp(6)
	<modf+85 @061135>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:249: referenced as `modf`
	cmplStd/lib/math.ci:362: referenced as `modf`
	cmplStd/lib/math.ci:310: referenced as `modf`
	cmplStd/lib/math.ci:306: referenced as `modf`
	cmplStd/lib/math.ci:49: referenced as `modf`
	cmplStd/lib/math.ci:25: referenced as `modf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@061138>
.name: 'floor'
.file: 'cmplStd/lib/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <floor @061138> - <floor+24 @061150>)
	cmplStd/lib/math.ci:48: (1 byte: <floor @061138> - <floor+1 @061139>): result: float64
	<floor @061138>      : 1b                         load.z128
	cmplStd/lib/math.ci:49: (20 bytes: <floor+1 @061139> - <floor+21 @06114d>): modf(x, &result);
	<floor+1 @061139>    : 11 05                      dup.x64 sp(5)
	<floor+3 @06113b>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @06113f>    : 1f e0 10 06 00             load.ref <@0610e0> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @061144>   : 02                         call
	<floor+13 @061145>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @061149>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:50: (3 bytes: <floor+21 @06114d> - <floor+24 @061150>): return .result := result;
	<floor+21 @06114d>   : 14 05                      set.x64 sp(5)
	<floor+23 @06114f>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:8: referenced as `floor`
	cmplStd/test/std/test.math.ci:7: referenced as `floor`
	cmplStd/test/std/test.math.ci:6: referenced as `floor`
	cmplStd/test/std/test.math.ci:5: referenced as `floor`
	cmplStd/test/std/test.math.ci:4: referenced as `floor`
	cmplStd/test/std/test.math.ci:3: referenced as `floor`
	cmplStd/lib/math.ci:57: referenced as `floor`
	cmplStd/lib/math.ci:54: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'cmplStd/lib/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'cmplStd/lib/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
}
Math.sign(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:63'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: bool(x != 0) ? bool(x < 0) ? int32(-1) : 1 : 0
.usages:
}
Math.sign(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: bool(x != (0)) ? bool(x < (0)) ? int32(-1) : 1 : 0
.usages:
}
Math.sign(x: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:65'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: uint32 (size: 4, offs: <+4>, cast: u32)
.value: bool(x > (0)) ? 1 : 0
.usages:
}
Math.sign(x: uint64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:66'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: uint64 (size: 8, offs: <+8>, cast: u64)
.value: bool(x > (0)) ? 1 : 0
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:71'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:15: referenced as `sign`
	cmplStd/test/std/test.math.ci:14: referenced as `sign`
	cmplStd/test/std/test.math.ci:13: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:74'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:12: referenced as `sign`
	cmplStd/test/std/test.math.ci:11: referenced as `sign`
	cmplStd/test/std/test.math.ci:10: referenced as `sign`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@061150>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <absMod @061150> - <absMod+27 @06116b>)
	cmplStd/lib/math.ci:78: (23 bytes: <absMod @061150> - <absMod+23 @061167>): if ((val := val % mod) < (0))
	<absMod @061150>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @061152>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @061154>    : 75                         mod.f32
	<absMod+5 @061155>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @061157>    : 13 04                      set.x32 sp(4)
	<absMod+9 @061159>    : 19                         load.z32
	<absMod+10 @06115a>   : 78                         clt.f32
	<absMod+11 @06115b>   : 06 0c 00 00                jz <absMod+23 @061167>
	cmplStd/lib/math.ci:79: (8 bytes: <absMod+15 @06115f> - <absMod+23 @061167>): return .result := val + mod;
	<absMod+15 @06115f>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @061161>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @061163>   : 71                         add.f32
	<absMod+20 @061164>   : 13 04                      set.x32 sp(4)
	<absMod+22 @061166>   : 03                         ret
	cmplStd/lib/math.ci:81: (4 bytes: <absMod+23 @061167> - <absMod+27 @06116b>): return .result := val;
	<absMod+23 @061167>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @06116a>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `absMod`
	cmplStd/test/std/test.math.ci:95: referenced as `absMod`
	cmplStd/test/std/test.math.ci:94: referenced as `absMod`
	cmplStd/test/std/test.math.ci:93: referenced as `absMod`
	cmplStd/test/std/test.math.ci:91: referenced as `absMod`
	cmplStd/test/std/test.math.ci:90: referenced as `absMod`
	cmplStd/test/std/test.math.ci:89: referenced as `absMod`
	cmplStd/test/std/test.math.ci:88: referenced as `absMod`
	cmplStd/test/std/test.math.ci:86: referenced as `absMod`
	cmplStd/test/std/test.math.ci:85: referenced as `absMod`
	cmplStd/test/std/test.math.ci:84: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@061170>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <absMod @061170> - <absMod+27 @06118b>)
	cmplStd/lib/math.ci:86: (23 bytes: <absMod @061170> - <absMod+23 @061187>): if ((val := val % mod) < (0))
	<absMod @061170>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @061172>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @061174>    : 85                         mod.f64
	<absMod+5 @061175>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @061177>    : 14 07                      set.x64 sp(7)
	<absMod+9 @061179>    : 1a                         load.z64
	<absMod+10 @06117a>   : 88                         clt.f64
	<absMod+11 @06117b>   : 06 0c 00 00                jz <absMod+23 @061187>
	cmplStd/lib/math.ci:87: (8 bytes: <absMod+15 @06117f> - <absMod+23 @061187>): return .result := val + mod;
	<absMod+15 @06117f>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @061181>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @061183>   : 81                         add.f64
	<absMod+20 @061184>   : 14 07                      set.x64 sp(7)
	<absMod+22 @061186>   : 03                         ret
	cmplStd/lib/math.ci:89: (4 bytes: <absMod+23 @061187> - <absMod+27 @06118b>): return .result := val;
	<absMod+23 @061187>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @06118a>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `absMod`
	cmplStd/test/std/test.math.ci:81: referenced as `absMod`
	cmplStd/test/std/test.math.ci:80: referenced as `absMod`
	cmplStd/test/std/test.math.ci:79: referenced as `absMod`
	cmplStd/test/std/test.math.ci:77: referenced as `absMod`
	cmplStd/test/std/test.math.ci:76: referenced as `absMod`
	cmplStd/test/std/test.math.ci:75: referenced as `absMod`
	cmplStd/test/std/test.math.ci:74: referenced as `absMod`
	cmplStd/test/std/test.math.ci:72: referenced as `absMod`
	cmplStd/test/std/test.math.ci:71: referenced as `absMod`
	cmplStd/test/std/test.math.ci:70: referenced as `absMod`
}
Math.abs(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:93'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'Returns the absolute value of the input'
.value: bool(x < 0) ? int32(-x) : x
.usages:
}
Math.abs(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:96'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param x: int64 (size: 8, offs: <+8>, cast: variable(i64))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? int64(-x) : x
.usages:
}
Math.abs(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:99'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param x: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:102'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param x: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:105'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? float32(-x) : x
.usages:
	cmplStd/test/std/test.math.ci:22: referenced as `abs`
	cmplStd/test/std/test.math.ci:21: referenced as `abs`
	cmplStd/test/std/test.math.ci:20: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:108'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? float64(-x) : x
.usages:
	cmplStd/test/std/test.math.ci:19: referenced as `abs`
	cmplStd/test/std/test.math.ci:18: referenced as `abs`
	cmplStd/test/std/test.math.ci:17: referenced as `abs`
	cmplStd/lib/string.ci:249: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math.ci:336: referenced as `abs`
}
Math.min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:111'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:114'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param a: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+16>, cast: variable(i64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:117'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param a: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:120'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:123'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:24: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:126'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:26: referenced as `min`
}
Math.max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:129'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:132'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param a: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+16>, cast: variable(i64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:135'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param a: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:138'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:141'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:25: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:144'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:27: referenced as `max`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@061190>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:147'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <clamp @061190> - <clamp+30 @0611ae>)
	cmplStd/lib/math.ci:148: (13 bytes: <clamp @061190> - <clamp+13 @06119d>): if (t < a)
	<clamp @061190>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @061192>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @061194>    : 78                         clt.f32
	<clamp+5 @061195>    : 06 08 00 00                jz <clamp+13 @06119d>
	cmplStd/lib/math.ci:149: (4 bytes: <clamp+9 @061199> - <clamp+13 @06119d>): return .result := a;
	<clamp+9 @061199>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @06119c>   : 03                         ret
	cmplStd/lib/math.ci:151: (13 bytes: <clamp+13 @06119d> - <clamp+26 @0611aa>): if (t > b)
	<clamp+13 @06119d>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @06119f>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @0611a1>   : 79                         cgt.f32
	<clamp+18 @0611a2>   : 06 08 00 00                jz <clamp+26 @0611aa>
	cmplStd/lib/math.ci:152: (4 bytes: <clamp+22 @0611a6> - <clamp+26 @0611aa>): return .result := b;
	<clamp+22 @0611a6>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @0611a9>   : 03                         ret
	cmplStd/lib/math.ci:154: (4 bytes: <clamp+26 @0611aa> - <clamp+30 @0611ae>): return .result := t;
	<clamp+26 @0611aa>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @0611ad>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:29: referenced as `clamp`
	cmplStd/lib/math.ci:183: referenced as `clamp`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@0611b0>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:158'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <clamp @0611b0> - <clamp+30 @0611ce>)
	cmplStd/lib/math.ci:159: (13 bytes: <clamp @0611b0> - <clamp+13 @0611bd>): if (t < a)
	<clamp @0611b0>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @0611b2>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @0611b4>    : 88                         clt.f64
	<clamp+5 @0611b5>    : 06 08 00 00                jz <clamp+13 @0611bd>
	cmplStd/lib/math.ci:160: (4 bytes: <clamp+9 @0611b9> - <clamp+13 @0611bd>): return .result := a;
	<clamp+9 @0611b9>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @0611bc>   : 03                         ret
	cmplStd/lib/math.ci:162: (13 bytes: <clamp+13 @0611bd> - <clamp+26 @0611ca>): if (t > b)
	<clamp+13 @0611bd>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @0611bf>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @0611c1>   : 89                         cgt.f64
	<clamp+18 @0611c2>   : 06 08 00 00                jz <clamp+26 @0611ca>
	cmplStd/lib/math.ci:163: (4 bytes: <clamp+22 @0611c6> - <clamp+26 @0611ca>): return .result := b;
	<clamp+22 @0611c6>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @0611c9>   : 03                         ret
	cmplStd/lib/math.ci:165: (4 bytes: <clamp+26 @0611ca> - <clamp+30 @0611ce>): return .result := t;
	<clamp+26 @0611ca>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @0611cd>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:30: referenced as `clamp`
	cmplStd/lib/math.ci:186: referenced as `clamp`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:174'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:32: referenced as `lerp`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:177'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:33: referenced as `lerp`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:179'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	cmplStd/lib/math.ci:183: referenced as `smooth`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:180'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	cmplStd/lib/math.ci:186: referenced as `smooth`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:183'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	cmplStd/test/std/test.math.ci:35: referenced as `smooth`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:186'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	cmplStd/test/std/test.math.ci:36: referenced as `smooth`
}
Math.min(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@0611d0>
.name: 'min'
.file: 'cmplStd/lib/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <min @0611d0> - <min+79 @06121f>)
	cmplStd/lib/math.ci:190: (20 bytes: <min @0611d0> - <min+20 @0611e4>): if (data.length == (0))
	<min @0611d0>      : 10 02                      dup.x32 sp(2)
	<min+2 @0611d2>    : 19                         load.z32
	<min+3 @0611d3>    : 57                         ceq.i32
	<min+4 @0611d4>    : 06 10 00 00                jz <min+20 @0611e4>
	cmplStd/lib/math.ci:191: (12 bytes: <min+8 @0611d8> - <min+20 @0611e4>): return .result := nan;
	<min+8 @0611d8>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @0611e1>   : 14 05                      set.x64 sp(5)
	<min+19 @0611e3>   : 03                         ret
	cmplStd/lib/math.ci:193: (3 bytes: <min+20 @0611e4> - <min+23 @0611e7>): result: float64 := data[0]
	<min+20 @0611e4>   : 10 01                      dup.x32 sp(1)
	<min+22 @0611e6>   : 29                         load.i64
	cmplStd/lib/math.ci:194: (53 bytes: <min+23 @0611e7> - <min+76 @06121c>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+23 @0611e7>   : 1c 01 00 00 00             load.c32 1
	<min+28 @0611ec>   : 04 23 00 00                jmp <min+63 @06120f>
	cmplStd/lib/math.ci:195: (27 bytes: <min+32 @0611f0> - <min+59 @06120b>): if (result > data[i])
	<min+32 @0611f0>   : 11 01                      dup.x64 sp(1)
	<min+34 @0611f2>   : 10 06                      dup.x32 sp(6)
	<min+36 @0611f4>   : 10 03                      dup.x32 sp(3)
	<min+38 @0611f6>   : 0d 08 00 00                mad.u32 8
	<min+42 @0611fa>   : 29                         load.i64
	<min+43 @0611fb>   : 89                         cgt.f64
	<min+44 @0611fc>   : 06 0f 00 00                jz <min+59 @06120b>
	cmplStd/lib/math.ci:196: (11 bytes: <min+48 @061200> - <min+59 @06120b>): result := data[i];
	<min+48 @061200>   : 10 04                      dup.x32 sp(4)
	<min+50 @061202>   : 10 01                      dup.x32 sp(1)
	<min+52 @061204>   : 0d 08 00 00                mad.u32 8
	<min+56 @061208>   : 29                         load.i64
	<min+57 @061209>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:194: (4 bytes: <min+59 @06120b> - <min+63 @06120f>): i := i + 1
	<min+59 @06120b>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:194: (9 bytes: <min+63 @06120f> - <min+72 @061218>): i < (data.length)
	<min+63 @06120f>   : 10 00                      dup.x32 sp(0)
	<min+65 @061211>   : 10 06                      dup.x32 sp(6)
	<min+67 @061213>   : 58                         clt.i32
	<min+68 @061214>   : 05 dc ff ff                jnz <min+32 @0611f0>
	<min+72 @061218>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:199: (3 bytes: <min+76 @06121c> - <min+79 @06121f>): return .result := result;
	<min+76 @06121c>   : 14 05                      set.x64 sp(5)
	<min+78 @06121e>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:39: referenced as `min`
	cmplStd/test/std/test.math.ci:38: referenced as `min`
}
Math.max(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@061220>
.name: 'max'
.file: 'cmplStd/lib/math.ci:203'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <max @061220> - <max+79 @06126f>)
	cmplStd/lib/math.ci:204: (20 bytes: <max @061220> - <max+20 @061234>): if (data.length == (0))
	<max @061220>      : 10 02                      dup.x32 sp(2)
	<max+2 @061222>    : 19                         load.z32
	<max+3 @061223>    : 57                         ceq.i32
	<max+4 @061224>    : 06 10 00 00                jz <max+20 @061234>
	cmplStd/lib/math.ci:205: (12 bytes: <max+8 @061228> - <max+20 @061234>): return .result := nan;
	<max+8 @061228>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @061231>   : 14 05                      set.x64 sp(5)
	<max+19 @061233>   : 03                         ret
	cmplStd/lib/math.ci:207: (3 bytes: <max+20 @061234> - <max+23 @061237>): result: float64 := data[0]
	<max+20 @061234>   : 10 01                      dup.x32 sp(1)
	<max+22 @061236>   : 29                         load.i64
	cmplStd/lib/math.ci:208: (53 bytes: <max+23 @061237> - <max+76 @06126c>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+23 @061237>   : 1c 01 00 00 00             load.c32 1
	<max+28 @06123c>   : 04 23 00 00                jmp <max+63 @06125f>
	cmplStd/lib/math.ci:209: (27 bytes: <max+32 @061240> - <max+59 @06125b>): if (result < data[i])
	<max+32 @061240>   : 11 01                      dup.x64 sp(1)
	<max+34 @061242>   : 10 06                      dup.x32 sp(6)
	<max+36 @061244>   : 10 03                      dup.x32 sp(3)
	<max+38 @061246>   : 0d 08 00 00                mad.u32 8
	<max+42 @06124a>   : 29                         load.i64
	<max+43 @06124b>   : 88                         clt.f64
	<max+44 @06124c>   : 06 0f 00 00                jz <max+59 @06125b>
	cmplStd/lib/math.ci:210: (11 bytes: <max+48 @061250> - <max+59 @06125b>): result := data[i];
	<max+48 @061250>   : 10 04                      dup.x32 sp(4)
	<max+50 @061252>   : 10 01                      dup.x32 sp(1)
	<max+52 @061254>   : 0d 08 00 00                mad.u32 8
	<max+56 @061258>   : 29                         load.i64
	<max+57 @061259>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:208: (4 bytes: <max+59 @06125b> - <max+63 @06125f>): i := i + 1
	<max+59 @06125b>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:208: (9 bytes: <max+63 @06125f> - <max+72 @061268>): i < (data.length)
	<max+63 @06125f>   : 10 00                      dup.x32 sp(0)
	<max+65 @061261>   : 10 06                      dup.x32 sp(6)
	<max+67 @061263>   : 58                         clt.i32
	<max+68 @061264>   : 05 dc ff ff                jnz <max+32 @061240>
	<max+72 @061268>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:213: (3 bytes: <max+76 @06126c> - <max+79 @06126f>): return .result := result;
	<max+76 @06126c>   : 14 05                      set.x64 sp(5)
	<max+78 @06126e>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:41: referenced as `max`
	cmplStd/test/std/test.math.ci:40: referenced as `max`
}
Math.sum(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.offset: <@061270>
.name: 'sum'
.file: 'cmplStd/lib/math.ci:217'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <sum @061270> - <sum+40 @061298>)
	cmplStd/lib/math.ci:218: (1 byte: <sum @061270> - <sum+1 @061271>): result: float64 := 0
	<sum @061270>      : 1b                         load.z128
	cmplStd/lib/math.ci:219: (36 bytes: <sum+1 @061271> - <sum+37 @061295>): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+1 @061271>    : 6a                         i64.2i32
	<sum+2 @061272>    : 04 16 00 00                jmp <sum+24 @061288>
	cmplStd/lib/math.ci:220: (14 bytes: <sum+6 @061276> - <sum+20 @061284>): result := result + data[i];
	<sum+6 @061276>    : 11 01                      dup.x64 sp(1)
	<sum+8 @061278>    : 10 06                      dup.x32 sp(6)
	<sum+10 @06127a>   : 10 03                      dup.x32 sp(3)
	<sum+12 @06127c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @061280>   : 29                         load.i64
	<sum+17 @061281>   : 81                         add.f64
	<sum+18 @061282>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:219: (4 bytes: <sum+20 @061284> - <sum+24 @061288>): i := i + 1
	<sum+20 @061284>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:219: (9 bytes: <sum+24 @061288> - <sum+33 @061291>): i < (data.length)
	<sum+24 @061288>   : 10 00                      dup.x32 sp(0)
	<sum+26 @06128a>   : 10 06                      dup.x32 sp(6)
	<sum+28 @06128c>   : 58                         clt.i32
	<sum+29 @06128d>   : 05 e9 ff ff                jnz <sum+6 @061276>
	<sum+33 @061291>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:222: (3 bytes: <sum+37 @061295> - <sum+40 @061298>): return .result := result;
	<sum+37 @061295>   : 14 05                      set.x64 sp(5)
	<sum+39 @061297>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:46: referenced as `sum`
	cmplStd/test/std/test.math.ci:45: referenced as `sum`
	cmplStd/test/std/test.math.ci:44: referenced as `sum`
	cmplStd/test/std/test.math.ci:43: referenced as `sum`
	cmplStd/lib/math.ci:227: referenced as `sum`
}
Math.mean(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.offset: <@061298>
.name: 'mean'
.file: 'cmplStd/lib/math.ci:226'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
}
.instructions: (20 bytes: <mean @061298> - <mean+20 @0612ac>)
	cmplStd/lib/math.ci:227: (20 bytes: <mean @061298> - <mean+20 @0612ac>): return .result := sum(...data) / (signed(data.length));
	<mean @061298>      : 1a                         load.z64
	<mean+1 @061299>    : 11 03                      dup.x64 sp(3)
	<mean+3 @06129b>    : 1f 70 12 06 00             load.ref <@061270> ;Math.sum(data: float64[]): float64
	<mean+8 @0612a0>    : 02                         call
	<mean+9 @0612a1>    : 09 f8 ff ff                inc.sp(-8)
	<mean+13 @0612a5>   : 10 04                      dup.x32 sp(4)
	<mean+15 @0612a7>   : 5d                         i32.2f64
	<mean+16 @0612a8>   : 84                         div.f64
	<mean+17 @0612a9>   : 14 05                      set.x64 sp(5)
	<mean+19 @0612ab>   : 03                         ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:231'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	cmplStd/test/std/test.math.ci:50: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:234'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	cmplStd/test/std/test.math.ci:51: referenced as `eval`
	cmplStd/lib/math.ci:237: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:237'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	cmplStd/test/std/test.math.ci:52: referenced as `eval`
	cmplStd/lib/math.ci:240: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:240'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	cmplStd/test/std/test.math.ci:53: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.offset: <@0612b0>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <eval @0612b0> - <eval+47 @0612df>)
	cmplStd/lib/math.ci:244: (1 byte: <eval @0612b0> - <eval+1 @0612b1>): result: float64 := 0
	<eval @0612b0>      : 1a                         load.z64
	cmplStd/lib/math.ci:245: (43 bytes: <eval+1 @0612b1> - <eval+44 @0612dc>): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+1 @0612b1>    : 10 04                      dup.x32 sp(4)
	<eval+3 @0612b3>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @0612b7>    : 04 19 00 00                jmp <eval+32 @0612d0>
	cmplStd/lib/math.ci:246: (17 bytes: <eval+11 @0612bb> - <eval+28 @0612cc>): result := result * x + polynomial[i];
	<eval+11 @0612bb>   : 11 01                      dup.x64 sp(1)
	<eval+13 @0612bd>   : 11 08                      dup.x64 sp(8)
	<eval+15 @0612bf>   : 83                         mul.f64
	<eval+16 @0612c0>   : 10 06                      dup.x32 sp(6)
	<eval+18 @0612c2>   : 10 03                      dup.x32 sp(3)
	<eval+20 @0612c4>   : 0d 08 00 00                mad.u32 8
	<eval+24 @0612c8>   : 29                         load.i64
	<eval+25 @0612c9>   : 81                         add.f64
	<eval+26 @0612ca>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:245: (4 bytes: <eval+28 @0612cc> - <eval+32 @0612d0>): i := i - 1
	<eval+28 @0612cc>   : 0c ff ff ff                inc.i32(-1)
	cmplStd/lib/math.ci:245: (8 bytes: <eval+32 @0612d0> - <eval+40 @0612d8>): i >= 0
	<eval+32 @0612d0>   : 10 00                      dup.x32 sp(0)
	<eval+34 @0612d2>   : 19                         load.z32
	<eval+35 @0612d3>   : 58                         clt.i32
	<eval+36 @0612d4>   : 06 e7 ff ff                jz <eval+11 @0612bb>
	<eval+40 @0612d8>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:248: (3 bytes: <eval+44 @0612dc> - <eval+47 @0612df>): return .result := result;
	<eval+44 @0612dc>   : 14 07                      set.x64 sp(7)
	<eval+46 @0612de>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `eval`
	cmplStd/test/std/test.math.ci:54: referenced as `eval`
	cmplStd/test/std/test.math.ci:49: referenced as `eval`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@0612e0>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:252'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float32(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @0612e0> - <cmp+57 @061319>)
	cmplStd/lib/math.ci:253: (53 bytes: <cmp @0612e0> - <cmp+53 @061315>): if (a < b)
	<cmp @0612e0>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @0612e2>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @0612e4>    : 78                         clt.f32
	<cmp+5 @0612e5>    : 06 1c 00 00                jz <cmp+33 @061301>
	cmplStd/lib/math.ci:254: (20 bytes: <cmp+9 @0612e9> - <cmp+29 @0612fd>): if (eps < (b - a))
	<cmp+9 @0612e9>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @0612eb>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @0612ed>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @0612ef>   : 72                         sub.f32
	<cmp+16 @0612f0>   : 78                         clt.f32
	<cmp+17 @0612f1>   : 06 0c 00 00                jz <cmp+29 @0612fd>
	cmplStd/lib/math.ci:255: (8 bytes: <cmp+21 @0612f5> - <cmp+29 @0612fd>): return .result := -1;
	<cmp+21 @0612f5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @0612fa>   : 13 05                      set.x32 sp(5)
	<cmp+28 @0612fc>   : 03                         ret
	<cmp+29 @0612fd>   : 04 18 00 00                jmp <cmp+53 @061315>
	cmplStd/lib/math.ci:259: (20 bytes: <cmp+33 @061301> - <cmp+53 @061315>): if (eps < (a - b))
	<cmp+33 @061301>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @061303>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @061305>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @061307>   : 72                         sub.f32
	<cmp+40 @061308>   : 78                         clt.f32
	<cmp+41 @061309>   : 06 0c 00 00                jz <cmp+53 @061315>
	cmplStd/lib/math.ci:260: (8 bytes: <cmp+45 @06130d> - <cmp+53 @061315>): return .result := +1;
	<cmp+45 @06130d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @061312>   : 13 05                      set.x32 sp(5)
	<cmp+52 @061314>   : 03                         ret
	cmplStd/lib/math.ci:263: (4 bytes: <cmp+53 @061315> - <cmp+57 @061319>): return .result := 0;
	<cmp+53 @061315>   : 19                         load.z32
	<cmp+54 @061316>   : 13 05                      set.x32 sp(5)
	<cmp+56 @061318>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:67: referenced as `cmp`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@061320>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:267'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float64(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @061320> - <cmp+57 @061359>)
	cmplStd/lib/math.ci:268: (53 bytes: <cmp @061320> - <cmp+53 @061355>): if (a < b)
	<cmp @061320>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @061322>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @061324>    : 88                         clt.f64
	<cmp+5 @061325>    : 06 1c 00 00                jz <cmp+33 @061341>
	cmplStd/lib/math.ci:269: (20 bytes: <cmp+9 @061329> - <cmp+29 @06133d>): if (eps < (b - a))
	<cmp+9 @061329>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @06132b>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @06132d>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @06132f>   : 82                         sub.f64
	<cmp+16 @061330>   : 88                         clt.f64
	<cmp+17 @061331>   : 06 0c 00 00                jz <cmp+29 @06133d>
	cmplStd/lib/math.ci:270: (8 bytes: <cmp+21 @061335> - <cmp+29 @06133d>): return .result := -1;
	<cmp+21 @061335>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @06133a>   : 13 08                      set.x32 sp(8)
	<cmp+28 @06133c>   : 03                         ret
	<cmp+29 @06133d>   : 04 18 00 00                jmp <cmp+53 @061355>
	cmplStd/lib/math.ci:274: (20 bytes: <cmp+33 @061341> - <cmp+53 @061355>): if (eps < (a - b))
	<cmp+33 @061341>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @061343>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @061345>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @061347>   : 82                         sub.f64
	<cmp+40 @061348>   : 88                         clt.f64
	<cmp+41 @061349>   : 06 0c 00 00                jz <cmp+53 @061355>
	cmplStd/lib/math.ci:275: (8 bytes: <cmp+45 @06134d> - <cmp+53 @061355>): return .result := +1;
	<cmp+45 @06134d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @061352>   : 13 08                      set.x32 sp(8)
	<cmp+52 @061354>   : 03                         ret
	cmplStd/lib/math.ci:278: (4 bytes: <cmp+53 @061355> - <cmp+57 @061359>): return .result := 0;
	<cmp+53 @061355>   : 19                         load.z32
	<cmp+54 @061356>   : 13 08                      set.x32 sp(8)
	<cmp+56 @061358>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `cmp`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 335
.offset: <@061360>
.name: 'sinCos'
.file: 'cmplStd/lib/math.ci:282'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <sinCos @061360> - <sinCos+335 @0614af>)
	cmplStd/lib/math.ci:296: (2 bytes: <sinCos @061360> - <sinCos+2 @061362>): x: float64 := arg
	<sinCos @061360>      : 11 02                      dup.x64 sp(2)
	cmplStd/lib/math.ci:297: (17 bytes: <sinCos+2 @061362> - <sinCos+19 @061373>): if (x < (0))
	<sinCos+2 @061362>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @061364>    : 1a                         load.z64
	<sinCos+5 @061365>    : 88                         clt.f64
	<sinCos+6 @061366>    : 06 0d 00 00                jz <sinCos+19 @061373>
	cmplStd/lib/math.ci:298: (1 byte: <sinCos+10 @06136a> - <sinCos+11 @06136b>): x := -x;
	<sinCos+10 @06136a>   : 80                         neg.f64
	cmplStd/lib/math.ci:299: (8 bytes: <sinCos+11 @06136b> - <sinCos+19 @061373>): quad := quad + 2;
	<sinCos+11 @06136b>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @06136d>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @061371>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math.ci:302: (1 byte: <sinCos+19 @061373> - <sinCos+20 @061374>): y: float64
	<sinCos+19 @061373>   : 1a                         load.z64
	cmplStd/lib/math.ci:303: (24 bytes: <sinCos+20 @061374> - <sinCos+44 @06138c>): x := x * (1) / PIO2;
	<sinCos+20 @061374>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @061376>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @06137f>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @061388>   : 84                         div.f64
	<sinCos+41 @061389>   : 83                         mul.f64
	<sinCos+42 @06138a>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:304: (124 bytes: <sinCos+44 @06138c> - <sinCos+168 @061408>): if (x > (32764))
	<sinCos+44 @06138c>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @06138e>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @061397>   : 89                         cgt.f64
	<sinCos+56 @061398>   : 06 54 00 00                jz <sinCos+140 @0613ec>
	cmplStd/lib/math.ci:305: (1 byte: <sinCos+60 @06139c> - <sinCos+61 @06139d>): e: float64
	<sinCos+60 @06139c>   : 1b                         load.z128
	cmplStd/lib/math.ci:306: (18 bytes: <sinCos+61 @06139d> - <sinCos+79 @0613af>): y := modf(x, &e);
	<sinCos+61 @06139d>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @06139f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @0613a3>   : 1f e0 10 06 00             load.ref <@0610e0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @0613a8>   : 02                         call
	<sinCos+73 @0613a9>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @0613ad>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:307: (4 bytes: <sinCos+79 @0613af> - <sinCos+83 @0613b3>): e := e + (quad);
	<sinCos+79 @0613af>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @0613b1>   : 5d                         i32.2f64
	<sinCos+82 @0613b2>   : 81                         add.f64
	cmplStd/lib/math.ci:309: (1 byte: <sinCos+83 @0613b3> - <sinCos+84 @0613b4>): f: float64
	<sinCos+83 @0613b3>   : 1b                         load.z128
	cmplStd/lib/math.ci:310: (30 bytes: <sinCos+84 @0613b4> - <sinCos+114 @0613d2>): modf(0.250000 * e, &f);
	<sinCos+84 @0613b4>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @0613bd>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @0613bf>   : 83                         mul.f64
	<sinCos+96 @0613c0>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @0613c4>  : 1f e0 10 06 00             load.ref <@0610e0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @0613c9>  : 02                         call
	<sinCos+106 @0613ca>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @0613ce>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:311: (18 bytes: <sinCos+114 @0613d2> - <sinCos+132 @0613e4>): quad := (e - (4) * f);
	<sinCos+114 @0613d2>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @0613d4>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @0613dd>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @0613df>  : 83                         mul.f64
	<sinCos+128 @0613e0>  : 82                         sub.f64
	<sinCos+129 @0613e1>  : 8a                         f64.2i32
	<sinCos+130 @0613e2>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @0613e4>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @0613e8>  : 04 20 00 00                jmp <sinCos+168 @061408>
	cmplStd/lib/math.ci:314: (3 bytes: <sinCos+140 @0613ec> - <sinCos+143 @0613ef>): k: int32 := x
	<sinCos+140 @0613ec>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @0613ee>  : 8a                         f64.2i32
	cmplStd/lib/math.ci:315: (8 bytes: <sinCos+143 @0613ef> - <sinCos+151 @0613f7>): y := x - (k);
	<sinCos+143 @0613ef>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @0613f1>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @0613f3>  : 5d                         i32.2f64
	<sinCos+148 @0613f4>  : 82                         sub.f64
	<sinCos+149 @0613f5>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:316: (7 bytes: <sinCos+151 @0613f7> - <sinCos+158 @0613fe>): quad := quad + k;
	<sinCos+151 @0613f7>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @0613f9>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @0613fb>  : 51                         add.i32
	<sinCos+156 @0613fc>  : 13 07                      set.x32 sp(7)
	cmplStd/lib/math.ci:317: (6 bytes: <sinCos+158 @0613fe> - <sinCos+164 @061404>): quad := quad & 3;
	<sinCos+158 @0613fe>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @061400>  : 3f 02                      b32.and 0x003
	<sinCos+162 @061402>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @061404>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:319: (22 bytes: <sinCos+168 @061408> - <sinCos+190 @06141e>): if (quad & 1)
	<sinCos+168 @061408>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @06140a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @06140c>  : 06 12 00 00                jz <sinCos+190 @06141e>
	cmplStd/lib/math.ci:320: (14 bytes: <sinCos+176 @061410> - <sinCos+190 @06141e>): y := (1) - y;
	<sinCos+176 @061410>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @061419>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @06141b>  : 82                         sub.f64
	<sinCos+188 @06141c>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:322: (13 bytes: <sinCos+190 @06141e> - <sinCos+203 @06142b>): if (quad > 1)
	<sinCos+190 @06141e>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @061420>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @061425>  : 59                         cgt.i32
	<sinCos+198 @061426>  : 06 05 00 00                jz <sinCos+203 @06142b>
	cmplStd/lib/math.ci:323: (1 byte: <sinCos+202 @06142a> - <sinCos+203 @06142b>): y := -y;
	<sinCos+202 @06142a>  : 80                         neg.f64
	cmplStd/lib/math.ci:326: (5 bytes: <sinCos+203 @06142b> - <sinCos+208 @061430>): ysq: float64 := y * y
	<sinCos+203 @06142b>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @06142d>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @06142f>  : 83                         mul.f64
	cmplStd/lib/math.ci:327: (64 bytes: <sinCos+208 @061430> - <sinCos+272 @061470>): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+208 @061430>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @061439>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @06143b>  : 83                         mul.f64
	<sinCos+220 @06143c>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @061445>  : 81                         add.f64
	<sinCos+230 @061446>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @061448>  : 83                         mul.f64
	<sinCos+233 @061449>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @061452>  : 81                         add.f64
	<sinCos+243 @061453>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @061455>  : 83                         mul.f64
	<sinCos+246 @061456>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @06145f>  : 81                         add.f64
	<sinCos+256 @061460>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @061462>  : 83                         mul.f64
	<sinCos+259 @061463>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @06146c>  : 81                         add.f64
	<sinCos+269 @06146d>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @06146f>  : 83                         mul.f64
	cmplStd/lib/math.ci:328: (51 bytes: <sinCos+272 @061470> - <sinCos+323 @0614a3>): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+272 @061470>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @061472>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @06147b>  : 81                         add.f64
	<sinCos+284 @06147c>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @06147e>  : 83                         mul.f64
	<sinCos+287 @06147f>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @061488>  : 81                         add.f64
	<sinCos+297 @061489>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @06148b>  : 83                         mul.f64
	<sinCos+300 @06148c>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @061495>  : 81                         add.f64
	<sinCos+310 @061496>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @061498>  : 83                         mul.f64
	<sinCos+313 @061499>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @0614a2>  : 81                         add.f64
	cmplStd/lib/math.ci:329: (12 bytes: <sinCos+323 @0614a3> - <sinCos+335 @0614af>): return .result := temp1 / temp2;
	<sinCos+323 @0614a3>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @0614a5>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @0614a7>  : 84                         div.f64
	<sinCos+328 @0614a8>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @0614aa>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @0614ae>  : 03                         ret
.usages:
	cmplStd/lib/math.ci:336: referenced as `sinCos`
	cmplStd/lib/math.ci:333: referenced as `sinCos`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math.ci:333'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	cmplStd/test/std/test.math.ci:57: referenced as `sin`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math.ci:336'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	cmplStd/test/std/test.math.ci:58: referenced as `cos`
}
Math.tan(arg: float64): float64: function {
.kind: static function
.base: `function`
.size: 378
.offset: <@0614b0>
.name: 'tan'
.file: 'cmplStd/lib/math.ci:339'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else if (bool(i == 1)) {
		float64(x := float64((1) - x));
		bool(complement := true);
	}
	else if (bool(i == 2)) {
		bool(negate := bool(!negate));
		bool(complement := true);
	}
	else if (bool(i == 3)) {
		float64(x := float64((1) - x));
		bool(negate := bool(!negate));
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <tan @0614b0> - <tan+378 @06162a>)
	cmplStd/lib/math.ci:352: (1 byte: <tan @0614b0> - <tan+1 @0614b1>): complement: bool := false
	<tan @0614b0>      : 19                         load.z32
	cmplStd/lib/math.ci:353: (1 byte: <tan+1 @0614b1> - <tan+2 @0614b2>): negate: bool := false
	<tan+1 @0614b1>    : 19                         load.z32
	cmplStd/lib/math.ci:355: (23 bytes: <tan+2 @0614b2> - <tan+25 @0614c9>): if (arg < (0))
	<tan+2 @0614b2>    : 11 03                      dup.x64 sp(3)
	<tan+4 @0614b4>    : 1a                         load.z64
	<tan+5 @0614b5>    : 88                         clt.f64
	<tan+6 @0614b6>    : 06 13 00 00                jz <tan+25 @0614c9>
	cmplStd/lib/math.ci:356: (5 bytes: <tan+10 @0614ba> - <tan+15 @0614bf>): arg := -arg;
	<tan+10 @0614ba>   : 11 03                      dup.x64 sp(3)
	<tan+12 @0614bc>   : 80                         neg.f64
	<tan+13 @0614bd>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:357: (10 bytes: <tan+15 @0614bf> - <tan+25 @0614c9>): negate := true;
	<tan+15 @0614bf>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @0614c4>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @0614c8>   : 2b                         store.i8
	cmplStd/lib/math.ci:359: (24 bytes: <tan+25 @0614c9> - <tan+49 @0614e1>): arg := (2) * arg / PIO2;
	<tan+25 @0614c9>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @0614d2>   : 11 05                      dup.x64 sp(5)
	<tan+36 @0614d4>   : 83                         mul.f64
	<tan+37 @0614d5>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @0614de>   : 84                         div.f64
	<tan+47 @0614df>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:361: (1 byte: <tan+49 @0614e1> - <tan+50 @0614e2>): e: float64
	<tan+49 @0614e1>   : 1b                         load.z128
	cmplStd/lib/math.ci:362: (16 bytes: <tan+50 @0614e2> - <tan+66 @0614f2>): x: float64 := modf(arg, &e)
	<tan+50 @0614e2>   : 11 07                      dup.x64 sp(7)
	<tan+52 @0614e4>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @0614e8>   : 1f e0 10 06 00             load.ref <@0610e0> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @0614ed>   : 02                         call
	<tan+62 @0614ee>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math.ci:363: (9 bytes: <tan+66 @0614f2> - <tan+75 @0614fb>): i: int32 := int32(e) % 4
	<tan+66 @0614f2>   : 11 02                      dup.x64 sp(2)
	<tan+68 @0614f4>   : 8a                         f64.2i32
	<tan+69 @0614f5>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @0614fa>   : 55                         mod.i32
	cmplStd/lib/math.ci:365: (122 bytes: <tan+75 @0614fb> - <tan+197 @061575>): if (i == 0)
	<tan+75 @0614fb>   : 10 00                      dup.x32 sp(0)
	<tan+77 @0614fd>   : 19                         load.z32
	<tan+78 @0614fe>   : 57                         ceq.i32
	<tan+79 @0614ff>   : 05 76 00 00                jnz <tan+197 @061575>
	cmplStd/lib/math.ci:366: (114 bytes: <tan+83 @061503> - <tan+197 @061575>): if (i == 1)
	<tan+83 @061503>   : 10 00                      dup.x32 sp(0)
	<tan+85 @061505>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @06150a>   : 57                         ceq.i32
	<tan+91 @06150b>   : 06 20 00 00                jz <tan+123 @06152b>
	cmplStd/lib/math.ci:367: (14 bytes: <tan+95 @06150f> - <tan+109 @06151d>): x := (1) - x;
	<tan+95 @06150f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @061518>  : 11 03                      dup.x64 sp(3)
	<tan+106 @06151a>  : 82                         sub.f64
	<tan+107 @06151b>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:368: (10 bytes: <tan+109 @06151d> - <tan+119 @061527>): complement := true;
	<tan+109 @06151d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @061522>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @061526>  : 2b                         store.i8
	<tan+119 @061527>  : 04 4e 00 00                jmp <tan+197 @061575>
	cmplStd/lib/math.ci:370: (74 bytes: <tan+123 @06152b> - <tan+197 @061575>): if (i == 2)
	<tan+123 @06152b>  : 10 00                      dup.x32 sp(0)
	<tan+125 @06152d>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @061532>  : 57                         ceq.i32
	<tan+131 @061533>  : 06 1d 00 00                jz <tan+160 @061550>
	cmplStd/lib/math.ci:371: (11 bytes: <tan+135 @061537> - <tan+146 @061542>): negate := !negate;
	<tan+135 @061537>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @06153b>  : 26                         load.i8
	<tan+140 @06153c>  : 0b                         not.b32
	<tan+141 @06153d>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @061541>  : 2b                         store.i8
	cmplStd/lib/math.ci:372: (10 bytes: <tan+146 @061542> - <tan+156 @06154c>): complement := true;
	<tan+146 @061542>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @061547>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @06154b>  : 2b                         store.i8
	<tan+156 @06154c>  : 04 29 00 00                jmp <tan+197 @061575>
	cmplStd/lib/math.ci:374: (37 bytes: <tan+160 @061550> - <tan+197 @061575>): if (i == 3)
	<tan+160 @061550>  : 10 00                      dup.x32 sp(0)
	<tan+162 @061552>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @061557>  : 57                         ceq.i32
	<tan+168 @061558>  : 06 1d 00 00                jz <tan+197 @061575>
	cmplStd/lib/math.ci:375: (14 bytes: <tan+172 @06155c> - <tan+186 @06156a>): x := (1) - x;
	<tan+172 @06155c>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @061565>  : 11 03                      dup.x64 sp(3)
	<tan+183 @061567>  : 82                         sub.f64
	<tan+184 @061568>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:376: (11 bytes: <tan+186 @06156a> - <tan+197 @061575>): negate := !negate;
	<tan+186 @06156a>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @06156e>  : 26                         load.i8
	<tan+191 @06156f>  : 0b                         not.b32
	<tan+192 @061570>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @061574>  : 2b                         store.i8
	cmplStd/lib/math.ci:379: (5 bytes: <tan+197 @061575> - <tan+202 @06157a>): xsq: float64 := x * x
	<tan+197 @061575>  : 11 01                      dup.x64 sp(1)
	<tan+199 @061577>  : 11 03                      dup.x64 sp(3)
	<tan+201 @061579>  : 83                         mul.f64
	cmplStd/lib/math.ci:380: (64 bytes: <tan+202 @06157a> - <tan+266 @0615ba>): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+202 @06157a>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @061583>  : 11 02                      dup.x64 sp(2)
	<tan+213 @061585>  : 83                         mul.f64
	<tan+214 @061586>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @06158f>  : 81                         add.f64
	<tan+224 @061590>  : 11 02                      dup.x64 sp(2)
	<tan+226 @061592>  : 83                         mul.f64
	<tan+227 @061593>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @06159c>  : 81                         add.f64
	<tan+237 @06159d>  : 11 02                      dup.x64 sp(2)
	<tan+239 @06159f>  : 83                         mul.f64
	<tan+240 @0615a0>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @0615a9>  : 81                         add.f64
	<tan+250 @0615aa>  : 11 02                      dup.x64 sp(2)
	<tan+252 @0615ac>  : 83                         mul.f64
	<tan+253 @0615ad>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @0615b6>  : 81                         add.f64
	<tan+263 @0615b7>  : 11 05                      dup.x64 sp(5)
	<tan+265 @0615b9>  : 83                         mul.f64
	cmplStd/lib/math.ci:381: (39 bytes: <tan+266 @0615ba> - <tan+305 @0615e1>): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+266 @0615ba>  : 11 02                      dup.x64 sp(2)
	<tan+268 @0615bc>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @0615c5>  : 81                         add.f64
	<tan+278 @0615c6>  : 11 04                      dup.x64 sp(4)
	<tan+280 @0615c8>  : 83                         mul.f64
	<tan+281 @0615c9>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @0615d2>  : 81                         add.f64
	<tan+291 @0615d3>  : 11 04                      dup.x64 sp(4)
	<tan+293 @0615d5>  : 83                         mul.f64
	<tan+294 @0615d6>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @0615df>  : 81                         add.f64
	<tan+304 @0615e0>  : 84                         div.f64
	cmplStd/lib/math.ci:383: (47 bytes: <tan+305 @0615e1> - <tan+352 @061610>): if (complement)
	<tan+305 @0615e1>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @0615e5>  : 26                         load.i8
	<tan+310 @0615e6>  : 06 2a 00 00                jz <tan+352 @061610>
	cmplStd/lib/math.ci:384: (24 bytes: <tan+314 @0615ea> - <tan+338 @061602>): if (result == (0))
	<tan+314 @0615ea>  : 11 00                      dup.x64 sp(0)
	<tan+316 @0615ec>  : 1a                         load.z64
	<tan+317 @0615ed>  : 87                         ceq.f64
	<tan+318 @0615ee>  : 06 14 00 00                jz <tan+338 @061602>
	cmplStd/lib/math.ci:385: (16 bytes: <tan+322 @0615f2> - <tan+338 @061602>): return .result := nan;
	<tan+322 @0615f2>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @0615fb>  : 14 10                      set.x64 sp(16)
	<tan+333 @0615fd>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @061601>  : 03                         ret
	cmplStd/lib/math.ci:387: (14 bytes: <tan+338 @061602> - <tan+352 @061610>): result := (1) / result;
	<tan+338 @061602>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @06160b>  : 11 02                      dup.x64 sp(2)
	<tan+349 @06160d>  : 84                         div.f64
	<tan+350 @06160e>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:389: (19 bytes: <tan+352 @061610> - <tan+371 @061623>): if (negate)
	<tan+352 @061610>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @061614>  : 26                         load.i8
	<tan+357 @061615>  : 06 0e 00 00                jz <tan+371 @061623>
	cmplStd/lib/math.ci:390: (10 bytes: <tan+361 @061619> - <tan+371 @061623>): return .result := -result;
	<tan+361 @061619>  : 11 00                      dup.x64 sp(0)
	<tan+363 @06161b>  : 80                         neg.f64
	<tan+364 @06161c>  : 14 10                      set.x64 sp(16)
	<tan+366 @06161e>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @061622>  : 03                         ret
	cmplStd/lib/math.ci:392: (7 bytes: <tan+371 @061623> - <tan+378 @06162a>): return .result := result;
	<tan+371 @061623>  : 14 0e                      set.x64 sp(14)
	<tan+373 @061625>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @061629>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:59: referenced as `tan`
}
Math.sinh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 241
.offset: <@061630>
.name: 'sinh'
.file: 'cmplStd/lib/math.ci:396'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <sinh @061630> - <sinh+241 @061721>)
	cmplStd/lib/math.ci:408: (1 byte: <sinh @061630> - <sinh+1 @061631>): negate: bool := false
	<sinh @061630>      : 19                         load.z32
	cmplStd/lib/math.ci:409: (23 bytes: <sinh+1 @061631> - <sinh+24 @061648>): if (x < (0))
	<sinh+1 @061631>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @061633>    : 1a                         load.z64
	<sinh+4 @061634>    : 88                         clt.f64
	<sinh+5 @061635>    : 06 13 00 00                jz <sinh+24 @061648>
	cmplStd/lib/math.ci:410: (5 bytes: <sinh+9 @061639> - <sinh+14 @06163e>): x := -x;
	<sinh+9 @061639>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @06163b>   : 80                         neg.f64
	<sinh+12 @06163c>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:411: (10 bytes: <sinh+14 @06163e> - <sinh+24 @061648>): negate := true;
	<sinh+14 @06163e>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @061643>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @061647>   : 2b                         store.i8
	cmplStd/lib/math.ci:414: (39 bytes: <sinh+24 @061648> - <sinh+63 @06166f>): if (x > (21))
	<sinh+24 @061648>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @06164a>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @061653>   : 89                         cgt.f64
	<sinh+36 @061654>   : 06 1b 00 00                jz <sinh+63 @06166f>
	cmplStd/lib/math.ci:415: (23 bytes: <sinh+40 @061658> - <sinh+63 @06166f>): return .result := float64.exp(x) / (2);
	<sinh+40 @061658>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @06165a>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+46 @06165e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @061667>   : 84                         div.f64
	<sinh+56 @061668>   : 14 06                      set.x64 sp(6)
	<sinh+58 @06166a>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @06166e>   : 03                         ret
	cmplStd/lib/math.ci:418: (1 byte: <sinh+63 @06166f> - <sinh+64 @061670>): result: float64
	<sinh+63 @06166f>   : 1a                         load.z64
	cmplStd/lib/math.ci:419: (151 bytes: <sinh+64 @061670> - <sinh+215 @061707>): if (x > 0.500000)
	<sinh+64 @061670>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @061672>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @06167b>   : 89                         cgt.f64
	<sinh+76 @06167c>   : 06 22 00 00                jz <sinh+110 @06169e>
	cmplStd/lib/math.ci:420: (26 bytes: <sinh+80 @061680> - <sinh+106 @06169a>): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+80 @061680>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @061682>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+86 @061686>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @061688>   : 80                         neg.f64
	<sinh+89 @061689>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+93 @06168d>   : 82                         sub.f64
	<sinh+94 @06168e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @061697>  : 84                         div.f64
	<sinh+104 @061698>  : 14 02                      set.x64 sp(2)
	<sinh+106 @06169a>  : 04 6d 00 00                jmp <sinh+215 @061707>
	cmplStd/lib/math.ci:423: (5 bytes: <sinh+110 @06169e> - <sinh+115 @0616a3>): sq: float64 := x * x
	<sinh+110 @06169e>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @0616a0>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @0616a2>  : 83                         mul.f64
	cmplStd/lib/math.ci:424: (53 bytes: <sinh+115 @0616a3> - <sinh+168 @0616d8>): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+115 @0616a3>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @0616ac>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @0616ae>  : 83                         mul.f64
	<sinh+127 @0616af>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @0616b8>  : 81                         add.f64
	<sinh+137 @0616b9>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @0616bb>  : 83                         mul.f64
	<sinh+140 @0616bc>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @0616c5>  : 81                         add.f64
	<sinh+150 @0616c6>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @0616c8>  : 83                         mul.f64
	<sinh+153 @0616c9>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @0616d2>  : 81                         add.f64
	<sinh+163 @0616d3>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @0616d5>  : 83                         mul.f64
	<sinh+166 @0616d6>  : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:425: (43 bytes: <sinh+168 @0616d8> - <sinh+211 @061703>): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+168 @0616d8>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @0616da>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @0616dc>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @0616e5>  : 81                         add.f64
	<sinh+182 @0616e6>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @0616e8>  : 83                         mul.f64
	<sinh+185 @0616e9>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @0616f2>  : 81                         add.f64
	<sinh+195 @0616f3>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @0616f5>  : 83                         mul.f64
	<sinh+198 @0616f6>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @0616ff>  : 81                         add.f64
	<sinh+208 @061700>  : 84                         div.f64
	<sinh+209 @061701>  : 14 04                      set.x64 sp(4)
	<sinh+211 @061703>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:428: (19 bytes: <sinh+215 @061707> - <sinh+234 @06171a>): if (negate)
	<sinh+215 @061707>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @06170b>  : 26                         load.i8
	<sinh+220 @06170c>  : 06 0e 00 00                jz <sinh+234 @06171a>
	cmplStd/lib/math.ci:429: (10 bytes: <sinh+224 @061710> - <sinh+234 @06171a>): return .result := -result;
	<sinh+224 @061710>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @061712>  : 80                         neg.f64
	<sinh+227 @061713>  : 14 08                      set.x64 sp(8)
	<sinh+229 @061715>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @061719>  : 03                         ret
	cmplStd/lib/math.ci:431: (7 bytes: <sinh+234 @06171a> - <sinh+241 @061721>): return .result := result;
	<sinh+234 @06171a>  : 14 06                      set.x64 sp(6)
	<sinh+236 @06171c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @061720>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:60: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:151: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:149: referenced as `sinh`
}
Math.cosh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 75
.offset: <@061728>
.name: 'cosh'
.file: 'cmplStd/lib/math.ci:435'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <cosh @061728> - <cosh+75 @061773>)
	cmplStd/lib/math.ci:436: (13 bytes: <cosh @061728> - <cosh+13 @061735>): if (x < (0))
	<cosh @061728>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @06172a>    : 1a                         load.z64
	<cosh+3 @06172b>    : 88                         clt.f64
	<cosh+4 @06172c>    : 06 09 00 00                jz <cosh+13 @061735>
	cmplStd/lib/math.ci:437: (5 bytes: <cosh+8 @061730> - <cosh+13 @061735>): x := -x;
	<cosh+8 @061730>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @061732>   : 80                         neg.f64
	<cosh+11 @061733>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:439: (35 bytes: <cosh+13 @061735> - <cosh+48 @061758>): if (x > (21))
	<cosh+13 @061735>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @061737>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @061740>   : 89                         cgt.f64
	<cosh+25 @061741>   : 06 17 00 00                jz <cosh+48 @061758>
	cmplStd/lib/math.ci:440: (19 bytes: <cosh+29 @061745> - <cosh+48 @061758>): return .result := float64.exp(x) / (2);
	<cosh+29 @061745>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @061747>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+35 @06174b>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @061754>   : 84                         div.f64
	<cosh+45 @061755>   : 14 05                      set.x64 sp(5)
	<cosh+47 @061757>   : 03                         ret
	cmplStd/lib/math.ci:442: (27 bytes: <cosh+48 @061758> - <cosh+75 @061773>): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+48 @061758>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @06175a>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+54 @06175e>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @061760>   : 80                         neg.f64
	<cosh+57 @061761>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+61 @061765>   : 81                         add.f64
	<cosh+62 @061766>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @06176f>   : 84                         div.f64
	<cosh+72 @061770>   : 14 05                      set.x64 sp(5)
	<cosh+74 @061772>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:151: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:149: referenced as `cosh`
}
Math.asin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 173
.offset: <@061778>
.name: 'asin'
.file: 'cmplStd/lib/math.ci:450'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <asin @061778> - <asin+173 @061825>)
	cmplStd/lib/math.ci:451: (12 bytes: <asin @061778> - <asin+12 @061784>): if (x == (0))
	<asin @061778>      : 11 01                      dup.x64 sp(1)
	<asin+2 @06177a>    : 1a                         load.z64
	<asin+3 @06177b>    : 87                         ceq.f64
	<asin+4 @06177c>    : 06 08 00 00                jz <asin+12 @061784>
	cmplStd/lib/math.ci:453: (4 bytes: <asin+8 @061780> - <asin+12 @061784>): return .result := x;
	<asin+8 @061780>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @061783>   : 03                         ret
	cmplStd/lib/math.ci:456: (1 byte: <asin+12 @061784> - <asin+13 @061785>): negate: bool := false
	<asin+12 @061784>   : 19                         load.z32
	cmplStd/lib/math.ci:457: (23 bytes: <asin+13 @061785> - <asin+36 @06179c>): if (x < (0))
	<asin+13 @061785>   : 11 02                      dup.x64 sp(2)
	<asin+15 @061787>   : 1a                         load.z64
	<asin+16 @061788>   : 88                         clt.f64
	<asin+17 @061789>   : 06 13 00 00                jz <asin+36 @06179c>
	cmplStd/lib/math.ci:458: (10 bytes: <asin+21 @06178d> - <asin+31 @061797>): negate := true;
	<asin+21 @06178d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @061792>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @061796>   : 2b                         store.i8
	cmplStd/lib/math.ci:459: (5 bytes: <asin+31 @061797> - <asin+36 @06179c>): x := -x;
	<asin+31 @061797>   : 11 02                      dup.x64 sp(2)
	<asin+33 @061799>   : 80                         neg.f64
	<asin+34 @06179a>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:462: (32 bytes: <asin+36 @06179c> - <asin+68 @0617bc>): if (x > (1))
	<asin+36 @06179c>   : 11 02                      dup.x64 sp(2)
	<asin+38 @06179e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @0617a7>   : 89                         cgt.f64
	<asin+48 @0617a8>   : 06 14 00 00                jz <asin+68 @0617bc>
	cmplStd/lib/math.ci:464: (16 bytes: <asin+52 @0617ac> - <asin+68 @0617bc>): return .result := nan;
	<asin+52 @0617ac>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @0617b5>   : 14 06                      set.x64 sp(6)
	<asin+63 @0617b7>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @0617bb>   : 03                         ret
	cmplStd/lib/math.ci:467: (19 bytes: <asin+68 @0617bc> - <asin+87 @0617cf>): result: float64 := float64.sqrt((1) - x * x)
	<asin+68 @0617bc>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @0617c5>   : 11 04                      dup.x64 sp(4)
	<asin+79 @0617c7>   : 11 06                      dup.x64 sp(6)
	<asin+81 @0617c9>   : 83                         mul.f64
	<asin+82 @0617ca>   : 82                         sub.f64
	<asin+83 @0617cb>   : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	cmplStd/lib/math.ci:468: (60 bytes: <asin+87 @0617cf> - <asin+147 @06180b>): if (x > 0.700000)
	<asin+87 @0617cf>   : 11 04                      dup.x64 sp(4)
	<asin+89 @0617d1>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @0617da>   : 89                         cgt.f64
	<asin+99 @0617db>   : 06 26 00 00                jz <asin+137 @061801>
	cmplStd/lib/math.ci:469: (30 bytes: <asin+103 @0617df> - <asin+133 @0617fd>): result := pi / (2) - float64.atan2(result, x);
	<asin+103 @0617df>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @0617e8>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @0617f1>  : 84                         div.f64
	<asin+122 @0617f2>  : 11 02                      dup.x64 sp(2)
	<asin+124 @0617f4>  : 11 08                      dup.x64 sp(8)
	<asin+126 @0617f6>  : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @0617fa>  : 82                         sub.f64
	<asin+131 @0617fb>  : 14 02                      set.x64 sp(2)
	<asin+133 @0617fd>  : 04 0e 00 00                jmp <asin+147 @06180b>
	cmplStd/lib/math.ci:472: (10 bytes: <asin+137 @061801> - <asin+147 @06180b>): result := float64.atan2(x, result);
	<asin+137 @061801>  : 11 04                      dup.x64 sp(4)
	<asin+139 @061803>  : 11 02                      dup.x64 sp(2)
	<asin+141 @061805>  : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @061809>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:475: (19 bytes: <asin+147 @06180b> - <asin+166 @06181e>): if (negate)
	<asin+147 @06180b>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @06180f>  : 26                         load.i8
	<asin+152 @061810>  : 06 0e 00 00                jz <asin+166 @06181e>
	cmplStd/lib/math.ci:476: (10 bytes: <asin+156 @061814> - <asin+166 @06181e>): return .result := -result;
	<asin+156 @061814>  : 11 00                      dup.x64 sp(0)
	<asin+158 @061816>  : 80                         neg.f64
	<asin+159 @061817>  : 14 08                      set.x64 sp(8)
	<asin+161 @061819>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @06181d>  : 03                         ret
	cmplStd/lib/math.ci:478: (7 bytes: <asin+166 @06181e> - <asin+173 @061825>): return .result := result;
	<asin+166 @06181e>  : 14 06                      set.x64 sp(6)
	<asin+168 @061820>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @061824>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:63: referenced as `asin`
	cmplStd/lib/math.ci:485: referenced as `asin`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'cmplStd/lib/math.ci:485'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	cmplStd/test/std/test.math.ci:64: referenced as `acos`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'cmplStd/lib/math.ci:509'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'cmplStd/lib/math.ci:512'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01f0a0>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:184: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:182: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:180: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:178: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:175: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:173: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:171: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:169: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:166: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:164: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:114: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:112: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:31: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:24: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:141: referenced as `re`
	cmplStd/lib/math/Complex.ci:139: referenced as `re`
	cmplStd/lib/math/Complex.ci:138: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:126: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:114: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:102: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:99: referenced as `re`
	cmplStd/lib/math/Complex.ci:98: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:95: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:92: referenced as `re`
	cmplStd/lib/math/Complex.ci:91: referenced as `re`
	cmplStd/lib/math/Complex.ci:90: referenced as `re`
	cmplStd/lib/math/Complex.ci:83: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:73: referenced as `re`
	cmplStd/lib/math/Complex.ci:71: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:64: referenced as `re`
	cmplStd/lib/math/Complex.ci:33: referenced as `re`
	cmplStd/lib/math/Complex.ci:26: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:139: referenced as `im`
	cmplStd/lib/math/Complex.ci:138: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:126: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:114: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:101: referenced as `im`
	cmplStd/lib/math/Complex.ci:99: referenced as `im`
	cmplStd/lib/math/Complex.ci:98: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:94: referenced as `im`
	cmplStd/lib/math/Complex.ci:92: referenced as `im`
	cmplStd/lib/math/Complex.ci:91: referenced as `im`
	cmplStd/lib/math/Complex.ci:90: referenced as `im`
	cmplStd/lib/math/Complex.ci:83: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:73: referenced as `im`
	cmplStd/lib/math/Complex.ci:71: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:64: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	internal usages: 1
}
Complex(re: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@061828>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <Complex @061828> - <Complex+7 @06182f>)
	cmplStd/lib/math/Complex.ci:25: (7 bytes: <Complex @061828> - <Complex+7 @06182f>): return .result := {...};
	cmplStd/lib/math/Complex.ci:26: (3 bytes: <Complex @061828> - <Complex+3 @06182b>): .result.re := re;
	<Complex @061828>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <Complex+3 @06182b> - <Complex+6 @06182e>): .result.im := (0);
	<Complex+3 @06182b>    : 1a                         load.z64
	<Complex+4 @06182c>    : 14 07                      set.x64 sp(7)
	<Complex+6 @06182e>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@061830>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <Complex @061830> - <Complex+7 @061837>)
	cmplStd/lib/math/Complex.ci:32: (7 bytes: <Complex @061830> - <Complex+7 @061837>): return .result := {...};
	cmplStd/lib/math/Complex.ci:33: (3 bytes: <Complex @061830> - <Complex+3 @061833>): .result.re := re;
	<Complex @061830>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:34: (3 bytes: <Complex+3 @061833> - <Complex+6 @061836>): .result.im := im;
	<Complex+3 @061833>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @061836>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(void(struct(a), neg.p2d)))
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:171: referenced as `neg`
	cmplStd/lib/math/Complex.ci:169: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `add`
	cmplStd/lib/math/Complex.ci:173: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:169: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `sub`
	cmplStd/lib/math/Complex.ci:173: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)))
.usages:
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 139
.offset: <@061838>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:86'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (139 bytes: <div @061838> - <div+139 @0618c3>)
	cmplStd/lib/math/Complex.ci:90: (95 bytes: <div @061838> - <div+95 @061897>): if (Math.abs(b.re) >= Math.abs(b.im))
	<div @061838>      : 11 01                      dup.x64 sp(1)
	<div+2 @06183a>    : 11 00                      dup.x64 sp(0)
	<div+4 @06183c>    : 1a                         load.z64
	<div+5 @06183d>    : 88                         clt.f64
	<div+6 @06183e>    : 06 0b 00 00                jz <div+17 @061849>
	<div+10 @061842>   : 11 00                      dup.x64 sp(0)
	<div+12 @061844>   : 80                         neg.f64
	<div+13 @061845>   : 04 06 00 00                jmp <div+19 @06184b>
	<div+17 @061849>   : 11 00                      dup.x64 sp(0)
	<div+19 @06184b>   : 14 02                      set.x64 sp(2)
	<div+21 @06184d>   : 11 05                      dup.x64 sp(5)
	<div+23 @06184f>   : 11 00                      dup.x64 sp(0)
	<div+25 @061851>   : 1a                         load.z64
	<div+26 @061852>   : 88                         clt.f64
	<div+27 @061853>   : 06 0b 00 00                jz <div+38 @06185e>
	<div+31 @061857>   : 11 00                      dup.x64 sp(0)
	<div+33 @061859>   : 80                         neg.f64
	<div+34 @06185a>   : 04 06 00 00                jmp <div+40 @061860>
	<div+38 @06185e>   : 11 00                      dup.x64 sp(0)
	<div+40 @061860>   : 14 02                      set.x64 sp(2)
	<div+42 @061862>   : 88                         clt.f64
	<div+43 @061863>   : 05 34 00 00                jnz <div+95 @061897>
	cmplStd/lib/math/Complex.ci:91: (5 bytes: <div+47 @061867> - <div+52 @06186c>): r: float64 := b.im / b.re
	<div+47 @061867>   : 11 03                      dup.x64 sp(3)
	<div+49 @061869>   : 11 03                      dup.x64 sp(3)
	<div+51 @06186b>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:92: (8 bytes: <div+52 @06186c> - <div+60 @061874>): den: float64 := b.re + r * b.im
	<div+52 @06186c>   : 11 03                      dup.x64 sp(3)
	<div+54 @06186e>   : 11 02                      dup.x64 sp(2)
	<div+56 @061870>   : 11 09                      dup.x64 sp(9)
	<div+58 @061872>   : 83                         mul.f64
	<div+59 @061873>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:93: (31 bytes: <div+60 @061874> - <div+91 @061893>): return .result := {...};
	cmplStd/lib/math/Complex.ci:94: (13 bytes: <div+60 @061874> - <div+73 @061881>): .result.re := (a.re + r * a.im) / den;
	<div+60 @061874>   : 11 09                      dup.x64 sp(9)
	<div+62 @061876>   : 11 04                      dup.x64 sp(4)
	<div+64 @061878>   : 11 0f                      dup.x64 sp(15)
	<div+66 @06187a>   : 83                         mul.f64
	<div+67 @06187b>   : 81                         add.f64
	<div+68 @06187c>   : 11 02                      dup.x64 sp(2)
	<div+70 @06187e>   : 84                         div.f64
	<div+71 @06187f>   : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:95: (13 bytes: <div+73 @061881> - <div+86 @06188e>): .result.im := (a.im - r * a.re) / den;
	<div+73 @061881>   : 11 0b                      dup.x64 sp(11)
	<div+75 @061883>   : 11 04                      dup.x64 sp(4)
	<div+77 @061885>   : 11 0d                      dup.x64 sp(13)
	<div+79 @061887>   : 83                         mul.f64
	<div+80 @061888>   : 82                         sub.f64
	<div+81 @061889>   : 11 02                      dup.x64 sp(2)
	<div+83 @06188b>   : 84                         div.f64
	<div+84 @06188c>   : 14 11                      set.x64 sp(17)
	<div+86 @06188e>   : 09 f0 ff ff                inc.sp(-16)
	<div+90 @061892>   : 03                         ret
	<div+91 @061893>   : 09 f0 ff ff                inc.sp(-16)
	cmplStd/lib/math/Complex.ci:98: (5 bytes: <div+95 @061897> - <div+100 @06189c>): r: float64 := b.re / b.im
	<div+95 @061897>   : 11 01                      dup.x64 sp(1)
	<div+97 @061899>   : 11 05                      dup.x64 sp(5)
	<div+99 @06189b>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:99: (8 bytes: <div+100 @06189c> - <div+108 @0618a4>): den: float64 := b.im + r * b.re
	<div+100 @06189c>  : 11 05                      dup.x64 sp(5)
	<div+102 @06189e>  : 11 02                      dup.x64 sp(2)
	<div+104 @0618a0>  : 11 07                      dup.x64 sp(7)
	<div+106 @0618a2>  : 83                         mul.f64
	<div+107 @0618a3>  : 81                         add.f64
	cmplStd/lib/math/Complex.ci:100: (31 bytes: <div+108 @0618a4> - <div+139 @0618c3>): return .result := {...};
	cmplStd/lib/math/Complex.ci:101: (13 bytes: <div+108 @0618a4> - <div+121 @0618b1>): .result.re := (a.re * r + a.im) / den;
	<div+108 @0618a4>  : 11 09                      dup.x64 sp(9)
	<div+110 @0618a6>  : 11 04                      dup.x64 sp(4)
	<div+112 @0618a8>  : 83                         mul.f64
	<div+113 @0618a9>  : 11 0d                      dup.x64 sp(13)
	<div+115 @0618ab>  : 81                         add.f64
	<div+116 @0618ac>  : 11 02                      dup.x64 sp(2)
	<div+118 @0618ae>  : 84                         div.f64
	<div+119 @0618af>  : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:102: (13 bytes: <div+121 @0618b1> - <div+134 @0618be>): .result.im := (a.im * r - a.re) / den;
	<div+121 @0618b1>  : 11 0b                      dup.x64 sp(11)
	<div+123 @0618b3>  : 11 04                      dup.x64 sp(4)
	<div+125 @0618b5>  : 83                         mul.f64
	<div+126 @0618b6>  : 11 0b                      dup.x64 sp(11)
	<div+128 @0618b8>  : 82                         sub.f64
	<div+129 @0618b9>  : 11 02                      dup.x64 sp(2)
	<div+131 @0618bb>  : 84                         div.f64
	<div+132 @0618bc>  : 14 11                      set.x64 sp(17)
	<div+134 @0618be>  : 09 f0 ff ff                inc.sp(-16)
	<div+138 @0618c2>  : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `div`
	cmplStd/lib/math/Complex.ci:173: referenced as `div`
	cmplStd/lib/math/Complex.ci:166: referenced as `div`
	cmplStd/lib/math/Complex.ci:164: referenced as `div`
	cmplStd/lib/math/Complex.ci:109: referenced as `div`
	cmplStd/lib/math/Complex.ci:107: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:107'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `div`
	cmplStd/lib/math/Complex.ci:169: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:109'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:112'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `abs`
	cmplStd/lib/math/Complex.ci:136: referenced as `abs`
	cmplStd/lib/math/Complex.ci:132: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:114'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `arg`
	cmplStd/lib/math/Complex.ci:137: referenced as `arg`
	cmplStd/lib/math/Complex.ci:132: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.offset: <@0618c8>
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:117'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <inv @0618c8> - <inv+31 @0618e7>)
	cmplStd/lib/math/Complex.ci:118: (11 bytes: <inv @0618c8> - <inv+11 @0618d3>): d: float64 := a.re * a.re + a.im * a.im
	<inv @0618c8>      : 11 01                      dup.x64 sp(1)
	<inv+2 @0618ca>    : 11 03                      dup.x64 sp(3)
	<inv+4 @0618cc>    : 83                         mul.f64
	<inv+5 @0618cd>    : 11 05                      dup.x64 sp(5)
	<inv+7 @0618cf>    : 11 07                      dup.x64 sp(7)
	<inv+9 @0618d1>    : 83                         mul.f64
	<inv+10 @0618d2>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:119: (20 bytes: <inv+11 @0618d3> - <inv+31 @0618e7>): return .result := {...};
	cmplStd/lib/math/Complex.ci:120: (7 bytes: <inv+11 @0618d3> - <inv+18 @0618da>): .result.re := +a.re / d;
	<inv+11 @0618d3>   : 11 03                      dup.x64 sp(3)
	<inv+13 @0618d5>   : 11 02                      dup.x64 sp(2)
	<inv+15 @0618d7>   : 84                         div.f64
	<inv+16 @0618d8>   : 14 09                      set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:121: (8 bytes: <inv+18 @0618da> - <inv+26 @0618e2>): .result.im := -a.im / d;
	<inv+18 @0618da>   : 11 05                      dup.x64 sp(5)
	<inv+20 @0618dc>   : 80                         neg.f64
	<inv+21 @0618dd>   : 11 02                      dup.x64 sp(2)
	<inv+23 @0618df>   : 84                         div.f64
	<inv+24 @0618e0>   : 14 0b                      set.x64 sp(11)
	<inv+26 @0618e2>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @0618e6>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `inv`
	cmplStd/lib/math/Complex.ci:182: referenced as `inv`
	cmplStd/lib/math/Complex.ci:180: referenced as `inv`
	cmplStd/lib/math/Complex.ci:178: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 100
.offset: <@0618e8>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <pow @0618e8> - <pow+100 @06194c>)
	cmplStd/lib/math/Complex.ci:136: (23 bytes: <pow @0618e8> - <pow+23 @0618ff>): r: float64 := abs(a)
	<pow @0618e8>      : 12 05                      dup.x128 sp(5)
	<pow+2 @0618ea>    : 11 00                      dup.x64 sp(0)
	<pow+4 @0618ec>    : 11 02                      dup.x64 sp(2)
	<pow+6 @0618ee>    : 83                         mul.f64
	<pow+7 @0618ef>    : 11 04                      dup.x64 sp(4)
	<pow+9 @0618f1>    : 11 06                      dup.x64 sp(6)
	<pow+11 @0618f3>   : 83                         mul.f64
	<pow+12 @0618f4>   : 81                         add.f64
	<pow+13 @0618f5>   : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	<pow+17 @0618f9>   : 14 04                      set.x64 sp(4)
	<pow+19 @0618fb>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:137: (16 bytes: <pow+23 @0618ff> - <pow+39 @06190f>): t: float64 := arg(a)
	<pow+23 @0618ff>   : 12 07                      dup.x128 sp(7)
	<pow+25 @061901>   : 11 00                      dup.x64 sp(0)
	<pow+27 @061903>   : 11 04                      dup.x64 sp(4)
	<pow+29 @061905>   : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @061909>   : 14 04                      set.x64 sp(4)
	<pow+35 @06190b>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:138: (15 bytes: <pow+39 @06190f> - <pow+54 @06191e>): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+39 @06190f>   : 11 05                      dup.x64 sp(5)
	<pow+41 @061911>   : 11 02                      dup.x64 sp(2)
	<pow+43 @061913>   : 83                         mul.f64
	<pow+44 @061914>   : 11 09                      dup.x64 sp(9)
	<pow+46 @061916>   : 11 06                      dup.x64 sp(6)
	<pow+48 @061918>   : 01 2a 00 00                nfc(42) ;float64.log(x: float64): float64
	<pow+52 @06191c>   : 83                         mul.f64
	<pow+53 @06191d>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:139: (19 bytes: <pow+54 @06191e> - <pow+73 @061931>): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+54 @06191e>   : 11 04                      dup.x64 sp(4)
	<pow+56 @061920>   : 11 09                      dup.x64 sp(9)
	<pow+58 @061922>   : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @061926>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @061928>   : 80                         neg.f64
	<pow+65 @061929>   : 11 06                      dup.x64 sp(6)
	<pow+67 @06192b>   : 83                         mul.f64
	<pow+68 @06192c>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<pow+72 @061930>   : 83                         mul.f64
	cmplStd/lib/math/Complex.ci:140: (27 bytes: <pow+73 @061931> - <pow+100 @06194c>): return .result := {...};
	cmplStd/lib/math/Complex.ci:141: (11 bytes: <pow+73 @061931> - <pow+84 @06193c>): .result.re := v * float64.cos(u);
	<pow+73 @061931>   : 11 00                      dup.x64 sp(0)
	<pow+75 @061933>   : 11 04                      dup.x64 sp(4)
	<pow+77 @061935>   : 01 28 00 00                nfc(40) ;float64.cos(x: float64): float64
	<pow+81 @061939>   : 83                         mul.f64
	<pow+82 @06193a>   : 14 13                      set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:142: (11 bytes: <pow+84 @06193c> - <pow+95 @061947>): .result.im := v * float64.sin(u);
	<pow+84 @06193c>   : 11 00                      dup.x64 sp(0)
	<pow+86 @06193e>   : 11 04                      dup.x64 sp(4)
	<pow+88 @061940>   : 01 27 00 00                nfc(39) ;float64.sin(x: float64): float64
	<pow+92 @061944>   : 83                         mul.f64
	<pow+93 @061945>   : 14 15                      set.x64 sp(21)
	<pow+95 @061947>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @06194b>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:149'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:180: referenced as `sin`
	cmplStd/lib/math/Complex.ci:166: referenced as `sin`
	cmplStd/lib/math/Complex.ci:164: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:151'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:178: referenced as `cos`
	cmplStd/lib/math/Complex.ci:166: referenced as `cos`
	cmplStd/lib/math/Complex.ci:164: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:164'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:169'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:171'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:182: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:173'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:178'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:180'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:182'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:187'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:189'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024be8>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:141'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.param w: float32 (size: 4, offs: <+16>, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:128: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(void(vec4f(a), b))
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(void(a, vec4f(b)))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(vec4f(a), b))
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(a, vec4f(b)))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(vec4f(a), b))
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(a, vec4f(b)))
.usages:
}
div(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(vec4f(a), b))
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(a, vec4f(b)))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:102'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: vec4f (size: 16, offs: <+32>, cast: val)
.param max: vec4f (size: 16, offs: <+48>, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(void(max(void(vec, min)), max))
.usages:
	cmplStd/lib/math/Vector4f.ci:108: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: float32 (size: 4, offs: <+20>, cast: f32)
.param max: float32 (size: 4, offs: <+24>, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(void(void(vec, vec4f(min)), vec4f(max)))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:112'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:116'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:120'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:126'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:128'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@02a080>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:142: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:147: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:152: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@061950>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
}
.instructions: (49 bytes: <mat4f @061950> - <mat4f+49 @061981>)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes: <mat4f @061950> - <mat4f+49 @061981>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f @061950> - <mat4f+3 @061953>): .result.xx := xx;
	<mat4f @061950>      : 16 11 10                   mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+3 @061953> - <mat4f+6 @061956>): .result.xy := xy;
	<mat4f+3 @061953>    : 16 12 0f                   mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+6 @061956> - <mat4f+9 @061959>): .result.xz := xz;
	<mat4f+6 @061956>    : 16 13 0e                   mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+9 @061959> - <mat4f+12 @06195c>): .result.xw := xw;
	<mat4f+9 @061959>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+12 @06195c> - <mat4f+15 @06195f>): .result.yx := yx;
	<mat4f+12 @06195c>   : 16 15 0c                   mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+15 @06195f> - <mat4f+18 @061962>): .result.yy := yy;
	<mat4f+15 @06195f>   : 16 16 0b                   mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+18 @061962> - <mat4f+21 @061965>): .result.yz := yz;
	<mat4f+18 @061962>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+21 @061965> - <mat4f+24 @061968>): .result.yw := yw;
	<mat4f+21 @061965>   : 16 18 09                   mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+24 @061968> - <mat4f+27 @06196b>): .result.zx := zx;
	<mat4f+24 @061968>   : 16 19 08                   mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+27 @06196b> - <mat4f+30 @06196e>): .result.zy := zy;
	<mat4f+27 @06196b>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+30 @06196e> - <mat4f+33 @061971>): .result.zz := zz;
	<mat4f+30 @06196e>   : 16 1b 06                   mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+33 @061971> - <mat4f+36 @061974>): .result.zw := zw;
	<mat4f+33 @061971>   : 16 1c 05                   mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+36 @061974> - <mat4f+39 @061977>): .result.wx := wx;
	<mat4f+36 @061974>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+39 @061977> - <mat4f+42 @06197a>): .result.wy := wy;
	<mat4f+39 @061977>   : 16 1e 03                   mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+42 @06197a> - <mat4f+45 @06197d>): .result.wz := wz;
	<mat4f+42 @06197a>   : 16 1f 02                   mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+45 @06197d> - <mat4f+48 @061980>): .result.ww := ww;
	<mat4f+45 @06197d>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @061980>   : 03                         ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.offset: <@061988>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <mat4f @061988> - <mat4f+21 @06199d>)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes: <mat4f @061988> - <mat4f+21 @06199d>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f @061988> - <mat4f+5 @06198d>): .result.x := x;
	<mat4f @061988>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @06198a>    : 2a                         load.i128
	<mat4f+3 @06198b>    : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+5 @06198d> - <mat4f+10 @061992>): .result.y := y;
	<mat4f+5 @06198d>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @06198f>    : 2a                         load.i128
	<mat4f+8 @061990>    : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+10 @061992> - <mat4f+15 @061997>): .result.z := z;
	<mat4f+10 @061992>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @061994>   : 2a                         load.i128
	<mat4f+13 @061995>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+15 @061997> - <mat4f+20 @06199c>): .result.w := w;
	<mat4f+15 @061997>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @061999>   : 2a                         load.i128
	<mat4f+18 @06199a>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @06199c>   : 03                         ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@0619a0>
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param mat: mat4f (size: 64, offs: <+128>, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
}
.instructions: (49 bytes: <transpose @0619a0> - <transpose+49 @0619d1>)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes: <transpose @0619a0> - <transpose+49 @0619d1>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose @0619a0> - <transpose+3 @0619a3>): .result.xx := mat.xx;
	<transpose @0619a0>      : 16 11 01                   mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+3 @0619a3> - <transpose+6 @0619a6>): .result.xy := mat.yx;
	<transpose+3 @0619a3>    : 16 12 05                   mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+6 @0619a6> - <transpose+9 @0619a9>): .result.xz := mat.zx;
	<transpose+6 @0619a6>    : 16 13 09                   mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+9 @0619a9> - <transpose+12 @0619ac>): .result.xw := mat.wx;
	<transpose+9 @0619a9>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+12 @0619ac> - <transpose+15 @0619af>): .result.yx := mat.xy;
	<transpose+12 @0619ac>   : 16 15 02                   mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+15 @0619af> - <transpose+18 @0619b2>): .result.yy := mat.yy;
	<transpose+15 @0619af>   : 16 16 06                   mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+18 @0619b2> - <transpose+21 @0619b5>): .result.yz := mat.zy;
	<transpose+18 @0619b2>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+21 @0619b5> - <transpose+24 @0619b8>): .result.yw := mat.wy;
	<transpose+21 @0619b5>   : 16 18 0e                   mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+24 @0619b8> - <transpose+27 @0619bb>): .result.zx := mat.xz;
	<transpose+24 @0619b8>   : 16 19 03                   mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+27 @0619bb> - <transpose+30 @0619be>): .result.zy := mat.yz;
	<transpose+27 @0619bb>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+30 @0619be> - <transpose+33 @0619c1>): .result.zz := mat.zz;
	<transpose+30 @0619be>   : 16 1b 0b                   mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+33 @0619c1> - <transpose+36 @0619c4>): .result.zw := mat.wz;
	<transpose+33 @0619c1>   : 16 1c 0f                   mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+36 @0619c4> - <transpose+39 @0619c7>): .result.wx := mat.xw;
	<transpose+36 @0619c4>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+39 @0619c7> - <transpose+42 @0619ca>): .result.wy := mat.yw;
	<transpose+39 @0619c7>   : 16 1e 08                   mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+42 @0619ca> - <transpose+45 @0619cd>): .result.wz := mat.zw;
	<transpose+42 @0619ca>   : 16 1f 0c                   mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+45 @0619cd> - <transpose+48 @0619d0>): .result.ww := mat.ww;
	<transpose+45 @0619cd>   : 16 20 10                   mov.x32 sp(32, 16)
	<transpose+48 @0619d0>   : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 245
.offset: <@0619d8>
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (245 bytes: <mul @0619d8> - <mul+245 @061acd>)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes: <mul @0619d8> - <mul+28 @0619f4>): transposed: mat4f := transpose(rhs)
	<mul @0619d8>      : 09 40 00 00                inc.sp(+64)
	<mul+4 @0619dc>    : 10 11                      dup.x32 sp(17)
	<mul+6 @0619de>    : 0a c4 ff ff                load.sp(-60)
	<mul+10 @0619e2>   : 1e c0 ff ff                copy.mem -64
	<mul+14 @0619e6>   : 09 40 00 00                inc.sp(+64)
	<mul+18 @0619ea>   : 1f a0 19 06 00             load.ref <@0619a0> ;transpose(mat: mat4f): mat4f
	<mul+23 @0619ef>   : 02                         call
	<mul+24 @0619f0>   : 09 c0 ff ff                inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (217 bytes: <mul+28 @0619f4> - <mul+245 @061acd>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (50 bytes: <mul+28 @0619f4> - <mul+78 @061a26>): .result.x := dp4(transposed, lhs.x);
	<mul+28 @0619f4>   : 0a 00 00 00                load.sp(+0)
	<mul+32 @0619f8>   : 10 13                      dup.x32 sp(19)
	<mul+34 @0619fa>   : 10 01                      dup.x32 sp(1)
	<mul+36 @0619fc>   : 0c 30 00 00                inc.i32(+48)
	<mul+40 @061a00>   : 2a                         load.i128
	<mul+41 @061a01>   : 10 04                      dup.x32 sp(4)
	<mul+43 @061a03>   : 2a                         load.i128
	<mul+44 @061a04>   : 9b                         dp4.v4f
	<mul+45 @061a05>   : 10 02                      dup.x32 sp(2)
	<mul+47 @061a07>   : 0c 20 00 00                inc.i32(+32)
	<mul+51 @061a0b>   : 2a                         load.i128
	<mul+52 @061a0c>   : 10 05                      dup.x32 sp(5)
	<mul+54 @061a0e>   : 2a                         load.i128
	<mul+55 @061a0f>   : 9b                         dp4.v4f
	<mul+56 @061a10>   : 10 03                      dup.x32 sp(3)
	<mul+58 @061a12>   : 0c 10 00 00                inc.i32(+16)
	<mul+62 @061a16>   : 2a                         load.i128
	<mul+63 @061a17>   : 10 06                      dup.x32 sp(6)
	<mul+65 @061a19>   : 2a                         load.i128
	<mul+66 @061a1a>   : 9b                         dp4.v4f
	<mul+67 @061a1b>   : 10 04                      dup.x32 sp(4)
	<mul+69 @061a1d>   : 2a                         load.i128
	<mul+70 @061a1e>   : 10 07                      dup.x32 sp(7)
	<mul+72 @061a20>   : 2a                         load.i128
	<mul+73 @061a21>   : 9b                         dp4.v4f
	<mul+74 @061a22>   : 15 02                      set.x128 sp(2)
	<mul+76 @061a24>   : 15 17                      set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (54 bytes: <mul+78 @061a26> - <mul+132 @061a5c>): .result.y := dp4(transposed, lhs.y);
	<mul+78 @061a26>   : 0a 00 00 00                load.sp(+0)
	<mul+82 @061a2a>   : 10 13                      dup.x32 sp(19)
	<mul+84 @061a2c>   : 0c 10 00 00                inc.i32(+16)
	<mul+88 @061a30>   : 10 01                      dup.x32 sp(1)
	<mul+90 @061a32>   : 0c 30 00 00                inc.i32(+48)
	<mul+94 @061a36>   : 2a                         load.i128
	<mul+95 @061a37>   : 10 04                      dup.x32 sp(4)
	<mul+97 @061a39>   : 2a                         load.i128
	<mul+98 @061a3a>   : 9b                         dp4.v4f
	<mul+99 @061a3b>   : 10 02                      dup.x32 sp(2)
	<mul+101 @061a3d>  : 0c 20 00 00                inc.i32(+32)
	<mul+105 @061a41>  : 2a                         load.i128
	<mul+106 @061a42>  : 10 05                      dup.x32 sp(5)
	<mul+108 @061a44>  : 2a                         load.i128
	<mul+109 @061a45>  : 9b                         dp4.v4f
	<mul+110 @061a46>  : 10 03                      dup.x32 sp(3)
	<mul+112 @061a48>  : 0c 10 00 00                inc.i32(+16)
	<mul+116 @061a4c>  : 2a                         load.i128
	<mul+117 @061a4d>  : 10 06                      dup.x32 sp(6)
	<mul+119 @061a4f>  : 2a                         load.i128
	<mul+120 @061a50>  : 9b                         dp4.v4f
	<mul+121 @061a51>  : 10 04                      dup.x32 sp(4)
	<mul+123 @061a53>  : 2a                         load.i128
	<mul+124 @061a54>  : 10 07                      dup.x32 sp(7)
	<mul+126 @061a56>  : 2a                         load.i128
	<mul+127 @061a57>  : 9b                         dp4.v4f
	<mul+128 @061a58>  : 15 02                      set.x128 sp(2)
	<mul+130 @061a5a>  : 15 1b                      set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (54 bytes: <mul+132 @061a5c> - <mul+186 @061a92>): .result.z := dp4(transposed, lhs.z);
	<mul+132 @061a5c>  : 0a 00 00 00                load.sp(+0)
	<mul+136 @061a60>  : 10 13                      dup.x32 sp(19)
	<mul+138 @061a62>  : 0c 20 00 00                inc.i32(+32)
	<mul+142 @061a66>  : 10 01                      dup.x32 sp(1)
	<mul+144 @061a68>  : 0c 30 00 00                inc.i32(+48)
	<mul+148 @061a6c>  : 2a                         load.i128
	<mul+149 @061a6d>  : 10 04                      dup.x32 sp(4)
	<mul+151 @061a6f>  : 2a                         load.i128
	<mul+152 @061a70>  : 9b                         dp4.v4f
	<mul+153 @061a71>  : 10 02                      dup.x32 sp(2)
	<mul+155 @061a73>  : 0c 20 00 00                inc.i32(+32)
	<mul+159 @061a77>  : 2a                         load.i128
	<mul+160 @061a78>  : 10 05                      dup.x32 sp(5)
	<mul+162 @061a7a>  : 2a                         load.i128
	<mul+163 @061a7b>  : 9b                         dp4.v4f
	<mul+164 @061a7c>  : 10 03                      dup.x32 sp(3)
	<mul+166 @061a7e>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @061a82>  : 2a                         load.i128
	<mul+171 @061a83>  : 10 06                      dup.x32 sp(6)
	<mul+173 @061a85>  : 2a                         load.i128
	<mul+174 @061a86>  : 9b                         dp4.v4f
	<mul+175 @061a87>  : 10 04                      dup.x32 sp(4)
	<mul+177 @061a89>  : 2a                         load.i128
	<mul+178 @061a8a>  : 10 07                      dup.x32 sp(7)
	<mul+180 @061a8c>  : 2a                         load.i128
	<mul+181 @061a8d>  : 9b                         dp4.v4f
	<mul+182 @061a8e>  : 15 02                      set.x128 sp(2)
	<mul+184 @061a90>  : 15 1f                      set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (54 bytes: <mul+186 @061a92> - <mul+240 @061ac8>): .result.w := dp4(transposed, lhs.w);
	<mul+186 @061a92>  : 0a 00 00 00                load.sp(+0)
	<mul+190 @061a96>  : 10 13                      dup.x32 sp(19)
	<mul+192 @061a98>  : 0c 30 00 00                inc.i32(+48)
	<mul+196 @061a9c>  : 10 01                      dup.x32 sp(1)
	<mul+198 @061a9e>  : 0c 30 00 00                inc.i32(+48)
	<mul+202 @061aa2>  : 2a                         load.i128
	<mul+203 @061aa3>  : 10 04                      dup.x32 sp(4)
	<mul+205 @061aa5>  : 2a                         load.i128
	<mul+206 @061aa6>  : 9b                         dp4.v4f
	<mul+207 @061aa7>  : 10 02                      dup.x32 sp(2)
	<mul+209 @061aa9>  : 0c 20 00 00                inc.i32(+32)
	<mul+213 @061aad>  : 2a                         load.i128
	<mul+214 @061aae>  : 10 05                      dup.x32 sp(5)
	<mul+216 @061ab0>  : 2a                         load.i128
	<mul+217 @061ab1>  : 9b                         dp4.v4f
	<mul+218 @061ab2>  : 10 03                      dup.x32 sp(3)
	<mul+220 @061ab4>  : 0c 10 00 00                inc.i32(+16)
	<mul+224 @061ab8>  : 2a                         load.i128
	<mul+225 @061ab9>  : 10 06                      dup.x32 sp(6)
	<mul+227 @061abb>  : 2a                         load.i128
	<mul+228 @061abc>  : 9b                         dp4.v4f
	<mul+229 @061abd>  : 10 04                      dup.x32 sp(4)
	<mul+231 @061abf>  : 2a                         load.i128
	<mul+232 @061ac0>  : 10 07                      dup.x32 sp(7)
	<mul+234 @061ac2>  : 2a                         load.i128
	<mul+235 @061ac3>  : 9b                         dp4.v4f
	<mul+236 @061ac4>  : 15 02                      set.x128 sp(2)
	<mul+238 @061ac6>  : 15 23                      set.x128 sp(35)
	<mul+240 @061ac8>  : 09 c0 ff ff                inc.sp(-64)
	<mul+244 @061acc>  : 03                         ret
.usages:
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 454
.offset: <@061ad0>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (454 bytes: <rotation @061ad0> - <rotation+454 @061c96>)
	cmplStd/lib/math/Matrix4f.ci:112: (18 bytes: <rotation @061ad0> - <rotation+18 @061ae2>): len: float32 := length(direction)
	<rotation @061ad0>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @061ad2>    : 2a                         load.i128
	<rotation+3 @061ad3>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @061ad5>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @061ad7>    : 9a                         dp3.v4f
	<rotation+8 @061ad8>    : 01 25 00 00                nfc(37) ;float32.sqrt(x: float32): float32
	<rotation+12 @061adc>   : 13 04                      set.x32 sp(4)
	<rotation+14 @061ade>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math/Matrix4f.ci:113: (82 bytes: <rotation+18 @061ae2> - <rotation+100 @061b34>): if ((len) < 0.000000)
	<rotation+18 @061ae2>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @061ae4>   : 7d                         f32.2f64
	<rotation+21 @061ae5>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @061aee>   : 88                         clt.f64
	<rotation+31 @061aef>   : 06 45 00 00                jz <rotation+100 @061b34>
	cmplStd/lib/math/Matrix4f.ci:114: (36 bytes: <rotation+35 @061af3> - <rotation+71 @061b17>): trace("invalid direction of rotation", direction);
	<rotation+35 @061af3>   : 1f 30 9d 02 00             load.ref <@029d30> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+40 @061af8>   : 1c 72 00 00 00             load.c32 114
	<rotation+45 @061afd>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @061b02>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @061b07>   : 1f ed 9f 02 00             load.ref <@029fed> ;"invalid direction of rotation"
	<rotation+60 @061b0c>   : 1f e8 4b 02 00             load.ref <@024be8> ;vec4f
	<rotation+65 @061b11>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @061b13>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/math/Matrix4f.ci:115: (29 bytes: <rotation+71 @061b17> - <rotation+100 @061b34>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes: <rotation+71 @061b17> - <rotation+77 @061b1d>): .result.x := vec4f(0, 0, 0, 0);
	<rotation+71 @061b17>   : 19                         load.z32
	<rotation+72 @061b18>   : 19                         load.z32
	<rotation+73 @061b19>   : 19                         load.z32
	<rotation+74 @061b1a>   : 19                         load.z32
	<rotation+75 @061b1b>   : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes: <rotation+77 @061b1d> - <rotation+83 @061b23>): .result.y := vec4f(0, 0, 0, 0);
	<rotation+77 @061b1d>   : 19                         load.z32
	<rotation+78 @061b1e>   : 19                         load.z32
	<rotation+79 @061b1f>   : 19                         load.z32
	<rotation+80 @061b20>   : 19                         load.z32
	<rotation+81 @061b21>   : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:118: (6 bytes: <rotation+83 @061b23> - <rotation+89 @061b29>): .result.z := vec4f(0, 0, 0, 0);
	<rotation+83 @061b23>   : 19                         load.z32
	<rotation+84 @061b24>   : 19                         load.z32
	<rotation+85 @061b25>   : 19                         load.z32
	<rotation+86 @061b26>   : 19                         load.z32
	<rotation+87 @061b27>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:119: (6 bytes: <rotation+89 @061b29> - <rotation+95 @061b2f>): .result.w := vec4f(0, 0, 0, 0);
	<rotation+89 @061b29>   : 19                         load.z32
	<rotation+90 @061b2a>   : 19                         load.z32
	<rotation+91 @061b2b>   : 19                         load.z32
	<rotation+92 @061b2c>   : 19                         load.z32
	<rotation+93 @061b2d>   : 15 15                      set.x128 sp(21)
	<rotation+95 @061b2f>   : 09 fc ff ff                inc.sp(-4)
	<rotation+99 @061b33>   : 03                         ret
	cmplStd/lib/math/Matrix4f.ci:122: (6 bytes: <rotation+100 @061b34> - <rotation+106 @061b3a>): x: float32 := direction.x / len
	<rotation+100 @061b34>  : 10 03                      dup.x32 sp(3)
	<rotation+102 @061b36>  : 28                         load.i32
	<rotation+103 @061b37>  : 10 01                      dup.x32 sp(1)
	<rotation+105 @061b39>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (10 bytes: <rotation+106 @061b3a> - <rotation+116 @061b44>): y: float32 := direction.y / len
	<rotation+106 @061b3a>  : 10 04                      dup.x32 sp(4)
	<rotation+108 @061b3c>  : 0c 04 00 00                inc.i32(+4)
	<rotation+112 @061b40>  : 28                         load.i32
	<rotation+113 @061b41>  : 10 02                      dup.x32 sp(2)
	<rotation+115 @061b43>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:124: (10 bytes: <rotation+116 @061b44> - <rotation+126 @061b4e>): z: float32 := direction.z / len
	<rotation+116 @061b44>  : 10 05                      dup.x32 sp(5)
	<rotation+118 @061b46>  : 0c 08 00 00                inc.i32(+8)
	<rotation+122 @061b4a>  : 28                         load.i32
	<rotation+123 @061b4b>  : 10 03                      dup.x32 sp(3)
	<rotation+125 @061b4d>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:125: (3 bytes: <rotation+126 @061b4e> - <rotation+129 @061b51>): cx: float32 := center.x
	<rotation+126 @061b4e>  : 10 07                      dup.x32 sp(7)
	<rotation+128 @061b50>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (7 bytes: <rotation+129 @061b51> - <rotation+136 @061b58>): cy: float32 := center.y
	<rotation+129 @061b51>  : 10 08                      dup.x32 sp(8)
	<rotation+131 @061b53>  : 0c 04 00 00                inc.i32(+4)
	<rotation+135 @061b57>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:127: (7 bytes: <rotation+136 @061b58> - <rotation+143 @061b5f>): cz: float32 := center.z
	<rotation+136 @061b58>  : 10 09                      dup.x32 sp(9)
	<rotation+138 @061b5a>  : 0c 08 00 00                inc.i32(+8)
	<rotation+142 @061b5e>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes: <rotation+143 @061b5f> - <rotation+148 @061b64>): xx: float32 := x * x
	<rotation+143 @061b5f>  : 10 05                      dup.x32 sp(5)
	<rotation+145 @061b61>  : 10 06                      dup.x32 sp(6)
	<rotation+147 @061b63>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes: <rotation+148 @061b64> - <rotation+153 @061b69>): xy: float32 := x * y
	<rotation+148 @061b64>  : 10 06                      dup.x32 sp(6)
	<rotation+150 @061b66>  : 10 06                      dup.x32 sp(6)
	<rotation+152 @061b68>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes: <rotation+153 @061b69> - <rotation+158 @061b6e>): xz: float32 := x * z
	<rotation+153 @061b69>  : 10 07                      dup.x32 sp(7)
	<rotation+155 @061b6b>  : 10 06                      dup.x32 sp(6)
	<rotation+157 @061b6d>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes: <rotation+158 @061b6e> - <rotation+163 @061b73>): yy: float32 := y * y
	<rotation+158 @061b6e>  : 10 07                      dup.x32 sp(7)
	<rotation+160 @061b70>  : 10 08                      dup.x32 sp(8)
	<rotation+162 @061b72>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:132: (5 bytes: <rotation+163 @061b73> - <rotation+168 @061b78>): yz: float32 := y * z
	<rotation+163 @061b73>  : 10 08                      dup.x32 sp(8)
	<rotation+165 @061b75>  : 10 08                      dup.x32 sp(8)
	<rotation+167 @061b77>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (5 bytes: <rotation+168 @061b78> - <rotation+173 @061b7d>): zz: float32 := z * z
	<rotation+168 @061b78>  : 10 08                      dup.x32 sp(8)
	<rotation+170 @061b7a>  : 10 09                      dup.x32 sp(9)
	<rotation+172 @061b7c>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:135: (6 bytes: <rotation+173 @061b7d> - <rotation+179 @061b83>): s: float32 := float32.sin(angle)
	<rotation+173 @061b7d>  : 10 0e                      dup.x32 sp(14)
	<rotation+175 @061b7f>  : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:136: (6 bytes: <rotation+179 @061b83> - <rotation+185 @061b89>): c: float32 := float32.cos(angle)
	<rotation+179 @061b83>  : 10 0f                      dup.x32 sp(15)
	<rotation+181 @061b85>  : 01 20 00 00                nfc(32) ;float32.cos(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:137: (8 bytes: <rotation+185 @061b89> - <rotation+193 @061b91>): k: float32 := (1) - c
	<rotation+185 @061b89>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+190 @061b8e>  : 10 01                      dup.x32 sp(1)
	<rotation+192 @061b90>  : 72                         sub.f32
	cmplStd/lib/math/Matrix4f.ci:139: (261 bytes: <rotation+193 @061b91> - <rotation+454 @061c96>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes: <rotation+193 @061b91> - <rotation+206 @061b9e>): .result.xx := xx + (yy + zz) * c;
	<rotation+193 @061b91>  : 10 08                      dup.x32 sp(8)
	<rotation+195 @061b93>  : 10 06                      dup.x32 sp(6)
	<rotation+197 @061b95>  : 10 05                      dup.x32 sp(5)
	<rotation+199 @061b97>  : 71                         add.f32
	<rotation+200 @061b98>  : 10 03                      dup.x32 sp(3)
	<rotation+202 @061b9a>  : 73                         mul.f32
	<rotation+203 @061b9b>  : 71                         add.f32
	<rotation+204 @061b9c>  : 13 15                      set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:141: (13 bytes: <rotation+206 @061b9e> - <rotation+219 @061bab>): .result.xy := xy * k - z * s;
	<rotation+206 @061b9e>  : 10 07                      dup.x32 sp(7)
	<rotation+208 @061ba0>  : 10 01                      dup.x32 sp(1)
	<rotation+210 @061ba2>  : 73                         mul.f32
	<rotation+211 @061ba3>  : 10 0d                      dup.x32 sp(13)
	<rotation+213 @061ba5>  : 10 04                      dup.x32 sp(4)
	<rotation+215 @061ba7>  : 73                         mul.f32
	<rotation+216 @061ba8>  : 72                         sub.f32
	<rotation+217 @061ba9>  : 13 16                      set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:142: (13 bytes: <rotation+219 @061bab> - <rotation+232 @061bb8>): .result.xz := xz * k + y * s;
	<rotation+219 @061bab>  : 10 06                      dup.x32 sp(6)
	<rotation+221 @061bad>  : 10 01                      dup.x32 sp(1)
	<rotation+223 @061baf>  : 73                         mul.f32
	<rotation+224 @061bb0>  : 10 0e                      dup.x32 sp(14)
	<rotation+226 @061bb2>  : 10 04                      dup.x32 sp(4)
	<rotation+228 @061bb4>  : 73                         mul.f32
	<rotation+229 @061bb5>  : 71                         add.f32
	<rotation+230 @061bb6>  : 13 17                      set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:143: (43 bytes: <rotation+232 @061bb8> - <rotation+275 @061be3>): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+232 @061bb8>  : 10 0b                      dup.x32 sp(11)
	<rotation+234 @061bba>  : 10 06                      dup.x32 sp(6)
	<rotation+236 @061bbc>  : 10 05                      dup.x32 sp(5)
	<rotation+238 @061bbe>  : 71                         add.f32
	<rotation+239 @061bbf>  : 73                         mul.f32
	<rotation+240 @061bc0>  : 10 0f                      dup.x32 sp(15)
	<rotation+242 @061bc2>  : 10 0c                      dup.x32 sp(12)
	<rotation+244 @061bc4>  : 10 10                      dup.x32 sp(16)
	<rotation+246 @061bc6>  : 73                         mul.f32
	<rotation+247 @061bc7>  : 10 0c                      dup.x32 sp(12)
	<rotation+249 @061bc9>  : 10 10                      dup.x32 sp(16)
	<rotation+251 @061bcb>  : 73                         mul.f32
	<rotation+252 @061bcc>  : 71                         add.f32
	<rotation+253 @061bcd>  : 73                         mul.f32
	<rotation+254 @061bce>  : 72                         sub.f32
	<rotation+255 @061bcf>  : 10 01                      dup.x32 sp(1)
	<rotation+257 @061bd1>  : 73                         mul.f32
	<rotation+258 @061bd2>  : 10 0b                      dup.x32 sp(11)
	<rotation+260 @061bd4>  : 10 0e                      dup.x32 sp(14)
	<rotation+262 @061bd6>  : 73                         mul.f32
	<rotation+263 @061bd7>  : 10 0b                      dup.x32 sp(11)
	<rotation+265 @061bd9>  : 10 10                      dup.x32 sp(16)
	<rotation+267 @061bdb>  : 73                         mul.f32
	<rotation+268 @061bdc>  : 72                         sub.f32
	<rotation+269 @061bdd>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @061bdf>  : 73                         mul.f32
	<rotation+272 @061be0>  : 71                         add.f32
	<rotation+273 @061be1>  : 13 18                      set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes: <rotation+275 @061be3> - <rotation+288 @061bf0>): .result.yx := xy * k + z * s;
	<rotation+275 @061be3>  : 10 07                      dup.x32 sp(7)
	<rotation+277 @061be5>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @061be7>  : 73                         mul.f32
	<rotation+280 @061be8>  : 10 0d                      dup.x32 sp(13)
	<rotation+282 @061bea>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @061bec>  : 73                         mul.f32
	<rotation+285 @061bed>  : 71                         add.f32
	<rotation+286 @061bee>  : 13 19                      set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:146: (13 bytes: <rotation+288 @061bf0> - <rotation+301 @061bfd>): .result.yy := yy + (xx + zz) * c;
	<rotation+288 @061bf0>  : 10 05                      dup.x32 sp(5)
	<rotation+290 @061bf2>  : 10 09                      dup.x32 sp(9)
	<rotation+292 @061bf4>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @061bf6>  : 71                         add.f32
	<rotation+295 @061bf7>  : 10 03                      dup.x32 sp(3)
	<rotation+297 @061bf9>  : 73                         mul.f32
	<rotation+298 @061bfa>  : 71                         add.f32
	<rotation+299 @061bfb>  : 13 1a                      set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:147: (13 bytes: <rotation+301 @061bfd> - <rotation+314 @061c0a>): .result.yz := yz * k - x * s;
	<rotation+301 @061bfd>  : 10 04                      dup.x32 sp(4)
	<rotation+303 @061bff>  : 10 01                      dup.x32 sp(1)
	<rotation+305 @061c01>  : 73                         mul.f32
	<rotation+306 @061c02>  : 10 0f                      dup.x32 sp(15)
	<rotation+308 @061c04>  : 10 04                      dup.x32 sp(4)
	<rotation+310 @061c06>  : 73                         mul.f32
	<rotation+311 @061c07>  : 72                         sub.f32
	<rotation+312 @061c08>  : 13 1b                      set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:148: (43 bytes: <rotation+314 @061c0a> - <rotation+357 @061c35>): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+314 @061c0a>  : 10 0a                      dup.x32 sp(10)
	<rotation+316 @061c0c>  : 10 09                      dup.x32 sp(9)
	<rotation+318 @061c0e>  : 10 05                      dup.x32 sp(5)
	<rotation+320 @061c10>  : 71                         add.f32
	<rotation+321 @061c11>  : 73                         mul.f32
	<rotation+322 @061c12>  : 10 0e                      dup.x32 sp(14)
	<rotation+324 @061c14>  : 10 0d                      dup.x32 sp(13)
	<rotation+326 @061c16>  : 10 11                      dup.x32 sp(17)
	<rotation+328 @061c18>  : 73                         mul.f32
	<rotation+329 @061c19>  : 10 0c                      dup.x32 sp(12)
	<rotation+331 @061c1b>  : 10 10                      dup.x32 sp(16)
	<rotation+333 @061c1d>  : 73                         mul.f32
	<rotation+334 @061c1e>  : 71                         add.f32
	<rotation+335 @061c1f>  : 73                         mul.f32
	<rotation+336 @061c20>  : 72                         sub.f32
	<rotation+337 @061c21>  : 10 01                      dup.x32 sp(1)
	<rotation+339 @061c23>  : 73                         mul.f32
	<rotation+340 @061c24>  : 10 0a                      dup.x32 sp(10)
	<rotation+342 @061c26>  : 10 10                      dup.x32 sp(16)
	<rotation+344 @061c28>  : 73                         mul.f32
	<rotation+345 @061c29>  : 10 0d                      dup.x32 sp(13)
	<rotation+347 @061c2b>  : 10 0f                      dup.x32 sp(15)
	<rotation+349 @061c2d>  : 73                         mul.f32
	<rotation+350 @061c2e>  : 72                         sub.f32
	<rotation+351 @061c2f>  : 10 04                      dup.x32 sp(4)
	<rotation+353 @061c31>  : 73                         mul.f32
	<rotation+354 @061c32>  : 71                         add.f32
	<rotation+355 @061c33>  : 13 1c                      set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes: <rotation+357 @061c35> - <rotation+370 @061c42>): .result.zx := xz * k - y * s;
	<rotation+357 @061c35>  : 10 06                      dup.x32 sp(6)
	<rotation+359 @061c37>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @061c39>  : 73                         mul.f32
	<rotation+362 @061c3a>  : 10 0e                      dup.x32 sp(14)
	<rotation+364 @061c3c>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @061c3e>  : 73                         mul.f32
	<rotation+367 @061c3f>  : 72                         sub.f32
	<rotation+368 @061c40>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:151: (13 bytes: <rotation+370 @061c42> - <rotation+383 @061c4f>): .result.zy := yz * k + x * s;
	<rotation+370 @061c42>  : 10 04                      dup.x32 sp(4)
	<rotation+372 @061c44>  : 10 01                      dup.x32 sp(1)
	<rotation+374 @061c46>  : 73                         mul.f32
	<rotation+375 @061c47>  : 10 0f                      dup.x32 sp(15)
	<rotation+377 @061c49>  : 10 04                      dup.x32 sp(4)
	<rotation+379 @061c4b>  : 73                         mul.f32
	<rotation+380 @061c4c>  : 71                         add.f32
	<rotation+381 @061c4d>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:152: (13 bytes: <rotation+383 @061c4f> - <rotation+396 @061c5c>): .result.zz := zz + (xx + yy) * c;
	<rotation+383 @061c4f>  : 10 03                      dup.x32 sp(3)
	<rotation+385 @061c51>  : 10 09                      dup.x32 sp(9)
	<rotation+387 @061c53>  : 10 07                      dup.x32 sp(7)
	<rotation+389 @061c55>  : 71                         add.f32
	<rotation+390 @061c56>  : 10 03                      dup.x32 sp(3)
	<rotation+392 @061c58>  : 73                         mul.f32
	<rotation+393 @061c59>  : 71                         add.f32
	<rotation+394 @061c5a>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:153: (43 bytes: <rotation+396 @061c5c> - <rotation+439 @061c87>): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+396 @061c5c>  : 10 09                      dup.x32 sp(9)
	<rotation+398 @061c5e>  : 10 09                      dup.x32 sp(9)
	<rotation+400 @061c60>  : 10 07                      dup.x32 sp(7)
	<rotation+402 @061c62>  : 71                         add.f32
	<rotation+403 @061c63>  : 73                         mul.f32
	<rotation+404 @061c64>  : 10 0d                      dup.x32 sp(13)
	<rotation+406 @061c66>  : 10 0d                      dup.x32 sp(13)
	<rotation+408 @061c68>  : 10 11                      dup.x32 sp(17)
	<rotation+410 @061c6a>  : 73                         mul.f32
	<rotation+411 @061c6b>  : 10 0d                      dup.x32 sp(13)
	<rotation+413 @061c6d>  : 10 11                      dup.x32 sp(17)
	<rotation+415 @061c6f>  : 73                         mul.f32
	<rotation+416 @061c70>  : 71                         add.f32
	<rotation+417 @061c71>  : 73                         mul.f32
	<rotation+418 @061c72>  : 72                         sub.f32
	<rotation+419 @061c73>  : 10 01                      dup.x32 sp(1)
	<rotation+421 @061c75>  : 73                         mul.f32
	<rotation+422 @061c76>  : 10 0c                      dup.x32 sp(12)
	<rotation+424 @061c78>  : 10 0f                      dup.x32 sp(15)
	<rotation+426 @061c7a>  : 73                         mul.f32
	<rotation+427 @061c7b>  : 10 0c                      dup.x32 sp(12)
	<rotation+429 @061c7d>  : 10 11                      dup.x32 sp(17)
	<rotation+431 @061c7f>  : 73                         mul.f32
	<rotation+432 @061c80>  : 72                         sub.f32
	<rotation+433 @061c81>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @061c83>  : 73                         mul.f32
	<rotation+436 @061c84>  : 71                         add.f32
	<rotation+437 @061c85>  : 13 20                      set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:155: (10 bytes: <rotation+439 @061c87> - <rotation+449 @061c91>): .result.w := vec4f(0, 0, 0, 1);
	<rotation+439 @061c87>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+444 @061c8c>  : 19                         load.z32
	<rotation+445 @061c8d>  : 19                         load.z32
	<rotation+446 @061c8e>  : 19                         load.z32
	<rotation+447 @061c8f>  : 15 24                      set.x128 sp(36)
	<rotation+449 @061c91>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+453 @061c95>  : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `rotation`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.offset: <@061c98>
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:163'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (88 bytes: <translation @061c98> - <translation+88 @061cf0>)
	cmplStd/lib/math/Matrix4f.ci:164: (88 bytes: <translation @061c98> - <translation+88 @061cf0>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:165: (7 bytes: <translation @061c98> - <translation+7 @061c9f>): .result.xx := (1);
	<translation @061c98>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @061c9d>    : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes: <translation+7 @061c9f> - <translation+10 @061ca2>): .result.xy := (0);
	<translation+7 @061c9f>    : 19                         load.z32
	<translation+8 @061ca0>    : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes: <translation+10 @061ca2> - <translation+13 @061ca5>): .result.xz := (0);
	<translation+10 @061ca2>   : 19                         load.z32
	<translation+11 @061ca3>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:165: (8 bytes: <translation+13 @061ca5> - <translation+21 @061cad>): .result.xw := direction.x * amount;
	<translation+13 @061ca5>   : 10 02                      dup.x32 sp(2)
	<translation+15 @061ca7>   : 28                         load.i32
	<translation+16 @061ca8>   : 10 02                      dup.x32 sp(2)
	<translation+18 @061caa>   : 73                         mul.f32
	<translation+19 @061cab>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes: <translation+21 @061cad> - <translation+24 @061cb0>): .result.yx := (0);
	<translation+21 @061cad>   : 19                         load.z32
	<translation+22 @061cae>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:166: (7 bytes: <translation+24 @061cb0> - <translation+31 @061cb7>): .result.yy := (1);
	<translation+24 @061cb0>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @061cb5>   : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes: <translation+31 @061cb7> - <translation+34 @061cba>): .result.yz := (0);
	<translation+31 @061cb7>   : 19                         load.z32
	<translation+32 @061cb8>   : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:166: (12 bytes: <translation+34 @061cba> - <translation+46 @061cc6>): .result.yw := direction.y * amount;
	<translation+34 @061cba>   : 10 02                      dup.x32 sp(2)
	<translation+36 @061cbc>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @061cc0>   : 28                         load.i32
	<translation+41 @061cc1>   : 10 02                      dup.x32 sp(2)
	<translation+43 @061cc3>   : 73                         mul.f32
	<translation+44 @061cc4>   : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes: <translation+46 @061cc6> - <translation+49 @061cc9>): .result.zx := (0);
	<translation+46 @061cc6>   : 19                         load.z32
	<translation+47 @061cc7>   : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes: <translation+49 @061cc9> - <translation+52 @061ccc>): .result.zy := (0);
	<translation+49 @061cc9>   : 19                         load.z32
	<translation+50 @061cca>   : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:167: (7 bytes: <translation+52 @061ccc> - <translation+59 @061cd3>): .result.zz := (1);
	<translation+52 @061ccc>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @061cd1>   : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:167: (12 bytes: <translation+59 @061cd3> - <translation+71 @061cdf>): .result.zw := direction.z * amount;
	<translation+59 @061cd3>   : 10 02                      dup.x32 sp(2)
	<translation+61 @061cd5>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @061cd9>   : 28                         load.i32
	<translation+66 @061cda>   : 10 02                      dup.x32 sp(2)
	<translation+68 @061cdc>   : 73                         mul.f32
	<translation+69 @061cdd>   : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+71 @061cdf> - <translation+74 @061ce2>): .result.wx := (0);
	<translation+71 @061cdf>   : 19                         load.z32
	<translation+72 @061ce0>   : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+74 @061ce2> - <translation+77 @061ce5>): .result.wy := (0);
	<translation+74 @061ce2>   : 19                         load.z32
	<translation+75 @061ce3>   : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+77 @061ce5> - <translation+80 @061ce8>): .result.wz := (0);
	<translation+77 @061ce5>   : 19                         load.z32
	<translation+78 @061ce6>   : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:168: (7 bytes: <translation+80 @061ce8> - <translation+87 @061cef>): .result.ww := (1);
	<translation+80 @061ce8>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @061ced>   : 13 13                      set.x32 sp(19)
	<translation+87 @061cef>   : 03                         ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.offset: <@061cf0>
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:173'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (217 bytes: <scale @061cf0> - <scale+217 @061dc9>)
	cmplStd/lib/math/Matrix4f.ci:175: (217 bytes: <scale @061cf0> - <scale+217 @061dc9>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:176: (55 bytes: <scale @061cf0> - <scale+55 @061d27>): .result.xx := rcp(direction.x * amount);
	<scale @061cf0>      : 10 02                      dup.x32 sp(2)
	<scale+2 @061cf2>    : 28                         load.i32
	<scale+3 @061cf3>    : 10 02                      dup.x32 sp(2)
	<scale+5 @061cf5>    : 73                         mul.f32
	<scale+6 @061cf6>    : 10 00                      dup.x32 sp(0)
	<scale+8 @061cf8>    : 19                         load.z32
	<scale+9 @061cf9>    : 78                         clt.f32
	<scale+10 @061cfa>   : 06 0b 00 00                jz <scale+21 @061d05>
	<scale+14 @061cfe>   : 10 00                      dup.x32 sp(0)
	<scale+16 @061d00>   : 70                         neg.f32
	<scale+17 @061d01>   : 04 06 00 00                jmp <scale+23 @061d07>
	<scale+21 @061d05>   : 10 00                      dup.x32 sp(0)
	<scale+23 @061d07>   : 7d                         f32.2f64
	<scale+24 @061d08>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @061d11>   : 88                         clt.f64
	<scale+34 @061d12>   : 06 09 00 00                jz <scale+43 @061d1b>
	<scale+38 @061d16>   : 19                         load.z32
	<scale+39 @061d17>   : 04 0c 00 00                jmp <scale+51 @061d23>
	<scale+43 @061d1b>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @061d20>   : 10 01                      dup.x32 sp(1)
	<scale+50 @061d22>   : 74                         div.f32
	<scale+51 @061d23>   : 13 01                      set.x32 sp(1)
	<scale+53 @061d25>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+55 @061d27> - <scale+58 @061d2a>): .result.xy := (0);
	<scale+55 @061d27>   : 19                         load.z32
	<scale+56 @061d28>   : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+58 @061d2a> - <scale+61 @061d2d>): .result.xz := (0);
	<scale+58 @061d2a>   : 19                         load.z32
	<scale+59 @061d2b>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+61 @061d2d> - <scale+64 @061d30>): .result.xw := (0);
	<scale+61 @061d2d>   : 19                         load.z32
	<scale+62 @061d2e>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+64 @061d30> - <scale+67 @061d33>): .result.yx := (0);
	<scale+64 @061d30>   : 19                         load.z32
	<scale+65 @061d31>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:177: (59 bytes: <scale+67 @061d33> - <scale+126 @061d6e>): .result.yy := rcp(direction.y * amount);
	<scale+67 @061d33>   : 10 02                      dup.x32 sp(2)
	<scale+69 @061d35>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @061d39>   : 28                         load.i32
	<scale+74 @061d3a>   : 10 02                      dup.x32 sp(2)
	<scale+76 @061d3c>   : 73                         mul.f32
	<scale+77 @061d3d>   : 10 00                      dup.x32 sp(0)
	<scale+79 @061d3f>   : 19                         load.z32
	<scale+80 @061d40>   : 78                         clt.f32
	<scale+81 @061d41>   : 06 0b 00 00                jz <scale+92 @061d4c>
	<scale+85 @061d45>   : 10 00                      dup.x32 sp(0)
	<scale+87 @061d47>   : 70                         neg.f32
	<scale+88 @061d48>   : 04 06 00 00                jmp <scale+94 @061d4e>
	<scale+92 @061d4c>   : 10 00                      dup.x32 sp(0)
	<scale+94 @061d4e>   : 7d                         f32.2f64
	<scale+95 @061d4f>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @061d58>  : 88                         clt.f64
	<scale+105 @061d59>  : 06 09 00 00                jz <scale+114 @061d62>
	<scale+109 @061d5d>  : 19                         load.z32
	<scale+110 @061d5e>  : 04 0c 00 00                jmp <scale+122 @061d6a>
	<scale+114 @061d62>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @061d67>  : 10 01                      dup.x32 sp(1)
	<scale+121 @061d69>  : 74                         div.f32
	<scale+122 @061d6a>  : 13 01                      set.x32 sp(1)
	<scale+124 @061d6c>  : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+126 @061d6e> - <scale+129 @061d71>): .result.yz := (0);
	<scale+126 @061d6e>  : 19                         load.z32
	<scale+127 @061d6f>  : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+129 @061d71> - <scale+132 @061d74>): .result.yw := (0);
	<scale+129 @061d71>  : 19                         load.z32
	<scale+130 @061d72>  : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+132 @061d74> - <scale+135 @061d77>): .result.zx := (0);
	<scale+132 @061d74>  : 19                         load.z32
	<scale+133 @061d75>  : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+135 @061d77> - <scale+138 @061d7a>): .result.zy := (0);
	<scale+135 @061d77>  : 19                         load.z32
	<scale+136 @061d78>  : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:178: (59 bytes: <scale+138 @061d7a> - <scale+197 @061db5>): .result.zz := rcp(direction.z * amount);
	<scale+138 @061d7a>  : 10 02                      dup.x32 sp(2)
	<scale+140 @061d7c>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @061d80>  : 28                         load.i32
	<scale+145 @061d81>  : 10 02                      dup.x32 sp(2)
	<scale+147 @061d83>  : 73                         mul.f32
	<scale+148 @061d84>  : 10 00                      dup.x32 sp(0)
	<scale+150 @061d86>  : 19                         load.z32
	<scale+151 @061d87>  : 78                         clt.f32
	<scale+152 @061d88>  : 06 0b 00 00                jz <scale+163 @061d93>
	<scale+156 @061d8c>  : 10 00                      dup.x32 sp(0)
	<scale+158 @061d8e>  : 70                         neg.f32
	<scale+159 @061d8f>  : 04 06 00 00                jmp <scale+165 @061d95>
	<scale+163 @061d93>  : 10 00                      dup.x32 sp(0)
	<scale+165 @061d95>  : 7d                         f32.2f64
	<scale+166 @061d96>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @061d9f>  : 88                         clt.f64
	<scale+176 @061da0>  : 06 09 00 00                jz <scale+185 @061da9>
	<scale+180 @061da4>  : 19                         load.z32
	<scale+181 @061da5>  : 04 0c 00 00                jmp <scale+193 @061db1>
	<scale+185 @061da9>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @061dae>  : 10 01                      dup.x32 sp(1)
	<scale+192 @061db0>  : 74                         div.f32
	<scale+193 @061db1>  : 13 01                      set.x32 sp(1)
	<scale+195 @061db3>  : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+197 @061db5> - <scale+200 @061db8>): .result.zw := (0);
	<scale+197 @061db5>  : 19                         load.z32
	<scale+198 @061db6>  : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+200 @061db8> - <scale+203 @061dbb>): .result.wx := (0);
	<scale+200 @061db8>  : 19                         load.z32
	<scale+201 @061db9>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+203 @061dbb> - <scale+206 @061dbe>): .result.wy := (0);
	<scale+203 @061dbb>  : 19                         load.z32
	<scale+204 @061dbc>  : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+206 @061dbe> - <scale+209 @061dc1>): .result.wz := (0);
	<scale+206 @061dbe>  : 19                         load.z32
	<scale+207 @061dbf>  : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:179: (7 bytes: <scale+209 @061dc1> - <scale+216 @061dc8>): .result.ww := (1);
	<scale+209 @061dc1>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @061dc6>  : 13 13                      set.x32 sp(19)
	<scale+216 @061dc8>  : 03                         ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02f560>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@061dd0>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <vec2d @061dd0> - <vec2d+7 @061dd7>)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes: <vec2d @061dd0> - <vec2d+7 @061dd7>): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes: <vec2d @061dd0> - <vec2d+3 @061dd3>): .result.x := x;
	<vec2d @061dd0>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes: <vec2d+3 @061dd3> - <vec2d+6 @061dd6>): .result.y := y;
	<vec2d+3 @061dd3>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @061dd6>    : 03                         ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), div.p2d)))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), min.p2d)))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), max.p2d)))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.offset: <@061dd8>
.name: 'length'
.file: 'cmplStd/lib/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <length @061dd8> - <length+38 @061dfe>)
	cmplStd/lib/string.ci:5: (16 bytes: <length @061dd8> - <length+16 @061de8>): if ((str) == null)
	<length @061dd8>      : 10 01                      dup.x32 sp(1)
	<length+2 @061dda>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @061ddf>    : 57                         ceq.i32
	<length+8 @061de0>    : 06 08 00 00                jz <length+16 @061de8>
	cmplStd/lib/string.ci:6: (4 bytes: <length+12 @061de4> - <length+16 @061de8>): return .result := 0;
	<length+12 @061de4>   : 19                         load.z32
	<length+13 @061de5>   : 13 03                      set.x32 sp(3)
	<length+15 @061de7>   : 03                         ret
	cmplStd/lib/string.ci:8: (1 byte: <length+16 @061de8> - <length+17 @061de9>): result: int32 := 0
	<length+16 @061de8>   : 19                         load.z32
	cmplStd/lib/string.ci:9: (18 bytes: <length+17 @061de9> - <length+35 @061dfb>): for ( ; str[result]; result := result + 1)
	<length+17 @061de9>   : 04 08 00 00                jmp <length+25 @061df1>
	cmplStd/lib/string.ci:9: (4 bytes: <length+21 @061ded> - <length+25 @061df1>): result := result + 1
	<length+21 @061ded>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:9: (10 bytes: <length+25 @061df1> - <length+35 @061dfb>): str[result]
	<length+25 @061df1>   : 10 02                      dup.x32 sp(2)
	<length+27 @061df3>   : 10 01                      dup.x32 sp(1)
	<length+29 @061df5>   : 51                         add.i32
	<length+30 @061df6>   : 26                         load.i8
	<length+31 @061df7>   : 05 f6 ff ff                jnz <length+21 @061ded>
	cmplStd/lib/string.ci:11: (3 bytes: <length+35 @061dfb> - <length+38 @061dfe>): return .result := result;
	<length+35 @061dfb>   : 13 03                      set.x32 sp(3)
	<length+37 @061dfd>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:48: referenced as `length`
	cmplStd/lib/string.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@061e00>
.name: 'indexOf'
.file: 'cmplStd/lib/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <indexOf @061e00> - <indexOf+50 @061e32>)
	cmplStd/lib/string.ci:16: (42 bytes: <indexOf @061e00> - <indexOf+42 @061e2a>): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf @061e00>      : 19                         load.z32
	<indexOf+1 @061e01>    : 04 1b 00 00                jmp <indexOf+28 @061e1c>
	cmplStd/lib/string.ci:17: (19 bytes: <indexOf+5 @061e05> - <indexOf+24 @061e18>): if (str[i] == chr)
	<indexOf+5 @061e05>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @061e07>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @061e09>    : 51                         add.i32
	<indexOf+10 @061e0a>   : 26                         load.i8
	<indexOf+11 @061e0b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @061e0f>   : 26                         load.i8
	<indexOf+16 @061e10>   : 57                         ceq.i32
	<indexOf+17 @061e11>   : 06 07 00 00                jz <indexOf+24 @061e18>
	cmplStd/lib/string.ci:18: (3 bytes: <indexOf+21 @061e15> - <indexOf+24 @061e18>): return .result := i;
	<indexOf+21 @061e15>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @061e17>   : 03                         ret
	cmplStd/lib/string.ci:16: (4 bytes: <indexOf+24 @061e18> - <indexOf+28 @061e1c>): i := i + 1
	<indexOf+24 @061e18>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:16: (10 bytes: <indexOf+28 @061e1c> - <indexOf+38 @061e26>): str[i]
	<indexOf+28 @061e1c>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @061e1e>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @061e20>   : 51                         add.i32
	<indexOf+33 @061e21>   : 26                         load.i8
	<indexOf+34 @061e22>   : 05 e3 ff ff                jnz <indexOf+5 @061e05>
	<indexOf+38 @061e26>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:21: (8 bytes: <indexOf+42 @061e2a> - <indexOf+50 @061e32>): return .result := -1;
	<indexOf+42 @061e2a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @061e2f>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @061e31>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:98: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@061e38>
.name: 'lastIndexOf'
.file: 'cmplStd/lib/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <lastIndexOf @061e38> - <lastIndexOf+50 @061e6a>)
	cmplStd/lib/string.ci:26: (5 bytes: <lastIndexOf @061e38> - <lastIndexOf+5 @061e3d>): result: int32 := -1
	<lastIndexOf @061e38>      : 1c ff ff ff ff             load.c32 -1
	cmplStd/lib/string.ci:27: (42 bytes: <lastIndexOf+5 @061e3d> - <lastIndexOf+47 @061e67>): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+5 @061e3d>    : 19                         load.z32
	<lastIndexOf+6 @061e3e>    : 04 1b 00 00                jmp <lastIndexOf+33 @061e59>
	cmplStd/lib/string.ci:28: (19 bytes: <lastIndexOf+10 @061e42> - <lastIndexOf+29 @061e55>): if (str[i] == chr)
	<lastIndexOf+10 @061e42>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @061e44>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @061e46>   : 51                         add.i32
	<lastIndexOf+15 @061e47>   : 26                         load.i8
	<lastIndexOf+16 @061e48>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @061e4c>   : 26                         load.i8
	<lastIndexOf+21 @061e4d>   : 57                         ceq.i32
	<lastIndexOf+22 @061e4e>   : 06 07 00 00                jz <lastIndexOf+29 @061e55>
	cmplStd/lib/string.ci:29: (3 bytes: <lastIndexOf+26 @061e52> - <lastIndexOf+29 @061e55>): result := i;
	<lastIndexOf+26 @061e52>   : 16 01 00                   mov.x32 sp(1, 0)
	cmplStd/lib/string.ci:27: (4 bytes: <lastIndexOf+29 @061e55> - <lastIndexOf+33 @061e59>): i := i + 1
	<lastIndexOf+29 @061e55>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:27: (10 bytes: <lastIndexOf+33 @061e59> - <lastIndexOf+43 @061e63>): str[i]
	<lastIndexOf+33 @061e59>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @061e5b>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @061e5d>   : 51                         add.i32
	<lastIndexOf+38 @061e5e>   : 26                         load.i8
	<lastIndexOf+39 @061e5f>   : 05 e3 ff ff                jnz <lastIndexOf+10 @061e42>
	<lastIndexOf+43 @061e63>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:32: (3 bytes: <lastIndexOf+47 @061e67> - <lastIndexOf+50 @061e6a>): return .result := result;
	<lastIndexOf+47 @061e67>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @061e69>   : 03                         ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.offset: <@061e70>
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <startsWith @061e70> - <startsWith+73 @061eb9>)
	cmplStd/lib/string.ci:37: (62 bytes: <startsWith @061e70> - <startsWith+62 @061eae>): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith @061e70>      : 19                         load.z32
	<startsWith+1 @061e71>    : 04 2d 00 00                jmp <startsWith+46 @061e9e>
	cmplStd/lib/string.ci:38: (37 bytes: <startsWith+5 @061e75> - <startsWith+42 @061e9a>): if (cmp(str[i], with[i]) != 0)
	<startsWith+5 @061e75>    : 19                         load.z32
	<startsWith+6 @061e76>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @061e78>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @061e7a>   : 51                         add.i32
	<startsWith+11 @061e7b>   : 26                         load.i8
	<startsWith+12 @061e7c>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @061e7e>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @061e80>   : 51                         add.i32
	<startsWith+17 @061e81>   : 26                         load.i8
	<startsWith+18 @061e82>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @061e84>   : 02                         call
	<startsWith+21 @061e85>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @061e89>   : 19                         load.z32
	<startsWith+26 @061e8a>   : 57                         ceq.i32
	<startsWith+27 @061e8b>   : 05 0f 00 00                jnz <startsWith+42 @061e9a>
	cmplStd/lib/string.ci:39: (11 bytes: <startsWith+31 @061e8f> - <startsWith+42 @061e9a>): return .result := false;
	<startsWith+31 @061e8f>   : 19                         load.z32
	<startsWith+32 @061e90>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @061e94>   : 2b                         store.i8
	<startsWith+37 @061e95>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @061e99>   : 03                         ret
	cmplStd/lib/string.ci:37: (4 bytes: <startsWith+42 @061e9a> - <startsWith+46 @061e9e>): i := i + 1
	<startsWith+42 @061e9a>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:37: (12 bytes: <startsWith+46 @061e9e> - <startsWith+58 @061eaa>): (with[i]) != 0
	<startsWith+46 @061e9e>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @061ea0>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @061ea2>   : 51                         add.i32
	<startsWith+51 @061ea3>   : 26                         load.i8
	<startsWith+52 @061ea4>   : 19                         load.z32
	<startsWith+53 @061ea5>   : 57                         ceq.i32
	<startsWith+54 @061ea6>   : 06 cf ff ff                jz <startsWith+5 @061e75>
	<startsWith+58 @061eaa>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:42: (11 bytes: <startsWith+62 @061eae> - <startsWith+73 @061eb9>): return .result := true;
	<startsWith+62 @061eae>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @061eb3>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @061eb7>   : 2b                         store.i8
	<startsWith+72 @061eb8>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:92: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.offset: <@061ec0>
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <endsWith @061ec0> - <endsWith+126 @061f3e>)
	cmplStd/lib/string.ci:47: (13 bytes: <endsWith @061ec0> - <endsWith+13 @061ecd>): withLen: int32 := length(with)
	<endsWith @061ec0>      : 19                         load.z32
	<endsWith+1 @061ec1>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @061ec3>    : 1f d8 1d 06 00             load.ref <@061dd8> ;length(str: char[*]): int32
	<endsWith+8 @061ec8>    : 02                         call
	<endsWith+9 @061ec9>    : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:48: (13 bytes: <endsWith+13 @061ecd> - <endsWith+26 @061eda>): strLen: int32 := length(str)
	<endsWith+13 @061ecd>   : 19                         load.z32
	<endsWith+14 @061ece>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @061ed0>   : 1f d8 1d 06 00             load.ref <@061dd8> ;length(str: char[*]): int32
	<endsWith+21 @061ed5>   : 02                         call
	<endsWith+22 @061ed6>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:49: (20 bytes: <endsWith+26 @061eda> - <endsWith+46 @061eee>): if (strLen < withLen)
	<endsWith+26 @061eda>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @061edc>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @061ede>   : 58                         clt.i32
	<endsWith+31 @061edf>   : 06 0f 00 00                jz <endsWith+46 @061eee>
	cmplStd/lib/string.ci:50: (11 bytes: <endsWith+35 @061ee3> - <endsWith+46 @061eee>): return .result := false;
	<endsWith+35 @061ee3>   : 19                         load.z32
	<endsWith+36 @061ee4>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @061ee8>   : 2b                         store.i8
	<endsWith+41 @061ee9>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @061eed>   : 03                         ret
	cmplStd/lib/string.ci:52: (65 bytes: <endsWith+46 @061eee> - <endsWith+111 @061f2f>): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+46 @061eee>   : 19                         load.z32
	<endsWith+47 @061eef>   : 04 33 00 00                jmp <endsWith+98 @061f22>
	cmplStd/lib/string.ci:53: (43 bytes: <endsWith+51 @061ef3> - <endsWith+94 @061f1e>): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+51 @061ef3>   : 19                         load.z32
	<endsWith+52 @061ef4>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @061ef6>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @061ef8>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @061efa>   : 52                         sub.i32
	<endsWith+59 @061efb>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @061efd>   : 51                         add.i32
	<endsWith+62 @061efe>   : 51                         add.i32
	<endsWith+63 @061eff>   : 26                         load.i8
	<endsWith+64 @061f00>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @061f02>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @061f04>   : 51                         add.i32
	<endsWith+69 @061f05>   : 26                         load.i8
	<endsWith+70 @061f06>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @061f08>   : 02                         call
	<endsWith+73 @061f09>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @061f0d>   : 19                         load.z32
	<endsWith+78 @061f0e>   : 57                         ceq.i32
	<endsWith+79 @061f0f>   : 05 0f 00 00                jnz <endsWith+94 @061f1e>
	cmplStd/lib/string.ci:54: (11 bytes: <endsWith+83 @061f13> - <endsWith+94 @061f1e>): return .result := false;
	<endsWith+83 @061f13>   : 19                         load.z32
	<endsWith+84 @061f14>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @061f18>   : 2b                         store.i8
	<endsWith+89 @061f19>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @061f1d>   : 03                         ret
	cmplStd/lib/string.ci:52: (4 bytes: <endsWith+94 @061f1e> - <endsWith+98 @061f22>): i := i + 1
	<endsWith+94 @061f1e>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:52: (9 bytes: <endsWith+98 @061f22> - <endsWith+107 @061f2b>): i < withLen
	<endsWith+98 @061f22>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @061f24>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @061f26>  : 58                         clt.i32
	<endsWith+103 @061f27>  : 05 cc ff ff                jnz <endsWith+51 @061ef3>
	<endsWith+107 @061f2b>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:57: (15 bytes: <endsWith+111 @061f2f> - <endsWith+126 @061f3e>): return .result := true;
	<endsWith+111 @061f2f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @061f34>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @061f38>  : 2b                         store.i8
	<endsWith+121 @061f39>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @061f3d>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:93: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@061f40>
.name: 'compare'
.file: 'cmplStd/lib/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <compare @061f40> - <compare+63 @061f7f>)
	cmplStd/lib/string.ci:62: (1 byte: <compare @061f40> - <compare+1 @061f41>): result: int32 := 0
	<compare @061f40>      : 19                         load.z32
	cmplStd/lib/string.ci:63: (59 bytes: <compare+1 @061f41> - <compare+60 @061f7c>): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+1 @061f41>    : 19                         load.z32
	<compare+2 @061f42>    : 04 2e 00 00                jmp <compare+48 @061f70>
	cmplStd/lib/string.ci:64: (22 bytes: <compare+6 @061f46> - <compare+28 @061f5c>): result := cmp(str[i], with[i]);
	<compare+6 @061f46>    : 19                         load.z32
	<compare+7 @061f47>    : 10 06                      dup.x32 sp(6)
	<compare+9 @061f49>    : 10 02                      dup.x32 sp(2)
	<compare+11 @061f4b>   : 51                         add.i32
	<compare+12 @061f4c>   : 26                         load.i8
	<compare+13 @061f4d>   : 10 06                      dup.x32 sp(6)
	<compare+15 @061f4f>   : 10 03                      dup.x32 sp(3)
	<compare+17 @061f51>   : 51                         add.i32
	<compare+18 @061f52>   : 26                         load.i8
	<compare+19 @061f53>   : 10 06                      dup.x32 sp(6)
	<compare+21 @061f55>   : 02                         call
	<compare+22 @061f56>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @061f5a>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:65: (16 bytes: <compare+28 @061f5c> - <compare+44 @061f6c>): if ((str[i]) == 0)
	<compare+28 @061f5c>   : 10 05                      dup.x32 sp(5)
	<compare+30 @061f5e>   : 10 01                      dup.x32 sp(1)
	<compare+32 @061f60>   : 51                         add.i32
	<compare+33 @061f61>   : 26                         load.i8
	<compare+34 @061f62>   : 19                         load.z32
	<compare+35 @061f63>   : 57                         ceq.i32
	<compare+36 @061f64>   : 06 08 00 00                jz <compare+44 @061f6c>
	cmplStd/lib/string.ci:66: (4 bytes: <compare+40 @061f68> - <compare+44 @061f6c>): break;
	<compare+40 @061f68>   : 04 10 00 00                jmp <compare+56 @061f78>
	cmplStd/lib/string.ci:63: (4 bytes: <compare+44 @061f6c> - <compare+48 @061f70>): i := i + 1
	<compare+44 @061f6c>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:63: (8 bytes: <compare+48 @061f70> - <compare+56 @061f78>): result == 0
	<compare+48 @061f70>   : 10 01                      dup.x32 sp(1)
	<compare+50 @061f72>   : 19                         load.z32
	<compare+51 @061f73>   : 57                         ceq.i32
	<compare+52 @061f74>   : 05 d2 ff ff                jnz <compare+6 @061f46>
	<compare+56 @061f78>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:69: (3 bytes: <compare+60 @061f7c> - <compare+63 @061f7f>): return .result := result;
	<compare+60 @061f7c>   : 13 05                      set.x32 sp(5)
	<compare+62 @061f7e>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:95: referenced as `compare`
	cmplStd/lib/string.ci:94: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.offset: <@061fc8>
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <ignCaseCmp @061fc8> - <ignCaseCmp+36 @061fec>)
	cmplStd/lib/string.ci:84: (36 bytes: <ignCaseCmp @061fc8> - <ignCaseCmp+36 @061fec>): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp @061fc8>      : 19                         load.z32
	<ignCaseCmp+1 @061fc9>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @061fcd>    : 26                         load.i8
	<ignCaseCmp+6 @061fce>    : 1f 80 1f 06 00             load.ref <@061f80> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @061fd3>   : 02                         call
	<ignCaseCmp+12 @061fd4>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @061fd8>   : 19                         load.z32
	<ignCaseCmp+17 @061fd9>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @061fdd>   : 26                         load.i8
	<ignCaseCmp+22 @061fde>   : 1f 80 1f 06 00             load.ref <@061f80> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @061fe3>   : 02                         call
	<ignCaseCmp+28 @061fe4>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @061fe8>   : 52                         sub.i32
	<ignCaseCmp+33 @061fe9>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @061feb>   : 03                         ret
.usages:
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.offset: <@061ff0>
.name: 'caseCmp'
.file: 'cmplStd/lib/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <caseCmp @061ff0> - <caseCmp+14 @061ffe>)
	cmplStd/lib/string.ci:89: (14 bytes: <caseCmp @061ff0> - <caseCmp+14 @061ffe>): return .result := chr - with;
	<caseCmp @061ff0>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @061ff4>    : 26                         load.i8
	<caseCmp+5 @061ff5>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @061ff9>    : 26                         load.i8
	<caseCmp+10 @061ffa>   : 52                         sub.i32
	<caseCmp+11 @061ffb>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @061ffd>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:95: referenced as `caseCmp`
	cmplStd/lib/string.ci:94: referenced as `caseCmp`
	cmplStd/lib/string.ci:93: referenced as `caseCmp`
	cmplStd/lib/string.ci:92: referenced as `caseCmp`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'cmplStd/lib/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'equals'
.file: 'cmplStd/lib/string.ci:95'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: bool(compare(void(void(str, with), caseCmp)) == 0)
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'cmplStd/lib/string.ci:98'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	cmplStd/lib/string.ci:182: referenced as `contains`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@035060>
.name: 'FormatFlags'
.file: 'cmplStd/lib/string.ci:112'
.field showSign: bool (size: 1, offs: <+0>, cast: const variable(bool))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	cmplStd/lib/string.ci:263: referenced as `FormatFlags`
	cmplStd/lib/string.ci:259: referenced as `FormatFlags`
	cmplStd/lib/string.ci:241: referenced as `FormatFlags`
	cmplStd/lib/string.ci:235: referenced as `FormatFlags`
	cmplStd/lib/string.ci:234: referenced as `FormatFlags`
	cmplStd/lib/string.ci:231: referenced as `FormatFlags`
	cmplStd/lib/string.ci:229: referenced as `FormatFlags`
	cmplStd/lib/string.ci:227: referenced as `FormatFlags`
	cmplStd/lib/string.ci:225: referenced as `FormatFlags`
	cmplStd/lib/string.ci:223: referenced as `FormatFlags`
	cmplStd/lib/string.ci:221: referenced as `FormatFlags`
	cmplStd/lib/string.ci:219: referenced as `FormatFlags`
	cmplStd/lib/string.ci:217: referenced as `FormatFlags`
	cmplStd/lib/string.ci:144: referenced as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.offset: <+0>
.name: 'showSign'
.file: 'cmplStd/lib/string.ci:114'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	cmplStd/lib/string.ci:242: referenced as `showSign`
	cmplStd/lib/string.ci:236: referenced as `showSign`
	cmplStd/lib/string.ci:236: referenced as `showSign`
	cmplStd/lib/string.ci:151: referenced as `showSign`
	internal usages: 1
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'cmplStd/lib/string.ci:117'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	cmplStd/lib/string.ci:253: referenced as `precision`
	cmplStd/lib/string.ci:243: referenced as `precision`
	cmplStd/lib/string.ci:245: referenced as `precision`
	cmplStd/lib/string.ci:237: referenced as `precision`
	cmplStd/lib/string.ci:239: referenced as `precision`
	cmplStd/lib/string.ci:157: referenced as `precision`
	internal usages: 1
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'cmplStd/lib/string.ci:120'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	cmplStd/lib/string.ci:244: referenced as `padChr`
	cmplStd/lib/string.ci:238: referenced as `padChr`
	cmplStd/lib/string.ci:238: referenced as `padChr`
	cmplStd/lib/string.ci:174: referenced as `padChr`
	internal usages: 1
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'cmplStd/lib/string.ci:123'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/string.ci:245: referenced as `padLen`
	cmplStd/lib/string.ci:239: referenced as `padLen`
	cmplStd/lib/string.ci:239: referenced as `padLen`
	cmplStd/lib/string.ci:172: referenced as `padLen`
	internal usages: 1
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 84
.offset: <@062000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:127'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <append @062000> - <append+84 @062054>)
	cmplStd/lib/string.ci:128: (56 bytes: <append @062000> - <append+56 @062038>): for (i: int32 := 0; value[i]; i := i + 1)
	<append @062000>      : 19                         load.z32
	<append+1 @062001>    : 04 29 00 00                jmp <append+42 @06202a>
	cmplStd/lib/string.ci:129: (13 bytes: <append+5 @062005> - <append+18 @062012>): if (pos >= (output.length))
	<append+5 @062005>    : 10 03                      dup.x32 sp(3)
	<append+7 @062007>    : 10 06                      dup.x32 sp(6)
	<append+9 @062009>    : 58                         clt.i32
	<append+10 @06200a>   : 05 08 00 00                jnz <append+18 @062012>
	cmplStd/lib/string.ci:130: (4 bytes: <append+14 @06200e> - <append+18 @062012>): break;
	<append+14 @06200e>   : 04 26 00 00                jmp <append+52 @062034>
	cmplStd/lib/string.ci:132: (12 bytes: <append+18 @062012> - <append+30 @06201e>): output[pos] := value[i];
	<append+18 @062012>   : 10 02                      dup.x32 sp(2)
	<append+20 @062014>   : 10 01                      dup.x32 sp(1)
	<append+22 @062016>   : 51                         add.i32
	<append+23 @062017>   : 26                         load.i8
	<append+24 @062018>   : 10 05                      dup.x32 sp(5)
	<append+26 @06201a>   : 10 05                      dup.x32 sp(5)
	<append+28 @06201c>   : 51                         add.i32
	<append+29 @06201d>   : 2b                         store.i8
	cmplStd/lib/string.ci:133: (8 bytes: <append+30 @06201e> - <append+38 @062026>): pos := pos + 1;
	<append+30 @06201e>   : 10 03                      dup.x32 sp(3)
	<append+32 @062020>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @062024>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:128: (4 bytes: <append+38 @062026> - <append+42 @06202a>): i := i + 1
	<append+38 @062026>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:128: (10 bytes: <append+42 @06202a> - <append+52 @062034>): value[i]
	<append+42 @06202a>   : 10 02                      dup.x32 sp(2)
	<append+44 @06202c>   : 10 01                      dup.x32 sp(1)
	<append+46 @06202e>   : 51                         add.i32
	<append+47 @06202f>   : 26                         load.i8
	<append+48 @062030>   : 05 d5 ff ff                jnz <append+5 @062005>
	<append+52 @062034>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:136: (17 bytes: <append+56 @062038> - <append+73 @062049>): if (pos >= (output.length))
	<append+56 @062038>   : 10 02                      dup.x32 sp(2)
	<append+58 @06203a>   : 10 05                      dup.x32 sp(5)
	<append+60 @06203c>   : 58                         clt.i32
	<append+61 @06203d>   : 05 0c 00 00                jnz <append+73 @062049>
	cmplStd/lib/string.ci:137: (8 bytes: <append+65 @062041> - <append+73 @062049>): pos := (output.length - (1));
	<append+65 @062041>   : 10 04                      dup.x32 sp(4)
	<append+67 @062043>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @062047>   : 13 03                      set.x32 sp(3)
	cmplStd/lib/string.ci:139: (7 bytes: <append+73 @062049> - <append+80 @062050>): output[pos] := (0);
	<append+73 @062049>   : 19                         load.z32
	<append+74 @06204a>   : 10 04                      dup.x32 sp(4)
	<append+76 @06204c>   : 10 04                      dup.x32 sp(4)
	<append+78 @06204e>   : 51                         add.i32
	<append+79 @06204f>   : 2b                         store.i8
	cmplStd/lib/string.ci:140: (4 bytes: <append+80 @062050> - <append+84 @062054>): return .result := pos;
	<append+80 @062050>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @062053>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:252: referenced as `append`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 707
.offset: <@062068>
.name: 'append'
.file: 'cmplStd/lib/string.ci:144'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	if (format.showSign) {
		if (bool((sign) == 0)) {
			char(sign := '+');
		}
	}
	radix: int32 := format.precision;
	if (bool(radix == 0)) {
		int32(radix := 10);
	}
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (707 bytes: <append @062068> - <append+707 @06232b>)
	cmplStd/lib/string.ci:148: (1 byte: <append @062068> - <append+1 @062069>): len: int32 := 0
	<append @062068>      : 19                         load.z32
	cmplStd/lib/string.ci:149: (4 bytes: <append+1 @062069> - <append+5 @06206d>): digits: char[80] := {...}
	<append+1 @062069>    : 09 50 00 00                inc.sp(+80)
	cmplStd/lib/string.ci:151: (28 bytes: <append+5 @06206d> - <append+33 @062089>): if (format.showSign)
	<append+5 @06206d>    : 10 16                      dup.x32 sp(22)
	<append+7 @06206f>    : 26                         load.i8
	<append+8 @062070>    : 06 19 00 00                jz <append+33 @062089>
	cmplStd/lib/string.ci:152: (21 bytes: <append+12 @062074> - <append+33 @062089>): if ((sign) == 0)
	<append+12 @062074>   : 0a 64 00 00                load.sp(+100)
	<append+16 @062078>   : 26                         load.i8
	<append+17 @062079>   : 19                         load.z32
	<append+18 @06207a>   : 57                         ceq.i32
	<append+19 @06207b>   : 06 0e 00 00                jz <append+33 @062089>
	cmplStd/lib/string.ci:153: (10 bytes: <append+23 @06207f> - <append+33 @062089>): sign := '+';
	<append+23 @06207f>   : 1c 2b 00 00 00             load.c32 43
	<append+28 @062084>   : 0a 68 00 00                load.sp(+104)
	<append+32 @062088>   : 2b                         store.i8
	cmplStd/lib/string.ci:157: (7 bytes: <append+33 @062089> - <append+40 @062090>): radix: int32 := format.precision
	<append+33 @062089>   : 10 16                      dup.x32 sp(22)
	<append+35 @06208b>   : 0c 04 00 00                inc.i32(+4)
	<append+39 @06208f>   : 28                         load.i32
	cmplStd/lib/string.ci:158: (15 bytes: <append+40 @062090> - <append+55 @06209f>): if (radix == 0)
	<append+40 @062090>   : 10 00                      dup.x32 sp(0)
	<append+42 @062092>   : 19                         load.z32
	<append+43 @062093>   : 57                         ceq.i32
	<append+44 @062094>   : 06 0b 00 00                jz <append+55 @06209f>
	cmplStd/lib/string.ci:159: (7 bytes: <append+48 @062098> - <append+55 @06209f>): radix := 10;
	<append+48 @062098>   : 1c 0a 00 00 00             load.c32 10
	<append+53 @06209d>   : 13 01                      set.x32 sp(1)
	cmplStd/lib/string.ci:161: (54 bytes: <append+55 @06209f> - <append+109 @0620d5>): assert(radix > 1, "radix is too small", radix);
	<append+55 @06209f>   : 10 00                      dup.x32 sp(0)
	<append+57 @0620a1>   : 1c 01 00 00 00             load.c32 1
	<append+62 @0620a6>   : 59                         cgt.i32
	<append+63 @0620a7>   : 06 08 00 00                jz <append+71 @0620af>
	<append+67 @0620ab>   : 04 2a 00 00                jmp <append+109 @0620d5>
	<append+71 @0620af>   : 1f 80 11 03 00             load.ref <@031180> ;"cmplStd/lib/string.ci"
	<append+76 @0620b4>   : 1c a1 00 00 00             load.c32 161
	<append+81 @0620b9>   : 1c fe ff ff ff             load.c32 -2
	<append+86 @0620be>   : 1c 80 00 00 00             load.c32 128
	<append+91 @0620c3>   : 1f 23 15 03 00             load.ref <@031523> ;"radix is too small"
	<append+96 @0620c8>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+101 @0620cd>  : 0a 18 00 00                load.sp(+24)
	<append+105 @0620d1>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:162: (53 bytes: <append+109 @0620d5> - <append+162 @06210a>): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+109 @0620d5>  : 10 00                      dup.x32 sp(0)
	<append+111 @0620d7>  : 20 64 20 06                load.m32 <@062064> ;append.radixDigits+4
	<append+115 @0620db>  : 58                         clt.i32
	<append+116 @0620dc>  : 06 08 00 00                jz <append+124 @0620e4>
	<append+120 @0620e0>  : 04 2a 00 00                jmp <append+162 @06210a>
	<append+124 @0620e4>  : 1f 80 11 03 00             load.ref <@031180> ;"cmplStd/lib/string.ci"
	<append+129 @0620e9>  : 1c a2 00 00 00             load.c32 162
	<append+134 @0620ee>  : 1c fe ff ff ff             load.c32 -2
	<append+139 @0620f3>  : 1c 80 00 00 00             load.c32 128
	<append+144 @0620f8>  : 1f 36 15 03 00             load.ref <@031536> ;"radix is too big"
	<append+149 @0620fd>  : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+154 @062102>  : 0a 18 00 00                load.sp(+24)
	<append+158 @062106>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:165: (49 bytes: <append+162 @06210a> - <append+211 @06213b>): for ( ; value > (0); value := value / (radix))
	<append+162 @06210a>  : 04 29 00 00                jmp <append+203 @062133>
	cmplStd/lib/string.ci:166: (29 bytes: <append+166 @06210e> - <append+195 @06212b>): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+166 @06210e>  : 20 60 20 06                load.m32 <@062060> ;append.radixDigits
	<append+170 @062112>  : 11 19                      dup.x64 sp(25)
	<append+172 @062114>  : 10 03                      dup.x32 sp(3)
	<append+174 @062116>  : 5b                         i32.2i64
	<append+175 @062117>  : 45                         mod.u64
	<append+176 @062118>  : 6a                         i64.2i32
	<append+177 @062119>  : 51                         add.i32
	<append+178 @06211a>  : 26                         load.i8
	<append+179 @06211b>  : 0a 08 00 00                load.sp(+8)
	<append+183 @06211f>  : 10 17                      dup.x32 sp(23)
	<append+185 @062121>  : 0c 01 00 00                inc.i32(+1)
	<append+189 @062125>  : 10 00                      dup.x32 sp(0)
	<append+191 @062127>  : 13 19                      set.x32 sp(25)
	<append+193 @062129>  : 51                         add.i32
	<append+194 @06212a>  : 2b                         store.i8
	cmplStd/lib/string.ci:165: (8 bytes: <append+195 @06212b> - <append+203 @062133>): value := value / (radix)
	<append+195 @06212b>  : 11 18                      dup.x64 sp(24)
	<append+197 @06212d>  : 10 02                      dup.x32 sp(2)
	<append+199 @06212f>  : 5b                         i32.2i64
	<append+200 @062130>  : 44                         div.u64
	<append+201 @062131>  : 14 1a                      set.x64 sp(26)
	cmplStd/lib/string.ci:165: (8 bytes: <append+203 @062133> - <append+211 @06213b>): value > (0)
	<append+203 @062133>  : 11 18                      dup.x64 sp(24)
	<append+205 @062135>  : 1a                         load.z64
	<append+206 @062136>  : 49                         cgt.u64
	<append+207 @062137>  : 05 d7 ff ff                jnz <append+166 @06210e>
	cmplStd/lib/string.ci:168: (29 bytes: <append+211 @06213b> - <append+240 @062158>): if (len == 0)
	<append+211 @06213b>  : 10 15                      dup.x32 sp(21)
	<append+213 @06213d>  : 19                         load.z32
	<append+214 @06213e>  : 57                         ceq.i32
	<append+215 @06213f>  : 06 19 00 00                jz <append+240 @062158>
	cmplStd/lib/string.ci:169: (21 bytes: <append+219 @062143> - <append+240 @062158>): digits[len := len + 1] := '0';
	<append+219 @062143>  : 1c 30 00 00 00             load.c32 48
	<append+224 @062148>  : 0a 08 00 00                load.sp(+8)
	<append+228 @06214c>  : 10 17                      dup.x32 sp(23)
	<append+230 @06214e>  : 0c 01 00 00                inc.i32(+1)
	<append+234 @062152>  : 10 00                      dup.x32 sp(0)
	<append+236 @062154>  : 13 19                      set.x32 sp(25)
	<append+238 @062156>  : 51                         add.i32
	<append+239 @062157>  : 2b                         store.i8
	cmplStd/lib/string.ci:172: (10 bytes: <append+240 @062158> - <append+250 @062162>): maxLen: int32 := format.padLen - len
	<append+240 @062158>  : 10 17                      dup.x32 sp(23)
	<append+242 @06215a>  : 0c 0c 00 00                inc.i32(+12)
	<append+246 @06215e>  : 28                         load.i32
	<append+247 @06215f>  : 10 16                      dup.x32 sp(22)
	<append+249 @062161>  : 52                         sub.i32
	cmplStd/lib/string.ci:174: (7 bytes: <append+250 @062162> - <append+257 @062169>): padChr: char := format.padChr
	<append+250 @062162>  : 10 18                      dup.x32 sp(24)
	<append+252 @062164>  : 0c 08 00 00                inc.i32(+8)
	<append+256 @062168>  : 26                         load.i8
	cmplStd/lib/string.ci:175: (21 bytes: <append+257 @062169> - <append+278 @06217e>): if (padChr == '')
	<append+257 @062169>  : 0a 00 00 00                load.sp(+0)
	<append+261 @06216d>  : 26                         load.i8
	<append+262 @06216e>  : 19                         load.z32
	<append+263 @06216f>  : 57                         ceq.i32
	<append+264 @062170>  : 06 0e 00 00                jz <append+278 @06217e>
	cmplStd/lib/string.ci:176: (10 bytes: <append+268 @062174> - <append+278 @06217e>): padChr := ' ';
	<append+268 @062174>  : 1c 20 00 00 00             load.c32 32
	<append+273 @062179>  : 0a 04 00 00                load.sp(+4)
	<append+277 @06217d>  : 2b                         store.i8
	cmplStd/lib/string.ci:180: (207 bytes: <append+278 @06217e> - <append+485 @06224d>): if ((sign) != 0)
	<append+278 @06217e>  : 0a 70 00 00                load.sp(+112)
	<append+282 @062182>  : 26                         load.i8
	<append+283 @062183>  : 19                         load.z32
	<append+284 @062184>  : 57                         ceq.i32
	<append+285 @062185>  : 05 c8 00 00                jnz <append+485 @06224d>
	cmplStd/lib/string.ci:181: (8 bytes: <append+289 @062189> - <append+297 @062191>): maxLen := maxLen - 1;
	<append+289 @062189>  : 10 01                      dup.x32 sp(1)
	<append+291 @06218b>  : 0c ff ff ff                inc.i32(-1)
	<append+295 @06218f>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:182: (117 bytes: <append+297 @062191> - <append+414 @062206>): if (contains(whiteSpace, padChr))
	<append+297 @062191>  : 19                         load.z32
	<append+298 @062192>  : 20 58 20 06                load.m32 <@062058> ;append.whiteSpace
	<append+302 @062196>  : 0a 08 00 00                load.sp(+8)
	<append+306 @06219a>  : 26                         load.i8
	<append+307 @06219b>  : 1f 00 1e 06 00             load.ref <@061e00> ;indexOf(str: char[*], chr: char): int32
	<append+312 @0621a0>  : 02                         call
	<append+313 @0621a1>  : 09 f8 ff ff                inc.sp(-8)
	<append+317 @0621a5>  : 19                         load.z32
	<append+318 @0621a6>  : 58                         clt.i32
	<append+319 @0621a7>  : 05 5f 00 00                jnz <append+414 @062206>
	cmplStd/lib/string.ci:184: (91 bytes: <append+323 @0621ab> - <append+414 @062206>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+323 @0621ab>  : 04 53 00 00                jmp <append+406 @0621fe>
	cmplStd/lib/string.ci:185: (52 bytes: <append+327 @0621af> - <append+379 @0621e3>): assert(pos < (output.length));
	<append+327 @0621af>  : 10 1d                      dup.x32 sp(29)
	<append+329 @0621b1>  : 10 20                      dup.x32 sp(32)
	<append+331 @0621b3>  : 58                         clt.i32
	<append+332 @0621b4>  : 06 08 00 00                jz <append+340 @0621bc>
	<append+336 @0621b8>  : 04 2b 00 00                jmp <append+379 @0621e3>
	<append+340 @0621bc>  : 1f 80 11 03 00             load.ref <@031180> ;"cmplStd/lib/string.ci"
	<append+345 @0621c1>  : 1c b9 00 00 00             load.c32 185
	<append+350 @0621c6>  : 1c fe ff ff ff             load.c32 -2
	<append+355 @0621cb>  : 1c 80 00 00 00             load.c32 128
	<append+360 @0621d0>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+365 @0621d5>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+370 @0621da>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+375 @0621df>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:186: (11 bytes: <append+379 @0621e3> - <append+390 @0621ee>): output[pos] := padChr;
	<append+379 @0621e3>  : 0a 00 00 00                load.sp(+0)
	<append+383 @0621e7>  : 26                         load.i8
	<append+384 @0621e8>  : 10 1f                      dup.x32 sp(31)
	<append+386 @0621ea>  : 10 1f                      dup.x32 sp(31)
	<append+388 @0621ec>  : 51                         add.i32
	<append+389 @0621ed>  : 2b                         store.i8
	cmplStd/lib/string.ci:187: (8 bytes: <append+390 @0621ee> - <append+398 @0621f6>): pos := pos + 1;
	<append+390 @0621ee>  : 10 1d                      dup.x32 sp(29)
	<append+392 @0621f0>  : 0c 01 00 00                inc.i32(+1)
	<append+396 @0621f4>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:184: (8 bytes: <append+398 @0621f6> - <append+406 @0621fe>): maxLen := maxLen - 1
	<append+398 @0621f6>  : 10 01                      dup.x32 sp(1)
	<append+400 @0621f8>  : 0c ff ff ff                inc.i32(-1)
	<append+404 @0621fc>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:184: (8 bytes: <append+406 @0621fe> - <append+414 @062206>): maxLen > 0
	<append+406 @0621fe>  : 10 01                      dup.x32 sp(1)
	<append+408 @062200>  : 19                         load.z32
	<append+409 @062201>  : 59                         cgt.i32
	<append+410 @062202>  : 05 ad ff ff                jnz <append+327 @0621af>
	cmplStd/lib/string.ci:190: (52 bytes: <append+414 @062206> - <append+466 @06223a>): assert(pos < (output.length));
	<append+414 @062206>  : 10 1d                      dup.x32 sp(29)
	<append+416 @062208>  : 10 20                      dup.x32 sp(32)
	<append+418 @06220a>  : 58                         clt.i32
	<append+419 @06220b>  : 06 08 00 00                jz <append+427 @062213>
	<append+423 @06220f>  : 04 2b 00 00                jmp <append+466 @06223a>
	<append+427 @062213>  : 1f 80 11 03 00             load.ref <@031180> ;"cmplStd/lib/string.ci"
	<append+432 @062218>  : 1c be 00 00 00             load.c32 190
	<append+437 @06221d>  : 1c fe ff ff ff             load.c32 -2
	<append+442 @062222>  : 1c 80 00 00 00             load.c32 128
	<append+447 @062227>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+452 @06222c>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+457 @062231>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+462 @062236>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:191: (11 bytes: <append+466 @06223a> - <append+477 @062245>): output[pos] := sign;
	<append+466 @06223a>  : 0a 70 00 00                load.sp(+112)
	<append+470 @06223e>  : 26                         load.i8
	<append+471 @06223f>  : 10 1f                      dup.x32 sp(31)
	<append+473 @062241>  : 10 1f                      dup.x32 sp(31)
	<append+475 @062243>  : 51                         add.i32
	<append+476 @062244>  : 2b                         store.i8
	cmplStd/lib/string.ci:192: (8 bytes: <append+477 @062245> - <append+485 @06224d>): pos := pos + 1;
	<append+477 @062245>  : 10 1d                      dup.x32 sp(29)
	<append+479 @062247>  : 0c 01 00 00                inc.i32(+1)
	<append+483 @06224b>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:196: (91 bytes: <append+485 @06224d> - <append+576 @0622a8>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+485 @06224d>  : 04 53 00 00                jmp <append+568 @0622a0>
	cmplStd/lib/string.ci:197: (52 bytes: <append+489 @062251> - <append+541 @062285>): assert(pos < (output.length));
	<append+489 @062251>  : 10 1d                      dup.x32 sp(29)
	<append+491 @062253>  : 10 20                      dup.x32 sp(32)
	<append+493 @062255>  : 58                         clt.i32
	<append+494 @062256>  : 06 08 00 00                jz <append+502 @06225e>
	<append+498 @06225a>  : 04 2b 00 00                jmp <append+541 @062285>
	<append+502 @06225e>  : 1f 80 11 03 00             load.ref <@031180> ;"cmplStd/lib/string.ci"
	<append+507 @062263>  : 1c c5 00 00 00             load.c32 197
	<append+512 @062268>  : 1c fe ff ff ff             load.c32 -2
	<append+517 @06226d>  : 1c 80 00 00 00             load.c32 128
	<append+522 @062272>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+527 @062277>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+532 @06227c>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+537 @062281>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:198: (11 bytes: <append+541 @062285> - <append+552 @062290>): output[pos] := padChr;
	<append+541 @062285>  : 0a 00 00 00                load.sp(+0)
	<append+545 @062289>  : 26                         load.i8
	<append+546 @06228a>  : 10 1f                      dup.x32 sp(31)
	<append+548 @06228c>  : 10 1f                      dup.x32 sp(31)
	<append+550 @06228e>  : 51                         add.i32
	<append+551 @06228f>  : 2b                         store.i8
	cmplStd/lib/string.ci:199: (8 bytes: <append+552 @062290> - <append+560 @062298>): pos := pos + 1;
	<append+552 @062290>  : 10 1d                      dup.x32 sp(29)
	<append+554 @062292>  : 0c 01 00 00                inc.i32(+1)
	<append+558 @062296>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:196: (8 bytes: <append+560 @062298> - <append+568 @0622a0>): maxLen := maxLen - 1
	<append+560 @062298>  : 10 01                      dup.x32 sp(1)
	<append+562 @06229a>  : 0c ff ff ff                inc.i32(-1)
	<append+566 @06229e>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:196: (8 bytes: <append+568 @0622a0> - <append+576 @0622a8>): maxLen > 0
	<append+568 @0622a0>  : 10 01                      dup.x32 sp(1)
	<append+570 @0622a2>  : 19                         load.z32
	<append+571 @0622a3>  : 59                         cgt.i32
	<append+572 @0622a4>  : 05 ad ff ff                jnz <append+489 @062251>
	cmplStd/lib/string.ci:203: (99 bytes: <append+576 @0622a8> - <append+675 @06230b>): for (i: int32 := 0; i < len; i := i + 1)
	<append+576 @0622a8>  : 19                         load.z32
	<append+577 @0622a9>  : 04 55 00 00                jmp <append+662 @0622fe>
	cmplStd/lib/string.ci:204: (52 bytes: <append+581 @0622ad> - <append+633 @0622e1>): assert(i < (output.length));
	<append+581 @0622ad>  : 10 00                      dup.x32 sp(0)
	<append+583 @0622af>  : 10 21                      dup.x32 sp(33)
	<append+585 @0622b1>  : 58                         clt.i32
	<append+586 @0622b2>  : 06 08 00 00                jz <append+594 @0622ba>
	<append+590 @0622b6>  : 04 2b 00 00                jmp <append+633 @0622e1>
	<append+594 @0622ba>  : 1f 80 11 03 00             load.ref <@031180> ;"cmplStd/lib/string.ci"
	<append+599 @0622bf>  : 1c cc 00 00 00             load.c32 204
	<append+604 @0622c4>  : 1c fe ff ff ff             load.c32 -2
	<append+609 @0622c9>  : 1c 80 00 00 00             load.c32 128
	<append+614 @0622ce>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+619 @0622d3>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+624 @0622d8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+629 @0622dd>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:205: (17 bytes: <append+633 @0622e1> - <append+650 @0622f2>): output[pos] := digits[len - i];
	<append+633 @0622e1>  : 0a 10 00 00                load.sp(+16)
	<append+637 @0622e5>  : 10 19                      dup.x32 sp(25)
	<append+639 @0622e7>  : 10 02                      dup.x32 sp(2)
	<append+641 @0622e9>  : 52                         sub.i32
	<append+642 @0622ea>  : 51                         add.i32
	<append+643 @0622eb>  : 26                         load.i8
	<append+644 @0622ec>  : 10 20                      dup.x32 sp(32)
	<append+646 @0622ee>  : 10 20                      dup.x32 sp(32)
	<append+648 @0622f0>  : 51                         add.i32
	<append+649 @0622f1>  : 2b                         store.i8
	cmplStd/lib/string.ci:206: (8 bytes: <append+650 @0622f2> - <append+658 @0622fa>): pos := pos + 1;
	<append+650 @0622f2>  : 10 1e                      dup.x32 sp(30)
	<append+652 @0622f4>  : 0c 01 00 00                inc.i32(+1)
	<append+656 @0622f8>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/string.ci:203: (4 bytes: <append+658 @0622fa> - <append+662 @0622fe>): i := i + 1
	<append+658 @0622fa>  : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:203: (9 bytes: <append+662 @0622fe> - <append+671 @062307>): i < len
	<append+662 @0622fe>  : 10 00                      dup.x32 sp(0)
	<append+664 @062300>  : 10 19                      dup.x32 sp(25)
	<append+666 @062302>  : 58                         clt.i32
	<append+667 @062303>  : 05 aa ff ff                jnz <append+581 @0622ad>
	<append+671 @062307>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:209: (17 bytes: <append+675 @06230b> - <append+692 @06231c>): if (pos >= (output.length))
	<append+675 @06230b>  : 10 1d                      dup.x32 sp(29)
	<append+677 @06230d>  : 10 20                      dup.x32 sp(32)
	<append+679 @06230f>  : 58                         clt.i32
	<append+680 @062310>  : 05 0c 00 00                jnz <append+692 @06231c>
	cmplStd/lib/string.ci:210: (8 bytes: <append+684 @062314> - <append+692 @06231c>): pos := (output.length - (1));
	<append+684 @062314>  : 10 1f                      dup.x32 sp(31)
	<append+686 @062316>  : 0c ff ff ff                inc.i32(-1)
	<append+690 @06231a>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:212: (7 bytes: <append+692 @06231c> - <append+699 @062323>): output[pos] := (0);
	<append+692 @06231c>  : 19                         load.z32
	<append+693 @06231d>  : 10 1f                      dup.x32 sp(31)
	<append+695 @06231f>  : 10 1f                      dup.x32 sp(31)
	<append+697 @062321>  : 51                         add.i32
	<append+698 @062322>  : 2b                         store.i8
	cmplStd/lib/string.ci:213: (8 bytes: <append+699 @062323> - <append+707 @06232b>): return .result := pos;
	<append+699 @062323>  : 16 20 1d                   mov.x32 sp(32, 29)
	<append+702 @062326>  : 09 a0 ff ff                inc.sp(-96)
	<append+706 @06232a>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:254: referenced as `append`
	cmplStd/lib/string.ci:250: referenced as `append`
	cmplStd/lib/string.ci:231: referenced as `append`
	cmplStd/lib/string.ci:229: referenced as `append`
	cmplStd/lib/string.ci:227: referenced as `append`
	cmplStd/lib/string.ci:225: referenced as `append`
	cmplStd/lib/string.ci:223: referenced as `append`
	cmplStd/lib/string.ci:221: referenced as `append`
	cmplStd/lib/string.ci:219: referenced as `append`
	cmplStd/lib/string.ci:217: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:217'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:219'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:221'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:223'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:225'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:227'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format))
.usages:
	cmplStd/lib/string.ci:264: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:229'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:231'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 236
.offset: <@062330>
.name: 'append'
.file: 'cmplStd/lib/string.ci:234'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		void(formatInt.showSign := format.showSign);
		void(formatInt.precision := 0);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(format.padLen - format.precision));
	};
	formatDec: FormatFlags := {
		void(formatDec.showSign := false);
		void(formatDec.precision := 0);
		void(formatDec.padChr := '0');
		void(formatDec.padLen := format.precision);
	};
	sign: char := bool(value < (0)) ? ('-') : 0;
	fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
	int32(pos := append(void(output, void(pos, "."))));
	float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
	return int32(.result := pos);
}
.instructions: (236 bytes: <append @062330> - <append+236 @06241c>)
	cmplStd/lib/string.ci:235: (44 bytes: <append @062330> - <append+44 @06235c>): formatInt: FormatFlags := {...}
	<append @062330>      : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/string.ci:236: (8 bytes: <append+4 @062334> - <append+12 @06233c>): formatInt.showSign := format.showSign;
	<append+4 @062334>    : 10 05                      dup.x32 sp(5)
	<append+6 @062336>    : 26                         load.i8
	<append+7 @062337>    : 0a 04 00 00                load.sp(+4)
	<append+11 @06233b>   : 2b                         store.i8
	cmplStd/lib/string.ci:237: (3 bytes: <append+12 @06233c> - <append+15 @06233f>): formatInt.precision := 0;
	<append+12 @06233c>   : 19                         load.z32
	<append+13 @06233d>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:238: (12 bytes: <append+15 @06233f> - <append+27 @06234b>): formatInt.padChr := format.padChr;
	<append+15 @06233f>   : 10 05                      dup.x32 sp(5)
	<append+17 @062341>   : 0c 08 00 00                inc.i32(+8)
	<append+21 @062345>   : 26                         load.i8
	<append+22 @062346>   : 0a 0c 00 00                load.sp(+12)
	<append+26 @06234a>   : 2b                         store.i8
	cmplStd/lib/string.ci:239: (17 bytes: <append+27 @06234b> - <append+44 @06235c>): formatInt.padLen := format.padLen - format.precision;
	<append+27 @06234b>   : 10 05                      dup.x32 sp(5)
	<append+29 @06234d>   : 0c 0c 00 00                inc.i32(+12)
	<append+33 @062351>   : 28                         load.i32
	<append+34 @062352>   : 10 06                      dup.x32 sp(6)
	<append+36 @062354>   : 0c 04 00 00                inc.i32(+4)
	<append+40 @062358>   : 28                         load.i32
	<append+41 @062359>   : 52                         sub.i32
	<append+42 @06235a>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:241: (32 bytes: <append+44 @06235c> - <append+76 @06237c>): formatDec: FormatFlags := {...}
	<append+44 @06235c>   : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/string.ci:242: (6 bytes: <append+48 @062360> - <append+54 @062366>): formatDec.showSign := false;
	<append+48 @062360>   : 19                         load.z32
	<append+49 @062361>   : 0a 04 00 00                load.sp(+4)
	<append+53 @062365>   : 2b                         store.i8
	cmplStd/lib/string.ci:243: (3 bytes: <append+54 @062366> - <append+57 @062369>): formatDec.precision := 0;
	<append+54 @062366>   : 19                         load.z32
	<append+55 @062367>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:244: (10 bytes: <append+57 @062369> - <append+67 @062373>): formatDec.padChr := '0';
	<append+57 @062369>   : 1c 30 00 00 00             load.c32 48
	<append+62 @06236e>   : 0a 0c 00 00                load.sp(+12)
	<append+66 @062372>   : 2b                         store.i8
	cmplStd/lib/string.ci:245: (9 bytes: <append+67 @062373> - <append+76 @06237c>): formatDec.padLen := format.precision;
	<append+67 @062373>   : 10 09                      dup.x32 sp(9)
	<append+69 @062375>   : 0c 04 00 00                inc.i32(+4)
	<append+73 @062379>   : 28                         load.i32
	<append+74 @06237a>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:248: (18 bytes: <append+76 @06237c> - <append+94 @06238e>): sign: char := value < (0) ? ('-') : 0
	<append+76 @06237c>   : 11 0a                      dup.x64 sp(10)
	<append+78 @06237e>   : 1a                         load.z64
	<append+79 @06237f>   : 88                         clt.f64
	<append+80 @062380>   : 06 0d 00 00                jz <append+93 @06238d>
	<append+84 @062384>   : 1c 2d 00 00 00             load.c32 45
	<append+89 @062389>   : 04 05 00 00                jmp <append+94 @06238e>
	<append+93 @06238d>   : 19                         load.z32
	cmplStd/lib/string.ci:249: (36 bytes: <append+94 @06238e> - <append+130 @0623b2>): fract: float64 := Math.modf(Math.abs(value), &value)
	<append+94 @06238e>   : 1a                         load.z64
	<append+95 @06238f>   : 11 0d                      dup.x64 sp(13)
	<append+97 @062391>   : 11 00                      dup.x64 sp(0)
	<append+99 @062393>   : 1a                         load.z64
	<append+100 @062394>  : 88                         clt.f64
	<append+101 @062395>  : 06 0b 00 00                jz <append+112 @0623a0>
	<append+105 @062399>  : 11 00                      dup.x64 sp(0)
	<append+107 @06239b>  : 80                         neg.f64
	<append+108 @06239c>  : 04 06 00 00                jmp <append+114 @0623a2>
	<append+112 @0623a0>  : 11 00                      dup.x64 sp(0)
	<append+114 @0623a2>  : 14 02                      set.x64 sp(2)
	<append+116 @0623a4>  : 0a 3c 00 00                load.sp(+60)
	<append+120 @0623a8>  : 1f e0 10 06 00             load.ref <@0610e0> ;Math.modf(x: float64, intPart: float64): float64
	<append+125 @0623ad>  : 02                         call
	<append+126 @0623ae>  : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/string.ci:250: (29 bytes: <append+130 @0623b2> - <append+159 @0623cf>): pos := append(output, pos, sign, uint64(int64(value)), formatInt);
	<append+130 @0623b2>  : 19                         load.z32
	<append+131 @0623b3>  : 11 11                      dup.x64 sp(17)
	<append+133 @0623b5>  : 10 12                      dup.x32 sp(18)
	<append+135 @0623b7>  : 0a 18 00 00                load.sp(+24)
	<append+139 @0623bb>  : 26                         load.i8
	<append+140 @0623bc>  : 11 12                      dup.x64 sp(18)
	<append+142 @0623be>  : 8b                         f64.2i64
	<append+143 @0623bf>  : 0a 38 00 00                load.sp(+56)
	<append+147 @0623c3>  : 1f 68 20 06 00             load.ref <@062068> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+152 @0623c8>  : 02                         call
	<append+153 @0623c9>  : 09 e4 ff ff                inc.sp(-28)
	<append+157 @0623cd>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:252: (22 bytes: <append+159 @0623cf> - <append+181 @0623e5>): pos := append(output, pos, ".");
	<append+159 @0623cf>  : 19                         load.z32
	<append+160 @0623d0>  : 11 11                      dup.x64 sp(17)
	<append+162 @0623d2>  : 10 12                      dup.x32 sp(18)
	<append+164 @0623d4>  : 1f 9c 15 03 00             load.ref <@03159c> ;"."
	<append+169 @0623d9>  : 1f 00 20 06 00             load.ref <@062000> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+174 @0623de>  : 02                         call
	<append+175 @0623df>  : 09 f0 ff ff                inc.sp(-16)
	<append+179 @0623e3>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:253: (22 bytes: <append+181 @0623e5> - <append+203 @0623fb>): fract := fract * float64.pow(10, format.precision);
	<append+181 @0623e5>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+190 @0623ee>  : 10 0e                      dup.x32 sp(14)
	<append+192 @0623f0>  : 0c 04 00 00                inc.i32(+4)
	<append+196 @0623f4>  : 28                         load.i32
	<append+197 @0623f5>  : 5d                         i32.2f64
	<append+198 @0623f6>  : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<append+202 @0623fa>  : 83                         mul.f64
	cmplStd/lib/string.ci:254: (25 bytes: <append+203 @0623fb> - <append+228 @062414>): pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
	<append+203 @0623fb>  : 19                         load.z32
	<append+204 @0623fc>  : 11 11                      dup.x64 sp(17)
	<append+206 @0623fe>  : 10 12                      dup.x32 sp(18)
	<append+208 @062400>  : 19                         load.z32
	<append+209 @062401>  : 11 05                      dup.x64 sp(5)
	<append+211 @062403>  : 8b                         f64.2i64
	<append+212 @062404>  : 0a 28 00 00                load.sp(+40)
	<append+216 @062408>  : 1f 68 20 06 00             load.ref <@062068> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+221 @06240d>  : 02                         call
	<append+222 @06240e>  : 09 e4 ff ff                inc.sp(-28)
	<append+226 @062412>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:255: (8 bytes: <append+228 @062414> - <append+236 @06241c>): return .result := pos;
	<append+228 @062414>  : 16 12 0f                   mov.x32 sp(18, 15)
	<append+231 @062417>  : 09 d4 ff ff                inc.sp(-44)
	<append+235 @06241b>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:259: referenced as `append`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:259'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@062430>
.name: 'append'
.file: 'cmplStd/lib/string.ci:262'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.showSign := false);
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (63 bytes: <append @062430> - <append+63 @06246f>)
	cmplStd/lib/string.ci:264: (63 bytes: <append @062430> - <append+63 @06246f>): return .result := append(output, pos, value, format);
	<append @062430>      : 10 01                      dup.x32 sp(1)
	<append+2 @062432>    : 19                         load.z32
	<append+3 @062433>    : 11 05                      dup.x64 sp(5)
	<append+5 @062435>    : 10 06                      dup.x32 sp(6)
	<append+7 @062437>    : 10 04                      dup.x32 sp(4)
	<append+9 @062439>    : 19                         load.z32
	<append+10 @06243a>   : 58                         clt.i32
	<append+11 @06243b>   : 06 0d 00 00                jz <append+24 @062448>
	<append+15 @06243f>   : 1c 2d 00 00 00             load.c32 45
	<append+20 @062444>   : 04 05 00 00                jmp <append+25 @062449>
	<append+24 @062448>   : 19                         load.z32
	<append+25 @062449>   : 10 05                      dup.x32 sp(5)
	<append+27 @06244b>   : 19                         load.z32
	<append+28 @06244c>   : 58                         clt.i32
	<append+29 @06244d>   : 06 0b 00 00                jz <append+40 @062458>
	<append+33 @062451>   : 10 05                      dup.x32 sp(5)
	<append+35 @062453>   : 50                         neg.i32
	<append+36 @062454>   : 04 06 00 00                jmp <append+42 @06245a>
	<append+40 @062458>   : 10 05                      dup.x32 sp(5)
	<append+42 @06245a>   : 5b                         i32.2i64
	<append+43 @06245b>   : 1f 20 24 06 00             load.ref <@062420> ;append.format
	<append+48 @062460>   : 1f 68 20 06 00             load.ref <@062068> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+53 @062465>   : 02                         call
	<append+54 @062466>   : 09 e4 ff ff                inc.sp(-28)
	<append+58 @06246a>   : 13 01                      set.x32 sp(1)
	<append+60 @06246c>   : 13 06                      set.x32 sp(6)
	<append+62 @06246e>   : 03                         ret
.usages:
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'cmplStd/test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062470>
.name: 'emitldz32'
.file: 'cmplStd/test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@062478>
.name: 'emitldz64'
.file: 'cmplStd/test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062480>
.name: 'emitA'
.file: 'cmplStd/test/lang/emit.ci:6'
.value: 42
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062488>
.name: 'emitB'
.file: 'cmplStd/test/lang/emit.ci:7'
.value: 96
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062490>
.name: 'emitAddI32'
.file: 'cmplStd/test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062498>
.name: 'emitDivI32'
.file: 'cmplStd/test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
}
emitNfcF32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0624a0>
.name: 'emitNfcF32'
.file: 'cmplStd/test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin))
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'cmplStd/test/lang/emit.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	cmplStd/test/lang/emit.ci:24: referenced as `floatAsInt32`
	cmplStd/test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'cmplStd/test/lang/emit.ci:21'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	cmplStd/test/lang/emit.ci:26: referenced as `floatAsInt64`
	cmplStd/test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624a8>
.name: 'emitFloatAsInt1'
.file: 'cmplStd/test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0624b0>
.name: 'emitFloatAsInt2'
.file: 'cmplStd/test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624b8>
.name: 'emitFloatAsInt3'
.file: 'cmplStd/test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0624c0>
.name: 'emitFloatAsInt4'
.file: 'cmplStd/test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@0624c8>
.name: 'emitSlice'
.file: 'cmplStd/test/lang/emit.ci:29'
.value: emit(void(int32(3), pointer("string")))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'cmplStd/test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'cmplStd/test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'cmplStd/test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'cmplStd/test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624d0>
.name: 'i3'
.file: 'cmplStd/test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624d8>
.name: 'i6'
.file: 'cmplStd/test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624e0>
.name: 'i2'
.file: 'cmplStd/test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624e8>
.name: 'i8'
.file: 'cmplStd/test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624f0>
.name: 'zeroVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0624f8>
.name: 'zeroVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062500>
.name: 'zeroXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062508>
.name: 'lastVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062510>
.name: 'lastVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062518>
.name: 'lastXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062520>
.name: 'sum2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062528>
.name: 'sum2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062530>
.name: 'sum2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062538>
.name: 'any2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062540>
.name: 'any2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062548>
.name: 'any2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062550>
.name: 'min2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062558>
.name: 'min2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062560>
.name: 'min2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062568>
.name: 'max2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062570>
.name: 'max2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062578>
.name: 'max2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062580>
.name: 'sumRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062588>
.name: 'sumLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062590>
.name: 'sumRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062598>
.name: 'sumLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625a0>
.name: 'sumRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625a8>
.name: 'sumLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625b0>
.name: 'anyRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625b8>
.name: 'anyLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625c0>
.name: 'anyRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625c8>
.name: 'anyLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625d0>
.name: 'anyRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625d8>
.name: 'anyLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625e0>
.name: 'minRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625e8>
.name: 'minLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625f0>
.name: 'minRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0625f8>
.name: 'minLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062600>
.name: 'minRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062608>
.name: 'minLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062610>
.name: 'maxRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062618>
.name: 'maxLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062620>
.name: 'maxRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062628>
.name: 'maxLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062630>
.name: 'maxRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062638>
.name: 'maxLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:3'
.value: 1
.usages:
	cmplStd/test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	cmplStd/test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	cmplStd/test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	cmplStd/test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	cmplStd/test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062640>
.name: 'overload1'
.file: 'cmplStd/test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062648>
.name: 'overload2'
.file: 'cmplStd/test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062650>
.name: 'overload3'
.file: 'cmplStd/test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062658>
.name: 'overload4'
.file: 'cmplStd/test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062660>
.name: 'overload5'
.file: 'cmplStd/test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03feb0>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03fff0>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	cmplStd/test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@062668>
.name: 'boilC'
.file: 'cmplStd/test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@062670>
.name: 'boilF'
.file: 'cmplStd/test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062678>
.name: 'pi64'
.file: 'cmplStd/test/std/number.ci:3'
.value: 3.141593
.usages:
	cmplStd/test/std/number.ci:44: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:39: referenced as `pi64`
	cmplStd/test/std/number.ci:38: referenced as `pi64`
	cmplStd/test/std/number.ci:37: referenced as `pi64`
	cmplStd/test/std/number.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062680>
.name: 'e64'
.file: 'cmplStd/test/std/number.ci:4'
.value: 2.718282
.usages:
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062688>
.name: 'pi32'
.file: 'cmplStd/test/std/number.ci:6'
.value: pi64
.usages:
	cmplStd/test/std/number.ci:53: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:48: referenced as `pi32`
	cmplStd/test/std/number.ci:47: referenced as `pi32`
	cmplStd/test/std/number.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062690>
.name: 'e32'
.file: 'cmplStd/test/std/number.ci:7'
.value: e64
.usages:
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'cmplStd/test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	cmplStd/test/std/number.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'cmplStd/test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	cmplStd/test/std/number.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062698>
.name: 'r_comp'
.file: 'cmplStd/test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `r_comp`
	cmplStd/test/std/number.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626a0>
.name: 'g_comp'
.file: 'cmplStd/test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `g_comp`
	cmplStd/test/std/number.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626a8>
.name: 'b_comp'
.file: 'cmplStd/test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `b_comp`
	cmplStd/test/std/number.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626b0>
.name: 'r5g6b5'
.file: 'cmplStd/test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:66: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:65: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:63: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:62: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:60: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:59: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:58: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:57: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:56: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:55: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:27: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:26: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:25: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:23: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:22: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626b8>
.name: 'r8g8b8'
.file: 'cmplStd/test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:35: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:34: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:33: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:31: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:30: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626c0>
.name: 'zxtR5'
.file: 'cmplStd/test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626c8>
.name: 'zxtG6'
.file: 'cmplStd/test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626d0>
.name: 'zxtB5'
.file: 'cmplStd/test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626d8>
.name: 'sxtR5'
.file: 'cmplStd/test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626e0>
.name: 'sxtG6'
.file: 'cmplStd/test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626e8>
.name: 'sxtB5'
.file: 'cmplStd/test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626f0>
.name: 'zxtR8'
.file: 'cmplStd/test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0626f8>
.name: 'zxtG8'
.file: 'cmplStd/test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062700>
.name: 'zxtB8'
.file: 'cmplStd/test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062708>
.name: 'sxtR8'
.file: 'cmplStd/test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062710>
.name: 'sxtG8'
.file: 'cmplStd/test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062718>
.name: 'sxtB8'
.file: 'cmplStd/test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062720>
.name: 'testSin_f64'
.file: 'cmplStd/test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062728>
.name: 'testCos_f64'
.file: 'cmplStd/test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062730>
.name: 'testTan_f64'
.file: 'cmplStd/test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062738>
.name: 'testLog_f64'
.file: 'cmplStd/test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062740>
.name: 'testExp_f64'
.file: 'cmplStd/test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062748>
.name: 'testPow_f64'
.file: 'cmplStd/test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062750>
.name: 'testSqrt_f64'
.file: 'cmplStd/test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@062758>
.name: 'testAtan_f64'
.file: 'cmplStd/test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062760>
.name: 'testSin_f32'
.file: 'cmplStd/test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062768>
.name: 'testCos_f32'
.file: 'cmplStd/test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062770>
.name: 'testTan_f32'
.file: 'cmplStd/test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062778>
.name: 'testLog_f32'
.file: 'cmplStd/test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062780>
.name: 'testExp_f32'
.file: 'cmplStd/test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062788>
.name: 'testPow_f32'
.file: 'cmplStd/test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062790>
.name: 'testSqrt_f32'
.file: 'cmplStd/test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062798>
.name: 'testAtan_f32'
.file: 'cmplStd/test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627a0>
.name: 'testPopulation_u32'
.file: 'cmplStd/test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0627a8>
.name: 'testSwapBits_u32'
.file: 'cmplStd/test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627b0>
.name: 'testBitScanReverse_u32'
.file: 'cmplStd/test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627b8>
.name: 'testBitScanForward_u32'
.file: 'cmplStd/test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627c0>
.name: 'testHighBit_u32'
.file: 'cmplStd/test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627c8>
.name: 'testLowBit_u32'
.file: 'cmplStd/test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627d0>
.name: 'testZeroExtend_u32'
.file: 'cmplStd/test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627d8>
.name: 'testSignExtend_u32'
.file: 'cmplStd/test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627e0>
.name: 'testZeroExtend_u64'
.file: 'cmplStd/test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0627e8>
.name: 'testSignExtend_u64'
.file: 'cmplStd/test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'cmplStd/test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'cmplStd/test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	cmplStd/test/std/memory.ci:10: referenced as `malloc`
	cmplStd/test/std/memory.ci:9: referenced as `malloc`
	cmplStd/test/std/memory.ci:8: referenced as `malloc`
	cmplStd/test/std/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'cmplStd/test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `free`
	cmplStd/test/std/memory.ci:19: referenced as `free`
	cmplStd/test/std/memory.ci:18: referenced as `free`
	cmplStd/test/std/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0627f0>
.name: 'p1'
.file: 'cmplStd/test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	cmplStd/test/std/memory.ci:17: referenced as `p1`
	cmplStd/test/std/memory.ci:14: referenced as `p1`
	cmplStd/test/std/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0627f8>
.name: 'p2'
.file: 'cmplStd/test/std/memory.ci:8'
.value: malloc(80)
.usages:
	cmplStd/test/std/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062800>
.name: 'p3'
.file: 'cmplStd/test/std/memory.ci:9'
.value: malloc(160)
.usages:
	cmplStd/test/std/memory.ci:19: referenced as `p3`
	cmplStd/test/std/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062808>
.name: 'p4'
.file: 'cmplStd/test/std/memory.ci:10'
.value: malloc(820)
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@062810>
.name: 'val1'
.file: 'cmplStd/test/std/memory.ci:23'
.value: 42
.usages:
	cmplStd/test/std/memory.ci:32: referenced as `val1`
	cmplStd/test/std/memory.ci:30: referenced as `val1`
	cmplStd/test/std/memory.ci:29: referenced as `val1`
	cmplStd/test/std/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@062818>
.name: 'val2'
.file: 'cmplStd/test/std/memory.ci:24'
.value: 96
.usages:
	cmplStd/test/std/memory.ci:33: referenced as `val2`
	cmplStd/test/std/memory.ci:29: referenced as `val2`
	cmplStd/test/std/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@062820>
.name: 'noError'
.file: 'cmplStd/test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <noError @062820> - <noError+1 @062821>)
	<noError @062820>      : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:47: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@062828>
.name: 'stackOverflow'
.file: 'cmplStd/test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes: <stackOverflow @062828> - <stackOverflow+24 @062840>)
	cmplStd/test/std/tryExec.ci:16: (4 bytes: <stackOverflow @062828> - <stackOverflow+4 @06282c>): data: uint8[8192] := {...}
	<stackOverflow @062828>      : 09 00 20 00                inc.sp(+8192)
	cmplStd/test/std/tryExec.ci:17: (15 bytes: <stackOverflow+4 @06282c> - <stackOverflow+19 @06283b>): stackOverflow(ptr);
	<stackOverflow+4 @06282c>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @062830>    : 28                         load.i32
	<stackOverflow+9 @062831>    : 1f 28 28 06 00             load.ref <@062828> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @062836>   : 02                         call
	<stackOverflow+15 @062837>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @06283b>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @06283f>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:49: referenced as `stackOverflow`
	cmplStd/test/std/tryExec.ci:17: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@062840>
.name: 'divisionByZero'
.file: 'cmplStd/test/std/tryExec.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <divisionByZero @062840> - <divisionByZero+12 @06284c>)
	cmplStd/test/std/tryExec.ci:21: (7 bytes: <divisionByZero @062840> - <divisionByZero+7 @062847>): value: int32 := 3 / 0
	<divisionByZero @062840>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @062845>    : 19                         load.z32
	<divisionByZero+6 @062846>    : 54                         div.i32
	<divisionByZero+7 @062847>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @06284b>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:50: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 68
.offset: <@062850>
.name: 'abortExecution'
.file: 'cmplStd/test/std/tryExec.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <abortExecution @062850> - <abortExecution+68 @062894>)
	cmplStd/test/std/tryExec.ci:30: (25 bytes: <abortExecution @062850> - <abortExecution+25 @062869>): details: NotEquals := {...}
	<abortExecution @062850>      : 09 10 00 00                inc.sp(+16)
	cmplStd/test/std/tryExec.ci:31: (7 bytes: <abortExecution+4 @062854> - <abortExecution+11 @06285b>): details.message := ("assertion failed");
	<abortExecution+4 @062854>    : 1f d0 f1 00 00             load.ref <@00f1d0> ;"assertion failed"
	<abortExecution+9 @062859>    : 13 01                      set.x32 sp(1)
	cmplStd/test/std/tryExec.ci:32: (7 bytes: <abortExecution+11 @06285b> - <abortExecution+18 @062862>): details.expected := 97;
	<abortExecution+11 @06285b>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @062860>   : 13 02                      set.x32 sp(2)
	cmplStd/test/std/tryExec.ci:33: (7 bytes: <abortExecution+18 @062862> - <abortExecution+25 @062869>): details.returned := 77;
	<abortExecution+18 @062862>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @062867>   : 13 03                      set.x32 sp(3)
	cmplStd/test/std/tryExec.ci:35: (38 bytes: <abortExecution+25 @062869> - <abortExecution+63 @06288f>): abort("fatal error", details);
	<abortExecution+25 @062869>   : 1f 78 3a 04 00             load.ref <@043a78> ;"cmplStd/test/std/tryExec.ci"
	<abortExecution+30 @06286e>   : 1c 23 00 00 00             load.c32 35
	<abortExecution+35 @062873>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @062878>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @06287d>   : 1f c8 3a 04 00             load.ref <@043ac8> ;"fatal error"
	<abortExecution+50 @062882>   : 1f 60 45 04 00             load.ref <@044560> ;abortExecution.NotEquals
	<abortExecution+55 @062887>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @06288b>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @06288f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @062893>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 13
.offset: <@062898>
.name: 'invalidMemoryAccess'
.file: 'cmplStd/test/std/tryExec.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <invalidMemoryAccess @062898> - <invalidMemoryAccess+13 @0628a5>)
	cmplStd/test/std/tryExec.ci:39: (5 bytes: <invalidMemoryAccess @062898> - <invalidMemoryAccess+5 @06289d>): i32Ref: int32 := null
	<invalidMemoryAccess @062898>      : 1f 00 00 00 00             load.ref <@000000> ;null
	cmplStd/test/std/tryExec.ci:40: (3 bytes: <invalidMemoryAccess+5 @06289d> - <invalidMemoryAccess+8 @0628a0>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @06289d>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @06289f>    : 28                         load.i32
	<invalidMemoryAccess+8 @0628a0>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @0628a4>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:52: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 2
.offset: <@0628a8>
.name: 'invalidInstruction'
.file: 'cmplStd/test/std/tryExec.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <invalidInstruction @0628a8> - <invalidInstruction+2 @0628aa>)
	cmplStd/test/std/tryExec.ci:44: (2 bytes: <invalidInstruction @0628a8> - <invalidInstruction+2 @0628aa>): emit(load.z32, ret);
	<invalidInstruction @0628a8>      : 19                         load.z32
	<invalidInstruction+1 @0628a9>    : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:51: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628b0>
.name: 'tryExecErr0'
.file: 'cmplStd/test/std/tryExec.ci:47'
.value: tryExec(void(null, noError))
.usages:
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628b8>
.name: 'tryExecErr1'
.file: 'cmplStd/test/std/tryExec.ci:48'
.value: tryExec(void(null, null))
.usages:
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628c0>
.name: 'tryExecErr2'
.file: 'cmplStd/test/std/tryExec.ci:49'
.value: tryExec(void(null, stackOverflow))
.usages:
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628c8>
.name: 'tryExecErr3'
.file: 'cmplStd/test/std/tryExec.ci:50'
.value: tryExec(void(null, divisionByZero))
.usages:
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628d0>
.name: 'tryExecErr4'
.file: 'cmplStd/test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidInstruction))
.usages:
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628d8>
.name: 'tryExecErr5'
.file: 'cmplStd/test/std/tryExec.ci:52'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0628e0>
.name: 'tryExecErr6'
.file: 'cmplStd/test/std/tryExec.ci:53'
.value: tryExec(void(null, abortExecution))
.usages:
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0628e8>
.name: 'value'
.file: 'cmplStd/test/lang/init.reference.ci:7'
.value: 42
.usages:
	cmplStd/test/lang/init.reference.ci:99: referenced as `value`
	cmplStd/test/lang/init.reference.ci:97: referenced as `value`
	cmplStd/test/lang/init.reference.ci:96: referenced as `value`
	cmplStd/test/lang/init.reference.ci:95: referenced as `value`
	cmplStd/test/lang/init.reference.ci:27: referenced as `value`
	cmplStd/test/lang/init.reference.ci:10: referenced as `value`
	cmplStd/test/lang/init.reference.ci:9: referenced as `value`
	cmplStd/test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0628f0>
.name: 'valueRef'
.file: 'cmplStd/test/lang/init.reference.ci:8'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:29: referenced as `valueRef`
	cmplStd/test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0628f8>
.name: 'valuePtr'
.file: 'cmplStd/test/lang/init.reference.ci:9'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:30: referenced as `valuePtr`
	cmplStd/test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062900>
.name: 'valueVar'
.file: 'cmplStd/test/lang/init.reference.ci:10'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:31: referenced as `valueVar`
	cmplStd/test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@062908>
.name: 'fromRef'
.file: 'cmplStd/test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@062910>
.name: 'fromPtr'
.file: 'cmplStd/test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@062918>
.name: 'fromVar'
.file: 'cmplStd/test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@062920>
.name: 'nullRef'
.file: 'cmplStd/test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062928>
.name: 'nullPtr'
.file: 'cmplStd/test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062930>
.name: 'nullVar'
.file: 'cmplStd/test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062938>
.name: 'nullTyp'
.file: 'cmplStd/test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@062940>
.name: 'nullFun'
.file: 'cmplStd/test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@062948>
.name: 'nullObj'
.file: 'cmplStd/test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062950>
.name: 'typePtr'
.file: 'cmplStd/test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062958>
.name: 'typeVar'
.file: 'cmplStd/test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062960>
.name: 'typeTyp'
.file: 'cmplStd/test/lang/init.reference.ci:25'
.value: int64
.usages:
	cmplStd/test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@062968>
.name: 'local'
.file: 'cmplStd/test/lang/init.reference.ci:27'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@062970>
.name: 'copyVal'
.file: 'cmplStd/test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@062978>
.name: 'copyRef'
.file: 'cmplStd/test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062980>
.name: 'copyPtr'
.file: 'cmplStd/test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062988>
.name: 'copyVar'
.file: 'cmplStd/test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062990>
.name: 'copyTyp'
.file: 'cmplStd/test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062998>
.name: 'ptrVoid'
.file: 'cmplStd/test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629a0>
.name: 'ptrBool'
.file: 'cmplStd/test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629a8>
.name: 'ptrChar'
.file: 'cmplStd/test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629b0>
.name: 'ptrInt8'
.file: 'cmplStd/test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629b8>
.name: 'ptrInt16'
.file: 'cmplStd/test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629c0>
.name: 'ptrInt32'
.file: 'cmplStd/test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629c8>
.name: 'ptrInt64'
.file: 'cmplStd/test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629d0>
.name: 'ptrUint8'
.file: 'cmplStd/test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629d8>
.name: 'ptrUint16'
.file: 'cmplStd/test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629e0>
.name: 'ptrUint32'
.file: 'cmplStd/test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629e8>
.name: 'ptrUint64'
.file: 'cmplStd/test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629f0>
.name: 'ptrFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0629f8>
.name: 'ptrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:47'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062a00>
.name: 'ptrTypename'
.file: 'cmplStd/test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062a08>
.name: 'ptrFunction'
.file: 'cmplStd/test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062a10>
.name: 'ptrPointer'
.file: 'cmplStd/test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062a18>
.name: 'ptrVariant'
.file: 'cmplStd/test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062a20>
.name: 'ptrObject'
.file: 'cmplStd/test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a28>
.name: 'varVoid'
.file: 'cmplStd/test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a30>
.name: 'varBool'
.file: 'cmplStd/test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a38>
.name: 'varChar'
.file: 'cmplStd/test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a40>
.name: 'varInt8'
.file: 'cmplStd/test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a48>
.name: 'varInt16'
.file: 'cmplStd/test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a50>
.name: 'varInt32'
.file: 'cmplStd/test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a58>
.name: 'varInt64'
.file: 'cmplStd/test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a60>
.name: 'varUint8'
.file: 'cmplStd/test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a68>
.name: 'varUint16'
.file: 'cmplStd/test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a70>
.name: 'varUint32'
.file: 'cmplStd/test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a78>
.name: 'varUint64'
.file: 'cmplStd/test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a80>
.name: 'varFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a88>
.name: 'varFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:67'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a90>
.name: 'varTypename'
.file: 'cmplStd/test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062a98>
.name: 'varFunction'
.file: 'cmplStd/test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062aa0>
.name: 'varPointer'
.file: 'cmplStd/test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062aa8>
.name: 'varVariant'
.file: 'cmplStd/test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062ab0>
.name: 'varObject'
.file: 'cmplStd/test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ab8>
.name: 'typVoid'
.file: 'cmplStd/test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ac0>
.name: 'typBool'
.file: 'cmplStd/test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ac8>
.name: 'typChar'
.file: 'cmplStd/test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ad0>
.name: 'typInt8'
.file: 'cmplStd/test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ad8>
.name: 'typInt16'
.file: 'cmplStd/test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ae0>
.name: 'typInt32'
.file: 'cmplStd/test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062ae8>
.name: 'typInt64'
.file: 'cmplStd/test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062af0>
.name: 'typUint8'
.file: 'cmplStd/test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062af8>
.name: 'typUint16'
.file: 'cmplStd/test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b00>
.name: 'typUint32'
.file: 'cmplStd/test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b08>
.name: 'typUint64'
.file: 'cmplStd/test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b10>
.name: 'typFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b18>
.name: 'typFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b20>
.name: 'typTypename'
.file: 'cmplStd/test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b28>
.name: 'typFunction'
.file: 'cmplStd/test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b30>
.name: 'typPointer'
.file: 'cmplStd/test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b38>
.name: 'typVariant'
.file: 'cmplStd/test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b40>
.name: 'typObject'
.file: 'cmplStd/test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062b48>
.name: 'valueOfPtr'
.file: 'cmplStd/test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062b50>
.name: 'valueOfVar'
.file: 'cmplStd/test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b58>
.name: 'valueOfTyp'
.file: 'cmplStd/test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062b60>
.name: 'typeOfValue'
.file: 'cmplStd/test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@062b68>
.name: 'copyPtrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@062b70>
.name: 'copyVarFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062b78>
.name: 'variable'
.file: 'cmplStd/test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@062b80>
.name: 'constant'
.file: 'cmplStd/test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@048e00>
.name: 'ComplexVal'
.file: 'cmplStd/test/lang/init.variable.ci:9'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
	internal usages: 1
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@048fe0>
.name: 'ComplexObj'
.file: 'cmplStd/test/lang/init.variable.ci:13'
.field re: float64 (size: 8, offs: <+4>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+12>, cast: const variable(f64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `ComplexObj`
	cmplStd/test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+4>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `re`
	cmplStd/test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+12>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
	internal usages: 2
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
valInitImplicit: ComplexVal {
.kind: static variable(val)
.base: `ComplexVal`
.size: 16
.offset: <@062b88>
.name: 'valInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	void(valInitImplicit.re := (8));
	void(valInitImplicit.im := (0));
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: static variable(ref)
.base: `ComplexObj`
.size: 4
.offset: <@062b98>
.name: 'objInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	void(objInitImplicit := create(ComplexObj));
	void(objInitImplicit.re := (8));
	void(objInitImplicit.im := (0));
}
.usages:
}
objInitExplicit: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@062ba0>
.name: 'objInitExplicit'
.file: 'cmplStd/test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	void(objInitExplicit := create(ComplexObj));
	void(objInitExplicit.re := (8));
	void(objInitExplicit.im := (0));
}
.usages:
}
empty(): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@062ba8>
.name: 'empty'
.file: 'cmplStd/test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <empty @062ba8> - <empty+1 @062ba9>)
	<empty @062ba8>      : 03                         ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@062bb0>
.name: 'funAdd'
.file: 'cmplStd/test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <funAdd @062bb0> - <funAdd+8 @062bb8>)
	cmplStd/test/lang/function.ci:8: (8 bytes: <funAdd @062bb0> - <funAdd+8 @062bb8>): return .result := x + y;
	<funAdd @062bb0>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @062bb2>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @062bb4>    : 51                         add.i32
	<funAdd+5 @062bb5>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @062bb7>    : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:15: referenced as `funAdd`
	cmplStd/test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062bb8>
.name: 'funAddResult'
.file: 'cmplStd/test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@062bc0>
.name: 'funAddRef'
.file: 'cmplStd/test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	cmplStd/test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062bc8>
.name: 'funAddRefResult'
.file: 'cmplStd/test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@062bd0>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:27: referenced as `funMul`
	cmplStd/test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062bd8>
.name: 'funMulResult'
.file: 'cmplStd/test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@062be0>
.name: 'funMulRef'
.file: 'cmplStd/test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062be8>
.name: 'funMulRefResult'
.file: 'cmplStd/test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@062bf0>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <funMul @062bf0> - <funMul+8 @062bf8>)
	cmplStd/test/lang/function.ci:34: (8 bytes: <funMul @062bf0> - <funMul+8 @062bf8>): return .result := x * y;
	<funMul @062bf0>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @062bf2>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @062bf4>    : 53                         mul.i32
	<funMul+5 @062bf5>    : 13 04                      set.x32 sp(4)
	<funMul+7 @062bf7>    : 03                         ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 54
.offset: <@062bf8>
.name: 'fib'
.file: 'cmplStd/test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <fib @062bf8> - <fib+54 @062c2e>)
	cmplStd/test/lang/function.ci:39: (16 bytes: <fib @062bf8> - <fib+16 @062c08>): if (n <= (1))
	<fib @062bf8>      : 10 01                      dup.x32 sp(1)
	<fib+2 @062bfa>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @062bff>    : 39                         cgt.u32
	<fib+8 @062c00>    : 05 08 00 00                jnz <fib+16 @062c08>
	cmplStd/test/lang/function.ci:40: (4 bytes: <fib+12 @062c04> - <fib+16 @062c08>): return .result := n;
	<fib+12 @062c04>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @062c07>   : 03                         ret
	cmplStd/test/lang/function.ci:42: (38 bytes: <fib+16 @062c08> - <fib+54 @062c2e>): return .result := fib(n - (1)) + fib(n - (2));
	<fib+16 @062c08>   : 19                         load.z32
	<fib+17 @062c09>   : 10 02                      dup.x32 sp(2)
	<fib+19 @062c0b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @062c0f>   : 1f f8 2b 06 00             load.ref <@062bf8> ;fib(n: uint32): uint32
	<fib+28 @062c14>   : 02                         call
	<fib+29 @062c15>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @062c19>   : 19                         load.z32
	<fib+34 @062c1a>   : 10 03                      dup.x32 sp(3)
	<fib+36 @062c1c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @062c20>   : 1f f8 2b 06 00             load.ref <@062bf8> ;fib(n: uint32): uint32
	<fib+45 @062c25>   : 02                         call
	<fib+46 @062c26>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @062c2a>   : 51                         add.i32
	<fib+51 @062c2b>   : 13 03                      set.x32 sp(3)
	<fib+53 @062c2d>   : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:46: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@062c30>
.name: 'fibonacci_13'
.file: 'cmplStd/test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c38>
.name: 'sizeofVoid'
.file: 'cmplStd/test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c40>
.name: 'sizeofBool'
.file: 'cmplStd/test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c48>
.name: 'sizeofChar'
.file: 'cmplStd/test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c50>
.name: 'sizeofInt8'
.file: 'cmplStd/test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c58>
.name: 'sizeofInt16'
.file: 'cmplStd/test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c60>
.name: 'sizeofInt32'
.file: 'cmplStd/test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c68>
.name: 'sizeofInt64'
.file: 'cmplStd/test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c70>
.name: 'sizeofUint8'
.file: 'cmplStd/test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c78>
.name: 'sizeofUint16'
.file: 'cmplStd/test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c80>
.name: 'sizeofUint32'
.file: 'cmplStd/test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c88>
.name: 'sizeofUint64'
.file: 'cmplStd/test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c90>
.name: 'sizeofFloat32'
.file: 'cmplStd/test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062c98>
.name: 'sizeofFloat64'
.file: 'cmplStd/test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062ca0>
.name: 'sizeofPointer'
.file: 'cmplStd/test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062ca8>
.name: 'sizeofVariant'
.file: 'cmplStd/test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062cb0>
.name: 'sizeofTypename'
.file: 'cmplStd/test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062cb8>
.name: 'sizeofFunction'
.file: 'cmplStd/test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062cc0>
.name: 'sizeofObject'
.file: 'cmplStd/test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@04b5b0>
.name: 'RecordSizeof'
.file: 'cmplStd/test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@04b6f0>
.name: 'RecordSizeofExt'
.file: 'cmplStd/test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'cmplStd/test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062cc8>
.name: 'typeofRecord'
.file: 'cmplStd/test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	cmplStd/test/lang/reflect.ci:37: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:35: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:34: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:33: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:32: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@062cd0>
.name: 'nameOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062cd8>
.name: 'offsetOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062ce0>
.name: 'sizeOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@062ce8>
.name: 'fileOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062cf0>
.name: 'lineOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062cf8>
.name: 'typeofBase'
.file: 'cmplStd/test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	cmplStd/test/lang/reflect.ci:44: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:42: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:41: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:40: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:39: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@062d00>
.name: 'nameOfBase'
.file: 'cmplStd/test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d08>
.name: 'offsetOfBase'
.file: 'cmplStd/test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d10>
.name: 'sizeOfBase'
.file: 'cmplStd/test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@062d18>
.name: 'fileOfBase'
.file: 'cmplStd/test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d20>
.name: 'lineOfBase'
.file: 'cmplStd/test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062d28>
.name: 'typeofBase1'
.file: 'cmplStd/test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:46: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d30>
.name: 'offsetOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d38>
.name: 'sizeOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@062d40>
.name: 'typeofBase2'
.file: 'cmplStd/test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `typeofBase2`
	cmplStd/test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d48>
.name: 'offsetOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d50>
.name: 'sizeOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@04c6f0>
.name: 'RecordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:2'
.field Inner: typename (size: 8, offs: <@04c790>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@062d58>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@062d60>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@062d68>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@062d70>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@062d78>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@062d80>, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	cmplStd/test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04c790>
.name: 'Inner'
.file: 'cmplStd/test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	cmplStd/test/lang/init.member.ci:49: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:46: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:43: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:25: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:64: referenced as `member`
	cmplStd/test/lang/init.member.ci:59: referenced as `member`
	cmplStd/test/lang/init.member.ci:49: referenced as `member`
	cmplStd/test/lang/init.member.ci:46: referenced as `member`
	internal usages: 1
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:65: referenced as `constant`
	cmplStd/test/lang/init.member.ci:60: referenced as `constant`
	cmplStd/test/lang/init.member.ci:49: referenced as `constant`
	cmplStd/test/lang/init.member.ci:46: referenced as `constant`
	cmplStd/test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'cmplStd/test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	cmplStd/test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'cmplStd/test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	cmplStd/test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'cmplStd/test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'cmplStd/test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d58>
.name: 'global'
.file: 'cmplStd/test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062d60>
.name: 'globalInit'
.file: 'cmplStd/test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@062d68>
.name: 'globalConstant'
.file: 'cmplStd/test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@062d70>
.name: 'globalRec'
.file: 'cmplStd/test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	void(globalRec.constant := 4);
	void(globalRec.member := (0));
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@062d78>
.name: 'globalRecInit'
.file: 'cmplStd/test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@062d80>
.name: 'globalConstantRec'
.file: 'cmplStd/test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@062d88>
.name: 'recordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:52'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04d608>
.name: 'RecordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:4'
.field staticMethod: function (size: 39, offs: <@062da8>, cast: static function)
.field forwardMethod: function (size: 4, offs: <@062dd0>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 39, offs: <@062dd8>, cast: static function)
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field forwardMethod: function (size: 39, offs: <@062e00>, cast: static function)
.doc: 'static, virtual and abstract methods'
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@062da8>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <staticMethod @062da8> - <staticMethod+39 @062dcf>)
	cmplStd/test/lang/init.method.ci:11: (38 bytes: <staticMethod @062da8> - <staticMethod+38 @062dce>): trace("staticMethod", x);
	<staticMethod @062da8>      : 1f 90 d1 04 00             load.ref <@04d190> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @062dad>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @062db2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @062db7>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @062dbc>   : 1f 3a d2 04 00             load.ref <@04d23a> ;"staticMethod"
	<staticMethod+25 @062dc1>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<staticMethod+30 @062dc6>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @062dca>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @062dce>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:101: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:87: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@062dd0>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	cmplStd/test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'cmplStd/test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'cmplStd/test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	internal usages: 1
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@062dd8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <virtualMethod @062dd8> - <virtualMethod+39 @062dff>)
	cmplStd/test/lang/init.method.ci:41: (38 bytes: <virtualMethod @062dd8> - <virtualMethod+38 @062dfe>): trace("virtualMethod", x);
	<virtualMethod @062dd8>      : 1f 90 d1 04 00             load.ref <@04d190> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @062ddd>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @062de2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @062de7>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @062dec>   : 1f 26 d5 04 00             load.ref <@04d526> ;"virtualMethod"
	<virtualMethod+25 @062df1>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<virtualMethod+30 @062df6>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @062dfa>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @062dfe>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:93: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:79: referenced as `virtualMethod`
	internal usages: 1
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@062e00>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <forwardMethod @062e00> - <forwardMethod+39 @062e27>)
	cmplStd/test/lang/init.method.ci:48: (38 bytes: <forwardMethod @062e00> - <forwardMethod+38 @062e26>): trace("forwardMethod", x);
	<forwardMethod @062e00>      : 1f 90 d1 04 00             load.ref <@04d190> ;"cmplStd/test/lang/init.method.ci"
	<forwardMethod+5 @062e05>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @062e0a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @062e0f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @062e14>   : 1f ad d2 04 00             load.ref <@04d2ad> ;"forwardMethod"
	<forwardMethod+25 @062e19>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<forwardMethod+30 @062e1e>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @062e22>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @062e26>   : 03                         ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@062e28>
.name: 'globalFunction'
.file: 'cmplStd/test/lang/init.method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <globalFunction @062e28> - <globalFunction+39 @062e4f>)
	cmplStd/test/lang/init.method.ci:58: (38 bytes: <globalFunction @062e28> - <globalFunction+38 @062e4e>): trace("globalFunction", x);
	<globalFunction @062e28>      : 1f 90 d1 04 00             load.ref <@04d190> ;"cmplStd/test/lang/init.method.ci"
	<globalFunction+5 @062e2d>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @062e32>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @062e37>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @062e3c>   : 1f 59 d5 04 00             load.ref <@04d559> ;"globalFunction"
	<globalFunction+25 @062e41>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<globalFunction+30 @062e46>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @062e4a>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @062e4e>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@062e50>
.name: 'recordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:102: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:98: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:97: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:79: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 66
.offset: <@062e60>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <staticMethod @062e60> - <staticMethod+66 @062ea2>)
	cmplStd/test/lang/init.method.ci:85: (35 bytes: <staticMethod @062e60> - <staticMethod+35 @062e83>): debug("extension.staticMethod");
	<staticMethod @062e60>      : 1f 90 d1 04 00             load.ref <@04d190> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @062e65>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @062e6a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @062e6f>   : 19                         load.z32
	<staticMethod+16 @062e70>   : 1f d5 d5 04 00             load.ref <@04d5d5> ;"extension.staticMethod"
	<staticMethod+21 @062e75>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<staticMethod+26 @062e7a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @062e7f>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:86: (30 bytes: <staticMethod+35 @062e83> - <staticMethod+65 @062ea1>): if ((this) != null)
	<staticMethod+35 @062e83>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @062e87>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @062e8c>   : 57                         ceq.i32
	<staticMethod+45 @062e8d>   : 05 14 00 00                jnz <staticMethod+65 @062ea1>
	cmplStd/test/lang/init.method.ci:87: (16 bytes: <staticMethod+49 @062e91> - <staticMethod+65 @062ea1>): RecordMethodTest.staticMethod(this, x);
	<staticMethod+49 @062e91>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @062e93>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @062e95>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @062e97>   : 1f a8 2d 06 00             load.ref <@062da8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @062e9c>   : 02                         call
	<staticMethod+61 @062e9d>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @062ea1>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@062ea8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <virtualMethod @062ea8> - <virtualMethod+63 @062ee7>)
	cmplStd/test/lang/init.method.ci:91: (35 bytes: <virtualMethod @062ea8> - <virtualMethod+35 @062ecb>): debug("extension.virtualMethod");
	<virtualMethod @062ea8>      : 1f 90 d1 04 00             load.ref <@04d190> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @062ead>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @062eb2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @062eb7>   : 19                         load.z32
	<virtualMethod+16 @062eb8>   : 1f ec d5 04 00             load.ref <@04d5ec> ;"extension.virtualMethod"
	<virtualMethod+21 @062ebd>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<virtualMethod+26 @062ec2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @062ec7>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:92: (27 bytes: <virtualMethod+35 @062ecb> - <virtualMethod+62 @062ee6>): if ((this) != null)
	<virtualMethod+35 @062ecb>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @062ecf>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @062ed4>   : 57                         ceq.i32
	<virtualMethod+45 @062ed5>   : 05 11 00 00                jnz <virtualMethod+62 @062ee6>
	cmplStd/test/lang/init.method.ci:93: (13 bytes: <virtualMethod+49 @062ed9> - <virtualMethod+62 @062ee6>): this.virtualMethod(this, x);
	<virtualMethod+49 @062ed9>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @062edb>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @062edd>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @062edf>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @062ee1>   : 02                         call
	<virtualMethod+58 @062ee2>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @062ee6>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:98: referenced as `virtualMethod`
}
arrFixedInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@062ee8>
.name: 'arrFixedInit'
.file: 'cmplStd/test/lang/init.array.ci:11'
.value: {
	void(arrFixedInit[0] := (42));
	void(arrFixedInit[1] := (43));
	void(arrFixedInit[2] := (44));
	void(arrFixedInit[3] := (45));
	void(arrFixedInit[4] := (46));
	void(arrFixedInit[5] := (47));
	void(arrFixedInit[6] := (48));
}
.usages:
	cmplStd/test/lang/init.array.ci:80: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:76: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:72: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:68: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:66: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:64: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:63: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:62: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:62: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:58: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:57: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:56: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:49: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:23: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:22: referenced as `arrFixedInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@062f20>
.name: 'arrArrayInitNull'
.file: 'cmplStd/test/lang/init.array.ci:18'
.value: null
.usages:
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@062f28>
.name: 'arrSliceInitNull'
.file: 'cmplStd/test/lang/init.array.ci:19'
.value: null
.usages:
	cmplStd/test/lang/init.array.ci:61: referenced as `arrSliceInitNull`
	cmplStd/test/lang/init.array.ci:48: referenced as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@062f30>
.name: 'arrArrayInitFixed'
.file: 'cmplStd/test/lang/init.array.ci:22'
.value: arrFixedInit
.usages:
	cmplStd/test/lang/init.array.ci:77: referenced as `arrArrayInitFixed`
	cmplStd/test/lang/init.array.ci:73: referenced as `arrArrayInitFixed`
	cmplStd/test/lang/init.array.ci:69: referenced as `arrArrayInitFixed`
	cmplStd/test/lang/init.array.ci:30: referenced as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@062f38>
.name: 'arrSliceInitFixed'
.file: 'cmplStd/test/lang/init.array.ci:23'
.value: arrFixedInit
.usages:
	cmplStd/test/lang/init.array.ci:82: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:78: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:74: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:70: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:63: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:57: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:27: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:26: referenced as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@062f40>
.name: 'arrArrayInitSlice'
.file: 'cmplStd/test/lang/init.array.ci:26'
.value: arrSliceInitFixed
.usages:
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@062f48>
.name: 'arrSliceInitSlice'
.file: 'cmplStd/test/lang/init.array.ci:27'
.value: arrSliceInitFixed
.usages:
	cmplStd/test/lang/init.array.ci:84: referenced as `arrSliceInitSlice`
	cmplStd/test/lang/init.array.ci:64: referenced as `arrSliceInitSlice`
	cmplStd/test/lang/init.array.ci:58: referenced as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@062f50>
.name: 'arrArrayInitPtr'
.file: 'cmplStd/test/lang/init.array.ci:30'
.value: arrArrayInitFixed
.usages:
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@062f58>
.name: 'strFixed'
.file: 'cmplStd/test/lang/init.array.ci:34'
.value: {
	void(strFixed[0] := 's');
	void(strFixed[1] := 't');
	void(strFixed[2] := 'r');
	void(strFixed[3] := 'i');
	void(strFixed[4] := 'n');
	void(strFixed[5] := 'g');
	void(strFixed[6] := (0));
}
.usages:
	cmplStd/test/lang/init.array.ci:35: referenced as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@062f60>
.name: 'strArray'
.file: 'cmplStd/test/lang/init.array.ci:37'
.value: "string"
.usages:
	cmplStd/test/lang/init.array.ci:38: referenced as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@062f68>
.name: 'strSlice'
.file: 'cmplStd/test/lang/init.array.ci:40'
.value: "string"
.usages:
	cmplStd/test/lang/init.array.ci:41: referenced as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static function
.base: `function`
.size: 4
.offset: <@062f70>
.name: 'lenSlice'
.file: 'cmplStd/test/lang/init.array.ci:51'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: const variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <lenSlice @062f70> - <lenSlice+4 @062f74>)
	cmplStd/test/lang/init.array.ci:51: (4 bytes: <lenSlice @062f70> - <lenSlice+4 @062f74>): return .result := values.length;
	<lenSlice @062f70>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @062f73>    : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:64: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:63: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:62: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:61: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:60: referenced as `lenSlice`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@062f78>
.name: 'nthFixed'
.file: 'cmplStd/test/lang/init.array.ci:52'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <nthFixed @062f78> - <nthFixed+12 @062f84>)
	cmplStd/test/lang/init.array.ci:52: (12 bytes: <nthFixed @062f78> - <nthFixed+12 @062f84>): return .result := values[idx];
	<nthFixed @062f78>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @062f7a>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @062f7c>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @062f80>    : 29                         load.i64
	<nthFixed+9 @062f81>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @062f83>   : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:74: referenced as `nthFixed`
	cmplStd/test/lang/init.array.ci:73: referenced as `nthFixed`
	cmplStd/test/lang/init.array.ci:72: referenced as `nthFixed`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@062f88>
.name: 'nthArray'
.file: 'cmplStd/test/lang/init.array.ci:53'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <nthArray @062f88> - <nthArray+12 @062f94>)
	cmplStd/test/lang/init.array.ci:53: (12 bytes: <nthArray @062f88> - <nthArray+12 @062f94>): return .result := values[idx];
	<nthArray @062f88>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @062f8a>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @062f8c>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @062f90>    : 29                         load.i64
	<nthArray+9 @062f91>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @062f93>   : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:78: referenced as `nthArray`
	cmplStd/test/lang/init.array.ci:77: referenced as `nthArray`
	cmplStd/test/lang/init.array.ci:76: referenced as `nthArray`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@062f98>
.name: 'nthSlice'
.file: 'cmplStd/test/lang/init.array.ci:54'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: const variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <nthSlice @062f98> - <nthSlice+12 @062fa4>)
	cmplStd/test/lang/init.array.ci:54: (12 bytes: <nthSlice @062f98> - <nthSlice+12 @062fa4>): return .result := values[idx];
	<nthSlice @062f98>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @062f9a>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @062f9c>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @062fa0>    : 29                         load.i64
	<nthSlice+9 @062fa1>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @062fa3>   : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:82: referenced as `nthSlice`
	cmplStd/test/lang/init.array.ci:80: referenced as `nthSlice`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@050d30>
.name: 'rgbF32'
.file: 'cmplStd/test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	cmplStd/test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@050fb0>
.name: 'rgbU8'
.file: 'cmplStd/test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	cmplStd/test/lang/recUnion.ci:28: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:27: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:26: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `b`
	cmplStd/test/lang/recUnion.ci:28: referenced as `b`
	cmplStd/test/lang/recUnion.ci:27: referenced as `b`
	cmplStd/test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `g`
	cmplStd/test/lang/recUnion.ci:28: referenced as `g`
	cmplStd/test/lang/recUnion.ci:27: referenced as `g`
	cmplStd/test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `r`
	cmplStd/test/lang/recUnion.ci:28: referenced as `r`
	cmplStd/test/lang/recUnion.ci:27: referenced as `r`
	cmplStd/test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@051230>
.name: 'color'
.file: 'cmplStd/test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `color`
	cmplStd/test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'cmplStd/test/lang/recUnion.ci:17'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'cmplStd/test/lang/recUnion.ci:18'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@051410>
.name: 'Color'
.file: 'cmplStd/test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'cmplStd/test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@062fa8>
.name: 'black'
.file: 'cmplStd/test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@062fb0>
.name: 'green'
.file: 'cmplStd/test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@062fb8>
.name: 'white'
.file: 'cmplStd/test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@062fc0>
.name: 'cyan'
.file: 'cmplStd/test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@062fc8>
.name: 'blue'
.file: 'cmplStd/test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0518f0>
.name: 'record_pack0'
.file: 'cmplStd/test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@051d50>
.name: 'record_pack1'
.file: 'cmplStd/test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0521b0>
.name: 'record_pack2'
.file: 'cmplStd/test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@052610>
.name: 'record_pack4'
.file: 'cmplStd/test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@052a70>
.name: 'record_pack8'
.file: 'cmplStd/test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@052ed0>
.name: 'record_packDef'
.file: 'cmplStd/test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'cmplStd/test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	cmplStd/test/lang/useOperator.ci:260: referenced as `a`
	cmplStd/test/lang/useOperator.ci:237: referenced as `a`
	cmplStd/test/lang/useOperator.ci:214: referenced as `a`
	cmplStd/test/lang/useOperator.ci:191: referenced as `a`
	cmplStd/test/lang/useOperator.ci:168: referenced as `a`
	cmplStd/test/lang/useOperator.ci:145: referenced as `a`
	cmplStd/test/lang/useOperator.ci:122: referenced as `a`
	cmplStd/test/lang/useOperator.ci:99: referenced as `a`
	cmplStd/test/lang/useOperator.ci:76: referenced as `a`
	cmplStd/test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'cmplStd/test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	cmplStd/test/lang/useOperator.ci:261: referenced as `b`
	cmplStd/test/lang/useOperator.ci:238: referenced as `b`
	cmplStd/test/lang/useOperator.ci:215: referenced as `b`
	cmplStd/test/lang/useOperator.ci:192: referenced as `b`
	cmplStd/test/lang/useOperator.ci:169: referenced as `b`
	cmplStd/test/lang/useOperator.ci:146: referenced as `b`
	cmplStd/test/lang/useOperator.ci:123: referenced as `b`
	cmplStd/test/lang/useOperator.ci:100: referenced as `b`
	cmplStd/test/lang/useOperator.ci:77: referenced as `b`
	cmplStd/test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@062fd0>
.name: 'shift'
.file: 'cmplStd/test/lang/useOperator.ci:5'
.value: 2
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:228: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:227: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:205: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:204: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:182: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:181: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:159: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:158: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:136: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:135: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:113: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:112: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:90: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:89: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:67: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:66: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:44: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@062fd8>
.name: 'boolA'
.file: 'cmplStd/test/lang/useOperator.ci:7'
.value: true
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@062fe0>
.name: 'boolB'
.file: 'cmplStd/test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:22: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@062fe8>
.name: 'boolAnd'
.file: 'cmplStd/test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@062ff0>
.name: 'boolIor'
.file: 'cmplStd/test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@062ff8>
.name: 'boolXor'
.file: 'cmplStd/test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063000>
.name: 'boolNot'
.file: 'cmplStd/test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063008>
.name: 'boolCeq'
.file: 'cmplStd/test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063010>
.name: 'boolCne'
.file: 'cmplStd/test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063018>
.name: 'boolClt'
.file: 'cmplStd/test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063020>
.name: 'boolCle'
.file: 'cmplStd/test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063028>
.name: 'boolCgt'
.file: 'cmplStd/test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063030>
.name: 'boolCge'
.file: 'cmplStd/test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063038>
.name: 'chrA'
.file: 'cmplStd/test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:44: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:43: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063040>
.name: 'chrB'
.file: 'cmplStd/test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:45: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:34: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:33: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063048>
.name: 'chrPls'
.file: 'cmplStd/test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063050>
.name: 'chrNeg'
.file: 'cmplStd/test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063058>
.name: 'chrCmt'
.file: 'cmplStd/test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063060>
.name: 'chrAdd'
.file: 'cmplStd/test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063068>
.name: 'chrSub'
.file: 'cmplStd/test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063070>
.name: 'chrMul'
.file: 'cmplStd/test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063078>
.name: 'chrDiv'
.file: 'cmplStd/test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063080>
.name: 'chrMod'
.file: 'cmplStd/test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063088>
.name: 'chrAnd'
.file: 'cmplStd/test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063090>
.name: 'chrIor'
.file: 'cmplStd/test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063098>
.name: 'chrXor'
.file: 'cmplStd/test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0630a0>
.name: 'chrShl'
.file: 'cmplStd/test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0630a8>
.name: 'chrShr'
.file: 'cmplStd/test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630b0>
.name: 'chrNot'
.file: 'cmplStd/test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630b8>
.name: 'chrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630c0>
.name: 'chrCne'
.file: 'cmplStd/test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630c8>
.name: 'chrClt'
.file: 'cmplStd/test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630d0>
.name: 'chrCle'
.file: 'cmplStd/test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630d8>
.name: 'chrCgt'
.file: 'cmplStd/test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0630e0>
.name: 'chrCge'
.file: 'cmplStd/test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0630e8>
.name: 'i8A'
.file: 'cmplStd/test/lang/useOperator.ci:53'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:67: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:66: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0630f0>
.name: 'i8B'
.file: 'cmplStd/test/lang/useOperator.ci:54'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:68: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:57: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:56: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0630f8>
.name: 'i8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063100>
.name: 'i8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063108>
.name: 'i8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063110>
.name: 'i8Add'
.file: 'cmplStd/test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063118>
.name: 'i8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063120>
.name: 'i8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063128>
.name: 'i8Div'
.file: 'cmplStd/test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063130>
.name: 'i8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063138>
.name: 'i8And'
.file: 'cmplStd/test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063140>
.name: 'i8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063148>
.name: 'i8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063150>
.name: 'i8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063158>
.name: 'i8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063160>
.name: 'i8Not'
.file: 'cmplStd/test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063168>
.name: 'i8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063170>
.name: 'i8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063178>
.name: 'i8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063180>
.name: 'i8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063188>
.name: 'i8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063190>
.name: 'i8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063198>
.name: 'u8A'
.file: 'cmplStd/test/lang/useOperator.ci:76'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:90: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:89: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631a0>
.name: 'u8B'
.file: 'cmplStd/test/lang/useOperator.ci:77'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:91: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:80: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:79: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631a8>
.name: 'u8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631b0>
.name: 'u8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631b8>
.name: 'u8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631c0>
.name: 'u8Add'
.file: 'cmplStd/test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631c8>
.name: 'u8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631d0>
.name: 'u8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631d8>
.name: 'u8Div'
.file: 'cmplStd/test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631e0>
.name: 'u8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631e8>
.name: 'u8And'
.file: 'cmplStd/test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631f0>
.name: 'u8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0631f8>
.name: 'u8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063200>
.name: 'u8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063208>
.name: 'u8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063210>
.name: 'u8Not'
.file: 'cmplStd/test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063218>
.name: 'u8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063220>
.name: 'u8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063228>
.name: 'u8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063230>
.name: 'u8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063238>
.name: 'u8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063240>
.name: 'u8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063248>
.name: 'i16A'
.file: 'cmplStd/test/lang/useOperator.ci:99'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:113: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:112: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063250>
.name: 'i16B'
.file: 'cmplStd/test/lang/useOperator.ci:100'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:114: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:103: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:102: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063258>
.name: 'i16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063260>
.name: 'i16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063268>
.name: 'i16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063270>
.name: 'i16Add'
.file: 'cmplStd/test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063278>
.name: 'i16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063280>
.name: 'i16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063288>
.name: 'i16Div'
.file: 'cmplStd/test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063290>
.name: 'i16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063298>
.name: 'i16And'
.file: 'cmplStd/test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0632a0>
.name: 'i16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0632a8>
.name: 'i16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0632b0>
.name: 'i16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0632b8>
.name: 'i16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632c0>
.name: 'i16Not'
.file: 'cmplStd/test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632c8>
.name: 'i16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632d0>
.name: 'i16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632d8>
.name: 'i16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632e0>
.name: 'i16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632e8>
.name: 'i16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0632f0>
.name: 'i16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0632f8>
.name: 'u16A'
.file: 'cmplStd/test/lang/useOperator.ci:122'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:136: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:135: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063300>
.name: 'u16B'
.file: 'cmplStd/test/lang/useOperator.ci:123'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:137: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:126: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:125: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063308>
.name: 'u16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063310>
.name: 'u16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063318>
.name: 'u16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063320>
.name: 'u16Add'
.file: 'cmplStd/test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063328>
.name: 'u16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063330>
.name: 'u16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063338>
.name: 'u16Div'
.file: 'cmplStd/test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063340>
.name: 'u16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063348>
.name: 'u16And'
.file: 'cmplStd/test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063350>
.name: 'u16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063358>
.name: 'u16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063360>
.name: 'u16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@063368>
.name: 'u16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063370>
.name: 'u16Not'
.file: 'cmplStd/test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063378>
.name: 'u16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063380>
.name: 'u16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063388>
.name: 'u16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063390>
.name: 'u16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063398>
.name: 'u16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0633a0>
.name: 'u16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633a8>
.name: 'i32A'
.file: 'cmplStd/test/lang/useOperator.ci:145'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:159: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:158: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633b0>
.name: 'i32B'
.file: 'cmplStd/test/lang/useOperator.ci:146'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:160: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:149: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:148: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633b8>
.name: 'i32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633c0>
.name: 'i32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633c8>
.name: 'i32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633d0>
.name: 'i32Add'
.file: 'cmplStd/test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633d8>
.name: 'i32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633e0>
.name: 'i32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633e8>
.name: 'i32Div'
.file: 'cmplStd/test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633f0>
.name: 'i32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633f8>
.name: 'i32And'
.file: 'cmplStd/test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063400>
.name: 'i32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063408>
.name: 'i32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063410>
.name: 'i32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063418>
.name: 'i32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063420>
.name: 'i32Not'
.file: 'cmplStd/test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063428>
.name: 'i32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063430>
.name: 'i32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063438>
.name: 'i32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063440>
.name: 'i32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063448>
.name: 'i32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063450>
.name: 'i32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063458>
.name: 'u32A'
.file: 'cmplStd/test/lang/useOperator.ci:168'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:182: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:181: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063460>
.name: 'u32B'
.file: 'cmplStd/test/lang/useOperator.ci:169'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:183: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:172: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:171: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063468>
.name: 'u32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063470>
.name: 'u32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063478>
.name: 'u32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063480>
.name: 'u32Add'
.file: 'cmplStd/test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063488>
.name: 'u32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063490>
.name: 'u32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063498>
.name: 'u32Div'
.file: 'cmplStd/test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0634a0>
.name: 'u32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0634a8>
.name: 'u32And'
.file: 'cmplStd/test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0634b0>
.name: 'u32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0634b8>
.name: 'u32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0634c0>
.name: 'u32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0634c8>
.name: 'u32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0634d0>
.name: 'u32Not'
.file: 'cmplStd/test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0634d8>
.name: 'u32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0634e0>
.name: 'u32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0634e8>
.name: 'u32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0634f0>
.name: 'u32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0634f8>
.name: 'u32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063500>
.name: 'u32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063508>
.name: 'i64A'
.file: 'cmplStd/test/lang/useOperator.ci:191'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:205: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:204: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063510>
.name: 'i64B'
.file: 'cmplStd/test/lang/useOperator.ci:192'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:206: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:195: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:194: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063518>
.name: 'i64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063520>
.name: 'i64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063528>
.name: 'i64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063530>
.name: 'i64Add'
.file: 'cmplStd/test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063538>
.name: 'i64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063540>
.name: 'i64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063548>
.name: 'i64Div'
.file: 'cmplStd/test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063550>
.name: 'i64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063558>
.name: 'i64And'
.file: 'cmplStd/test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063560>
.name: 'i64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063568>
.name: 'i64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063570>
.name: 'i64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063578>
.name: 'i64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063580>
.name: 'i64Not'
.file: 'cmplStd/test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063588>
.name: 'i64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063590>
.name: 'i64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063598>
.name: 'i64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0635a0>
.name: 'i64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0635a8>
.name: 'i64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0635b0>
.name: 'i64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635b8>
.name: 'u64A'
.file: 'cmplStd/test/lang/useOperator.ci:214'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:228: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:227: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635c0>
.name: 'u64B'
.file: 'cmplStd/test/lang/useOperator.ci:215'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:229: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:218: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:217: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635c8>
.name: 'u64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635d0>
.name: 'u64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635d8>
.name: 'u64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635e0>
.name: 'u64Add'
.file: 'cmplStd/test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635e8>
.name: 'u64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635f0>
.name: 'u64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0635f8>
.name: 'u64Div'
.file: 'cmplStd/test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@063600>
.name: 'u64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@063608>
.name: 'u64And'
.file: 'cmplStd/test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@063610>
.name: 'u64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@063618>
.name: 'u64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@063620>
.name: 'u64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@063628>
.name: 'u64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063630>
.name: 'u64Not'
.file: 'cmplStd/test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063638>
.name: 'u64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063640>
.name: 'u64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063648>
.name: 'u64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063650>
.name: 'u64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063658>
.name: 'u64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063660>
.name: 'u64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063668>
.name: 'f32A'
.file: 'cmplStd/test/lang/useOperator.ci:237'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063670>
.name: 'f32B'
.file: 'cmplStd/test/lang/useOperator.ci:238'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:252: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:240: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063678>
.name: 'f32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063680>
.name: 'f32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063688>
.name: 'f32Add'
.file: 'cmplStd/test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063690>
.name: 'f32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063698>
.name: 'f32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0636a0>
.name: 'f32Div'
.file: 'cmplStd/test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0636a8>
.name: 'f32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636b0>
.name: 'f32Not'
.file: 'cmplStd/test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636b8>
.name: 'f32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636c0>
.name: 'f32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636c8>
.name: 'f32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636d0>
.name: 'f32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636d8>
.name: 'f32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0636e0>
.name: 'f32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0636e8>
.name: 'f64A'
.file: 'cmplStd/test/lang/useOperator.ci:260'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0636f0>
.name: 'f64B'
.file: 'cmplStd/test/lang/useOperator.ci:261'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:275: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:263: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0636f8>
.name: 'f64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063700>
.name: 'f64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063708>
.name: 'f64Add'
.file: 'cmplStd/test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063710>
.name: 'f64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063718>
.name: 'f64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063720>
.name: 'f64Div'
.file: 'cmplStd/test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063728>
.name: 'f64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063730>
.name: 'f64Not'
.file: 'cmplStd/test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063738>
.name: 'f64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063740>
.name: 'f64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063748>
.name: 'f64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063750>
.name: 'f64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063758>
.name: 'f64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063760>
.name: 'f64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063768>
.name: 'ptrA'
.file: 'cmplStd/test/lang/useOperator.ci:283'
.value: null
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrA`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063770>
.name: 'ptrB'
.file: 'cmplStd/test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrB`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063778>
.name: 'ptrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063780>
.name: 'ptrCne'
.file: 'cmplStd/test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063788>
.name: 't'
.file: 'cmplStd/test/lang/stmt.if.ci:26'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:65: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:62: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:59: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:56: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:53: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:50: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:43: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:36: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:32: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063790>
.name: 'forIdx'
.file: 'cmplStd/test/lang/stmt.for.ci:12'
.usages:
	cmplStd/test/lang/stmt.for.ci:14: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063798>
.name: 'testMathFloor_1'
.file: 'cmplStd/test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637a0>
.name: 'testMathFloor_2'
.file: 'cmplStd/test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637a8>
.name: 'testMathFloor_3'
.file: 'cmplStd/test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637b0>
.name: 'testMathFloor_4'
.file: 'cmplStd/test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637b8>
.name: 'testMathFloor_5'
.file: 'cmplStd/test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637c0>
.name: 'testMathFloor_6'
.file: 'cmplStd/test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637c8>
.name: 'testMathSign_1F'
.file: 'cmplStd/test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637d0>
.name: 'testMathSign_2F'
.file: 'cmplStd/test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637d8>
.name: 'testMathSign_3F'
.file: 'cmplStd/test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637e0>
.name: 'testMathSign_1f'
.file: 'cmplStd/test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637e8>
.name: 'testMathSign_2f'
.file: 'cmplStd/test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637f0>
.name: 'testMathSign_3f'
.file: 'cmplStd/test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0637f8>
.name: 'testMathAbs_1F'
.file: 'cmplStd/test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063800>
.name: 'testMathAbs_2F'
.file: 'cmplStd/test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063808>
.name: 'testMathAbs_3F'
.file: 'cmplStd/test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063810>
.name: 'testMathAbs_1f'
.file: 'cmplStd/test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063818>
.name: 'testMathAbs_2f'
.file: 'cmplStd/test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063820>
.name: 'testMathAbs_3f'
.file: 'cmplStd/test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063828>
.name: 'testMathMin_1f'
.file: 'cmplStd/test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063830>
.name: 'testMathMax_2f'
.file: 'cmplStd/test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063838>
.name: 'testMathMin_1F'
.file: 'cmplStd/test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063840>
.name: 'testMathMax_2F'
.file: 'cmplStd/test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063848>
.name: 'testMathClamp_1f'
.file: 'cmplStd/test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063850>
.name: 'testMathClamp_1F'
.file: 'cmplStd/test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063858>
.name: 'testMathLerp_1f'
.file: 'cmplStd/test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063860>
.name: 'testMathLerp_1F'
.file: 'cmplStd/test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063868>
.name: 'testMathSmooth_1f'
.file: 'cmplStd/test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063870>
.name: 'testMathSmooth_1F'
.file: 'cmplStd/test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063878>
.name: 'testMathMin_nan'
.file: 'cmplStd/test/std/test.math.ci:38'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063880>
.name: 'testMathMin_1'
.file: 'cmplStd/test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063888>
.name: 'testMathMax_nan'
.file: 'cmplStd/test/std/test.math.ci:40'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063890>
.name: 'testMathMax_9'
.file: 'cmplStd/test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063898>
.name: 'testMathSum_0'
.file: 'cmplStd/test/std/test.math.ci:43'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638a0>
.name: 'testMathSum_1'
.file: 'cmplStd/test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638a8>
.name: 'testMathSum_3'
.file: 'cmplStd/test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638b0>
.name: 'testMathSum_55'
.file: 'cmplStd/test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638b8>
.name: 'testMathEval_x'
.file: 'cmplStd/test/std/test.math.ci:48'
.value: 10
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:54: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:53: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:52: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:51: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:50: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:49: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638c0>
.name: 'testMathEval_0'
.file: 'cmplStd/test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638c8>
.name: 'testMathEval_1'
.file: 'cmplStd/test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638d0>
.name: 'testMathEval_2'
.file: 'cmplStd/test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638d8>
.name: 'testMathEval_3'
.file: 'cmplStd/test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638e0>
.name: 'testMathEval_4'
.file: 'cmplStd/test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638e8>
.name: 'testMathEval_5'
.file: 'cmplStd/test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638f0>
.name: 'testMathEval_6'
.file: 'cmplStd/test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0638f8>
.name: 'testMathSin_f64'
.file: 'cmplStd/test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063900>
.name: 'testMathCos_f64'
.file: 'cmplStd/test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063908>
.name: 'testMathTan_f64'
.file: 'cmplStd/test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063910>
.name: 'testMathSinh_f64'
.file: 'cmplStd/test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063918>
.name: 'testMathCosh_f64'
.file: 'cmplStd/test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063920>
.name: 'testMathAsin_f64'
.file: 'cmplStd/test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063928>
.name: 'testMathAcos_f64'
.file: 'cmplStd/test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063930>
.name: 'testMathCmp_f32'
.file: 'cmplStd/test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063938>
.name: 'testMathCmp_f64'
.file: 'cmplStd/test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063940>
.name: 'testMathAbsMod_f64_0a'
.file: 'cmplStd/test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063948>
.name: 'testMathAbsMod_f64_0b'
.file: 'cmplStd/test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063950>
.name: 'testMathAbsMod_f64_0c'
.file: 'cmplStd/test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063958>
.name: 'testMathAbsMod_f64_9a'
.file: 'cmplStd/test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063960>
.name: 'testMathAbsMod_f64_9b'
.file: 'cmplStd/test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063968>
.name: 'testMathAbsMod_f64_9c'
.file: 'cmplStd/test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063970>
.name: 'testMathAbsMod_f64_9d'
.file: 'cmplStd/test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063978>
.name: 'testMathAbsMod_f64_8a'
.file: 'cmplStd/test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063980>
.name: 'testMathAbsMod_f64_8b'
.file: 'cmplStd/test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063988>
.name: 'testMathAbsMod_f64_8c'
.file: 'cmplStd/test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063990>
.name: 'testMathAbsMod_f64_8d'
.file: 'cmplStd/test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063998>
.name: 'testMathAbsMod_f32_0a'
.file: 'cmplStd/test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639a0>
.name: 'testMathAbsMod_f32_0b'
.file: 'cmplStd/test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639a8>
.name: 'testMathAbsMod_f32_0c'
.file: 'cmplStd/test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639b0>
.name: 'testMathAbsMod_f32_9a'
.file: 'cmplStd/test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639b8>
.name: 'testMathAbsMod_f32_9b'
.file: 'cmplStd/test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639c0>
.name: 'testMathAbsMod_f32_9c'
.file: 'cmplStd/test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639c8>
.name: 'testMathAbsMod_f32_9d'
.file: 'cmplStd/test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639d0>
.name: 'testMathAbsMod_f32_8a'
.file: 'cmplStd/test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639d8>
.name: 'testMathAbsMod_f32_8b'
.file: 'cmplStd/test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639e0>
.name: 'testMathAbsMod_f32_8c'
.file: 'cmplStd/test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0639e8>
.name: 'testMathAbsMod_f32_8d'
.file: 'cmplStd/test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 14826
.offset: <@0639ec>
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b8>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000160>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@000208>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@0002b0>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000358>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000400>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@0004a8>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000550>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005f8>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0006a0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000748>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0007f0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000898>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@000940>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@0009e8>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a90>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000b40>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000de0>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000e88>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005ed8>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0078e0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@008230>, cast: static const inline)
.field System: typename (size: 0, offs: <@008f38>, cast: static const typename(void))
.field true: bool (size: 0, offs: <@000000>, cast: static const val)
.field false: bool (size: 0, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 24, offs: <@012348>, cast: static const typename(val))
.field assertEq: function (size: 103, offs: <@061078>, cast: static function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@0135e0>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01f0a0>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@061828>, cast: static function)
.field Complex: function (size: 7, offs: <@061830>, cast: static function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 139, offs: <@061838>, cast: static function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@0618c8>, cast: static function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@0618e8>, cast: static function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@024be8>, cast: static const typename(val))
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@02a080>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@061950>, cast: static function)
.field mat4f: function (size: 21, offs: <@061988>, cast: static function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field transpose: function (size: 49, offs: <@0619a0>, cast: static function)
.field mul: function (size: 245, offs: <@0619d8>, cast: static function)
.field rotation: function (size: 454, offs: <@061ad0>, cast: static function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@061c98>, cast: static function)
.field scale: function (size: 217, offs: <@061cf0>, cast: static function)
.field vec2d: typename (size: 16, offs: <@02f560>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@061dd0>, cast: static function)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field ceq: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@061dd8>, cast: static function)
.field indexOf: function (size: 50, offs: <@061e00>, cast: static function)
.field lastIndexOf: function (size: 50, offs: <@061e38>, cast: static function)
.field startsWith: function (size: 73, offs: <@061e70>, cast: static function)
.field endsWith: function (size: 126, offs: <@061ec0>, cast: static function)
.field compare: function (size: 63, offs: <@061f40>, cast: static function)
.field ignCaseCmp: function (size: 36, offs: <@061fc8>, cast: static function)
.field caseCmp: function (size: 14, offs: <@061ff0>, cast: static function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field equals: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@035060>, cast: static const typename(val))
.field append: function (size: 84, offs: <@062000>, cast: static function)
.field append: function (size: 707, offs: <@062068>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 236, offs: <@062330>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 63, offs: <@062430>, cast: static function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@062470>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@062478>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@062480>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@062488>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@062490>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@062498>, cast: static variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <@0624a0>, cast: static variable(f32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@0624a8>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@0624b0>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@0624b8>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@0624c0>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@0624c8>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@0624d0>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@0624d8>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@0624e0>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@0624e8>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@0624f0>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@0624f8>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@062500>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@062508>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@062510>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@062518>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@062520>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@062528>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@062530>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@062538>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@062540>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@062548>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@062550>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@062558>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@062560>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@062568>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@062570>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@062578>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@062580>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@062588>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@062590>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@062598>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@0625a0>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@0625a8>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@0625b0>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@0625b8>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@0625c0>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@0625c8>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@0625d0>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@0625d8>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@0625e0>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@0625e8>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@0625f0>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@0625f8>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@062600>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@062608>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@062610>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@062618>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@062620>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@062628>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@062630>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@062638>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@062640>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@062648>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@062650>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@062658>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@062660>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@03feb0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@03fff0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@062668>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@062670>, cast: static variable(val))
.field pi64: float64 (size: 8, offs: <@062678>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@062680>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@062688>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@062690>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@062698>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@0626a0>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@0626a8>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@0626b0>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@0626b8>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@0626c0>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@0626c8>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@0626d0>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@0626d8>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@0626e0>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@0626e8>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@0626f0>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@0626f8>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@062700>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@062708>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@062710>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@062718>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@062720>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@062728>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@062730>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@062738>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@062740>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@062748>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@062750>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@062758>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@062760>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@062768>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@062770>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@062778>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@062780>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@062788>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@062790>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@062798>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@0627a0>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@0627a8>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@0627b0>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@0627b8>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@0627c0>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@0627c8>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@0627d0>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@0627d8>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@0627e0>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@0627e8>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@0627f0>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@0627f8>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@062800>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@062808>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@062810>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@062818>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@062820>, cast: static function)
.field stackOverflow: function (size: 24, offs: <@062828>, cast: static function)
.field divisionByZero: function (size: 12, offs: <@062840>, cast: static function)
.field abortExecution: function (size: 68, offs: <@062850>, cast: static function)
.field invalidMemoryAccess: function (size: 13, offs: <@062898>, cast: static function)
.field invalidInstruction: function (size: 2, offs: <@0628a8>, cast: static function)
.field tryExecErr0: int32 (size: 4, offs: <@0628b0>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@0628b8>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@0628c0>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@0628c8>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@0628d0>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@0628d8>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@0628e0>, cast: static variable(i32))
.field value: int64 (size: 8, offs: <@0628e8>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@0628f0>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@0628f8>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@062900>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@062908>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@062910>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@062918>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@062920>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@062928>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@062930>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@062938>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@062940>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@062948>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@062950>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@062958>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@062960>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@062968>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@062970>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@062978>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@062980>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@062988>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@062990>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@062998>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@0629a0>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@0629a8>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@0629b0>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@0629b8>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@0629c0>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@0629c8>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@0629d0>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@0629d8>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@0629e0>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@0629e8>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@0629f0>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@0629f8>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@062a00>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@062a08>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@062a10>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@062a18>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@062a20>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@062a28>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@062a30>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@062a38>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@062a40>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@062a48>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@062a50>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@062a58>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@062a60>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@062a68>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@062a70>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@062a78>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@062a80>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@062a88>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@062a90>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@062a98>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@062aa0>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@062aa8>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@062ab0>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@062ab8>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@062ac0>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@062ac8>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@062ad0>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@062ad8>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@062ae0>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@062ae8>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@062af0>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@062af8>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@062b00>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@062b08>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@062b10>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@062b18>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@062b20>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@062b28>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@062b30>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@062b38>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@062b40>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@062b48>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@062b50>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@062b58>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@062b60>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@062b68>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@062b70>, cast: static variable(ref))
.field variable: int32 (size: 4, offs: <@062b78>, cast: static variable(i32))
.field constant: int32 (size: 4, offs: <@062b80>, cast: static const variable(i32))
.field ComplexVal: typename (size: 16, offs: <@048e00>, cast: static const typename(val))
.field ComplexObj: object (size: 20, offs: <@048fe0>, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, offs: <@062b88>, cast: static variable(val))
.field objInitImplicit: ComplexObj (size: 4, offs: <@062b98>, cast: static variable(ref))
.field objInitExplicit: object (size: 4, offs: <@062ba0>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@062ba8>, cast: static function)
.field funAdd: function (size: 8, offs: <@062bb0>, cast: static function)
.field funAddResult: int32 (size: 4, offs: <@062bb8>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@062bc0>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@062bc8>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@062bd0>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@062bd8>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@062be0>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@062be8>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@062bf0>, cast: static function)
.field fib: function (size: 54, offs: <@062bf8>, cast: static function)
.field fibonacci_13: uint32 (size: 4, offs: <@062c30>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@062c38>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@062c40>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@062c48>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@062c50>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@062c58>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@062c60>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@062c68>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@062c70>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@062c78>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@062c80>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@062c88>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@062c90>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@062c98>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@062ca0>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@062ca8>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@062cb0>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@062cb8>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@062cc0>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@04b5b0>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@04b6f0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@062cc8>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@062cd0>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@062cd8>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@062ce0>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@062ce8>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@062cf0>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@062cf8>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@062d00>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@062d08>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@062d10>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@062d18>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@062d20>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@062d28>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@062d30>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@062d38>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@062d40>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@062d48>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@062d50>, cast: static variable(i32))
.field RecordMemberTest: typename (size: 32, offs: <@04c6f0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@062d88>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@04d608>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@062e28>, cast: static function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@062e50>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@062e60>, cast: static function)
.field virtualMethod: function (size: 63, offs: <@062ea8>, cast: static function)
.field arrFixedInit: int64[7] (size: 56, offs: <@062ee8>, cast: static variable(val))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@062f20>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@062f28>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@062f30>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@062f38>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@062f40>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@062f48>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@062f50>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@062f58>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@062f60>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@062f68>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@062f70>, cast: static function)
.field nthFixed: function (size: 12, offs: <@062f78>, cast: static function)
.field nthArray: function (size: 12, offs: <@062f88>, cast: static function)
.field nthSlice: function (size: 12, offs: <@062f98>, cast: static function)
.field rgbF32: typename (size: 16, offs: <@050d30>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@050fb0>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@051230>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@051410>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@062fa8>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@062fb0>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@062fb8>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@062fc0>, cast: static variable(val))
.field blue: color (size: 4, offs: <@062fc8>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@0518f0>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@051d50>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0521b0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@052610>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@052a70>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@052ed0>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@062fd0>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@062fd8>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@062fe0>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@062fe8>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@062ff0>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@062ff8>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@063000>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@063008>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@063010>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@063018>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@063020>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@063028>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@063030>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@063038>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@063040>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@063048>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@063050>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@063058>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@063060>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@063068>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@063070>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@063078>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@063080>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@063088>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@063090>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@063098>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@0630a0>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@0630a8>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@0630b0>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@0630b8>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@0630c0>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@0630c8>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@0630d0>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@0630d8>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@0630e0>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@0630e8>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@0630f0>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@0630f8>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@063100>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@063108>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@063110>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@063118>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@063120>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@063128>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@063130>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@063138>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@063140>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@063148>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@063150>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@063158>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@063160>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@063168>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@063170>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@063178>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@063180>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@063188>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@063190>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@063198>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@0631a0>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@0631a8>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@0631b0>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@0631b8>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@0631c0>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@0631c8>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@0631d0>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@0631d8>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@0631e0>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@0631e8>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@0631f0>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@0631f8>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@063200>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@063208>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@063210>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@063218>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@063220>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@063228>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@063230>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@063238>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@063240>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@063248>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@063250>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@063258>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@063260>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@063268>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@063270>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@063278>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@063280>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@063288>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@063290>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@063298>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@0632a0>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@0632a8>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@0632b0>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@0632b8>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@0632c0>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@0632c8>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@0632d0>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@0632d8>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@0632e0>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@0632e8>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@0632f0>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@0632f8>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@063300>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@063308>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@063310>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@063318>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@063320>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@063328>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@063330>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@063338>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@063340>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@063348>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@063350>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@063358>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@063360>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@063368>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@063370>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@063378>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@063380>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@063388>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@063390>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@063398>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@0633a0>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@0633a8>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@0633b0>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@0633b8>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@0633c0>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@0633c8>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@0633d0>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@0633d8>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@0633e0>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@0633e8>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@0633f0>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@0633f8>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@063400>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@063408>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@063410>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@063418>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@063420>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@063428>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@063430>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@063438>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@063440>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@063448>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@063450>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@063458>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@063460>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@063468>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@063470>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@063478>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@063480>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@063488>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@063490>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@063498>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@0634a0>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@0634a8>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@0634b0>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@0634b8>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@0634c0>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@0634c8>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@0634d0>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@0634d8>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@0634e0>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@0634e8>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@0634f0>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@0634f8>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@063500>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@063508>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@063510>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@063518>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@063520>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@063528>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@063530>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@063538>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@063540>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@063548>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@063550>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@063558>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@063560>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@063568>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@063570>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@063578>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@063580>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@063588>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@063590>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@063598>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@0635a0>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@0635a8>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@0635b0>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@0635b8>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@0635c0>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@0635c8>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@0635d0>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@0635d8>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@0635e0>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@0635e8>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@0635f0>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@0635f8>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@063600>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@063608>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@063610>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@063618>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@063620>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@063628>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@063630>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@063638>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@063640>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@063648>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@063650>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@063658>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@063660>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@063668>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@063670>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@063678>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@063680>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@063688>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@063690>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@063698>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@0636a0>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@0636a8>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@0636b0>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@0636b8>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@0636c0>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@0636c8>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@0636d0>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@0636d8>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@0636e0>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@0636e8>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@0636f0>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@0636f8>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@063700>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@063708>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@063710>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@063718>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@063720>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@063728>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@063730>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@063738>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@063740>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@063748>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@063750>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@063758>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@063760>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@063768>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@063770>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@063778>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@063780>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@063788>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@063790>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@063798>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@0637a0>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@0637a8>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@0637b0>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@0637b8>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@0637c0>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@0637c8>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@0637d0>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@0637d8>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@0637e0>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@0637e8>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@0637f0>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@0637f8>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@063800>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@063808>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@063810>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@063818>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@063820>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@063828>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@063830>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@063838>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@063840>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@063848>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@063850>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@063858>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@063860>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@063868>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@063870>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@063878>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@063880>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@063888>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@063890>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@063898>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@0638a0>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@0638a8>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@0638b0>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@0638b8>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@0638c0>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@0638c8>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@0638d0>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@0638d8>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@0638e0>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@0638e8>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@0638f0>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@0638f8>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@063900>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@063908>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@063910>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@063918>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@063920>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@063928>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@063930>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@063938>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@063940>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@063948>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@063950>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@063958>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@063960>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@063968>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@063970>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@063978>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@063980>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@063988>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@063990>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@063998>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@0639a0>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@0639a8>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@0639b0>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@0639b8>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@0639c0>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@0639c8>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@0639d0>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@0639d8>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@0639e0>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@0639e8>, cast: static variable(f32))
.field .main: function (size: 14826, offs: <@0639ec>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static signed(value: uint8): int8 := int8(value);
		static signed(value: uint16): int16 := int16(value);
		static signed(value: uint32): int32 := int32(value);
		static signed(value: uint64): int64 := int64(value);
		static unsigned(value: int8): uint8 := uint8(value);
		static unsigned(value: int16): uint16 := uint16(value);
		static unsigned(value: int32): uint32 := uint32(value);
		static unsigned(value: int64): uint64 := uint64(value);
		static sizeof(type: typename): int32 := int32(type.size);
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[] := null;
			};
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				extras: variant[1] := {
					void(extras[0] := (message));
				};
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.extras := (extras));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: int32): int32 := bool(x != 0) ? bool(x < 0) ? int32(-1) : 1 : 0;
			static sign(x: int64): int32 := bool(x != (0)) ? bool(x < (0)) ? int32(-1) : 1 : 0;
			static sign(x: uint32): int32 := bool(x > (0)) ? 1 : 0;
			static sign(x: uint64): int32 := bool(x > (0)) ? 1 : 0;
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static abs(x: int32): int32 := bool(x < 0) ? int32(-x) : x;
			static abs(x: int64): int64 := bool(x < (0)) ? int64(-x) : x;
			static abs(x: uint32): uint32 := x;
			static abs(x: uint64): uint64 := x;
			static abs(x: float32): float32 := bool(x < (0)) ? float32(-x) : x;
			static abs(x: float64): float64 := bool(x < (0)) ? float64(-x) : x;
			static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
			static min(a: int64, b: int64): int64 := bool(a < b) ? a : b;
			static min(a: uint32, b: uint32): uint32 := bool(a < b) ? a : b;
			static min(a: uint64, b: uint64): uint64 := bool(a < b) ? a : b;
			static min(a: float32, b: float32): float32 := bool(a < b) ? a : b;
			static min(a: float64, b: float64): float64 := bool(a < b) ? a : b;
			static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
			static max(a: int64, b: int64): int64 := bool(a > b) ? a : b;
			static max(a: uint32, b: uint32): uint32 := bool(a > b) ? a : b;
			static max(a: uint64, b: uint64): uint64 := bool(a > b) ? a : b;
			static max(a: float32, b: float32): float32 := bool(a > b) ? a : b;
			static max(a: float64, b: float64): float64 := bool(a > b) ? a : b;
			static clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static mean(data: float64[]): float64 := {
				return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float32(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float64(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else if (bool(i == 1)) {
					float64(x := float64((1) - x));
					bool(complement := true);
				}
				else if (bool(i == 2)) {
					bool(negate := bool(!negate));
					bool(complement := true);
				}
				else if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(emit(void(struct(a), neg.p2d)));
		static add(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), add.p2d)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static inv(a: Complex): Complex := {
			d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		static vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))));
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static add(a: float32, b: vec4f): vec4f := add(void(vec4f(a), b));
		static add(a: vec4f, b: float32): vec4f := add(void(a, vec4f(b)));
		static sub(a: float32, b: vec4f): vec4f := sub(void(vec4f(a), b));
		static sub(a: vec4f, b: float32): vec4f := sub(void(a, vec4f(b)));
		static mul(a: float32, b: vec4f): vec4f := mul(void(vec4f(a), b));
		static mul(a: vec4f, b: float32): vec4f := mul(void(a, vec4f(b)));
		static div(a: float32, b: vec4f): vec4f := div(void(vec4f(a), b));
		static div(a: vec4f, b: float32): vec4f := div(void(a, vec4f(b)));
		static min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(void(max(void(vec, min)), max));
		static clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(void(void(vec, vec4f(min)), vec4f(max)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static transpose(const mat: mat4f): mat4f := {
			return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static add(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), add.p2d)));
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)));
		static div(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), div.p2d)));
		static min(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), min.p2d)));
		static max(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), max.p2d)));
		static ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static equals(const str: char[*], const with: char[*]): bool := bool(compare(void(void(str, with), caseCmp)) == 0);
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			if (format.showSign) {
				if (bool((sign) == 0)) {
					char(sign := '+');
				}
			}
			radix: int32 := format.precision;
			if (bool(radix == 0)) {
				int32(radix := 10);
			}
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format));
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				void(formatInt.showSign := format.showSign);
				void(formatInt.precision := 0);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(format.padLen - format.precision));
			};
			formatDec: FormatFlags := {
				void(formatDec.showSign := false);
				void(formatDec.precision := 0);
				void(formatDec.padChr := '0');
				void(formatDec.padLen := format.precision);
			};
			sign: char := bool(value < (0)) ? ('-') : 0;
			fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
			int32(pos := append(void(output, void(pos, "."))));
			float64(fract := float64(fract * float64.pow(void(10, format.precision))));
			int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.showSign := false);
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static emitNfcF32: float32 := emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static noError(ptr: pointer): void := {
		};
		static stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static variable: int32;
		static const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static valInitImplicit: ComplexVal := {
			void(valInitImplicit.re := (8));
			void(valInitImplicit.im := (0));
		};
		static objInitImplicit: ComplexObj := {
			void(objInitImplicit := create(ComplexObj));
			void(objInitImplicit.re := (8));
			void(objInitImplicit.im := (0));
		};
		static objInitExplicit: object := {
			void(objInitExplicit := create(ComplexObj));
			void(objInitExplicit.re := (8));
			void(objInitExplicit.im := (0));
		};
		static empty(): void := {
		};
		static funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				void(globalRec.constant := 4);
				void(globalRec.member := (0));
			};
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			static virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedInit: int64[7] := {
			void(arrFixedInit[0] := (42));
			void(arrFixedInit[1] := (43));
			void(arrFixedInit[2] := (44));
			void(arrFixedInit[3] := (45));
			void(arrFixedInit[4] := (46));
			void(arrFixedInit[5] := (47));
			void(arrFixedInit[6] := (48));
		};
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedInit;
		static arrSliceInitFixed: int64[] := arrFixedInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7] := {
			void(strFixed[0] := 's');
			void(strFixed[1] := 't');
			void(strFixed[2] := 'r');
			void(strFixed[3] := 'i');
			void(strFixed[4] := 'n');
			void(strFixed[5] := 'g');
			void(strFixed[6] := (0));
		};
		debug(void("string as variant", strFixed));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedInit[0] == (42)));
		static lenSlice(const values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static nthFixed(idx: int32, const values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static nthArray(idx: int32, const values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static nthSlice(idx: int32, const values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedInit.(length)));
		assertEq(void(arrFixedInit.(length), arrSliceInitFixed.length));
		assertEq(void(arrFixedInit.(length), arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedInit.(length), lenSlice(arrFixedInit)));
		assertEq(void(arrFixedInit.(length), lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedInit.(length), lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedInit.(length)); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else if (bool(t == 1)) {
				raise(void(void(void(raise.debug, 10), "t == 1"), t));
			}
			else if (bool(t == 2)) {
				raise(void(void(void(raise.debug, 10), "t == 2"), t));
			}
			else if (bool(t == 3)) {
				raise(void(void(void(raise.debug, 10), "t == 3"), t));
			}
			else if (bool(t == 4)) {
				raise(void(void(void(raise.debug, 10), "t == 4"), t));
			}
			else if (bool(t == 5)) {
				raise(void(void(void(raise.debug, 10), "t == 5"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14826 bytes: <.main @0639ec> - <.main+14826 @0673d6>)
	cmplStd/lib/string.ci:145: (14 bytes: <.main @0639ec> - <.main+14 @0639fa>): static const whiteSpace: char[] := " \t\n\r"
	<.main @0639ec>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @0639f1>    : 1f e0 14 03 00             load.ref <@0314e0> ;" \t\n\r"
	<.main+10 @0639f6>   : 23 58 20 06                store.m64 <@062058> ;append.whiteSpace
	cmplStd/lib/string.ci:146: (14 bytes: <.main+14 @0639fa> - <.main+28 @063a08>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @0639fa>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @0639ff>   : 1f f1 14 03 00             load.ref <@0314f1> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @063a04>   : 23 60 20 06                store.m64 <@062060> ;append.radixDigits
	cmplStd/lib/string.ci:263: (24 bytes: <.main+28 @063a08> - <.main+52 @063a20>): static const format: FormatFlags := {...}
	:: (7 bytes: <.main+28 @063a08> - <.main+35 @063a0f>): format.showSign := false;
	<.main+28 @063a08>   : 19                         load.z32
	<.main+29 @063a09>   : 1f 20 24 06 00             load.ref <@062420> ;append.format
	<.main+34 @063a0e>   : 2b                         store.i8
	:: (5 bytes: <.main+35 @063a0f> - <.main+40 @063a14>): format.precision := 0;
	<.main+35 @063a0f>   : 19                         load.z32
	<.main+36 @063a10>   : 24 24 24 06                store.m32 <@062424> ;append.format+4
	:: (7 bytes: <.main+40 @063a14> - <.main+47 @063a1b>): format.padChr := (0);
	<.main+40 @063a14>   : 19                         load.z32
	<.main+41 @063a15>   : 1f 28 24 06 00             load.ref <@062428> ;append.format+8
	<.main+46 @063a1a>   : 2b                         store.i8
	:: (5 bytes: <.main+47 @063a1b> - <.main+52 @063a20>): format.padLen := 0;
	<.main+47 @063a1b>   : 19                         load.z32
	<.main+48 @063a1c>   : 24 2c 24 06                store.m32 <@06242c> ;append.format+12
	cmplStd/test/lang/emit.ci:3: (5 bytes: <.main+52 @063a20> - <.main+57 @063a25>): static emitldz32: int32 := emit(load.z32)
	<.main+52 @063a20>   : 19                         load.z32
	<.main+53 @063a21>   : 24 70 24 06                store.m32 <@062470> ;emitldz32
	cmplStd/test/lang/emit.ci:4: (5 bytes: <.main+57 @063a25> - <.main+62 @063a2a>): static emitldz64: int64 := emit(load.z64)
	<.main+57 @063a25>   : 1a                         load.z64
	<.main+58 @063a26>   : 23 78 24 06                store.m64 <@062478> ;emitldz64
	cmplStd/test/lang/emit.ci:6: (9 bytes: <.main+62 @063a2a> - <.main+71 @063a33>): static emitA: int32 := 42
	<.main+62 @063a2a>   : 1c 2a 00 00 00             load.c32 42
	<.main+67 @063a2f>   : 24 80 24 06                store.m32 <@062480> ;emitA
	cmplStd/test/lang/emit.ci:7: (9 bytes: <.main+71 @063a33> - <.main+80 @063a3c>): static emitB: int32 := 96
	<.main+71 @063a33>   : 1c 60 00 00 00             load.c32 96
	<.main+76 @063a38>   : 24 88 24 06                store.m32 <@062488> ;emitB
	cmplStd/test/lang/emit.ci:10: (13 bytes: <.main+80 @063a3c> - <.main+93 @063a49>): static emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+80 @063a3c>   : 20 80 24 06                load.m32 <@062480> ;emitA
	<.main+84 @063a40>   : 20 88 24 06                load.m32 <@062488> ;emitB
	<.main+88 @063a44>   : 51                         add.i32
	<.main+89 @063a45>   : 24 90 24 06                store.m32 <@062490> ;emitAddI32
	cmplStd/test/lang/emit.ci:13: (15 bytes: <.main+93 @063a49> - <.main+108 @063a58>): static emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+93 @063a49>   : 1c 0a 00 00 00             load.c32 10
	<.main+98 @063a4e>   : 1c 05 00 00 00             load.c32 5
	<.main+103 @063a53>  : 54                         div.i32
	<.main+104 @063a54>  : 24 98 24 06                store.m32 <@062498> ;emitDivI32
	cmplStd/test/lang/emit.ci:16: (19 bytes: <.main+108 @063a58> - <.main+127 @063a6b>): static emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+108 @063a58>  : 7f c3 f5 48 40             load.f32 3.140000
	<.main+113 @063a5d>  : 7f 00 00 00 40             load.f32 2.000000
	<.main+118 @063a62>  : 74                         div.f32
	<.main+119 @063a63>  : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	<.main+123 @063a67>  : 24 a0 24 06                store.m32 <@0624a0> ;emitNfcF32
	cmplStd/test/lang/emit.ci:23: (9 bytes: <.main+127 @063a6b> - <.main+136 @063a74>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+127 @063a6b>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+132 @063a70>  : 24 a8 24 06                store.m32 <@0624a8> ;emitFloatAsInt1
	cmplStd/test/lang/emit.ci:24: (10 bytes: <.main+136 @063a74> - <.main+146 @063a7e>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+136 @063a74>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+141 @063a79>  : 5b                         i32.2i64
	<.main+142 @063a7a>  : 23 b0 24 06                store.m64 <@0624b0> ;emitFloatAsInt2
	cmplStd/test/lang/emit.ci:25: (14 bytes: <.main+146 @063a7e> - <.main+160 @063a8c>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+146 @063a7e>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+155 @063a87>  : 6a                         i64.2i32
	<.main+156 @063a88>  : 24 b8 24 06                store.m32 <@0624b8> ;emitFloatAsInt3
	cmplStd/test/lang/emit.ci:26: (13 bytes: <.main+160 @063a8c> - <.main+173 @063a99>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+160 @063a8c>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+169 @063a95>  : 23 c0 24 06                store.m64 <@0624c0> ;emitFloatAsInt4
	cmplStd/test/lang/emit.ci:29: (14 bytes: <.main+173 @063a99> - <.main+187 @063aa7>): static emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+173 @063a99>  : 1c 03 00 00 00             load.c32 3
	<.main+178 @063a9e>  : 1f 6d 9b 03 00             load.ref <@039b6d> ;"string"
	<.main+183 @063aa3>  : 23 c8 24 06                store.m64 <@0624c8> ;emitSlice
	cmplStd/test/lang/inlineMacros.ci:10: (9 bytes: <.main+187 @063aa7> - <.main+196 @063ab0>): static i3: int32 := 3
	<.main+187 @063aa7>  : 1c 03 00 00 00             load.c32 3
	<.main+192 @063aac>  : 24 d0 24 06                store.m32 <@0624d0> ;i3
	cmplStd/test/lang/inlineMacros.ci:11: (9 bytes: <.main+196 @063ab0> - <.main+205 @063ab9>): static i6: int32 := 6
	<.main+196 @063ab0>  : 1c 06 00 00 00             load.c32 6
	<.main+201 @063ab5>  : 24 d8 24 06                store.m32 <@0624d8> ;i6
	cmplStd/test/lang/inlineMacros.ci:12: (9 bytes: <.main+205 @063ab9> - <.main+214 @063ac2>): static i2: int32 := 2
	<.main+205 @063ab9>  : 1c 02 00 00 00             load.c32 2
	<.main+210 @063abe>  : 24 e0 24 06                store.m32 <@0624e0> ;i2
	cmplStd/test/lang/inlineMacros.ci:13: (9 bytes: <.main+214 @063ac2> - <.main+223 @063acb>): static i8: int32 := 8
	<.main+214 @063ac2>  : 1c 08 00 00 00             load.c32 8
	<.main+219 @063ac7>  : 24 e8 24 06                store.m32 <@0624e8> ;i8
	cmplStd/test/lang/inlineMacros.ci:15: (5 bytes: <.main+223 @063acb> - <.main+228 @063ad0>): static zeroVal: int32 := zero(3, 6)
	<.main+223 @063acb>  : 19                         load.z32
	<.main+224 @063acc>  : 24 f0 24 06                store.m32 <@0624f0> ;zeroVal
	cmplStd/test/lang/inlineMacros.ci:16: (5 bytes: <.main+228 @063ad0> - <.main+233 @063ad5>): static zeroVar: int32 := zero(i3, i6)
	<.main+228 @063ad0>  : 19                         load.z32
	<.main+229 @063ad1>  : 24 f8 24 06                store.m32 <@0624f8> ;zeroVar
	cmplStd/test/lang/inlineMacros.ci:17: (5 bytes: <.main+233 @063ad5> - <.main+238 @063ada>): static zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+233 @063ad5>  : 19                         load.z32
	<.main+234 @063ad6>  : 24 00 25 06                store.m32 <@062500> ;zeroXpr
	cmplStd/test/lang/inlineMacros.ci:19: (9 bytes: <.main+238 @063ada> - <.main+247 @063ae3>): static lastVal: int32 := last(3, 6)
	<.main+238 @063ada>  : 1c 06 00 00 00             load.c32 6
	<.main+243 @063adf>  : 24 08 25 06                store.m32 <@062508> ;lastVal
	cmplStd/test/lang/inlineMacros.ci:20: (8 bytes: <.main+247 @063ae3> - <.main+255 @063aeb>): static lastVar: int32 := last(i3, i6)
	<.main+247 @063ae3>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+251 @063ae7>  : 24 10 25 06                store.m32 <@062510> ;lastVar
	cmplStd/test/lang/inlineMacros.ci:21: (16 bytes: <.main+255 @063aeb> - <.main+271 @063afb>): static lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+255 @063aeb>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+259 @063aef>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @063af3>  : 0c ff ff ff                inc.i32(-1)
	<.main+267 @063af7>  : 24 18 25 06                store.m32 <@062518> ;lastXpr
	cmplStd/test/lang/inlineMacros.ci:23: (13 bytes: <.main+271 @063afb> - <.main+284 @063b08>): static sum2Val: int32 := sum(3, 6)
	<.main+271 @063afb>  : 1c 03 00 00 00             load.c32 3
	<.main+276 @063b00>  : 0c 06 00 00                inc.i32(+6)
	<.main+280 @063b04>  : 24 20 25 06                store.m32 <@062520> ;sum2Val
	cmplStd/test/lang/inlineMacros.ci:24: (13 bytes: <.main+284 @063b08> - <.main+297 @063b15>): static sum2Var: int32 := sum(i3, i6)
	<.main+284 @063b08>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+288 @063b0c>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+292 @063b10>  : 51                         add.i32
	<.main+293 @063b11>  : 24 28 25 06                store.m32 <@062528> ;sum2Var
	cmplStd/test/lang/inlineMacros.ci:25: (25 bytes: <.main+297 @063b15> - <.main+322 @063b2e>): static sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+297 @063b15>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+301 @063b19>  : 0c 01 00 00                inc.i32(+1)
	<.main+305 @063b1d>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+309 @063b21>  : 0c 01 00 00                inc.i32(+1)
	<.main+313 @063b25>  : 51                         add.i32
	<.main+314 @063b26>  : 0c fe ff ff                inc.i32(-2)
	<.main+318 @063b2a>  : 24 30 25 06                store.m32 <@062530> ;sum2Xpr
	cmplStd/test/lang/inlineMacros.ci:27: (28 bytes: <.main+322 @063b2e> - <.main+350 @063b4a>): static any2Val: int32 := any(3, 6)
	<.main+322 @063b2e>  : 1c 03 00 00 00             load.c32 3
	<.main+327 @063b33>  : 10 00                      dup.x32 sp(0)
	<.main+329 @063b35>  : 06 0a 00 00                jz <.main+339 @063b3f>
	<.main+333 @063b39>  : 10 00                      dup.x32 sp(0)
	<.main+335 @063b3b>  : 04 09 00 00                jmp <.main+344 @063b44>
	<.main+339 @063b3f>  : 1c 06 00 00 00             load.c32 6
	<.main+344 @063b44>  : 13 01                      set.x32 sp(1)
	<.main+346 @063b46>  : 24 38 25 06                store.m32 <@062538> ;any2Val
	cmplStd/test/lang/inlineMacros.ci:28: (26 bytes: <.main+350 @063b4a> - <.main+376 @063b64>): static any2Var: int32 := any(i3, i6)
	<.main+350 @063b4a>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+354 @063b4e>  : 10 00                      dup.x32 sp(0)
	<.main+356 @063b50>  : 06 0a 00 00                jz <.main+366 @063b5a>
	<.main+360 @063b54>  : 10 00                      dup.x32 sp(0)
	<.main+362 @063b56>  : 04 08 00 00                jmp <.main+370 @063b5e>
	<.main+366 @063b5a>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+370 @063b5e>  : 13 01                      set.x32 sp(1)
	<.main+372 @063b60>  : 24 40 25 06                store.m32 <@062540> ;any2Var
	cmplStd/test/lang/inlineMacros.ci:29: (38 bytes: <.main+376 @063b64> - <.main+414 @063b8a>): static any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+376 @063b64>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+380 @063b68>  : 0c 01 00 00                inc.i32(+1)
	<.main+384 @063b6c>  : 10 00                      dup.x32 sp(0)
	<.main+386 @063b6e>  : 06 0a 00 00                jz <.main+396 @063b78>
	<.main+390 @063b72>  : 10 00                      dup.x32 sp(0)
	<.main+392 @063b74>  : 04 0c 00 00                jmp <.main+404 @063b80>
	<.main+396 @063b78>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+400 @063b7c>  : 0c 01 00 00                inc.i32(+1)
	<.main+404 @063b80>  : 13 01                      set.x32 sp(1)
	<.main+406 @063b82>  : 0c ff ff ff                inc.i32(-1)
	<.main+410 @063b86>  : 24 48 25 06                store.m32 <@062548> ;any2Xpr
	cmplStd/test/lang/inlineMacros.ci:31: (37 bytes: <.main+414 @063b8a> - <.main+451 @063baf>): static min2Val: int32 := min(3, 6)
	<.main+414 @063b8a>  : 1c 03 00 00 00             load.c32 3
	<.main+419 @063b8f>  : 1c 06 00 00 00             load.c32 6
	<.main+424 @063b94>  : 10 01                      dup.x32 sp(1)
	<.main+426 @063b96>  : 10 01                      dup.x32 sp(1)
	<.main+428 @063b98>  : 58                         clt.i32
	<.main+429 @063b99>  : 06 0a 00 00                jz <.main+439 @063ba3>
	<.main+433 @063b9d>  : 10 01                      dup.x32 sp(1)
	<.main+435 @063b9f>  : 04 06 00 00                jmp <.main+441 @063ba5>
	<.main+439 @063ba3>  : 10 00                      dup.x32 sp(0)
	<.main+441 @063ba5>  : 13 02                      set.x32 sp(2)
	<.main+443 @063ba7>  : 09 fc ff ff                inc.sp(-4)
	<.main+447 @063bab>  : 24 50 25 06                store.m32 <@062550> ;min2Val
	cmplStd/test/lang/inlineMacros.ci:32: (35 bytes: <.main+451 @063baf> - <.main+486 @063bd2>): static min2Var: int32 := min(i3, i6)
	<.main+451 @063baf>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+455 @063bb3>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+459 @063bb7>  : 10 01                      dup.x32 sp(1)
	<.main+461 @063bb9>  : 10 01                      dup.x32 sp(1)
	<.main+463 @063bbb>  : 58                         clt.i32
	<.main+464 @063bbc>  : 06 0a 00 00                jz <.main+474 @063bc6>
	<.main+468 @063bc0>  : 10 01                      dup.x32 sp(1)
	<.main+470 @063bc2>  : 04 06 00 00                jmp <.main+476 @063bc8>
	<.main+474 @063bc6>  : 10 00                      dup.x32 sp(0)
	<.main+476 @063bc8>  : 13 02                      set.x32 sp(2)
	<.main+478 @063bca>  : 09 fc ff ff                inc.sp(-4)
	<.main+482 @063bce>  : 24 58 25 06                store.m32 <@062558> ;min2Var
	cmplStd/test/lang/inlineMacros.ci:33: (47 bytes: <.main+486 @063bd2> - <.main+533 @063c01>): static min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+486 @063bd2>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+490 @063bd6>  : 0c 01 00 00                inc.i32(+1)
	<.main+494 @063bda>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+498 @063bde>  : 0c 01 00 00                inc.i32(+1)
	<.main+502 @063be2>  : 10 01                      dup.x32 sp(1)
	<.main+504 @063be4>  : 10 01                      dup.x32 sp(1)
	<.main+506 @063be6>  : 58                         clt.i32
	<.main+507 @063be7>  : 06 0a 00 00                jz <.main+517 @063bf1>
	<.main+511 @063beb>  : 10 01                      dup.x32 sp(1)
	<.main+513 @063bed>  : 04 06 00 00                jmp <.main+519 @063bf3>
	<.main+517 @063bf1>  : 10 00                      dup.x32 sp(0)
	<.main+519 @063bf3>  : 13 02                      set.x32 sp(2)
	<.main+521 @063bf5>  : 09 fc ff ff                inc.sp(-4)
	<.main+525 @063bf9>  : 0c ff ff ff                inc.i32(-1)
	<.main+529 @063bfd>  : 24 60 25 06                store.m32 <@062560> ;min2Xpr
	cmplStd/test/lang/inlineMacros.ci:35: (37 bytes: <.main+533 @063c01> - <.main+570 @063c26>): static max2Val: int32 := max(3, 6)
	<.main+533 @063c01>  : 1c 03 00 00 00             load.c32 3
	<.main+538 @063c06>  : 1c 06 00 00 00             load.c32 6
	<.main+543 @063c0b>  : 10 01                      dup.x32 sp(1)
	<.main+545 @063c0d>  : 10 01                      dup.x32 sp(1)
	<.main+547 @063c0f>  : 59                         cgt.i32
	<.main+548 @063c10>  : 06 0a 00 00                jz <.main+558 @063c1a>
	<.main+552 @063c14>  : 10 01                      dup.x32 sp(1)
	<.main+554 @063c16>  : 04 06 00 00                jmp <.main+560 @063c1c>
	<.main+558 @063c1a>  : 10 00                      dup.x32 sp(0)
	<.main+560 @063c1c>  : 13 02                      set.x32 sp(2)
	<.main+562 @063c1e>  : 09 fc ff ff                inc.sp(-4)
	<.main+566 @063c22>  : 24 68 25 06                store.m32 <@062568> ;max2Val
	cmplStd/test/lang/inlineMacros.ci:36: (35 bytes: <.main+570 @063c26> - <.main+605 @063c49>): static max2Var: int32 := max(i3, i6)
	<.main+570 @063c26>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+574 @063c2a>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+578 @063c2e>  : 10 01                      dup.x32 sp(1)
	<.main+580 @063c30>  : 10 01                      dup.x32 sp(1)
	<.main+582 @063c32>  : 59                         cgt.i32
	<.main+583 @063c33>  : 06 0a 00 00                jz <.main+593 @063c3d>
	<.main+587 @063c37>  : 10 01                      dup.x32 sp(1)
	<.main+589 @063c39>  : 04 06 00 00                jmp <.main+595 @063c3f>
	<.main+593 @063c3d>  : 10 00                      dup.x32 sp(0)
	<.main+595 @063c3f>  : 13 02                      set.x32 sp(2)
	<.main+597 @063c41>  : 09 fc ff ff                inc.sp(-4)
	<.main+601 @063c45>  : 24 70 25 06                store.m32 <@062570> ;max2Var
	cmplStd/test/lang/inlineMacros.ci:37: (47 bytes: <.main+605 @063c49> - <.main+652 @063c78>): static max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+605 @063c49>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+609 @063c4d>  : 0c 01 00 00                inc.i32(+1)
	<.main+613 @063c51>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+617 @063c55>  : 0c 01 00 00                inc.i32(+1)
	<.main+621 @063c59>  : 10 01                      dup.x32 sp(1)
	<.main+623 @063c5b>  : 10 01                      dup.x32 sp(1)
	<.main+625 @063c5d>  : 59                         cgt.i32
	<.main+626 @063c5e>  : 06 0a 00 00                jz <.main+636 @063c68>
	<.main+630 @063c62>  : 10 01                      dup.x32 sp(1)
	<.main+632 @063c64>  : 04 06 00 00                jmp <.main+638 @063c6a>
	<.main+636 @063c68>  : 10 00                      dup.x32 sp(0)
	<.main+638 @063c6a>  : 13 02                      set.x32 sp(2)
	<.main+640 @063c6c>  : 09 fc ff ff                inc.sp(-4)
	<.main+644 @063c70>  : 0c ff ff ff                inc.i32(-1)
	<.main+648 @063c74>  : 24 78 25 06                store.m32 <@062578> ;max2Xpr
	cmplStd/test/lang/inlineMacros.ci:41: (25 bytes: <.main+652 @063c78> - <.main+677 @063c91>): static sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+652 @063c78>  : 1c 03 00 00 00             load.c32 3
	<.main+657 @063c7d>  : 1c 06 00 00 00             load.c32 6
	<.main+662 @063c82>  : 1c 02 00 00 00             load.c32 2
	<.main+667 @063c87>  : 0c 08 00 00                inc.i32(+8)
	<.main+671 @063c8b>  : 51                         add.i32
	<.main+672 @063c8c>  : 51                         add.i32
	<.main+673 @063c8d>  : 24 80 25 06                store.m32 <@062580> ;sumRlVal
	cmplStd/test/lang/inlineMacros.ci:42: (21 bytes: <.main+677 @063c91> - <.main+698 @063ca6>): static sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+677 @063c91>  : 1c 03 00 00 00             load.c32 3
	<.main+682 @063c96>  : 0c 06 00 00                inc.i32(+6)
	<.main+686 @063c9a>  : 0c 02 00 00                inc.i32(+2)
	<.main+690 @063c9e>  : 0c 08 00 00                inc.i32(+8)
	<.main+694 @063ca2>  : 24 88 25 06                store.m32 <@062588> ;sumLrVal
	cmplStd/test/lang/inlineMacros.ci:43: (23 bytes: <.main+698 @063ca6> - <.main+721 @063cbd>): static sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+698 @063ca6>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+702 @063caa>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+706 @063cae>  : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+710 @063cb2>  : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+714 @063cb6>  : 51                         add.i32
	<.main+715 @063cb7>  : 51                         add.i32
	<.main+716 @063cb8>  : 51                         add.i32
	<.main+717 @063cb9>  : 24 90 25 06                store.m32 <@062590> ;sumRlVar
	cmplStd/test/lang/inlineMacros.ci:44: (23 bytes: <.main+721 @063cbd> - <.main+744 @063cd4>): static sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+721 @063cbd>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+725 @063cc1>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+729 @063cc5>  : 51                         add.i32
	<.main+730 @063cc6>  : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+734 @063cca>  : 51                         add.i32
	<.main+735 @063ccb>  : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+739 @063ccf>  : 51                         add.i32
	<.main+740 @063cd0>  : 24 98 25 06                store.m32 <@062598> ;sumLrVar
	cmplStd/test/lang/inlineMacros.ci:45: (43 bytes: <.main+744 @063cd4> - <.main+787 @063cff>): static sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+744 @063cd4>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+748 @063cd8>  : 0c 01 00 00                inc.i32(+1)
	<.main+752 @063cdc>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+756 @063ce0>  : 0c 01 00 00                inc.i32(+1)
	<.main+760 @063ce4>  : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+764 @063ce8>  : 0c 01 00 00                inc.i32(+1)
	<.main+768 @063cec>  : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+772 @063cf0>  : 0c 01 00 00                inc.i32(+1)
	<.main+776 @063cf4>  : 51                         add.i32
	<.main+777 @063cf5>  : 51                         add.i32
	<.main+778 @063cf6>  : 51                         add.i32
	<.main+779 @063cf7>  : 0c fc ff ff                inc.i32(-4)
	<.main+783 @063cfb>  : 24 a0 25 06                store.m32 <@0625a0> ;sumRlXpr
	cmplStd/test/lang/inlineMacros.ci:46: (43 bytes: <.main+787 @063cff> - <.main+830 @063d2a>): static sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+787 @063cff>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+791 @063d03>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @063d07>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+799 @063d0b>  : 0c 01 00 00                inc.i32(+1)
	<.main+803 @063d0f>  : 51                         add.i32
	<.main+804 @063d10>  : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+808 @063d14>  : 0c 01 00 00                inc.i32(+1)
	<.main+812 @063d18>  : 51                         add.i32
	<.main+813 @063d19>  : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+817 @063d1d>  : 0c 01 00 00                inc.i32(+1)
	<.main+821 @063d21>  : 51                         add.i32
	<.main+822 @063d22>  : 0c fc ff ff                inc.i32(-4)
	<.main+826 @063d26>  : 24 a8 25 06                store.m32 <@0625a8> ;sumLrXpr
	cmplStd/test/lang/inlineMacros.ci:50: (66 bytes: <.main+830 @063d2a> - <.main+896 @063d6c>): static anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+830 @063d2a>  : 1c 03 00 00 00             load.c32 3
	<.main+835 @063d2f>  : 10 00                      dup.x32 sp(0)
	<.main+837 @063d31>  : 06 0a 00 00                jz <.main+847 @063d3b>
	<.main+841 @063d35>  : 10 00                      dup.x32 sp(0)
	<.main+843 @063d37>  : 04 2f 00 00                jmp <.main+890 @063d66>
	<.main+847 @063d3b>  : 1c 06 00 00 00             load.c32 6
	<.main+852 @063d40>  : 10 00                      dup.x32 sp(0)
	<.main+854 @063d42>  : 06 0a 00 00                jz <.main+864 @063d4c>
	<.main+858 @063d46>  : 10 00                      dup.x32 sp(0)
	<.main+860 @063d48>  : 04 1c 00 00                jmp <.main+888 @063d64>
	<.main+864 @063d4c>  : 1c 02 00 00 00             load.c32 2
	<.main+869 @063d51>  : 10 00                      dup.x32 sp(0)
	<.main+871 @063d53>  : 06 0a 00 00                jz <.main+881 @063d5d>
	<.main+875 @063d57>  : 10 00                      dup.x32 sp(0)
	<.main+877 @063d59>  : 04 09 00 00                jmp <.main+886 @063d62>
	<.main+881 @063d5d>  : 1c 08 00 00 00             load.c32 8
	<.main+886 @063d62>  : 13 01                      set.x32 sp(1)
	<.main+888 @063d64>  : 13 01                      set.x32 sp(1)
	<.main+890 @063d66>  : 13 01                      set.x32 sp(1)
	<.main+892 @063d68>  : 24 b0 25 06                store.m32 <@0625b0> ;anyRlVal
	cmplStd/test/lang/inlineMacros.ci:51: (66 bytes: <.main+896 @063d6c> - <.main+962 @063dae>): static anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+896 @063d6c>  : 1c 03 00 00 00             load.c32 3
	<.main+901 @063d71>  : 10 00                      dup.x32 sp(0)
	<.main+903 @063d73>  : 06 0a 00 00                jz <.main+913 @063d7d>
	<.main+907 @063d77>  : 10 00                      dup.x32 sp(0)
	<.main+909 @063d79>  : 04 09 00 00                jmp <.main+918 @063d82>
	<.main+913 @063d7d>  : 1c 06 00 00 00             load.c32 6
	<.main+918 @063d82>  : 13 01                      set.x32 sp(1)
	<.main+920 @063d84>  : 10 00                      dup.x32 sp(0)
	<.main+922 @063d86>  : 06 0a 00 00                jz <.main+932 @063d90>
	<.main+926 @063d8a>  : 10 00                      dup.x32 sp(0)
	<.main+928 @063d8c>  : 04 09 00 00                jmp <.main+937 @063d95>
	<.main+932 @063d90>  : 1c 02 00 00 00             load.c32 2
	<.main+937 @063d95>  : 13 01                      set.x32 sp(1)
	<.main+939 @063d97>  : 10 00                      dup.x32 sp(0)
	<.main+941 @063d99>  : 06 0a 00 00                jz <.main+951 @063da3>
	<.main+945 @063d9d>  : 10 00                      dup.x32 sp(0)
	<.main+947 @063d9f>  : 04 09 00 00                jmp <.main+956 @063da8>
	<.main+951 @063da3>  : 1c 08 00 00 00             load.c32 8
	<.main+956 @063da8>  : 13 01                      set.x32 sp(1)
	<.main+958 @063daa>  : 24 b8 25 06                store.m32 <@0625b8> ;anyLrVal
	cmplStd/test/lang/inlineMacros.ci:52: (62 bytes: <.main+962 @063dae> - <.main+1024 @063dec>): static anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+962 @063dae>  : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+966 @063db2>  : 10 00                      dup.x32 sp(0)
	<.main+968 @063db4>  : 06 0a 00 00                jz <.main+978 @063dbe>
	<.main+972 @063db8>  : 10 00                      dup.x32 sp(0)
	<.main+974 @063dba>  : 04 2c 00 00                jmp <.main+1018 @063de6>
	<.main+978 @063dbe>  : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+982 @063dc2>  : 10 00                      dup.x32 sp(0)
	<.main+984 @063dc4>  : 06 0a 00 00                jz <.main+994 @063dce>
	<.main+988 @063dc8>  : 10 00                      dup.x32 sp(0)
	<.main+990 @063dca>  : 04 1a 00 00                jmp <.main+1016 @063de4>
	<.main+994 @063dce>  : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+998 @063dd2>  : 10 00                      dup.x32 sp(0)
	<.main+1000 @063dd4> : 06 0a 00 00                jz <.main+1010 @063dde>
	<.main+1004 @063dd8> : 10 00                      dup.x32 sp(0)
	<.main+1006 @063dda> : 04 08 00 00                jmp <.main+1014 @063de2>
	<.main+1010 @063dde> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1014 @063de2> : 13 01                      set.x32 sp(1)
	<.main+1016 @063de4> : 13 01                      set.x32 sp(1)
	<.main+1018 @063de6> : 13 01                      set.x32 sp(1)
	<.main+1020 @063de8> : 24 c0 25 06                store.m32 <@0625c0> ;anyRlVar
	cmplStd/test/lang/inlineMacros.ci:53: (62 bytes: <.main+1024 @063dec> - <.main+1086 @063e2a>): static anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+1024 @063dec> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1028 @063df0> : 10 00                      dup.x32 sp(0)
	<.main+1030 @063df2> : 06 0a 00 00                jz <.main+1040 @063dfc>
	<.main+1034 @063df6> : 10 00                      dup.x32 sp(0)
	<.main+1036 @063df8> : 04 08 00 00                jmp <.main+1044 @063e00>
	<.main+1040 @063dfc> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1044 @063e00> : 13 01                      set.x32 sp(1)
	<.main+1046 @063e02> : 10 00                      dup.x32 sp(0)
	<.main+1048 @063e04> : 06 0a 00 00                jz <.main+1058 @063e0e>
	<.main+1052 @063e08> : 10 00                      dup.x32 sp(0)
	<.main+1054 @063e0a> : 04 08 00 00                jmp <.main+1062 @063e12>
	<.main+1058 @063e0e> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1062 @063e12> : 13 01                      set.x32 sp(1)
	<.main+1064 @063e14> : 10 00                      dup.x32 sp(0)
	<.main+1066 @063e16> : 06 0a 00 00                jz <.main+1076 @063e20>
	<.main+1070 @063e1a> : 10 00                      dup.x32 sp(0)
	<.main+1072 @063e1c> : 04 08 00 00                jmp <.main+1080 @063e24>
	<.main+1076 @063e20> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1080 @063e24> : 13 01                      set.x32 sp(1)
	<.main+1082 @063e26> : 24 c8 25 06                store.m32 <@0625c8> ;anyLrVar
	cmplStd/test/lang/inlineMacros.ci:54: (82 bytes: <.main+1086 @063e2a> - <.main+1168 @063e7c>): static anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1086 @063e2a> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1090 @063e2e> : 0c 01 00 00                inc.i32(+1)
	<.main+1094 @063e32> : 10 00                      dup.x32 sp(0)
	<.main+1096 @063e34> : 06 0a 00 00                jz <.main+1106 @063e3e>
	<.main+1100 @063e38> : 10 00                      dup.x32 sp(0)
	<.main+1102 @063e3a> : 04 38 00 00                jmp <.main+1158 @063e72>
	<.main+1106 @063e3e> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1110 @063e42> : 0c 01 00 00                inc.i32(+1)
	<.main+1114 @063e46> : 10 00                      dup.x32 sp(0)
	<.main+1116 @063e48> : 06 0a 00 00                jz <.main+1126 @063e52>
	<.main+1120 @063e4c> : 10 00                      dup.x32 sp(0)
	<.main+1122 @063e4e> : 04 22 00 00                jmp <.main+1156 @063e70>
	<.main+1126 @063e52> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1130 @063e56> : 0c 01 00 00                inc.i32(+1)
	<.main+1134 @063e5a> : 10 00                      dup.x32 sp(0)
	<.main+1136 @063e5c> : 06 0a 00 00                jz <.main+1146 @063e66>
	<.main+1140 @063e60> : 10 00                      dup.x32 sp(0)
	<.main+1142 @063e62> : 04 0c 00 00                jmp <.main+1154 @063e6e>
	<.main+1146 @063e66> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1150 @063e6a> : 0c 01 00 00                inc.i32(+1)
	<.main+1154 @063e6e> : 13 01                      set.x32 sp(1)
	<.main+1156 @063e70> : 13 01                      set.x32 sp(1)
	<.main+1158 @063e72> : 13 01                      set.x32 sp(1)
	<.main+1160 @063e74> : 0c ff ff ff                inc.i32(-1)
	<.main+1164 @063e78> : 24 d0 25 06                store.m32 <@0625d0> ;anyRlXpr
	cmplStd/test/lang/inlineMacros.ci:55: (82 bytes: <.main+1168 @063e7c> - <.main+1250 @063ece>): static anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1168 @063e7c> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1172 @063e80> : 0c 01 00 00                inc.i32(+1)
	<.main+1176 @063e84> : 10 00                      dup.x32 sp(0)
	<.main+1178 @063e86> : 06 0a 00 00                jz <.main+1188 @063e90>
	<.main+1182 @063e8a> : 10 00                      dup.x32 sp(0)
	<.main+1184 @063e8c> : 04 0c 00 00                jmp <.main+1196 @063e98>
	<.main+1188 @063e90> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1192 @063e94> : 0c 01 00 00                inc.i32(+1)
	<.main+1196 @063e98> : 13 01                      set.x32 sp(1)
	<.main+1198 @063e9a> : 10 00                      dup.x32 sp(0)
	<.main+1200 @063e9c> : 06 0a 00 00                jz <.main+1210 @063ea6>
	<.main+1204 @063ea0> : 10 00                      dup.x32 sp(0)
	<.main+1206 @063ea2> : 04 0c 00 00                jmp <.main+1218 @063eae>
	<.main+1210 @063ea6> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1214 @063eaa> : 0c 01 00 00                inc.i32(+1)
	<.main+1218 @063eae> : 13 01                      set.x32 sp(1)
	<.main+1220 @063eb0> : 10 00                      dup.x32 sp(0)
	<.main+1222 @063eb2> : 06 0a 00 00                jz <.main+1232 @063ebc>
	<.main+1226 @063eb6> : 10 00                      dup.x32 sp(0)
	<.main+1228 @063eb8> : 04 0c 00 00                jmp <.main+1240 @063ec4>
	<.main+1232 @063ebc> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1236 @063ec0> : 0c 01 00 00                inc.i32(+1)
	<.main+1240 @063ec4> : 13 01                      set.x32 sp(1)
	<.main+1242 @063ec6> : 0c ff ff ff                inc.i32(-1)
	<.main+1246 @063eca> : 24 d8 25 06                store.m32 <@0625d8> ;anyLrXpr
	cmplStd/test/lang/inlineMacros.ci:59: (93 bytes: <.main+1250 @063ece> - <.main+1343 @063f2b>): static minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+1250 @063ece> : 1c 03 00 00 00             load.c32 3
	<.main+1255 @063ed3> : 1c 06 00 00 00             load.c32 6
	<.main+1260 @063ed8> : 1c 02 00 00 00             load.c32 2
	<.main+1265 @063edd> : 1c 08 00 00 00             load.c32 8
	<.main+1270 @063ee2> : 10 01                      dup.x32 sp(1)
	<.main+1272 @063ee4> : 10 01                      dup.x32 sp(1)
	<.main+1274 @063ee6> : 58                         clt.i32
	<.main+1275 @063ee7> : 06 0a 00 00                jz <.main+1285 @063ef1>
	<.main+1279 @063eeb> : 10 01                      dup.x32 sp(1)
	<.main+1281 @063eed> : 04 06 00 00                jmp <.main+1287 @063ef3>
	<.main+1285 @063ef1> : 10 00                      dup.x32 sp(0)
	<.main+1287 @063ef3> : 13 02                      set.x32 sp(2)
	<.main+1289 @063ef5> : 09 fc ff ff                inc.sp(-4)
	<.main+1293 @063ef9> : 10 01                      dup.x32 sp(1)
	<.main+1295 @063efb> : 10 01                      dup.x32 sp(1)
	<.main+1297 @063efd> : 58                         clt.i32
	<.main+1298 @063efe> : 06 0a 00 00                jz <.main+1308 @063f08>
	<.main+1302 @063f02> : 10 01                      dup.x32 sp(1)
	<.main+1304 @063f04> : 04 06 00 00                jmp <.main+1310 @063f0a>
	<.main+1308 @063f08> : 10 00                      dup.x32 sp(0)
	<.main+1310 @063f0a> : 13 02                      set.x32 sp(2)
	<.main+1312 @063f0c> : 09 fc ff ff                inc.sp(-4)
	<.main+1316 @063f10> : 10 01                      dup.x32 sp(1)
	<.main+1318 @063f12> : 10 01                      dup.x32 sp(1)
	<.main+1320 @063f14> : 58                         clt.i32
	<.main+1321 @063f15> : 06 0a 00 00                jz <.main+1331 @063f1f>
	<.main+1325 @063f19> : 10 01                      dup.x32 sp(1)
	<.main+1327 @063f1b> : 04 06 00 00                jmp <.main+1333 @063f21>
	<.main+1331 @063f1f> : 10 00                      dup.x32 sp(0)
	<.main+1333 @063f21> : 13 02                      set.x32 sp(2)
	<.main+1335 @063f23> : 09 fc ff ff                inc.sp(-4)
	<.main+1339 @063f27> : 24 e0 25 06                store.m32 <@0625e0> ;minRlVal
	cmplStd/test/lang/inlineMacros.ci:60: (93 bytes: <.main+1343 @063f2b> - <.main+1436 @063f88>): static minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+1343 @063f2b> : 1c 03 00 00 00             load.c32 3
	<.main+1348 @063f30> : 1c 06 00 00 00             load.c32 6
	<.main+1353 @063f35> : 10 01                      dup.x32 sp(1)
	<.main+1355 @063f37> : 10 01                      dup.x32 sp(1)
	<.main+1357 @063f39> : 58                         clt.i32
	<.main+1358 @063f3a> : 06 0a 00 00                jz <.main+1368 @063f44>
	<.main+1362 @063f3e> : 10 01                      dup.x32 sp(1)
	<.main+1364 @063f40> : 04 06 00 00                jmp <.main+1370 @063f46>
	<.main+1368 @063f44> : 10 00                      dup.x32 sp(0)
	<.main+1370 @063f46> : 13 02                      set.x32 sp(2)
	<.main+1372 @063f48> : 09 fc ff ff                inc.sp(-4)
	<.main+1376 @063f4c> : 1c 02 00 00 00             load.c32 2
	<.main+1381 @063f51> : 10 01                      dup.x32 sp(1)
	<.main+1383 @063f53> : 10 01                      dup.x32 sp(1)
	<.main+1385 @063f55> : 58                         clt.i32
	<.main+1386 @063f56> : 06 0a 00 00                jz <.main+1396 @063f60>
	<.main+1390 @063f5a> : 10 01                      dup.x32 sp(1)
	<.main+1392 @063f5c> : 04 06 00 00                jmp <.main+1398 @063f62>
	<.main+1396 @063f60> : 10 00                      dup.x32 sp(0)
	<.main+1398 @063f62> : 13 02                      set.x32 sp(2)
	<.main+1400 @063f64> : 09 fc ff ff                inc.sp(-4)
	<.main+1404 @063f68> : 1c 08 00 00 00             load.c32 8
	<.main+1409 @063f6d> : 10 01                      dup.x32 sp(1)
	<.main+1411 @063f6f> : 10 01                      dup.x32 sp(1)
	<.main+1413 @063f71> : 58                         clt.i32
	<.main+1414 @063f72> : 06 0a 00 00                jz <.main+1424 @063f7c>
	<.main+1418 @063f76> : 10 01                      dup.x32 sp(1)
	<.main+1420 @063f78> : 04 06 00 00                jmp <.main+1426 @063f7e>
	<.main+1424 @063f7c> : 10 00                      dup.x32 sp(0)
	<.main+1426 @063f7e> : 13 02                      set.x32 sp(2)
	<.main+1428 @063f80> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @063f84> : 24 e8 25 06                store.m32 <@0625e8> ;minLrVal
	cmplStd/test/lang/inlineMacros.ci:61: (89 bytes: <.main+1436 @063f88> - <.main+1525 @063fe1>): static minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+1436 @063f88> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1440 @063f8c> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1444 @063f90> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1448 @063f94> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1452 @063f98> : 10 01                      dup.x32 sp(1)
	<.main+1454 @063f9a> : 10 01                      dup.x32 sp(1)
	<.main+1456 @063f9c> : 58                         clt.i32
	<.main+1457 @063f9d> : 06 0a 00 00                jz <.main+1467 @063fa7>
	<.main+1461 @063fa1> : 10 01                      dup.x32 sp(1)
	<.main+1463 @063fa3> : 04 06 00 00                jmp <.main+1469 @063fa9>
	<.main+1467 @063fa7> : 10 00                      dup.x32 sp(0)
	<.main+1469 @063fa9> : 13 02                      set.x32 sp(2)
	<.main+1471 @063fab> : 09 fc ff ff                inc.sp(-4)
	<.main+1475 @063faf> : 10 01                      dup.x32 sp(1)
	<.main+1477 @063fb1> : 10 01                      dup.x32 sp(1)
	<.main+1479 @063fb3> : 58                         clt.i32
	<.main+1480 @063fb4> : 06 0a 00 00                jz <.main+1490 @063fbe>
	<.main+1484 @063fb8> : 10 01                      dup.x32 sp(1)
	<.main+1486 @063fba> : 04 06 00 00                jmp <.main+1492 @063fc0>
	<.main+1490 @063fbe> : 10 00                      dup.x32 sp(0)
	<.main+1492 @063fc0> : 13 02                      set.x32 sp(2)
	<.main+1494 @063fc2> : 09 fc ff ff                inc.sp(-4)
	<.main+1498 @063fc6> : 10 01                      dup.x32 sp(1)
	<.main+1500 @063fc8> : 10 01                      dup.x32 sp(1)
	<.main+1502 @063fca> : 58                         clt.i32
	<.main+1503 @063fcb> : 06 0a 00 00                jz <.main+1513 @063fd5>
	<.main+1507 @063fcf> : 10 01                      dup.x32 sp(1)
	<.main+1509 @063fd1> : 04 06 00 00                jmp <.main+1515 @063fd7>
	<.main+1513 @063fd5> : 10 00                      dup.x32 sp(0)
	<.main+1515 @063fd7> : 13 02                      set.x32 sp(2)
	<.main+1517 @063fd9> : 09 fc ff ff                inc.sp(-4)
	<.main+1521 @063fdd> : 24 f0 25 06                store.m32 <@0625f0> ;minRlVar
	cmplStd/test/lang/inlineMacros.ci:62: (89 bytes: <.main+1525 @063fe1> - <.main+1614 @06403a>): static minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+1525 @063fe1> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1529 @063fe5> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1533 @063fe9> : 10 01                      dup.x32 sp(1)
	<.main+1535 @063feb> : 10 01                      dup.x32 sp(1)
	<.main+1537 @063fed> : 58                         clt.i32
	<.main+1538 @063fee> : 06 0a 00 00                jz <.main+1548 @063ff8>
	<.main+1542 @063ff2> : 10 01                      dup.x32 sp(1)
	<.main+1544 @063ff4> : 04 06 00 00                jmp <.main+1550 @063ffa>
	<.main+1548 @063ff8> : 10 00                      dup.x32 sp(0)
	<.main+1550 @063ffa> : 13 02                      set.x32 sp(2)
	<.main+1552 @063ffc> : 09 fc ff ff                inc.sp(-4)
	<.main+1556 @064000> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1560 @064004> : 10 01                      dup.x32 sp(1)
	<.main+1562 @064006> : 10 01                      dup.x32 sp(1)
	<.main+1564 @064008> : 58                         clt.i32
	<.main+1565 @064009> : 06 0a 00 00                jz <.main+1575 @064013>
	<.main+1569 @06400d> : 10 01                      dup.x32 sp(1)
	<.main+1571 @06400f> : 04 06 00 00                jmp <.main+1577 @064015>
	<.main+1575 @064013> : 10 00                      dup.x32 sp(0)
	<.main+1577 @064015> : 13 02                      set.x32 sp(2)
	<.main+1579 @064017> : 09 fc ff ff                inc.sp(-4)
	<.main+1583 @06401b> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1587 @06401f> : 10 01                      dup.x32 sp(1)
	<.main+1589 @064021> : 10 01                      dup.x32 sp(1)
	<.main+1591 @064023> : 58                         clt.i32
	<.main+1592 @064024> : 06 0a 00 00                jz <.main+1602 @06402e>
	<.main+1596 @064028> : 10 01                      dup.x32 sp(1)
	<.main+1598 @06402a> : 04 06 00 00                jmp <.main+1604 @064030>
	<.main+1602 @06402e> : 10 00                      dup.x32 sp(0)
	<.main+1604 @064030> : 13 02                      set.x32 sp(2)
	<.main+1606 @064032> : 09 fc ff ff                inc.sp(-4)
	<.main+1610 @064036> : 24 f8 25 06                store.m32 <@0625f8> ;minLrVar
	cmplStd/test/lang/inlineMacros.ci:63: (109 bytes: <.main+1614 @06403a> - <.main+1723 @0640a7>): static minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1614 @06403a> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1618 @06403e> : 0c 01 00 00                inc.i32(+1)
	<.main+1622 @064042> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1626 @064046> : 0c 01 00 00                inc.i32(+1)
	<.main+1630 @06404a> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1634 @06404e> : 0c 01 00 00                inc.i32(+1)
	<.main+1638 @064052> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1642 @064056> : 0c 01 00 00                inc.i32(+1)
	<.main+1646 @06405a> : 10 01                      dup.x32 sp(1)
	<.main+1648 @06405c> : 10 01                      dup.x32 sp(1)
	<.main+1650 @06405e> : 58                         clt.i32
	<.main+1651 @06405f> : 06 0a 00 00                jz <.main+1661 @064069>
	<.main+1655 @064063> : 10 01                      dup.x32 sp(1)
	<.main+1657 @064065> : 04 06 00 00                jmp <.main+1663 @06406b>
	<.main+1661 @064069> : 10 00                      dup.x32 sp(0)
	<.main+1663 @06406b> : 13 02                      set.x32 sp(2)
	<.main+1665 @06406d> : 09 fc ff ff                inc.sp(-4)
	<.main+1669 @064071> : 10 01                      dup.x32 sp(1)
	<.main+1671 @064073> : 10 01                      dup.x32 sp(1)
	<.main+1673 @064075> : 58                         clt.i32
	<.main+1674 @064076> : 06 0a 00 00                jz <.main+1684 @064080>
	<.main+1678 @06407a> : 10 01                      dup.x32 sp(1)
	<.main+1680 @06407c> : 04 06 00 00                jmp <.main+1686 @064082>
	<.main+1684 @064080> : 10 00                      dup.x32 sp(0)
	<.main+1686 @064082> : 13 02                      set.x32 sp(2)
	<.main+1688 @064084> : 09 fc ff ff                inc.sp(-4)
	<.main+1692 @064088> : 10 01                      dup.x32 sp(1)
	<.main+1694 @06408a> : 10 01                      dup.x32 sp(1)
	<.main+1696 @06408c> : 58                         clt.i32
	<.main+1697 @06408d> : 06 0a 00 00                jz <.main+1707 @064097>
	<.main+1701 @064091> : 10 01                      dup.x32 sp(1)
	<.main+1703 @064093> : 04 06 00 00                jmp <.main+1709 @064099>
	<.main+1707 @064097> : 10 00                      dup.x32 sp(0)
	<.main+1709 @064099> : 13 02                      set.x32 sp(2)
	<.main+1711 @06409b> : 09 fc ff ff                inc.sp(-4)
	<.main+1715 @06409f> : 0c ff ff ff                inc.i32(-1)
	<.main+1719 @0640a3> : 24 00 26 06                store.m32 <@062600> ;minRlXpr
	cmplStd/test/lang/inlineMacros.ci:64: (109 bytes: <.main+1723 @0640a7> - <.main+1832 @064114>): static minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1723 @0640a7> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+1727 @0640ab> : 0c 01 00 00                inc.i32(+1)
	<.main+1731 @0640af> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+1735 @0640b3> : 0c 01 00 00                inc.i32(+1)
	<.main+1739 @0640b7> : 10 01                      dup.x32 sp(1)
	<.main+1741 @0640b9> : 10 01                      dup.x32 sp(1)
	<.main+1743 @0640bb> : 58                         clt.i32
	<.main+1744 @0640bc> : 06 0a 00 00                jz <.main+1754 @0640c6>
	<.main+1748 @0640c0> : 10 01                      dup.x32 sp(1)
	<.main+1750 @0640c2> : 04 06 00 00                jmp <.main+1756 @0640c8>
	<.main+1754 @0640c6> : 10 00                      dup.x32 sp(0)
	<.main+1756 @0640c8> : 13 02                      set.x32 sp(2)
	<.main+1758 @0640ca> : 09 fc ff ff                inc.sp(-4)
	<.main+1762 @0640ce> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+1766 @0640d2> : 0c 01 00 00                inc.i32(+1)
	<.main+1770 @0640d6> : 10 01                      dup.x32 sp(1)
	<.main+1772 @0640d8> : 10 01                      dup.x32 sp(1)
	<.main+1774 @0640da> : 58                         clt.i32
	<.main+1775 @0640db> : 06 0a 00 00                jz <.main+1785 @0640e5>
	<.main+1779 @0640df> : 10 01                      dup.x32 sp(1)
	<.main+1781 @0640e1> : 04 06 00 00                jmp <.main+1787 @0640e7>
	<.main+1785 @0640e5> : 10 00                      dup.x32 sp(0)
	<.main+1787 @0640e7> : 13 02                      set.x32 sp(2)
	<.main+1789 @0640e9> : 09 fc ff ff                inc.sp(-4)
	<.main+1793 @0640ed> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+1797 @0640f1> : 0c 01 00 00                inc.i32(+1)
	<.main+1801 @0640f5> : 10 01                      dup.x32 sp(1)
	<.main+1803 @0640f7> : 10 01                      dup.x32 sp(1)
	<.main+1805 @0640f9> : 58                         clt.i32
	<.main+1806 @0640fa> : 06 0a 00 00                jz <.main+1816 @064104>
	<.main+1810 @0640fe> : 10 01                      dup.x32 sp(1)
	<.main+1812 @064100> : 04 06 00 00                jmp <.main+1818 @064106>
	<.main+1816 @064104> : 10 00                      dup.x32 sp(0)
	<.main+1818 @064106> : 13 02                      set.x32 sp(2)
	<.main+1820 @064108> : 09 fc ff ff                inc.sp(-4)
	<.main+1824 @06410c> : 0c ff ff ff                inc.i32(-1)
	<.main+1828 @064110> : 24 08 26 06                store.m32 <@062608> ;minLrXpr
	cmplStd/test/lang/inlineMacros.ci:68: (93 bytes: <.main+1832 @064114> - <.main+1925 @064171>): static maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+1832 @064114> : 1c 03 00 00 00             load.c32 3
	<.main+1837 @064119> : 1c 06 00 00 00             load.c32 6
	<.main+1842 @06411e> : 1c 02 00 00 00             load.c32 2
	<.main+1847 @064123> : 1c 08 00 00 00             load.c32 8
	<.main+1852 @064128> : 10 01                      dup.x32 sp(1)
	<.main+1854 @06412a> : 10 01                      dup.x32 sp(1)
	<.main+1856 @06412c> : 59                         cgt.i32
	<.main+1857 @06412d> : 06 0a 00 00                jz <.main+1867 @064137>
	<.main+1861 @064131> : 10 01                      dup.x32 sp(1)
	<.main+1863 @064133> : 04 06 00 00                jmp <.main+1869 @064139>
	<.main+1867 @064137> : 10 00                      dup.x32 sp(0)
	<.main+1869 @064139> : 13 02                      set.x32 sp(2)
	<.main+1871 @06413b> : 09 fc ff ff                inc.sp(-4)
	<.main+1875 @06413f> : 10 01                      dup.x32 sp(1)
	<.main+1877 @064141> : 10 01                      dup.x32 sp(1)
	<.main+1879 @064143> : 59                         cgt.i32
	<.main+1880 @064144> : 06 0a 00 00                jz <.main+1890 @06414e>
	<.main+1884 @064148> : 10 01                      dup.x32 sp(1)
	<.main+1886 @06414a> : 04 06 00 00                jmp <.main+1892 @064150>
	<.main+1890 @06414e> : 10 00                      dup.x32 sp(0)
	<.main+1892 @064150> : 13 02                      set.x32 sp(2)
	<.main+1894 @064152> : 09 fc ff ff                inc.sp(-4)
	<.main+1898 @064156> : 10 01                      dup.x32 sp(1)
	<.main+1900 @064158> : 10 01                      dup.x32 sp(1)
	<.main+1902 @06415a> : 59                         cgt.i32
	<.main+1903 @06415b> : 06 0a 00 00                jz <.main+1913 @064165>
	<.main+1907 @06415f> : 10 01                      dup.x32 sp(1)
	<.main+1909 @064161> : 04 06 00 00                jmp <.main+1915 @064167>
	<.main+1913 @064165> : 10 00                      dup.x32 sp(0)
	<.main+1915 @064167> : 13 02                      set.x32 sp(2)
	<.main+1917 @064169> : 09 fc ff ff                inc.sp(-4)
	<.main+1921 @06416d> : 24 10 26 06                store.m32 <@062610> ;maxRlVal
	cmplStd/test/lang/inlineMacros.ci:69: (93 bytes: <.main+1925 @064171> - <.main+2018 @0641ce>): static maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+1925 @064171> : 1c 03 00 00 00             load.c32 3
	<.main+1930 @064176> : 1c 06 00 00 00             load.c32 6
	<.main+1935 @06417b> : 10 01                      dup.x32 sp(1)
	<.main+1937 @06417d> : 10 01                      dup.x32 sp(1)
	<.main+1939 @06417f> : 59                         cgt.i32
	<.main+1940 @064180> : 06 0a 00 00                jz <.main+1950 @06418a>
	<.main+1944 @064184> : 10 01                      dup.x32 sp(1)
	<.main+1946 @064186> : 04 06 00 00                jmp <.main+1952 @06418c>
	<.main+1950 @06418a> : 10 00                      dup.x32 sp(0)
	<.main+1952 @06418c> : 13 02                      set.x32 sp(2)
	<.main+1954 @06418e> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @064192> : 1c 02 00 00 00             load.c32 2
	<.main+1963 @064197> : 10 01                      dup.x32 sp(1)
	<.main+1965 @064199> : 10 01                      dup.x32 sp(1)
	<.main+1967 @06419b> : 59                         cgt.i32
	<.main+1968 @06419c> : 06 0a 00 00                jz <.main+1978 @0641a6>
	<.main+1972 @0641a0> : 10 01                      dup.x32 sp(1)
	<.main+1974 @0641a2> : 04 06 00 00                jmp <.main+1980 @0641a8>
	<.main+1978 @0641a6> : 10 00                      dup.x32 sp(0)
	<.main+1980 @0641a8> : 13 02                      set.x32 sp(2)
	<.main+1982 @0641aa> : 09 fc ff ff                inc.sp(-4)
	<.main+1986 @0641ae> : 1c 08 00 00 00             load.c32 8
	<.main+1991 @0641b3> : 10 01                      dup.x32 sp(1)
	<.main+1993 @0641b5> : 10 01                      dup.x32 sp(1)
	<.main+1995 @0641b7> : 59                         cgt.i32
	<.main+1996 @0641b8> : 06 0a 00 00                jz <.main+2006 @0641c2>
	<.main+2000 @0641bc> : 10 01                      dup.x32 sp(1)
	<.main+2002 @0641be> : 04 06 00 00                jmp <.main+2008 @0641c4>
	<.main+2006 @0641c2> : 10 00                      dup.x32 sp(0)
	<.main+2008 @0641c4> : 13 02                      set.x32 sp(2)
	<.main+2010 @0641c6> : 09 fc ff ff                inc.sp(-4)
	<.main+2014 @0641ca> : 24 18 26 06                store.m32 <@062618> ;maxLrVal
	cmplStd/test/lang/inlineMacros.ci:70: (89 bytes: <.main+2018 @0641ce> - <.main+2107 @064227>): static maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+2018 @0641ce> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+2022 @0641d2> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+2026 @0641d6> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+2030 @0641da> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+2034 @0641de> : 10 01                      dup.x32 sp(1)
	<.main+2036 @0641e0> : 10 01                      dup.x32 sp(1)
	<.main+2038 @0641e2> : 59                         cgt.i32
	<.main+2039 @0641e3> : 06 0a 00 00                jz <.main+2049 @0641ed>
	<.main+2043 @0641e7> : 10 01                      dup.x32 sp(1)
	<.main+2045 @0641e9> : 04 06 00 00                jmp <.main+2051 @0641ef>
	<.main+2049 @0641ed> : 10 00                      dup.x32 sp(0)
	<.main+2051 @0641ef> : 13 02                      set.x32 sp(2)
	<.main+2053 @0641f1> : 09 fc ff ff                inc.sp(-4)
	<.main+2057 @0641f5> : 10 01                      dup.x32 sp(1)
	<.main+2059 @0641f7> : 10 01                      dup.x32 sp(1)
	<.main+2061 @0641f9> : 59                         cgt.i32
	<.main+2062 @0641fa> : 06 0a 00 00                jz <.main+2072 @064204>
	<.main+2066 @0641fe> : 10 01                      dup.x32 sp(1)
	<.main+2068 @064200> : 04 06 00 00                jmp <.main+2074 @064206>
	<.main+2072 @064204> : 10 00                      dup.x32 sp(0)
	<.main+2074 @064206> : 13 02                      set.x32 sp(2)
	<.main+2076 @064208> : 09 fc ff ff                inc.sp(-4)
	<.main+2080 @06420c> : 10 01                      dup.x32 sp(1)
	<.main+2082 @06420e> : 10 01                      dup.x32 sp(1)
	<.main+2084 @064210> : 59                         cgt.i32
	<.main+2085 @064211> : 06 0a 00 00                jz <.main+2095 @06421b>
	<.main+2089 @064215> : 10 01                      dup.x32 sp(1)
	<.main+2091 @064217> : 04 06 00 00                jmp <.main+2097 @06421d>
	<.main+2095 @06421b> : 10 00                      dup.x32 sp(0)
	<.main+2097 @06421d> : 13 02                      set.x32 sp(2)
	<.main+2099 @06421f> : 09 fc ff ff                inc.sp(-4)
	<.main+2103 @064223> : 24 20 26 06                store.m32 <@062620> ;maxRlVar
	cmplStd/test/lang/inlineMacros.ci:71: (89 bytes: <.main+2107 @064227> - <.main+2196 @064280>): static maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+2107 @064227> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+2111 @06422b> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+2115 @06422f> : 10 01                      dup.x32 sp(1)
	<.main+2117 @064231> : 10 01                      dup.x32 sp(1)
	<.main+2119 @064233> : 59                         cgt.i32
	<.main+2120 @064234> : 06 0a 00 00                jz <.main+2130 @06423e>
	<.main+2124 @064238> : 10 01                      dup.x32 sp(1)
	<.main+2126 @06423a> : 04 06 00 00                jmp <.main+2132 @064240>
	<.main+2130 @06423e> : 10 00                      dup.x32 sp(0)
	<.main+2132 @064240> : 13 02                      set.x32 sp(2)
	<.main+2134 @064242> : 09 fc ff ff                inc.sp(-4)
	<.main+2138 @064246> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+2142 @06424a> : 10 01                      dup.x32 sp(1)
	<.main+2144 @06424c> : 10 01                      dup.x32 sp(1)
	<.main+2146 @06424e> : 59                         cgt.i32
	<.main+2147 @06424f> : 06 0a 00 00                jz <.main+2157 @064259>
	<.main+2151 @064253> : 10 01                      dup.x32 sp(1)
	<.main+2153 @064255> : 04 06 00 00                jmp <.main+2159 @06425b>
	<.main+2157 @064259> : 10 00                      dup.x32 sp(0)
	<.main+2159 @06425b> : 13 02                      set.x32 sp(2)
	<.main+2161 @06425d> : 09 fc ff ff                inc.sp(-4)
	<.main+2165 @064261> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+2169 @064265> : 10 01                      dup.x32 sp(1)
	<.main+2171 @064267> : 10 01                      dup.x32 sp(1)
	<.main+2173 @064269> : 59                         cgt.i32
	<.main+2174 @06426a> : 06 0a 00 00                jz <.main+2184 @064274>
	<.main+2178 @06426e> : 10 01                      dup.x32 sp(1)
	<.main+2180 @064270> : 04 06 00 00                jmp <.main+2186 @064276>
	<.main+2184 @064274> : 10 00                      dup.x32 sp(0)
	<.main+2186 @064276> : 13 02                      set.x32 sp(2)
	<.main+2188 @064278> : 09 fc ff ff                inc.sp(-4)
	<.main+2192 @06427c> : 24 28 26 06                store.m32 <@062628> ;maxLrVar
	cmplStd/test/lang/inlineMacros.ci:72: (109 bytes: <.main+2196 @064280> - <.main+2305 @0642ed>): static maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2196 @064280> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+2200 @064284> : 0c 01 00 00                inc.i32(+1)
	<.main+2204 @064288> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+2208 @06428c> : 0c 01 00 00                inc.i32(+1)
	<.main+2212 @064290> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+2216 @064294> : 0c 01 00 00                inc.i32(+1)
	<.main+2220 @064298> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+2224 @06429c> : 0c 01 00 00                inc.i32(+1)
	<.main+2228 @0642a0> : 10 01                      dup.x32 sp(1)
	<.main+2230 @0642a2> : 10 01                      dup.x32 sp(1)
	<.main+2232 @0642a4> : 59                         cgt.i32
	<.main+2233 @0642a5> : 06 0a 00 00                jz <.main+2243 @0642af>
	<.main+2237 @0642a9> : 10 01                      dup.x32 sp(1)
	<.main+2239 @0642ab> : 04 06 00 00                jmp <.main+2245 @0642b1>
	<.main+2243 @0642af> : 10 00                      dup.x32 sp(0)
	<.main+2245 @0642b1> : 13 02                      set.x32 sp(2)
	<.main+2247 @0642b3> : 09 fc ff ff                inc.sp(-4)
	<.main+2251 @0642b7> : 10 01                      dup.x32 sp(1)
	<.main+2253 @0642b9> : 10 01                      dup.x32 sp(1)
	<.main+2255 @0642bb> : 59                         cgt.i32
	<.main+2256 @0642bc> : 06 0a 00 00                jz <.main+2266 @0642c6>
	<.main+2260 @0642c0> : 10 01                      dup.x32 sp(1)
	<.main+2262 @0642c2> : 04 06 00 00                jmp <.main+2268 @0642c8>
	<.main+2266 @0642c6> : 10 00                      dup.x32 sp(0)
	<.main+2268 @0642c8> : 13 02                      set.x32 sp(2)
	<.main+2270 @0642ca> : 09 fc ff ff                inc.sp(-4)
	<.main+2274 @0642ce> : 10 01                      dup.x32 sp(1)
	<.main+2276 @0642d0> : 10 01                      dup.x32 sp(1)
	<.main+2278 @0642d2> : 59                         cgt.i32
	<.main+2279 @0642d3> : 06 0a 00 00                jz <.main+2289 @0642dd>
	<.main+2283 @0642d7> : 10 01                      dup.x32 sp(1)
	<.main+2285 @0642d9> : 04 06 00 00                jmp <.main+2291 @0642df>
	<.main+2289 @0642dd> : 10 00                      dup.x32 sp(0)
	<.main+2291 @0642df> : 13 02                      set.x32 sp(2)
	<.main+2293 @0642e1> : 09 fc ff ff                inc.sp(-4)
	<.main+2297 @0642e5> : 0c ff ff ff                inc.i32(-1)
	<.main+2301 @0642e9> : 24 30 26 06                store.m32 <@062630> ;maxRlXpr
	cmplStd/test/lang/inlineMacros.ci:73: (109 bytes: <.main+2305 @0642ed> - <.main+2414 @06435a>): static maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2305 @0642ed> : 20 d0 24 06                load.m32 <@0624d0> ;i3
	<.main+2309 @0642f1> : 0c 01 00 00                inc.i32(+1)
	<.main+2313 @0642f5> : 20 d8 24 06                load.m32 <@0624d8> ;i6
	<.main+2317 @0642f9> : 0c 01 00 00                inc.i32(+1)
	<.main+2321 @0642fd> : 10 01                      dup.x32 sp(1)
	<.main+2323 @0642ff> : 10 01                      dup.x32 sp(1)
	<.main+2325 @064301> : 59                         cgt.i32
	<.main+2326 @064302> : 06 0a 00 00                jz <.main+2336 @06430c>
	<.main+2330 @064306> : 10 01                      dup.x32 sp(1)
	<.main+2332 @064308> : 04 06 00 00                jmp <.main+2338 @06430e>
	<.main+2336 @06430c> : 10 00                      dup.x32 sp(0)
	<.main+2338 @06430e> : 13 02                      set.x32 sp(2)
	<.main+2340 @064310> : 09 fc ff ff                inc.sp(-4)
	<.main+2344 @064314> : 20 e0 24 06                load.m32 <@0624e0> ;i2
	<.main+2348 @064318> : 0c 01 00 00                inc.i32(+1)
	<.main+2352 @06431c> : 10 01                      dup.x32 sp(1)
	<.main+2354 @06431e> : 10 01                      dup.x32 sp(1)
	<.main+2356 @064320> : 59                         cgt.i32
	<.main+2357 @064321> : 06 0a 00 00                jz <.main+2367 @06432b>
	<.main+2361 @064325> : 10 01                      dup.x32 sp(1)
	<.main+2363 @064327> : 04 06 00 00                jmp <.main+2369 @06432d>
	<.main+2367 @06432b> : 10 00                      dup.x32 sp(0)
	<.main+2369 @06432d> : 13 02                      set.x32 sp(2)
	<.main+2371 @06432f> : 09 fc ff ff                inc.sp(-4)
	<.main+2375 @064333> : 20 e8 24 06                load.m32 <@0624e8> ;i8
	<.main+2379 @064337> : 0c 01 00 00                inc.i32(+1)
	<.main+2383 @06433b> : 10 01                      dup.x32 sp(1)
	<.main+2385 @06433d> : 10 01                      dup.x32 sp(1)
	<.main+2387 @06433f> : 59                         cgt.i32
	<.main+2388 @064340> : 06 0a 00 00                jz <.main+2398 @06434a>
	<.main+2392 @064344> : 10 01                      dup.x32 sp(1)
	<.main+2394 @064346> : 04 06 00 00                jmp <.main+2400 @06434c>
	<.main+2398 @06434a> : 10 00                      dup.x32 sp(0)
	<.main+2400 @06434c> : 13 02                      set.x32 sp(2)
	<.main+2402 @06434e> : 09 fc ff ff                inc.sp(-4)
	<.main+2406 @064352> : 0c ff ff ff                inc.i32(-1)
	<.main+2410 @064356> : 24 38 26 06                store.m32 <@062638> ;maxLrXpr
	cmplStd/test/lang/overload.inline.ci:9: (9 bytes: <.main+2414 @06435a> - <.main+2423 @064363>): static overload1: float32 := overload
	<.main+2414 @06435a> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2419 @06435f> : 24 40 26 06                store.m32 <@062640> ;overload1
	cmplStd/test/lang/overload.inline.ci:10: (9 bytes: <.main+2423 @064363> - <.main+2432 @06436c>): static overload2: float32 := overload()
	<.main+2423 @064363> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2428 @064368> : 24 48 26 06                store.m32 <@062648> ;overload2
	cmplStd/test/lang/overload.inline.ci:11: (9 bytes: <.main+2432 @06436c> - <.main+2441 @064375>): static overload3: float32 := overload(0)
	<.main+2432 @06436c> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2437 @064371> : 24 50 26 06                store.m32 <@062650> ;overload3
	cmplStd/test/lang/overload.inline.ci:12: (9 bytes: <.main+2441 @064375> - <.main+2450 @06437e>): static overload4: float32 := overload(0.000000)
	<.main+2441 @064375> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2446 @06437a> : 24 58 26 06                store.m32 <@062658> ;overload4
	cmplStd/test/lang/overload.inline.ci:13: (9 bytes: <.main+2450 @06437e> - <.main+2459 @064387>): static overload5: float32 := overload(0, 0)
	<.main+2450 @06437e> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2455 @064383> : 24 60 26 06                store.m32 <@062660> ;overload5
	cmplStd/test/lang/overload.inline.ci:28: (13 bytes: <.main+2459 @064387> - <.main+2472 @064394>): static boilC: Celsius := Celsius(100.000000)
	<.main+2459 @064387> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2468 @064390> : 23 68 26 06                store.m64 <@062668> ;boilC
	cmplStd/test/lang/overload.inline.ci:29: (28 bytes: <.main+2472 @064394> - <.main+2500 @0643b0>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2472 @064394> : 21 68 26 06                load.m64 <@062668> ;boilC
	<.main+2476 @064398> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2485 @0643a1> : 83                         mul.f64
	<.main+2486 @0643a2> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2495 @0643ab> : 81                         add.f64
	<.main+2496 @0643ac> : 23 70 26 06                store.m64 <@062670> ;boilF
	cmplStd/test/std/number.ci:3: (13 bytes: <.main+2500 @0643b0> - <.main+2513 @0643bd>): static pi64: float64 := 3.141593
	<.main+2500 @0643b0> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+2509 @0643b9> : 23 78 26 06                store.m64 <@062678> ;pi64
	cmplStd/test/std/number.ci:4: (13 bytes: <.main+2513 @0643bd> - <.main+2526 @0643ca>): static e64: float64 := 2.718282
	<.main+2513 @0643bd> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+2522 @0643c6> : 23 80 26 06                store.m64 <@062680> ;e64
	cmplStd/test/std/number.ci:6: (9 bytes: <.main+2526 @0643ca> - <.main+2535 @0643d3>): static pi32: float32 := pi64
	<.main+2526 @0643ca> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+2530 @0643ce> : 8c                         f64.2f32
	<.main+2531 @0643cf> : 24 88 26 06                store.m32 <@062688> ;pi32
	cmplStd/test/std/number.ci:7: (9 bytes: <.main+2535 @0643d3> - <.main+2544 @0643dc>): static e32: float32 := e64
	<.main+2535 @0643d3> : 21 80 26 06                load.m64 <@062680> ;e64
	<.main+2539 @0643d7> : 8c                         f64.2f32
	<.main+2540 @0643d8> : 24 90 26 06                store.m32 <@062690> ;e32
	cmplStd/test/std/number.ci:14: (11 bytes: <.main+2544 @0643dc> - <.main+2555 @0643e7>): static r_comp: int32 := 14 << 3
	<.main+2544 @0643dc> : 1c 0e 00 00 00             load.c32 14
	<.main+2549 @0643e1> : 3f 43                      b32.shl 0x003
	<.main+2551 @0643e3> : 24 98 26 06                store.m32 <@062698> ;r_comp
	cmplStd/test/std/number.ci:15: (11 bytes: <.main+2555 @0643e7> - <.main+2566 @0643f2>): static g_comp: int32 := 63 << 2
	<.main+2555 @0643e7> : 1c 3f 00 00 00             load.c32 63
	<.main+2560 @0643ec> : 3f 42                      b32.shl 0x002
	<.main+2562 @0643ee> : 24 a0 26 06                store.m32 <@0626a0> ;g_comp
	cmplStd/test/std/number.ci:16: (11 bytes: <.main+2566 @0643f2> - <.main+2577 @0643fd>): static b_comp: int32 := 31 << 3
	<.main+2566 @0643f2> : 1c 1f 00 00 00             load.c32 31
	<.main+2571 @0643f7> : 3f 43                      b32.shl 0x003
	<.main+2573 @0643f9> : 24 a8 26 06                store.m32 <@0626a8> ;b_comp
	cmplStd/test/std/number.ci:18: (38 bytes: <.main+2577 @0643fd> - <.main+2615 @064423>): static r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+2577 @0643fd> : 20 98 26 06                load.m32 <@062698> ;r_comp
	<.main+2581 @064401> : 3f 48                      b32.shl 0x008
	<.main+2583 @064403> : 1c 00 f8 00 00             load.c32 63488
	<.main+2588 @064408> : 31                         and.b32
	<.main+2589 @064409> : 20 a0 26 06                load.m32 <@0626a0> ;g_comp
	<.main+2593 @06440d> : 3f 43                      b32.shl 0x003
	<.main+2595 @06440f> : 1c e0 07 00 00             load.c32 2016
	<.main+2600 @064414> : 31                         and.b32
	<.main+2601 @064415> : 32                         or.b32
	<.main+2602 @064416> : 20 a8 26 06                load.m32 <@0626a8> ;b_comp
	<.main+2606 @06441a> : 3f c3                      b32.sar 0x003
	<.main+2608 @06441c> : 3f 05                      b32.and 0x01f
	<.main+2610 @06441e> : 32                         or.b32
	<.main+2611 @06441f> : 24 b0 26 06                store.m32 <@0626b0> ;r5g6b5
	cmplStd/test/std/number.ci:19: (36 bytes: <.main+2615 @064423> - <.main+2651 @064447>): static r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+2615 @064423> : 20 98 26 06                load.m32 <@062698> ;r_comp
	<.main+2619 @064427> : 3f 50                      b32.shl 0x010
	<.main+2621 @064429> : 1c 00 00 ff 00             load.c32 16711680
	<.main+2626 @06442e> : 31                         and.b32
	<.main+2627 @06442f> : 20 a0 26 06                load.m32 <@0626a0> ;g_comp
	<.main+2631 @064433> : 3f 48                      b32.shl 0x008
	<.main+2633 @064435> : 1c 00 ff 00 00             load.c32 65280
	<.main+2638 @06443a> : 31                         and.b32
	<.main+2639 @06443b> : 32                         or.b32
	<.main+2640 @06443c> : 20 a8 26 06                load.m32 <@0626a8> ;b_comp
	<.main+2644 @064440> : 3f 08                      b32.and 0x0ff
	<.main+2646 @064442> : 32                         or.b32
	<.main+2647 @064443> : 24 b8 26 06                store.m32 <@0626b8> ;r8g8b8
	cmplStd/test/std/number.ci:21: (22 bytes: <.main+2651 @064447> - <.main+2673 @06445d>): static zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+2651 @064447> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+2655 @06444b> : 1c 0b 00 00 00             load.c32 11
	<.main+2660 @064450> : 1c 05 00 00 00             load.c32 5
	<.main+2665 @064455> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2669 @064459> : 24 c0 26 06                store.m32 <@0626c0> ;zxtR5
	cmplStd/test/std/number.ci:22: (22 bytes: <.main+2673 @06445d> - <.main+2695 @064473>): static zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+2673 @06445d> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+2677 @064461> : 1c 05 00 00 00             load.c32 5
	<.main+2682 @064466> : 1c 06 00 00 00             load.c32 6
	<.main+2687 @06446b> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2691 @06446f> : 24 c8 26 06                store.m32 <@0626c8> ;zxtG6
	cmplStd/test/std/number.ci:23: (18 bytes: <.main+2695 @064473> - <.main+2713 @064485>): static zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+2695 @064473> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+2699 @064477> : 19                         load.z32
	<.main+2700 @064478> : 1c 05 00 00 00             load.c32 5
	<.main+2705 @06447d> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2709 @064481> : 24 d0 26 06                store.m32 <@0626d0> ;zxtB5
	cmplStd/test/std/number.ci:25: (22 bytes: <.main+2713 @064485> - <.main+2735 @06449b>): static sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+2713 @064485> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+2717 @064489> : 1c 0b 00 00 00             load.c32 11
	<.main+2722 @06448e> : 1c 05 00 00 00             load.c32 5
	<.main+2727 @064493> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2731 @064497> : 24 d8 26 06                store.m32 <@0626d8> ;sxtR5
	cmplStd/test/std/number.ci:26: (22 bytes: <.main+2735 @06449b> - <.main+2757 @0644b1>): static sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+2735 @06449b> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+2739 @06449f> : 1c 05 00 00 00             load.c32 5
	<.main+2744 @0644a4> : 1c 06 00 00 00             load.c32 6
	<.main+2749 @0644a9> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2753 @0644ad> : 24 e0 26 06                store.m32 <@0626e0> ;sxtG6
	cmplStd/test/std/number.ci:27: (18 bytes: <.main+2757 @0644b1> - <.main+2775 @0644c3>): static sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+2757 @0644b1> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+2761 @0644b5> : 19                         load.z32
	<.main+2762 @0644b6> : 1c 05 00 00 00             load.c32 5
	<.main+2767 @0644bb> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2771 @0644bf> : 24 e8 26 06                store.m32 <@0626e8> ;sxtB5
	cmplStd/test/std/number.ci:29: (22 bytes: <.main+2775 @0644c3> - <.main+2797 @0644d9>): static zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+2775 @0644c3> : 20 b8 26 06                load.m32 <@0626b8> ;r8g8b8
	<.main+2779 @0644c7> : 1c 10 00 00 00             load.c32 16
	<.main+2784 @0644cc> : 1c 08 00 00 00             load.c32 8
	<.main+2789 @0644d1> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2793 @0644d5> : 24 f0 26 06                store.m32 <@0626f0> ;zxtR8
	cmplStd/test/std/number.ci:30: (22 bytes: <.main+2797 @0644d9> - <.main+2819 @0644ef>): static zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+2797 @0644d9> : 20 b8 26 06                load.m32 <@0626b8> ;r8g8b8
	<.main+2801 @0644dd> : 1c 08 00 00 00             load.c32 8
	<.main+2806 @0644e2> : 1c 08 00 00 00             load.c32 8
	<.main+2811 @0644e7> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2815 @0644eb> : 24 f8 26 06                store.m32 <@0626f8> ;zxtG8
	cmplStd/test/std/number.ci:31: (18 bytes: <.main+2819 @0644ef> - <.main+2837 @064501>): static zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+2819 @0644ef> : 20 b8 26 06                load.m32 <@0626b8> ;r8g8b8
	<.main+2823 @0644f3> : 19                         load.z32
	<.main+2824 @0644f4> : 1c 08 00 00 00             load.c32 8
	<.main+2829 @0644f9> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2833 @0644fd> : 24 00 27 06                store.m32 <@062700> ;zxtB8
	cmplStd/test/std/number.ci:33: (22 bytes: <.main+2837 @064501> - <.main+2859 @064517>): static sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+2837 @064501> : 20 b8 26 06                load.m32 <@0626b8> ;r8g8b8
	<.main+2841 @064505> : 1c 10 00 00 00             load.c32 16
	<.main+2846 @06450a> : 1c 08 00 00 00             load.c32 8
	<.main+2851 @06450f> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2855 @064513> : 24 08 27 06                store.m32 <@062708> ;sxtR8
	cmplStd/test/std/number.ci:34: (22 bytes: <.main+2859 @064517> - <.main+2881 @06452d>): static sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+2859 @064517> : 20 b8 26 06                load.m32 <@0626b8> ;r8g8b8
	<.main+2863 @06451b> : 1c 08 00 00 00             load.c32 8
	<.main+2868 @064520> : 1c 08 00 00 00             load.c32 8
	<.main+2873 @064525> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2877 @064529> : 24 10 27 06                store.m32 <@062710> ;sxtG8
	cmplStd/test/std/number.ci:35: (18 bytes: <.main+2881 @06452d> - <.main+2899 @06453f>): static sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+2881 @06452d> : 20 b8 26 06                load.m32 <@0626b8> ;r8g8b8
	<.main+2885 @064531> : 19                         load.z32
	<.main+2886 @064532> : 1c 08 00 00 00             load.c32 8
	<.main+2891 @064537> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2895 @06453b> : 24 18 27 06                store.m32 <@062718> ;sxtB8
	cmplStd/test/std/number.ci:37: (22 bytes: <.main+2899 @06453f> - <.main+2921 @064555>): static testSin_f64: float64 := float64.sin(pi64 / (2))
	<.main+2899 @06453f> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+2903 @064543> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2912 @06454c> : 84                         div.f64
	<.main+2913 @06454d> : 01 27 00 00                nfc(39) ;float64.sin(x: float64): float64
	<.main+2917 @064551> : 23 20 27 06                store.m64 <@062720> ;testSin_f64
	cmplStd/test/std/number.ci:38: (22 bytes: <.main+2921 @064555> - <.main+2943 @06456b>): static testCos_f64: float64 := float64.cos(pi64 / (2))
	<.main+2921 @064555> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+2925 @064559> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2934 @064562> : 84                         div.f64
	<.main+2935 @064563> : 01 28 00 00                nfc(40) ;float64.cos(x: float64): float64
	<.main+2939 @064567> : 23 28 27 06                store.m64 <@062728> ;testCos_f64
	cmplStd/test/std/number.ci:39: (22 bytes: <.main+2943 @06456b> - <.main+2965 @064581>): static testTan_f64: float64 := float64.tan(pi64 / (4))
	<.main+2943 @06456b> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+2947 @06456f> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+2956 @064578> : 84                         div.f64
	<.main+2957 @064579> : 01 29 00 00                nfc(41) ;float64.tan(x: float64): float64
	<.main+2961 @06457d> : 23 30 27 06                store.m64 <@062730> ;testTan_f64
	cmplStd/test/std/number.ci:40: (22 bytes: <.main+2965 @064581> - <.main+2987 @064597>): static testLog_f64: float64 := float64.log(e64 * e64 * e64)
	<.main+2965 @064581> : 21 80 26 06                load.m64 <@062680> ;e64
	<.main+2969 @064585> : 21 80 26 06                load.m64 <@062680> ;e64
	<.main+2973 @064589> : 83                         mul.f64
	<.main+2974 @06458a> : 21 80 26 06                load.m64 <@062680> ;e64
	<.main+2978 @06458e> : 83                         mul.f64
	<.main+2979 @06458f> : 01 2a 00 00                nfc(42) ;float64.log(x: float64): float64
	<.main+2983 @064593> : 23 38 27 06                store.m64 <@062738> ;testLog_f64
	cmplStd/test/std/number.ci:41: (17 bytes: <.main+2987 @064597> - <.main+3004 @0645a8>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+2987 @064597> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+2996 @0645a0> : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<.main+3000 @0645a4> : 23 40 27 06                store.m64 <@062740> ;testExp_f64
	cmplStd/test/std/number.ci:42: (26 bytes: <.main+3004 @0645a8> - <.main+3030 @0645c2>): static testPow_f64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+3004 @0645a8> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+3008 @0645ac> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+3012 @0645b0> : 83                         mul.f64
	<.main+3013 @0645b1> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3022 @0645ba> : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<.main+3026 @0645be> : 23 48 27 06                store.m64 <@062748> ;testPow_f64
	cmplStd/test/std/number.ci:43: (17 bytes: <.main+3030 @0645c2> - <.main+3047 @0645d3>): static testSqrt_f64: float64 := float64.sqrt(pi64 * pi64)
	<.main+3030 @0645c2> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+3034 @0645c6> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+3038 @0645ca> : 83                         mul.f64
	<.main+3039 @0645cb> : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	<.main+3043 @0645cf> : 23 50 27 06                store.m64 <@062750> ;testSqrt_f64
	cmplStd/test/std/number.ci:44: (21 bytes: <.main+3047 @0645d3> - <.main+3068 @0645e8>): static testAtan_f64: float64 := float64.atan2(pi64, 1.000000)
	<.main+3047 @0645d3> : 21 78 26 06                load.m64 <@062678> ;pi64
	<.main+3051 @0645d7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3060 @0645e0> : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<.main+3064 @0645e4> : 23 58 27 06                store.m64 <@062758> ;testAtan_f64
	cmplStd/test/std/number.ci:46: (18 bytes: <.main+3068 @0645e8> - <.main+3086 @0645fa>): static testSin_f32: float32 := float32.sin(pi32 / (2))
	<.main+3068 @0645e8> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3072 @0645ec> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3077 @0645f1> : 74                         div.f32
	<.main+3078 @0645f2> : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	<.main+3082 @0645f6> : 24 60 27 06                store.m32 <@062760> ;testSin_f32
	cmplStd/test/std/number.ci:47: (18 bytes: <.main+3086 @0645fa> - <.main+3104 @06460c>): static testCos_f32: float32 := float32.cos(pi32 / (2))
	<.main+3086 @0645fa> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3090 @0645fe> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3095 @064603> : 74                         div.f32
	<.main+3096 @064604> : 01 20 00 00                nfc(32) ;float32.cos(x: float32): float32
	<.main+3100 @064608> : 24 68 27 06                store.m32 <@062768> ;testCos_f32
	cmplStd/test/std/number.ci:48: (18 bytes: <.main+3104 @06460c> - <.main+3122 @06461e>): static testTan_f32: float32 := float32.tan(pi32 / (4))
	<.main+3104 @06460c> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3108 @064610> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3113 @064615> : 74                         div.f32
	<.main+3114 @064616> : 01 21 00 00                nfc(33) ;float32.tan(x: float32): float32
	<.main+3118 @06461a> : 24 70 27 06                store.m32 <@062770> ;testTan_f32
	cmplStd/test/std/number.ci:49: (22 bytes: <.main+3122 @06461e> - <.main+3144 @064634>): static testLog_f32: float32 := float32.log(e32 * e32 * e32)
	<.main+3122 @06461e> : 20 90 26 06                load.m32 <@062690> ;e32
	<.main+3126 @064622> : 20 90 26 06                load.m32 <@062690> ;e32
	<.main+3130 @064626> : 73                         mul.f32
	<.main+3131 @064627> : 20 90 26 06                load.m32 <@062690> ;e32
	<.main+3135 @06462b> : 73                         mul.f32
	<.main+3136 @06462c> : 01 22 00 00                nfc(34) ;float32.log(x: float32): float32
	<.main+3140 @064630> : 24 78 27 06                store.m32 <@062778> ;testLog_f32
	cmplStd/test/std/number.ci:50: (13 bytes: <.main+3144 @064634> - <.main+3157 @064641>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+3144 @064634> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3149 @064639> : 01 23 00 00                nfc(35) ;float32.exp(x: float32): float32
	<.main+3153 @06463d> : 24 80 27 06                store.m32 <@062780> ;testExp_f32
	cmplStd/test/std/number.ci:51: (22 bytes: <.main+3157 @064641> - <.main+3179 @064657>): static testPow_f32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+3157 @064641> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3161 @064645> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3165 @064649> : 73                         mul.f32
	<.main+3166 @06464a> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3171 @06464f> : 01 24 00 00                nfc(36) ;float32.pow(x: float32, y: float32): float32
	<.main+3175 @064653> : 24 88 27 06                store.m32 <@062788> ;testPow_f32
	cmplStd/test/std/number.ci:52: (17 bytes: <.main+3179 @064657> - <.main+3196 @064668>): static testSqrt_f32: float32 := float32.sqrt(pi32 * pi32)
	<.main+3179 @064657> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3183 @06465b> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3187 @06465f> : 73                         mul.f32
	<.main+3188 @064660> : 01 25 00 00                nfc(37) ;float32.sqrt(x: float32): float32
	<.main+3192 @064664> : 24 90 27 06                store.m32 <@062790> ;testSqrt_f32
	cmplStd/test/std/number.ci:53: (17 bytes: <.main+3196 @064668> - <.main+3213 @064679>): static testAtan_f32: float32 := float32.atan2(pi32, 1.000000)
	<.main+3196 @064668> : 20 88 26 06                load.m32 <@062688> ;pi32
	<.main+3200 @06466c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3205 @064671> : 01 26 00 00                nfc(38) ;float32.atan2(x: float32, y: float32): float32
	<.main+3209 @064675> : 24 98 27 06                store.m32 <@062798> ;testAtan_f32
	cmplStd/test/std/number.ci:55: (12 bytes: <.main+3213 @064679> - <.main+3225 @064685>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3213 @064679> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3217 @06467d> : 01 17 00 00                nfc(23) ;uint32.pop(value: int32): int32
	<.main+3221 @064681> : 24 a0 27 06                store.m32 <@0627a0> ;testPopulation_u32
	cmplStd/test/std/number.ci:56: (12 bytes: <.main+3225 @064685> - <.main+3237 @064691>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3225 @064685> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3229 @064689> : 01 18 00 00                nfc(24) ;uint32.swap(value: int32): int32
	<.main+3233 @06468d> : 24 a8 27 06                store.m32 <@0627a8> ;testSwapBits_u32
	cmplStd/test/std/number.ci:57: (12 bytes: <.main+3237 @064691> - <.main+3249 @06469d>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3237 @064691> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3241 @064695> : 01 19 00 00                nfc(25) ;uint32.bsr(value: int32): int32
	<.main+3245 @064699> : 24 b0 27 06                store.m32 <@0627b0> ;testBitScanReverse_u32
	cmplStd/test/std/number.ci:58: (12 bytes: <.main+3249 @06469d> - <.main+3261 @0646a9>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3249 @06469d> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3253 @0646a1> : 01 1a 00 00                nfc(26) ;uint32.bsf(value: int32): int32
	<.main+3257 @0646a5> : 24 b8 27 06                store.m32 <@0627b8> ;testBitScanForward_u32
	cmplStd/test/std/number.ci:59: (12 bytes: <.main+3261 @0646a9> - <.main+3273 @0646b5>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3261 @0646a9> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3265 @0646ad> : 01 1b 00 00                nfc(27) ;uint32.hib(value: int32): int32
	<.main+3269 @0646b1> : 24 c0 27 06                store.m32 <@0627c0> ;testHighBit_u32
	cmplStd/test/std/number.ci:60: (12 bytes: <.main+3273 @0646b5> - <.main+3285 @0646c1>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3273 @0646b5> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3277 @0646b9> : 01 1c 00 00                nfc(28) ;uint32.lob(value: int32): int32
	<.main+3281 @0646bd> : 24 c8 27 06                store.m32 <@0627c8> ;testLowBit_u32
	cmplStd/test/std/number.ci:62: (18 bytes: <.main+3285 @0646c1> - <.main+3303 @0646d3>): static testZeroExtend_u32: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+3285 @0646c1> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3289 @0646c5> : 19                         load.z32
	<.main+3290 @0646c6> : 1c 05 00 00 00             load.c32 5
	<.main+3295 @0646cb> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+3299 @0646cf> : 24 d0 27 06                store.m32 <@0627d0> ;testZeroExtend_u32
	cmplStd/test/std/number.ci:63: (18 bytes: <.main+3303 @0646d3> - <.main+3321 @0646e5>): static testSignExtend_u32: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+3303 @0646d3> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3307 @0646d7> : 19                         load.z32
	<.main+3308 @0646d8> : 1c 05 00 00 00             load.c32 5
	<.main+3313 @0646dd> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+3317 @0646e1> : 24 d8 27 06                store.m32 <@0627d8> ;testSignExtend_u32
	cmplStd/test/std/number.ci:65: (20 bytes: <.main+3321 @0646e5> - <.main+3341 @0646f9>): static testZeroExtend_u64: int32 := uint64.zxt(r5g6b5, 0, 5)
	<.main+3321 @0646e5> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3325 @0646e9> : 5b                         i32.2i64
	<.main+3326 @0646ea> : 19                         load.z32
	<.main+3327 @0646eb> : 1c 05 00 00 00             load.c32 5
	<.main+3332 @0646f0> : 01 1d 00 00                nfc(29) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3336 @0646f4> : 6a                         i64.2i32
	<.main+3337 @0646f5> : 24 e0 27 06                store.m32 <@0627e0> ;testZeroExtend_u64
	cmplStd/test/std/number.ci:66: (20 bytes: <.main+3341 @0646f9> - <.main+3361 @06470d>): static testSignExtend_u64: int32 := uint64.sxt(r5g6b5, 0, 5)
	<.main+3341 @0646f9> : 20 b0 26 06                load.m32 <@0626b0> ;r5g6b5
	<.main+3345 @0646fd> : 5b                         i32.2i64
	<.main+3346 @0646fe> : 19                         load.z32
	<.main+3347 @0646ff> : 1c 05 00 00 00             load.c32 5
	<.main+3352 @064704> : 01 1e 00 00                nfc(30) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3356 @064708> : 6a                         i64.2i32
	<.main+3357 @064709> : 24 e8 27 06                store.m32 <@0627e8> ;testSignExtend_u64
	cmplStd/test/std/memory.ci:7: (18 bytes: <.main+3361 @06470d> - <.main+3379 @06471f>): static p1: pointer := malloc(1024)
	<.main+3361 @06470d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3366 @064712> : 1c 00 04 00 00             load.c32 1024
	<.main+3371 @064717> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3375 @06471b> : 24 f0 27 06                store.m32 <@0627f0> ;p1
	cmplStd/test/std/memory.ci:8: (18 bytes: <.main+3379 @06471f> - <.main+3397 @064731>): static p2: pointer := malloc(80)
	<.main+3379 @06471f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3384 @064724> : 1c 50 00 00 00             load.c32 80
	<.main+3389 @064729> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3393 @06472d> : 24 f8 27 06                store.m32 <@0627f8> ;p2
	cmplStd/test/std/memory.ci:9: (18 bytes: <.main+3397 @064731> - <.main+3415 @064743>): static p3: pointer := malloc(160)
	<.main+3397 @064731> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3402 @064736> : 1c a0 00 00 00             load.c32 160
	<.main+3407 @06473b> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3411 @06473f> : 24 00 28 06                store.m32 <@062800> ;p3
	cmplStd/test/std/memory.ci:10: (18 bytes: <.main+3415 @064743> - <.main+3433 @064755>): static p4: pointer := malloc(820)
	<.main+3415 @064743> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3420 @064748> : 1c 34 03 00 00             load.c32 820
	<.main+3425 @06474d> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3429 @064751> : 24 08 28 06                store.m32 <@062808> ;p4
	cmplStd/test/std/memory.ci:23: (13 bytes: <.main+3433 @064755> - <.main+3446 @064762>): static val1: int64 := 42
	<.main+3433 @064755> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3442 @06475e> : 23 10 28 06                store.m64 <@062810> ;val1
	cmplStd/test/std/memory.ci:24: (13 bytes: <.main+3446 @064762> - <.main+3459 @06476f>): static val2: int64 := 96
	<.main+3446 @064762> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+3455 @06476b> : 23 18 28 06                store.m64 <@062818> ;val2
	cmplStd/test/std/tryExec.ci:47: (18 bytes: <.main+3459 @06476f> - <.main+3477 @064781>): static tryExecErr0: int32 := tryExec(null, noError)
	<.main+3459 @06476f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3464 @064774> : 1f 20 28 06 00             load.ref <@062820> ;noError(ptr: pointer): void
	<.main+3469 @064779> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3473 @06477d> : 24 b0 28 06                store.m32 <@0628b0> ;tryExecErr0
	cmplStd/test/std/tryExec.ci:48: (18 bytes: <.main+3477 @064781> - <.main+3495 @064793>): static tryExecErr1: int32 := tryExec(null, null)
	<.main+3477 @064781> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3482 @064786> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3487 @06478b> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3491 @06478f> : 24 b8 28 06                store.m32 <@0628b8> ;tryExecErr1
	cmplStd/test/std/tryExec.ci:49: (18 bytes: <.main+3495 @064793> - <.main+3513 @0647a5>): static tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+3495 @064793> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3500 @064798> : 1f 28 28 06 00             load.ref <@062828> ;stackOverflow(ptr: pointer): void
	<.main+3505 @06479d> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3509 @0647a1> : 24 c0 28 06                store.m32 <@0628c0> ;tryExecErr2
	cmplStd/test/std/tryExec.ci:50: (18 bytes: <.main+3513 @0647a5> - <.main+3531 @0647b7>): static tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+3513 @0647a5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3518 @0647aa> : 1f 40 28 06 00             load.ref <@062840> ;divisionByZero(args: pointer): void
	<.main+3523 @0647af> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3527 @0647b3> : 24 c8 28 06                store.m32 <@0628c8> ;tryExecErr3
	cmplStd/test/std/tryExec.ci:51: (18 bytes: <.main+3531 @0647b7> - <.main+3549 @0647c9>): static tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+3531 @0647b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3536 @0647bc> : 1f a8 28 06 00             load.ref <@0628a8> ;invalidInstruction(args: pointer): void
	<.main+3541 @0647c1> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3545 @0647c5> : 24 d0 28 06                store.m32 <@0628d0> ;tryExecErr4
	cmplStd/test/std/tryExec.ci:52: (18 bytes: <.main+3549 @0647c9> - <.main+3567 @0647db>): static tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+3549 @0647c9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3554 @0647ce> : 1f 98 28 06 00             load.ref <@062898> ;invalidMemoryAccess(args: pointer): void
	<.main+3559 @0647d3> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3563 @0647d7> : 24 d8 28 06                store.m32 <@0628d8> ;tryExecErr5
	cmplStd/test/std/tryExec.ci:53: (18 bytes: <.main+3567 @0647db> - <.main+3585 @0647ed>): static tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+3567 @0647db> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3572 @0647e0> : 1f 50 28 06 00             load.ref <@062850> ;abortExecution(args: pointer): void
	<.main+3577 @0647e5> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3581 @0647e9> : 24 e0 28 06                store.m32 <@0628e0> ;tryExecErr6
	cmplStd/test/lang/init.reference.ci:7: (13 bytes: <.main+3585 @0647ed> - <.main+3598 @0647fa>): static value: int64 := 42
	<.main+3585 @0647ed> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3594 @0647f6> : 23 e8 28 06                store.m64 <@0628e8> ;value
	cmplStd/test/lang/init.reference.ci:8: (9 bytes: <.main+3598 @0647fa> - <.main+3607 @064803>): static valueRef: int64 := value
	<.main+3598 @0647fa> : 1f e8 28 06 00             load.ref <@0628e8> ;value
	<.main+3603 @0647ff> : 24 f0 28 06                store.m32 <@0628f0> ;valueRef
	cmplStd/test/lang/init.reference.ci:9: (9 bytes: <.main+3607 @064803> - <.main+3616 @06480c>): static valuePtr: pointer := value
	<.main+3607 @064803> : 1f e8 28 06 00             load.ref <@0628e8> ;value
	<.main+3612 @064808> : 24 f8 28 06                store.m32 <@0628f8> ;valuePtr
	cmplStd/test/lang/init.reference.ci:10: (14 bytes: <.main+3616 @06480c> - <.main+3630 @06481a>): static valueVar: variant := value
	<.main+3616 @06480c> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3621 @064811> : 1f e8 28 06 00             load.ref <@0628e8> ;value
	<.main+3626 @064816> : 23 00 29 06                store.m64 <@062900> ;valueVar
	cmplStd/test/lang/init.reference.ci:12: (9 bytes: <.main+3630 @06481a> - <.main+3639 @064823>): static fromRef: int64 := valueRef
	<.main+3630 @06481a> : 20 f0 28 06                load.m32 <@0628f0> ;valueRef
	<.main+3634 @06481e> : 29                         load.i64
	<.main+3635 @06481f> : 23 08 29 06                store.m64 <@062908> ;fromRef
	cmplStd/test/lang/init.reference.ci:13: (8 bytes: <.main+3639 @064823> - <.main+3647 @06482b>): static fromPtr: int64 := valuePtr
	<.main+3639 @064823> : 20 f8 28 06                load.m32 <@0628f8> ;valuePtr
	<.main+3643 @064827> : 24 10 29 06                store.m32 <@062910> ;fromPtr
	cmplStd/test/lang/init.reference.ci:14: (8 bytes: <.main+3647 @06482b> - <.main+3655 @064833>): static fromVar: int64 := valueVar
	<.main+3647 @06482b> : 20 00 29 06                load.m32 <@062900> ;valueVar
	<.main+3651 @06482f> : 24 18 29 06                store.m32 <@062918> ;fromVar
	cmplStd/test/lang/init.reference.ci:16: (9 bytes: <.main+3655 @064833> - <.main+3664 @06483c>): static nullRef: int64 := null
	<.main+3655 @064833> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3660 @064838> : 24 20 29 06                store.m32 <@062920> ;nullRef
	cmplStd/test/lang/init.reference.ci:17: (9 bytes: <.main+3664 @06483c> - <.main+3673 @064845>): static nullPtr: pointer := null
	<.main+3664 @06483c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3669 @064841> : 24 28 29 06                store.m32 <@062928> ;nullPtr
	cmplStd/test/lang/init.reference.ci:18: (14 bytes: <.main+3673 @064845> - <.main+3687 @064853>): static nullVar: variant := null
	<.main+3673 @064845> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3678 @06484a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3683 @06484f> : 23 30 29 06                store.m64 <@062930> ;nullVar
	cmplStd/test/lang/init.reference.ci:19: (9 bytes: <.main+3687 @064853> - <.main+3696 @06485c>): static nullTyp: typename := null
	<.main+3687 @064853> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3692 @064858> : 24 38 29 06                store.m32 <@062938> ;nullTyp
	cmplStd/test/lang/init.reference.ci:20: (9 bytes: <.main+3696 @06485c> - <.main+3705 @064865>): static nullFun: function := null
	<.main+3696 @06485c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3701 @064861> : 24 40 29 06                store.m32 <@062940> ;nullFun
	cmplStd/test/lang/init.reference.ci:21: (9 bytes: <.main+3705 @064865> - <.main+3714 @06486e>): static nullObj: object := null
	<.main+3705 @064865> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3710 @06486a> : 24 48 29 06                store.m32 <@062948> ;nullObj
	cmplStd/test/lang/init.reference.ci:23: (9 bytes: <.main+3714 @06486e> - <.main+3723 @064877>): static typePtr: pointer := int64
	<.main+3714 @06486e> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3719 @064873> : 24 50 29 06                store.m32 <@062950> ;typePtr
	cmplStd/test/lang/init.reference.ci:24: (14 bytes: <.main+3723 @064877> - <.main+3737 @064885>): static typeVar: variant := int64
	<.main+3723 @064877> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3728 @06487c> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3733 @064881> : 23 58 29 06                store.m64 <@062958> ;typeVar
	cmplStd/test/lang/init.reference.ci:25: (9 bytes: <.main+3737 @064885> - <.main+3746 @06488e>): static typeTyp: typename := int64
	<.main+3737 @064885> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3742 @06488a> : 24 60 29 06                store.m32 <@062960> ;typeTyp
	cmplStd/test/lang/init.reference.ci:27: (8 bytes: <.main+3746 @06488e> - <.main+3754 @064896>): static local: int64 := value
	<.main+3746 @06488e> : 21 e8 28 06                load.m64 <@0628e8> ;value
	<.main+3750 @064892> : 23 68 29 06                store.m64 <@062968> ;local
	cmplStd/test/lang/init.reference.ci:28: (8 bytes: <.main+3754 @064896> - <.main+3762 @06489e>): static copyVal: int64 := local
	<.main+3754 @064896> : 21 68 29 06                load.m64 <@062968> ;local
	<.main+3758 @06489a> : 23 70 29 06                store.m64 <@062970> ;copyVal
	cmplStd/test/lang/init.reference.ci:29: (8 bytes: <.main+3762 @06489e> - <.main+3770 @0648a6>): static copyRef: int64 := valueRef
	<.main+3762 @06489e> : 20 f0 28 06                load.m32 <@0628f0> ;valueRef
	<.main+3766 @0648a2> : 24 78 29 06                store.m32 <@062978> ;copyRef
	cmplStd/test/lang/init.reference.ci:30: (8 bytes: <.main+3770 @0648a6> - <.main+3778 @0648ae>): static copyPtr: pointer := valuePtr
	<.main+3770 @0648a6> : 20 f8 28 06                load.m32 <@0628f8> ;valuePtr
	<.main+3774 @0648aa> : 24 80 29 06                store.m32 <@062980> ;copyPtr
	cmplStd/test/lang/init.reference.ci:31: (8 bytes: <.main+3778 @0648ae> - <.main+3786 @0648b6>): static copyVar: variant := valueVar
	<.main+3778 @0648ae> : 21 00 29 06                load.m64 <@062900> ;valueVar
	<.main+3782 @0648b2> : 23 88 29 06                store.m64 <@062988> ;copyVar
	cmplStd/test/lang/init.reference.ci:32: (8 bytes: <.main+3786 @0648b6> - <.main+3794 @0648be>): static copyTyp: typename := typeTyp
	<.main+3786 @0648b6> : 20 60 29 06                load.m32 <@062960> ;typeTyp
	<.main+3790 @0648ba> : 24 90 29 06                store.m32 <@062990> ;copyTyp
	cmplStd/test/lang/init.reference.ci:35: (9 bytes: <.main+3794 @0648be> - <.main+3803 @0648c7>): static ptrVoid: pointer := void
	<.main+3794 @0648be> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3799 @0648c3> : 24 98 29 06                store.m32 <@062998> ;ptrVoid
	cmplStd/test/lang/init.reference.ci:36: (9 bytes: <.main+3803 @0648c7> - <.main+3812 @0648d0>): static ptrBool: pointer := bool
	<.main+3803 @0648c7> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3808 @0648cc> : 24 a0 29 06                store.m32 <@0629a0> ;ptrBool
	cmplStd/test/lang/init.reference.ci:37: (9 bytes: <.main+3812 @0648d0> - <.main+3821 @0648d9>): static ptrChar: pointer := char
	<.main+3812 @0648d0> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3817 @0648d5> : 24 a8 29 06                store.m32 <@0629a8> ;ptrChar
	cmplStd/test/lang/init.reference.ci:38: (9 bytes: <.main+3821 @0648d9> - <.main+3830 @0648e2>): static ptrInt8: pointer := int8
	<.main+3821 @0648d9> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+3826 @0648de> : 24 b0 29 06                store.m32 <@0629b0> ;ptrInt8
	cmplStd/test/lang/init.reference.ci:39: (9 bytes: <.main+3830 @0648e2> - <.main+3839 @0648eb>): static ptrInt16: pointer := int16
	<.main+3830 @0648e2> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+3835 @0648e7> : 24 b8 29 06                store.m32 <@0629b8> ;ptrInt16
	cmplStd/test/lang/init.reference.ci:40: (9 bytes: <.main+3839 @0648eb> - <.main+3848 @0648f4>): static ptrInt32: pointer := int32
	<.main+3839 @0648eb> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+3844 @0648f0> : 24 c0 29 06                store.m32 <@0629c0> ;ptrInt32
	cmplStd/test/lang/init.reference.ci:41: (9 bytes: <.main+3848 @0648f4> - <.main+3857 @0648fd>): static ptrInt64: pointer := int64
	<.main+3848 @0648f4> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3853 @0648f9> : 24 c8 29 06                store.m32 <@0629c8> ;ptrInt64
	cmplStd/test/lang/init.reference.ci:42: (9 bytes: <.main+3857 @0648fd> - <.main+3866 @064906>): static ptrUint8: pointer := uint8
	<.main+3857 @0648fd> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+3862 @064902> : 24 d0 29 06                store.m32 <@0629d0> ;ptrUint8
	cmplStd/test/lang/init.reference.ci:43: (9 bytes: <.main+3866 @064906> - <.main+3875 @06490f>): static ptrUint16: pointer := uint16
	<.main+3866 @064906> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+3871 @06490b> : 24 d8 29 06                store.m32 <@0629d8> ;ptrUint16
	cmplStd/test/lang/init.reference.ci:44: (9 bytes: <.main+3875 @06490f> - <.main+3884 @064918>): static ptrUint32: pointer := uint32
	<.main+3875 @06490f> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+3880 @064914> : 24 e0 29 06                store.m32 <@0629e0> ;ptrUint32
	cmplStd/test/lang/init.reference.ci:45: (9 bytes: <.main+3884 @064918> - <.main+3893 @064921>): static ptrUint64: pointer := uint64
	<.main+3884 @064918> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+3889 @06491d> : 24 e8 29 06                store.m32 <@0629e8> ;ptrUint64
	cmplStd/test/lang/init.reference.ci:46: (9 bytes: <.main+3893 @064921> - <.main+3902 @06492a>): static ptrFloat32: pointer := float32
	<.main+3893 @064921> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+3898 @064926> : 24 f0 29 06                store.m32 <@0629f0> ;ptrFloat32
	cmplStd/test/lang/init.reference.ci:47: (9 bytes: <.main+3902 @06492a> - <.main+3911 @064933>): static ptrFloat64: pointer := float64
	<.main+3902 @06492a> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+3907 @06492f> : 24 f8 29 06                store.m32 <@0629f8> ;ptrFloat64
	cmplStd/test/lang/init.reference.ci:48: (9 bytes: <.main+3911 @064933> - <.main+3920 @06493c>): static ptrTypename: pointer := typename
	<.main+3911 @064933> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3916 @064938> : 24 00 2a 06                store.m32 <@062a00> ;ptrTypename
	cmplStd/test/lang/init.reference.ci:49: (9 bytes: <.main+3920 @06493c> - <.main+3929 @064945>): static ptrFunction: pointer := function
	<.main+3920 @06493c> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+3925 @064941> : 24 08 2a 06                store.m32 <@062a08> ;ptrFunction
	cmplStd/test/lang/init.reference.ci:50: (9 bytes: <.main+3929 @064945> - <.main+3938 @06494e>): static ptrPointer: pointer := pointer
	<.main+3929 @064945> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3934 @06494a> : 24 10 2a 06                store.m32 <@062a10> ;ptrPointer
	cmplStd/test/lang/init.reference.ci:51: (9 bytes: <.main+3938 @06494e> - <.main+3947 @064957>): static ptrVariant: pointer := variant
	<.main+3938 @06494e> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+3943 @064953> : 24 18 2a 06                store.m32 <@062a18> ;ptrVariant
	cmplStd/test/lang/init.reference.ci:52: (9 bytes: <.main+3947 @064957> - <.main+3956 @064960>): static ptrObject: pointer := object
	<.main+3947 @064957> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+3952 @06495c> : 24 20 2a 06                store.m32 <@062a20> ;ptrObject
	cmplStd/test/lang/init.reference.ci:55: (14 bytes: <.main+3956 @064960> - <.main+3970 @06496e>): static varVoid: variant := void
	<.main+3956 @064960> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3961 @064965> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3966 @06496a> : 23 28 2a 06                store.m64 <@062a28> ;varVoid
	cmplStd/test/lang/init.reference.ci:56: (14 bytes: <.main+3970 @06496e> - <.main+3984 @06497c>): static varBool: variant := bool
	<.main+3970 @06496e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3975 @064973> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3980 @064978> : 23 30 2a 06                store.m64 <@062a30> ;varBool
	cmplStd/test/lang/init.reference.ci:57: (14 bytes: <.main+3984 @06497c> - <.main+3998 @06498a>): static varChar: variant := char
	<.main+3984 @06497c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3989 @064981> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3994 @064986> : 23 38 2a 06                store.m64 <@062a38> ;varChar
	cmplStd/test/lang/init.reference.ci:58: (14 bytes: <.main+3998 @06498a> - <.main+4012 @064998>): static varInt8: variant := int8
	<.main+3998 @06498a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4003 @06498f> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4008 @064994> : 23 40 2a 06                store.m64 <@062a40> ;varInt8
	cmplStd/test/lang/init.reference.ci:59: (14 bytes: <.main+4012 @064998> - <.main+4026 @0649a6>): static varInt16: variant := int16
	<.main+4012 @064998> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4017 @06499d> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4022 @0649a2> : 23 48 2a 06                store.m64 <@062a48> ;varInt16
	cmplStd/test/lang/init.reference.ci:60: (14 bytes: <.main+4026 @0649a6> - <.main+4040 @0649b4>): static varInt32: variant := int32
	<.main+4026 @0649a6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4031 @0649ab> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4036 @0649b0> : 23 50 2a 06                store.m64 <@062a50> ;varInt32
	cmplStd/test/lang/init.reference.ci:61: (14 bytes: <.main+4040 @0649b4> - <.main+4054 @0649c2>): static varInt64: variant := int64
	<.main+4040 @0649b4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4045 @0649b9> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4050 @0649be> : 23 58 2a 06                store.m64 <@062a58> ;varInt64
	cmplStd/test/lang/init.reference.ci:62: (14 bytes: <.main+4054 @0649c2> - <.main+4068 @0649d0>): static varUint8: variant := uint8
	<.main+4054 @0649c2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4059 @0649c7> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4064 @0649cc> : 23 60 2a 06                store.m64 <@062a60> ;varUint8
	cmplStd/test/lang/init.reference.ci:63: (14 bytes: <.main+4068 @0649d0> - <.main+4082 @0649de>): static varUint16: variant := uint16
	<.main+4068 @0649d0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4073 @0649d5> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4078 @0649da> : 23 68 2a 06                store.m64 <@062a68> ;varUint16
	cmplStd/test/lang/init.reference.ci:64: (14 bytes: <.main+4082 @0649de> - <.main+4096 @0649ec>): static varUint32: variant := uint32
	<.main+4082 @0649de> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4087 @0649e3> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4092 @0649e8> : 23 70 2a 06                store.m64 <@062a70> ;varUint32
	cmplStd/test/lang/init.reference.ci:65: (14 bytes: <.main+4096 @0649ec> - <.main+4110 @0649fa>): static varUint64: variant := uint64
	<.main+4096 @0649ec> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4101 @0649f1> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4106 @0649f6> : 23 78 2a 06                store.m64 <@062a78> ;varUint64
	cmplStd/test/lang/init.reference.ci:66: (14 bytes: <.main+4110 @0649fa> - <.main+4124 @064a08>): static varFloat32: variant := float32
	<.main+4110 @0649fa> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4115 @0649ff> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4120 @064a04> : 23 80 2a 06                store.m64 <@062a80> ;varFloat32
	cmplStd/test/lang/init.reference.ci:67: (14 bytes: <.main+4124 @064a08> - <.main+4138 @064a16>): static varFloat64: variant := float64
	<.main+4124 @064a08> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4129 @064a0d> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4134 @064a12> : 23 88 2a 06                store.m64 <@062a88> ;varFloat64
	cmplStd/test/lang/init.reference.ci:68: (14 bytes: <.main+4138 @064a16> - <.main+4152 @064a24>): static varTypename: variant := typename
	<.main+4138 @064a16> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4143 @064a1b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4148 @064a20> : 23 90 2a 06                store.m64 <@062a90> ;varTypename
	cmplStd/test/lang/init.reference.ci:69: (14 bytes: <.main+4152 @064a24> - <.main+4166 @064a32>): static varFunction: variant := function
	<.main+4152 @064a24> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4157 @064a29> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4162 @064a2e> : 23 98 2a 06                store.m64 <@062a98> ;varFunction
	cmplStd/test/lang/init.reference.ci:70: (14 bytes: <.main+4166 @064a32> - <.main+4180 @064a40>): static varPointer: variant := pointer
	<.main+4166 @064a32> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4171 @064a37> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4176 @064a3c> : 23 a0 2a 06                store.m64 <@062aa0> ;varPointer
	cmplStd/test/lang/init.reference.ci:71: (14 bytes: <.main+4180 @064a40> - <.main+4194 @064a4e>): static varVariant: variant := variant
	<.main+4180 @064a40> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4185 @064a45> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4190 @064a4a> : 23 a8 2a 06                store.m64 <@062aa8> ;varVariant
	cmplStd/test/lang/init.reference.ci:72: (14 bytes: <.main+4194 @064a4e> - <.main+4208 @064a5c>): static varObject: variant := object
	<.main+4194 @064a4e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4199 @064a53> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4204 @064a58> : 23 b0 2a 06                store.m64 <@062ab0> ;varObject
	cmplStd/test/lang/init.reference.ci:75: (9 bytes: <.main+4208 @064a5c> - <.main+4217 @064a65>): static typVoid: typename := void
	<.main+4208 @064a5c> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4213 @064a61> : 24 b8 2a 06                store.m32 <@062ab8> ;typVoid
	cmplStd/test/lang/init.reference.ci:76: (9 bytes: <.main+4217 @064a65> - <.main+4226 @064a6e>): static typBool: typename := bool
	<.main+4217 @064a65> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4222 @064a6a> : 24 c0 2a 06                store.m32 <@062ac0> ;typBool
	cmplStd/test/lang/init.reference.ci:77: (9 bytes: <.main+4226 @064a6e> - <.main+4235 @064a77>): static typChar: typename := char
	<.main+4226 @064a6e> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4231 @064a73> : 24 c8 2a 06                store.m32 <@062ac8> ;typChar
	cmplStd/test/lang/init.reference.ci:78: (9 bytes: <.main+4235 @064a77> - <.main+4244 @064a80>): static typInt8: typename := int8
	<.main+4235 @064a77> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4240 @064a7c> : 24 d0 2a 06                store.m32 <@062ad0> ;typInt8
	cmplStd/test/lang/init.reference.ci:79: (9 bytes: <.main+4244 @064a80> - <.main+4253 @064a89>): static typInt16: typename := int16
	<.main+4244 @064a80> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4249 @064a85> : 24 d8 2a 06                store.m32 <@062ad8> ;typInt16
	cmplStd/test/lang/init.reference.ci:80: (9 bytes: <.main+4253 @064a89> - <.main+4262 @064a92>): static typInt32: typename := int32
	<.main+4253 @064a89> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4258 @064a8e> : 24 e0 2a 06                store.m32 <@062ae0> ;typInt32
	cmplStd/test/lang/init.reference.ci:81: (9 bytes: <.main+4262 @064a92> - <.main+4271 @064a9b>): static typInt64: typename := int64
	<.main+4262 @064a92> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4267 @064a97> : 24 e8 2a 06                store.m32 <@062ae8> ;typInt64
	cmplStd/test/lang/init.reference.ci:82: (9 bytes: <.main+4271 @064a9b> - <.main+4280 @064aa4>): static typUint8: typename := uint8
	<.main+4271 @064a9b> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4276 @064aa0> : 24 f0 2a 06                store.m32 <@062af0> ;typUint8
	cmplStd/test/lang/init.reference.ci:83: (9 bytes: <.main+4280 @064aa4> - <.main+4289 @064aad>): static typUint16: typename := uint16
	<.main+4280 @064aa4> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4285 @064aa9> : 24 f8 2a 06                store.m32 <@062af8> ;typUint16
	cmplStd/test/lang/init.reference.ci:84: (9 bytes: <.main+4289 @064aad> - <.main+4298 @064ab6>): static typUint32: typename := uint32
	<.main+4289 @064aad> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4294 @064ab2> : 24 00 2b 06                store.m32 <@062b00> ;typUint32
	cmplStd/test/lang/init.reference.ci:85: (9 bytes: <.main+4298 @064ab6> - <.main+4307 @064abf>): static typUint64: typename := uint64
	<.main+4298 @064ab6> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4303 @064abb> : 24 08 2b 06                store.m32 <@062b08> ;typUint64
	cmplStd/test/lang/init.reference.ci:86: (9 bytes: <.main+4307 @064abf> - <.main+4316 @064ac8>): static typFloat32: typename := float32
	<.main+4307 @064abf> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4312 @064ac4> : 24 10 2b 06                store.m32 <@062b10> ;typFloat32
	cmplStd/test/lang/init.reference.ci:87: (9 bytes: <.main+4316 @064ac8> - <.main+4325 @064ad1>): static typFloat64: typename := float64
	<.main+4316 @064ac8> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4321 @064acd> : 24 18 2b 06                store.m32 <@062b18> ;typFloat64
	cmplStd/test/lang/init.reference.ci:88: (9 bytes: <.main+4325 @064ad1> - <.main+4334 @064ada>): static typTypename: typename := typename
	<.main+4325 @064ad1> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4330 @064ad6> : 24 20 2b 06                store.m32 <@062b20> ;typTypename
	cmplStd/test/lang/init.reference.ci:89: (9 bytes: <.main+4334 @064ada> - <.main+4343 @064ae3>): static typFunction: typename := function
	<.main+4334 @064ada> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4339 @064adf> : 24 28 2b 06                store.m32 <@062b28> ;typFunction
	cmplStd/test/lang/init.reference.ci:90: (9 bytes: <.main+4343 @064ae3> - <.main+4352 @064aec>): static typPointer: typename := pointer
	<.main+4343 @064ae3> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4348 @064ae8> : 24 30 2b 06                store.m32 <@062b30> ;typPointer
	cmplStd/test/lang/init.reference.ci:91: (9 bytes: <.main+4352 @064aec> - <.main+4361 @064af5>): static typVariant: typename := variant
	<.main+4352 @064aec> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4357 @064af1> : 24 38 2b 06                store.m32 <@062b38> ;typVariant
	cmplStd/test/lang/init.reference.ci:92: (9 bytes: <.main+4361 @064af5> - <.main+4370 @064afe>): static typObject: typename := object
	<.main+4361 @064af5> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4366 @064afa> : 24 40 2b 06                store.m32 <@062b40> ;typObject
	cmplStd/test/lang/init.reference.ci:95: (9 bytes: <.main+4370 @064afe> - <.main+4379 @064b07>): static valueOfPtr: pointer := pointer(value)
	<.main+4370 @064afe> : 1f e8 28 06 00             load.ref <@0628e8> ;value
	<.main+4375 @064b03> : 24 48 2b 06                store.m32 <@062b48> ;valueOfPtr
	cmplStd/test/lang/init.reference.ci:96: (14 bytes: <.main+4379 @064b07> - <.main+4393 @064b15>): static valueOfVar: variant := variant(value)
	<.main+4379 @064b07> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4384 @064b0c> : 1f e8 28 06 00             load.ref <@0628e8> ;value
	<.main+4389 @064b11> : 23 50 2b 06                store.m64 <@062b50> ;valueOfVar
	cmplStd/test/lang/init.reference.ci:97: (9 bytes: <.main+4393 @064b15> - <.main+4402 @064b1e>): static valueOfTyp: typename := typename(value)
	<.main+4393 @064b15> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4398 @064b1a> : 24 58 2b 06                store.m32 <@062b58> ;valueOfTyp
	cmplStd/test/lang/init.reference.ci:99: (9 bytes: <.main+4402 @064b1e> - <.main+4411 @064b27>): static typeOfValue: typename := typename(value)
	<.main+4402 @064b1e> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4407 @064b23> : 24 60 2b 06                store.m32 <@062b60> ;typeOfValue
	cmplStd/test/lang/init.reference.ci:105: (13 bytes: <.main+4411 @064b27> - <.main+4424 @064b34>): static copyPtrFloat64: variant := ptrFloat64
	<.main+4411 @064b27> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4416 @064b2c> : 20 f8 29 06                load.m32 <@0629f8> ;ptrFloat64
	<.main+4420 @064b30> : 23 68 2b 06                store.m64 <@062b68> ;copyPtrFloat64
	cmplStd/test/lang/init.reference.ci:108: (8 bytes: <.main+4424 @064b34> - <.main+4432 @064b3c>): static copyVarFloat64: pointer := varFloat64
	<.main+4424 @064b34> : 20 88 2a 06                load.m32 <@062a88> ;varFloat64
	<.main+4428 @064b38> : 24 70 2b 06                store.m32 <@062b70> ;copyVarFloat64
	cmplStd/test/lang/init.variable.ci:3: (5 bytes: <.main+4432 @064b3c> - <.main+4437 @064b41>): static variable: int32
	<.main+4432 @064b3c> : 19                         load.z32
	<.main+4433 @064b3d> : 24 78 2b 06                store.m32 <@062b78> ;variable
	cmplStd/test/lang/init.variable.ci:7: (9 bytes: <.main+4437 @064b41> - <.main+4446 @064b4a>): static const constant: int32 := 42
	<.main+4437 @064b41> : 1c 2a 00 00 00             load.c32 42
	<.main+4442 @064b46> : 24 80 2b 06                store.m32 <@062b80> ;constant
	cmplStd/test/lang/init.variable.ci:24: (18 bytes: <.main+4446 @064b4a> - <.main+4464 @064b5c>): static valInitImplicit: ComplexVal := {...}
	cmplStd/test/lang/init.variable.ci:24: (13 bytes: <.main+4446 @064b4a> - <.main+4459 @064b57>): valInitImplicit.re := (8);
	<.main+4446 @064b4a> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4455 @064b53> : 23 88 2b 06                store.m64 <@062b88> ;valInitImplicit
	:: (5 bytes: <.main+4459 @064b57> - <.main+4464 @064b5c>): valInitImplicit.im := (0);
	<.main+4459 @064b57> : 1a                         load.z64
	<.main+4460 @064b58> : 23 90 2b 06                store.m64 <@062b90> ;valInitImplicit+8
	cmplStd/test/lang/init.variable.ci:33: (41 bytes: <.main+4464 @064b5c> - <.main+4505 @064b85>): static objInitImplicit: ComplexObj := {...}
	cmplStd/test/lang/init.variable.ci:33: (13 bytes: <.main+4464 @064b5c> - <.main+4477 @064b69>): objInitImplicit := create(ComplexObj);
	<.main+4464 @064b5c> : 1f e0 8f 04 00             load.ref <@048fe0> ;ComplexObj
	<.main+4469 @064b61> : 01 06 00 00                nfc(6) ;object.create(type: typename): pointer
	<.main+4473 @064b65> : 24 98 2b 06                store.m32 <@062b98> ;objInitImplicit
	cmplStd/test/lang/init.variable.ci:33: (18 bytes: <.main+4477 @064b69> - <.main+4495 @064b7b>): objInitImplicit.re := (8);
	<.main+4477 @064b69> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4486 @064b72> : 20 98 2b 06                load.m32 <@062b98> ;objInitImplicit
	<.main+4490 @064b76> : 0c 04 00 00                inc.i32(+4)
	<.main+4494 @064b7a> : 2e                         store.i64
	:: (10 bytes: <.main+4495 @064b7b> - <.main+4505 @064b85>): objInitImplicit.im := (0);
	<.main+4495 @064b7b> : 1a                         load.z64
	<.main+4496 @064b7c> : 20 98 2b 06                load.m32 <@062b98> ;objInitImplicit
	<.main+4500 @064b80> : 0c 0c 00 00                inc.i32(+12)
	<.main+4504 @064b84> : 2e                         store.i64
	cmplStd/test/lang/init.variable.ci:41: (41 bytes: <.main+4505 @064b85> - <.main+4546 @064bae>): static objInitExplicit: object := {...}
	cmplStd/test/lang/init.variable.ci:41: (13 bytes: <.main+4505 @064b85> - <.main+4518 @064b92>): objInitExplicit := create(ComplexObj);
	<.main+4505 @064b85> : 1f e0 8f 04 00             load.ref <@048fe0> ;ComplexObj
	<.main+4510 @064b8a> : 01 06 00 00                nfc(6) ;object.create(type: typename): pointer
	<.main+4514 @064b8e> : 24 a0 2b 06                store.m32 <@062ba0> ;objInitExplicit
	cmplStd/test/lang/init.variable.ci:41: (18 bytes: <.main+4518 @064b92> - <.main+4536 @064ba4>): objInitExplicit.re := (8);
	<.main+4518 @064b92> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4527 @064b9b> : 20 a0 2b 06                load.m32 <@062ba0> ;objInitExplicit
	<.main+4531 @064b9f> : 0c 04 00 00                inc.i32(+4)
	<.main+4535 @064ba3> : 2e                         store.i64
	:: (10 bytes: <.main+4536 @064ba4> - <.main+4546 @064bae>): objInitExplicit.im := (0);
	<.main+4536 @064ba4> : 1a                         load.z64
	<.main+4537 @064ba5> : 20 a0 2b 06                load.m32 <@062ba0> ;objInitExplicit
	<.main+4541 @064ba9> : 0c 0c 00 00                inc.i32(+12)
	<.main+4545 @064bad> : 2e                         store.i64
	cmplStd/test/lang/function.ci:12: (25 bytes: <.main+4546 @064bae> - <.main+4571 @064bc7>): static funAddResult: int32 := funAdd(2, 7)
	<.main+4546 @064bae> : 19                         load.z32
	<.main+4547 @064baf> : 1c 02 00 00 00             load.c32 2
	<.main+4552 @064bb4> : 1c 07 00 00 00             load.c32 7
	<.main+4557 @064bb9> : 1f b0 2b 06 00             load.ref <@062bb0> ;funAdd(x: int32, y: int32): int32
	<.main+4562 @064bbe> : 02                         call
	<.main+4563 @064bbf> : 09 f8 ff ff                inc.sp(-8)
	<.main+4567 @064bc3> : 24 b8 2b 06                store.m32 <@062bb8> ;funAddResult
	cmplStd/test/lang/function.ci:15: (9 bytes: <.main+4571 @064bc7> - <.main+4580 @064bd0>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+4571 @064bc7> : 1f b0 2b 06 00             load.ref <@062bb0> ;funAdd(x: int32, y: int32): int32
	<.main+4576 @064bcc> : 24 c0 2b 06                store.m32 <@062bc0> ;funAddRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:18: (24 bytes: <.main+4580 @064bd0> - <.main+4604 @064be8>): static funAddRefResult: int32 := funAddRef(2, 8)
	<.main+4580 @064bd0> : 19                         load.z32
	<.main+4581 @064bd1> : 1c 02 00 00 00             load.c32 2
	<.main+4586 @064bd6> : 1c 08 00 00 00             load.c32 8
	<.main+4591 @064bdb> : 20 c0 2b 06                load.m32 <@062bc0> ;funAddRef(x: int32, y: int32): int32
	<.main+4595 @064bdf> : 02                         call
	<.main+4596 @064be0> : 09 f8 ff ff                inc.sp(-8)
	<.main+4600 @064be4> : 24 c8 2b 06                store.m32 <@062bc8> ;funAddRefResult
	cmplStd/test/lang/function.ci:21: (9 bytes: <.main+4604 @064be8> - <.main+4613 @064bf1>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+4604 @064be8> : 1f f0 2b 06 00             load.ref <@062bf0> ;funMul(x: int32, y: int32): int32
	<.main+4609 @064bed> : 24 d0 2b 06                store.m32 <@062bd0> ;funMul(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:24: (24 bytes: <.main+4613 @064bf1> - <.main+4637 @064c09>): static funMulResult: int32 := funMul(2, 6)
	<.main+4613 @064bf1> : 19                         load.z32
	<.main+4614 @064bf2> : 1c 02 00 00 00             load.c32 2
	<.main+4619 @064bf7> : 1c 06 00 00 00             load.c32 6
	<.main+4624 @064bfc> : 20 d0 2b 06                load.m32 <@062bd0> ;funMul(x: int32, y: int32): int32
	<.main+4628 @064c00> : 02                         call
	<.main+4629 @064c01> : 09 f8 ff ff                inc.sp(-8)
	<.main+4633 @064c05> : 24 d8 2b 06                store.m32 <@062bd8> ;funMulResult
	cmplStd/test/lang/function.ci:27: (8 bytes: <.main+4637 @064c09> - <.main+4645 @064c11>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+4637 @064c09> : 20 d0 2b 06                load.m32 <@062bd0> ;funMul(x: int32, y: int32): int32
	<.main+4641 @064c0d> : 24 e0 2b 06                store.m32 <@062be0> ;funMulRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:30: (24 bytes: <.main+4645 @064c11> - <.main+4669 @064c29>): static funMulRefResult: int32 := funMulRef(2, 7)
	<.main+4645 @064c11> : 19                         load.z32
	<.main+4646 @064c12> : 1c 02 00 00 00             load.c32 2
	<.main+4651 @064c17> : 1c 07 00 00 00             load.c32 7
	<.main+4656 @064c1c> : 20 e0 2b 06                load.m32 <@062be0> ;funMulRef(x: int32, y: int32): int32
	<.main+4660 @064c20> : 02                         call
	<.main+4661 @064c21> : 09 f8 ff ff                inc.sp(-8)
	<.main+4665 @064c25> : 24 e8 2b 06                store.m32 <@062be8> ;funMulRefResult
	cmplStd/test/lang/function.ci:46: (20 bytes: <.main+4669 @064c29> - <.main+4689 @064c3d>): static fibonacci_13: uint32 := fib(13)
	<.main+4669 @064c29> : 19                         load.z32
	<.main+4670 @064c2a> : 1c 0d 00 00 00             load.c32 13
	<.main+4675 @064c2f> : 1f f8 2b 06 00             load.ref <@062bf8> ;fib(n: uint32): uint32
	<.main+4680 @064c34> : 02                         call
	<.main+4681 @064c35> : 09 fc ff ff                inc.sp(-4)
	<.main+4685 @064c39> : 24 30 2c 06                store.m32 <@062c30> ;fibonacci_13
	cmplStd/test/lang/reflect.ci:3: (8 bytes: <.main+4689 @064c3d> - <.main+4697 @064c45>): static sizeofVoid: int32 := sizeof(void)
	<.main+4689 @064c3d> : 20 d8 00 00                load.m32 <@0000d8> ;void+32
	<.main+4693 @064c41> : 24 38 2c 06                store.m32 <@062c38> ;sizeofVoid
	cmplStd/test/lang/reflect.ci:4: (8 bytes: <.main+4697 @064c45> - <.main+4705 @064c4d>): static sizeofBool: int32 := sizeof(bool)
	<.main+4697 @064c45> : 20 80 01 00                load.m32 <@000180> ;bool+32
	<.main+4701 @064c49> : 24 40 2c 06                store.m32 <@062c40> ;sizeofBool
	cmplStd/test/lang/reflect.ci:5: (8 bytes: <.main+4705 @064c4d> - <.main+4713 @064c55>): static sizeofChar: int32 := sizeof(char)
	<.main+4705 @064c4d> : 20 28 02 00                load.m32 <@000228> ;char+32
	<.main+4709 @064c51> : 24 48 2c 06                store.m32 <@062c48> ;sizeofChar
	cmplStd/test/lang/reflect.ci:6: (8 bytes: <.main+4713 @064c55> - <.main+4721 @064c5d>): static sizeofInt8: int32 := sizeof(int8)
	<.main+4713 @064c55> : 20 d0 02 00                load.m32 <@0002d0> ;int8+32
	<.main+4717 @064c59> : 24 50 2c 06                store.m32 <@062c50> ;sizeofInt8
	cmplStd/test/lang/reflect.ci:7: (8 bytes: <.main+4721 @064c5d> - <.main+4729 @064c65>): static sizeofInt16: int32 := sizeof(int16)
	<.main+4721 @064c5d> : 20 78 03 00                load.m32 <@000378> ;int16+32
	<.main+4725 @064c61> : 24 58 2c 06                store.m32 <@062c58> ;sizeofInt16
	cmplStd/test/lang/reflect.ci:8: (8 bytes: <.main+4729 @064c65> - <.main+4737 @064c6d>): static sizeofInt32: int32 := sizeof(int32)
	<.main+4729 @064c65> : 20 20 04 00                load.m32 <@000420> ;int32+32
	<.main+4733 @064c69> : 24 60 2c 06                store.m32 <@062c60> ;sizeofInt32
	cmplStd/test/lang/reflect.ci:9: (8 bytes: <.main+4737 @064c6d> - <.main+4745 @064c75>): static sizeofInt64: int32 := sizeof(int64)
	<.main+4737 @064c6d> : 20 c8 04 00                load.m32 <@0004c8> ;int64+32
	<.main+4741 @064c71> : 24 68 2c 06                store.m32 <@062c68> ;sizeofInt64
	cmplStd/test/lang/reflect.ci:10: (8 bytes: <.main+4745 @064c75> - <.main+4753 @064c7d>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+4745 @064c75> : 20 70 05 00                load.m32 <@000570> ;uint8+32
	<.main+4749 @064c79> : 24 70 2c 06                store.m32 <@062c70> ;sizeofUint8
	cmplStd/test/lang/reflect.ci:11: (8 bytes: <.main+4753 @064c7d> - <.main+4761 @064c85>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+4753 @064c7d> : 20 18 06 00                load.m32 <@000618> ;uint16+32
	<.main+4757 @064c81> : 24 78 2c 06                store.m32 <@062c78> ;sizeofUint16
	cmplStd/test/lang/reflect.ci:12: (8 bytes: <.main+4761 @064c85> - <.main+4769 @064c8d>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+4761 @064c85> : 20 c0 06 00                load.m32 <@0006c0> ;uint32+32
	<.main+4765 @064c89> : 24 80 2c 06                store.m32 <@062c80> ;sizeofUint32
	cmplStd/test/lang/reflect.ci:13: (8 bytes: <.main+4769 @064c8d> - <.main+4777 @064c95>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+4769 @064c8d> : 20 68 07 00                load.m32 <@000768> ;uint64+32
	<.main+4773 @064c91> : 24 88 2c 06                store.m32 <@062c88> ;sizeofUint64
	cmplStd/test/lang/reflect.ci:14: (8 bytes: <.main+4777 @064c95> - <.main+4785 @064c9d>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+4777 @064c95> : 20 10 08 00                load.m32 <@000810> ;float32+32
	<.main+4781 @064c99> : 24 90 2c 06                store.m32 <@062c90> ;sizeofFloat32
	cmplStd/test/lang/reflect.ci:15: (8 bytes: <.main+4785 @064c9d> - <.main+4793 @064ca5>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+4785 @064c9d> : 20 b8 08 00                load.m32 <@0008b8> ;float64+32
	<.main+4789 @064ca1> : 24 98 2c 06                store.m32 <@062c98> ;sizeofFloat64
	cmplStd/test/lang/reflect.ci:16: (8 bytes: <.main+4793 @064ca5> - <.main+4801 @064cad>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+4793 @064ca5> : 20 60 09 00                load.m32 <@000960> ;pointer+32
	<.main+4797 @064ca9> : 24 a0 2c 06                store.m32 <@062ca0> ;sizeofPointer
	cmplStd/test/lang/reflect.ci:17: (8 bytes: <.main+4801 @064cad> - <.main+4809 @064cb5>): static sizeofVariant: int32 := sizeof(variant)
	<.main+4801 @064cad> : 20 08 0a 00                load.m32 <@000a08> ;variant+32
	<.main+4805 @064cb1> : 24 a8 2c 06                store.m32 <@062ca8> ;sizeofVariant
	cmplStd/test/lang/reflect.ci:18: (8 bytes: <.main+4809 @064cb5> - <.main+4817 @064cbd>): static sizeofTypename: int32 := sizeof(typename)
	<.main+4809 @064cb5> : 20 28 00 00                load.m32 <@000028> ;typename+32
	<.main+4813 @064cb9> : 24 b0 2c 06                store.m32 <@062cb0> ;sizeofTypename
	cmplStd/test/lang/reflect.ci:19: (8 bytes: <.main+4817 @064cbd> - <.main+4825 @064cc5>): static sizeofFunction: int32 := sizeof(function)
	<.main+4817 @064cbd> : 20 b0 0a 00                load.m32 <@000ab0> ;function+32
	<.main+4821 @064cc1> : 24 b8 2c 06                store.m32 <@062cb8> ;sizeofFunction
	cmplStd/test/lang/reflect.ci:20: (8 bytes: <.main+4825 @064cc5> - <.main+4833 @064ccd>): static sizeofObject: int32 := sizeof(object)
	<.main+4825 @064cc5> : 20 60 0b 00                load.m32 <@000b60> ;object+32
	<.main+4829 @064cc9> : 24 c0 2c 06                store.m32 <@062cc0> ;sizeofObject
	cmplStd/test/lang/reflect.ci:30: (9 bytes: <.main+4833 @064ccd> - <.main+4842 @064cd6>): static typeofRecord: typename := RecordSizeofExt
	<.main+4833 @064ccd> : 1f f0 b6 04 00             load.ref <@04b6f0> ;RecordSizeofExt
	<.main+4838 @064cd2> : 24 c8 2c 06                store.m32 <@062cc8> ;typeofRecord
	cmplStd/test/lang/reflect.ci:31: (12 bytes: <.main+4842 @064cd6> - <.main+4854 @064ce2>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+4842 @064cd6> : 20 c8 2c 06                load.m32 <@062cc8> ;typeofRecord
	<.main+4846 @064cda> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4850 @064cde> : 24 d0 2c 06                store.m32 <@062cd0> ;nameOfRecord
	cmplStd/test/lang/reflect.ci:32: (13 bytes: <.main+4854 @064ce2> - <.main+4867 @064cef>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+4854 @064ce2> : 20 c8 2c 06                load.m32 <@062cc8> ;typeofRecord
	<.main+4858 @064ce6> : 0c 28 00 00                inc.i32(+40)
	<.main+4862 @064cea> : 28                         load.i32
	<.main+4863 @064ceb> : 24 d8 2c 06                store.m32 <@062cd8> ;offsetOfRecord
	cmplStd/test/lang/reflect.ci:33: (13 bytes: <.main+4867 @064cef> - <.main+4880 @064cfc>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+4867 @064cef> : 20 c8 2c 06                load.m32 <@062cc8> ;typeofRecord
	<.main+4871 @064cf3> : 0c 20 00 00                inc.i32(+32)
	<.main+4875 @064cf7> : 28                         load.i32
	<.main+4876 @064cf8> : 24 e0 2c 06                store.m32 <@062ce0> ;sizeOfRecord
	cmplStd/test/lang/reflect.ci:34: (12 bytes: <.main+4880 @064cfc> - <.main+4892 @064d08>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+4880 @064cfc> : 20 c8 2c 06                load.m32 <@062cc8> ;typeofRecord
	<.main+4884 @064d00> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4888 @064d04> : 24 e8 2c 06                store.m32 <@062ce8> ;fileOfRecord
	cmplStd/test/lang/reflect.ci:35: (12 bytes: <.main+4892 @064d08> - <.main+4904 @064d14>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+4892 @064d08> : 20 c8 2c 06                load.m32 <@062cc8> ;typeofRecord
	<.main+4896 @064d0c> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4900 @064d10> : 24 f0 2c 06                store.m32 <@062cf0> ;lineOfRecord
	cmplStd/test/lang/reflect.ci:37: (12 bytes: <.main+4904 @064d14> - <.main+4916 @064d20>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+4904 @064d14> : 20 c8 2c 06                load.m32 <@062cc8> ;typeofRecord
	<.main+4908 @064d18> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+4912 @064d1c> : 24 f8 2c 06                store.m32 <@062cf8> ;typeofBase
	cmplStd/test/lang/reflect.ci:38: (12 bytes: <.main+4916 @064d20> - <.main+4928 @064d2c>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+4916 @064d20> : 20 f8 2c 06                load.m32 <@062cf8> ;typeofBase
	<.main+4920 @064d24> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4924 @064d28> : 24 00 2d 06                store.m32 <@062d00> ;nameOfBase
	cmplStd/test/lang/reflect.ci:39: (13 bytes: <.main+4928 @064d2c> - <.main+4941 @064d39>): static offsetOfBase: int32 := typeofBase.offset
	<.main+4928 @064d2c> : 20 f8 2c 06                load.m32 <@062cf8> ;typeofBase
	<.main+4932 @064d30> : 0c 28 00 00                inc.i32(+40)
	<.main+4936 @064d34> : 28                         load.i32
	<.main+4937 @064d35> : 24 08 2d 06                store.m32 <@062d08> ;offsetOfBase
	cmplStd/test/lang/reflect.ci:40: (13 bytes: <.main+4941 @064d39> - <.main+4954 @064d46>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+4941 @064d39> : 20 f8 2c 06                load.m32 <@062cf8> ;typeofBase
	<.main+4945 @064d3d> : 0c 20 00 00                inc.i32(+32)
	<.main+4949 @064d41> : 28                         load.i32
	<.main+4950 @064d42> : 24 10 2d 06                store.m32 <@062d10> ;sizeOfBase
	cmplStd/test/lang/reflect.ci:41: (12 bytes: <.main+4954 @064d46> - <.main+4966 @064d52>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+4954 @064d46> : 20 f8 2c 06                load.m32 <@062cf8> ;typeofBase
	<.main+4958 @064d4a> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4962 @064d4e> : 24 18 2d 06                store.m32 <@062d18> ;fileOfBase
	cmplStd/test/lang/reflect.ci:42: (12 bytes: <.main+4966 @064d52> - <.main+4978 @064d5e>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+4966 @064d52> : 20 f8 2c 06                load.m32 <@062cf8> ;typeofBase
	<.main+4970 @064d56> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4974 @064d5a> : 24 20 2d 06                store.m32 <@062d20> ;lineOfBase
	cmplStd/test/lang/reflect.ci:44: (12 bytes: <.main+4978 @064d5e> - <.main+4990 @064d6a>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+4978 @064d5e> : 20 f8 2c 06                load.m32 <@062cf8> ;typeofBase
	<.main+4982 @064d62> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+4986 @064d66> : 24 28 2d 06                store.m32 <@062d28> ;typeofBase1
	cmplStd/test/lang/reflect.ci:45: (13 bytes: <.main+4990 @064d6a> - <.main+5003 @064d77>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+4990 @064d6a> : 20 28 2d 06                load.m32 <@062d28> ;typeofBase1
	<.main+4994 @064d6e> : 0c 28 00 00                inc.i32(+40)
	<.main+4998 @064d72> : 28                         load.i32
	<.main+4999 @064d73> : 24 30 2d 06                store.m32 <@062d30> ;offsetOfBase1
	cmplStd/test/lang/reflect.ci:46: (13 bytes: <.main+5003 @064d77> - <.main+5016 @064d84>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+5003 @064d77> : 20 28 2d 06                load.m32 <@062d28> ;typeofBase1
	<.main+5007 @064d7b> : 0c 20 00 00                inc.i32(+32)
	<.main+5011 @064d7f> : 28                         load.i32
	<.main+5012 @064d80> : 24 38 2d 06                store.m32 <@062d38> ;sizeOfBase1
	cmplStd/test/lang/reflect.ci:48: (12 bytes: <.main+5016 @064d84> - <.main+5028 @064d90>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+5016 @064d84> : 20 28 2d 06                load.m32 <@062d28> ;typeofBase1
	<.main+5020 @064d88> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5024 @064d8c> : 24 40 2d 06                store.m32 <@062d40> ;typeofBase2
	cmplStd/test/lang/reflect.ci:49: (13 bytes: <.main+5028 @064d90> - <.main+5041 @064d9d>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+5028 @064d90> : 20 40 2d 06                load.m32 <@062d40> ;typeofBase2
	<.main+5032 @064d94> : 0c 28 00 00                inc.i32(+40)
	<.main+5036 @064d98> : 28                         load.i32
	<.main+5037 @064d99> : 24 48 2d 06                store.m32 <@062d48> ;offsetOfBase2
	cmplStd/test/lang/reflect.ci:50: (13 bytes: <.main+5041 @064d9d> - <.main+5054 @064daa>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+5041 @064d9d> : 20 40 2d 06                load.m32 <@062d40> ;typeofBase2
	<.main+5045 @064da1> : 0c 20 00 00                inc.i32(+32)
	<.main+5049 @064da5> : 28                         load.i32
	<.main+5050 @064da6> : 24 50 2d 06                store.m32 <@062d50> ;sizeOfBase2
	cmplStd/test/lang/init.member.ci:34: (5 bytes: <.main+5054 @064daa> - <.main+5059 @064daf>): static global: int32
	<.main+5054 @064daa> : 19                         load.z32
	<.main+5055 @064dab> : 24 58 2d 06                store.m32 <@062d58> ;RecordMemberTest.global
	cmplStd/test/lang/init.member.ci:37: (9 bytes: <.main+5059 @064daf> - <.main+5068 @064db8>): static globalInit: int32 := 1
	<.main+5059 @064daf> : 1c 01 00 00 00             load.c32 1
	<.main+5064 @064db4> : 24 60 2d 06                store.m32 <@062d60> ;RecordMemberTest.globalInit
	cmplStd/test/lang/init.member.ci:40: (9 bytes: <.main+5068 @064db8> - <.main+5077 @064dc1>): static const globalConstant: int32 := 2
	<.main+5068 @064db8> : 1c 02 00 00 00             load.c32 2
	<.main+5073 @064dbd> : 24 68 2d 06                store.m32 <@062d68> ;RecordMemberTest.globalConstant
	cmplStd/test/lang/init.member.ci:43: (14 bytes: <.main+5077 @064dc1> - <.main+5091 @064dcf>): static globalRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:43: (9 bytes: <.main+5077 @064dc1> - <.main+5086 @064dca>): globalRec.constant := 4;
	<.main+5077 @064dc1> : 1c 04 00 00 00             load.c32 4
	<.main+5082 @064dc6> : 24 74 2d 06                store.m32 <@062d74> ;RecordMemberTest.globalRec+4
	:: (5 bytes: <.main+5086 @064dca> - <.main+5091 @064dcf>): globalRec.member := (0);
	<.main+5086 @064dca> : 19                         load.z32
	<.main+5087 @064dcb> : 24 70 2d 06                store.m32 <@062d70> ;RecordMemberTest.globalRec
	cmplStd/test/lang/init.member.ci:46: (18 bytes: <.main+5091 @064dcf> - <.main+5109 @064de1>): static globalRecInit: Inner := {...}
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5091 @064dcf> - <.main+5100 @064dd8>): globalRecInit.member := 4;
	<.main+5091 @064dcf> : 1c 04 00 00 00             load.c32 4
	<.main+5096 @064dd4> : 24 78 2d 06                store.m32 <@062d78> ;RecordMemberTest.globalRecInit
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5100 @064dd8> - <.main+5109 @064de1>): globalRecInit.constant := 5;
	<.main+5100 @064dd8> : 1c 05 00 00 00             load.c32 5
	<.main+5105 @064ddd> : 24 7c 2d 06                store.m32 <@062d7c> ;RecordMemberTest.globalRecInit+4
	cmplStd/test/lang/init.member.ci:49: (18 bytes: <.main+5109 @064de1> - <.main+5127 @064df3>): static const globalConstantRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5109 @064de1> - <.main+5118 @064dea>): globalConstantRec.member := 6;
	<.main+5109 @064de1> : 1c 06 00 00 00             load.c32 6
	<.main+5114 @064de6> : 24 80 2d 06                store.m32 <@062d80> ;RecordMemberTest.globalConstantRec
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5118 @064dea> - <.main+5127 @064df3>): globalConstantRec.constant := 7;
	<.main+5118 @064dea> : 1c 07 00 00 00             load.c32 7
	<.main+5123 @064def> : 24 84 2d 06                store.m32 <@062d84> ;RecordMemberTest.globalConstantRec+4
	cmplStd/test/lang/init.member.ci:52: (72 bytes: <.main+5127 @064df3> - <.main+5199 @064e3b>): static recordMemberTest: RecordMemberTest := {...}
	cmplStd/test/lang/init.member.ci:53: (9 bytes: <.main+5127 @064df3> - <.main+5136 @064dfc>): recordMemberTest.member := 10;
	<.main+5127 @064df3> : 1c 0a 00 00 00             load.c32 10
	<.main+5132 @064df8> : 24 88 2d 06                store.m32 <@062d88> ;recordMemberTest
	cmplStd/test/lang/init.member.ci:54: (9 bytes: <.main+5136 @064dfc> - <.main+5145 @064e05>): recordMemberTest.constant := 11;
	<.main+5136 @064dfc> : 1c 0b 00 00 00             load.c32 11
	<.main+5141 @064e01> : 24 8c 2d 06                store.m32 <@062d8c> ;recordMemberTest+4
	cmplStd/test/lang/init.member.ci:55: (9 bytes: <.main+5145 @064e05> - <.main+5154 @064e0e>): recordMemberTest.memberInit := 12;
	<.main+5145 @064e05> : 1c 0c 00 00 00             load.c32 12
	<.main+5150 @064e0a> : 24 90 2d 06                store.m32 <@062d90> ;recordMemberTest+8
	cmplStd/test/lang/init.member.ci:56: (9 bytes: <.main+5154 @064e0e> - <.main+5163 @064e17>): recordMemberTest.constantInit := 13;
	<.main+5154 @064e0e> : 1c 0d 00 00 00             load.c32 13
	<.main+5159 @064e13> : 24 94 2d 06                store.m32 <@062d94> ;recordMemberTest+12
	cmplStd/test/lang/init.member.ci:59: (9 bytes: <.main+5163 @064e17> - <.main+5172 @064e20>): recordMemberTest.memberRec.member := 14;
	<.main+5163 @064e17> : 1c 0e 00 00 00             load.c32 14
	<.main+5168 @064e1c> : 24 98 2d 06                store.m32 <@062d98> ;recordMemberTest+16
	cmplStd/test/lang/init.member.ci:60: (9 bytes: <.main+5172 @064e20> - <.main+5181 @064e29>): recordMemberTest.memberRec.constant := 15;
	<.main+5172 @064e20> : 1c 0f 00 00 00             load.c32 15
	<.main+5177 @064e25> : 24 9c 2d 06                store.m32 <@062d9c> ;recordMemberTest+20
	cmplStd/test/lang/init.member.ci:64: (9 bytes: <.main+5181 @064e29> - <.main+5190 @064e32>): recordMemberTest.constantRec.member := 16;
	<.main+5181 @064e29> : 1c 10 00 00 00             load.c32 16
	<.main+5186 @064e2e> : 24 a0 2d 06                store.m32 <@062da0> ;recordMemberTest+24
	cmplStd/test/lang/init.member.ci:65: (9 bytes: <.main+5190 @064e32> - <.main+5199 @064e3b>): recordMemberTest.constantRec.constant := 17;
	<.main+5190 @064e32> : 1c 11 00 00 00             load.c32 17
	<.main+5195 @064e37> : 24 a4 2d 06                store.m32 <@062da4> ;recordMemberTest+28
	cmplStd/test/lang/init.method.ci:18: (9 bytes: <.main+5199 @064e3b> - <.main+5208 @064e44>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5199 @064e3b> : 1f 00 2e 06 00             load.ref <@062e00> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5204 @064e40> : 24 d0 2d 06                store.m32 <@062dd0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	cmplStd/test/lang/init.method.ci:62: (26 bytes: <.main+5208 @064e44> - <.main+5234 @064e5e>): static recordMethodTest: RecordMethodTest := {...}
	cmplStd/test/lang/init.method.ci:64: (9 bytes: <.main+5208 @064e44> - <.main+5217 @064e4d>): recordMethodTest.abstractMethod := globalFunction;
	<.main+5208 @064e44> : 1f 28 2e 06 00             load.ref <@062e28> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5213 @064e49> : 24 50 2e 06                store.m32 <@062e50> ;recordMethodTest
	:: (8 bytes: <.main+5217 @064e4d> - <.main+5225 @064e55>): recordMethodTest.delegateMethod := forwardMethod;
	<.main+5217 @064e4d> : 20 d0 2d 06                load.m32 <@062dd0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5221 @064e51> : 24 54 2e 06                store.m32 <@062e54> ;recordMethodTest+4
	:: (9 bytes: <.main+5225 @064e55> - <.main+5234 @064e5e>): recordMethodTest.virtualMethod := virtualMethod;
	<.main+5225 @064e55> : 1f d8 2d 06 00             load.ref <@062dd8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5230 @064e5a> : 24 58 2e 06                store.m32 <@062e58> ;recordMethodTest+8
	cmplStd/test/lang/init.array.ci:11: (91 bytes: <.main+5234 @064e5e> - <.main+5325 @064eb9>): static arrFixedInit: int64[7] := {...}
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5234 @064e5e> - <.main+5247 @064e6b>): arrFixedInit[0] := (42);
	<.main+5234 @064e5e> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+5243 @064e67> : 23 e8 2e 06                store.m64 <@062ee8> ;arrFixedInit
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5247 @064e6b> - <.main+5260 @064e78>): arrFixedInit[1] := (43);
	<.main+5247 @064e6b> : 1d 2b 00 00 00 00 00 00 00 load.c64 43
	<.main+5256 @064e74> : 23 f0 2e 06                store.m64 <@062ef0> ;arrFixedInit+8
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5260 @064e78> - <.main+5273 @064e85>): arrFixedInit[2] := (44);
	<.main+5260 @064e78> : 1d 2c 00 00 00 00 00 00 00 load.c64 44
	<.main+5269 @064e81> : 23 f8 2e 06                store.m64 <@062ef8> ;arrFixedInit+16
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5273 @064e85> - <.main+5286 @064e92>): arrFixedInit[3] := (45);
	<.main+5273 @064e85> : 1d 2d 00 00 00 00 00 00 00 load.c64 45
	<.main+5282 @064e8e> : 23 00 2f 06                store.m64 <@062f00> ;arrFixedInit+24
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5286 @064e92> - <.main+5299 @064e9f>): arrFixedInit[4] := (46);
	<.main+5286 @064e92> : 1d 2e 00 00 00 00 00 00 00 load.c64 46
	<.main+5295 @064e9b> : 23 08 2f 06                store.m64 <@062f08> ;arrFixedInit+32
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5299 @064e9f> - <.main+5312 @064eac>): arrFixedInit[5] := (47);
	<.main+5299 @064e9f> : 1d 2f 00 00 00 00 00 00 00 load.c64 47
	<.main+5308 @064ea8> : 23 10 2f 06                store.m64 <@062f10> ;arrFixedInit+40
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5312 @064eac> - <.main+5325 @064eb9>): arrFixedInit[6] := (48);
	<.main+5312 @064eac> : 1d 30 00 00 00 00 00 00 00 load.c64 48
	<.main+5321 @064eb5> : 23 18 2f 06                store.m64 <@062f18> ;arrFixedInit+48
	cmplStd/test/lang/init.array.ci:18: (9 bytes: <.main+5325 @064eb9> - <.main+5334 @064ec2>): static arrArrayInitNull: int64[*] := null
	<.main+5325 @064eb9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5330 @064ebe> : 24 20 2f 06                store.m32 <@062f20> ;arrArrayInitNull
	cmplStd/test/lang/init.array.ci:19: (10 bytes: <.main+5334 @064ec2> - <.main+5344 @064ecc>): static arrSliceInitNull: int64[] := null
	<.main+5334 @064ec2> : 19                         load.z32
	<.main+5335 @064ec3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5340 @064ec8> : 23 28 2f 06                store.m64 <@062f28> ;arrSliceInitNull
	cmplStd/test/lang/init.array.ci:22: (9 bytes: <.main+5344 @064ecc> - <.main+5353 @064ed5>): static arrArrayInitFixed: int64[*] := arrFixedInit
	<.main+5344 @064ecc> : 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+5349 @064ed1> : 24 30 2f 06                store.m32 <@062f30> ;arrArrayInitFixed
	cmplStd/test/lang/init.array.ci:23: (14 bytes: <.main+5353 @064ed5> - <.main+5367 @064ee3>): static arrSliceInitFixed: int64[] := arrFixedInit
	<.main+5353 @064ed5> : 1c 07 00 00 00             load.c32 7
	<.main+5358 @064eda> : 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+5363 @064edf> : 23 38 2f 06                store.m64 <@062f38> ;arrSliceInitFixed
	cmplStd/test/lang/init.array.ci:26: (8 bytes: <.main+5367 @064ee3> - <.main+5375 @064eeb>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+5367 @064ee3> : 20 38 2f 06                load.m32 <@062f38> ;arrSliceInitFixed
	<.main+5371 @064ee7> : 24 40 2f 06                store.m32 <@062f40> ;arrArrayInitSlice
	cmplStd/test/lang/init.array.ci:27: (8 bytes: <.main+5375 @064eeb> - <.main+5383 @064ef3>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+5375 @064eeb> : 21 38 2f 06                load.m64 <@062f38> ;arrSliceInitFixed
	<.main+5379 @064eef> : 23 48 2f 06                store.m64 <@062f48> ;arrSliceInitSlice
	cmplStd/test/lang/init.array.ci:30: (8 bytes: <.main+5383 @064ef3> - <.main+5391 @064efb>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+5383 @064ef3> : 20 30 2f 06                load.m32 <@062f30> ;arrArrayInitFixed
	<.main+5387 @064ef7> : 24 50 2f 06                store.m32 <@062f50> ;arrArrayInitPtr
	cmplStd/test/lang/init.array.ci:34: (73 bytes: <.main+5391 @064efb> - <.main+5464 @064f44>): static strFixed: char[7] := {...}
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5391 @064efb> - <.main+5402 @064f06>): strFixed[0] := 's';
	<.main+5391 @064efb> : 1c 73 00 00 00             load.c32 115
	<.main+5396 @064f00> : 1f 58 2f 06 00             load.ref <@062f58> ;strFixed
	<.main+5401 @064f05> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5402 @064f06> - <.main+5413 @064f11>): strFixed[1] := 't';
	<.main+5402 @064f06> : 1c 74 00 00 00             load.c32 116
	<.main+5407 @064f0b> : 1f 59 2f 06 00             load.ref <@062f59> ;strFixed+1
	<.main+5412 @064f10> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5413 @064f11> - <.main+5424 @064f1c>): strFixed[2] := 'r';
	<.main+5413 @064f11> : 1c 72 00 00 00             load.c32 114
	<.main+5418 @064f16> : 1f 5a 2f 06 00             load.ref <@062f5a> ;strFixed+2
	<.main+5423 @064f1b> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5424 @064f1c> - <.main+5435 @064f27>): strFixed[3] := 'i';
	<.main+5424 @064f1c> : 1c 69 00 00 00             load.c32 105
	<.main+5429 @064f21> : 1f 5b 2f 06 00             load.ref <@062f5b> ;strFixed+3
	<.main+5434 @064f26> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5435 @064f27> - <.main+5446 @064f32>): strFixed[4] := 'n';
	<.main+5435 @064f27> : 1c 6e 00 00 00             load.c32 110
	<.main+5440 @064f2c> : 1f 5c 2f 06 00             load.ref <@062f5c> ;strFixed+4
	<.main+5445 @064f31> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5446 @064f32> - <.main+5457 @064f3d>): strFixed[5] := 'g';
	<.main+5446 @064f32> : 1c 67 00 00 00             load.c32 103
	<.main+5451 @064f37> : 1f 5d 2f 06 00             load.ref <@062f5d> ;strFixed+5
	<.main+5456 @064f3c> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (7 bytes: <.main+5457 @064f3d> - <.main+5464 @064f44>): strFixed[6] := (0);
	<.main+5457 @064f3d> : 19                         load.z32
	<.main+5458 @064f3e> : 1f 5e 2f 06 00             load.ref <@062f5e> ;strFixed+6
	<.main+5463 @064f43> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:37: (9 bytes: <.main+5464 @064f44> - <.main+5473 @064f4d>): static strArray: char[*] := "string"
	<.main+5464 @064f44> : 1f 6d 9b 03 00             load.ref <@039b6d> ;"string"
	<.main+5469 @064f49> : 24 60 2f 06                store.m32 <@062f60> ;strArray
	cmplStd/test/lang/init.array.ci:40: (14 bytes: <.main+5473 @064f4d> - <.main+5487 @064f5b>): static strSlice: char[] := "string"
	<.main+5473 @064f4d> : 1c 06 00 00 00             load.c32 6
	<.main+5478 @064f52> : 1f 6d 9b 03 00             load.ref <@039b6d> ;"string"
	<.main+5483 @064f57> : 23 68 2f 06                store.m64 <@062f68> ;strSlice
	cmplStd/test/lang/recUnion.ci:26: (21 bytes: <.main+5487 @064f5b> - <.main+5508 @064f70>): static black: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5487 @064f5b> - <.main+5494 @064f62>): black.r := (0);
	<.main+5487 @064f5b> : 19                         load.z32
	<.main+5488 @064f5c> : 1f aa 2f 06 00             load.ref <@062faa> ;black+2
	<.main+5493 @064f61> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5494 @064f62> - <.main+5501 @064f69>): black.g := (0);
	<.main+5494 @064f62> : 19                         load.z32
	<.main+5495 @064f63> : 1f a9 2f 06 00             load.ref <@062fa9> ;black+1
	<.main+5500 @064f68> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5501 @064f69> - <.main+5508 @064f70>): black.b := (0);
	<.main+5501 @064f69> : 19                         load.z32
	<.main+5502 @064f6a> : 1f a8 2f 06 00             load.ref <@062fa8> ;black
	<.main+5507 @064f6f> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (25 bytes: <.main+5508 @064f70> - <.main+5533 @064f89>): static green: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5508 @064f70> - <.main+5515 @064f77>): green.r := (0);
	<.main+5508 @064f70> : 19                         load.z32
	<.main+5509 @064f71> : 1f b2 2f 06 00             load.ref <@062fb2> ;green+2
	<.main+5514 @064f76> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (11 bytes: <.main+5515 @064f77> - <.main+5526 @064f82>): green.g := (255);
	<.main+5515 @064f77> : 1c ff 00 00 00             load.c32 255
	<.main+5520 @064f7c> : 1f b1 2f 06 00             load.ref <@062fb1> ;green+1
	<.main+5525 @064f81> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5526 @064f82> - <.main+5533 @064f89>): green.b := (0);
	<.main+5526 @064f82> : 19                         load.z32
	<.main+5527 @064f83> : 1f b0 2f 06 00             load.ref <@062fb0> ;green
	<.main+5532 @064f88> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (33 bytes: <.main+5533 @064f89> - <.main+5566 @064faa>): static white: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5533 @064f89> - <.main+5544 @064f94>): white.r := (255);
	<.main+5533 @064f89> : 1c ff 00 00 00             load.c32 255
	<.main+5538 @064f8e> : 1f ba 2f 06 00             load.ref <@062fba> ;white+2
	<.main+5543 @064f93> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5544 @064f94> - <.main+5555 @064f9f>): white.g := (255);
	<.main+5544 @064f94> : 1c ff 00 00 00             load.c32 255
	<.main+5549 @064f99> : 1f b9 2f 06 00             load.ref <@062fb9> ;white+1
	<.main+5554 @064f9e> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5555 @064f9f> - <.main+5566 @064faa>): white.b := (255);
	<.main+5555 @064f9f> : 1c ff 00 00 00             load.c32 255
	<.main+5560 @064fa4> : 1f b8 2f 06 00             load.ref <@062fb8> ;white
	<.main+5565 @064fa9> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5566 @064faa> - <.main+5575 @064fb3>): cyan.col := (65535);
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5566 @064faa> - <.main+5575 @064fb3>): static cyan: color := {...}
	<.main+5566 @064faa> : 1c ff ff 00 00             load.c32 65535
	<.main+5571 @064faf> : 24 c0 2f 06                store.m32 <@062fc0> ;cyan
	cmplStd/test/lang/recUnion.ci:31: (25 bytes: <.main+5575 @064fb3> - <.main+5600 @064fcc>): static blue: color := {...}
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5575 @064fb3> - <.main+5582 @064fba>): blue.rgb.r := (0);
	<.main+5575 @064fb3> : 19                         load.z32
	<.main+5576 @064fb4> : 1f ca 2f 06 00             load.ref <@062fca> ;blue+2
	<.main+5581 @064fb9> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5582 @064fba> - <.main+5589 @064fc1>): blue.rgb.g := (0);
	<.main+5582 @064fba> : 19                         load.z32
	<.main+5583 @064fbb> : 1f c9 2f 06 00             load.ref <@062fc9> ;blue+1
	<.main+5588 @064fc0> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (11 bytes: <.main+5589 @064fc1> - <.main+5600 @064fcc>): blue.rgb.b := (255);
	<.main+5589 @064fc1> : 1c ff 00 00 00             load.c32 255
	<.main+5594 @064fc6> : 1f c8 2f 06 00             load.ref <@062fc8> ;blue
	<.main+5599 @064fcb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:5: (9 bytes: <.main+5600 @064fcc> - <.main+5609 @064fd5>): static shift: int32 := 2
	<.main+5600 @064fcc> : 1c 02 00 00 00             load.c32 2
	<.main+5605 @064fd1> : 24 d0 2f 06                store.m32 <@062fd0> ;shift
	cmplStd/test/lang/useOperator.ci:7: (11 bytes: <.main+5609 @064fd5> - <.main+5620 @064fe0>): static boolA: bool := true
	<.main+5609 @064fd5> : 1c 01 00 00 00             load.c32 1
	<.main+5614 @064fda> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5619 @064fdf> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:8: (11 bytes: <.main+5620 @064fe0> - <.main+5631 @064feb>): static boolB: bool := !false
	<.main+5620 @064fe0> : 1c 01 00 00 00             load.c32 1
	<.main+5625 @064fe5> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5630 @064fea> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:17: (19 bytes: <.main+5631 @064feb> - <.main+5650 @064ffe>): static boolAnd: bool := boolA & boolB
	<.main+5631 @064feb> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5636 @064ff0> : 26                         load.i8
	<.main+5637 @064ff1> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5642 @064ff6> : 26                         load.i8
	<.main+5643 @064ff7> : 31                         and.b32
	<.main+5644 @064ff8> : 1f e8 2f 06 00             load.ref <@062fe8> ;boolAnd
	<.main+5649 @064ffd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:18: (19 bytes: <.main+5650 @064ffe> - <.main+5669 @065011>): static boolIor: bool := boolA | boolB
	<.main+5650 @064ffe> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5655 @065003> : 26                         load.i8
	<.main+5656 @065004> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5661 @065009> : 26                         load.i8
	<.main+5662 @06500a> : 32                         or.b32
	<.main+5663 @06500b> : 1f f0 2f 06 00             load.ref <@062ff0> ;boolIor
	<.main+5668 @065010> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:19: (19 bytes: <.main+5669 @065011> - <.main+5688 @065024>): static boolXor: bool := boolA ^ boolB
	<.main+5669 @065011> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5674 @065016> : 26                         load.i8
	<.main+5675 @065017> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5680 @06501c> : 26                         load.i8
	<.main+5681 @06501d> : 36                         xor.b32
	<.main+5682 @06501e> : 1f f8 2f 06 00             load.ref <@062ff8> ;boolXor
	<.main+5687 @065023> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:22: (13 bytes: <.main+5688 @065024> - <.main+5701 @065031>): static boolNot: bool := !boolB
	<.main+5688 @065024> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5693 @065029> : 26                         load.i8
	<.main+5694 @06502a> : 0b                         not.b32
	<.main+5695 @06502b> : 1f 00 30 06 00             load.ref <@063000> ;boolNot
	<.main+5700 @065030> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:23: (19 bytes: <.main+5701 @065031> - <.main+5720 @065044>): static boolCeq: bool := boolA == boolB
	<.main+5701 @065031> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5706 @065036> : 26                         load.i8
	<.main+5707 @065037> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5712 @06503c> : 26                         load.i8
	<.main+5713 @06503d> : 57                         ceq.i32
	<.main+5714 @06503e> : 1f 08 30 06 00             load.ref <@063008> ;boolCeq
	<.main+5719 @065043> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:24: (20 bytes: <.main+5720 @065044> - <.main+5740 @065058>): static boolCne: bool := boolA != boolB
	<.main+5720 @065044> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5725 @065049> : 26                         load.i8
	<.main+5726 @06504a> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5731 @06504f> : 26                         load.i8
	<.main+5732 @065050> : 57                         ceq.i32
	<.main+5733 @065051> : 0b                         not.b32
	<.main+5734 @065052> : 1f 10 30 06 00             load.ref <@063010> ;boolCne
	<.main+5739 @065057> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:25: (19 bytes: <.main+5740 @065058> - <.main+5759 @06506b>): static boolClt: bool := boolA < boolB
	<.main+5740 @065058> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5745 @06505d> : 26                         load.i8
	<.main+5746 @06505e> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5751 @065063> : 26                         load.i8
	<.main+5752 @065064> : 58                         clt.i32
	<.main+5753 @065065> : 1f 18 30 06 00             load.ref <@063018> ;boolClt
	<.main+5758 @06506a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:26: (20 bytes: <.main+5759 @06506b> - <.main+5779 @06507f>): static boolCle: bool := boolA <= boolB
	<.main+5759 @06506b> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5764 @065070> : 26                         load.i8
	<.main+5765 @065071> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5770 @065076> : 26                         load.i8
	<.main+5771 @065077> : 59                         cgt.i32
	<.main+5772 @065078> : 0b                         not.b32
	<.main+5773 @065079> : 1f 20 30 06 00             load.ref <@063020> ;boolCle
	<.main+5778 @06507e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:27: (19 bytes: <.main+5779 @06507f> - <.main+5798 @065092>): static boolCgt: bool := boolA > boolB
	<.main+5779 @06507f> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5784 @065084> : 26                         load.i8
	<.main+5785 @065085> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5790 @06508a> : 26                         load.i8
	<.main+5791 @06508b> : 59                         cgt.i32
	<.main+5792 @06508c> : 1f 28 30 06 00             load.ref <@063028> ;boolCgt
	<.main+5797 @065091> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:28: (20 bytes: <.main+5798 @065092> - <.main+5818 @0650a6>): static boolCge: bool := boolA >= boolB
	<.main+5798 @065092> : 1f d8 2f 06 00             load.ref <@062fd8> ;boolA
	<.main+5803 @065097> : 26                         load.i8
	<.main+5804 @065098> : 1f e0 2f 06 00             load.ref <@062fe0> ;boolB
	<.main+5809 @06509d> : 26                         load.i8
	<.main+5810 @06509e> : 58                         clt.i32
	<.main+5811 @06509f> : 0b                         not.b32
	<.main+5812 @0650a0> : 1f 30 30 06 00             load.ref <@063030> ;boolCge
	<.main+5817 @0650a5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:30: (11 bytes: <.main+5818 @0650a6> - <.main+5829 @0650b1>): static chrA: char := 'a'
	<.main+5818 @0650a6> : 1c 61 00 00 00             load.c32 97
	<.main+5823 @0650ab> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5828 @0650b0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:31: (11 bytes: <.main+5829 @0650b1> - <.main+5840 @0650bc>): static chrB: char := 'b'
	<.main+5829 @0650b1> : 1c 62 00 00 00             load.c32 98
	<.main+5834 @0650b6> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5839 @0650bb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:32: (12 bytes: <.main+5840 @0650bc> - <.main+5852 @0650c8>): static chrPls: char := +chrB
	<.main+5840 @0650bc> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5845 @0650c1> : 26                         load.i8
	<.main+5846 @0650c2> : 1f 48 30 06 00             load.ref <@063048> ;chrPls
	<.main+5851 @0650c7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:33: (13 bytes: <.main+5852 @0650c8> - <.main+5865 @0650d5>): static chrNeg: char := -chrB
	<.main+5852 @0650c8> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5857 @0650cd> : 26                         load.i8
	<.main+5858 @0650ce> : 50                         neg.i32
	<.main+5859 @0650cf> : 1f 50 30 06 00             load.ref <@063050> ;chrNeg
	<.main+5864 @0650d4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:34: (13 bytes: <.main+5865 @0650d5> - <.main+5878 @0650e2>): static chrCmt: char := ~chrB
	<.main+5865 @0650d5> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5870 @0650da> : 26                         load.i8
	<.main+5871 @0650db> : 30                         cmt.b32
	<.main+5872 @0650dc> : 1f 58 30 06 00             load.ref <@063058> ;chrCmt
	<.main+5877 @0650e1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:35: (19 bytes: <.main+5878 @0650e2> - <.main+5897 @0650f5>): static chrAdd: char := chrA + chrB
	<.main+5878 @0650e2> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5883 @0650e7> : 26                         load.i8
	<.main+5884 @0650e8> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5889 @0650ed> : 26                         load.i8
	<.main+5890 @0650ee> : 51                         add.i32
	<.main+5891 @0650ef> : 1f 60 30 06 00             load.ref <@063060> ;chrAdd
	<.main+5896 @0650f4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:36: (19 bytes: <.main+5897 @0650f5> - <.main+5916 @065108>): static chrSub: char := chrA - chrB
	<.main+5897 @0650f5> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5902 @0650fa> : 26                         load.i8
	<.main+5903 @0650fb> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5908 @065100> : 26                         load.i8
	<.main+5909 @065101> : 52                         sub.i32
	<.main+5910 @065102> : 1f 68 30 06 00             load.ref <@063068> ;chrSub
	<.main+5915 @065107> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:37: (19 bytes: <.main+5916 @065108> - <.main+5935 @06511b>): static chrMul: char := chrA * chrB
	<.main+5916 @065108> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5921 @06510d> : 26                         load.i8
	<.main+5922 @06510e> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5927 @065113> : 26                         load.i8
	<.main+5928 @065114> : 53                         mul.i32
	<.main+5929 @065115> : 1f 70 30 06 00             load.ref <@063070> ;chrMul
	<.main+5934 @06511a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:38: (19 bytes: <.main+5935 @06511b> - <.main+5954 @06512e>): static chrDiv: char := chrA / chrB
	<.main+5935 @06511b> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5940 @065120> : 26                         load.i8
	<.main+5941 @065121> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5946 @065126> : 26                         load.i8
	<.main+5947 @065127> : 54                         div.i32
	<.main+5948 @065128> : 1f 78 30 06 00             load.ref <@063078> ;chrDiv
	<.main+5953 @06512d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:39: (19 bytes: <.main+5954 @06512e> - <.main+5973 @065141>): static chrMod: char := chrA % chrB
	<.main+5954 @06512e> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5959 @065133> : 26                         load.i8
	<.main+5960 @065134> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5965 @065139> : 26                         load.i8
	<.main+5966 @06513a> : 55                         mod.i32
	<.main+5967 @06513b> : 1f 80 30 06 00             load.ref <@063080> ;chrMod
	<.main+5972 @065140> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:40: (19 bytes: <.main+5973 @065141> - <.main+5992 @065154>): static chrAnd: char := chrA & chrB
	<.main+5973 @065141> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5978 @065146> : 26                         load.i8
	<.main+5979 @065147> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+5984 @06514c> : 26                         load.i8
	<.main+5985 @06514d> : 31                         and.b32
	<.main+5986 @06514e> : 1f 88 30 06 00             load.ref <@063088> ;chrAnd
	<.main+5991 @065153> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:41: (19 bytes: <.main+5992 @065154> - <.main+6011 @065167>): static chrIor: char := chrA | chrB
	<.main+5992 @065154> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+5997 @065159> : 26                         load.i8
	<.main+5998 @06515a> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6003 @06515f> : 26                         load.i8
	<.main+6004 @065160> : 32                         or.b32
	<.main+6005 @065161> : 1f 90 30 06 00             load.ref <@063090> ;chrIor
	<.main+6010 @065166> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:42: (19 bytes: <.main+6011 @065167> - <.main+6030 @06517a>): static chrXor: char := chrA ^ chrB
	<.main+6011 @065167> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6016 @06516c> : 26                         load.i8
	<.main+6017 @06516d> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6022 @065172> : 26                         load.i8
	<.main+6023 @065173> : 36                         xor.b32
	<.main+6024 @065174> : 1f 98 30 06 00             load.ref <@063098> ;chrXor
	<.main+6029 @065179> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:43: (17 bytes: <.main+6030 @06517a> - <.main+6047 @06518b>): static chrShl: char := (chrA) << shift
	<.main+6030 @06517a> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6035 @06517f> : 26                         load.i8
	<.main+6036 @065180> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+6040 @065184> : 3a                         shl.b32
	<.main+6041 @065185> : 1f a0 30 06 00             load.ref <@0630a0> ;chrShl
	<.main+6046 @06518a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:44: (17 bytes: <.main+6047 @06518b> - <.main+6064 @06519c>): static chrShr: char := (chrA) >> shift
	<.main+6047 @06518b> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6052 @065190> : 26                         load.i8
	<.main+6053 @065191> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+6057 @065195> : 3c                         sar.b32
	<.main+6058 @065196> : 1f a8 30 06 00             load.ref <@0630a8> ;chrShr
	<.main+6063 @06519b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:45: (14 bytes: <.main+6064 @06519c> - <.main+6078 @0651aa>): static chrNot: bool := !(chrB)
	<.main+6064 @06519c> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6069 @0651a1> : 26                         load.i8
	<.main+6070 @0651a2> : 5a                         i32.2bool
	<.main+6071 @0651a3> : 0b                         not.b32
	<.main+6072 @0651a4> : 1f b0 30 06 00             load.ref <@0630b0> ;chrNot
	<.main+6077 @0651a9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:46: (19 bytes: <.main+6078 @0651aa> - <.main+6097 @0651bd>): static chrCeq: bool := chrA == chrB
	<.main+6078 @0651aa> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6083 @0651af> : 26                         load.i8
	<.main+6084 @0651b0> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6089 @0651b5> : 26                         load.i8
	<.main+6090 @0651b6> : 57                         ceq.i32
	<.main+6091 @0651b7> : 1f b8 30 06 00             load.ref <@0630b8> ;chrCeq
	<.main+6096 @0651bc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:47: (20 bytes: <.main+6097 @0651bd> - <.main+6117 @0651d1>): static chrCne: bool := chrA != chrB
	<.main+6097 @0651bd> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6102 @0651c2> : 26                         load.i8
	<.main+6103 @0651c3> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6108 @0651c8> : 26                         load.i8
	<.main+6109 @0651c9> : 57                         ceq.i32
	<.main+6110 @0651ca> : 0b                         not.b32
	<.main+6111 @0651cb> : 1f c0 30 06 00             load.ref <@0630c0> ;chrCne
	<.main+6116 @0651d0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:48: (19 bytes: <.main+6117 @0651d1> - <.main+6136 @0651e4>): static chrClt: bool := chrA < chrB
	<.main+6117 @0651d1> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6122 @0651d6> : 26                         load.i8
	<.main+6123 @0651d7> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6128 @0651dc> : 26                         load.i8
	<.main+6129 @0651dd> : 58                         clt.i32
	<.main+6130 @0651de> : 1f c8 30 06 00             load.ref <@0630c8> ;chrClt
	<.main+6135 @0651e3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:49: (20 bytes: <.main+6136 @0651e4> - <.main+6156 @0651f8>): static chrCle: bool := chrA <= chrB
	<.main+6136 @0651e4> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6141 @0651e9> : 26                         load.i8
	<.main+6142 @0651ea> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6147 @0651ef> : 26                         load.i8
	<.main+6148 @0651f0> : 59                         cgt.i32
	<.main+6149 @0651f1> : 0b                         not.b32
	<.main+6150 @0651f2> : 1f d0 30 06 00             load.ref <@0630d0> ;chrCle
	<.main+6155 @0651f7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:50: (19 bytes: <.main+6156 @0651f8> - <.main+6175 @06520b>): static chrCgt: bool := chrA > chrB
	<.main+6156 @0651f8> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6161 @0651fd> : 26                         load.i8
	<.main+6162 @0651fe> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6167 @065203> : 26                         load.i8
	<.main+6168 @065204> : 59                         cgt.i32
	<.main+6169 @065205> : 1f d8 30 06 00             load.ref <@0630d8> ;chrCgt
	<.main+6174 @06520a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:51: (20 bytes: <.main+6175 @06520b> - <.main+6195 @06521f>): static chrCge: bool := chrA >= chrB
	<.main+6175 @06520b> : 1f 38 30 06 00             load.ref <@063038> ;chrA
	<.main+6180 @065210> : 26                         load.i8
	<.main+6181 @065211> : 1f 40 30 06 00             load.ref <@063040> ;chrB
	<.main+6186 @065216> : 26                         load.i8
	<.main+6187 @065217> : 58                         clt.i32
	<.main+6188 @065218> : 0b                         not.b32
	<.main+6189 @065219> : 1f e0 30 06 00             load.ref <@0630e0> ;chrCge
	<.main+6194 @06521e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:53: (11 bytes: <.main+6195 @06521f> - <.main+6206 @06522a>): static i8A: int8 := a
	<.main+6195 @06521f> : 1c 60 00 00 00             load.c32 96
	<.main+6200 @065224> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6205 @065229> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:54: (11 bytes: <.main+6206 @06522a> - <.main+6217 @065235>): static i8B: int8 := b
	<.main+6206 @06522a> : 1c 2a 00 00 00             load.c32 42
	<.main+6211 @06522f> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6216 @065234> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:55: (12 bytes: <.main+6217 @065235> - <.main+6229 @065241>): static i8Pls: int8 := +i8B
	<.main+6217 @065235> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6222 @06523a> : 26                         load.i8
	<.main+6223 @06523b> : 1f f8 30 06 00             load.ref <@0630f8> ;i8Pls
	<.main+6228 @065240> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:56: (13 bytes: <.main+6229 @065241> - <.main+6242 @06524e>): static i8Neg: int8 := -i8B
	<.main+6229 @065241> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6234 @065246> : 26                         load.i8
	<.main+6235 @065247> : 50                         neg.i32
	<.main+6236 @065248> : 1f 00 31 06 00             load.ref <@063100> ;i8Neg
	<.main+6241 @06524d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:57: (13 bytes: <.main+6242 @06524e> - <.main+6255 @06525b>): static i8Cmt: int8 := ~i8B
	<.main+6242 @06524e> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6247 @065253> : 26                         load.i8
	<.main+6248 @065254> : 30                         cmt.b32
	<.main+6249 @065255> : 1f 08 31 06 00             load.ref <@063108> ;i8Cmt
	<.main+6254 @06525a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:58: (19 bytes: <.main+6255 @06525b> - <.main+6274 @06526e>): static i8Add: int8 := i8A + i8B
	<.main+6255 @06525b> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6260 @065260> : 26                         load.i8
	<.main+6261 @065261> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6266 @065266> : 26                         load.i8
	<.main+6267 @065267> : 51                         add.i32
	<.main+6268 @065268> : 1f 10 31 06 00             load.ref <@063110> ;i8Add
	<.main+6273 @06526d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:59: (19 bytes: <.main+6274 @06526e> - <.main+6293 @065281>): static i8Sub: int8 := i8A - i8B
	<.main+6274 @06526e> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6279 @065273> : 26                         load.i8
	<.main+6280 @065274> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6285 @065279> : 26                         load.i8
	<.main+6286 @06527a> : 52                         sub.i32
	<.main+6287 @06527b> : 1f 18 31 06 00             load.ref <@063118> ;i8Sub
	<.main+6292 @065280> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:60: (19 bytes: <.main+6293 @065281> - <.main+6312 @065294>): static i8Mul: int8 := i8A * i8B
	<.main+6293 @065281> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6298 @065286> : 26                         load.i8
	<.main+6299 @065287> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6304 @06528c> : 26                         load.i8
	<.main+6305 @06528d> : 53                         mul.i32
	<.main+6306 @06528e> : 1f 20 31 06 00             load.ref <@063120> ;i8Mul
	<.main+6311 @065293> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:61: (19 bytes: <.main+6312 @065294> - <.main+6331 @0652a7>): static i8Div: int8 := i8A / i8B
	<.main+6312 @065294> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6317 @065299> : 26                         load.i8
	<.main+6318 @06529a> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6323 @06529f> : 26                         load.i8
	<.main+6324 @0652a0> : 54                         div.i32
	<.main+6325 @0652a1> : 1f 28 31 06 00             load.ref <@063128> ;i8Div
	<.main+6330 @0652a6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:62: (19 bytes: <.main+6331 @0652a7> - <.main+6350 @0652ba>): static i8Mod: int8 := i8A % i8B
	<.main+6331 @0652a7> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6336 @0652ac> : 26                         load.i8
	<.main+6337 @0652ad> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6342 @0652b2> : 26                         load.i8
	<.main+6343 @0652b3> : 55                         mod.i32
	<.main+6344 @0652b4> : 1f 30 31 06 00             load.ref <@063130> ;i8Mod
	<.main+6349 @0652b9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:63: (19 bytes: <.main+6350 @0652ba> - <.main+6369 @0652cd>): static i8And: int8 := i8A & i8B
	<.main+6350 @0652ba> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6355 @0652bf> : 26                         load.i8
	<.main+6356 @0652c0> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6361 @0652c5> : 26                         load.i8
	<.main+6362 @0652c6> : 31                         and.b32
	<.main+6363 @0652c7> : 1f 38 31 06 00             load.ref <@063138> ;i8And
	<.main+6368 @0652cc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:64: (19 bytes: <.main+6369 @0652cd> - <.main+6388 @0652e0>): static i8Ior: int8 := i8A | i8B
	<.main+6369 @0652cd> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6374 @0652d2> : 26                         load.i8
	<.main+6375 @0652d3> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6380 @0652d8> : 26                         load.i8
	<.main+6381 @0652d9> : 32                         or.b32
	<.main+6382 @0652da> : 1f 40 31 06 00             load.ref <@063140> ;i8Ior
	<.main+6387 @0652df> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:65: (19 bytes: <.main+6388 @0652e0> - <.main+6407 @0652f3>): static i8Xor: int8 := i8A ^ i8B
	<.main+6388 @0652e0> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6393 @0652e5> : 26                         load.i8
	<.main+6394 @0652e6> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6399 @0652eb> : 26                         load.i8
	<.main+6400 @0652ec> : 36                         xor.b32
	<.main+6401 @0652ed> : 1f 48 31 06 00             load.ref <@063148> ;i8Xor
	<.main+6406 @0652f2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:66: (17 bytes: <.main+6407 @0652f3> - <.main+6424 @065304>): static i8Shl: int8 := (i8A) << shift
	<.main+6407 @0652f3> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6412 @0652f8> : 26                         load.i8
	<.main+6413 @0652f9> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+6417 @0652fd> : 3a                         shl.b32
	<.main+6418 @0652fe> : 1f 50 31 06 00             load.ref <@063150> ;i8Shl
	<.main+6423 @065303> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:67: (17 bytes: <.main+6424 @065304> - <.main+6441 @065315>): static i8Shr: int8 := (i8A) >> shift
	<.main+6424 @065304> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6429 @065309> : 26                         load.i8
	<.main+6430 @06530a> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+6434 @06530e> : 3c                         sar.b32
	<.main+6435 @06530f> : 1f 58 31 06 00             load.ref <@063158> ;i8Shr
	<.main+6440 @065314> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:68: (14 bytes: <.main+6441 @065315> - <.main+6455 @065323>): static i8Not: bool := !(i8B)
	<.main+6441 @065315> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6446 @06531a> : 26                         load.i8
	<.main+6447 @06531b> : 5a                         i32.2bool
	<.main+6448 @06531c> : 0b                         not.b32
	<.main+6449 @06531d> : 1f 60 31 06 00             load.ref <@063160> ;i8Not
	<.main+6454 @065322> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:69: (19 bytes: <.main+6455 @065323> - <.main+6474 @065336>): static i8Ceq: bool := i8A == i8B
	<.main+6455 @065323> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6460 @065328> : 26                         load.i8
	<.main+6461 @065329> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6466 @06532e> : 26                         load.i8
	<.main+6467 @06532f> : 57                         ceq.i32
	<.main+6468 @065330> : 1f 68 31 06 00             load.ref <@063168> ;i8Ceq
	<.main+6473 @065335> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:70: (20 bytes: <.main+6474 @065336> - <.main+6494 @06534a>): static i8Cne: bool := i8A != i8B
	<.main+6474 @065336> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6479 @06533b> : 26                         load.i8
	<.main+6480 @06533c> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6485 @065341> : 26                         load.i8
	<.main+6486 @065342> : 57                         ceq.i32
	<.main+6487 @065343> : 0b                         not.b32
	<.main+6488 @065344> : 1f 70 31 06 00             load.ref <@063170> ;i8Cne
	<.main+6493 @065349> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:71: (19 bytes: <.main+6494 @06534a> - <.main+6513 @06535d>): static i8Clt: bool := i8A < i8B
	<.main+6494 @06534a> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6499 @06534f> : 26                         load.i8
	<.main+6500 @065350> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6505 @065355> : 26                         load.i8
	<.main+6506 @065356> : 58                         clt.i32
	<.main+6507 @065357> : 1f 78 31 06 00             load.ref <@063178> ;i8Clt
	<.main+6512 @06535c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:72: (20 bytes: <.main+6513 @06535d> - <.main+6533 @065371>): static i8Cle: bool := i8A <= i8B
	<.main+6513 @06535d> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6518 @065362> : 26                         load.i8
	<.main+6519 @065363> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6524 @065368> : 26                         load.i8
	<.main+6525 @065369> : 59                         cgt.i32
	<.main+6526 @06536a> : 0b                         not.b32
	<.main+6527 @06536b> : 1f 80 31 06 00             load.ref <@063180> ;i8Cle
	<.main+6532 @065370> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:73: (19 bytes: <.main+6533 @065371> - <.main+6552 @065384>): static i8Cgt: bool := i8A > i8B
	<.main+6533 @065371> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6538 @065376> : 26                         load.i8
	<.main+6539 @065377> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6544 @06537c> : 26                         load.i8
	<.main+6545 @06537d> : 59                         cgt.i32
	<.main+6546 @06537e> : 1f 88 31 06 00             load.ref <@063188> ;i8Cgt
	<.main+6551 @065383> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:74: (20 bytes: <.main+6552 @065384> - <.main+6572 @065398>): static i8Cge: bool := i8A >= i8B
	<.main+6552 @065384> : 1f e8 30 06 00             load.ref <@0630e8> ;i8A
	<.main+6557 @065389> : 26                         load.i8
	<.main+6558 @06538a> : 1f f0 30 06 00             load.ref <@0630f0> ;i8B
	<.main+6563 @06538f> : 26                         load.i8
	<.main+6564 @065390> : 58                         clt.i32
	<.main+6565 @065391> : 0b                         not.b32
	<.main+6566 @065392> : 1f 90 31 06 00             load.ref <@063190> ;i8Cge
	<.main+6571 @065397> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:76: (11 bytes: <.main+6572 @065398> - <.main+6583 @0653a3>): static u8A: uint8 := a
	<.main+6572 @065398> : 1c 60 00 00 00             load.c32 96
	<.main+6577 @06539d> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6582 @0653a2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:77: (11 bytes: <.main+6583 @0653a3> - <.main+6594 @0653ae>): static u8B: uint8 := b
	<.main+6583 @0653a3> : 1c 2a 00 00 00             load.c32 42
	<.main+6588 @0653a8> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6593 @0653ad> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:78: (12 bytes: <.main+6594 @0653ae> - <.main+6606 @0653ba>): static u8Pls: uint8 := +u8B
	<.main+6594 @0653ae> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6599 @0653b3> : 26                         load.i8
	<.main+6600 @0653b4> : 1f a8 31 06 00             load.ref <@0631a8> ;u8Pls
	<.main+6605 @0653b9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:79: (13 bytes: <.main+6606 @0653ba> - <.main+6619 @0653c7>): static u8Neg: uint8 := -u8B
	<.main+6606 @0653ba> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6611 @0653bf> : 26                         load.i8
	<.main+6612 @0653c0> : 50                         neg.i32
	<.main+6613 @0653c1> : 1f b0 31 06 00             load.ref <@0631b0> ;u8Neg
	<.main+6618 @0653c6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:80: (13 bytes: <.main+6619 @0653c7> - <.main+6632 @0653d4>): static u8Cmt: uint8 := ~u8B
	<.main+6619 @0653c7> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6624 @0653cc> : 26                         load.i8
	<.main+6625 @0653cd> : 30                         cmt.b32
	<.main+6626 @0653ce> : 1f b8 31 06 00             load.ref <@0631b8> ;u8Cmt
	<.main+6631 @0653d3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:81: (19 bytes: <.main+6632 @0653d4> - <.main+6651 @0653e7>): static u8Add: uint8 := u8A + u8B
	<.main+6632 @0653d4> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6637 @0653d9> : 26                         load.i8
	<.main+6638 @0653da> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6643 @0653df> : 26                         load.i8
	<.main+6644 @0653e0> : 51                         add.i32
	<.main+6645 @0653e1> : 1f c0 31 06 00             load.ref <@0631c0> ;u8Add
	<.main+6650 @0653e6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:82: (19 bytes: <.main+6651 @0653e7> - <.main+6670 @0653fa>): static u8Sub: uint8 := u8A - u8B
	<.main+6651 @0653e7> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6656 @0653ec> : 26                         load.i8
	<.main+6657 @0653ed> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6662 @0653f2> : 26                         load.i8
	<.main+6663 @0653f3> : 52                         sub.i32
	<.main+6664 @0653f4> : 1f c8 31 06 00             load.ref <@0631c8> ;u8Sub
	<.main+6669 @0653f9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:83: (19 bytes: <.main+6670 @0653fa> - <.main+6689 @06540d>): static u8Mul: uint8 := u8A * u8B
	<.main+6670 @0653fa> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6675 @0653ff> : 26                         load.i8
	<.main+6676 @065400> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6681 @065405> : 26                         load.i8
	<.main+6682 @065406> : 33                         mul.u32
	<.main+6683 @065407> : 1f d0 31 06 00             load.ref <@0631d0> ;u8Mul
	<.main+6688 @06540c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:84: (19 bytes: <.main+6689 @06540d> - <.main+6708 @065420>): static u8Div: uint8 := u8A / u8B
	<.main+6689 @06540d> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6694 @065412> : 26                         load.i8
	<.main+6695 @065413> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6700 @065418> : 26                         load.i8
	<.main+6701 @065419> : 34                         div.u32
	<.main+6702 @06541a> : 1f d8 31 06 00             load.ref <@0631d8> ;u8Div
	<.main+6707 @06541f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:85: (19 bytes: <.main+6708 @065420> - <.main+6727 @065433>): static u8Mod: uint8 := u8A % u8B
	<.main+6708 @065420> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6713 @065425> : 26                         load.i8
	<.main+6714 @065426> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6719 @06542b> : 26                         load.i8
	<.main+6720 @06542c> : 35                         mod.u32
	<.main+6721 @06542d> : 1f e0 31 06 00             load.ref <@0631e0> ;u8Mod
	<.main+6726 @065432> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:86: (19 bytes: <.main+6727 @065433> - <.main+6746 @065446>): static u8And: uint8 := u8A & u8B
	<.main+6727 @065433> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6732 @065438> : 26                         load.i8
	<.main+6733 @065439> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6738 @06543e> : 26                         load.i8
	<.main+6739 @06543f> : 31                         and.b32
	<.main+6740 @065440> : 1f e8 31 06 00             load.ref <@0631e8> ;u8And
	<.main+6745 @065445> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:87: (19 bytes: <.main+6746 @065446> - <.main+6765 @065459>): static u8Ior: uint8 := u8A | u8B
	<.main+6746 @065446> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6751 @06544b> : 26                         load.i8
	<.main+6752 @06544c> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6757 @065451> : 26                         load.i8
	<.main+6758 @065452> : 32                         or.b32
	<.main+6759 @065453> : 1f f0 31 06 00             load.ref <@0631f0> ;u8Ior
	<.main+6764 @065458> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:88: (19 bytes: <.main+6765 @065459> - <.main+6784 @06546c>): static u8Xor: uint8 := u8A ^ u8B
	<.main+6765 @065459> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6770 @06545e> : 26                         load.i8
	<.main+6771 @06545f> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6776 @065464> : 26                         load.i8
	<.main+6777 @065465> : 36                         xor.b32
	<.main+6778 @065466> : 1f f8 31 06 00             load.ref <@0631f8> ;u8Xor
	<.main+6783 @06546b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:89: (17 bytes: <.main+6784 @06546c> - <.main+6801 @06547d>): static u8Shl: uint8 := (u8A) << shift
	<.main+6784 @06546c> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6789 @065471> : 26                         load.i8
	<.main+6790 @065472> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+6794 @065476> : 3a                         shl.b32
	<.main+6795 @065477> : 1f 00 32 06 00             load.ref <@063200> ;u8Shl
	<.main+6800 @06547c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:90: (17 bytes: <.main+6801 @06547d> - <.main+6818 @06548e>): static u8Shr: uint8 := (u8A) >> shift
	<.main+6801 @06547d> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6806 @065482> : 26                         load.i8
	<.main+6807 @065483> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+6811 @065487> : 3c                         sar.b32
	<.main+6812 @065488> : 1f 08 32 06 00             load.ref <@063208> ;u8Shr
	<.main+6817 @06548d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:91: (14 bytes: <.main+6818 @06548e> - <.main+6832 @06549c>): static u8Not: bool := !(u8B)
	<.main+6818 @06548e> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6823 @065493> : 26                         load.i8
	<.main+6824 @065494> : 5a                         i32.2bool
	<.main+6825 @065495> : 0b                         not.b32
	<.main+6826 @065496> : 1f 10 32 06 00             load.ref <@063210> ;u8Not
	<.main+6831 @06549b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:92: (19 bytes: <.main+6832 @06549c> - <.main+6851 @0654af>): static u8Ceq: bool := u8A == u8B
	<.main+6832 @06549c> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6837 @0654a1> : 26                         load.i8
	<.main+6838 @0654a2> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6843 @0654a7> : 26                         load.i8
	<.main+6844 @0654a8> : 57                         ceq.i32
	<.main+6845 @0654a9> : 1f 18 32 06 00             load.ref <@063218> ;u8Ceq
	<.main+6850 @0654ae> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:93: (20 bytes: <.main+6851 @0654af> - <.main+6871 @0654c3>): static u8Cne: bool := u8A != u8B
	<.main+6851 @0654af> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6856 @0654b4> : 26                         load.i8
	<.main+6857 @0654b5> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6862 @0654ba> : 26                         load.i8
	<.main+6863 @0654bb> : 57                         ceq.i32
	<.main+6864 @0654bc> : 0b                         not.b32
	<.main+6865 @0654bd> : 1f 20 32 06 00             load.ref <@063220> ;u8Cne
	<.main+6870 @0654c2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:94: (19 bytes: <.main+6871 @0654c3> - <.main+6890 @0654d6>): static u8Clt: bool := u8A < u8B
	<.main+6871 @0654c3> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6876 @0654c8> : 26                         load.i8
	<.main+6877 @0654c9> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6882 @0654ce> : 26                         load.i8
	<.main+6883 @0654cf> : 38                         clt.u32
	<.main+6884 @0654d0> : 1f 28 32 06 00             load.ref <@063228> ;u8Clt
	<.main+6889 @0654d5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:95: (20 bytes: <.main+6890 @0654d6> - <.main+6910 @0654ea>): static u8Cle: bool := u8A <= u8B
	<.main+6890 @0654d6> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6895 @0654db> : 26                         load.i8
	<.main+6896 @0654dc> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6901 @0654e1> : 26                         load.i8
	<.main+6902 @0654e2> : 39                         cgt.u32
	<.main+6903 @0654e3> : 0b                         not.b32
	<.main+6904 @0654e4> : 1f 30 32 06 00             load.ref <@063230> ;u8Cle
	<.main+6909 @0654e9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:96: (19 bytes: <.main+6910 @0654ea> - <.main+6929 @0654fd>): static u8Cgt: bool := u8A > u8B
	<.main+6910 @0654ea> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6915 @0654ef> : 26                         load.i8
	<.main+6916 @0654f0> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6921 @0654f5> : 26                         load.i8
	<.main+6922 @0654f6> : 39                         cgt.u32
	<.main+6923 @0654f7> : 1f 38 32 06 00             load.ref <@063238> ;u8Cgt
	<.main+6928 @0654fc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:97: (20 bytes: <.main+6929 @0654fd> - <.main+6949 @065511>): static u8Cge: bool := u8A >= u8B
	<.main+6929 @0654fd> : 1f 98 31 06 00             load.ref <@063198> ;u8A
	<.main+6934 @065502> : 26                         load.i8
	<.main+6935 @065503> : 1f a0 31 06 00             load.ref <@0631a0> ;u8B
	<.main+6940 @065508> : 26                         load.i8
	<.main+6941 @065509> : 38                         clt.u32
	<.main+6942 @06550a> : 0b                         not.b32
	<.main+6943 @06550b> : 1f 40 32 06 00             load.ref <@063240> ;u8Cge
	<.main+6948 @065510> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:99: (11 bytes: <.main+6949 @065511> - <.main+6960 @06551c>): static i16A: int16 := a
	<.main+6949 @065511> : 1c 60 00 00 00             load.c32 96
	<.main+6954 @065516> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+6959 @06551b> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:100: (11 bytes: <.main+6960 @06551c> - <.main+6971 @065527>): static i16B: int16 := b
	<.main+6960 @06551c> : 1c 2a 00 00 00             load.c32 42
	<.main+6965 @065521> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+6970 @065526> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:101: (12 bytes: <.main+6971 @065527> - <.main+6983 @065533>): static i16Pls: int16 := +i16B
	<.main+6971 @065527> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+6976 @06552c> : 27                         load.i16
	<.main+6977 @06552d> : 1f 58 32 06 00             load.ref <@063258> ;i16Pls
	<.main+6982 @065532> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:102: (13 bytes: <.main+6983 @065533> - <.main+6996 @065540>): static i16Neg: int16 := -i16B
	<.main+6983 @065533> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+6988 @065538> : 27                         load.i16
	<.main+6989 @065539> : 50                         neg.i32
	<.main+6990 @06553a> : 1f 60 32 06 00             load.ref <@063260> ;i16Neg
	<.main+6995 @06553f> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:103: (13 bytes: <.main+6996 @065540> - <.main+7009 @06554d>): static i16Cmt: int16 := ~i16B
	<.main+6996 @065540> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7001 @065545> : 27                         load.i16
	<.main+7002 @065546> : 30                         cmt.b32
	<.main+7003 @065547> : 1f 68 32 06 00             load.ref <@063268> ;i16Cmt
	<.main+7008 @06554c> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:104: (19 bytes: <.main+7009 @06554d> - <.main+7028 @065560>): static i16Add: int16 := i16A + i16B
	<.main+7009 @06554d> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7014 @065552> : 27                         load.i16
	<.main+7015 @065553> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7020 @065558> : 27                         load.i16
	<.main+7021 @065559> : 51                         add.i32
	<.main+7022 @06555a> : 1f 70 32 06 00             load.ref <@063270> ;i16Add
	<.main+7027 @06555f> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:105: (19 bytes: <.main+7028 @065560> - <.main+7047 @065573>): static i16Sub: int16 := i16A - i16B
	<.main+7028 @065560> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7033 @065565> : 27                         load.i16
	<.main+7034 @065566> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7039 @06556b> : 27                         load.i16
	<.main+7040 @06556c> : 52                         sub.i32
	<.main+7041 @06556d> : 1f 78 32 06 00             load.ref <@063278> ;i16Sub
	<.main+7046 @065572> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:106: (19 bytes: <.main+7047 @065573> - <.main+7066 @065586>): static i16Mul: int16 := i16A * i16B
	<.main+7047 @065573> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7052 @065578> : 27                         load.i16
	<.main+7053 @065579> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7058 @06557e> : 27                         load.i16
	<.main+7059 @06557f> : 53                         mul.i32
	<.main+7060 @065580> : 1f 80 32 06 00             load.ref <@063280> ;i16Mul
	<.main+7065 @065585> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:107: (19 bytes: <.main+7066 @065586> - <.main+7085 @065599>): static i16Div: int16 := i16A / i16B
	<.main+7066 @065586> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7071 @06558b> : 27                         load.i16
	<.main+7072 @06558c> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7077 @065591> : 27                         load.i16
	<.main+7078 @065592> : 54                         div.i32
	<.main+7079 @065593> : 1f 88 32 06 00             load.ref <@063288> ;i16Div
	<.main+7084 @065598> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:108: (19 bytes: <.main+7085 @065599> - <.main+7104 @0655ac>): static i16Mod: int16 := i16A % i16B
	<.main+7085 @065599> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7090 @06559e> : 27                         load.i16
	<.main+7091 @06559f> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7096 @0655a4> : 27                         load.i16
	<.main+7097 @0655a5> : 55                         mod.i32
	<.main+7098 @0655a6> : 1f 90 32 06 00             load.ref <@063290> ;i16Mod
	<.main+7103 @0655ab> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:109: (19 bytes: <.main+7104 @0655ac> - <.main+7123 @0655bf>): static i16And: int16 := i16A & i16B
	<.main+7104 @0655ac> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7109 @0655b1> : 27                         load.i16
	<.main+7110 @0655b2> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7115 @0655b7> : 27                         load.i16
	<.main+7116 @0655b8> : 31                         and.b32
	<.main+7117 @0655b9> : 1f 98 32 06 00             load.ref <@063298> ;i16And
	<.main+7122 @0655be> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:110: (19 bytes: <.main+7123 @0655bf> - <.main+7142 @0655d2>): static i16Ior: int16 := i16A | i16B
	<.main+7123 @0655bf> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7128 @0655c4> : 27                         load.i16
	<.main+7129 @0655c5> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7134 @0655ca> : 27                         load.i16
	<.main+7135 @0655cb> : 32                         or.b32
	<.main+7136 @0655cc> : 1f a0 32 06 00             load.ref <@0632a0> ;i16Ior
	<.main+7141 @0655d1> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:111: (19 bytes: <.main+7142 @0655d2> - <.main+7161 @0655e5>): static i16Xor: int16 := i16A ^ i16B
	<.main+7142 @0655d2> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7147 @0655d7> : 27                         load.i16
	<.main+7148 @0655d8> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7153 @0655dd> : 27                         load.i16
	<.main+7154 @0655de> : 36                         xor.b32
	<.main+7155 @0655df> : 1f a8 32 06 00             load.ref <@0632a8> ;i16Xor
	<.main+7160 @0655e4> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:112: (17 bytes: <.main+7161 @0655e5> - <.main+7178 @0655f6>): static i16Shl: int16 := (i16A) << shift
	<.main+7161 @0655e5> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7166 @0655ea> : 27                         load.i16
	<.main+7167 @0655eb> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+7171 @0655ef> : 3a                         shl.b32
	<.main+7172 @0655f0> : 1f b0 32 06 00             load.ref <@0632b0> ;i16Shl
	<.main+7177 @0655f5> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:113: (17 bytes: <.main+7178 @0655f6> - <.main+7195 @065607>): static i16Shr: int16 := (i16A) >> shift
	<.main+7178 @0655f6> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7183 @0655fb> : 27                         load.i16
	<.main+7184 @0655fc> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+7188 @065600> : 3c                         sar.b32
	<.main+7189 @065601> : 1f b8 32 06 00             load.ref <@0632b8> ;i16Shr
	<.main+7194 @065606> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:114: (14 bytes: <.main+7195 @065607> - <.main+7209 @065615>): static i16Not: bool := !(i16B)
	<.main+7195 @065607> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7200 @06560c> : 27                         load.i16
	<.main+7201 @06560d> : 5a                         i32.2bool
	<.main+7202 @06560e> : 0b                         not.b32
	<.main+7203 @06560f> : 1f c0 32 06 00             load.ref <@0632c0> ;i16Not
	<.main+7208 @065614> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:115: (19 bytes: <.main+7209 @065615> - <.main+7228 @065628>): static i16Ceq: bool := i16A == i16B
	<.main+7209 @065615> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7214 @06561a> : 27                         load.i16
	<.main+7215 @06561b> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7220 @065620> : 27                         load.i16
	<.main+7221 @065621> : 57                         ceq.i32
	<.main+7222 @065622> : 1f c8 32 06 00             load.ref <@0632c8> ;i16Ceq
	<.main+7227 @065627> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:116: (20 bytes: <.main+7228 @065628> - <.main+7248 @06563c>): static i16Cne: bool := i16A != i16B
	<.main+7228 @065628> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7233 @06562d> : 27                         load.i16
	<.main+7234 @06562e> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7239 @065633> : 27                         load.i16
	<.main+7240 @065634> : 57                         ceq.i32
	<.main+7241 @065635> : 0b                         not.b32
	<.main+7242 @065636> : 1f d0 32 06 00             load.ref <@0632d0> ;i16Cne
	<.main+7247 @06563b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:117: (19 bytes: <.main+7248 @06563c> - <.main+7267 @06564f>): static i16Clt: bool := i16A < i16B
	<.main+7248 @06563c> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7253 @065641> : 27                         load.i16
	<.main+7254 @065642> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7259 @065647> : 27                         load.i16
	<.main+7260 @065648> : 58                         clt.i32
	<.main+7261 @065649> : 1f d8 32 06 00             load.ref <@0632d8> ;i16Clt
	<.main+7266 @06564e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:118: (20 bytes: <.main+7267 @06564f> - <.main+7287 @065663>): static i16Cle: bool := i16A <= i16B
	<.main+7267 @06564f> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7272 @065654> : 27                         load.i16
	<.main+7273 @065655> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7278 @06565a> : 27                         load.i16
	<.main+7279 @06565b> : 59                         cgt.i32
	<.main+7280 @06565c> : 0b                         not.b32
	<.main+7281 @06565d> : 1f e0 32 06 00             load.ref <@0632e0> ;i16Cle
	<.main+7286 @065662> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:119: (19 bytes: <.main+7287 @065663> - <.main+7306 @065676>): static i16Cgt: bool := i16A > i16B
	<.main+7287 @065663> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7292 @065668> : 27                         load.i16
	<.main+7293 @065669> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7298 @06566e> : 27                         load.i16
	<.main+7299 @06566f> : 59                         cgt.i32
	<.main+7300 @065670> : 1f e8 32 06 00             load.ref <@0632e8> ;i16Cgt
	<.main+7305 @065675> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:120: (20 bytes: <.main+7306 @065676> - <.main+7326 @06568a>): static i16Cge: bool := i16A >= i16B
	<.main+7306 @065676> : 1f 48 32 06 00             load.ref <@063248> ;i16A
	<.main+7311 @06567b> : 27                         load.i16
	<.main+7312 @06567c> : 1f 50 32 06 00             load.ref <@063250> ;i16B
	<.main+7317 @065681> : 27                         load.i16
	<.main+7318 @065682> : 58                         clt.i32
	<.main+7319 @065683> : 0b                         not.b32
	<.main+7320 @065684> : 1f f0 32 06 00             load.ref <@0632f0> ;i16Cge
	<.main+7325 @065689> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:122: (11 bytes: <.main+7326 @06568a> - <.main+7337 @065695>): static u16A: uint16 := a
	<.main+7326 @06568a> : 1c 60 00 00 00             load.c32 96
	<.main+7331 @06568f> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7336 @065694> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:123: (11 bytes: <.main+7337 @065695> - <.main+7348 @0656a0>): static u16B: uint16 := b
	<.main+7337 @065695> : 1c 2a 00 00 00             load.c32 42
	<.main+7342 @06569a> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7347 @06569f> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:124: (12 bytes: <.main+7348 @0656a0> - <.main+7360 @0656ac>): static u16Pls: uint16 := +u16B
	<.main+7348 @0656a0> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7353 @0656a5> : 27                         load.i16
	<.main+7354 @0656a6> : 1f 08 33 06 00             load.ref <@063308> ;u16Pls
	<.main+7359 @0656ab> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:125: (13 bytes: <.main+7360 @0656ac> - <.main+7373 @0656b9>): static u16Neg: uint16 := -u16B
	<.main+7360 @0656ac> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7365 @0656b1> : 27                         load.i16
	<.main+7366 @0656b2> : 50                         neg.i32
	<.main+7367 @0656b3> : 1f 10 33 06 00             load.ref <@063310> ;u16Neg
	<.main+7372 @0656b8> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:126: (13 bytes: <.main+7373 @0656b9> - <.main+7386 @0656c6>): static u16Cmt: uint16 := ~u16B
	<.main+7373 @0656b9> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7378 @0656be> : 27                         load.i16
	<.main+7379 @0656bf> : 30                         cmt.b32
	<.main+7380 @0656c0> : 1f 18 33 06 00             load.ref <@063318> ;u16Cmt
	<.main+7385 @0656c5> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:127: (19 bytes: <.main+7386 @0656c6> - <.main+7405 @0656d9>): static u16Add: uint16 := u16A + u16B
	<.main+7386 @0656c6> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7391 @0656cb> : 27                         load.i16
	<.main+7392 @0656cc> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7397 @0656d1> : 27                         load.i16
	<.main+7398 @0656d2> : 51                         add.i32
	<.main+7399 @0656d3> : 1f 20 33 06 00             load.ref <@063320> ;u16Add
	<.main+7404 @0656d8> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:128: (19 bytes: <.main+7405 @0656d9> - <.main+7424 @0656ec>): static u16Sub: uint16 := u16A - u16B
	<.main+7405 @0656d9> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7410 @0656de> : 27                         load.i16
	<.main+7411 @0656df> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7416 @0656e4> : 27                         load.i16
	<.main+7417 @0656e5> : 52                         sub.i32
	<.main+7418 @0656e6> : 1f 28 33 06 00             load.ref <@063328> ;u16Sub
	<.main+7423 @0656eb> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:129: (19 bytes: <.main+7424 @0656ec> - <.main+7443 @0656ff>): static u16Mul: uint16 := u16A * u16B
	<.main+7424 @0656ec> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7429 @0656f1> : 27                         load.i16
	<.main+7430 @0656f2> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7435 @0656f7> : 27                         load.i16
	<.main+7436 @0656f8> : 33                         mul.u32
	<.main+7437 @0656f9> : 1f 30 33 06 00             load.ref <@063330> ;u16Mul
	<.main+7442 @0656fe> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:130: (19 bytes: <.main+7443 @0656ff> - <.main+7462 @065712>): static u16Div: uint16 := u16A / u16B
	<.main+7443 @0656ff> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7448 @065704> : 27                         load.i16
	<.main+7449 @065705> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7454 @06570a> : 27                         load.i16
	<.main+7455 @06570b> : 34                         div.u32
	<.main+7456 @06570c> : 1f 38 33 06 00             load.ref <@063338> ;u16Div
	<.main+7461 @065711> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:131: (19 bytes: <.main+7462 @065712> - <.main+7481 @065725>): static u16Mod: uint16 := u16A % u16B
	<.main+7462 @065712> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7467 @065717> : 27                         load.i16
	<.main+7468 @065718> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7473 @06571d> : 27                         load.i16
	<.main+7474 @06571e> : 35                         mod.u32
	<.main+7475 @06571f> : 1f 40 33 06 00             load.ref <@063340> ;u16Mod
	<.main+7480 @065724> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:132: (19 bytes: <.main+7481 @065725> - <.main+7500 @065738>): static u16And: uint16 := u16A & u16B
	<.main+7481 @065725> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7486 @06572a> : 27                         load.i16
	<.main+7487 @06572b> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7492 @065730> : 27                         load.i16
	<.main+7493 @065731> : 31                         and.b32
	<.main+7494 @065732> : 1f 48 33 06 00             load.ref <@063348> ;u16And
	<.main+7499 @065737> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:133: (19 bytes: <.main+7500 @065738> - <.main+7519 @06574b>): static u16Ior: uint16 := u16A | u16B
	<.main+7500 @065738> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7505 @06573d> : 27                         load.i16
	<.main+7506 @06573e> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7511 @065743> : 27                         load.i16
	<.main+7512 @065744> : 32                         or.b32
	<.main+7513 @065745> : 1f 50 33 06 00             load.ref <@063350> ;u16Ior
	<.main+7518 @06574a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:134: (19 bytes: <.main+7519 @06574b> - <.main+7538 @06575e>): static u16Xor: uint16 := u16A ^ u16B
	<.main+7519 @06574b> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7524 @065750> : 27                         load.i16
	<.main+7525 @065751> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7530 @065756> : 27                         load.i16
	<.main+7531 @065757> : 36                         xor.b32
	<.main+7532 @065758> : 1f 58 33 06 00             load.ref <@063358> ;u16Xor
	<.main+7537 @06575d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:135: (17 bytes: <.main+7538 @06575e> - <.main+7555 @06576f>): static u16Shl: uint16 := (u16A) << shift
	<.main+7538 @06575e> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7543 @065763> : 27                         load.i16
	<.main+7544 @065764> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+7548 @065768> : 3a                         shl.b32
	<.main+7549 @065769> : 1f 60 33 06 00             load.ref <@063360> ;u16Shl
	<.main+7554 @06576e> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:136: (17 bytes: <.main+7555 @06576f> - <.main+7572 @065780>): static u16Shr: uint16 := (u16A) >> shift
	<.main+7555 @06576f> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7560 @065774> : 27                         load.i16
	<.main+7561 @065775> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+7565 @065779> : 3c                         sar.b32
	<.main+7566 @06577a> : 1f 68 33 06 00             load.ref <@063368> ;u16Shr
	<.main+7571 @06577f> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:137: (14 bytes: <.main+7572 @065780> - <.main+7586 @06578e>): static u16Not: bool := !(u16B)
	<.main+7572 @065780> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7577 @065785> : 27                         load.i16
	<.main+7578 @065786> : 5a                         i32.2bool
	<.main+7579 @065787> : 0b                         not.b32
	<.main+7580 @065788> : 1f 70 33 06 00             load.ref <@063370> ;u16Not
	<.main+7585 @06578d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:138: (19 bytes: <.main+7586 @06578e> - <.main+7605 @0657a1>): static u16Ceq: bool := u16A == u16B
	<.main+7586 @06578e> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7591 @065793> : 27                         load.i16
	<.main+7592 @065794> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7597 @065799> : 27                         load.i16
	<.main+7598 @06579a> : 57                         ceq.i32
	<.main+7599 @06579b> : 1f 78 33 06 00             load.ref <@063378> ;u16Ceq
	<.main+7604 @0657a0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:139: (20 bytes: <.main+7605 @0657a1> - <.main+7625 @0657b5>): static u16Cne: bool := u16A != u16B
	<.main+7605 @0657a1> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7610 @0657a6> : 27                         load.i16
	<.main+7611 @0657a7> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7616 @0657ac> : 27                         load.i16
	<.main+7617 @0657ad> : 57                         ceq.i32
	<.main+7618 @0657ae> : 0b                         not.b32
	<.main+7619 @0657af> : 1f 80 33 06 00             load.ref <@063380> ;u16Cne
	<.main+7624 @0657b4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:140: (19 bytes: <.main+7625 @0657b5> - <.main+7644 @0657c8>): static u16Clt: bool := u16A < u16B
	<.main+7625 @0657b5> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7630 @0657ba> : 27                         load.i16
	<.main+7631 @0657bb> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7636 @0657c0> : 27                         load.i16
	<.main+7637 @0657c1> : 38                         clt.u32
	<.main+7638 @0657c2> : 1f 88 33 06 00             load.ref <@063388> ;u16Clt
	<.main+7643 @0657c7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:141: (20 bytes: <.main+7644 @0657c8> - <.main+7664 @0657dc>): static u16Cle: bool := u16A <= u16B
	<.main+7644 @0657c8> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7649 @0657cd> : 27                         load.i16
	<.main+7650 @0657ce> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7655 @0657d3> : 27                         load.i16
	<.main+7656 @0657d4> : 39                         cgt.u32
	<.main+7657 @0657d5> : 0b                         not.b32
	<.main+7658 @0657d6> : 1f 90 33 06 00             load.ref <@063390> ;u16Cle
	<.main+7663 @0657db> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:142: (19 bytes: <.main+7664 @0657dc> - <.main+7683 @0657ef>): static u16Cgt: bool := u16A > u16B
	<.main+7664 @0657dc> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7669 @0657e1> : 27                         load.i16
	<.main+7670 @0657e2> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7675 @0657e7> : 27                         load.i16
	<.main+7676 @0657e8> : 39                         cgt.u32
	<.main+7677 @0657e9> : 1f 98 33 06 00             load.ref <@063398> ;u16Cgt
	<.main+7682 @0657ee> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:143: (20 bytes: <.main+7683 @0657ef> - <.main+7703 @065803>): static u16Cge: bool := u16A >= u16B
	<.main+7683 @0657ef> : 1f f8 32 06 00             load.ref <@0632f8> ;u16A
	<.main+7688 @0657f4> : 27                         load.i16
	<.main+7689 @0657f5> : 1f 00 33 06 00             load.ref <@063300> ;u16B
	<.main+7694 @0657fa> : 27                         load.i16
	<.main+7695 @0657fb> : 38                         clt.u32
	<.main+7696 @0657fc> : 0b                         not.b32
	<.main+7697 @0657fd> : 1f a0 33 06 00             load.ref <@0633a0> ;u16Cge
	<.main+7702 @065802> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:145: (9 bytes: <.main+7703 @065803> - <.main+7712 @06580c>): static i32A: int32 := a
	<.main+7703 @065803> : 1c 60 00 00 00             load.c32 96
	<.main+7708 @065808> : 24 a8 33 06                store.m32 <@0633a8> ;i32A
	cmplStd/test/lang/useOperator.ci:146: (9 bytes: <.main+7712 @06580c> - <.main+7721 @065815>): static i32B: int32 := b
	<.main+7712 @06580c> : 1c 2a 00 00 00             load.c32 42
	<.main+7717 @065811> : 24 b0 33 06                store.m32 <@0633b0> ;i32B
	cmplStd/test/lang/useOperator.ci:147: (8 bytes: <.main+7721 @065815> - <.main+7729 @06581d>): static i32Pls: int32 := +i32B
	<.main+7721 @065815> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7725 @065819> : 24 b8 33 06                store.m32 <@0633b8> ;i32Pls
	cmplStd/test/lang/useOperator.ci:148: (9 bytes: <.main+7729 @06581d> - <.main+7738 @065826>): static i32Neg: int32 := -i32B
	<.main+7729 @06581d> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7733 @065821> : 50                         neg.i32
	<.main+7734 @065822> : 24 c0 33 06                store.m32 <@0633c0> ;i32Neg
	cmplStd/test/lang/useOperator.ci:149: (9 bytes: <.main+7738 @065826> - <.main+7747 @06582f>): static i32Cmt: int32 := ~i32B
	<.main+7738 @065826> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7742 @06582a> : 30                         cmt.b32
	<.main+7743 @06582b> : 24 c8 33 06                store.m32 <@0633c8> ;i32Cmt
	cmplStd/test/lang/useOperator.ci:150: (13 bytes: <.main+7747 @06582f> - <.main+7760 @06583c>): static i32Add: int32 := i32A + i32B
	<.main+7747 @06582f> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7751 @065833> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7755 @065837> : 51                         add.i32
	<.main+7756 @065838> : 24 d0 33 06                store.m32 <@0633d0> ;i32Add
	cmplStd/test/lang/useOperator.ci:151: (13 bytes: <.main+7760 @06583c> - <.main+7773 @065849>): static i32Sub: int32 := i32A - i32B
	<.main+7760 @06583c> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7764 @065840> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7768 @065844> : 52                         sub.i32
	<.main+7769 @065845> : 24 d8 33 06                store.m32 <@0633d8> ;i32Sub
	cmplStd/test/lang/useOperator.ci:152: (13 bytes: <.main+7773 @065849> - <.main+7786 @065856>): static i32Mul: int32 := i32A * i32B
	<.main+7773 @065849> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7777 @06584d> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7781 @065851> : 53                         mul.i32
	<.main+7782 @065852> : 24 e0 33 06                store.m32 <@0633e0> ;i32Mul
	cmplStd/test/lang/useOperator.ci:153: (13 bytes: <.main+7786 @065856> - <.main+7799 @065863>): static i32Div: int32 := i32A / i32B
	<.main+7786 @065856> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7790 @06585a> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7794 @06585e> : 54                         div.i32
	<.main+7795 @06585f> : 24 e8 33 06                store.m32 <@0633e8> ;i32Div
	cmplStd/test/lang/useOperator.ci:154: (13 bytes: <.main+7799 @065863> - <.main+7812 @065870>): static i32Mod: int32 := i32A % i32B
	<.main+7799 @065863> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7803 @065867> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7807 @06586b> : 55                         mod.i32
	<.main+7808 @06586c> : 24 f0 33 06                store.m32 <@0633f0> ;i32Mod
	cmplStd/test/lang/useOperator.ci:155: (13 bytes: <.main+7812 @065870> - <.main+7825 @06587d>): static i32And: int32 := i32A & i32B
	<.main+7812 @065870> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7816 @065874> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7820 @065878> : 31                         and.b32
	<.main+7821 @065879> : 24 f8 33 06                store.m32 <@0633f8> ;i32And
	cmplStd/test/lang/useOperator.ci:156: (13 bytes: <.main+7825 @06587d> - <.main+7838 @06588a>): static i32Ior: int32 := i32A | i32B
	<.main+7825 @06587d> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7829 @065881> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7833 @065885> : 32                         or.b32
	<.main+7834 @065886> : 24 00 34 06                store.m32 <@063400> ;i32Ior
	cmplStd/test/lang/useOperator.ci:157: (13 bytes: <.main+7838 @06588a> - <.main+7851 @065897>): static i32Xor: int32 := i32A ^ i32B
	<.main+7838 @06588a> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7842 @06588e> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7846 @065892> : 36                         xor.b32
	<.main+7847 @065893> : 24 08 34 06                store.m32 <@063408> ;i32Xor
	cmplStd/test/lang/useOperator.ci:158: (13 bytes: <.main+7851 @065897> - <.main+7864 @0658a4>): static i32Shl: int32 := i32A << shift
	<.main+7851 @065897> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7855 @06589b> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+7859 @06589f> : 3a                         shl.b32
	<.main+7860 @0658a0> : 24 10 34 06                store.m32 <@063410> ;i32Shl
	cmplStd/test/lang/useOperator.ci:159: (13 bytes: <.main+7864 @0658a4> - <.main+7877 @0658b1>): static i32Shr: int32 := i32A >> shift
	<.main+7864 @0658a4> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7868 @0658a8> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+7872 @0658ac> : 3c                         sar.b32
	<.main+7873 @0658ad> : 24 18 34 06                store.m32 <@063418> ;i32Shr
	cmplStd/test/lang/useOperator.ci:160: (12 bytes: <.main+7877 @0658b1> - <.main+7889 @0658bd>): static i32Not: bool := !(i32B)
	<.main+7877 @0658b1> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7881 @0658b5> : 5a                         i32.2bool
	<.main+7882 @0658b6> : 0b                         not.b32
	<.main+7883 @0658b7> : 1f 20 34 06 00             load.ref <@063420> ;i32Not
	<.main+7888 @0658bc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:161: (15 bytes: <.main+7889 @0658bd> - <.main+7904 @0658cc>): static i32Ceq: bool := i32A == i32B
	<.main+7889 @0658bd> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7893 @0658c1> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7897 @0658c5> : 57                         ceq.i32
	<.main+7898 @0658c6> : 1f 28 34 06 00             load.ref <@063428> ;i32Ceq
	<.main+7903 @0658cb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:162: (16 bytes: <.main+7904 @0658cc> - <.main+7920 @0658dc>): static i32Cne: bool := i32A != i32B
	<.main+7904 @0658cc> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7908 @0658d0> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7912 @0658d4> : 57                         ceq.i32
	<.main+7913 @0658d5> : 0b                         not.b32
	<.main+7914 @0658d6> : 1f 30 34 06 00             load.ref <@063430> ;i32Cne
	<.main+7919 @0658db> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:163: (15 bytes: <.main+7920 @0658dc> - <.main+7935 @0658eb>): static i32Clt: bool := i32A < i32B
	<.main+7920 @0658dc> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7924 @0658e0> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7928 @0658e4> : 58                         clt.i32
	<.main+7929 @0658e5> : 1f 38 34 06 00             load.ref <@063438> ;i32Clt
	<.main+7934 @0658ea> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:164: (16 bytes: <.main+7935 @0658eb> - <.main+7951 @0658fb>): static i32Cle: bool := i32A <= i32B
	<.main+7935 @0658eb> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7939 @0658ef> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7943 @0658f3> : 59                         cgt.i32
	<.main+7944 @0658f4> : 0b                         not.b32
	<.main+7945 @0658f5> : 1f 40 34 06 00             load.ref <@063440> ;i32Cle
	<.main+7950 @0658fa> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:165: (15 bytes: <.main+7951 @0658fb> - <.main+7966 @06590a>): static i32Cgt: bool := i32A > i32B
	<.main+7951 @0658fb> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7955 @0658ff> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7959 @065903> : 59                         cgt.i32
	<.main+7960 @065904> : 1f 48 34 06 00             load.ref <@063448> ;i32Cgt
	<.main+7965 @065909> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:166: (16 bytes: <.main+7966 @06590a> - <.main+7982 @06591a>): static i32Cge: bool := i32A >= i32B
	<.main+7966 @06590a> : 20 a8 33 06                load.m32 <@0633a8> ;i32A
	<.main+7970 @06590e> : 20 b0 33 06                load.m32 <@0633b0> ;i32B
	<.main+7974 @065912> : 58                         clt.i32
	<.main+7975 @065913> : 0b                         not.b32
	<.main+7976 @065914> : 1f 50 34 06 00             load.ref <@063450> ;i32Cge
	<.main+7981 @065919> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:168: (9 bytes: <.main+7982 @06591a> - <.main+7991 @065923>): static u32A: uint32 := a
	<.main+7982 @06591a> : 1c 60 00 00 00             load.c32 96
	<.main+7987 @06591f> : 24 58 34 06                store.m32 <@063458> ;u32A
	cmplStd/test/lang/useOperator.ci:169: (9 bytes: <.main+7991 @065923> - <.main+8000 @06592c>): static u32B: uint32 := b
	<.main+7991 @065923> : 1c 2a 00 00 00             load.c32 42
	<.main+7996 @065928> : 24 60 34 06                store.m32 <@063460> ;u32B
	cmplStd/test/lang/useOperator.ci:170: (8 bytes: <.main+8000 @06592c> - <.main+8008 @065934>): static u32Pls: uint32 := +u32B
	<.main+8000 @06592c> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8004 @065930> : 24 68 34 06                store.m32 <@063468> ;u32Pls
	cmplStd/test/lang/useOperator.ci:171: (9 bytes: <.main+8008 @065934> - <.main+8017 @06593d>): static u32Neg: uint32 := -u32B
	<.main+8008 @065934> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8012 @065938> : 50                         neg.i32
	<.main+8013 @065939> : 24 70 34 06                store.m32 <@063470> ;u32Neg
	cmplStd/test/lang/useOperator.ci:172: (9 bytes: <.main+8017 @06593d> - <.main+8026 @065946>): static u32Cmt: uint32 := ~u32B
	<.main+8017 @06593d> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8021 @065941> : 30                         cmt.b32
	<.main+8022 @065942> : 24 78 34 06                store.m32 <@063478> ;u32Cmt
	cmplStd/test/lang/useOperator.ci:173: (13 bytes: <.main+8026 @065946> - <.main+8039 @065953>): static u32Add: uint32 := u32A + u32B
	<.main+8026 @065946> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8030 @06594a> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8034 @06594e> : 51                         add.i32
	<.main+8035 @06594f> : 24 80 34 06                store.m32 <@063480> ;u32Add
	cmplStd/test/lang/useOperator.ci:174: (13 bytes: <.main+8039 @065953> - <.main+8052 @065960>): static u32Sub: uint32 := u32A - u32B
	<.main+8039 @065953> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8043 @065957> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8047 @06595b> : 52                         sub.i32
	<.main+8048 @06595c> : 24 88 34 06                store.m32 <@063488> ;u32Sub
	cmplStd/test/lang/useOperator.ci:175: (13 bytes: <.main+8052 @065960> - <.main+8065 @06596d>): static u32Mul: uint32 := u32A * u32B
	<.main+8052 @065960> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8056 @065964> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8060 @065968> : 33                         mul.u32
	<.main+8061 @065969> : 24 90 34 06                store.m32 <@063490> ;u32Mul
	cmplStd/test/lang/useOperator.ci:176: (13 bytes: <.main+8065 @06596d> - <.main+8078 @06597a>): static u32Div: uint32 := u32A / u32B
	<.main+8065 @06596d> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8069 @065971> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8073 @065975> : 34                         div.u32
	<.main+8074 @065976> : 24 98 34 06                store.m32 <@063498> ;u32Div
	cmplStd/test/lang/useOperator.ci:177: (13 bytes: <.main+8078 @06597a> - <.main+8091 @065987>): static u32Mod: uint32 := u32A % u32B
	<.main+8078 @06597a> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8082 @06597e> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8086 @065982> : 35                         mod.u32
	<.main+8087 @065983> : 24 a0 34 06                store.m32 <@0634a0> ;u32Mod
	cmplStd/test/lang/useOperator.ci:178: (13 bytes: <.main+8091 @065987> - <.main+8104 @065994>): static u32And: uint32 := u32A & u32B
	<.main+8091 @065987> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8095 @06598b> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8099 @06598f> : 31                         and.b32
	<.main+8100 @065990> : 24 a8 34 06                store.m32 <@0634a8> ;u32And
	cmplStd/test/lang/useOperator.ci:179: (13 bytes: <.main+8104 @065994> - <.main+8117 @0659a1>): static u32Ior: uint32 := u32A | u32B
	<.main+8104 @065994> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8108 @065998> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8112 @06599c> : 32                         or.b32
	<.main+8113 @06599d> : 24 b0 34 06                store.m32 <@0634b0> ;u32Ior
	cmplStd/test/lang/useOperator.ci:180: (13 bytes: <.main+8117 @0659a1> - <.main+8130 @0659ae>): static u32Xor: uint32 := u32A ^ u32B
	<.main+8117 @0659a1> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8121 @0659a5> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8125 @0659a9> : 36                         xor.b32
	<.main+8126 @0659aa> : 24 b8 34 06                store.m32 <@0634b8> ;u32Xor
	cmplStd/test/lang/useOperator.ci:181: (13 bytes: <.main+8130 @0659ae> - <.main+8143 @0659bb>): static u32Shl: uint32 := u32A << shift
	<.main+8130 @0659ae> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8134 @0659b2> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+8138 @0659b6> : 3a                         shl.b32
	<.main+8139 @0659b7> : 24 c0 34 06                store.m32 <@0634c0> ;u32Shl
	cmplStd/test/lang/useOperator.ci:182: (13 bytes: <.main+8143 @0659bb> - <.main+8156 @0659c8>): static u32Shr: uint32 := u32A >> shift
	<.main+8143 @0659bb> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8147 @0659bf> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+8151 @0659c3> : 3b                         shr.b32
	<.main+8152 @0659c4> : 24 c8 34 06                store.m32 <@0634c8> ;u32Shr
	cmplStd/test/lang/useOperator.ci:183: (12 bytes: <.main+8156 @0659c8> - <.main+8168 @0659d4>): static u32Not: bool := !(u32B)
	<.main+8156 @0659c8> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8160 @0659cc> : 5a                         i32.2bool
	<.main+8161 @0659cd> : 0b                         not.b32
	<.main+8162 @0659ce> : 1f d0 34 06 00             load.ref <@0634d0> ;u32Not
	<.main+8167 @0659d3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:184: (15 bytes: <.main+8168 @0659d4> - <.main+8183 @0659e3>): static u32Ceq: bool := u32A == u32B
	<.main+8168 @0659d4> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8172 @0659d8> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8176 @0659dc> : 57                         ceq.i32
	<.main+8177 @0659dd> : 1f d8 34 06 00             load.ref <@0634d8> ;u32Ceq
	<.main+8182 @0659e2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:185: (16 bytes: <.main+8183 @0659e3> - <.main+8199 @0659f3>): static u32Cne: bool := u32A != u32B
	<.main+8183 @0659e3> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8187 @0659e7> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8191 @0659eb> : 57                         ceq.i32
	<.main+8192 @0659ec> : 0b                         not.b32
	<.main+8193 @0659ed> : 1f e0 34 06 00             load.ref <@0634e0> ;u32Cne
	<.main+8198 @0659f2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:186: (15 bytes: <.main+8199 @0659f3> - <.main+8214 @065a02>): static u32Clt: bool := u32A < u32B
	<.main+8199 @0659f3> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8203 @0659f7> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8207 @0659fb> : 38                         clt.u32
	<.main+8208 @0659fc> : 1f e8 34 06 00             load.ref <@0634e8> ;u32Clt
	<.main+8213 @065a01> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:187: (16 bytes: <.main+8214 @065a02> - <.main+8230 @065a12>): static u32Cle: bool := u32A <= u32B
	<.main+8214 @065a02> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8218 @065a06> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8222 @065a0a> : 39                         cgt.u32
	<.main+8223 @065a0b> : 0b                         not.b32
	<.main+8224 @065a0c> : 1f f0 34 06 00             load.ref <@0634f0> ;u32Cle
	<.main+8229 @065a11> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:188: (15 bytes: <.main+8230 @065a12> - <.main+8245 @065a21>): static u32Cgt: bool := u32A > u32B
	<.main+8230 @065a12> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8234 @065a16> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8238 @065a1a> : 39                         cgt.u32
	<.main+8239 @065a1b> : 1f f8 34 06 00             load.ref <@0634f8> ;u32Cgt
	<.main+8244 @065a20> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:189: (16 bytes: <.main+8245 @065a21> - <.main+8261 @065a31>): static u32Cge: bool := u32A >= u32B
	<.main+8245 @065a21> : 20 58 34 06                load.m32 <@063458> ;u32A
	<.main+8249 @065a25> : 20 60 34 06                load.m32 <@063460> ;u32B
	<.main+8253 @065a29> : 38                         clt.u32
	<.main+8254 @065a2a> : 0b                         not.b32
	<.main+8255 @065a2b> : 1f 00 35 06 00             load.ref <@063500> ;u32Cge
	<.main+8260 @065a30> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:191: (13 bytes: <.main+8261 @065a31> - <.main+8274 @065a3e>): static i64A: int64 := a
	<.main+8261 @065a31> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8270 @065a3a> : 23 08 35 06                store.m64 <@063508> ;i64A
	cmplStd/test/lang/useOperator.ci:192: (13 bytes: <.main+8274 @065a3e> - <.main+8287 @065a4b>): static i64B: int64 := b
	<.main+8274 @065a3e> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8283 @065a47> : 23 10 35 06                store.m64 <@063510> ;i64B
	cmplStd/test/lang/useOperator.ci:193: (8 bytes: <.main+8287 @065a4b> - <.main+8295 @065a53>): static i64Pls: int64 := +i64B
	<.main+8287 @065a4b> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8291 @065a4f> : 23 18 35 06                store.m64 <@063518> ;i64Pls
	cmplStd/test/lang/useOperator.ci:194: (9 bytes: <.main+8295 @065a53> - <.main+8304 @065a5c>): static i64Neg: int64 := -i64B
	<.main+8295 @065a53> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8299 @065a57> : 60                         neg.i64
	<.main+8300 @065a58> : 23 20 35 06                store.m64 <@063520> ;i64Neg
	cmplStd/test/lang/useOperator.ci:195: (9 bytes: <.main+8304 @065a5c> - <.main+8313 @065a65>): static i64Cmt: int64 := ~i64B
	<.main+8304 @065a5c> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8308 @065a60> : 40                         cmt.b64
	<.main+8309 @065a61> : 23 28 35 06                store.m64 <@063528> ;i64Cmt
	cmplStd/test/lang/useOperator.ci:196: (13 bytes: <.main+8313 @065a65> - <.main+8326 @065a72>): static i64Add: int64 := i64A + i64B
	<.main+8313 @065a65> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8317 @065a69> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8321 @065a6d> : 61                         add.i64
	<.main+8322 @065a6e> : 23 30 35 06                store.m64 <@063530> ;i64Add
	cmplStd/test/lang/useOperator.ci:197: (13 bytes: <.main+8326 @065a72> - <.main+8339 @065a7f>): static i64Sub: int64 := i64A - i64B
	<.main+8326 @065a72> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8330 @065a76> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8334 @065a7a> : 62                         sub.i64
	<.main+8335 @065a7b> : 23 38 35 06                store.m64 <@063538> ;i64Sub
	cmplStd/test/lang/useOperator.ci:198: (13 bytes: <.main+8339 @065a7f> - <.main+8352 @065a8c>): static i64Mul: int64 := i64A * i64B
	<.main+8339 @065a7f> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8343 @065a83> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8347 @065a87> : 63                         mul.i64
	<.main+8348 @065a88> : 23 40 35 06                store.m64 <@063540> ;i64Mul
	cmplStd/test/lang/useOperator.ci:199: (13 bytes: <.main+8352 @065a8c> - <.main+8365 @065a99>): static i64Div: int64 := i64A / i64B
	<.main+8352 @065a8c> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8356 @065a90> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8360 @065a94> : 64                         div.i64
	<.main+8361 @065a95> : 23 48 35 06                store.m64 <@063548> ;i64Div
	cmplStd/test/lang/useOperator.ci:200: (13 bytes: <.main+8365 @065a99> - <.main+8378 @065aa6>): static i64Mod: int64 := i64A % i64B
	<.main+8365 @065a99> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8369 @065a9d> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8373 @065aa1> : 65                         mod.i64
	<.main+8374 @065aa2> : 23 50 35 06                store.m64 <@063550> ;i64Mod
	cmplStd/test/lang/useOperator.ci:201: (13 bytes: <.main+8378 @065aa6> - <.main+8391 @065ab3>): static i64And: int64 := i64A & i64B
	<.main+8378 @065aa6> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8382 @065aaa> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8386 @065aae> : 41                         and.b64
	<.main+8387 @065aaf> : 23 58 35 06                store.m64 <@063558> ;i64And
	cmplStd/test/lang/useOperator.ci:202: (13 bytes: <.main+8391 @065ab3> - <.main+8404 @065ac0>): static i64Ior: int64 := i64A | i64B
	<.main+8391 @065ab3> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8395 @065ab7> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8399 @065abb> : 42                         or.b64
	<.main+8400 @065abc> : 23 60 35 06                store.m64 <@063560> ;i64Ior
	cmplStd/test/lang/useOperator.ci:203: (13 bytes: <.main+8404 @065ac0> - <.main+8417 @065acd>): static i64Xor: int64 := i64A ^ i64B
	<.main+8404 @065ac0> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8408 @065ac4> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8412 @065ac8> : 46                         xor.b64
	<.main+8413 @065ac9> : 23 68 35 06                store.m64 <@063568> ;i64Xor
	cmplStd/test/lang/useOperator.ci:204: (13 bytes: <.main+8417 @065acd> - <.main+8430 @065ada>): static i64Shl: int64 := i64A << shift
	<.main+8417 @065acd> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8421 @065ad1> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+8425 @065ad5> : 4a                         shl.b64
	<.main+8426 @065ad6> : 23 70 35 06                store.m64 <@063570> ;i64Shl
	cmplStd/test/lang/useOperator.ci:205: (13 bytes: <.main+8430 @065ada> - <.main+8443 @065ae7>): static i64Shr: int64 := i64A >> shift
	<.main+8430 @065ada> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8434 @065ade> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+8438 @065ae2> : 4c                         sar.b64
	<.main+8439 @065ae3> : 23 78 35 06                store.m64 <@063578> ;i64Shr
	cmplStd/test/lang/useOperator.ci:206: (12 bytes: <.main+8443 @065ae7> - <.main+8455 @065af3>): static i64Not: bool := !(i64B)
	<.main+8443 @065ae7> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8447 @065aeb> : 6b                         i64.2bool
	<.main+8448 @065aec> : 0b                         not.b32
	<.main+8449 @065aed> : 1f 80 35 06 00             load.ref <@063580> ;i64Not
	<.main+8454 @065af2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:207: (15 bytes: <.main+8455 @065af3> - <.main+8470 @065b02>): static i64Ceq: bool := i64A == i64B
	<.main+8455 @065af3> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8459 @065af7> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8463 @065afb> : 67                         ceq.i64
	<.main+8464 @065afc> : 1f 88 35 06 00             load.ref <@063588> ;i64Ceq
	<.main+8469 @065b01> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:208: (16 bytes: <.main+8470 @065b02> - <.main+8486 @065b12>): static i64Cne: bool := i64A != i64B
	<.main+8470 @065b02> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8474 @065b06> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8478 @065b0a> : 67                         ceq.i64
	<.main+8479 @065b0b> : 0b                         not.b32
	<.main+8480 @065b0c> : 1f 90 35 06 00             load.ref <@063590> ;i64Cne
	<.main+8485 @065b11> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:209: (15 bytes: <.main+8486 @065b12> - <.main+8501 @065b21>): static i64Clt: bool := i64A < i64B
	<.main+8486 @065b12> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8490 @065b16> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8494 @065b1a> : 68                         clt.i64
	<.main+8495 @065b1b> : 1f 98 35 06 00             load.ref <@063598> ;i64Clt
	<.main+8500 @065b20> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:210: (16 bytes: <.main+8501 @065b21> - <.main+8517 @065b31>): static i64Cle: bool := i64A <= i64B
	<.main+8501 @065b21> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8505 @065b25> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8509 @065b29> : 69                         cgt.i64
	<.main+8510 @065b2a> : 0b                         not.b32
	<.main+8511 @065b2b> : 1f a0 35 06 00             load.ref <@0635a0> ;i64Cle
	<.main+8516 @065b30> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:211: (15 bytes: <.main+8517 @065b31> - <.main+8532 @065b40>): static i64Cgt: bool := i64A > i64B
	<.main+8517 @065b31> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8521 @065b35> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8525 @065b39> : 69                         cgt.i64
	<.main+8526 @065b3a> : 1f a8 35 06 00             load.ref <@0635a8> ;i64Cgt
	<.main+8531 @065b3f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:212: (16 bytes: <.main+8532 @065b40> - <.main+8548 @065b50>): static i64Cge: bool := i64A >= i64B
	<.main+8532 @065b40> : 21 08 35 06                load.m64 <@063508> ;i64A
	<.main+8536 @065b44> : 21 10 35 06                load.m64 <@063510> ;i64B
	<.main+8540 @065b48> : 68                         clt.i64
	<.main+8541 @065b49> : 0b                         not.b32
	<.main+8542 @065b4a> : 1f b0 35 06 00             load.ref <@0635b0> ;i64Cge
	<.main+8547 @065b4f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:214: (13 bytes: <.main+8548 @065b50> - <.main+8561 @065b5d>): static u64A: uint64 := a
	<.main+8548 @065b50> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8557 @065b59> : 23 b8 35 06                store.m64 <@0635b8> ;u64A
	cmplStd/test/lang/useOperator.ci:215: (13 bytes: <.main+8561 @065b5d> - <.main+8574 @065b6a>): static u64B: uint64 := b
	<.main+8561 @065b5d> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8570 @065b66> : 23 c0 35 06                store.m64 <@0635c0> ;u64B
	cmplStd/test/lang/useOperator.ci:216: (8 bytes: <.main+8574 @065b6a> - <.main+8582 @065b72>): static u64Pls: uint64 := +u64B
	<.main+8574 @065b6a> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8578 @065b6e> : 23 c8 35 06                store.m64 <@0635c8> ;u64Pls
	cmplStd/test/lang/useOperator.ci:217: (9 bytes: <.main+8582 @065b72> - <.main+8591 @065b7b>): static u64Neg: uint64 := -u64B
	<.main+8582 @065b72> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8586 @065b76> : 60                         neg.i64
	<.main+8587 @065b77> : 23 d0 35 06                store.m64 <@0635d0> ;u64Neg
	cmplStd/test/lang/useOperator.ci:218: (9 bytes: <.main+8591 @065b7b> - <.main+8600 @065b84>): static u64Cmt: uint64 := ~u64B
	<.main+8591 @065b7b> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8595 @065b7f> : 40                         cmt.b64
	<.main+8596 @065b80> : 23 d8 35 06                store.m64 <@0635d8> ;u64Cmt
	cmplStd/test/lang/useOperator.ci:219: (13 bytes: <.main+8600 @065b84> - <.main+8613 @065b91>): static u64Add: uint64 := u64A + u64B
	<.main+8600 @065b84> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8604 @065b88> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8608 @065b8c> : 61                         add.i64
	<.main+8609 @065b8d> : 23 e0 35 06                store.m64 <@0635e0> ;u64Add
	cmplStd/test/lang/useOperator.ci:220: (13 bytes: <.main+8613 @065b91> - <.main+8626 @065b9e>): static u64Sub: uint64 := u64A - u64B
	<.main+8613 @065b91> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8617 @065b95> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8621 @065b99> : 62                         sub.i64
	<.main+8622 @065b9a> : 23 e8 35 06                store.m64 <@0635e8> ;u64Sub
	cmplStd/test/lang/useOperator.ci:221: (13 bytes: <.main+8626 @065b9e> - <.main+8639 @065bab>): static u64Mul: uint64 := u64A * u64B
	<.main+8626 @065b9e> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8630 @065ba2> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8634 @065ba6> : 43                         mul.u64
	<.main+8635 @065ba7> : 23 f0 35 06                store.m64 <@0635f0> ;u64Mul
	cmplStd/test/lang/useOperator.ci:222: (13 bytes: <.main+8639 @065bab> - <.main+8652 @065bb8>): static u64Div: uint64 := u64A / u64B
	<.main+8639 @065bab> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8643 @065baf> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8647 @065bb3> : 44                         div.u64
	<.main+8648 @065bb4> : 23 f8 35 06                store.m64 <@0635f8> ;u64Div
	cmplStd/test/lang/useOperator.ci:223: (13 bytes: <.main+8652 @065bb8> - <.main+8665 @065bc5>): static u64Mod: uint64 := u64A % u64B
	<.main+8652 @065bb8> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8656 @065bbc> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8660 @065bc0> : 45                         mod.u64
	<.main+8661 @065bc1> : 23 00 36 06                store.m64 <@063600> ;u64Mod
	cmplStd/test/lang/useOperator.ci:224: (13 bytes: <.main+8665 @065bc5> - <.main+8678 @065bd2>): static u64And: uint64 := u64A & u64B
	<.main+8665 @065bc5> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8669 @065bc9> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8673 @065bcd> : 41                         and.b64
	<.main+8674 @065bce> : 23 08 36 06                store.m64 <@063608> ;u64And
	cmplStd/test/lang/useOperator.ci:225: (13 bytes: <.main+8678 @065bd2> - <.main+8691 @065bdf>): static u64Ior: uint64 := u64A | u64B
	<.main+8678 @065bd2> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8682 @065bd6> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8686 @065bda> : 42                         or.b64
	<.main+8687 @065bdb> : 23 10 36 06                store.m64 <@063610> ;u64Ior
	cmplStd/test/lang/useOperator.ci:226: (13 bytes: <.main+8691 @065bdf> - <.main+8704 @065bec>): static u64Xor: uint64 := u64A ^ u64B
	<.main+8691 @065bdf> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8695 @065be3> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8699 @065be7> : 46                         xor.b64
	<.main+8700 @065be8> : 23 18 36 06                store.m64 <@063618> ;u64Xor
	cmplStd/test/lang/useOperator.ci:227: (13 bytes: <.main+8704 @065bec> - <.main+8717 @065bf9>): static u64Shl: uint64 := u64A << shift
	<.main+8704 @065bec> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8708 @065bf0> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+8712 @065bf4> : 4a                         shl.b64
	<.main+8713 @065bf5> : 23 20 36 06                store.m64 <@063620> ;u64Shl
	cmplStd/test/lang/useOperator.ci:228: (13 bytes: <.main+8717 @065bf9> - <.main+8730 @065c06>): static u64Shr: uint64 := u64A >> shift
	<.main+8717 @065bf9> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8721 @065bfd> : 20 d0 2f 06                load.m32 <@062fd0> ;shift
	<.main+8725 @065c01> : 4b                         shr.b64
	<.main+8726 @065c02> : 23 28 36 06                store.m64 <@063628> ;u64Shr
	cmplStd/test/lang/useOperator.ci:229: (12 bytes: <.main+8730 @065c06> - <.main+8742 @065c12>): static u64Not: bool := !(u64B)
	<.main+8730 @065c06> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8734 @065c0a> : 6b                         i64.2bool
	<.main+8735 @065c0b> : 0b                         not.b32
	<.main+8736 @065c0c> : 1f 30 36 06 00             load.ref <@063630> ;u64Not
	<.main+8741 @065c11> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:230: (15 bytes: <.main+8742 @065c12> - <.main+8757 @065c21>): static u64Ceq: bool := u64A == u64B
	<.main+8742 @065c12> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8746 @065c16> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8750 @065c1a> : 67                         ceq.i64
	<.main+8751 @065c1b> : 1f 38 36 06 00             load.ref <@063638> ;u64Ceq
	<.main+8756 @065c20> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:231: (16 bytes: <.main+8757 @065c21> - <.main+8773 @065c31>): static u64Cne: bool := u64A != u64B
	<.main+8757 @065c21> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8761 @065c25> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8765 @065c29> : 67                         ceq.i64
	<.main+8766 @065c2a> : 0b                         not.b32
	<.main+8767 @065c2b> : 1f 40 36 06 00             load.ref <@063640> ;u64Cne
	<.main+8772 @065c30> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:232: (15 bytes: <.main+8773 @065c31> - <.main+8788 @065c40>): static u64Clt: bool := u64A < u64B
	<.main+8773 @065c31> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8777 @065c35> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8781 @065c39> : 48                         clt.u64
	<.main+8782 @065c3a> : 1f 48 36 06 00             load.ref <@063648> ;u64Clt
	<.main+8787 @065c3f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:233: (16 bytes: <.main+8788 @065c40> - <.main+8804 @065c50>): static u64Cle: bool := u64A <= u64B
	<.main+8788 @065c40> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8792 @065c44> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8796 @065c48> : 49                         cgt.u64
	<.main+8797 @065c49> : 0b                         not.b32
	<.main+8798 @065c4a> : 1f 50 36 06 00             load.ref <@063650> ;u64Cle
	<.main+8803 @065c4f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:234: (15 bytes: <.main+8804 @065c50> - <.main+8819 @065c5f>): static u64Cgt: bool := u64A > u64B
	<.main+8804 @065c50> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8808 @065c54> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8812 @065c58> : 49                         cgt.u64
	<.main+8813 @065c59> : 1f 58 36 06 00             load.ref <@063658> ;u64Cgt
	<.main+8818 @065c5e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:235: (16 bytes: <.main+8819 @065c5f> - <.main+8835 @065c6f>): static u64Cge: bool := u64A >= u64B
	<.main+8819 @065c5f> : 21 b8 35 06                load.m64 <@0635b8> ;u64A
	<.main+8823 @065c63> : 21 c0 35 06                load.m64 <@0635c0> ;u64B
	<.main+8827 @065c67> : 48                         clt.u64
	<.main+8828 @065c68> : 0b                         not.b32
	<.main+8829 @065c69> : 1f 60 36 06 00             load.ref <@063660> ;u64Cge
	<.main+8834 @065c6e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:237: (9 bytes: <.main+8835 @065c6f> - <.main+8844 @065c78>): static f32A: float32 := a
	<.main+8835 @065c6f> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8840 @065c74> : 24 68 36 06                store.m32 <@063668> ;f32A
	cmplStd/test/lang/useOperator.ci:238: (9 bytes: <.main+8844 @065c78> - <.main+8853 @065c81>): static f32B: float32 := b
	<.main+8844 @065c78> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8849 @065c7d> : 24 70 36 06                store.m32 <@063670> ;f32B
	cmplStd/test/lang/useOperator.ci:239: (8 bytes: <.main+8853 @065c81> - <.main+8861 @065c89>): static f32Pls: float32 := +f32B
	<.main+8853 @065c81> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8857 @065c85> : 24 78 36 06                store.m32 <@063678> ;f32Pls
	cmplStd/test/lang/useOperator.ci:240: (9 bytes: <.main+8861 @065c89> - <.main+8870 @065c92>): static f32Neg: float32 := -f32B
	<.main+8861 @065c89> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8865 @065c8d> : 70                         neg.f32
	<.main+8866 @065c8e> : 24 80 36 06                store.m32 <@063680> ;f32Neg
	cmplStd/test/lang/useOperator.ci:242: (13 bytes: <.main+8870 @065c92> - <.main+8883 @065c9f>): static f32Add: float32 := f32A + f32B
	<.main+8870 @065c92> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8874 @065c96> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8878 @065c9a> : 71                         add.f32
	<.main+8879 @065c9b> : 24 88 36 06                store.m32 <@063688> ;f32Add
	cmplStd/test/lang/useOperator.ci:243: (13 bytes: <.main+8883 @065c9f> - <.main+8896 @065cac>): static f32Sub: float32 := f32A - f32B
	<.main+8883 @065c9f> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8887 @065ca3> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8891 @065ca7> : 72                         sub.f32
	<.main+8892 @065ca8> : 24 90 36 06                store.m32 <@063690> ;f32Sub
	cmplStd/test/lang/useOperator.ci:244: (13 bytes: <.main+8896 @065cac> - <.main+8909 @065cb9>): static f32Mul: float32 := f32A * f32B
	<.main+8896 @065cac> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8900 @065cb0> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8904 @065cb4> : 73                         mul.f32
	<.main+8905 @065cb5> : 24 98 36 06                store.m32 <@063698> ;f32Mul
	cmplStd/test/lang/useOperator.ci:245: (13 bytes: <.main+8909 @065cb9> - <.main+8922 @065cc6>): static f32Div: float32 := f32A / f32B
	<.main+8909 @065cb9> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8913 @065cbd> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8917 @065cc1> : 74                         div.f32
	<.main+8918 @065cc2> : 24 a0 36 06                store.m32 <@0636a0> ;f32Div
	cmplStd/test/lang/useOperator.ci:246: (13 bytes: <.main+8922 @065cc6> - <.main+8935 @065cd3>): static f32Mod: float32 := f32A % f32B
	<.main+8922 @065cc6> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8926 @065cca> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8930 @065cce> : 75                         mod.f32
	<.main+8931 @065ccf> : 24 a8 36 06                store.m32 <@0636a8> ;f32Mod
	cmplStd/test/lang/useOperator.ci:252: (12 bytes: <.main+8935 @065cd3> - <.main+8947 @065cdf>): static f32Not: bool := !(f32B)
	<.main+8935 @065cd3> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8939 @065cd7> : 7c                         f32.2bool
	<.main+8940 @065cd8> : 0b                         not.b32
	<.main+8941 @065cd9> : 1f b0 36 06 00             load.ref <@0636b0> ;f32Not
	<.main+8946 @065cde> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:253: (15 bytes: <.main+8947 @065cdf> - <.main+8962 @065cee>): static f32Ceq: bool := f32A == f32B
	<.main+8947 @065cdf> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8951 @065ce3> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8955 @065ce7> : 77                         ceq.f32
	<.main+8956 @065ce8> : 1f b8 36 06 00             load.ref <@0636b8> ;f32Ceq
	<.main+8961 @065ced> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:254: (16 bytes: <.main+8962 @065cee> - <.main+8978 @065cfe>): static f32Cne: bool := f32A != f32B
	<.main+8962 @065cee> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8966 @065cf2> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8970 @065cf6> : 77                         ceq.f32
	<.main+8971 @065cf7> : 0b                         not.b32
	<.main+8972 @065cf8> : 1f c0 36 06 00             load.ref <@0636c0> ;f32Cne
	<.main+8977 @065cfd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:255: (15 bytes: <.main+8978 @065cfe> - <.main+8993 @065d0d>): static f32Clt: bool := f32A < f32B
	<.main+8978 @065cfe> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8982 @065d02> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+8986 @065d06> : 78                         clt.f32
	<.main+8987 @065d07> : 1f c8 36 06 00             load.ref <@0636c8> ;f32Clt
	<.main+8992 @065d0c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:256: (16 bytes: <.main+8993 @065d0d> - <.main+9009 @065d1d>): static f32Cle: bool := f32A <= f32B
	<.main+8993 @065d0d> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+8997 @065d11> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+9001 @065d15> : 79                         cgt.f32
	<.main+9002 @065d16> : 0b                         not.b32
	<.main+9003 @065d17> : 1f d0 36 06 00             load.ref <@0636d0> ;f32Cle
	<.main+9008 @065d1c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:257: (15 bytes: <.main+9009 @065d1d> - <.main+9024 @065d2c>): static f32Cgt: bool := f32A > f32B
	<.main+9009 @065d1d> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+9013 @065d21> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+9017 @065d25> : 79                         cgt.f32
	<.main+9018 @065d26> : 1f d8 36 06 00             load.ref <@0636d8> ;f32Cgt
	<.main+9023 @065d2b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:258: (16 bytes: <.main+9024 @065d2c> - <.main+9040 @065d3c>): static f32Cge: bool := f32A >= f32B
	<.main+9024 @065d2c> : 20 68 36 06                load.m32 <@063668> ;f32A
	<.main+9028 @065d30> : 20 70 36 06                load.m32 <@063670> ;f32B
	<.main+9032 @065d34> : 78                         clt.f32
	<.main+9033 @065d35> : 0b                         not.b32
	<.main+9034 @065d36> : 1f e0 36 06 00             load.ref <@0636e0> ;f32Cge
	<.main+9039 @065d3b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:260: (13 bytes: <.main+9040 @065d3c> - <.main+9053 @065d49>): static f64A: float64 := a
	<.main+9040 @065d3c> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+9049 @065d45> : 23 e8 36 06                store.m64 <@0636e8> ;f64A
	cmplStd/test/lang/useOperator.ci:261: (13 bytes: <.main+9053 @065d49> - <.main+9066 @065d56>): static f64B: float64 := b
	<.main+9053 @065d49> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+9062 @065d52> : 23 f0 36 06                store.m64 <@0636f0> ;f64B
	cmplStd/test/lang/useOperator.ci:262: (8 bytes: <.main+9066 @065d56> - <.main+9074 @065d5e>): static f64Pls: float64 := +f64B
	<.main+9066 @065d56> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9070 @065d5a> : 23 f8 36 06                store.m64 <@0636f8> ;f64Pls
	cmplStd/test/lang/useOperator.ci:263: (9 bytes: <.main+9074 @065d5e> - <.main+9083 @065d67>): static f64Neg: float64 := -f64B
	<.main+9074 @065d5e> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9078 @065d62> : 80                         neg.f64
	<.main+9079 @065d63> : 23 00 37 06                store.m64 <@063700> ;f64Neg
	cmplStd/test/lang/useOperator.ci:265: (13 bytes: <.main+9083 @065d67> - <.main+9096 @065d74>): static f64Add: float64 := f64A + f64B
	<.main+9083 @065d67> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9087 @065d6b> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9091 @065d6f> : 81                         add.f64
	<.main+9092 @065d70> : 23 08 37 06                store.m64 <@063708> ;f64Add
	cmplStd/test/lang/useOperator.ci:266: (13 bytes: <.main+9096 @065d74> - <.main+9109 @065d81>): static f64Sub: float64 := f64A - f64B
	<.main+9096 @065d74> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9100 @065d78> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9104 @065d7c> : 82                         sub.f64
	<.main+9105 @065d7d> : 23 10 37 06                store.m64 <@063710> ;f64Sub
	cmplStd/test/lang/useOperator.ci:267: (13 bytes: <.main+9109 @065d81> - <.main+9122 @065d8e>): static f64Mul: float64 := f64A * f64B
	<.main+9109 @065d81> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9113 @065d85> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9117 @065d89> : 83                         mul.f64
	<.main+9118 @065d8a> : 23 18 37 06                store.m64 <@063718> ;f64Mul
	cmplStd/test/lang/useOperator.ci:268: (13 bytes: <.main+9122 @065d8e> - <.main+9135 @065d9b>): static f64Div: float64 := f64A / f64B
	<.main+9122 @065d8e> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9126 @065d92> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9130 @065d96> : 84                         div.f64
	<.main+9131 @065d97> : 23 20 37 06                store.m64 <@063720> ;f64Div
	cmplStd/test/lang/useOperator.ci:269: (13 bytes: <.main+9135 @065d9b> - <.main+9148 @065da8>): static f64Mod: float64 := f64A % f64B
	<.main+9135 @065d9b> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9139 @065d9f> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9143 @065da3> : 85                         mod.f64
	<.main+9144 @065da4> : 23 28 37 06                store.m64 <@063728> ;f64Mod
	cmplStd/test/lang/useOperator.ci:275: (12 bytes: <.main+9148 @065da8> - <.main+9160 @065db4>): static f64Not: bool := !(f64B)
	<.main+9148 @065da8> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9152 @065dac> : 8d                         f64.2bool
	<.main+9153 @065dad> : 0b                         not.b32
	<.main+9154 @065dae> : 1f 30 37 06 00             load.ref <@063730> ;f64Not
	<.main+9159 @065db3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:276: (15 bytes: <.main+9160 @065db4> - <.main+9175 @065dc3>): static f64Ceq: bool := f64A == f64B
	<.main+9160 @065db4> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9164 @065db8> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9168 @065dbc> : 87                         ceq.f64
	<.main+9169 @065dbd> : 1f 38 37 06 00             load.ref <@063738> ;f64Ceq
	<.main+9174 @065dc2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:277: (16 bytes: <.main+9175 @065dc3> - <.main+9191 @065dd3>): static f64Cne: bool := f64A != f64B
	<.main+9175 @065dc3> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9179 @065dc7> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9183 @065dcb> : 87                         ceq.f64
	<.main+9184 @065dcc> : 0b                         not.b32
	<.main+9185 @065dcd> : 1f 40 37 06 00             load.ref <@063740> ;f64Cne
	<.main+9190 @065dd2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:278: (15 bytes: <.main+9191 @065dd3> - <.main+9206 @065de2>): static f64Clt: bool := f64A < f64B
	<.main+9191 @065dd3> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9195 @065dd7> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9199 @065ddb> : 88                         clt.f64
	<.main+9200 @065ddc> : 1f 48 37 06 00             load.ref <@063748> ;f64Clt
	<.main+9205 @065de1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:279: (16 bytes: <.main+9206 @065de2> - <.main+9222 @065df2>): static f64Cle: bool := f64A <= f64B
	<.main+9206 @065de2> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9210 @065de6> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9214 @065dea> : 89                         cgt.f64
	<.main+9215 @065deb> : 0b                         not.b32
	<.main+9216 @065dec> : 1f 50 37 06 00             load.ref <@063750> ;f64Cle
	<.main+9221 @065df1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:280: (15 bytes: <.main+9222 @065df2> - <.main+9237 @065e01>): static f64Cgt: bool := f64A > f64B
	<.main+9222 @065df2> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9226 @065df6> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9230 @065dfa> : 89                         cgt.f64
	<.main+9231 @065dfb> : 1f 58 37 06 00             load.ref <@063758> ;f64Cgt
	<.main+9236 @065e00> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:281: (16 bytes: <.main+9237 @065e01> - <.main+9253 @065e11>): static f64Cge: bool := f64A >= f64B
	<.main+9237 @065e01> : 21 e8 36 06                load.m64 <@0636e8> ;f64A
	<.main+9241 @065e05> : 21 f0 36 06                load.m64 <@0636f0> ;f64B
	<.main+9245 @065e09> : 88                         clt.f64
	<.main+9246 @065e0a> : 0b                         not.b32
	<.main+9247 @065e0b> : 1f 60 37 06 00             load.ref <@063760> ;f64Cge
	<.main+9252 @065e10> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:283: (9 bytes: <.main+9253 @065e11> - <.main+9262 @065e1a>): static ptrA: pointer := null
	<.main+9253 @065e11> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+9258 @065e16> : 24 68 37 06                store.m32 <@063768> ;ptrA
	cmplStd/test/lang/useOperator.ci:284: (9 bytes: <.main+9262 @065e1a> - <.main+9271 @065e23>): static ptrB: pointer := pointer(shift)
	<.main+9262 @065e1a> : 1f d0 2f 06 00             load.ref <@062fd0> ;shift
	<.main+9267 @065e1f> : 24 70 37 06                store.m32 <@063770> ;ptrB
	cmplStd/test/lang/useOperator.ci:299: (15 bytes: <.main+9271 @065e23> - <.main+9286 @065e32>): static ptrCeq: bool := ptrA == ptrB
	<.main+9271 @065e23> : 20 68 37 06                load.m32 <@063768> ;ptrA
	<.main+9275 @065e27> : 20 70 37 06                load.m32 <@063770> ;ptrB
	<.main+9279 @065e2b> : 57                         ceq.i32
	<.main+9280 @065e2c> : 1f 78 37 06 00             load.ref <@063778> ;ptrCeq
	<.main+9285 @065e31> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:300: (16 bytes: <.main+9286 @065e32> - <.main+9302 @065e42>): static ptrCne: bool := ptrA != ptrB
	<.main+9286 @065e32> : 20 68 37 06                load.m32 <@063768> ;ptrA
	<.main+9290 @065e36> : 20 70 37 06                load.m32 <@063770> ;ptrB
	<.main+9294 @065e3a> : 57                         ceq.i32
	<.main+9295 @065e3b> : 0b                         not.b32
	<.main+9296 @065e3c> : 1f 80 37 06 00             load.ref <@063780> ;ptrCne
	<.main+9301 @065e41> : 2b                         store.i8
	cmplStd/test/lang/stmt.if.ci:26: (5 bytes: <.main+9302 @065e42> - <.main+9307 @065e47>): static t: int32 := 0
	<.main+9302 @065e42> : 19                         load.z32
	<.main+9303 @065e43> : 24 88 37 06                store.m32 <@063788> ;t
	cmplStd/test/lang/stmt.for.ci:12: (5 bytes: <.main+9307 @065e47> - <.main+9312 @065e4c>): static forIdx: int32
	<.main+9307 @065e47> : 19                         load.z32
	<.main+9308 @065e48> : 24 90 37 06                store.m32 <@063790> ;forIdx
	cmplStd/test/std/test.math.ci:3: (24 bytes: <.main+9312 @065e4c> - <.main+9336 @065e64>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9312 @065e4c> : 1a                         load.z64
	<.main+9313 @065e4d> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9322 @065e56> : 1f 38 11 06 00             load.ref <@061138> ;Math.floor(x: float64): float64
	<.main+9327 @065e5b> : 02                         call
	<.main+9328 @065e5c> : 09 f8 ff ff                inc.sp(-8)
	<.main+9332 @065e60> : 23 98 37 06                store.m64 <@063798> ;testMathFloor_1
	cmplStd/test/std/test.math.ci:4: (24 bytes: <.main+9336 @065e64> - <.main+9360 @065e7c>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9336 @065e64> : 1a                         load.z64
	<.main+9337 @065e65> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9346 @065e6e> : 1f 38 11 06 00             load.ref <@061138> ;Math.floor(x: float64): float64
	<.main+9351 @065e73> : 02                         call
	<.main+9352 @065e74> : 09 f8 ff ff                inc.sp(-8)
	<.main+9356 @065e78> : 23 a0 37 06                store.m64 <@0637a0> ;testMathFloor_2
	cmplStd/test/std/test.math.ci:5: (24 bytes: <.main+9360 @065e7c> - <.main+9384 @065e94>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9360 @065e7c> : 1a                         load.z64
	<.main+9361 @065e7d> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9370 @065e86> : 1f 38 11 06 00             load.ref <@061138> ;Math.floor(x: float64): float64
	<.main+9375 @065e8b> : 02                         call
	<.main+9376 @065e8c> : 09 f8 ff ff                inc.sp(-8)
	<.main+9380 @065e90> : 23 a8 37 06                store.m64 <@0637a8> ;testMathFloor_3
	cmplStd/test/std/test.math.ci:6: (24 bytes: <.main+9384 @065e94> - <.main+9408 @065eac>): static testMathFloor_4: float64 := Math.floor(-3.200000)
	<.main+9384 @065e94> : 1a                         load.z64
	<.main+9385 @065e95> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9394 @065e9e> : 1f 38 11 06 00             load.ref <@061138> ;Math.floor(x: float64): float64
	<.main+9399 @065ea3> : 02                         call
	<.main+9400 @065ea4> : 09 f8 ff ff                inc.sp(-8)
	<.main+9404 @065ea8> : 23 b0 37 06                store.m64 <@0637b0> ;testMathFloor_4
	cmplStd/test/std/test.math.ci:7: (24 bytes: <.main+9408 @065eac> - <.main+9432 @065ec4>): static testMathFloor_5: float64 := Math.floor(-3.500000)
	<.main+9408 @065eac> : 1a                         load.z64
	<.main+9409 @065ead> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9418 @065eb6> : 1f 38 11 06 00             load.ref <@061138> ;Math.floor(x: float64): float64
	<.main+9423 @065ebb> : 02                         call
	<.main+9424 @065ebc> : 09 f8 ff ff                inc.sp(-8)
	<.main+9428 @065ec0> : 23 b8 37 06                store.m64 <@0637b8> ;testMathFloor_5
	cmplStd/test/std/test.math.ci:8: (24 bytes: <.main+9432 @065ec4> - <.main+9456 @065edc>): static testMathFloor_6: float64 := Math.floor(-3.600000)
	<.main+9432 @065ec4> : 1a                         load.z64
	<.main+9433 @065ec5> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9442 @065ece> : 1f 38 11 06 00             load.ref <@061138> ;Math.floor(x: float64): float64
	<.main+9447 @065ed3> : 02                         call
	<.main+9448 @065ed4> : 09 f8 ff ff                inc.sp(-8)
	<.main+9452 @065ed8> : 23 c0 37 06                store.m64 <@0637c0> ;testMathFloor_6
	cmplStd/test/std/test.math.ci:10: (29 bytes: <.main+9456 @065edc> - <.main+9485 @065ef9>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9456 @065edc> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9465 @065ee5> : 11 00                      dup.x64 sp(0)
	<.main+9467 @065ee7> : 1a                         load.z64
	<.main+9468 @065ee8> : 89                         cgt.f64
	<.main+9469 @065ee9> : 11 01                      dup.x64 sp(1)
	<.main+9471 @065eeb> : 1a                         load.z64
	<.main+9472 @065eec> : 88                         clt.f64
	<.main+9473 @065eed> : 52                         sub.i32
	<.main+9474 @065eee> : 13 02                      set.x32 sp(2)
	<.main+9476 @065ef0> : 09 fc ff ff                inc.sp(-4)
	<.main+9480 @065ef4> : 5d                         i32.2f64
	<.main+9481 @065ef5> : 23 c8 37 06                store.m64 <@0637c8> ;testMathSign_1F
	cmplStd/test/std/test.math.ci:11: (21 bytes: <.main+9485 @065ef9> - <.main+9506 @065f0e>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9485 @065ef9> : 1a                         load.z64
	<.main+9486 @065efa> : 11 00                      dup.x64 sp(0)
	<.main+9488 @065efc> : 1a                         load.z64
	<.main+9489 @065efd> : 89                         cgt.f64
	<.main+9490 @065efe> : 11 01                      dup.x64 sp(1)
	<.main+9492 @065f00> : 1a                         load.z64
	<.main+9493 @065f01> : 88                         clt.f64
	<.main+9494 @065f02> : 52                         sub.i32
	<.main+9495 @065f03> : 13 02                      set.x32 sp(2)
	<.main+9497 @065f05> : 09 fc ff ff                inc.sp(-4)
	<.main+9501 @065f09> : 5d                         i32.2f64
	<.main+9502 @065f0a> : 23 d0 37 06                store.m64 <@0637d0> ;testMathSign_2F
	cmplStd/test/std/test.math.ci:12: (29 bytes: <.main+9506 @065f0e> - <.main+9535 @065f2b>): static testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+9506 @065f0e> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9515 @065f17> : 11 00                      dup.x64 sp(0)
	<.main+9517 @065f19> : 1a                         load.z64
	<.main+9518 @065f1a> : 89                         cgt.f64
	<.main+9519 @065f1b> : 11 01                      dup.x64 sp(1)
	<.main+9521 @065f1d> : 1a                         load.z64
	<.main+9522 @065f1e> : 88                         clt.f64
	<.main+9523 @065f1f> : 52                         sub.i32
	<.main+9524 @065f20> : 13 02                      set.x32 sp(2)
	<.main+9526 @065f22> : 09 fc ff ff                inc.sp(-4)
	<.main+9530 @065f26> : 5d                         i32.2f64
	<.main+9531 @065f27> : 23 d8 37 06                store.m64 <@0637d8> ;testMathSign_3F
	cmplStd/test/std/test.math.ci:13: (21 bytes: <.main+9535 @065f2b> - <.main+9556 @065f40>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9535 @065f2b> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9540 @065f30> : 10 00                      dup.x32 sp(0)
	<.main+9542 @065f32> : 19                         load.z32
	<.main+9543 @065f33> : 79                         cgt.f32
	<.main+9544 @065f34> : 10 01                      dup.x32 sp(1)
	<.main+9546 @065f36> : 19                         load.z32
	<.main+9547 @065f37> : 78                         clt.f32
	<.main+9548 @065f38> : 52                         sub.i32
	<.main+9549 @065f39> : 13 01                      set.x32 sp(1)
	<.main+9551 @065f3b> : 5d                         i32.2f64
	<.main+9552 @065f3c> : 23 e0 37 06                store.m64 <@0637e0> ;testMathSign_1f
	cmplStd/test/std/test.math.ci:14: (17 bytes: <.main+9556 @065f40> - <.main+9573 @065f51>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9556 @065f40> : 19                         load.z32
	<.main+9557 @065f41> : 10 00                      dup.x32 sp(0)
	<.main+9559 @065f43> : 19                         load.z32
	<.main+9560 @065f44> : 79                         cgt.f32
	<.main+9561 @065f45> : 10 01                      dup.x32 sp(1)
	<.main+9563 @065f47> : 19                         load.z32
	<.main+9564 @065f48> : 78                         clt.f32
	<.main+9565 @065f49> : 52                         sub.i32
	<.main+9566 @065f4a> : 13 01                      set.x32 sp(1)
	<.main+9568 @065f4c> : 5d                         i32.2f64
	<.main+9569 @065f4d> : 23 e8 37 06                store.m64 <@0637e8> ;testMathSign_2f
	cmplStd/test/std/test.math.ci:15: (21 bytes: <.main+9573 @065f51> - <.main+9594 @065f66>): static testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+9573 @065f51> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9578 @065f56> : 10 00                      dup.x32 sp(0)
	<.main+9580 @065f58> : 19                         load.z32
	<.main+9581 @065f59> : 79                         cgt.f32
	<.main+9582 @065f5a> : 10 01                      dup.x32 sp(1)
	<.main+9584 @065f5c> : 19                         load.z32
	<.main+9585 @065f5d> : 78                         clt.f32
	<.main+9586 @065f5e> : 52                         sub.i32
	<.main+9587 @065f5f> : 13 01                      set.x32 sp(1)
	<.main+9589 @065f61> : 5d                         i32.2f64
	<.main+9590 @065f62> : 23 f0 37 06                store.m64 <@0637f0> ;testMathSign_3f
	cmplStd/test/std/test.math.ci:17: (32 bytes: <.main+9594 @065f66> - <.main+9626 @065f86>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9594 @065f66> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9603 @065f6f> : 11 00                      dup.x64 sp(0)
	<.main+9605 @065f71> : 1a                         load.z64
	<.main+9606 @065f72> : 88                         clt.f64
	<.main+9607 @065f73> : 06 0b 00 00                jz <.main+9618 @065f7e>
	<.main+9611 @065f77> : 11 00                      dup.x64 sp(0)
	<.main+9613 @065f79> : 80                         neg.f64
	<.main+9614 @065f7a> : 04 06 00 00                jmp <.main+9620 @065f80>
	<.main+9618 @065f7e> : 11 00                      dup.x64 sp(0)
	<.main+9620 @065f80> : 14 02                      set.x64 sp(2)
	<.main+9622 @065f82> : 23 f8 37 06                store.m64 <@0637f8> ;testMathAbs_1F
	cmplStd/test/std/test.math.ci:18: (24 bytes: <.main+9626 @065f86> - <.main+9650 @065f9e>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9626 @065f86> : 1a                         load.z64
	<.main+9627 @065f87> : 11 00                      dup.x64 sp(0)
	<.main+9629 @065f89> : 1a                         load.z64
	<.main+9630 @065f8a> : 88                         clt.f64
	<.main+9631 @065f8b> : 06 0b 00 00                jz <.main+9642 @065f96>
	<.main+9635 @065f8f> : 11 00                      dup.x64 sp(0)
	<.main+9637 @065f91> : 80                         neg.f64
	<.main+9638 @065f92> : 04 06 00 00                jmp <.main+9644 @065f98>
	<.main+9642 @065f96> : 11 00                      dup.x64 sp(0)
	<.main+9644 @065f98> : 14 02                      set.x64 sp(2)
	<.main+9646 @065f9a> : 23 00 38 06                store.m64 <@063800> ;testMathAbs_2F
	cmplStd/test/std/test.math.ci:19: (32 bytes: <.main+9650 @065f9e> - <.main+9682 @065fbe>): static testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+9650 @065f9e> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9659 @065fa7> : 11 00                      dup.x64 sp(0)
	<.main+9661 @065fa9> : 1a                         load.z64
	<.main+9662 @065faa> : 88                         clt.f64
	<.main+9663 @065fab> : 06 0b 00 00                jz <.main+9674 @065fb6>
	<.main+9667 @065faf> : 11 00                      dup.x64 sp(0)
	<.main+9669 @065fb1> : 80                         neg.f64
	<.main+9670 @065fb2> : 04 06 00 00                jmp <.main+9676 @065fb8>
	<.main+9674 @065fb6> : 11 00                      dup.x64 sp(0)
	<.main+9676 @065fb8> : 14 02                      set.x64 sp(2)
	<.main+9678 @065fba> : 23 08 38 06                store.m64 <@063808> ;testMathAbs_3F
	cmplStd/test/std/test.math.ci:20: (29 bytes: <.main+9682 @065fbe> - <.main+9711 @065fdb>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9682 @065fbe> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9687 @065fc3> : 10 00                      dup.x32 sp(0)
	<.main+9689 @065fc5> : 19                         load.z32
	<.main+9690 @065fc6> : 78                         clt.f32
	<.main+9691 @065fc7> : 06 0b 00 00                jz <.main+9702 @065fd2>
	<.main+9695 @065fcb> : 10 00                      dup.x32 sp(0)
	<.main+9697 @065fcd> : 70                         neg.f32
	<.main+9698 @065fce> : 04 06 00 00                jmp <.main+9704 @065fd4>
	<.main+9702 @065fd2> : 10 00                      dup.x32 sp(0)
	<.main+9704 @065fd4> : 13 01                      set.x32 sp(1)
	<.main+9706 @065fd6> : 7d                         f32.2f64
	<.main+9707 @065fd7> : 23 10 38 06                store.m64 <@063810> ;testMathAbs_1f
	cmplStd/test/std/test.math.ci:21: (25 bytes: <.main+9711 @065fdb> - <.main+9736 @065ff4>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9711 @065fdb> : 19                         load.z32
	<.main+9712 @065fdc> : 10 00                      dup.x32 sp(0)
	<.main+9714 @065fde> : 19                         load.z32
	<.main+9715 @065fdf> : 78                         clt.f32
	<.main+9716 @065fe0> : 06 0b 00 00                jz <.main+9727 @065feb>
	<.main+9720 @065fe4> : 10 00                      dup.x32 sp(0)
	<.main+9722 @065fe6> : 70                         neg.f32
	<.main+9723 @065fe7> : 04 06 00 00                jmp <.main+9729 @065fed>
	<.main+9727 @065feb> : 10 00                      dup.x32 sp(0)
	<.main+9729 @065fed> : 13 01                      set.x32 sp(1)
	<.main+9731 @065fef> : 7d                         f32.2f64
	<.main+9732 @065ff0> : 23 18 38 06                store.m64 <@063818> ;testMathAbs_2f
	cmplStd/test/std/test.math.ci:22: (29 bytes: <.main+9736 @065ff4> - <.main+9765 @066011>): static testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+9736 @065ff4> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9741 @065ff9> : 10 00                      dup.x32 sp(0)
	<.main+9743 @065ffb> : 19                         load.z32
	<.main+9744 @065ffc> : 78                         clt.f32
	<.main+9745 @065ffd> : 06 0b 00 00                jz <.main+9756 @066008>
	<.main+9749 @066001> : 10 00                      dup.x32 sp(0)
	<.main+9751 @066003> : 70                         neg.f32
	<.main+9752 @066004> : 04 06 00 00                jmp <.main+9758 @06600a>
	<.main+9756 @066008> : 10 00                      dup.x32 sp(0)
	<.main+9758 @06600a> : 13 01                      set.x32 sp(1)
	<.main+9760 @06600c> : 7d                         f32.2f64
	<.main+9761 @06600d> : 23 20 38 06                store.m64 <@063820> ;testMathAbs_3f
	cmplStd/test/std/test.math.ci:24: (38 bytes: <.main+9765 @066011> - <.main+9803 @066037>): static testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+9765 @066011> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9770 @066016> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9775 @06601b> : 10 01                      dup.x32 sp(1)
	<.main+9777 @06601d> : 10 01                      dup.x32 sp(1)
	<.main+9779 @06601f> : 78                         clt.f32
	<.main+9780 @066020> : 06 0a 00 00                jz <.main+9790 @06602a>
	<.main+9784 @066024> : 10 01                      dup.x32 sp(1)
	<.main+9786 @066026> : 04 06 00 00                jmp <.main+9792 @06602c>
	<.main+9790 @06602a> : 10 00                      dup.x32 sp(0)
	<.main+9792 @06602c> : 13 02                      set.x32 sp(2)
	<.main+9794 @06602e> : 09 fc ff ff                inc.sp(-4)
	<.main+9798 @066032> : 7d                         f32.2f64
	<.main+9799 @066033> : 23 28 38 06                store.m64 <@063828> ;testMathMin_1f
	cmplStd/test/std/test.math.ci:25: (38 bytes: <.main+9803 @066037> - <.main+9841 @06605d>): static testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+9803 @066037> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9808 @06603c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9813 @066041> : 10 01                      dup.x32 sp(1)
	<.main+9815 @066043> : 10 01                      dup.x32 sp(1)
	<.main+9817 @066045> : 79                         cgt.f32
	<.main+9818 @066046> : 06 0a 00 00                jz <.main+9828 @066050>
	<.main+9822 @06604a> : 10 01                      dup.x32 sp(1)
	<.main+9824 @06604c> : 04 06 00 00                jmp <.main+9830 @066052>
	<.main+9828 @066050> : 10 00                      dup.x32 sp(0)
	<.main+9830 @066052> : 13 02                      set.x32 sp(2)
	<.main+9832 @066054> : 09 fc ff ff                inc.sp(-4)
	<.main+9836 @066058> : 7d                         f32.2f64
	<.main+9837 @066059> : 23 30 38 06                store.m64 <@063830> ;testMathMax_2f
	cmplStd/test/std/test.math.ci:26: (45 bytes: <.main+9841 @06605d> - <.main+9886 @06608a>): static testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+9841 @06605d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9850 @066066> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9859 @06606f> : 11 02                      dup.x64 sp(2)
	<.main+9861 @066071> : 11 02                      dup.x64 sp(2)
	<.main+9863 @066073> : 88                         clt.f64
	<.main+9864 @066074> : 06 0a 00 00                jz <.main+9874 @06607e>
	<.main+9868 @066078> : 11 02                      dup.x64 sp(2)
	<.main+9870 @06607a> : 04 06 00 00                jmp <.main+9876 @066080>
	<.main+9874 @06607e> : 11 00                      dup.x64 sp(0)
	<.main+9876 @066080> : 14 04                      set.x64 sp(4)
	<.main+9878 @066082> : 09 f8 ff ff                inc.sp(-8)
	<.main+9882 @066086> : 23 38 38 06                store.m64 <@063838> ;testMathMin_1F
	cmplStd/test/std/test.math.ci:27: (45 bytes: <.main+9886 @06608a> - <.main+9931 @0660b7>): static testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+9886 @06608a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9895 @066093> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9904 @06609c> : 11 02                      dup.x64 sp(2)
	<.main+9906 @06609e> : 11 02                      dup.x64 sp(2)
	<.main+9908 @0660a0> : 89                         cgt.f64
	<.main+9909 @0660a1> : 06 0a 00 00                jz <.main+9919 @0660ab>
	<.main+9913 @0660a5> : 11 02                      dup.x64 sp(2)
	<.main+9915 @0660a7> : 04 06 00 00                jmp <.main+9921 @0660ad>
	<.main+9919 @0660ab> : 11 00                      dup.x64 sp(0)
	<.main+9921 @0660ad> : 14 04                      set.x64 sp(4)
	<.main+9923 @0660af> : 09 f8 ff ff                inc.sp(-8)
	<.main+9927 @0660b3> : 23 40 38 06                store.m64 <@063840> ;testMathMax_2F
	cmplStd/test/std/test.math.ci:29: (27 bytes: <.main+9931 @0660b7> - <.main+9958 @0660d2>): static testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9931 @0660b7> : 19                         load.z32
	<.main+9932 @0660b8> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9937 @0660bd> : 19                         load.z32
	<.main+9938 @0660be> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9943 @0660c3> : 1f 90 11 06 00             load.ref <@061190> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9948 @0660c8> : 02                         call
	<.main+9949 @0660c9> : 09 f4 ff ff                inc.sp(-12)
	<.main+9953 @0660cd> : 7d                         f32.2f64
	<.main+9954 @0660ce> : 23 48 38 06                store.m64 <@063848> ;testMathClamp_1f
	cmplStd/test/std/test.math.ci:30: (34 bytes: <.main+9958 @0660d2> - <.main+9992 @0660f4>): static testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9958 @0660d2> : 1a                         load.z64
	<.main+9959 @0660d3> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9968 @0660dc> : 1a                         load.z64
	<.main+9969 @0660dd> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9978 @0660e6> : 1f b0 11 06 00             load.ref <@0611b0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9983 @0660eb> : 02                         call
	<.main+9984 @0660ec> : 09 e8 ff ff                inc.sp(-24)
	<.main+9988 @0660f0> : 23 50 38 06                store.m64 <@063850> ;testMathClamp_1F
	cmplStd/test/std/test.math.ci:32: (25 bytes: <.main+9992 @0660f4> - <.main+10017 @06610d>): static testMathLerp_1f: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9992 @0660f4> : 19                         load.z32
	<.main+9993 @0660f5> : 10 00                      dup.x32 sp(0)
	<.main+9995 @0660f7> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+10000 @0660fc>: 7f 00 00 00 40             load.f32 2.000000
	<.main+10005 @066101>: 10 03                      dup.x32 sp(3)
	<.main+10007 @066103>: 72                         sub.f32
	<.main+10008 @066104>: 73                         mul.f32
	<.main+10009 @066105>: 71                         add.f32
	<.main+10010 @066106>: 13 01                      set.x32 sp(1)
	<.main+10012 @066108>: 7d                         f32.2f64
	<.main+10013 @066109>: 23 58 38 06                store.m64 <@063858> ;testMathLerp_1f
	cmplStd/test/std/test.math.ci:33: (32 bytes: <.main+10017 @06610d> - <.main+10049 @06612d>): static testMathLerp_1F: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+10017 @06610d>: 1a                         load.z64
	<.main+10018 @06610e>: 11 00                      dup.x64 sp(0)
	<.main+10020 @066110>: 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+10029 @066119>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10038 @066122>: 11 06                      dup.x64 sp(6)
	<.main+10040 @066124>: 82                         sub.f64
	<.main+10041 @066125>: 83                         mul.f64
	<.main+10042 @066126>: 81                         add.f64
	<.main+10043 @066127>: 14 02                      set.x64 sp(2)
	<.main+10045 @066129>: 23 60 38 06                store.m64 <@063860> ;testMathLerp_1F
	cmplStd/test/std/test.math.ci:35: (64 bytes: <.main+10049 @06612d> - <.main+10113 @06616d>): static testMathSmooth_1f: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+10049 @06612d>: 19                         load.z32
	<.main+10050 @06612e>: 19                         load.z32
	<.main+10051 @06612f>: 7f 00 00 80 3f             load.f32 1.000000
	<.main+10056 @066134>: 10 02                      dup.x32 sp(2)
	<.main+10058 @066136>: 72                         sub.f32
	<.main+10059 @066137>: 7f 00 00 80 3f             load.f32 1.000000
	<.main+10064 @06613c>: 10 03                      dup.x32 sp(3)
	<.main+10066 @06613e>: 72                         sub.f32
	<.main+10067 @06613f>: 74                         div.f32
	<.main+10068 @066140>: 19                         load.z32
	<.main+10069 @066141>: 7f 00 00 80 3f             load.f32 1.000000
	<.main+10074 @066146>: 1f 90 11 06 00             load.ref <@061190> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+10079 @06614b>: 02                         call
	<.main+10080 @06614c>: 09 f4 ff ff                inc.sp(-12)
	<.main+10084 @066150>: 10 00                      dup.x32 sp(0)
	<.main+10086 @066152>: 10 01                      dup.x32 sp(1)
	<.main+10088 @066154>: 73                         mul.f32
	<.main+10089 @066155>: 7f 00 00 40 40             load.f32 3.000000
	<.main+10094 @06615a>: 7f 00 00 00 40             load.f32 2.000000
	<.main+10099 @06615f>: 10 03                      dup.x32 sp(3)
	<.main+10101 @066161>: 73                         mul.f32
	<.main+10102 @066162>: 72                         sub.f32
	<.main+10103 @066163>: 73                         mul.f32
	<.main+10104 @066164>: 13 01                      set.x32 sp(1)
	<.main+10106 @066166>: 13 01                      set.x32 sp(1)
	<.main+10108 @066168>: 7d                         f32.2f64
	<.main+10109 @066169>: 23 68 38 06                store.m64 <@063868> ;testMathSmooth_1f
	cmplStd/test/std/test.math.ci:36: (82 bytes: <.main+10113 @06616d> - <.main+10195 @0661bf>): static testMathSmooth_1F: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+10113 @06616d>: 1b                         load.z128
	<.main+10114 @06616e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10123 @066177>: 11 04                      dup.x64 sp(4)
	<.main+10125 @066179>: 82                         sub.f64
	<.main+10126 @06617a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10135 @066183>: 11 06                      dup.x64 sp(6)
	<.main+10137 @066185>: 82                         sub.f64
	<.main+10138 @066186>: 84                         div.f64
	<.main+10139 @066187>: 1a                         load.z64
	<.main+10140 @066188>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10149 @066191>: 1f b0 11 06 00             load.ref <@0611b0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+10154 @066196>: 02                         call
	<.main+10155 @066197>: 09 e8 ff ff                inc.sp(-24)
	<.main+10159 @06619b>: 11 00                      dup.x64 sp(0)
	<.main+10161 @06619d>: 11 02                      dup.x64 sp(2)
	<.main+10163 @06619f>: 83                         mul.f64
	<.main+10164 @0661a0>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10173 @0661a9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10182 @0661b2>: 11 06                      dup.x64 sp(6)
	<.main+10184 @0661b4>: 83                         mul.f64
	<.main+10185 @0661b5>: 82                         sub.f64
	<.main+10186 @0661b6>: 83                         mul.f64
	<.main+10187 @0661b7>: 14 02                      set.x64 sp(2)
	<.main+10189 @0661b9>: 14 02                      set.x64 sp(2)
	<.main+10191 @0661bb>: 23 70 38 06                store.m64 <@063870> ;testMathSmooth_1F
	cmplStd/test/std/test.math.ci:38: (25 bytes: <.main+10195 @0661bf> - <.main+10220 @0661d8>): static testMathMin_nan: float64 := Math.min()
	<.main+10195 @0661bf>: 19                         load.z32
	<.main+10196 @0661c0>: 0a 04 00 00                load.sp(+4)
	<.main+10200 @0661c4>: 1a                         load.z64
	<.main+10201 @0661c5>: 11 02                      dup.x64 sp(2)
	<.main+10203 @0661c7>: 1f d0 11 06 00             load.ref <@0611d0> ;Math.min(data: float64[]): float64
	<.main+10208 @0661cc>: 02                         call
	<.main+10209 @0661cd>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10212 @0661d0>: 09 f0 ff ff                inc.sp(-16)
	<.main+10216 @0661d4>: 23 78 38 06                store.m64 <@063878> ;testMathMin_nan
	cmplStd/test/std/test.math.ci:39: (110 bytes: <.main+10220 @0661d8> - <.main+10330 @066246>): static testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10220 @0661d8>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10229 @0661e1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10238 @0661ea>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10247 @0661f3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10256 @0661fc>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10265 @066205>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10274 @06620e>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10283 @066217>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10292 @066220>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10301 @066229>: 1c 09 00 00 00             load.c32 9
	<.main+10306 @06622e>: 0a 04 00 00                load.sp(+4)
	<.main+10310 @066232>: 1a                         load.z64
	<.main+10311 @066233>: 11 02                      dup.x64 sp(2)
	<.main+10313 @066235>: 1f d0 11 06 00             load.ref <@0611d0> ;Math.min(data: float64[]): float64
	<.main+10318 @06623a>: 02                         call
	<.main+10319 @06623b>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10322 @06623e>: 09 a8 ff ff                inc.sp(-88)
	<.main+10326 @066242>: 23 80 38 06                store.m64 <@063880> ;testMathMin_1
	cmplStd/test/std/test.math.ci:40: (25 bytes: <.main+10330 @066246> - <.main+10355 @06625f>): static testMathMax_nan: float64 := Math.max()
	<.main+10330 @066246>: 19                         load.z32
	<.main+10331 @066247>: 0a 04 00 00                load.sp(+4)
	<.main+10335 @06624b>: 1a                         load.z64
	<.main+10336 @06624c>: 11 02                      dup.x64 sp(2)
	<.main+10338 @06624e>: 1f 20 12 06 00             load.ref <@061220> ;Math.max(data: float64[]): float64
	<.main+10343 @066253>: 02                         call
	<.main+10344 @066254>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10347 @066257>: 09 f0 ff ff                inc.sp(-16)
	<.main+10351 @06625b>: 23 88 38 06                store.m64 <@063888> ;testMathMax_nan
	cmplStd/test/std/test.math.ci:41: (110 bytes: <.main+10355 @06625f> - <.main+10465 @0662cd>): static testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10355 @06625f>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10364 @066268>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10373 @066271>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10382 @06627a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10391 @066283>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10400 @06628c>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10409 @066295>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10418 @06629e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10427 @0662a7>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10436 @0662b0>: 1c 09 00 00 00             load.c32 9
	<.main+10441 @0662b5>: 0a 04 00 00                load.sp(+4)
	<.main+10445 @0662b9>: 1a                         load.z64
	<.main+10446 @0662ba>: 11 02                      dup.x64 sp(2)
	<.main+10448 @0662bc>: 1f 20 12 06 00             load.ref <@061220> ;Math.max(data: float64[]): float64
	<.main+10453 @0662c1>: 02                         call
	<.main+10454 @0662c2>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10457 @0662c5>: 09 a8 ff ff                inc.sp(-88)
	<.main+10461 @0662c9>: 23 90 38 06                store.m64 <@063890> ;testMathMax_9
	cmplStd/test/std/test.math.ci:43: (25 bytes: <.main+10465 @0662cd> - <.main+10490 @0662e6>): static testMathSum_0: float64 := Math.sum()
	<.main+10465 @0662cd>: 19                         load.z32
	<.main+10466 @0662ce>: 0a 04 00 00                load.sp(+4)
	<.main+10470 @0662d2>: 1a                         load.z64
	<.main+10471 @0662d3>: 11 02                      dup.x64 sp(2)
	<.main+10473 @0662d5>: 1f 70 12 06 00             load.ref <@061270> ;Math.sum(data: float64[]): float64
	<.main+10478 @0662da>: 02                         call
	<.main+10479 @0662db>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10482 @0662de>: 09 f0 ff ff                inc.sp(-16)
	<.main+10486 @0662e2>: 23 98 38 06                store.m64 <@063898> ;testMathSum_0
	cmplStd/test/std/test.math.ci:44: (38 bytes: <.main+10490 @0662e6> - <.main+10528 @06630c>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10490 @0662e6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10499 @0662ef>: 1c 01 00 00 00             load.c32 1
	<.main+10504 @0662f4>: 0a 04 00 00                load.sp(+4)
	<.main+10508 @0662f8>: 1a                         load.z64
	<.main+10509 @0662f9>: 11 02                      dup.x64 sp(2)
	<.main+10511 @0662fb>: 1f 70 12 06 00             load.ref <@061270> ;Math.sum(data: float64[]): float64
	<.main+10516 @066300>: 02                         call
	<.main+10517 @066301>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10520 @066304>: 09 e8 ff ff                inc.sp(-24)
	<.main+10524 @066308>: 23 a0 38 06                store.m64 <@0638a0> ;testMathSum_1
	cmplStd/test/std/test.math.ci:45: (47 bytes: <.main+10528 @06630c> - <.main+10575 @06633b>): static testMathSum_3: float64 := Math.sum(1, 2)
	<.main+10528 @06630c>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10537 @066315>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10546 @06631e>: 1c 02 00 00 00             load.c32 2
	<.main+10551 @066323>: 0a 04 00 00                load.sp(+4)
	<.main+10555 @066327>: 1a                         load.z64
	<.main+10556 @066328>: 11 02                      dup.x64 sp(2)
	<.main+10558 @06632a>: 1f 70 12 06 00             load.ref <@061270> ;Math.sum(data: float64[]): float64
	<.main+10563 @06632f>: 02                         call
	<.main+10564 @066330>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10567 @066333>: 09 e0 ff ff                inc.sp(-32)
	<.main+10571 @066337>: 23 a8 38 06                store.m64 <@0638a8> ;testMathSum_3
	cmplStd/test/std/test.math.ci:46: (119 bytes: <.main+10575 @06633b> - <.main+10694 @0663b2>): static testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+10575 @06633b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10584 @066344>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10593 @06634d>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10602 @066356>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10611 @06635f>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10620 @066368>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10629 @066371>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10638 @06637a>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10647 @066383>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10656 @06638c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10665 @066395>: 1c 0a 00 00 00             load.c32 10
	<.main+10670 @06639a>: 0a 04 00 00                load.sp(+4)
	<.main+10674 @06639e>: 1a                         load.z64
	<.main+10675 @06639f>: 11 02                      dup.x64 sp(2)
	<.main+10677 @0663a1>: 1f 70 12 06 00             load.ref <@061270> ;Math.sum(data: float64[]): float64
	<.main+10682 @0663a6>: 02                         call
	<.main+10683 @0663a7>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10686 @0663aa>: 09 a0 ff ff                inc.sp(-96)
	<.main+10690 @0663ae>: 23 b0 38 06                store.m64 <@0638b0> ;testMathSum_55
	cmplStd/test/std/test.math.ci:48: (13 bytes: <.main+10694 @0663b2> - <.main+10707 @0663bf>): static testMathEval_x: float64 := 10
	<.main+10694 @0663b2>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10703 @0663bb>: 23 b8 38 06                store.m64 <@0638b8> ;testMathEval_x
	cmplStd/test/std/test.math.ci:49: (29 bytes: <.main+10707 @0663bf> - <.main+10736 @0663dc>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10707 @0663bf>: 19                         load.z32
	<.main+10708 @0663c0>: 0a 04 00 00                load.sp(+4)
	<.main+10712 @0663c4>: 1a                         load.z64
	<.main+10713 @0663c5>: 21 b8 38 06                load.m64 <@0638b8> ;testMathEval_x
	<.main+10717 @0663c9>: 11 04                      dup.x64 sp(4)
	<.main+10719 @0663cb>: 1f b0 12 06 00             load.ref <@0612b0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10724 @0663d0>: 02                         call
	<.main+10725 @0663d1>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10728 @0663d4>: 09 e8 ff ff                inc.sp(-24)
	<.main+10732 @0663d8>: 23 c0 38 06                store.m64 <@0638c0> ;testMathEval_0
	cmplStd/test/std/test.math.ci:50: (13 bytes: <.main+10736 @0663dc> - <.main+10749 @0663e9>): static testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+10736 @0663dc>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10745 @0663e5>: 23 c8 38 06                store.m64 <@0638c8> ;testMathEval_1
	cmplStd/test/std/test.math.ci:51: (28 bytes: <.main+10749 @0663e9> - <.main+10777 @066405>): static testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+10749 @0663e9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10758 @0663f2>: 21 b8 38 06                load.m64 <@0638b8> ;testMathEval_x
	<.main+10762 @0663f6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10771 @0663ff>: 83                         mul.f64
	<.main+10772 @066400>: 81                         add.f64
	<.main+10773 @066401>: 23 d0 38 06                store.m64 <@0638d0> ;testMathEval_2
	cmplStd/test/std/test.math.ci:52: (45 bytes: <.main+10777 @066405> - <.main+10822 @066432>): static testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+10777 @066405>: 21 b8 38 06                load.m64 <@0638b8> ;testMathEval_x
	<.main+10781 @066409>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10790 @066412>: 11 02                      dup.x64 sp(2)
	<.main+10792 @066414>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10801 @06641d>: 11 06                      dup.x64 sp(6)
	<.main+10803 @06641f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10812 @066428>: 83                         mul.f64
	<.main+10813 @066429>: 81                         add.f64
	<.main+10814 @06642a>: 83                         mul.f64
	<.main+10815 @06642b>: 81                         add.f64
	<.main+10816 @06642c>: 14 02                      set.x64 sp(2)
	<.main+10818 @06642e>: 23 d8 38 06                store.m64 <@0638d8> ;testMathEval_3
	cmplStd/test/std/test.math.ci:53: (62 bytes: <.main+10822 @066432> - <.main+10884 @066470>): static testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10822 @066432>: 21 b8 38 06                load.m64 <@0638b8> ;testMathEval_x
	<.main+10826 @066436>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10835 @06643f>: 11 02                      dup.x64 sp(2)
	<.main+10837 @066441>: 11 04                      dup.x64 sp(4)
	<.main+10839 @066443>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10848 @06644c>: 11 02                      dup.x64 sp(2)
	<.main+10850 @06644e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10859 @066457>: 11 06                      dup.x64 sp(6)
	<.main+10861 @066459>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10870 @066462>: 83                         mul.f64
	<.main+10871 @066463>: 81                         add.f64
	<.main+10872 @066464>: 83                         mul.f64
	<.main+10873 @066465>: 81                         add.f64
	<.main+10874 @066466>: 14 02                      set.x64 sp(2)
	<.main+10876 @066468>: 83                         mul.f64
	<.main+10877 @066469>: 81                         add.f64
	<.main+10878 @06646a>: 14 02                      set.x64 sp(2)
	<.main+10880 @06646c>: 23 e0 38 06                store.m64 <@0638e0> ;testMathEval_4
	cmplStd/test/std/test.math.ci:54: (78 bytes: <.main+10884 @066470> - <.main+10962 @0664be>): static testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10884 @066470>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10893 @066479>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10902 @066482>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10911 @06648b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10920 @066494>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10929 @06649d>: 1c 05 00 00 00             load.c32 5
	<.main+10934 @0664a2>: 0a 04 00 00                load.sp(+4)
	<.main+10938 @0664a6>: 1a                         load.z64
	<.main+10939 @0664a7>: 21 b8 38 06                load.m64 <@0638b8> ;testMathEval_x
	<.main+10943 @0664ab>: 11 04                      dup.x64 sp(4)
	<.main+10945 @0664ad>: 1f b0 12 06 00             load.ref <@0612b0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10950 @0664b2>: 02                         call
	<.main+10951 @0664b3>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10954 @0664b6>: 09 c0 ff ff                inc.sp(-64)
	<.main+10958 @0664ba>: 23 e8 38 06                store.m64 <@0638e8> ;testMathEval_5
	cmplStd/test/std/test.math.ci:55: (87 bytes: <.main+10962 @0664be> - <.main+11049 @066515>): static testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10962 @0664be>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10971 @0664c7>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10980 @0664d0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10989 @0664d9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10998 @0664e2>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+11007 @0664eb>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+11016 @0664f4>: 1c 06 00 00 00             load.c32 6
	<.main+11021 @0664f9>: 0a 04 00 00                load.sp(+4)
	<.main+11025 @0664fd>: 1a                         load.z64
	<.main+11026 @0664fe>: 21 b8 38 06                load.m64 <@0638b8> ;testMathEval_x
	<.main+11030 @066502>: 11 04                      dup.x64 sp(4)
	<.main+11032 @066504>: 1f b0 12 06 00             load.ref <@0612b0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+11037 @066509>: 02                         call
	<.main+11038 @06650a>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+11041 @06650d>: 09 b8 ff ff                inc.sp(-72)
	<.main+11045 @066511>: 23 f0 38 06                store.m64 <@0638f0> ;testMathEval_6
	cmplStd/test/std/test.math.ci:57: (35 bytes: <.main+11049 @066515> - <.main+11084 @066538>): static testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+11049 @066515>: 1a                         load.z64
	<.main+11050 @066516>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11059 @06651f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11068 @066528>: 84                         div.f64
	<.main+11069 @066529>: 19                         load.z32
	<.main+11070 @06652a>: 1f 60 13 06 00             load.ref <@061360> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+11075 @06652f>: 02                         call
	<.main+11076 @066530>: 09 f4 ff ff                inc.sp(-12)
	<.main+11080 @066534>: 23 f8 38 06                store.m64 <@0638f8> ;testMathSin_f64
	cmplStd/test/std/test.math.ci:58: (58 bytes: <.main+11084 @066538> - <.main+11142 @066572>): static testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+11084 @066538>: 1a                         load.z64
	<.main+11085 @066539>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11094 @066542>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11103 @06654b>: 84                         div.f64
	<.main+11104 @06654c>: 11 00                      dup.x64 sp(0)
	<.main+11106 @06654e>: 1a                         load.z64
	<.main+11107 @06654f>: 88                         clt.f64
	<.main+11108 @066550>: 06 0b 00 00                jz <.main+11119 @06655b>
	<.main+11112 @066554>: 11 00                      dup.x64 sp(0)
	<.main+11114 @066556>: 80                         neg.f64
	<.main+11115 @066557>: 04 06 00 00                jmp <.main+11121 @06655d>
	<.main+11119 @06655b>: 11 00                      dup.x64 sp(0)
	<.main+11121 @06655d>: 14 02                      set.x64 sp(2)
	<.main+11123 @06655f>: 1c 01 00 00 00             load.c32 1
	<.main+11128 @066564>: 1f 60 13 06 00             load.ref <@061360> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+11133 @066569>: 02                         call
	<.main+11134 @06656a>: 09 f4 ff ff                inc.sp(-12)
	<.main+11138 @06656e>: 23 00 39 06                store.m64 <@063900> ;testMathCos_f64
	cmplStd/test/std/test.math.ci:59: (34 bytes: <.main+11142 @066572> - <.main+11176 @066594>): static testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+11142 @066572>: 1a                         load.z64
	<.main+11143 @066573>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11152 @06657c>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+11161 @066585>: 84                         div.f64
	<.main+11162 @066586>: 1f b0 14 06 00             load.ref <@0614b0> ;Math.tan(arg: float64): float64
	<.main+11167 @06658b>: 02                         call
	<.main+11168 @06658c>: 09 f8 ff ff                inc.sp(-8)
	<.main+11172 @066590>: 23 08 39 06                store.m64 <@063908> ;testMathTan_f64
	cmplStd/test/std/test.math.ci:60: (34 bytes: <.main+11176 @066594> - <.main+11210 @0665b6>): static testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+11176 @066594>: 1a                         load.z64
	<.main+11177 @066595>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11186 @06659e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11195 @0665a7>: 84                         div.f64
	<.main+11196 @0665a8>: 1f 30 16 06 00             load.ref <@061630> ;Math.sinh(x: float64): float64
	<.main+11201 @0665ad>: 02                         call
	<.main+11202 @0665ae>: 09 f8 ff ff                inc.sp(-8)
	<.main+11206 @0665b2>: 23 10 39 06                store.m64 <@063910> ;testMathSinh_f64
	cmplStd/test/std/test.math.ci:61: (34 bytes: <.main+11210 @0665b6> - <.main+11244 @0665d8>): static testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+11210 @0665b6>: 1a                         load.z64
	<.main+11211 @0665b7>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11220 @0665c0>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11229 @0665c9>: 84                         div.f64
	<.main+11230 @0665ca>: 1f 28 17 06 00             load.ref <@061728> ;Math.cosh(x: float64): float64
	<.main+11235 @0665cf>: 02                         call
	<.main+11236 @0665d0>: 09 f8 ff ff                inc.sp(-8)
	<.main+11240 @0665d4>: 23 18 39 06                store.m64 <@063918> ;testMathCosh_f64
	cmplStd/test/std/test.math.ci:63: (24 bytes: <.main+11244 @0665d8> - <.main+11268 @0665f0>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+11244 @0665d8>: 1a                         load.z64
	<.main+11245 @0665d9>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11254 @0665e2>: 1f 78 17 06 00             load.ref <@061778> ;Math.asin(x: float64): float64
	<.main+11259 @0665e7>: 02                         call
	<.main+11260 @0665e8>: 09 f8 ff ff                inc.sp(-8)
	<.main+11264 @0665ec>: 23 20 39 06                store.m64 <@063920> ;testMathAsin_f64
	cmplStd/test/std/test.math.ci:64: (44 bytes: <.main+11268 @0665f0> - <.main+11312 @06661c>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+11268 @0665f0>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11277 @0665f9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11286 @066602>: 84                         div.f64
	<.main+11287 @066603>: 1a                         load.z64
	<.main+11288 @066604>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11297 @06660d>: 1f 78 17 06 00             load.ref <@061778> ;Math.asin(x: float64): float64
	<.main+11302 @066612>: 02                         call
	<.main+11303 @066613>: 09 f8 ff ff                inc.sp(-8)
	<.main+11307 @066617>: 82                         sub.f64
	<.main+11308 @066618>: 23 28 39 06                store.m64 <@063928> ;testMathAcos_f64
	cmplStd/test/std/test.math.ci:67: (34 bytes: <.main+11312 @06661c> - <.main+11346 @06663e>): static testMathCmp_f32: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11312 @06661c>: 19                         load.z32
	<.main+11313 @06661d>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11318 @066622>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+11323 @066627>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11328 @06662c>: 1f e0 12 06 00             load.ref <@0612e0> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+11333 @066631>: 02                         call
	<.main+11334 @066632>: 09 f4 ff ff                inc.sp(-12)
	<.main+11338 @066636>: 19                         load.z32
	<.main+11339 @066637>: 57                         ceq.i32
	<.main+11340 @066638>: 1f 30 39 06 00             load.ref <@063930> ;testMathCmp_f32
	<.main+11345 @06663d>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:68: (46 bytes: <.main+11346 @06663e> - <.main+11392 @06666c>): static testMathCmp_f64: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11346 @06663e>: 19                         load.z32
	<.main+11347 @06663f>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11356 @066648>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+11365 @066651>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11374 @06665a>: 1f 20 13 06 00             load.ref <@061320> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+11379 @06665f>: 02                         call
	<.main+11380 @066660>: 09 e8 ff ff                inc.sp(-24)
	<.main+11384 @066664>: 19                         load.z32
	<.main+11385 @066665>: 57                         ceq.i32
	<.main+11386 @066666>: 1f 38 39 06 00             load.ref <@063938> ;testMathCmp_f64
	<.main+11391 @06666b>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:70: (33 bytes: <.main+11392 @06666c> - <.main+11425 @06668d>): static testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+11392 @06666c>: 1a                         load.z64
	<.main+11393 @06666d>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11402 @066676>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11411 @06667f>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11416 @066684>: 02                         call
	<.main+11417 @066685>: 09 f0 ff ff                inc.sp(-16)
	<.main+11421 @066689>: 23 40 39 06                store.m64 <@063940> ;testMathAbsMod_f64_0a
	cmplStd/test/std/test.math.ci:71: (24 bytes: <.main+11425 @06668d> - <.main+11449 @0666a5>): static testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+11425 @06668d>: 1b                         load.z128
	<.main+11426 @06668e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11435 @066697>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11440 @06669c>: 02                         call
	<.main+11441 @06669d>: 09 f0 ff ff                inc.sp(-16)
	<.main+11445 @0666a1>: 23 48 39 06                store.m64 <@063948> ;testMathAbsMod_f64_0b
	cmplStd/test/std/test.math.ci:72: (33 bytes: <.main+11449 @0666a5> - <.main+11482 @0666c6>): static testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+11449 @0666a5>: 1a                         load.z64
	<.main+11450 @0666a6>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11459 @0666af>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11468 @0666b8>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11473 @0666bd>: 02                         call
	<.main+11474 @0666be>: 09 f0 ff ff                inc.sp(-16)
	<.main+11478 @0666c2>: 23 50 39 06                store.m64 <@063950> ;testMathAbsMod_f64_0c
	cmplStd/test/std/test.math.ci:74: (33 bytes: <.main+11482 @0666c6> - <.main+11515 @0666e7>): static testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+11482 @0666c6>: 1a                         load.z64
	<.main+11483 @0666c7>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11492 @0666d0>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11501 @0666d9>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11506 @0666de>: 02                         call
	<.main+11507 @0666df>: 09 f0 ff ff                inc.sp(-16)
	<.main+11511 @0666e3>: 23 58 39 06                store.m64 <@063958> ;testMathAbsMod_f64_9a
	cmplStd/test/std/test.math.ci:75: (33 bytes: <.main+11515 @0666e7> - <.main+11548 @066708>): static testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+11515 @0666e7>: 1a                         load.z64
	<.main+11516 @0666e8>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11525 @0666f1>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11534 @0666fa>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11539 @0666ff>: 02                         call
	<.main+11540 @066700>: 09 f0 ff ff                inc.sp(-16)
	<.main+11544 @066704>: 23 60 39 06                store.m64 <@063960> ;testMathAbsMod_f64_9b
	cmplStd/test/std/test.math.ci:76: (33 bytes: <.main+11548 @066708> - <.main+11581 @066729>): static testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+11548 @066708>: 1a                         load.z64
	<.main+11549 @066709>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11558 @066712>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11567 @06671b>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11572 @066720>: 02                         call
	<.main+11573 @066721>: 09 f0 ff ff                inc.sp(-16)
	<.main+11577 @066725>: 23 68 39 06                store.m64 <@063968> ;testMathAbsMod_f64_9c
	cmplStd/test/std/test.math.ci:77: (33 bytes: <.main+11581 @066729> - <.main+11614 @06674a>): static testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+11581 @066729>: 1a                         load.z64
	<.main+11582 @06672a>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11591 @066733>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11600 @06673c>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11605 @066741>: 02                         call
	<.main+11606 @066742>: 09 f0 ff ff                inc.sp(-16)
	<.main+11610 @066746>: 23 70 39 06                store.m64 <@063970> ;testMathAbsMod_f64_9d
	cmplStd/test/std/test.math.ci:79: (33 bytes: <.main+11614 @06674a> - <.main+11647 @06676b>): static testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+11614 @06674a>: 1a                         load.z64
	<.main+11615 @06674b>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11624 @066754>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11633 @06675d>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11638 @066762>: 02                         call
	<.main+11639 @066763>: 09 f0 ff ff                inc.sp(-16)
	<.main+11643 @066767>: 23 78 39 06                store.m64 <@063978> ;testMathAbsMod_f64_8a
	cmplStd/test/std/test.math.ci:80: (33 bytes: <.main+11647 @06676b> - <.main+11680 @06678c>): static testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+11647 @06676b>: 1a                         load.z64
	<.main+11648 @06676c>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11657 @066775>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11666 @06677e>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11671 @066783>: 02                         call
	<.main+11672 @066784>: 09 f0 ff ff                inc.sp(-16)
	<.main+11676 @066788>: 23 80 39 06                store.m64 <@063980> ;testMathAbsMod_f64_8b
	cmplStd/test/std/test.math.ci:81: (33 bytes: <.main+11680 @06678c> - <.main+11713 @0667ad>): static testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+11680 @06678c>: 1a                         load.z64
	<.main+11681 @06678d>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11690 @066796>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11699 @06679f>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11704 @0667a4>: 02                         call
	<.main+11705 @0667a5>: 09 f0 ff ff                inc.sp(-16)
	<.main+11709 @0667a9>: 23 88 39 06                store.m64 <@063988> ;testMathAbsMod_f64_8c
	cmplStd/test/std/test.math.ci:82: (33 bytes: <.main+11713 @0667ad> - <.main+11746 @0667ce>): static testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+11713 @0667ad>: 1a                         load.z64
	<.main+11714 @0667ae>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11723 @0667b7>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11732 @0667c0>: 1f 70 11 06 00             load.ref <@061170> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11737 @0667c5>: 02                         call
	<.main+11738 @0667c6>: 09 f0 ff ff                inc.sp(-16)
	<.main+11742 @0667ca>: 23 90 39 06                store.m64 <@063990> ;testMathAbsMod_f64_8d
	cmplStd/test/std/test.math.ci:84: (25 bytes: <.main+11746 @0667ce> - <.main+11771 @0667e7>): static testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+11746 @0667ce>: 19                         load.z32
	<.main+11747 @0667cf>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11752 @0667d4>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11757 @0667d9>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11762 @0667de>: 02                         call
	<.main+11763 @0667df>: 09 f8 ff ff                inc.sp(-8)
	<.main+11767 @0667e3>: 24 98 39 06                store.m32 <@063998> ;testMathAbsMod_f32_0a
	cmplStd/test/std/test.math.ci:85: (21 bytes: <.main+11771 @0667e7> - <.main+11792 @0667fc>): static testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+11771 @0667e7>: 19                         load.z32
	<.main+11772 @0667e8>: 19                         load.z32
	<.main+11773 @0667e9>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11778 @0667ee>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11783 @0667f3>: 02                         call
	<.main+11784 @0667f4>: 09 f8 ff ff                inc.sp(-8)
	<.main+11788 @0667f8>: 24 a0 39 06                store.m32 <@0639a0> ;testMathAbsMod_f32_0b
	cmplStd/test/std/test.math.ci:86: (25 bytes: <.main+11792 @0667fc> - <.main+11817 @066815>): static testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+11792 @0667fc>: 19                         load.z32
	<.main+11793 @0667fd>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11798 @066802>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11803 @066807>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11808 @06680c>: 02                         call
	<.main+11809 @06680d>: 09 f8 ff ff                inc.sp(-8)
	<.main+11813 @066811>: 24 a8 39 06                store.m32 <@0639a8> ;testMathAbsMod_f32_0c
	cmplStd/test/std/test.math.ci:88: (25 bytes: <.main+11817 @066815> - <.main+11842 @06682e>): static testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+11817 @066815>: 19                         load.z32
	<.main+11818 @066816>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11823 @06681b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11828 @066820>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11833 @066825>: 02                         call
	<.main+11834 @066826>: 09 f8 ff ff                inc.sp(-8)
	<.main+11838 @06682a>: 24 b0 39 06                store.m32 <@0639b0> ;testMathAbsMod_f32_9a
	cmplStd/test/std/test.math.ci:89: (25 bytes: <.main+11842 @06682e> - <.main+11867 @066847>): static testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+11842 @06682e>: 19                         load.z32
	<.main+11843 @06682f>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11848 @066834>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11853 @066839>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11858 @06683e>: 02                         call
	<.main+11859 @06683f>: 09 f8 ff ff                inc.sp(-8)
	<.main+11863 @066843>: 24 b8 39 06                store.m32 <@0639b8> ;testMathAbsMod_f32_9b
	cmplStd/test/std/test.math.ci:90: (25 bytes: <.main+11867 @066847> - <.main+11892 @066860>): static testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+11867 @066847>: 19                         load.z32
	<.main+11868 @066848>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11873 @06684d>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11878 @066852>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11883 @066857>: 02                         call
	<.main+11884 @066858>: 09 f8 ff ff                inc.sp(-8)
	<.main+11888 @06685c>: 24 c0 39 06                store.m32 <@0639c0> ;testMathAbsMod_f32_9c
	cmplStd/test/std/test.math.ci:91: (25 bytes: <.main+11892 @066860> - <.main+11917 @066879>): static testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+11892 @066860>: 19                         load.z32
	<.main+11893 @066861>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11898 @066866>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11903 @06686b>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11908 @066870>: 02                         call
	<.main+11909 @066871>: 09 f8 ff ff                inc.sp(-8)
	<.main+11913 @066875>: 24 c8 39 06                store.m32 <@0639c8> ;testMathAbsMod_f32_9d
	cmplStd/test/std/test.math.ci:93: (25 bytes: <.main+11917 @066879> - <.main+11942 @066892>): static testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+11917 @066879>: 19                         load.z32
	<.main+11918 @06687a>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11923 @06687f>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11928 @066884>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11933 @066889>: 02                         call
	<.main+11934 @06688a>: 09 f8 ff ff                inc.sp(-8)
	<.main+11938 @06688e>: 24 d0 39 06                store.m32 <@0639d0> ;testMathAbsMod_f32_8a
	cmplStd/test/std/test.math.ci:94: (25 bytes: <.main+11942 @066892> - <.main+11967 @0668ab>): static testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+11942 @066892>: 19                         load.z32
	<.main+11943 @066893>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11948 @066898>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11953 @06689d>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11958 @0668a2>: 02                         call
	<.main+11959 @0668a3>: 09 f8 ff ff                inc.sp(-8)
	<.main+11963 @0668a7>: 24 d8 39 06                store.m32 <@0639d8> ;testMathAbsMod_f32_8b
	cmplStd/test/std/test.math.ci:95: (25 bytes: <.main+11967 @0668ab> - <.main+11992 @0668c4>): static testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+11967 @0668ab>: 19                         load.z32
	<.main+11968 @0668ac>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11973 @0668b1>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11978 @0668b6>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11983 @0668bb>: 02                         call
	<.main+11984 @0668bc>: 09 f8 ff ff                inc.sp(-8)
	<.main+11988 @0668c0>: 24 e0 39 06                store.m32 <@0639e0> ;testMathAbsMod_f32_8c
	cmplStd/test/std/test.math.ci:96: (25 bytes: <.main+11992 @0668c4> - <.main+12017 @0668dd>): static testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+11992 @0668c4>: 19                         load.z32
	<.main+11993 @0668c5>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11998 @0668ca>: 7f 00 00 20 41             load.f32 10.000000
	<.main+12003 @0668cf>: 1f 50 11 06 00             load.ref <@061150> ;Math.absMod(val: float32, mod: float32): float32
	<.main+12008 @0668d4>: 02                         call
	<.main+12009 @0668d5>: 09 f8 ff ff                inc.sp(-8)
	<.main+12013 @0668d9>: 24 e8 39 06                store.m32 <@0639e8> ;testMathAbsMod_f32_8d
	cmplStd/test/std/memory.ci:13: (18 bytes: <.main+12017 @0668dd> - <.main+12035 @0668ef>): pointer.fill(p1, 0, 1024);
	<.main+12017 @0668dd>: 20 f0 27 06                load.m32 <@0627f0> ;p1
	<.main+12021 @0668e1>: 19                         load.z32
	<.main+12022 @0668e2>: 1c 00 04 00 00             load.c32 1024
	<.main+12027 @0668e7>: 01 0b 00 00                nfc(11) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+12031 @0668eb>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:14: (21 bytes: <.main+12035 @0668ef> - <.main+12056 @066904>): pointer.copy(p1, p3, 160);
	<.main+12035 @0668ef>: 20 f0 27 06                load.m32 <@0627f0> ;p1
	<.main+12039 @0668f3>: 20 00 28 06                load.m32 <@062800> ;p3
	<.main+12043 @0668f7>: 1c a0 00 00 00             load.c32 160
	<.main+12048 @0668fc>: 01 0c 00 00                nfc(12) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+12052 @066900>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:17: (13 bytes: <.main+12056 @066904> - <.main+12069 @066911>): free(p1);
	<.main+12056 @066904>: 20 f0 27 06                load.m32 <@0627f0> ;p1
	<.main+12060 @066908>: 19                         load.z32
	<.main+12061 @066909>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+12065 @06690d>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:18: (13 bytes: <.main+12069 @066911> - <.main+12082 @06691e>): free(p2);
	<.main+12069 @066911>: 20 f8 27 06                load.m32 <@0627f8> ;p2
	<.main+12073 @066915>: 19                         load.z32
	<.main+12074 @066916>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+12078 @06691a>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:19: (13 bytes: <.main+12082 @06691e> - <.main+12095 @06692b>): free(p3);
	<.main+12082 @06691e>: 20 00 28 06                load.m32 <@062800> ;p3
	<.main+12086 @066922>: 19                         load.z32
	<.main+12087 @066923>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+12091 @066927>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:20: (13 bytes: <.main+12095 @06692b> - <.main+12108 @066938>): free(p4);
	<.main+12095 @06692b>: 20 08 28 06                load.m32 <@062808> ;p4
	<.main+12099 @06692f>: 19                         load.z32
	<.main+12100 @066930>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+12104 @066934>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:26: (35 bytes: <.main+12108 @066938> - <.main+12143 @06695b>): debug("val1", val1);
	<.main+12108 @066938>: 1f 38 30 04 00             load.ref <@043038> ;"cmplStd/test/std/memory.ci"
	<.main+12113 @06693d>: 1c 1a 00 00 00             load.c32 26
	<.main+12118 @066942>: 1c 0e 00 00 00             load.c32 14
	<.main+12123 @066947>: 19                         load.z32
	<.main+12124 @066948>: 1f 67 30 04 00             load.ref <@043067> ;"val1"
	<.main+12129 @06694d>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12134 @066952>: 1f 10 28 06 00             load.ref <@062810> ;val1
	<.main+12139 @066957>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:27: (35 bytes: <.main+12143 @06695b> - <.main+12178 @06697e>): debug("val2", val2);
	<.main+12143 @06695b>: 1f 38 30 04 00             load.ref <@043038> ;"cmplStd/test/std/memory.ci"
	<.main+12148 @066960>: 1c 1b 00 00 00             load.c32 27
	<.main+12153 @066965>: 1c 0e 00 00 00             load.c32 14
	<.main+12158 @06696a>: 19                         load.z32
	<.main+12159 @06696b>: 1f 6c 30 04 00             load.ref <@04306c> ;"val2"
	<.main+12164 @066970>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12169 @066975>: 1f 18 28 06 00             load.ref <@062818> ;val2
	<.main+12174 @06697a>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:29: (22 bytes: <.main+12178 @06697e> - <.main+12200 @066994>): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+12178 @06697e>: 1f 18 28 06 00             load.ref <@062818> ;val2
	<.main+12183 @066983>: 1f 10 28 06 00             load.ref <@062810> ;val1
	<.main+12188 @066988>: 20 c8 04 00                load.m32 <@0004c8> ;int64+32
	<.main+12192 @06698c>: 01 0d 00 00                nfc(13) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+12196 @066990>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:30: (18 bytes: <.main+12200 @066994> - <.main+12218 @0669a6>): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+12200 @066994>: 1f 10 28 06 00             load.ref <@062810> ;val1
	<.main+12205 @066999>: 19                         load.z32
	<.main+12206 @06699a>: 20 c8 04 00                load.m32 <@0004c8> ;int64+32
	<.main+12210 @06699e>: 01 0b 00 00                nfc(11) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+12214 @0669a2>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:32: (35 bytes: <.main+12218 @0669a6> - <.main+12253 @0669c9>): debug("val1", val1);
	<.main+12218 @0669a6>: 1f 38 30 04 00             load.ref <@043038> ;"cmplStd/test/std/memory.ci"
	<.main+12223 @0669ab>: 1c 20 00 00 00             load.c32 32
	<.main+12228 @0669b0>: 1c 0e 00 00 00             load.c32 14
	<.main+12233 @0669b5>: 19                         load.z32
	<.main+12234 @0669b6>: 1f 67 30 04 00             load.ref <@043067> ;"val1"
	<.main+12239 @0669bb>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12244 @0669c0>: 1f 10 28 06 00             load.ref <@062810> ;val1
	<.main+12249 @0669c5>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:33: (35 bytes: <.main+12253 @0669c9> - <.main+12288 @0669ec>): debug("val2", val2);
	<.main+12253 @0669c9>: 1f 38 30 04 00             load.ref <@043038> ;"cmplStd/test/std/memory.ci"
	<.main+12258 @0669ce>: 1c 21 00 00 00             load.c32 33
	<.main+12263 @0669d3>: 1c 0e 00 00 00             load.c32 14
	<.main+12268 @0669d8>: 19                         load.z32
	<.main+12269 @0669d9>: 1f 6c 30 04 00             load.ref <@04306c> ;"val2"
	<.main+12274 @0669de>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12279 @0669e3>: 1f 18 28 06 00             load.ref <@062818> ;val2
	<.main+12284 @0669e8>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:78: (21 bytes: <.main+12288 @0669ec> - <.main+12309 @066a01>): recordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+12288 @0669ec>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12292 @0669f0>: 1c 01 00 00 00             load.c32 1
	<.main+12297 @0669f5>: 13 04                      set.x32 sp(4)
	<.main+12299 @0669f7>: 1f a8 2d 06 00             load.ref <@062da8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12304 @0669fc>: 02                         call
	<.main+12305 @0669fd>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:79: (20 bytes: <.main+12309 @066a01> - <.main+12329 @066a15>): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+12309 @066a01>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12313 @066a05>: 1c 01 00 00 00             load.c32 1
	<.main+12318 @066a0a>: 13 04                      set.x32 sp(4)
	<.main+12320 @066a0c>: 20 58 2e 06                load.m32 <@062e58> ;recordMethodTest+8
	<.main+12324 @066a10>: 02                         call
	<.main+12325 @066a11>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:97: (19 bytes: <.main+12329 @066a15> - <.main+12348 @066a28>): staticMethod(recordMethodTest, 2);
	<.main+12329 @066a15>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12333 @066a19>: 1c 02 00 00 00             load.c32 2
	<.main+12338 @066a1e>: 1f 60 2e 06 00             load.ref <@062e60> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12343 @066a23>: 02                         call
	<.main+12344 @066a24>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:98: (19 bytes: <.main+12348 @066a28> - <.main+12367 @066a3b>): virtualMethod(recordMethodTest, 2);
	<.main+12348 @066a28>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12352 @066a2c>: 1c 02 00 00 00             load.c32 2
	<.main+12357 @066a31>: 1f a8 2e 06 00             load.ref <@062ea8> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12362 @066a36>: 02                         call
	<.main+12363 @066a37>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:101: (21 bytes: <.main+12367 @066a3b> - <.main+12388 @066a50>): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+12367 @066a3b>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12371 @066a3f>: 1c 03 00 00 00             load.c32 3
	<.main+12376 @066a44>: 13 04                      set.x32 sp(4)
	<.main+12378 @066a46>: 1f a8 2d 06 00             load.ref <@062da8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12383 @066a4b>: 02                         call
	<.main+12384 @066a4c>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:102: (21 bytes: <.main+12388 @066a50> - <.main+12409 @066a65>): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12388 @066a50>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12392 @066a54>: 1c 03 00 00 00             load.c32 3
	<.main+12397 @066a59>: 13 04                      set.x32 sp(4)
	<.main+12399 @066a5b>: 1f d8 2d 06 00             load.ref <@062dd8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12404 @066a60>: 02                         call
	<.main+12405 @066a61>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:103: (20 bytes: <.main+12409 @066a65> - <.main+12429 @066a79>): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12409 @066a65>: 22 50 2e 06                load.m128 <@062e50> ;recordMethodTest
	<.main+12413 @066a69>: 1c 03 00 00 00             load.c32 3
	<.main+12418 @066a6e>: 13 04                      set.x32 sp(4)
	<.main+12420 @066a70>: 20 58 2e 06                load.m32 <@062e58> ;recordMethodTest+8
	<.main+12424 @066a74>: 02                         call
	<.main+12425 @066a75>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.array.ci:35: (35 bytes: <.main+12429 @066a79> - <.main+12464 @066a9c>): debug("string as variant", strFixed);
	<.main+12429 @066a79>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12434 @066a7e>: 1c 23 00 00 00             load.c32 35
	<.main+12439 @066a83>: 1c 0e 00 00 00             load.c32 14
	<.main+12444 @066a88>: 19                         load.z32
	<.main+12445 @066a89>: 1f 18 ef 04 00             load.ref <@04ef18> ;"string as variant"
	<.main+12450 @066a8e>: 1f b0 fa 04 00             load.ref <@04fab0>
	<.main+12455 @066a93>: 1f 58 2f 06 00             load.ref <@062f58> ;strFixed
	<.main+12460 @066a98>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:38: (34 bytes: <.main+12464 @066a9c> - <.main+12498 @066abe>): debug("string as variant", strArray);
	<.main+12464 @066a9c>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12469 @066aa1>: 1c 26 00 00 00             load.c32 38
	<.main+12474 @066aa6>: 1c 0e 00 00 00             load.c32 14
	<.main+12479 @066aab>: 19                         load.z32
	<.main+12480 @066aac>: 1f 18 ef 04 00             load.ref <@04ef18> ;"string as variant"
	<.main+12485 @066ab1>: 1f 90 fc 04 00             load.ref <@04fc90>
	<.main+12490 @066ab6>: 20 60 2f 06                load.m32 <@062f60> ;strArray
	<.main+12494 @066aba>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:41: (34 bytes: <.main+12498 @066abe> - <.main+12532 @066ae0>): debug("string as variant", strSlice);
	<.main+12498 @066abe>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12503 @066ac3>: 1c 29 00 00 00             load.c32 41
	<.main+12508 @066ac8>: 1c 0e 00 00 00             load.c32 14
	<.main+12513 @066acd>: 19                         load.z32
	<.main+12514 @066ace>: 1f 18 ef 04 00             load.ref <@04ef18> ;"string as variant"
	<.main+12519 @066ad3>: 1f d0 fd 04 00             load.ref <@04fdd0>
	<.main+12524 @066ad8>: 20 68 2f 06                load.m32 <@062f68> ;strSlice
	<.main+12528 @066adc>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:48: (53 bytes: <.main+12532 @066ae0> - <.main+12585 @066b15>): assert(arrSliceInitNull.length == (0));
	<.main+12532 @066ae0>: 20 2c 2f 06                load.m32 <@062f2c> ;arrSliceInitNull+4
	<.main+12536 @066ae4>: 19                         load.z32
	<.main+12537 @066ae5>: 57                         ceq.i32
	<.main+12538 @066ae6>: 06 08 00 00                jz <.main+12546 @066aee>
	<.main+12542 @066aea>: 04 2b 00 00                jmp <.main+12585 @066b15>
	<.main+12546 @066aee>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12551 @066af3>: 1c 30 00 00 00             load.c32 48
	<.main+12556 @066af8>: 1c fe ff ff ff             load.c32 -2
	<.main+12561 @066afd>: 1c 80 00 00 00             load.c32 128
	<.main+12566 @066b02>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12571 @066b07>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12576 @066b0c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12581 @066b11>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:49: (61 bytes: <.main+12585 @066b15> - <.main+12646 @066b52>): assert(arrFixedInit[0] == (42));
	<.main+12585 @066b15>: 21 e8 2e 06                load.m64 <@062ee8> ;arrFixedInit
	<.main+12589 @066b19>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12598 @066b22>: 67                         ceq.i64
	<.main+12599 @066b23>: 06 08 00 00                jz <.main+12607 @066b2b>
	<.main+12603 @066b27>: 04 2b 00 00                jmp <.main+12646 @066b52>
	<.main+12607 @066b2b>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12612 @066b30>: 1c 31 00 00 00             load.c32 49
	<.main+12617 @066b35>: 1c fe ff ff ff             load.c32 -2
	<.main+12622 @066b3a>: 1c 80 00 00 00             load.c32 128
	<.main+12627 @066b3f>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12632 @066b44>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12637 @066b49>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12642 @066b4e>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:56: (25 bytes: <.main+12646 @066b52> - <.main+12671 @066b6b>): assertEq(7, arrFixedInit.(length));
	<.main+12646 @066b52>: 1c 07 00 00 00             load.c32 7
	<.main+12651 @066b57>: 1c 07 00 00 00             load.c32 7
	<.main+12656 @066b5c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12661 @066b61>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12666 @066b66>: 02                         call
	<.main+12667 @066b67>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:57: (24 bytes: <.main+12671 @066b6b> - <.main+12695 @066b83>): assertEq(arrFixedInit.(length), arrSliceInitFixed.length);
	<.main+12671 @066b6b>: 1c 07 00 00 00             load.c32 7
	<.main+12676 @066b70>: 20 3c 2f 06                load.m32 <@062f3c> ;arrSliceInitFixed+4
	<.main+12680 @066b74>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12685 @066b79>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12690 @066b7e>: 02                         call
	<.main+12691 @066b7f>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:58: (24 bytes: <.main+12695 @066b83> - <.main+12719 @066b9b>): assertEq(arrFixedInit.(length), arrSliceInitSlice.length);
	<.main+12695 @066b83>: 1c 07 00 00 00             load.c32 7
	<.main+12700 @066b88>: 20 4c 2f 06                load.m32 <@062f4c> ;arrSliceInitSlice+4
	<.main+12704 @066b8c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12709 @066b91>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12714 @066b96>: 02                         call
	<.main+12715 @066b97>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:60: (32 bytes: <.main+12719 @066b9b> - <.main+12751 @066bbb>): assertEq(0, lenSlice(null));
	<.main+12719 @066b9b>: 19                         load.z32
	<.main+12720 @066b9c>: 1a                         load.z64
	<.main+12721 @066b9d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12726 @066ba2>: 1f 70 2f 06 00             load.ref <@062f70> ;lenSlice(values: int64[]): int32
	<.main+12731 @066ba7>: 02                         call
	<.main+12732 @066ba8>: 09 f8 ff ff                inc.sp(-8)
	<.main+12736 @066bac>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12741 @066bb1>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12746 @066bb6>: 02                         call
	<.main+12747 @066bb7>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:61: (31 bytes: <.main+12751 @066bbb> - <.main+12782 @066bda>): assertEq(0, lenSlice(arrSliceInitNull));
	<.main+12751 @066bbb>: 19                         load.z32
	<.main+12752 @066bbc>: 19                         load.z32
	<.main+12753 @066bbd>: 21 28 2f 06                load.m64 <@062f28> ;arrSliceInitNull
	<.main+12757 @066bc1>: 1f 70 2f 06 00             load.ref <@062f70> ;lenSlice(values: int64[]): int32
	<.main+12762 @066bc6>: 02                         call
	<.main+12763 @066bc7>: 09 f8 ff ff                inc.sp(-8)
	<.main+12767 @066bcb>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12772 @066bd0>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12777 @066bd5>: 02                         call
	<.main+12778 @066bd6>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:62: (41 bytes: <.main+12782 @066bda> - <.main+12823 @066c03>): assertEq(arrFixedInit.(length), lenSlice(arrFixedInit));
	<.main+12782 @066bda>: 1c 07 00 00 00             load.c32 7
	<.main+12787 @066bdf>: 19                         load.z32
	<.main+12788 @066be0>: 1c 07 00 00 00             load.c32 7
	<.main+12793 @066be5>: 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+12798 @066bea>: 1f 70 2f 06 00             load.ref <@062f70> ;lenSlice(values: int64[]): int32
	<.main+12803 @066bef>: 02                         call
	<.main+12804 @066bf0>: 09 f8 ff ff                inc.sp(-8)
	<.main+12808 @066bf4>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12813 @066bf9>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12818 @066bfe>: 02                         call
	<.main+12819 @066bff>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:63: (35 bytes: <.main+12823 @066c03> - <.main+12858 @066c26>): assertEq(arrFixedInit.(length), lenSlice(arrSliceInitFixed));
	<.main+12823 @066c03>: 1c 07 00 00 00             load.c32 7
	<.main+12828 @066c08>: 19                         load.z32
	<.main+12829 @066c09>: 21 38 2f 06                load.m64 <@062f38> ;arrSliceInitFixed
	<.main+12833 @066c0d>: 1f 70 2f 06 00             load.ref <@062f70> ;lenSlice(values: int64[]): int32
	<.main+12838 @066c12>: 02                         call
	<.main+12839 @066c13>: 09 f8 ff ff                inc.sp(-8)
	<.main+12843 @066c17>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12848 @066c1c>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12853 @066c21>: 02                         call
	<.main+12854 @066c22>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:64: (35 bytes: <.main+12858 @066c26> - <.main+12893 @066c49>): assertEq(arrFixedInit.(length), lenSlice(arrSliceInitSlice));
	<.main+12858 @066c26>: 1c 07 00 00 00             load.c32 7
	<.main+12863 @066c2b>: 19                         load.z32
	<.main+12864 @066c2c>: 21 48 2f 06                load.m64 <@062f48> ;arrSliceInitSlice
	<.main+12868 @066c30>: 1f 70 2f 06 00             load.ref <@062f70> ;lenSlice(values: int64[]): int32
	<.main+12873 @066c35>: 02                         call
	<.main+12874 @066c36>: 09 f8 ff ff                inc.sp(-8)
	<.main+12878 @066c3a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12883 @066c3f>: 1f 78 10 06 00             load.ref <@061078> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12888 @066c44>: 02                         call
	<.main+12889 @066c45>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:66: (827 bytes: <.main+12893 @066c49> - <.main+13720 @066f84>): for (i: int32 := 0; i < arrFixedInit.(length); i := i + 1)
	<.main+12893 @066c49>: 19                         load.z32
	<.main+12894 @066c4a>: 04 2a 03 00                jmp <.main+13704 @066f74>
	cmplStd/test/lang/init.array.ci:67: (9 bytes: <.main+12898 @066c4e> - <.main+12907 @066c57>): expected: int64 := 42 + i
	<.main+12898 @066c4e>: 1c 2a 00 00 00             load.c32 42
	<.main+12903 @066c53>: 10 01                      dup.x32 sp(1)
	<.main+12905 @066c55>: 51                         add.i32
	<.main+12906 @066c56>: 5b                         i32.2i64
	cmplStd/test/lang/init.array.ci:68: (62 bytes: <.main+12907 @066c57> - <.main+12969 @066c95>): assert(expected == arrFixedInit[i]);
	<.main+12907 @066c57>: 11 00                      dup.x64 sp(0)
	<.main+12909 @066c59>: 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+12914 @066c5e>: 10 05                      dup.x32 sp(5)
	<.main+12916 @066c60>: 0d 08 00 00                mad.u32 8
	<.main+12920 @066c64>: 29                         load.i64
	<.main+12921 @066c65>: 67                         ceq.i64
	<.main+12922 @066c66>: 06 08 00 00                jz <.main+12930 @066c6e>
	<.main+12926 @066c6a>: 04 2b 00 00                jmp <.main+12969 @066c95>
	<.main+12930 @066c6e>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12935 @066c73>: 1c 44 00 00 00             load.c32 68
	<.main+12940 @066c78>: 1c fe ff ff ff             load.c32 -2
	<.main+12945 @066c7d>: 1c 80 00 00 00             load.c32 128
	<.main+12950 @066c82>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12955 @066c87>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12960 @066c8c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12965 @066c91>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:69: (61 bytes: <.main+12969 @066c95> - <.main+13030 @066cd2>): assert(expected == arrArrayInitFixed[i]);
	<.main+12969 @066c95>: 11 00                      dup.x64 sp(0)
	<.main+12971 @066c97>: 20 30 2f 06                load.m32 <@062f30> ;arrArrayInitFixed
	<.main+12975 @066c9b>: 10 05                      dup.x32 sp(5)
	<.main+12977 @066c9d>: 0d 08 00 00                mad.u32 8
	<.main+12981 @066ca1>: 29                         load.i64
	<.main+12982 @066ca2>: 67                         ceq.i64
	<.main+12983 @066ca3>: 06 08 00 00                jz <.main+12991 @066cab>
	<.main+12987 @066ca7>: 04 2b 00 00                jmp <.main+13030 @066cd2>
	<.main+12991 @066cab>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12996 @066cb0>: 1c 45 00 00 00             load.c32 69
	<.main+13001 @066cb5>: 1c fe ff ff ff             load.c32 -2
	<.main+13006 @066cba>: 1c 80 00 00 00             load.c32 128
	<.main+13011 @066cbf>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13016 @066cc4>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13021 @066cc9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13026 @066cce>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:70: (61 bytes: <.main+13030 @066cd2> - <.main+13091 @066d0f>): assert(expected == arrSliceInitFixed[i]);
	<.main+13030 @066cd2>: 11 00                      dup.x64 sp(0)
	<.main+13032 @066cd4>: 20 38 2f 06                load.m32 <@062f38> ;arrSliceInitFixed
	<.main+13036 @066cd8>: 10 05                      dup.x32 sp(5)
	<.main+13038 @066cda>: 0d 08 00 00                mad.u32 8
	<.main+13042 @066cde>: 29                         load.i64
	<.main+13043 @066cdf>: 67                         ceq.i64
	<.main+13044 @066ce0>: 06 08 00 00                jz <.main+13052 @066ce8>
	<.main+13048 @066ce4>: 04 2b 00 00                jmp <.main+13091 @066d0f>
	<.main+13052 @066ce8>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13057 @066ced>: 1c 46 00 00 00             load.c32 70
	<.main+13062 @066cf2>: 1c fe ff ff ff             load.c32 -2
	<.main+13067 @066cf7>: 1c 80 00 00 00             load.c32 128
	<.main+13072 @066cfc>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13077 @066d01>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13082 @066d06>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13087 @066d0b>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:72: (68 bytes: <.main+13091 @066d0f> - <.main+13159 @066d53>): assert(expected == nthFixed(i, arrFixedInit));
	<.main+13091 @066d0f>: 11 00                      dup.x64 sp(0)
	<.main+13093 @066d11>: 1a                         load.z64
	<.main+13094 @066d12>: 10 06                      dup.x32 sp(6)
	<.main+13096 @066d14>: 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+13101 @066d19>: 1f 78 2f 06 00             load.ref <@062f78> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13106 @066d1e>: 02                         call
	<.main+13107 @066d1f>: 09 f8 ff ff                inc.sp(-8)
	<.main+13111 @066d23>: 67                         ceq.i64
	<.main+13112 @066d24>: 06 08 00 00                jz <.main+13120 @066d2c>
	<.main+13116 @066d28>: 04 2b 00 00                jmp <.main+13159 @066d53>
	<.main+13120 @066d2c>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13125 @066d31>: 1c 48 00 00 00             load.c32 72
	<.main+13130 @066d36>: 1c fe ff ff ff             load.c32 -2
	<.main+13135 @066d3b>: 1c 80 00 00 00             load.c32 128
	<.main+13140 @066d40>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13145 @066d45>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13150 @066d4a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13155 @066d4f>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:73: (67 bytes: <.main+13159 @066d53> - <.main+13226 @066d96>): assert(expected == nthFixed(i, arrArrayInitFixed));
	<.main+13159 @066d53>: 11 00                      dup.x64 sp(0)
	<.main+13161 @066d55>: 1a                         load.z64
	<.main+13162 @066d56>: 10 06                      dup.x32 sp(6)
	<.main+13164 @066d58>: 20 30 2f 06                load.m32 <@062f30> ;arrArrayInitFixed
	<.main+13168 @066d5c>: 1f 78 2f 06 00             load.ref <@062f78> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13173 @066d61>: 02                         call
	<.main+13174 @066d62>: 09 f8 ff ff                inc.sp(-8)
	<.main+13178 @066d66>: 67                         ceq.i64
	<.main+13179 @066d67>: 06 08 00 00                jz <.main+13187 @066d6f>
	<.main+13183 @066d6b>: 04 2b 00 00                jmp <.main+13226 @066d96>
	<.main+13187 @066d6f>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13192 @066d74>: 1c 49 00 00 00             load.c32 73
	<.main+13197 @066d79>: 1c fe ff ff ff             load.c32 -2
	<.main+13202 @066d7e>: 1c 80 00 00 00             load.c32 128
	<.main+13207 @066d83>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13212 @066d88>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13217 @066d8d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13222 @066d92>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:74: (67 bytes: <.main+13226 @066d96> - <.main+13293 @066dd9>): assert(expected == nthFixed(i, arrSliceInitFixed));
	<.main+13226 @066d96>: 11 00                      dup.x64 sp(0)
	<.main+13228 @066d98>: 1a                         load.z64
	<.main+13229 @066d99>: 10 06                      dup.x32 sp(6)
	<.main+13231 @066d9b>: 20 38 2f 06                load.m32 <@062f38> ;arrSliceInitFixed
	<.main+13235 @066d9f>: 1f 78 2f 06 00             load.ref <@062f78> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13240 @066da4>: 02                         call
	<.main+13241 @066da5>: 09 f8 ff ff                inc.sp(-8)
	<.main+13245 @066da9>: 67                         ceq.i64
	<.main+13246 @066daa>: 06 08 00 00                jz <.main+13254 @066db2>
	<.main+13250 @066dae>: 04 2b 00 00                jmp <.main+13293 @066dd9>
	<.main+13254 @066db2>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13259 @066db7>: 1c 4a 00 00 00             load.c32 74
	<.main+13264 @066dbc>: 1c fe ff ff ff             load.c32 -2
	<.main+13269 @066dc1>: 1c 80 00 00 00             load.c32 128
	<.main+13274 @066dc6>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13279 @066dcb>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13284 @066dd0>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13289 @066dd5>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:76: (68 bytes: <.main+13293 @066dd9> - <.main+13361 @066e1d>): assert(expected == nthArray(i, arrFixedInit));
	<.main+13293 @066dd9>: 11 00                      dup.x64 sp(0)
	<.main+13295 @066ddb>: 1a                         load.z64
	<.main+13296 @066ddc>: 10 06                      dup.x32 sp(6)
	<.main+13298 @066dde>: 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+13303 @066de3>: 1f 88 2f 06 00             load.ref <@062f88> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13308 @066de8>: 02                         call
	<.main+13309 @066de9>: 09 f8 ff ff                inc.sp(-8)
	<.main+13313 @066ded>: 67                         ceq.i64
	<.main+13314 @066dee>: 06 08 00 00                jz <.main+13322 @066df6>
	<.main+13318 @066df2>: 04 2b 00 00                jmp <.main+13361 @066e1d>
	<.main+13322 @066df6>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13327 @066dfb>: 1c 4c 00 00 00             load.c32 76
	<.main+13332 @066e00>: 1c fe ff ff ff             load.c32 -2
	<.main+13337 @066e05>: 1c 80 00 00 00             load.c32 128
	<.main+13342 @066e0a>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13347 @066e0f>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13352 @066e14>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13357 @066e19>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:77: (67 bytes: <.main+13361 @066e1d> - <.main+13428 @066e60>): assert(expected == nthArray(i, arrArrayInitFixed));
	<.main+13361 @066e1d>: 11 00                      dup.x64 sp(0)
	<.main+13363 @066e1f>: 1a                         load.z64
	<.main+13364 @066e20>: 10 06                      dup.x32 sp(6)
	<.main+13366 @066e22>: 20 30 2f 06                load.m32 <@062f30> ;arrArrayInitFixed
	<.main+13370 @066e26>: 1f 88 2f 06 00             load.ref <@062f88> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13375 @066e2b>: 02                         call
	<.main+13376 @066e2c>: 09 f8 ff ff                inc.sp(-8)
	<.main+13380 @066e30>: 67                         ceq.i64
	<.main+13381 @066e31>: 06 08 00 00                jz <.main+13389 @066e39>
	<.main+13385 @066e35>: 04 2b 00 00                jmp <.main+13428 @066e60>
	<.main+13389 @066e39>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13394 @066e3e>: 1c 4d 00 00 00             load.c32 77
	<.main+13399 @066e43>: 1c fe ff ff ff             load.c32 -2
	<.main+13404 @066e48>: 1c 80 00 00 00             load.c32 128
	<.main+13409 @066e4d>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13414 @066e52>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13419 @066e57>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13424 @066e5c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:78: (67 bytes: <.main+13428 @066e60> - <.main+13495 @066ea3>): assert(expected == nthArray(i, arrSliceInitFixed));
	<.main+13428 @066e60>: 11 00                      dup.x64 sp(0)
	<.main+13430 @066e62>: 1a                         load.z64
	<.main+13431 @066e63>: 10 06                      dup.x32 sp(6)
	<.main+13433 @066e65>: 20 38 2f 06                load.m32 <@062f38> ;arrSliceInitFixed
	<.main+13437 @066e69>: 1f 88 2f 06 00             load.ref <@062f88> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13442 @066e6e>: 02                         call
	<.main+13443 @066e6f>: 09 f8 ff ff                inc.sp(-8)
	<.main+13447 @066e73>: 67                         ceq.i64
	<.main+13448 @066e74>: 06 08 00 00                jz <.main+13456 @066e7c>
	<.main+13452 @066e78>: 04 2b 00 00                jmp <.main+13495 @066ea3>
	<.main+13456 @066e7c>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13461 @066e81>: 1c 4e 00 00 00             load.c32 78
	<.main+13466 @066e86>: 1c fe ff ff ff             load.c32 -2
	<.main+13471 @066e8b>: 1c 80 00 00 00             load.c32 128
	<.main+13476 @066e90>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13481 @066e95>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13486 @066e9a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13491 @066e9f>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:80: (73 bytes: <.main+13495 @066ea3> - <.main+13568 @066eec>): assert(expected == nthSlice(i, arrFixedInit));
	<.main+13495 @066ea3>: 11 00                      dup.x64 sp(0)
	<.main+13497 @066ea5>: 1a                         load.z64
	<.main+13498 @066ea6>: 10 06                      dup.x32 sp(6)
	<.main+13500 @066ea8>: 1c 07 00 00 00             load.c32 7
	<.main+13505 @066ead>: 1f e8 2e 06 00             load.ref <@062ee8> ;arrFixedInit
	<.main+13510 @066eb2>: 1f 98 2f 06 00             load.ref <@062f98> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13515 @066eb7>: 02                         call
	<.main+13516 @066eb8>: 09 f4 ff ff                inc.sp(-12)
	<.main+13520 @066ebc>: 67                         ceq.i64
	<.main+13521 @066ebd>: 06 08 00 00                jz <.main+13529 @066ec5>
	<.main+13525 @066ec1>: 04 2b 00 00                jmp <.main+13568 @066eec>
	<.main+13529 @066ec5>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13534 @066eca>: 1c 50 00 00 00             load.c32 80
	<.main+13539 @066ecf>: 1c fe ff ff ff             load.c32 -2
	<.main+13544 @066ed4>: 1c 80 00 00 00             load.c32 128
	<.main+13549 @066ed9>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13554 @066ede>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13559 @066ee3>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13564 @066ee8>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:82: (67 bytes: <.main+13568 @066eec> - <.main+13635 @066f2f>): assert(expected == nthSlice(i, arrSliceInitFixed));
	<.main+13568 @066eec>: 11 00                      dup.x64 sp(0)
	<.main+13570 @066eee>: 1a                         load.z64
	<.main+13571 @066eef>: 10 06                      dup.x32 sp(6)
	<.main+13573 @066ef1>: 21 38 2f 06                load.m64 <@062f38> ;arrSliceInitFixed
	<.main+13577 @066ef5>: 1f 98 2f 06 00             load.ref <@062f98> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13582 @066efa>: 02                         call
	<.main+13583 @066efb>: 09 f4 ff ff                inc.sp(-12)
	<.main+13587 @066eff>: 67                         ceq.i64
	<.main+13588 @066f00>: 06 08 00 00                jz <.main+13596 @066f08>
	<.main+13592 @066f04>: 04 2b 00 00                jmp <.main+13635 @066f2f>
	<.main+13596 @066f08>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13601 @066f0d>: 1c 52 00 00 00             load.c32 82
	<.main+13606 @066f12>: 1c fe ff ff ff             load.c32 -2
	<.main+13611 @066f17>: 1c 80 00 00 00             load.c32 128
	<.main+13616 @066f1c>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13621 @066f21>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13626 @066f26>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13631 @066f2b>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:84: (61 bytes: <.main+13635 @066f2f> - <.main+13696 @066f6c>): assert(expected == arrSliceInitSlice[i]);
	<.main+13635 @066f2f>: 11 00                      dup.x64 sp(0)
	<.main+13637 @066f31>: 20 48 2f 06                load.m32 <@062f48> ;arrSliceInitSlice
	<.main+13641 @066f35>: 10 05                      dup.x32 sp(5)
	<.main+13643 @066f37>: 0d 08 00 00                mad.u32 8
	<.main+13647 @066f3b>: 29                         load.i64
	<.main+13648 @066f3c>: 67                         ceq.i64
	<.main+13649 @066f3d>: 06 08 00 00                jz <.main+13657 @066f45>
	<.main+13653 @066f41>: 04 2b 00 00                jmp <.main+13696 @066f6c>
	<.main+13657 @066f45>: 1f 68 ee 04 00             load.ref <@04ee68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13662 @066f4a>: 1c 54 00 00 00             load.c32 84
	<.main+13667 @066f4f>: 1c fe ff ff ff             load.c32 -2
	<.main+13672 @066f54>: 1c 80 00 00 00             load.c32 128
	<.main+13677 @066f59>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13682 @066f5e>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13687 @066f63>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13692 @066f68>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13696 @066f6c>: 09 f8 ff ff                inc.sp(-8)
	cmplStd/test/lang/init.array.ci:66: (4 bytes: <.main+13700 @066f70> - <.main+13704 @066f74>): i := i + 1
	<.main+13700 @066f70>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/init.array.ci:66: (12 bytes: <.main+13704 @066f74> - <.main+13716 @066f80>): i < arrFixedInit.(length)
	<.main+13704 @066f74>: 10 00                      dup.x32 sp(0)
	<.main+13706 @066f76>: 1c 07 00 00 00             load.c32 7
	<.main+13711 @066f7b>: 58                         clt.i32
	<.main+13712 @066f7c>: 05 d2 fc ff                jnz <.main+12898 @066c4e>
	<.main+13716 @066f80>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.if.ci:4: (39 bytes: <.main+13720 @066f84> - <.main+13759 @066fab>): raise(raise.debug, 1, "0 == 0", null);
	<.main+13720 @066f84>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13725 @066f89>: 1c 04 00 00 00             load.c32 4
	<.main+13730 @066f8e>: 1c 0e 00 00 00             load.c32 14
	<.main+13735 @066f93>: 1c 01 00 00 00             load.c32 1
	<.main+13740 @066f98>: 1f 7d d5 05 00             load.ref <@05d57d> ;"0 == 0"
	<.main+13745 @066f9d>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13750 @066fa2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13755 @066fa7>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:12: (39 bytes: <.main+13759 @066fab> - <.main+13798 @066fd2>): raise(raise.debug, 3, "0 == 0", null);
	<.main+13759 @066fab>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13764 @066fb0>: 1c 0c 00 00 00             load.c32 12
	<.main+13769 @066fb5>: 1c 0e 00 00 00             load.c32 14
	<.main+13774 @066fba>: 1c 03 00 00 00             load.c32 3
	<.main+13779 @066fbf>: 1f 7d d5 05 00             load.ref <@05d57d> ;"0 == 0"
	<.main+13784 @066fc4>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13789 @066fc9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13794 @066fce>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:22: (39 bytes: <.main+13798 @066fd2> - <.main+13837 @066ff9>): raise(raise.debug, 6, "0 == 0", null);
	<.main+13798 @066fd2>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13803 @066fd7>: 1c 16 00 00 00             load.c32 22
	<.main+13808 @066fdc>: 1c 0e 00 00 00             load.c32 14
	<.main+13813 @066fe1>: 1c 06 00 00 00             load.c32 6
	<.main+13818 @066fe6>: 1f 7d d5 05 00             load.ref <@05d57d> ;"0 == 0"
	<.main+13823 @066feb>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13828 @066ff0>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13833 @066ff5>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:28: (49 bytes: <.main+13837 @066ff9> - <.main+13886 @06702a>): if (t == 0)
	<.main+13837 @066ff9>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+13841 @066ffd>: 19                         load.z32
	<.main+13842 @066ffe>: 57                         ceq.i32
	<.main+13843 @066fff>: 06 2b 00 00                jz <.main+13886 @06702a>
	cmplStd/test/lang/stmt.if.ci:29: (39 bytes: <.main+13847 @067003> - <.main+13886 @06702a>): raise(raise.debug, 7, "t == 0", t);
	<.main+13847 @067003>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13852 @067008>: 1c 1d 00 00 00             load.c32 29
	<.main+13857 @06700d>: 1c 0e 00 00 00             load.c32 14
	<.main+13862 @067012>: 1c 07 00 00 00             load.c32 7
	<.main+13867 @067017>: 1f 8b d5 05 00             load.ref <@05d58b> ;"t == 0"
	<.main+13872 @06701c>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13877 @067021>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+13882 @067026>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:32: (49 bytes: <.main+13886 @06702a> - <.main+13935 @06705b>): if (t != 0)
	<.main+13886 @06702a>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+13890 @06702e>: 19                         load.z32
	<.main+13891 @06702f>: 57                         ceq.i32
	<.main+13892 @067030>: 05 2b 00 00                jnz <.main+13935 @06705b>
	cmplStd/test/lang/stmt.if.ci:33: (39 bytes: <.main+13896 @067034> - <.main+13935 @06705b>): raise(raise.debug, 8, "t != 0", t);
	<.main+13896 @067034>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13901 @067039>: 1c 21 00 00 00             load.c32 33
	<.main+13906 @06703e>: 1c 0e 00 00 00             load.c32 14
	<.main+13911 @067043>: 1c 08 00 00 00             load.c32 8
	<.main+13916 @067048>: 1f 92 d5 05 00             load.ref <@05d592> ;"t != 0"
	<.main+13921 @06704d>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13926 @067052>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+13931 @067057>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:36: (92 bytes: <.main+13935 @06705b> - <.main+14027 @0670b7>): if (t == 0)
	<.main+13935 @06705b>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+13939 @06705f>: 19                         load.z32
	<.main+13940 @067060>: 57                         ceq.i32
	<.main+13941 @067061>: 06 2f 00 00                jz <.main+13988 @067090>
	cmplStd/test/lang/stmt.if.ci:37: (39 bytes: <.main+13945 @067065> - <.main+13984 @06708c>): raise(raise.debug, 9, "t == 0", t);
	<.main+13945 @067065>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13950 @06706a>: 1c 25 00 00 00             load.c32 37
	<.main+13955 @06706f>: 1c 0e 00 00 00             load.c32 14
	<.main+13960 @067074>: 1c 09 00 00 00             load.c32 9
	<.main+13965 @067079>: 1f 8b d5 05 00             load.ref <@05d58b> ;"t == 0"
	<.main+13970 @06707e>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13975 @067083>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+13980 @067088>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13984 @06708c>: 04 2b 00 00                jmp <.main+14027 @0670b7>
	cmplStd/test/lang/stmt.if.ci:40: (39 bytes: <.main+13988 @067090> - <.main+14027 @0670b7>): raise(raise.debug, 10, "t != 0", t);
	<.main+13988 @067090>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13993 @067095>: 1c 28 00 00 00             load.c32 40
	<.main+13998 @06709a>: 1c 0e 00 00 00             load.c32 14
	<.main+14003 @06709f>: 1c 0a 00 00 00             load.c32 10
	<.main+14008 @0670a4>: 1f 92 d5 05 00             load.ref <@05d592> ;"t != 0"
	<.main+14013 @0670a9>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14018 @0670ae>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14023 @0670b3>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:43: (92 bytes: <.main+14027 @0670b7> - <.main+14119 @067113>): if (t != 0)
	<.main+14027 @0670b7>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14031 @0670bb>: 19                         load.z32
	<.main+14032 @0670bc>: 57                         ceq.i32
	<.main+14033 @0670bd>: 05 2f 00 00                jnz <.main+14080 @0670ec>
	cmplStd/test/lang/stmt.if.ci:44: (39 bytes: <.main+14037 @0670c1> - <.main+14076 @0670e8>): raise(raise.debug, 11, "t != 0", t);
	<.main+14037 @0670c1>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14042 @0670c6>: 1c 2c 00 00 00             load.c32 44
	<.main+14047 @0670cb>: 1c 0e 00 00 00             load.c32 14
	<.main+14052 @0670d0>: 1c 0b 00 00 00             load.c32 11
	<.main+14057 @0670d5>: 1f 92 d5 05 00             load.ref <@05d592> ;"t != 0"
	<.main+14062 @0670da>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14067 @0670df>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14072 @0670e4>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14076 @0670e8>: 04 2b 00 00                jmp <.main+14119 @067113>
	cmplStd/test/lang/stmt.if.ci:47: (39 bytes: <.main+14080 @0670ec> - <.main+14119 @067113>): raise(raise.debug, 12, "t == 0", t);
	<.main+14080 @0670ec>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14085 @0670f1>: 1c 2f 00 00 00             load.c32 47
	<.main+14090 @0670f6>: 1c 0e 00 00 00             load.c32 14
	<.main+14095 @0670fb>: 1c 0c 00 00 00             load.c32 12
	<.main+14100 @067100>: 1f 8b d5 05 00             load.ref <@05d58b> ;"t == 0"
	<.main+14105 @067105>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14110 @06710a>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14115 @06710f>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:50: (377 bytes: <.main+14119 @067113> - <.main+14496 @06728c>): if (t == 0)
	<.main+14119 @067113>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14123 @067117>: 19                         load.z32
	<.main+14124 @067118>: 57                         ceq.i32
	<.main+14125 @067119>: 06 2f 00 00                jz <.main+14172 @067148>
	cmplStd/test/lang/stmt.if.ci:51: (39 bytes: <.main+14129 @06711d> - <.main+14168 @067144>): raise(raise.debug, 9, "t == 0", t);
	<.main+14129 @06711d>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14134 @067122>: 1c 33 00 00 00             load.c32 51
	<.main+14139 @067127>: 1c 0e 00 00 00             load.c32 14
	<.main+14144 @06712c>: 1c 09 00 00 00             load.c32 9
	<.main+14149 @067131>: 1f 8b d5 05 00             load.ref <@05d58b> ;"t == 0"
	<.main+14154 @067136>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14159 @06713b>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14164 @067140>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14168 @067144>: 04 48 01 00                jmp <.main+14496 @06728c>
	cmplStd/test/lang/stmt.if.ci:53: (324 bytes: <.main+14172 @067148> - <.main+14496 @06728c>): if (t == 1)
	<.main+14172 @067148>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14176 @06714c>: 1c 01 00 00 00             load.c32 1
	<.main+14181 @067151>: 57                         ceq.i32
	<.main+14182 @067152>: 06 2f 00 00                jz <.main+14229 @067181>
	cmplStd/test/lang/stmt.if.ci:54: (39 bytes: <.main+14186 @067156> - <.main+14225 @06717d>): raise(raise.debug, 10, "t == 1", t);
	<.main+14186 @067156>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14191 @06715b>: 1c 36 00 00 00             load.c32 54
	<.main+14196 @067160>: 1c 0e 00 00 00             load.c32 14
	<.main+14201 @067165>: 1c 0a 00 00 00             load.c32 10
	<.main+14206 @06716a>: 1f 99 d5 05 00             load.ref <@05d599> ;"t == 1"
	<.main+14211 @06716f>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14216 @067174>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14221 @067179>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14225 @06717d>: 04 0f 01 00                jmp <.main+14496 @06728c>
	cmplStd/test/lang/stmt.if.ci:56: (267 bytes: <.main+14229 @067181> - <.main+14496 @06728c>): if (t == 2)
	<.main+14229 @067181>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14233 @067185>: 1c 02 00 00 00             load.c32 2
	<.main+14238 @06718a>: 57                         ceq.i32
	<.main+14239 @06718b>: 06 2f 00 00                jz <.main+14286 @0671ba>
	cmplStd/test/lang/stmt.if.ci:57: (39 bytes: <.main+14243 @06718f> - <.main+14282 @0671b6>): raise(raise.debug, 10, "t == 2", t);
	<.main+14243 @06718f>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14248 @067194>: 1c 39 00 00 00             load.c32 57
	<.main+14253 @067199>: 1c 0e 00 00 00             load.c32 14
	<.main+14258 @06719e>: 1c 0a 00 00 00             load.c32 10
	<.main+14263 @0671a3>: 1f a0 d5 05 00             load.ref <@05d5a0> ;"t == 2"
	<.main+14268 @0671a8>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14273 @0671ad>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14278 @0671b2>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14282 @0671b6>: 04 d6 00 00                jmp <.main+14496 @06728c>
	cmplStd/test/lang/stmt.if.ci:59: (210 bytes: <.main+14286 @0671ba> - <.main+14496 @06728c>): if (t == 3)
	<.main+14286 @0671ba>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14290 @0671be>: 1c 03 00 00 00             load.c32 3
	<.main+14295 @0671c3>: 57                         ceq.i32
	<.main+14296 @0671c4>: 06 2f 00 00                jz <.main+14343 @0671f3>
	cmplStd/test/lang/stmt.if.ci:60: (39 bytes: <.main+14300 @0671c8> - <.main+14339 @0671ef>): raise(raise.debug, 10, "t == 3", t);
	<.main+14300 @0671c8>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14305 @0671cd>: 1c 3c 00 00 00             load.c32 60
	<.main+14310 @0671d2>: 1c 0e 00 00 00             load.c32 14
	<.main+14315 @0671d7>: 1c 0a 00 00 00             load.c32 10
	<.main+14320 @0671dc>: 1f a7 d5 05 00             load.ref <@05d5a7> ;"t == 3"
	<.main+14325 @0671e1>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14330 @0671e6>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14335 @0671eb>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14339 @0671ef>: 04 9d 00 00                jmp <.main+14496 @06728c>
	cmplStd/test/lang/stmt.if.ci:62: (153 bytes: <.main+14343 @0671f3> - <.main+14496 @06728c>): if (t == 4)
	<.main+14343 @0671f3>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14347 @0671f7>: 1c 04 00 00 00             load.c32 4
	<.main+14352 @0671fc>: 57                         ceq.i32
	<.main+14353 @0671fd>: 06 2f 00 00                jz <.main+14400 @06722c>
	cmplStd/test/lang/stmt.if.ci:63: (39 bytes: <.main+14357 @067201> - <.main+14396 @067228>): raise(raise.debug, 10, "t == 4", t);
	<.main+14357 @067201>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14362 @067206>: 1c 3f 00 00 00             load.c32 63
	<.main+14367 @06720b>: 1c 0e 00 00 00             load.c32 14
	<.main+14372 @067210>: 1c 0a 00 00 00             load.c32 10
	<.main+14377 @067215>: 1f ae d5 05 00             load.ref <@05d5ae> ;"t == 4"
	<.main+14382 @06721a>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14387 @06721f>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14392 @067224>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14396 @067228>: 04 64 00 00                jmp <.main+14496 @06728c>
	cmplStd/test/lang/stmt.if.ci:65: (96 bytes: <.main+14400 @06722c> - <.main+14496 @06728c>): if (t == 5)
	<.main+14400 @06722c>: 20 88 37 06                load.m32 <@063788> ;t
	<.main+14404 @067230>: 1c 05 00 00 00             load.c32 5
	<.main+14409 @067235>: 57                         ceq.i32
	<.main+14410 @067236>: 06 2f 00 00                jz <.main+14457 @067265>
	cmplStd/test/lang/stmt.if.ci:66: (39 bytes: <.main+14414 @06723a> - <.main+14453 @067261>): raise(raise.debug, 10, "t == 5", t);
	<.main+14414 @06723a>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14419 @06723f>: 1c 42 00 00 00             load.c32 66
	<.main+14424 @067244>: 1c 0e 00 00 00             load.c32 14
	<.main+14429 @067249>: 1c 0a 00 00 00             load.c32 10
	<.main+14434 @06724e>: 1f b5 d5 05 00             load.ref <@05d5b5> ;"t == 5"
	<.main+14439 @067253>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14444 @067258>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14449 @06725d>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14453 @067261>: 04 2b 00 00                jmp <.main+14496 @06728c>
	cmplStd/test/lang/stmt.if.ci:69: (39 bytes: <.main+14457 @067265> - <.main+14496 @06728c>): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+14457 @067265>: 1f 60 d5 05 00             load.ref <@05d560> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14462 @06726a>: 1c 45 00 00 00             load.c32 69
	<.main+14467 @06726f>: 1c 0e 00 00 00             load.c32 14
	<.main+14472 @067274>: 1c 0a 00 00 00             load.c32 10
	<.main+14477 @067279>: 1f bc d5 05 00             load.ref <@05d5bc> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14482 @06727e>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14487 @067283>: 1f 88 37 06 00             load.ref <@063788> ;t
	<.main+14492 @067288>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:3: (47 bytes: <.main+14496 @06728c> - <.main+14543 @0672bb>): for ( ; ; )
	<.main+14496 @06728c>: 04 2b 00 00                jmp <.main+14539 @0672b7>
	cmplStd/test/lang/stmt.for.ci:4: (35 bytes: <.main+14500 @067290> - <.main+14535 @0672b3>): debug("for ( ; ; )");
	<.main+14500 @067290>: 1f a8 d6 05 00             load.ref <@05d6a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14505 @067295>: 1c 04 00 00 00             load.c32 4
	<.main+14510 @06729a>: 1c 0e 00 00 00             load.c32 14
	<.main+14515 @06729f>: 19                         load.z32
	<.main+14516 @0672a0>: 1f c6 d6 05 00             load.ref <@05d6c6> ;"for ( ; ; )"
	<.main+14521 @0672a5>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+14526 @0672aa>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14531 @0672af>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:5: (4 bytes: <.main+14535 @0672b3> - <.main+14539 @0672b7>): break;
	<.main+14535 @0672b3>: 04 08 00 00                jmp <.main+14543 @0672bb>
	:: (4 bytes: <.main+14539 @0672b7> - <.main+14543 @0672bb>)
	<.main+14539 @0672b7>: 04 d9 ff ff                jmp <.main+14500 @067290>
	cmplStd/test/lang/stmt.for.ci:8: (59 bytes: <.main+14543 @0672bb> - <.main+14602 @0672f6>): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+14543 @0672bb>: 19                         load.z32
	<.main+14544 @0672bc>: 04 2a 00 00                jmp <.main+14586 @0672e6>
	cmplStd/test/lang/stmt.for.ci:9: (34 bytes: <.main+14548 @0672c0> - <.main+14582 @0672e2>): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+14548 @0672c0>: 1f a8 d6 05 00             load.ref <@05d6a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14553 @0672c5>: 1c 09 00 00 00             load.c32 9
	<.main+14558 @0672ca>: 1c 0e 00 00 00             load.c32 14
	<.main+14563 @0672cf>: 19                         load.z32
	<.main+14564 @0672d0>: 1f d2 d6 05 00             load.ref <@05d6d2> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14569 @0672d5>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14574 @0672da>: 0a 18 00 00                load.sp(+24)
	<.main+14578 @0672de>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:8: (4 bytes: <.main+14582 @0672e2> - <.main+14586 @0672e6>): i := i + 1
	<.main+14582 @0672e2>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:8: (12 bytes: <.main+14586 @0672e6> - <.main+14598 @0672f2>): i < 2
	<.main+14586 @0672e6>: 10 00                      dup.x32 sp(0)
	<.main+14588 @0672e8>: 1c 02 00 00 00             load.c32 2
	<.main+14593 @0672ed>: 58                         clt.i32
	<.main+14594 @0672ee>: 05 d2 ff ff                jnz <.main+14548 @0672c0>
	<.main+14598 @0672f2>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:13: (70 bytes: <.main+14602 @0672f6> - <.main+14672 @06733c>): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+14602 @0672f6>: 19                         load.z32
	<.main+14603 @0672f7>: 24 90 37 06                store.m32 <@063790> ;forIdx
	<.main+14607 @0672fb>: 04 33 00 00                jmp <.main+14658 @06732e>
	cmplStd/test/lang/stmt.for.ci:14: (35 bytes: <.main+14611 @0672ff> - <.main+14646 @067322>): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+14611 @0672ff>: 1f a8 d6 05 00             load.ref <@05d6a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14616 @067304>: 1c 0e 00 00 00             load.c32 14
	<.main+14621 @067309>: 1c 0e 00 00 00             load.c32 14
	<.main+14626 @06730e>: 19                         load.z32
	<.main+14627 @06730f>: 1f f8 d6 05 00             load.ref <@05d6f8> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14632 @067314>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14637 @067319>: 1f 90 37 06 00             load.ref <@063790> ;forIdx
	<.main+14642 @06731e>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:13: (12 bytes: <.main+14646 @067322> - <.main+14658 @06732e>): forIdx := forIdx + 1
	<.main+14646 @067322>: 20 90 37 06                load.m32 <@063790> ;forIdx
	<.main+14650 @067326>: 0c 01 00 00                inc.i32(+1)
	<.main+14654 @06732a>: 24 90 37 06                store.m32 <@063790> ;forIdx
	cmplStd/test/lang/stmt.for.ci:13: (14 bytes: <.main+14658 @06732e> - <.main+14672 @06733c>): forIdx < 2
	<.main+14658 @06732e>: 20 90 37 06                load.m32 <@063790> ;forIdx
	<.main+14662 @067332>: 1c 02 00 00 00             load.c32 2
	<.main+14667 @067337>: 58                         clt.i32
	<.main+14668 @067338>: 05 c7 ff ff                jnz <.main+14611 @0672ff>
	cmplStd/test/lang/stmt.for.ci:17: (75 bytes: <.main+14672 @06733c> - <.main+14747 @067387>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+14672 @06733c>: 19                         load.z32
	<.main+14673 @06733d>: 04 3a 00 00                jmp <.main+14731 @067377>
	cmplStd/test/lang/stmt.for.ci:18: (16 bytes: <.main+14677 @067341> - <.main+14693 @067351>): if (i < 2)
	<.main+14677 @067341>: 10 00                      dup.x32 sp(0)
	<.main+14679 @067343>: 1c 02 00 00 00             load.c32 2
	<.main+14684 @067348>: 58                         clt.i32
	<.main+14685 @067349>: 06 08 00 00                jz <.main+14693 @067351>
	cmplStd/test/lang/stmt.for.ci:19: (4 bytes: <.main+14689 @06734d> - <.main+14693 @067351>): continue;
	<.main+14689 @06734d>: 04 26 00 00                jmp <.main+14727 @067373>
	cmplStd/test/lang/stmt.for.ci:21: (34 bytes: <.main+14693 @067351> - <.main+14727 @067373>): debug("for with continue", i);
	<.main+14693 @067351>: 1f a8 d6 05 00             load.ref <@05d6a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14698 @067356>: 1c 15 00 00 00             load.c32 21
	<.main+14703 @06735b>: 1c 0e 00 00 00             load.c32 14
	<.main+14708 @067360>: 19                         load.z32
	<.main+14709 @067361>: 1f 22 d7 05 00             load.ref <@05d722> ;"for with continue"
	<.main+14714 @067366>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14719 @06736b>: 0a 18 00 00                load.sp(+24)
	<.main+14723 @06736f>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:17: (4 bytes: <.main+14727 @067373> - <.main+14731 @067377>): i := i + 1
	<.main+14727 @067373>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:17: (12 bytes: <.main+14731 @067377> - <.main+14743 @067383>): i < 7
	<.main+14731 @067377>: 10 00                      dup.x32 sp(0)
	<.main+14733 @067379>: 1c 07 00 00 00             load.c32 7
	<.main+14738 @06737e>: 58                         clt.i32
	<.main+14739 @06737f>: 05 c2 ff ff                jnz <.main+14677 @067341>
	<.main+14743 @067383>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:24: (75 bytes: <.main+14747 @067387> - <.main+14822 @0673d2>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+14747 @067387>: 19                         load.z32
	<.main+14748 @067388>: 04 3a 00 00                jmp <.main+14806 @0673c2>
	cmplStd/test/lang/stmt.for.ci:25: (16 bytes: <.main+14752 @06738c> - <.main+14768 @06739c>): if (i > 2)
	<.main+14752 @06738c>: 10 00                      dup.x32 sp(0)
	<.main+14754 @06738e>: 1c 02 00 00 00             load.c32 2
	<.main+14759 @067393>: 59                         cgt.i32
	<.main+14760 @067394>: 06 08 00 00                jz <.main+14768 @06739c>
	cmplStd/test/lang/stmt.for.ci:26: (4 bytes: <.main+14764 @067398> - <.main+14768 @06739c>): break;
	<.main+14764 @067398>: 04 36 00 00                jmp <.main+14818 @0673ce>
	cmplStd/test/lang/stmt.for.ci:28: (34 bytes: <.main+14768 @06739c> - <.main+14802 @0673be>): debug("for with break", i);
	<.main+14768 @06739c>: 1f a8 d6 05 00             load.ref <@05d6a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14773 @0673a1>: 1c 1c 00 00 00             load.c32 28
	<.main+14778 @0673a6>: 1c 0e 00 00 00             load.c32 14
	<.main+14783 @0673ab>: 19                         load.z32
	<.main+14784 @0673ac>: 1f 34 d7 05 00             load.ref <@05d734> ;"for with break"
	<.main+14789 @0673b1>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14794 @0673b6>: 0a 18 00 00                load.sp(+24)
	<.main+14798 @0673ba>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:24: (4 bytes: <.main+14802 @0673be> - <.main+14806 @0673c2>): i := i + 1
	<.main+14802 @0673be>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:24: (12 bytes: <.main+14806 @0673c2> - <.main+14818 @0673ce>): i < 7
	<.main+14806 @0673c2>: 10 00                      dup.x32 sp(0)
	<.main+14808 @0673c4>: 1c 07 00 00 00             load.c32 7
	<.main+14813 @0673c9>: 58                         clt.i32
	<.main+14814 @0673ca>: 05 c2 ff ff                jnz <.main+14752 @06738c>
	<.main+14818 @0673ce>: 09 fc ff ff                inc.sp(-4)
	<.main+14822 @0673d2>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 173.39] > .main
[ 173.42]  > float32.sin(x: float32): float32
[ 173.44]  < return
[ 173.76]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 173.77]  < return
[ 173.78]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 173.79]  < return
[ 173.80]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 173.81]  < return
[ 173.81]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 173.83]  < return
[ 173.83]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 173.84]  < return
[ 173.85]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 173.86]  < return
[ 173.87]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 173.88]  < return
[ 173.88]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 173.90]  < return
[ 173.90]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 173.91]  < return
[ 173.92]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 173.93]  < return
[ 173.94]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 173.95]  < return
[ 173.96]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 173.97]  < return
[ 173.97]  > float64.sin(x: float64): float64
[ 173.99]  < return
[ 173.99]  > float64.cos(x: float64): float64
[ 174.01]  < return
[ 174.01]  > float64.tan(x: float64): float64
[ 174.02]  < return
[ 174.03]  > float64.log(x: float64): float64
[ 174.04]  < return
[ 174.05]  > float64.exp(x: float64): float64
[ 174.06]  < return
[ 174.07]  > float64.pow(x: float64, y: float64): float64
[ 174.08]  < return
[ 174.09]  > float64.sqrt(x: float64): float64
[ 174.10]  < return
[ 174.10]  > float64.atan2(x: float64, y: float64): float64
[ 174.12]  < return
[ 174.12]  > float32.sin(x: float32): float32
[ 174.13]  < return
[ 174.14]  > float32.cos(x: float32): float32
[ 174.15]  < return
[ 174.16]  > float32.tan(x: float32): float32
[ 174.17]  < return
[ 174.18]  > float32.log(x: float32): float32
[ 174.19]  < return
[ 174.19]  > float32.exp(x: float32): float32
[ 174.21]  < return
[ 174.21]  > float32.pow(x: float32, y: float32): float32
[ 174.22]  < return
[ 174.23]  > float32.sqrt(x: float32): float32
[ 174.24]  < return
[ 174.25]  > float32.atan2(x: float32, y: float32): float32
[ 174.26]  < return
[ 174.26]  > uint32.pop(value: int32): int32
[ 174.28]  < return
[ 174.28]  > uint32.swap(value: int32): int32
[ 174.29]  < return
[ 174.30]  > uint32.bsr(value: int32): int32
[ 174.31]  < return
[ 174.31]  > uint32.bsf(value: int32): int32
[ 174.32]  < return
[ 174.33]  > uint32.hib(value: int32): int32
[ 174.34]  < return
[ 174.35]  > uint32.lob(value: int32): int32
[ 174.36]  < return
[ 174.36]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 174.38]  < return
[ 174.38]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 174.39]  < return
[ 174.40]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 174.41]  < return
[ 174.42]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 174.43]  < return
[ 174.44]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 174.45]  < return
[ 174.46]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 174.47]  < return
[ 174.47]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 174.48]  < return
[ 174.49]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 174.50]  < return
[ 174.51]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 174.52]   > noError(ptr: pointer): void
[ 174.53]   < return
[ 174.53]   > halt(): void
[ 174.54]   < return
[ 174.54]  < return
[ 174.55]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 174.56]  < return
[ 174.57]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 174.57]   > stackOverflow(ptr: pointer): void
[ 174.58]    > stackOverflow(ptr: pointer): void
[ 174.59]     > stackOverflow(ptr: pointer): void
[ 174.60]      > stackOverflow(ptr: pointer): void
[ 174.61]       > stackOverflow(ptr: pointer): void
[ 174.62]        > stackOverflow(ptr: pointer): void
[ 174.63]         > stackOverflow(ptr: pointer): void
[ 174.64]          > stackOverflow(ptr: pointer): void
[ 174.65]           > stackOverflow(ptr: pointer): void
[ 174.65]            > stackOverflow(ptr: pointer): void
[ 174.66]             > stackOverflow(ptr: pointer): void
[ 174.67]              > stackOverflow(ptr: pointer): void
[ 174.68]               > stackOverflow(ptr: pointer): void
[ 174.69]                > stackOverflow(ptr: pointer): void
[ 174.70]                 > stackOverflow(ptr: pointer): void
[ 174.71]                  > stackOverflow(ptr: pointer): void
[ 174.71]                   > stackOverflow(ptr: pointer): void
[ 174.72]                    > stackOverflow(ptr: pointer): void
[ 174.73]                     > stackOverflow(ptr: pointer): void
[ 174.74]                      > stackOverflow(ptr: pointer): void
[ 174.75]                       > stackOverflow(ptr: pointer): void
[ 174.76]                        > stackOverflow(ptr: pointer): void
[ 174.77]                         > stackOverflow(ptr: pointer): void
[ 174.77]                          > stackOverflow(ptr: pointer): void
[ 174.78]                           > stackOverflow(ptr: pointer): void
[ 174.79]                            > stackOverflow(ptr: pointer): void
[ 174.80]                             > stackOverflow(ptr: pointer): void
[ 174.81]                              > stackOverflow(ptr: pointer): void
[ 174.82]                               > stackOverflow(ptr: pointer): void
[ 174.83]                                > stackOverflow(ptr: pointer): void
[ 174.84]                                 > stackOverflow(ptr: pointer): void
[ 174.84]                                  > stackOverflow(ptr: pointer): void
[ 174.85]                                   > stackOverflow(ptr: pointer): void
[ 174.86]                                    > stackOverflow(ptr: pointer): void
[ 174.87]                                     > stackOverflow(ptr: pointer): void
[ 174.88]                                      > stackOverflow(ptr: pointer): void
[ 174.89]                                       > stackOverflow(ptr: pointer): void
[ 174.90]                                        > stackOverflow(ptr: pointer): void
[ 174.91]                                         > stackOverflow(ptr: pointer): void
[ 174.91]                                          > stackOverflow(ptr: pointer): void
[ 174.92]                                           > stackOverflow(ptr: pointer): void
[ 174.93]                                            > stackOverflow(ptr: pointer): void
[ 174.94]                                             > stackOverflow(ptr: pointer): void
[ 174.95]                                              > stackOverflow(ptr: pointer): void
[ 174.96]                                               > stackOverflow(ptr: pointer): void
[ 174.97]                                                > stackOverflow(ptr: pointer): void
[ 174.97]                                                 > stackOverflow(ptr: pointer): void
[ 174.98]                                                  > stackOverflow(ptr: pointer): void
[ 175.00]                                                   > stackOverflow(ptr: pointer): void
[ 175.00]                                                    > stackOverflow(ptr: pointer): void
[ 175.01]                                                     > stackOverflow(ptr: pointer): void
[ 175.02]                                                      > stackOverflow(ptr: pointer): void
[ 175.03]                                                       > stackOverflow(ptr: pointer): void
[ 175.04]                                                        > stackOverflow(ptr: pointer): void
[ 175.05]                                                         > stackOverflow(ptr: pointer): void
[ 175.06]                                                          > stackOverflow(ptr: pointer): void
[ 175.07]                                                           > stackOverflow(ptr: pointer): void
[ 175.07]                                                            > stackOverflow(ptr: pointer): void
[ 175.08]                                                             > stackOverflow(ptr: pointer): void
[ 175.09]                                                              > stackOverflow(ptr: pointer): void
[ 175.10]                                                               > stackOverflow(ptr: pointer): void
[ 175.11]                                                                > stackOverflow(ptr: pointer): void
[ 175.12]                                                                 > stackOverflow(ptr: pointer): void
[ 175.13]                                                                  > stackOverflow(ptr: pointer): void
[ 175.14]                                                                   > stackOverflow(ptr: pointer): void
[ 175.15]                                                                    > stackOverflow(ptr: pointer): void
[ 175.15]                                                                     > stackOverflow(ptr: pointer): void
[ 175.16]                                                                      > stackOverflow(ptr: pointer): void
[ 175.17]                                                                       > stackOverflow(ptr: pointer): void
[ 175.18]                                                                        > stackOverflow(ptr: pointer): void
[ 175.19]                                                                         > stackOverflow(ptr: pointer): void
[ 175.20]                                                                          > stackOverflow(ptr: pointer): void
[ 175.21]                                                                           > stackOverflow(ptr: pointer): void
[ 175.22]                                                                            > stackOverflow(ptr: pointer): void
[ 175.22]                                                                             > stackOverflow(ptr: pointer): void
[ 175.23]                                                                              > stackOverflow(ptr: pointer): void
[ 175.24]                                                                               > stackOverflow(ptr: pointer): void
[ 175.25]                                                                                > stackOverflow(ptr: pointer): void
[ 175.26]                                                                                 > stackOverflow(ptr: pointer): void
[ 175.27]                                                                                  > stackOverflow(ptr: pointer): void
[ 175.28]                                                                                   > stackOverflow(ptr: pointer): void
[ 175.28]                                                                                    > stackOverflow(ptr: pointer): void
[ 175.29]                                                                                     > stackOverflow(ptr: pointer): void
[ 175.30]                                                                                      > stackOverflow(ptr: pointer): void
[ 175.31]                                                                                       > stackOverflow(ptr: pointer): void
[ 175.32]                                                                                        > stackOverflow(ptr: pointer): void
[ 175.33]                                                                                         > stackOverflow(ptr: pointer): void
[ 175.34]                                                                                          > stackOverflow(ptr: pointer): void
[ 175.35]                                                                                           > stackOverflow(ptr: pointer): void
[ 175.36]                                                                                            > stackOverflow(ptr: pointer): void
[ 175.37]                                                                                             > stackOverflow(ptr: pointer): void
[ 175.38]                                                                                              > stackOverflow(ptr: pointer): void
[ 175.38]                                                                                               > stackOverflow(ptr: pointer): void
[ 175.39]                                                                                                > stackOverflow(ptr: pointer): void
[ 175.40]                                                                                                 > stackOverflow(ptr: pointer): void
[ 175.41]                                                                                                  > stackOverflow(ptr: pointer): void
[ 175.42]                                                                                                   > stackOverflow(ptr: pointer): void
[ 175.43]                                                                                                    > stackOverflow(ptr: pointer): void
[ 175.44]                                                                                                     > stackOverflow(ptr: pointer): void
[ 175.45]                                                                                                      > stackOverflow(ptr: pointer): void
[ 175.46]                                                                                                       > stackOverflow(ptr: pointer): void
[ 175.46]                                                                                                        > stackOverflow(ptr: pointer): void
[ 175.47]                                                                                                         > stackOverflow(ptr: pointer): void
[ 175.48]                                                                                                          > stackOverflow(ptr: pointer): void
[ 175.49]                                                                                                           > stackOverflow(ptr: pointer): void
[ 175.50]                                                                                                            > stackOverflow(ptr: pointer): void
[ 175.51]                                                                                                             > stackOverflow(ptr: pointer): void
[ 175.52]                                                                                                              > stackOverflow(ptr: pointer): void
[ 175.53]                                                                                                               > stackOverflow(ptr: pointer): void
[ 175.53]                                                                                                                > stackOverflow(ptr: pointer): void
[ 175.54]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 175.55]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 175.56]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 175.58]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 175.59]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 175.59]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 175.60]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 175.61]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 175.62]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 175.63]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 175.64]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 175.65]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 175.66]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 175.66]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 175.67]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 175.68]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 175.69]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 175.70]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 175.71]                                                                                                                                  < return
[ 175.71]                                                                                                                                 < return
[ 175.72]                                                                                                                                < return
[ 175.72]                                                                                                                               < return
[ 175.73]                                                                                                                              < return
[ 175.73]                                                                                                                             < return
[ 175.74]                                                                                                                            < return
[ 175.74]                                                                                                                           < return
[ 175.74]                                                                                                                          < return
[ 175.75]                                                                                                                         < return
[ 175.75]                                                                                                                        < return
[ 175.76]                                                                                                                       < return
[ 175.76]                                                                                                                      < return
[ 175.77]                                                                                                                     < return
[ 175.77]                                                                                                                    < return
[ 175.78]                                                                                                                   < return
[ 175.78]                                                                                                                  < return
[ 175.78]                                                                                                                 < return
[ 175.79]                                                                                                                < return
[ 175.79]                                                                                                               < return
[ 175.80]                                                                                                              < return
[ 175.80]                                                                                                             < return
[ 175.81]                                                                                                            < return
[ 175.81]                                                                                                           < return
[ 175.82]                                                                                                          < return
[ 175.82]                                                                                                         < return
[ 175.82]                                                                                                        < return
[ 175.83]                                                                                                       < return
[ 175.83]                                                                                                      < return
[ 175.84]                                                                                                     < return
[ 175.84]                                                                                                    < return
[ 175.85]                                                                                                   < return
[ 175.85]                                                                                                  < return
[ 175.85]                                                                                                 < return
[ 175.86]                                                                                                < return
[ 175.86]                                                                                               < return
[ 175.87]                                                                                              < return
[ 175.87]                                                                                             < return
[ 175.88]                                                                                            < return
[ 175.88]                                                                                           < return
[ 175.89]                                                                                          < return
[ 175.89]                                                                                         < return
[ 175.89]                                                                                        < return
[ 175.90]                                                                                       < return
[ 175.90]                                                                                      < return
[ 175.91]                                                                                     < return
[ 175.91]                                                                                    < return
[ 175.92]                                                                                   < return
[ 175.92]                                                                                  < return
[ 175.93]                                                                                 < return
[ 175.93]                                                                                < return
[ 175.94]                                                                               < return
[ 175.94]                                                                              < return
[ 175.94]                                                                             < return
[ 175.95]                                                                            < return
[ 175.95]                                                                           < return
[ 175.96]                                                                          < return
[ 175.96]                                                                         < return
[ 175.97]                                                                        < return
[ 175.97]                                                                       < return
[ 175.97]                                                                      < return
[ 175.98]                                                                     < return
[ 175.98]                                                                    < return
[ 175.99]                                                                   < return
[ 175.99]                                                                  < return
[ 176.00]                                                                 < return
[ 176.00]                                                                < return
[ 176.00]                                                               < return
[ 176.01]                                                              < return
[ 176.01]                                                             < return
[ 176.02]                                                            < return
[ 176.02]                                                           < return
[ 176.03]                                                          < return
[ 176.03]                                                         < return
[ 176.03]                                                        < return
[ 176.04]                                                       < return
[ 176.04]                                                      < return
[ 176.05]                                                     < return
[ 176.05]                                                    < return
[ 176.06]                                                   < return
[ 176.06]                                                  < return
[ 176.06]                                                 < return
[ 176.07]                                                < return
[ 176.07]                                               < return
[ 176.08]                                              < return
[ 176.08]                                             < return
[ 176.09]                                            < return
[ 176.09]                                           < return
[ 176.09]                                          < return
[ 176.10]                                         < return
[ 176.10]                                        < return
[ 176.11]                                       < return
[ 176.11]                                      < return
[ 176.12]                                     < return
[ 176.12]                                    < return
[ 176.12]                                   < return
[ 176.13]                                  < return
[ 176.13]                                 < return
[ 176.14]                                < return
[ 176.14]                               < return
[ 176.15]                              < return
[ 176.15]                             < return
[ 176.16]                            < return
[ 176.16]                           < return
[ 176.16]                          < return
[ 176.17]                         < return
[ 176.17]                        < return
[ 176.18]                       < return
[ 176.18]                      < return
[ 176.18]                     < return
[ 176.19]                    < return
[ 176.19]                   < return
[ 176.20]                  < return
[ 176.20]                 < return
[ 176.21]                < return
[ 176.21]               < return
[ 176.21]              < return
[ 176.22]             < return
[ 176.22]            < return
[ 176.23]           < return
[ 176.23]          < return
[ 176.24]         < return
[ 176.24]        < return
[ 176.24]       < return
[ 176.25]      < return
[ 176.25]     < return
[ 176.26]    < return
[ 176.26]   < return
[ 176.26]  < return
[ 176.27]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 176.28]   > divisionByZero(args: pointer): void
[ 176.29]   < return
[ 176.29]  < return
[ 176.30]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 176.31]   > invalidInstruction(args: pointer): void
[ 176.31]   < return
[ 176.32]  < return
[ 176.32]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 176.33]   > invalidMemoryAccess(args: pointer): void
[ 176.34]   < return
[ 176.34]  < return
[ 176.35]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 176.36]   > abortExecution(args: pointer): void
[ 176.37]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/tryExec.ci:35: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	cmplStd/test/std/tryExec.ci:53: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 176.44]    < return
[ 176.44]   < return
[ 176.44]  < return
[ 176.58]  > object.create(type: typename): pointer
[ 176.59]  < return
[ 176.61]  > object.create(type: typename): pointer
[ 176.62]  < return
[ 176.63]  > funAdd(x: int32, y: int32): int32
[ 176.64]  < return
[ 176.65]  > funAdd(x: int32, y: int32): int32
[ 176.66]  < return
[ 176.67]  > funMul(x: int32, y: int32): int32
[ 176.68]  < return
[ 176.69]  > funMul(x: int32, y: int32): int32
[ 176.70]  < return
[ 176.71]  > fib(n: uint32): uint32
[ 176.72]   > fib(n: uint32): uint32
[ 176.73]    > fib(n: uint32): uint32
[ 176.75]     > fib(n: uint32): uint32
[ 176.76]      > fib(n: uint32): uint32
[ 176.77]       > fib(n: uint32): uint32
[ 176.78]        > fib(n: uint32): uint32
[ 176.79]         > fib(n: uint32): uint32
[ 176.80]          > fib(n: uint32): uint32
[ 176.81]           > fib(n: uint32): uint32
[ 176.82]            > fib(n: uint32): uint32
[ 176.83]             > fib(n: uint32): uint32
[ 176.84]              > fib(n: uint32): uint32
[ 176.85]              < return
[ 176.86]              > fib(n: uint32): uint32
[ 176.87]              < return
[ 176.88]             < return
[ 176.88]             > fib(n: uint32): uint32
[ 176.89]             < return
[ 176.90]            < return
[ 176.90]            > fib(n: uint32): uint32
[ 176.91]             > fib(n: uint32): uint32
[ 176.92]             < return
[ 176.93]             > fib(n: uint32): uint32
[ 176.94]             < return
[ 176.94]            < return
[ 176.95]           < return
[ 176.96]           > fib(n: uint32): uint32
[ 176.97]            > fib(n: uint32): uint32
[ 176.98]             > fib(n: uint32): uint32
[ 176.99]             < return
[ 176.99]             > fib(n: uint32): uint32
[ 177.00]             < return
[ 177.01]            < return
[ 177.01]            > fib(n: uint32): uint32
[ 177.03]            < return
[ 177.03]           < return
[ 177.04]          < return
[ 177.04]          > fib(n: uint32): uint32
[ 177.05]           > fib(n: uint32): uint32
[ 177.06]            > fib(n: uint32): uint32
[ 177.07]             > fib(n: uint32): uint32
[ 177.09]             < return
[ 177.09]             > fib(n: uint32): uint32
[ 177.10]             < return
[ 177.11]            < return
[ 177.11]            > fib(n: uint32): uint32
[ 177.12]            < return
[ 177.13]           < return
[ 177.13]           > fib(n: uint32): uint32
[ 177.14]            > fib(n: uint32): uint32
[ 177.15]            < return
[ 177.16]            > fib(n: uint32): uint32
[ 177.17]            < return
[ 177.18]           < return
[ 177.18]          < return
[ 177.19]         < return
[ 177.19]         > fib(n: uint32): uint32
[ 177.20]          > fib(n: uint32): uint32
[ 177.21]           > fib(n: uint32): uint32
[ 177.22]            > fib(n: uint32): uint32
[ 177.24]             > fib(n: uint32): uint32
[ 177.25]             < return
[ 177.25]             > fib(n: uint32): uint32
[ 177.26]             < return
[ 177.27]            < return
[ 177.27]            > fib(n: uint32): uint32
[ 177.28]            < return
[ 177.29]           < return
[ 177.29]           > fib(n: uint32): uint32
[ 177.30]            > fib(n: uint32): uint32
[ 177.31]            < return
[ 177.32]            > fib(n: uint32): uint32
[ 177.33]            < return
[ 177.34]           < return
[ 177.34]          < return
[ 177.35]          > fib(n: uint32): uint32
[ 177.36]           > fib(n: uint32): uint32
[ 177.37]            > fib(n: uint32): uint32
[ 177.38]            < return
[ 177.38]            > fib(n: uint32): uint32
[ 177.39]            < return
[ 177.40]           < return
[ 177.41]           > fib(n: uint32): uint32
[ 177.41]           < return
[ 177.42]          < return
[ 177.43]         < return
[ 177.43]        < return
[ 177.44]        > fib(n: uint32): uint32
[ 177.45]         > fib(n: uint32): uint32
[ 177.46]          > fib(n: uint32): uint32
[ 177.47]           > fib(n: uint32): uint32
[ 177.48]            > fib(n: uint32): uint32
[ 177.49]             > fib(n: uint32): uint32
[ 177.50]             < return
[ 177.51]             > fib(n: uint32): uint32
[ 177.52]             < return
[ 177.52]            < return
[ 177.53]            > fib(n: uint32): uint32
[ 177.54]            < return
[ 177.54]           < return
[ 177.55]           > fib(n: uint32): uint32
[ 177.56]            > fib(n: uint32): uint32
[ 177.57]            < return
[ 177.57]            > fib(n: uint32): uint32
[ 177.59]            < return
[ 177.59]           < return
[ 177.59]          < return
[ 177.60]          > fib(n: uint32): uint32
[ 177.61]           > fib(n: uint32): uint32
[ 177.62]            > fib(n: uint32): uint32
[ 177.63]            < return
[ 177.64]            > fib(n: uint32): uint32
[ 177.65]            < return
[ 177.65]           < return
[ 177.66]           > fib(n: uint32): uint32
[ 177.67]           < return
[ 177.68]          < return
[ 177.68]         < return
[ 177.69]         > fib(n: uint32): uint32
[ 177.70]          > fib(n: uint32): uint32
[ 177.71]           > fib(n: uint32): uint32
[ 177.72]            > fib(n: uint32): uint32
[ 177.73]            < return
[ 177.74]            > fib(n: uint32): uint32
[ 177.75]            < return
[ 177.75]           < return
[ 177.75]           > fib(n: uint32): uint32
[ 177.76]           < return
[ 177.77]          < return
[ 177.78]          > fib(n: uint32): uint32
[ 177.79]           > fib(n: uint32): uint32
[ 177.80]           < return
[ 177.80]           > fib(n: uint32): uint32
[ 177.81]           < return
[ 177.82]          < return
[ 177.82]         < return
[ 177.83]        < return
[ 177.83]       < return
[ 177.84]       > fib(n: uint32): uint32
[ 177.85]        > fib(n: uint32): uint32
[ 177.86]         > fib(n: uint32): uint32
[ 177.87]          > fib(n: uint32): uint32
[ 177.88]           > fib(n: uint32): uint32
[ 177.90]            > fib(n: uint32): uint32
[ 177.91]             > fib(n: uint32): uint32
[ 177.92]             < return
[ 177.92]             > fib(n: uint32): uint32
[ 177.93]             < return
[ 177.94]            < return
[ 177.94]            > fib(n: uint32): uint32
[ 177.95]            < return
[ 177.96]           < return
[ 177.97]           > fib(n: uint32): uint32
[ 177.98]            > fib(n: uint32): uint32
[ 177.99]            < return
[ 177.99]            > fib(n: uint32): uint32
[ 178.00]            < return
[ 178.01]           < return
[ 178.01]          < return
[ 178.02]          > fib(n: uint32): uint32
[ 178.03]           > fib(n: uint32): uint32
[ 178.04]            > fib(n: uint32): uint32
[ 178.05]            < return
[ 178.06]            > fib(n: uint32): uint32
[ 178.07]            < return
[ 178.07]           < return
[ 178.08]           > fib(n: uint32): uint32
[ 178.09]           < return
[ 178.09]          < return
[ 178.10]         < return
[ 178.10]         > fib(n: uint32): uint32
[ 178.12]          > fib(n: uint32): uint32
[ 178.13]           > fib(n: uint32): uint32
[ 178.14]            > fib(n: uint32): uint32
[ 178.15]            < return
[ 178.15]            > fib(n: uint32): uint32
[ 178.16]            < return
[ 178.17]           < return
[ 178.17]           > fib(n: uint32): uint32
[ 178.19]           < return
[ 178.19]          < return
[ 178.20]          > fib(n: uint32): uint32
[ 178.22]           > fib(n: uint32): uint32
[ 178.22]           < return
[ 178.23]           > fib(n: uint32): uint32
[ 178.24]           < return
[ 178.25]          < return
[ 178.25]         < return
[ 178.26]        < return
[ 178.26]        > fib(n: uint32): uint32
[ 178.27]         > fib(n: uint32): uint32
[ 178.28]          > fib(n: uint32): uint32
[ 178.30]           > fib(n: uint32): uint32
[ 178.31]            > fib(n: uint32): uint32
[ 178.32]            < return
[ 178.32]            > fib(n: uint32): uint32
[ 178.33]            < return
[ 178.34]           < return
[ 178.34]           > fib(n: uint32): uint32
[ 178.35]           < return
[ 178.36]          < return
[ 178.37]          > fib(n: uint32): uint32
[ 178.38]           > fib(n: uint32): uint32
[ 178.39]           < return
[ 178.39]           > fib(n: uint32): uint32
[ 178.40]           < return
[ 178.41]          < return
[ 178.41]         < return
[ 178.42]         > fib(n: uint32): uint32
[ 178.43]          > fib(n: uint32): uint32
[ 178.44]           > fib(n: uint32): uint32
[ 178.45]           < return
[ 178.46]           > fib(n: uint32): uint32
[ 178.47]           < return
[ 178.47]          < return
[ 178.48]          > fib(n: uint32): uint32
[ 178.49]          < return
[ 178.49]         < return
[ 178.50]        < return
[ 178.50]       < return
[ 178.51]      < return
[ 178.51]      > fib(n: uint32): uint32
[ 178.52]       > fib(n: uint32): uint32
[ 178.53]        > fib(n: uint32): uint32
[ 178.55]         > fib(n: uint32): uint32
[ 178.56]          > fib(n: uint32): uint32
[ 178.57]           > fib(n: uint32): uint32
[ 178.58]            > fib(n: uint32): uint32
[ 178.59]             > fib(n: uint32): uint32
[ 178.60]             < return
[ 178.61]             > fib(n: uint32): uint32
[ 178.62]             < return
[ 178.62]            < return
[ 178.63]            > fib(n: uint32): uint32
[ 178.64]            < return
[ 178.64]           < return
[ 178.65]           > fib(n: uint32): uint32
[ 178.66]            > fib(n: uint32): uint32
[ 178.67]            < return
[ 178.68]            > fib(n: uint32): uint32
[ 178.69]            < return
[ 178.69]           < return
[ 178.70]          < return
[ 178.70]          > fib(n: uint32): uint32
[ 178.71]           > fib(n: uint32): uint32
[ 178.72]            > fib(n: uint32): uint32
[ 178.73]            < return
[ 178.74]            > fib(n: uint32): uint32
[ 178.75]            < return
[ 178.75]           < return
[ 178.76]           > fib(n: uint32): uint32
[ 178.77]           < return
[ 178.78]          < return
[ 178.78]         < return
[ 178.79]         > fib(n: uint32): uint32
[ 178.80]          > fib(n: uint32): uint32
[ 178.81]           > fib(n: uint32): uint32
[ 178.82]            > fib(n: uint32): uint32
[ 178.83]            < return
[ 178.84]            > fib(n: uint32): uint32
[ 178.85]            < return
[ 178.85]           < return
[ 178.86]           > fib(n: uint32): uint32
[ 178.87]           < return
[ 178.88]          < return
[ 178.88]          > fib(n: uint32): uint32
[ 178.89]           > fib(n: uint32): uint32
[ 178.90]           < return
[ 178.91]           > fib(n: uint32): uint32
[ 178.92]           < return
[ 178.92]          < return
[ 178.93]         < return
[ 178.93]        < return
[ 178.94]        > fib(n: uint32): uint32
[ 178.95]         > fib(n: uint32): uint32
[ 178.96]          > fib(n: uint32): uint32
[ 178.97]           > fib(n: uint32): uint32
[ 178.98]            > fib(n: uint32): uint32
[ 178.99]            < return
[ 179.00]            > fib(n: uint32): uint32
[ 179.01]            < return
[ 179.02]           < return
[ 179.02]           > fib(n: uint32): uint32
[ 179.03]           < return
[ 179.04]          < return
[ 179.04]          > fib(n: uint32): uint32
[ 179.05]           > fib(n: uint32): uint32
[ 179.06]           < return
[ 179.07]           > fib(n: uint32): uint32
[ 179.08]           < return
[ 179.09]          < return
[ 179.09]         < return
[ 179.09]         > fib(n: uint32): uint32
[ 179.11]          > fib(n: uint32): uint32
[ 179.12]           > fib(n: uint32): uint32
[ 179.13]           < return
[ 179.13]           > fib(n: uint32): uint32
[ 179.14]           < return
[ 179.15]          < return
[ 179.16]          > fib(n: uint32): uint32
[ 179.16]          < return
[ 179.17]         < return
[ 179.18]        < return
[ 179.18]       < return
[ 179.19]       > fib(n: uint32): uint32
[ 179.20]        > fib(n: uint32): uint32
[ 179.21]         > fib(n: uint32): uint32
[ 179.22]          > fib(n: uint32): uint32
[ 179.23]           > fib(n: uint32): uint32
[ 179.24]            > fib(n: uint32): uint32
[ 179.25]            < return
[ 179.26]            > fib(n: uint32): uint32
[ 179.27]            < return
[ 179.27]           < return
[ 179.28]           > fib(n: uint32): uint32
[ 179.29]           < return
[ 179.29]          < return
[ 179.30]          > fib(n: uint32): uint32
[ 179.31]           > fib(n: uint32): uint32
[ 179.32]           < return
[ 179.32]           > fib(n: uint32): uint32
[ 179.34]           < return
[ 179.34]          < return
[ 179.34]         < return
[ 179.35]         > fib(n: uint32): uint32
[ 179.36]          > fib(n: uint32): uint32
[ 179.37]           > fib(n: uint32): uint32
[ 179.38]           < return
[ 179.39]           > fib(n: uint32): uint32
[ 179.40]           < return
[ 179.41]          < return
[ 179.41]          > fib(n: uint32): uint32
[ 179.42]          < return
[ 179.43]         < return
[ 179.43]        < return
[ 179.44]        > fib(n: uint32): uint32
[ 179.45]         > fib(n: uint32): uint32
[ 179.46]          > fib(n: uint32): uint32
[ 179.47]           > fib(n: uint32): uint32
[ 179.48]           < return
[ 179.49]           > fib(n: uint32): uint32
[ 179.50]           < return
[ 179.50]          < return
[ 179.51]          > fib(n: uint32): uint32
[ 179.52]          < return
[ 179.52]         < return
[ 179.53]         > fib(n: uint32): uint32
[ 179.54]          > fib(n: uint32): uint32
[ 179.55]          < return
[ 179.56]          > fib(n: uint32): uint32
[ 179.57]          < return
[ 179.58]         < return
[ 179.58]        < return
[ 179.59]       < return
[ 179.59]      < return
[ 179.59]     < return
[ 179.60]     > fib(n: uint32): uint32
[ 179.61]      > fib(n: uint32): uint32
[ 179.62]       > fib(n: uint32): uint32
[ 179.64]        > fib(n: uint32): uint32
[ 179.65]         > fib(n: uint32): uint32
[ 179.66]          > fib(n: uint32): uint32
[ 179.67]           > fib(n: uint32): uint32
[ 179.68]            > fib(n: uint32): uint32
[ 179.69]             > fib(n: uint32): uint32
[ 179.70]             < return
[ 179.71]             > fib(n: uint32): uint32
[ 179.72]             < return
[ 179.72]            < return
[ 179.73]            > fib(n: uint32): uint32
[ 179.74]            < return
[ 179.75]           < return
[ 179.75]           > fib(n: uint32): uint32
[ 179.76]            > fib(n: uint32): uint32
[ 179.77]            < return
[ 179.78]            > fib(n: uint32): uint32
[ 179.79]            < return
[ 179.79]           < return
[ 179.80]          < return
[ 179.80]          > fib(n: uint32): uint32
[ 179.81]           > fib(n: uint32): uint32
[ 179.83]            > fib(n: uint32): uint32
[ 179.84]            < return
[ 179.84]            > fib(n: uint32): uint32
[ 179.85]            < return
[ 179.86]           < return
[ 179.86]           > fib(n: uint32): uint32
[ 179.87]           < return
[ 179.88]          < return
[ 179.88]         < return
[ 179.89]         > fib(n: uint32): uint32
[ 179.90]          > fib(n: uint32): uint32
[ 179.91]           > fib(n: uint32): uint32
[ 179.92]            > fib(n: uint32): uint32
[ 179.93]            < return
[ 179.94]            > fib(n: uint32): uint32
[ 179.95]            < return
[ 179.96]           < return
[ 179.96]           > fib(n: uint32): uint32
[ 179.97]           < return
[ 179.98]          < return
[ 179.98]          > fib(n: uint32): uint32
[ 179.99]           > fib(n: uint32): uint32
[ 180.00]           < return
[ 180.01]           > fib(n: uint32): uint32
[ 180.02]           < return
[ 180.02]          < return
[ 180.03]         < return
[ 180.03]        < return
[ 180.04]        > fib(n: uint32): uint32
[ 180.05]         > fib(n: uint32): uint32
[ 180.06]          > fib(n: uint32): uint32
[ 180.07]           > fib(n: uint32): uint32
[ 180.08]            > fib(n: uint32): uint32
[ 180.09]            < return
[ 180.10]            > fib(n: uint32): uint32
[ 180.11]            < return
[ 180.11]           < return
[ 180.12]           > fib(n: uint32): uint32
[ 180.13]           < return
[ 180.13]          < return
[ 180.14]          > fib(n: uint32): uint32
[ 180.15]           > fib(n: uint32): uint32
[ 180.16]           < return
[ 180.17]           > fib(n: uint32): uint32
[ 180.18]           < return
[ 180.18]          < return
[ 180.19]         < return
[ 180.19]         > fib(n: uint32): uint32
[ 180.20]          > fib(n: uint32): uint32
[ 180.22]           > fib(n: uint32): uint32
[ 180.22]           < return
[ 180.23]           > fib(n: uint32): uint32
[ 180.24]           < return
[ 180.25]          < return
[ 180.25]          > fib(n: uint32): uint32
[ 180.26]          < return
[ 180.27]         < return
[ 180.27]        < return
[ 180.28]       < return
[ 180.28]       > fib(n: uint32): uint32
[ 180.29]        > fib(n: uint32): uint32
[ 180.31]         > fib(n: uint32): uint32
[ 180.32]          > fib(n: uint32): uint32
[ 180.33]           > fib(n: uint32): uint32
[ 180.34]            > fib(n: uint32): uint32
[ 180.35]            < return
[ 180.35]            > fib(n: uint32): uint32
[ 180.36]            < return
[ 180.37]           < return
[ 180.38]           > fib(n: uint32): uint32
[ 180.38]           < return
[ 180.39]          < return
[ 180.40]          > fib(n: uint32): uint32
[ 180.41]           > fib(n: uint32): uint32
[ 180.42]           < return
[ 180.42]           > fib(n: uint32): uint32
[ 180.43]           < return
[ 180.44]          < return
[ 180.44]         < return
[ 180.45]         > fib(n: uint32): uint32
[ 180.46]          > fib(n: uint32): uint32
[ 180.47]           > fib(n: uint32): uint32
[ 180.48]           < return
[ 180.49]           > fib(n: uint32): uint32
[ 180.50]           < return
[ 180.50]          < return
[ 180.51]          > fib(n: uint32): uint32
[ 180.52]          < return
[ 180.52]         < return
[ 180.53]        < return
[ 180.53]        > fib(n: uint32): uint32
[ 180.54]         > fib(n: uint32): uint32
[ 180.56]          > fib(n: uint32): uint32
[ 180.57]           > fib(n: uint32): uint32
[ 180.58]           < return
[ 180.58]           > fib(n: uint32): uint32
[ 180.59]           < return
[ 180.60]          < return
[ 180.60]          > fib(n: uint32): uint32
[ 180.61]          < return
[ 180.62]         < return
[ 180.63]         > fib(n: uint32): uint32
[ 180.64]          > fib(n: uint32): uint32
[ 180.65]          < return
[ 180.65]          > fib(n: uint32): uint32
[ 180.66]          < return
[ 180.67]         < return
[ 180.67]        < return
[ 180.68]       < return
[ 180.68]      < return
[ 180.69]      > fib(n: uint32): uint32
[ 180.70]       > fib(n: uint32): uint32
[ 180.71]        > fib(n: uint32): uint32
[ 180.72]         > fib(n: uint32): uint32
[ 180.73]          > fib(n: uint32): uint32
[ 180.74]           > fib(n: uint32): uint32
[ 180.76]            > fib(n: uint32): uint32
[ 180.76]            < return
[ 180.77]            > fib(n: uint32): uint32
[ 180.78]            < return
[ 180.79]           < return
[ 180.79]           > fib(n: uint32): uint32
[ 180.80]           < return
[ 180.81]          < return
[ 180.81]          > fib(n: uint32): uint32
[ 180.82]           > fib(n: uint32): uint32
[ 180.83]           < return
[ 180.84]           > fib(n: uint32): uint32
[ 180.85]           < return
[ 180.85]          < return
[ 180.86]         < return
[ 180.87]         > fib(n: uint32): uint32
[ 180.88]          > fib(n: uint32): uint32
[ 180.89]           > fib(n: uint32): uint32
[ 180.90]           < return
[ 180.91]           > fib(n: uint32): uint32
[ 180.91]           < return
[ 180.92]          < return
[ 180.93]          > fib(n: uint32): uint32
[ 180.94]          < return
[ 180.94]         < return
[ 180.94]        < return
[ 180.95]        > fib(n: uint32): uint32
[ 180.96]         > fib(n: uint32): uint32
[ 180.97]          > fib(n: uint32): uint32
[ 180.99]           > fib(n: uint32): uint32
[ 181.00]           < return
[ 181.00]           > fib(n: uint32): uint32
[ 181.01]           < return
[ 181.02]          < return
[ 181.02]          > fib(n: uint32): uint32
[ 181.03]          < return
[ 181.04]         < return
[ 181.04]         > fib(n: uint32): uint32
[ 181.05]          > fib(n: uint32): uint32
[ 181.06]          < return
[ 181.07]          > fib(n: uint32): uint32
[ 181.08]          < return
[ 181.09]         < return
[ 181.09]        < return
[ 181.09]       < return
[ 181.10]       > fib(n: uint32): uint32
[ 181.11]        > fib(n: uint32): uint32
[ 181.12]         > fib(n: uint32): uint32
[ 181.13]          > fib(n: uint32): uint32
[ 181.15]           > fib(n: uint32): uint32
[ 181.16]           < return
[ 181.16]           > fib(n: uint32): uint32
[ 181.17]           < return
[ 181.18]          < return
[ 181.18]          > fib(n: uint32): uint32
[ 181.19]          < return
[ 181.20]         < return
[ 181.20]         > fib(n: uint32): uint32
[ 181.22]          > fib(n: uint32): uint32
[ 181.22]          < return
[ 181.23]          > fib(n: uint32): uint32
[ 181.24]          < return
[ 181.25]         < return
[ 181.25]        < return
[ 181.26]        > fib(n: uint32): uint32
[ 181.27]         > fib(n: uint32): uint32
[ 181.28]          > fib(n: uint32): uint32
[ 181.29]          < return
[ 181.29]          > fib(n: uint32): uint32
[ 181.31]          < return
[ 181.31]         < return
[ 181.32]         > fib(n: uint32): uint32
[ 181.33]         < return
[ 181.33]        < return
[ 181.34]       < return
[ 181.34]      < return
[ 181.35]     < return
[ 181.35]    < return
[ 181.36]    > fib(n: uint32): uint32
[ 181.37]     > fib(n: uint32): uint32
[ 181.38]      > fib(n: uint32): uint32
[ 181.39]       > fib(n: uint32): uint32
[ 181.40]        > fib(n: uint32): uint32
[ 181.41]         > fib(n: uint32): uint32
[ 181.43]          > fib(n: uint32): uint32
[ 181.44]           > fib(n: uint32): uint32
[ 181.45]            > fib(n: uint32): uint32
[ 181.46]             > fib(n: uint32): uint32
[ 181.47]             < return
[ 181.47]             > fib(n: uint32): uint32
[ 181.49]             < return
[ 181.49]            < return
[ 181.50]            > fib(n: uint32): uint32
[ 181.51]            < return
[ 181.51]           < return
[ 181.52]           > fib(n: uint32): uint32
[ 181.53]            > fib(n: uint32): uint32
[ 181.54]            < return
[ 181.54]            > fib(n: uint32): uint32
[ 181.56]            < return
[ 181.56]           < return
[ 181.57]          < return
[ 181.57]          > fib(n: uint32): uint32
[ 181.58]           > fib(n: uint32): uint32
[ 181.59]            > fib(n: uint32): uint32
[ 181.60]            < return
[ 181.61]            > fib(n: uint32): uint32
[ 181.62]            < return
[ 181.62]           < return
[ 181.63]           > fib(n: uint32): uint32
[ 181.64]           < return
[ 181.65]          < return
[ 181.65]         < return
[ 181.66]         > fib(n: uint32): uint32
[ 181.67]          > fib(n: uint32): uint32
[ 181.68]           > fib(n: uint32): uint32
[ 181.69]            > fib(n: uint32): uint32
[ 181.70]            < return
[ 181.71]            > fib(n: uint32): uint32
[ 181.72]            < return
[ 181.72]           < return
[ 181.73]           > fib(n: uint32): uint32
[ 181.74]           < return
[ 181.74]          < return
[ 181.75]          > fib(n: uint32): uint32
[ 181.76]           > fib(n: uint32): uint32
[ 181.77]           < return
[ 181.78]           > fib(n: uint32): uint32
[ 181.79]           < return
[ 181.79]          < return
[ 181.80]         < return
[ 181.80]        < return
[ 181.81]        > fib(n: uint32): uint32
[ 181.82]         > fib(n: uint32): uint32
[ 181.83]          > fib(n: uint32): uint32
[ 181.84]           > fib(n: uint32): uint32
[ 181.85]            > fib(n: uint32): uint32
[ 181.86]            < return
[ 181.87]            > fib(n: uint32): uint32
[ 181.88]            < return
[ 181.88]           < return
[ 181.89]           > fib(n: uint32): uint32
[ 181.90]           < return
[ 181.90]          < return
[ 181.91]          > fib(n: uint32): uint32
[ 181.92]           > fib(n: uint32): uint32
[ 181.93]           < return
[ 181.94]           > fib(n: uint32): uint32
[ 181.95]           < return
[ 181.95]          < return
[ 181.96]         < return
[ 181.96]         > fib(n: uint32): uint32
[ 181.97]          > fib(n: uint32): uint32
[ 181.98]           > fib(n: uint32): uint32
[ 181.99]           < return
[ 182.00]           > fib(n: uint32): uint32
[ 182.01]           < return
[ 182.01]          < return
[ 182.02]          > fib(n: uint32): uint32
[ 182.03]          < return
[ 182.04]         < return
[ 182.04]        < return
[ 182.05]       < return
[ 182.05]       > fib(n: uint32): uint32
[ 182.06]        > fib(n: uint32): uint32
[ 182.07]         > fib(n: uint32): uint32
[ 182.09]          > fib(n: uint32): uint32
[ 182.10]           > fib(n: uint32): uint32
[ 182.11]            > fib(n: uint32): uint32
[ 182.12]            < return
[ 182.12]            > fib(n: uint32): uint32
[ 182.13]            < return
[ 182.14]           < return
[ 182.15]           > fib(n: uint32): uint32
[ 182.16]           < return
[ 182.16]          < return
[ 182.16]          > fib(n: uint32): uint32
[ 182.18]           > fib(n: uint32): uint32
[ 182.19]           < return
[ 182.19]           > fib(n: uint32): uint32
[ 182.20]           < return
[ 182.21]          < return
[ 182.21]         < return
[ 182.22]         > fib(n: uint32): uint32
[ 182.23]          > fib(n: uint32): uint32
[ 182.24]           > fib(n: uint32): uint32
[ 182.25]           < return
[ 182.26]           > fib(n: uint32): uint32
[ 182.26]           < return
[ 182.27]          < return
[ 182.28]          > fib(n: uint32): uint32
[ 182.29]          < return
[ 182.29]         < return
[ 182.30]        < return
[ 182.30]        > fib(n: uint32): uint32
[ 182.31]         > fib(n: uint32): uint32
[ 182.32]          > fib(n: uint32): uint32
[ 182.34]           > fib(n: uint32): uint32
[ 182.35]           < return
[ 182.35]           > fib(n: uint32): uint32
[ 182.36]           < return
[ 182.37]          < return
[ 182.37]          > fib(n: uint32): uint32
[ 182.38]          < return
[ 182.39]         < return
[ 182.39]         > fib(n: uint32): uint32
[ 182.40]          > fib(n: uint32): uint32
[ 182.41]          < return
[ 182.42]          > fib(n: uint32): uint32
[ 182.43]          < return
[ 182.44]         < return
[ 182.44]        < return
[ 182.44]       < return
[ 182.45]      < return
[ 182.46]      > fib(n: uint32): uint32
[ 182.47]       > fib(n: uint32): uint32
[ 182.48]        > fib(n: uint32): uint32
[ 182.49]         > fib(n: uint32): uint32
[ 182.50]          > fib(n: uint32): uint32
[ 182.51]           > fib(n: uint32): uint32
[ 182.52]            > fib(n: uint32): uint32
[ 182.53]            < return
[ 182.54]            > fib(n: uint32): uint32
[ 182.55]            < return
[ 182.56]           < return
[ 182.56]           > fib(n: uint32): uint32
[ 182.57]           < return
[ 182.58]          < return
[ 182.58]          > fib(n: uint32): uint32
[ 182.59]           > fib(n: uint32): uint32
[ 182.60]           < return
[ 182.61]           > fib(n: uint32): uint32
[ 182.62]           < return
[ 182.62]          < return
[ 182.63]         < return
[ 182.63]         > fib(n: uint32): uint32
[ 182.65]          > fib(n: uint32): uint32
[ 182.66]           > fib(n: uint32): uint32
[ 182.67]           < return
[ 182.67]           > fib(n: uint32): uint32
[ 182.68]           < return
[ 182.69]          < return
[ 182.69]          > fib(n: uint32): uint32
[ 182.70]          < return
[ 182.71]         < return
[ 182.71]        < return
[ 182.72]        > fib(n: uint32): uint32
[ 182.73]         > fib(n: uint32): uint32
[ 182.74]          > fib(n: uint32): uint32
[ 182.75]           > fib(n: uint32): uint32
[ 182.76]           < return
[ 182.77]           > fib(n: uint32): uint32
[ 182.78]           < return
[ 182.78]          < return
[ 182.79]          > fib(n: uint32): uint32
[ 182.80]          < return
[ 182.80]         < return
[ 182.81]         > fib(n: uint32): uint32
[ 182.82]          > fib(n: uint32): uint32
[ 182.83]          < return
[ 182.84]          > fib(n: uint32): uint32
[ 182.84]          < return
[ 182.85]         < return
[ 182.86]        < return
[ 182.86]       < return
[ 182.87]       > fib(n: uint32): uint32
[ 182.88]        > fib(n: uint32): uint32
[ 182.89]         > fib(n: uint32): uint32
[ 182.90]          > fib(n: uint32): uint32
[ 182.91]           > fib(n: uint32): uint32
[ 182.92]           < return
[ 182.93]           > fib(n: uint32): uint32
[ 182.94]           < return
[ 182.94]          < return
[ 182.95]          > fib(n: uint32): uint32
[ 182.96]          < return
[ 182.96]         < return
[ 182.97]         > fib(n: uint32): uint32
[ 182.98]          > fib(n: uint32): uint32
[ 182.99]          < return
[ 183.00]          > fib(n: uint32): uint32
[ 183.00]          < return
[ 183.01]         < return
[ 183.01]        < return
[ 183.02]        > fib(n: uint32): uint32
[ 183.03]         > fib(n: uint32): uint32
[ 183.04]          > fib(n: uint32): uint32
[ 183.05]          < return
[ 183.06]          > fib(n: uint32): uint32
[ 183.07]          < return
[ 183.07]         < return
[ 183.08]         > fib(n: uint32): uint32
[ 183.09]         < return
[ 183.09]        < return
[ 183.10]       < return
[ 183.10]      < return
[ 183.11]     < return
[ 183.11]     > fib(n: uint32): uint32
[ 183.12]      > fib(n: uint32): uint32
[ 183.14]       > fib(n: uint32): uint32
[ 183.15]        > fib(n: uint32): uint32
[ 183.16]         > fib(n: uint32): uint32
[ 183.17]          > fib(n: uint32): uint32
[ 183.18]           > fib(n: uint32): uint32
[ 183.19]            > fib(n: uint32): uint32
[ 183.20]            < return
[ 183.21]            > fib(n: uint32): uint32
[ 183.22]            < return
[ 183.22]           < return
[ 183.23]           > fib(n: uint32): uint32
[ 183.24]           < return
[ 183.24]          < return
[ 183.25]          > fib(n: uint32): uint32
[ 183.26]           > fib(n: uint32): uint32
[ 183.27]           < return
[ 183.28]           > fib(n: uint32): uint32
[ 183.29]           < return
[ 183.29]          < return
[ 183.30]         < return
[ 183.30]         > fib(n: uint32): uint32
[ 183.31]          > fib(n: uint32): uint32
[ 183.32]           > fib(n: uint32): uint32
[ 183.33]           < return
[ 183.34]           > fib(n: uint32): uint32
[ 183.35]           < return
[ 183.35]          < return
[ 183.36]          > fib(n: uint32): uint32
[ 183.37]          < return
[ 183.38]         < return
[ 183.38]        < return
[ 183.39]        > fib(n: uint32): uint32
[ 183.40]         > fib(n: uint32): uint32
[ 183.41]          > fib(n: uint32): uint32
[ 183.42]           > fib(n: uint32): uint32
[ 183.43]           < return
[ 183.44]           > fib(n: uint32): uint32
[ 183.45]           < return
[ 183.45]          < return
[ 183.46]          > fib(n: uint32): uint32
[ 183.47]          < return
[ 183.47]         < return
[ 183.48]         > fib(n: uint32): uint32
[ 183.49]          > fib(n: uint32): uint32
[ 183.50]          < return
[ 183.51]          > fib(n: uint32): uint32
[ 183.51]          < return
[ 183.52]         < return
[ 183.53]        < return
[ 183.53]       < return
[ 183.54]       > fib(n: uint32): uint32
[ 183.55]        > fib(n: uint32): uint32
[ 183.56]         > fib(n: uint32): uint32
[ 183.57]          > fib(n: uint32): uint32
[ 183.58]           > fib(n: uint32): uint32
[ 183.59]           < return
[ 183.60]           > fib(n: uint32): uint32
[ 183.61]           < return
[ 183.62]          < return
[ 183.62]          > fib(n: uint32): uint32
[ 183.63]          < return
[ 183.64]         < return
[ 183.64]         > fib(n: uint32): uint32
[ 183.65]          > fib(n: uint32): uint32
[ 183.66]          < return
[ 183.67]          > fib(n: uint32): uint32
[ 183.68]          < return
[ 183.68]         < return
[ 183.69]        < return
[ 183.69]        > fib(n: uint32): uint32
[ 183.71]         > fib(n: uint32): uint32
[ 183.72]          > fib(n: uint32): uint32
[ 183.73]          < return
[ 183.73]          > fib(n: uint32): uint32
[ 183.74]          < return
[ 183.75]         < return
[ 183.75]         > fib(n: uint32): uint32
[ 183.76]         < return
[ 183.77]        < return
[ 183.77]       < return
[ 183.78]      < return
[ 183.78]      > fib(n: uint32): uint32
[ 183.79]       > fib(n: uint32): uint32
[ 183.81]        > fib(n: uint32): uint32
[ 183.82]         > fib(n: uint32): uint32
[ 183.83]          > fib(n: uint32): uint32
[ 183.84]           > fib(n: uint32): uint32
[ 183.85]           < return
[ 183.86]           > fib(n: uint32): uint32
[ 183.87]           < return
[ 183.87]          < return
[ 183.88]          > fib(n: uint32): uint32
[ 183.89]          < return
[ 183.89]         < return
[ 183.90]         > fib(n: uint32): uint32
[ 183.91]          > fib(n: uint32): uint32
[ 183.92]          < return
[ 183.92]          > fib(n: uint32): uint32
[ 183.93]          < return
[ 183.94]         < return
[ 183.94]        < return
[ 183.95]        > fib(n: uint32): uint32
[ 183.96]         > fib(n: uint32): uint32
[ 183.97]          > fib(n: uint32): uint32
[ 183.98]          < return
[ 183.99]          > fib(n: uint32): uint32
[ 184.00]          < return
[ 184.00]         < return
[ 184.01]         > fib(n: uint32): uint32
[ 184.02]         < return
[ 184.02]        < return
[ 184.03]       < return
[ 184.03]       > fib(n: uint32): uint32
[ 184.04]        > fib(n: uint32): uint32
[ 184.06]         > fib(n: uint32): uint32
[ 184.07]          > fib(n: uint32): uint32
[ 184.08]          < return
[ 184.08]          > fib(n: uint32): uint32
[ 184.09]          < return
[ 184.10]         < return
[ 184.10]         > fib(n: uint32): uint32
[ 184.11]         < return
[ 184.12]        < return
[ 184.12]        > fib(n: uint32): uint32
[ 184.14]         > fib(n: uint32): uint32
[ 184.15]         < return
[ 184.15]         > fib(n: uint32): uint32
[ 184.16]         < return
[ 184.17]        < return
[ 184.17]       < return
[ 184.18]      < return
[ 184.18]     < return
[ 184.19]    < return
[ 184.19]   < return
[ 184.20]   > fib(n: uint32): uint32
[ 184.21]    > fib(n: uint32): uint32
[ 184.22]     > fib(n: uint32): uint32
[ 184.23]      > fib(n: uint32): uint32
[ 184.24]       > fib(n: uint32): uint32
[ 184.25]        > fib(n: uint32): uint32
[ 184.26]         > fib(n: uint32): uint32
[ 184.28]          > fib(n: uint32): uint32
[ 184.29]           > fib(n: uint32): uint32
[ 184.30]            > fib(n: uint32): uint32
[ 184.31]             > fib(n: uint32): uint32
[ 184.32]             < return
[ 184.33]             > fib(n: uint32): uint32
[ 184.34]             < return
[ 184.34]            < return
[ 184.35]            > fib(n: uint32): uint32
[ 184.36]            < return
[ 184.36]           < return
[ 184.37]           > fib(n: uint32): uint32
[ 184.38]            > fib(n: uint32): uint32
[ 184.39]            < return
[ 184.40]            > fib(n: uint32): uint32
[ 184.40]            < return
[ 184.41]           < return
[ 184.41]          < return
[ 184.42]          > fib(n: uint32): uint32
[ 184.43]           > fib(n: uint32): uint32
[ 184.44]            > fib(n: uint32): uint32
[ 184.45]            < return
[ 184.46]            > fib(n: uint32): uint32
[ 184.47]            < return
[ 184.47]           < return
[ 184.48]           > fib(n: uint32): uint32
[ 184.49]           < return
[ 184.49]          < return
[ 184.50]         < return
[ 184.50]         > fib(n: uint32): uint32
[ 184.52]          > fib(n: uint32): uint32
[ 184.53]           > fib(n: uint32): uint32
[ 184.54]            > fib(n: uint32): uint32
[ 184.55]            < return
[ 184.55]            > fib(n: uint32): uint32
[ 184.56]            < return
[ 184.57]           < return
[ 184.57]           > fib(n: uint32): uint32
[ 184.58]           < return
[ 184.59]          < return
[ 184.59]          > fib(n: uint32): uint32
[ 184.61]           > fib(n: uint32): uint32
[ 184.62]           < return
[ 184.62]           > fib(n: uint32): uint32
[ 184.63]           < return
[ 184.64]          < return
[ 184.64]         < return
[ 184.65]        < return
[ 184.65]        > fib(n: uint32): uint32
[ 184.66]         > fib(n: uint32): uint32
[ 184.68]          > fib(n: uint32): uint32
[ 184.69]           > fib(n: uint32): uint32
[ 184.70]            > fib(n: uint32): uint32
[ 184.71]            < return
[ 184.71]            > fib(n: uint32): uint32
[ 184.72]            < return
[ 184.73]           < return
[ 184.73]           > fib(n: uint32): uint32
[ 184.74]           < return
[ 184.75]          < return
[ 184.75]          > fib(n: uint32): uint32
[ 184.76]           > fib(n: uint32): uint32
[ 184.78]           < return
[ 184.78]           > fib(n: uint32): uint32
[ 184.79]           < return
[ 184.80]          < return
[ 184.80]         < return
[ 184.81]         > fib(n: uint32): uint32
[ 184.82]          > fib(n: uint32): uint32
[ 184.83]           > fib(n: uint32): uint32
[ 184.84]           < return
[ 184.84]           > fib(n: uint32): uint32
[ 184.85]           < return
[ 184.86]          < return
[ 184.87]          > fib(n: uint32): uint32
[ 184.88]          < return
[ 184.88]         < return
[ 184.88]        < return
[ 184.89]       < return
[ 184.90]       > fib(n: uint32): uint32
[ 184.91]        > fib(n: uint32): uint32
[ 184.92]         > fib(n: uint32): uint32
[ 184.93]          > fib(n: uint32): uint32
[ 184.94]           > fib(n: uint32): uint32
[ 184.95]            > fib(n: uint32): uint32
[ 184.96]            < return
[ 184.97]            > fib(n: uint32): uint32
[ 184.98]            < return
[ 184.98]           < return
[ 184.99]           > fib(n: uint32): uint32
[ 185.00]           < return
[ 185.00]          < return
[ 185.01]          > fib(n: uint32): uint32
[ 185.02]           > fib(n: uint32): uint32
[ 185.03]           < return
[ 185.03]           > fib(n: uint32): uint32
[ 185.04]           < return
[ 185.05]          < return
[ 185.06]         < return
[ 185.06]         > fib(n: uint32): uint32
[ 185.07]          > fib(n: uint32): uint32
[ 185.08]           > fib(n: uint32): uint32
[ 185.09]           < return
[ 185.10]           > fib(n: uint32): uint32
[ 185.11]           < return
[ 185.11]          < return
[ 185.12]          > fib(n: uint32): uint32
[ 185.13]          < return
[ 185.13]         < return
[ 185.14]        < return
[ 185.15]        > fib(n: uint32): uint32
[ 185.16]         > fib(n: uint32): uint32
[ 185.17]          > fib(n: uint32): uint32
[ 185.18]           > fib(n: uint32): uint32
[ 185.19]           < return
[ 185.19]           > fib(n: uint32): uint32
[ 185.21]           < return
[ 185.21]          < return
[ 185.22]          > fib(n: uint32): uint32
[ 185.23]          < return
[ 185.23]         < return
[ 185.24]         > fib(n: uint32): uint32
[ 185.25]          > fib(n: uint32): uint32
[ 185.26]          < return
[ 185.27]          > fib(n: uint32): uint32
[ 185.28]          < return
[ 185.28]         < return
[ 185.29]        < return
[ 185.29]       < return
[ 185.30]      < return
[ 185.30]      > fib(n: uint32): uint32
[ 185.31]       > fib(n: uint32): uint32
[ 185.32]        > fib(n: uint32): uint32
[ 185.34]         > fib(n: uint32): uint32
[ 185.35]          > fib(n: uint32): uint32
[ 185.36]           > fib(n: uint32): uint32
[ 185.37]            > fib(n: uint32): uint32
[ 185.38]            < return
[ 185.38]            > fib(n: uint32): uint32
[ 185.40]            < return
[ 185.40]           < return
[ 185.41]           > fib(n: uint32): uint32
[ 185.42]           < return
[ 185.42]          < return
[ 185.43]          > fib(n: uint32): uint32
[ 185.44]           > fib(n: uint32): uint32
[ 185.45]           < return
[ 185.45]           > fib(n: uint32): uint32
[ 185.46]           < return
[ 185.47]          < return
[ 185.47]         < return
[ 185.48]         > fib(n: uint32): uint32
[ 185.49]          > fib(n: uint32): uint32
[ 185.50]           > fib(n: uint32): uint32
[ 185.51]           < return
[ 185.52]           > fib(n: uint32): uint32
[ 185.53]           < return
[ 185.53]          < return
[ 185.54]          > fib(n: uint32): uint32
[ 185.55]          < return
[ 185.55]         < return
[ 185.56]        < return
[ 185.56]        > fib(n: uint32): uint32
[ 185.57]         > fib(n: uint32): uint32
[ 185.59]          > fib(n: uint32): uint32
[ 185.60]           > fib(n: uint32): uint32
[ 185.61]           < return
[ 185.61]           > fib(n: uint32): uint32
[ 185.62]           < return
[ 185.63]          < return
[ 185.63]          > fib(n: uint32): uint32
[ 185.64]          < return
[ 185.65]         < return
[ 185.66]         > fib(n: uint32): uint32
[ 185.67]          > fib(n: uint32): uint32
[ 185.68]          < return
[ 185.68]          > fib(n: uint32): uint32
[ 185.69]          < return
[ 185.70]         < return
[ 185.70]        < return
[ 185.71]       < return
[ 185.71]       > fib(n: uint32): uint32
[ 185.72]        > fib(n: uint32): uint32
[ 185.74]         > fib(n: uint32): uint32
[ 185.75]          > fib(n: uint32): uint32
[ 185.76]           > fib(n: uint32): uint32
[ 185.77]           < return
[ 185.77]           > fib(n: uint32): uint32
[ 185.78]           < return
[ 185.79]          < return
[ 185.79]          > fib(n: uint32): uint32
[ 185.80]          < return
[ 185.81]         < return
[ 185.81]         > fib(n: uint32): uint32
[ 185.83]          > fib(n: uint32): uint32
[ 185.84]          < return
[ 185.84]          > fib(n: uint32): uint32
[ 185.85]          < return
[ 185.86]         < return
[ 185.86]        < return
[ 185.87]        > fib(n: uint32): uint32
[ 185.88]         > fib(n: uint32): uint32
[ 185.89]          > fib(n: uint32): uint32
[ 185.90]          < return
[ 185.91]          > fib(n: uint32): uint32
[ 185.92]          < return
[ 185.92]         < return
[ 185.93]         > fib(n: uint32): uint32
[ 185.94]         < return
[ 185.94]        < return
[ 185.95]       < return
[ 185.95]      < return
[ 185.96]     < return
[ 185.96]     > fib(n: uint32): uint32
[ 185.97]      > fib(n: uint32): uint32
[ 185.99]       > fib(n: uint32): uint32
[ 186.00]        > fib(n: uint32): uint32
[ 186.01]         > fib(n: uint32): uint32
[ 186.02]          > fib(n: uint32): uint32
[ 186.03]           > fib(n: uint32): uint32
[ 186.04]            > fib(n: uint32): uint32
[ 186.05]            < return
[ 186.06]            > fib(n: uint32): uint32
[ 186.07]            < return
[ 186.07]           < return
[ 186.08]           > fib(n: uint32): uint32
[ 186.09]           < return
[ 186.09]          < return
[ 186.10]          > fib(n: uint32): uint32
[ 186.11]           > fib(n: uint32): uint32
[ 186.12]           < return
[ 186.13]           > fib(n: uint32): uint32
[ 186.14]           < return
[ 186.14]          < return
[ 186.15]         < return
[ 186.15]         > fib(n: uint32): uint32
[ 186.16]          > fib(n: uint32): uint32
[ 186.18]           > fib(n: uint32): uint32
[ 186.19]           < return
[ 186.19]           > fib(n: uint32): uint32
[ 186.20]           < return
[ 186.21]          < return
[ 186.21]          > fib(n: uint32): uint32
[ 186.22]          < return
[ 186.23]         < return
[ 186.23]        < return
[ 186.24]        > fib(n: uint32): uint32
[ 186.25]         > fib(n: uint32): uint32
[ 186.26]          > fib(n: uint32): uint32
[ 186.27]           > fib(n: uint32): uint32
[ 186.28]           < return
[ 186.29]           > fib(n: uint32): uint32
[ 186.30]           < return
[ 186.30]          < return
[ 186.31]          > fib(n: uint32): uint32
[ 186.32]          < return
[ 186.32]         < return
[ 186.33]         > fib(n: uint32): uint32
[ 186.34]          > fib(n: uint32): uint32
[ 186.35]          < return
[ 186.36]          > fib(n: uint32): uint32
[ 186.37]          < return
[ 186.37]         < return
[ 186.38]        < return
[ 186.38]       < return
[ 186.39]       > fib(n: uint32): uint32
[ 186.40]        > fib(n: uint32): uint32
[ 186.41]         > fib(n: uint32): uint32
[ 186.42]          > fib(n: uint32): uint32
[ 186.43]           > fib(n: uint32): uint32
[ 186.44]           < return
[ 186.45]           > fib(n: uint32): uint32
[ 186.46]           < return
[ 186.46]          < return
[ 186.47]          > fib(n: uint32): uint32
[ 186.48]          < return
[ 186.48]         < return
[ 186.49]         > fib(n: uint32): uint32
[ 186.50]          > fib(n: uint32): uint32
[ 186.51]          < return
[ 186.51]          > fib(n: uint32): uint32
[ 186.53]          < return
[ 186.53]         < return
[ 186.53]        < return
[ 186.54]        > fib(n: uint32): uint32
[ 186.55]         > fib(n: uint32): uint32
[ 186.56]          > fib(n: uint32): uint32
[ 186.57]          < return
[ 186.58]          > fib(n: uint32): uint32
[ 186.59]          < return
[ 186.59]         < return
[ 186.60]         > fib(n: uint32): uint32
[ 186.61]         < return
[ 186.61]        < return
[ 186.62]       < return
[ 186.62]      < return
[ 186.63]      > fib(n: uint32): uint32
[ 186.64]       > fib(n: uint32): uint32
[ 186.65]        > fib(n: uint32): uint32
[ 186.66]         > fib(n: uint32): uint32
[ 186.67]          > fib(n: uint32): uint32
[ 186.69]           > fib(n: uint32): uint32
[ 186.69]           < return
[ 186.70]           > fib(n: uint32): uint32
[ 186.71]           < return
[ 186.72]          < return
[ 186.72]          > fib(n: uint32): uint32
[ 186.73]          < return
[ 186.74]         < return
[ 186.74]         > fib(n: uint32): uint32
[ 186.75]          > fib(n: uint32): uint32
[ 186.76]          < return
[ 186.77]          > fib(n: uint32): uint32
[ 186.78]          < return
[ 186.78]         < return
[ 186.79]        < return
[ 186.79]        > fib(n: uint32): uint32
[ 186.81]         > fib(n: uint32): uint32
[ 186.82]          > fib(n: uint32): uint32
[ 186.83]          < return
[ 186.83]          > fib(n: uint32): uint32
[ 186.84]          < return
[ 186.85]         < return
[ 186.85]         > fib(n: uint32): uint32
[ 186.86]         < return
[ 186.87]        < return
[ 186.87]       < return
[ 186.88]       > fib(n: uint32): uint32
[ 186.89]        > fib(n: uint32): uint32
[ 186.90]         > fib(n: uint32): uint32
[ 186.91]          > fib(n: uint32): uint32
[ 186.92]          < return
[ 186.93]          > fib(n: uint32): uint32
[ 186.94]          < return
[ 186.94]         < return
[ 186.95]         > fib(n: uint32): uint32
[ 186.96]         < return
[ 186.96]        < return
[ 186.97]        > fib(n: uint32): uint32
[ 186.98]         > fib(n: uint32): uint32
[ 186.99]         < return
[ 187.00]         > fib(n: uint32): uint32
[ 187.00]         < return
[ 187.01]        < return
[ 187.02]       < return
[ 187.02]      < return
[ 187.03]     < return
[ 187.03]    < return
[ 187.04]    > fib(n: uint32): uint32
[ 187.05]     > fib(n: uint32): uint32
[ 187.06]      > fib(n: uint32): uint32
[ 187.07]       > fib(n: uint32): uint32
[ 187.08]        > fib(n: uint32): uint32
[ 187.09]         > fib(n: uint32): uint32
[ 187.10]          > fib(n: uint32): uint32
[ 187.12]           > fib(n: uint32): uint32
[ 187.13]            > fib(n: uint32): uint32
[ 187.14]            < return
[ 187.14]            > fib(n: uint32): uint32
[ 187.15]            < return
[ 187.16]           < return
[ 187.16]           > fib(n: uint32): uint32
[ 187.17]           < return
[ 187.18]          < return
[ 187.19]          > fib(n: uint32): uint32
[ 187.20]           > fib(n: uint32): uint32
[ 187.21]           < return
[ 187.21]           > fib(n: uint32): uint32
[ 187.22]           < return
[ 187.23]          < return
[ 187.23]         < return
[ 187.24]         > fib(n: uint32): uint32
[ 187.25]          > fib(n: uint32): uint32
[ 187.26]           > fib(n: uint32): uint32
[ 187.27]           < return
[ 187.28]           > fib(n: uint32): uint32
[ 187.29]           < return
[ 187.29]          < return
[ 187.30]          > fib(n: uint32): uint32
[ 187.31]          < return
[ 187.31]         < return
[ 187.32]        < return
[ 187.32]        > fib(n: uint32): uint32
[ 187.33]         > fib(n: uint32): uint32
[ 187.35]          > fib(n: uint32): uint32
[ 187.36]           > fib(n: uint32): uint32
[ 187.37]           < return
[ 187.37]           > fib(n: uint32): uint32
[ 187.38]           < return
[ 187.39]          < return
[ 187.39]          > fib(n: uint32): uint32
[ 187.40]          < return
[ 187.41]         < return
[ 187.41]         > fib(n: uint32): uint32
[ 187.43]          > fib(n: uint32): uint32
[ 187.44]          < return
[ 187.44]          > fib(n: uint32): uint32
[ 187.45]          < return
[ 187.46]         < return
[ 187.46]        < return
[ 187.47]       < return
[ 187.47]       > fib(n: uint32): uint32
[ 187.48]        > fib(n: uint32): uint32
[ 187.49]         > fib(n: uint32): uint32
[ 187.50]          > fib(n: uint32): uint32
[ 187.51]           > fib(n: uint32): uint32
[ 187.53]           < return
[ 187.53]           > fib(n: uint32): uint32
[ 187.54]           < return
[ 187.55]          < return
[ 187.55]          > fib(n: uint32): uint32
[ 187.56]          < return
[ 187.57]         < return
[ 187.58]         > fib(n: uint32): uint32
[ 187.59]          > fib(n: uint32): uint32
[ 187.60]          < return
[ 187.61]          > fib(n: uint32): uint32
[ 187.62]          < return
[ 187.62]         < return
[ 187.62]        < return
[ 187.63]        > fib(n: uint32): uint32
[ 187.64]         > fib(n: uint32): uint32
[ 187.65]          > fib(n: uint32): uint32
[ 187.66]          < return
[ 187.67]          > fib(n: uint32): uint32
[ 187.68]          < return
[ 187.68]         < return
[ 187.69]         > fib(n: uint32): uint32
[ 187.70]         < return
[ 187.71]        < return
[ 187.71]       < return
[ 187.72]      < return
[ 187.72]      > fib(n: uint32): uint32
[ 187.73]       > fib(n: uint32): uint32
[ 187.74]        > fib(n: uint32): uint32
[ 187.75]         > fib(n: uint32): uint32
[ 187.76]          > fib(n: uint32): uint32
[ 187.78]           > fib(n: uint32): uint32
[ 187.79]           < return
[ 187.79]           > fib(n: uint32): uint32
[ 187.80]           < return
[ 187.81]          < return
[ 187.81]          > fib(n: uint32): uint32
[ 187.82]          < return
[ 187.83]         < return
[ 187.83]         > fib(n: uint32): uint32
[ 187.84]          > fib(n: uint32): uint32
[ 187.85]          < return
[ 187.86]          > fib(n: uint32): uint32
[ 187.87]          < return
[ 187.88]         < return
[ 187.88]        < return
[ 187.89]        > fib(n: uint32): uint32
[ 187.90]         > fib(n: uint32): uint32
[ 187.91]          > fib(n: uint32): uint32
[ 187.92]          < return
[ 187.92]          > fib(n: uint32): uint32
[ 187.93]          < return
[ 187.94]         < return
[ 187.94]         > fib(n: uint32): uint32
[ 187.96]         < return
[ 187.96]        < return
[ 187.97]       < return
[ 187.97]       > fib(n: uint32): uint32
[ 187.98]        > fib(n: uint32): uint32
[ 188.00]         > fib(n: uint32): uint32
[ 188.01]          > fib(n: uint32): uint32
[ 188.02]          < return
[ 188.02]          > fib(n: uint32): uint32
[ 188.03]          < return
[ 188.04]         < return
[ 188.04]         > fib(n: uint32): uint32
[ 188.05]         < return
[ 188.06]        < return
[ 188.06]        > fib(n: uint32): uint32
[ 188.07]         > fib(n: uint32): uint32
[ 188.08]         < return
[ 188.09]         > fib(n: uint32): uint32
[ 188.10]         < return
[ 188.10]        < return
[ 188.11]       < return
[ 188.11]      < return
[ 188.12]     < return
[ 188.12]     > fib(n: uint32): uint32
[ 188.14]      > fib(n: uint32): uint32
[ 188.15]       > fib(n: uint32): uint32
[ 188.16]        > fib(n: uint32): uint32
[ 188.17]         > fib(n: uint32): uint32
[ 188.18]          > fib(n: uint32): uint32
[ 188.19]           > fib(n: uint32): uint32
[ 188.20]           < return
[ 188.21]           > fib(n: uint32): uint32
[ 188.22]           < return
[ 188.22]          < return
[ 188.23]          > fib(n: uint32): uint32
[ 188.24]          < return
[ 188.24]         < return
[ 188.25]         > fib(n: uint32): uint32
[ 188.26]          > fib(n: uint32): uint32
[ 188.27]          < return
[ 188.28]          > fib(n: uint32): uint32
[ 188.28]          < return
[ 188.29]         < return
[ 188.30]        < return
[ 188.30]        > fib(n: uint32): uint32
[ 188.31]         > fib(n: uint32): uint32
[ 188.32]          > fib(n: uint32): uint32
[ 188.33]          < return
[ 188.34]          > fib(n: uint32): uint32
[ 188.35]          < return
[ 188.35]         < return
[ 188.36]         > fib(n: uint32): uint32
[ 188.37]         < return
[ 188.38]        < return
[ 188.38]       < return
[ 188.38]       > fib(n: uint32): uint32
[ 188.40]        > fib(n: uint32): uint32
[ 188.41]         > fib(n: uint32): uint32
[ 188.42]          > fib(n: uint32): uint32
[ 188.43]          < return
[ 188.44]          > fib(n: uint32): uint32
[ 188.44]          < return
[ 188.45]         < return
[ 188.46]         > fib(n: uint32): uint32
[ 188.47]         < return
[ 188.47]        < return
[ 188.48]        > fib(n: uint32): uint32
[ 188.49]         > fib(n: uint32): uint32
[ 188.50]         < return
[ 188.50]         > fib(n: uint32): uint32
[ 188.51]         < return
[ 188.52]        < return
[ 188.52]       < return
[ 188.53]      < return
[ 188.53]      > fib(n: uint32): uint32
[ 188.54]       > fib(n: uint32): uint32
[ 188.56]        > fib(n: uint32): uint32
[ 188.57]         > fib(n: uint32): uint32
[ 188.58]          > fib(n: uint32): uint32
[ 188.59]          < return
[ 188.59]          > fib(n: uint32): uint32
[ 188.60]          < return
[ 188.61]         < return
[ 188.62]         > fib(n: uint32): uint32
[ 188.62]         < return
[ 188.63]        < return
[ 188.63]        > fib(n: uint32): uint32
[ 188.65]         > fib(n: uint32): uint32
[ 188.66]         < return
[ 188.66]         > fib(n: uint32): uint32
[ 188.67]         < return
[ 188.68]        < return
[ 188.68]       < return
[ 188.69]       > fib(n: uint32): uint32
[ 188.70]        > fib(n: uint32): uint32
[ 188.71]         > fib(n: uint32): uint32
[ 188.72]         < return
[ 188.72]         > fib(n: uint32): uint32
[ 188.74]         < return
[ 188.74]        < return
[ 188.75]        > fib(n: uint32): uint32
[ 188.76]        < return
[ 188.76]       < return
[ 188.77]      < return
[ 188.77]     < return
[ 188.78]    < return
[ 188.78]   < return
[ 188.78]  < return
[ 188.82]  > typename.name(type: typename): .cstr
[ 188.84]  < return
[ 188.85]  > typename.file(type: typename): .cstr
[ 188.87]  < return
[ 188.87]  > typename.line(type: typename): int32
[ 188.89]  < return
[ 188.90]  > typename.base(type: typename): typename
[ 188.91]  < return
[ 188.91]  > typename.name(type: typename): .cstr
[ 188.93]  < return
[ 188.94]  > typename.file(type: typename): .cstr
[ 188.96]  < return
[ 188.96]  > typename.line(type: typename): int32
[ 188.98]  < return
[ 188.98]  > typename.base(type: typename): typename
[ 189.00]  < return
[ 189.02]  > typename.base(type: typename): typename
[ 189.03]  < return
[ 190.15]  > Math.floor(x: float64): float64
[ 190.16]   > Math.modf(x: float64, intPart: float64): float64
[ 190.16]   < return
[ 190.16]  < return
[ 190.18]  > Math.floor(x: float64): float64
[ 190.18]   > Math.modf(x: float64, intPart: float64): float64
[ 190.19]   < return
[ 190.19]  < return
[ 190.20]  > Math.floor(x: float64): float64
[ 190.20]   > Math.modf(x: float64, intPart: float64): float64
[ 190.21]   < return
[ 190.21]  < return
[ 190.22]  > Math.floor(x: float64): float64
[ 190.22]   > Math.modf(x: float64, intPart: float64): float64
[ 190.23]    > Math.modf(x: float64, intPart: float64): float64
[ 190.24]    < return
[ 190.24]   < return
[ 190.24]  < return
[ 190.25]  > Math.floor(x: float64): float64
[ 190.26]   > Math.modf(x: float64, intPart: float64): float64
[ 190.26]    > Math.modf(x: float64, intPart: float64): float64
[ 190.27]    < return
[ 190.27]   < return
[ 190.27]  < return
[ 190.28]  > Math.floor(x: float64): float64
[ 190.29]   > Math.modf(x: float64, intPart: float64): float64
[ 190.29]    > Math.modf(x: float64, intPart: float64): float64
[ 190.30]    < return
[ 190.30]   < return
[ 190.30]  < return
[ 190.46]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 190.47]  < return
[ 190.48]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 190.49]  < return
[ 190.52]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 190.53]  < return
[ 190.56]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 190.56]  < return
[ 190.58]  > Math.min(data: float64[]): float64
[ 190.59]  < return
[ 190.61]  > Math.min(data: float64[]): float64
[ 190.63]  < return
[ 190.64]  > Math.max(data: float64[]): float64
[ 190.65]  < return
[ 190.67]  > Math.max(data: float64[]): float64
[ 190.69]  < return
[ 190.70]  > Math.sum(data: float64[]): float64
[ 190.71]  < return
[ 190.72]  > Math.sum(data: float64[]): float64
[ 190.73]  < return
[ 190.75]  > Math.sum(data: float64[]): float64
[ 190.75]  < return
[ 190.78]  > Math.sum(data: float64[]): float64
[ 190.80]  < return
[ 190.81]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 190.82]  < return
[ 190.87]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 190.89]  < return
[ 190.91]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 190.93]  < return
[ 190.94]  > Math.sinCos(arg: float64, quad: int32): float64
[ 190.96]  < return
[ 190.97]  > Math.sinCos(arg: float64, quad: int32): float64
[ 190.99]  < return
[ 191.00]  > Math.tan(arg: float64): float64
[ 191.01]   > Math.modf(x: float64, intPart: float64): float64
[ 191.02]   < return
[ 191.03]  < return
[ 191.04]  > Math.sinh(x: float64): float64
[ 191.05]   > float64.exp(x: float64): float64
[ 191.06]   < return
[ 191.07]   > float64.exp(x: float64): float64
[ 191.08]   < return
[ 191.08]  < return
[ 191.09]  > Math.cosh(x: float64): float64
[ 191.10]   > float64.exp(x: float64): float64
[ 191.11]   < return
[ 191.12]   > float64.exp(x: float64): float64
[ 191.13]   < return
[ 191.13]  < return
[ 191.14]  > Math.asin(x: float64): float64
[ 191.15]   > float64.sqrt(x: float64): float64
[ 191.16]   < return
[ 191.16]   > float64.atan2(x: float64, y: float64): float64
[ 191.18]   < return
[ 191.18]  < return
[ 191.19]  > Math.asin(x: float64): float64
[ 191.20]   > float64.sqrt(x: float64): float64
[ 191.21]   < return
[ 191.22]   > float64.atan2(x: float64, y: float64): float64
[ 191.23]   < return
[ 191.23]  < return
[ 191.25]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 191.25]  < return
[ 191.27]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 191.27]  < return
[ 191.29]  > Math.absMod(val: float64, mod: float64): float64
[ 191.29]  < return
[ 191.30]  > Math.absMod(val: float64, mod: float64): float64
[ 191.31]  < return
[ 191.32]  > Math.absMod(val: float64, mod: float64): float64
[ 191.32]  < return
[ 191.33]  > Math.absMod(val: float64, mod: float64): float64
[ 191.34]  < return
[ 191.35]  > Math.absMod(val: float64, mod: float64): float64
[ 191.36]  < return
[ 191.37]  > Math.absMod(val: float64, mod: float64): float64
[ 191.37]  < return
[ 191.38]  > Math.absMod(val: float64, mod: float64): float64
[ 191.39]  < return
[ 191.40]  > Math.absMod(val: float64, mod: float64): float64
[ 191.41]  < return
[ 191.42]  > Math.absMod(val: float64, mod: float64): float64
[ 191.42]  < return
[ 191.43]  > Math.absMod(val: float64, mod: float64): float64
[ 191.44]  < return
[ 191.45]  > Math.absMod(val: float64, mod: float64): float64
[ 191.45]  < return
[ 191.46]  > Math.absMod(val: float32, mod: float32): float32
[ 191.47]  < return
[ 191.48]  > Math.absMod(val: float32, mod: float32): float32
[ 191.49]  < return
[ 191.50]  > Math.absMod(val: float32, mod: float32): float32
[ 191.50]  < return
[ 191.51]  > Math.absMod(val: float32, mod: float32): float32
[ 191.52]  < return
[ 191.53]  > Math.absMod(val: float32, mod: float32): float32
[ 191.53]  < return
[ 191.54]  > Math.absMod(val: float32, mod: float32): float32
[ 191.55]  < return
[ 191.56]  > Math.absMod(val: float32, mod: float32): float32
[ 191.57]  < return
[ 191.58]  > Math.absMod(val: float32, mod: float32): float32
[ 191.59]  < return
[ 191.60]  > Math.absMod(val: float32, mod: float32): float32
[ 191.60]  < return
[ 191.61]  > Math.absMod(val: float32, mod: float32): float32
[ 191.62]  < return
[ 191.63]  > Math.absMod(val: float32, mod: float32): float32
[ 191.63]  < return
[ 191.65]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 191.66]  < return
[ 191.67]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 191.68]  < return
[ 191.69]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 191.70]  < return
[ 191.71]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 191.72]  < return
[ 191.73]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 191.74]  < return
[ 191.75]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 191.76]  < return
[ 191.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:26: debug: val1: int64(42)
[ 191.79]  < return
[ 191.80]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:27: debug: val2: int64(96)
[ 191.82]  < return
[ 191.82]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 191.84]  < return
[ 191.85]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 191.86]  < return
[ 191.87]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:32: debug: val1: int64(0)
[ 191.89]  < return
[ 191.90]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:33: debug: val2: int64(42)
[ 191.91]  < return
[ 191.92]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 191.93]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	cmplStd/test/lang/init.method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 191.99]   < return
[ 192.00]  < return
[ 192.01]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 192.02]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	cmplStd/test/lang/init.method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 192.07]   < return
[ 192.08]  < return
[ 192.09]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 192.10]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:85: debug: extension.staticMethod
[ 192.11]   < return
[ 192.12]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 192.13]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	cmplStd/test/lang/init.method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	cmplStd/test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 192.20]    < return
[ 192.20]   < return
[ 192.21]  < return
[ 192.22]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 192.23]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:91: debug: extension.virtualMethod
[ 192.24]   < return
[ 192.25]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 192.26]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	cmplStd/test/lang/init.method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	cmplStd/test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 192.33]    < return
[ 192.33]   < return
[ 192.34]  < return
[ 192.35]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 192.36]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	cmplStd/test/lang/init.method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 192.42]   < return
[ 192.42]  < return
[ 192.43]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 192.44]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 192.50]   < return
[ 192.50]  < return
[ 192.51]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 192.53]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 192.58]   < return
[ 192.59]  < return
[ 192.60]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.array.ci:35: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 192.64]  < return
[ 192.65]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.array.ci:38: debug: string as variant: char[*]("string")
[ 192.67]  < return
[ 192.68]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.array.ci:41: debug: string as variant: char[]([0] {})
[ 192.70]  < return
[ 192.72]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.72]  < return
[ 192.73]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.74]  < return
[ 192.75]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.76]  < return
[ 192.77]  > lenSlice(values: int64[]): int32
[ 192.78]  < return
[ 192.78]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.79]  < return
[ 192.80]  > lenSlice(values: int64[]): int32
[ 192.81]  < return
[ 192.82]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.83]  < return
[ 192.84]  > lenSlice(values: int64[]): int32
[ 192.85]  < return
[ 192.86]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.86]  < return
[ 192.87]  > lenSlice(values: int64[]): int32
[ 192.88]  < return
[ 192.89]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.90]  < return
[ 192.91]  > lenSlice(values: int64[]): int32
[ 192.92]  < return
[ 192.93]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 192.93]  < return
[ 192.98]  > nthFixed(idx: int32, values: int64[7]): int64
[ 192.99]  < return
[ 193.01]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.02]  < return
[ 193.03]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.04]  < return
[ 193.06]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.07]  < return
[ 193.09]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.10]  < return
[ 193.12]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.13]  < return
[ 193.14]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.15]  < return
[ 193.17]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.18]  < return
[ 193.24]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.25]  < return
[ 193.27]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.28]  < return
[ 193.29]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.31]  < return
[ 193.32]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.33]  < return
[ 193.35]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.36]  < return
[ 193.37]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.39]  < return
[ 193.40]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.41]  < return
[ 193.43]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.44]  < return
[ 193.50]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.51]  < return
[ 193.53]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.54]  < return
[ 193.55]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.57]  < return
[ 193.58]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.59]  < return
[ 193.61]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.62]  < return
[ 193.64]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.65]  < return
[ 193.66]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.68]  < return
[ 193.69]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.70]  < return
[ 193.76]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.77]  < return
[ 193.79]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.80]  < return
[ 193.81]  > nthFixed(idx: int32, values: int64[7]): int64
[ 193.83]  < return
[ 193.84]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.85]  < return
[ 193.87]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.88]  < return
[ 193.90]  > nthArray(idx: int32, values: int64[*]): int64
[ 193.91]  < return
[ 193.93]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.94]  < return
[ 193.95]  > nthSlice(idx: int32, values: int64[]): int64
[ 193.97]  < return
[ 194.02]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.04]  < return
[ 194.05]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.06]  < return
[ 194.08]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.09]  < return
[ 194.10]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.12]  < return
[ 194.13]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.14]  < return
[ 194.16]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.17]  < return
[ 194.19]  > nthSlice(idx: int32, values: int64[]): int64
[ 194.20]  < return
[ 194.22]  > nthSlice(idx: int32, values: int64[]): int64
[ 194.23]  < return
[ 194.28]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.30]  < return
[ 194.31]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.32]  < return
[ 194.34]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.35]  < return
[ 194.37]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.38]  < return
[ 194.39]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.40]  < return
[ 194.42]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.43]  < return
[ 194.45]  > nthSlice(idx: int32, values: int64[]): int64
[ 194.46]  < return
[ 194.47]  > nthSlice(idx: int32, values: int64[]): int64
[ 194.49]  < return
[ 194.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.56]  < return
[ 194.57]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.58]  < return
[ 194.60]  > nthFixed(idx: int32, values: int64[7]): int64
[ 194.61]  < return
[ 194.62]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.64]  < return
[ 194.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.66]  < return
[ 194.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 194.69]  < return
[ 194.71]  > nthSlice(idx: int32, values: int64[]): int64
[ 194.72]  < return
[ 194.73]  > nthSlice(idx: int32, values: int64[]): int64
[ 194.74]  < return
[ 194.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
[ 194.79]  < return
[ 194.80]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
[ 194.82]  < return
[ 194.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
[ 194.84]  < return
[ 194.87]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 194.88]  < return
[ 194.91]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 194.92]  < return
[ 194.94]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 194.96]  < return
[ 194.97]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 194.99]  < return
[ 195.01]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:4: debug: for ( ; ; )
[ 195.02]  < return
[ 195.04]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 195.05]  < return
[ 195.07]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 195.08]  < return
[ 195.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 195.12]  < return
[ 195.14]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 195.16]  < return
[ 195.21]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
[ 195.22]  < return
[ 195.25]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
[ 195.26]  < return
[ 195.28]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
[ 195.30]  < return
[ 195.32]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
[ 195.33]  < return
[ 195.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
[ 195.37]  < return
[ 195.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(0)
[ 195.41]  < return
[ 195.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(1)
[ 195.45]  < return
[ 195.47]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(2)
[ 195.49]  < return
[ 195.50]  > halt(): void
[ 195.51]  < return
[ 195.51] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
cmplStd/lib/debug.ci:48: NotEquals: typename(<NotEquals>)
cmplStd/lib/debug.ci:61: assertEq: function(<assertEq>)
cmplStd/lib/math.ci:22: Math.modf: function(<Math.modf>)
cmplStd/lib/math.ci:47: Math.floor: function(<Math.floor>)
cmplStd/lib/math.ci:77: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:85: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:147: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:158: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:189: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:203: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:217: Math.sum: function(<Math.sum>)
cmplStd/lib/math.ci:226: Math.mean: function(<Math.mean>)
cmplStd/lib/math.ci:243: Math.eval: function(<Math.eval>)
cmplStd/lib/math.ci:252: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:267: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:282: Math.sinCos: function(<Math.sinCos>)
cmplStd/lib/math.ci:339: Math.tan: function(<Math.tan>)
cmplStd/lib/math.ci:396: Math.sinh: function(<Math.sinh>)
cmplStd/lib/math.ci:435: Math.cosh: function(<Math.cosh>)
cmplStd/lib/math.ci:450: Math.asin: function(<Math.asin>)
cmplStd/lib/math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:24: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:31: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:86: div: function(<div>)
cmplStd/lib/math/Complex.ci:117: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:135: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:111: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:163: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:173: scale: function(<scale>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/string.ci:4: length: function(<length>)
cmplStd/lib/string.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/string.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/string.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/string.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/string.ci:61: compare: function(<compare>)
cmplStd/lib/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/string.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/string.ci:112: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/string.ci:127: append: function(<append>)
cmplStd/lib/string.ci:144: append: function(<append>)
cmplStd/lib/string.ci:234: append: function(<append>)
cmplStd/lib/string.ci:262: append: function(<append>)
cmplStd/test/lang/emit.ci:3: emitldz32: int32(0)
cmplStd/test/lang/emit.ci:4: emitldz64: int64(0)
cmplStd/test/lang/emit.ci:6: emitA: int32(42)
cmplStd/test/lang/emit.ci:7: emitB: int32(96)
cmplStd/test/lang/emit.ci:10: emitAddI32: int32(138)
cmplStd/test/lang/emit.ci:13: emitDivI32: int32(2)
cmplStd/test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
cmplStd/test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
cmplStd/test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
cmplStd/test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
cmplStd/test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
cmplStd/test/lang/emit.ci:29: emitSlice: char[]([3] {'s', 't', 'r'})
cmplStd/test/lang/inlineMacros.ci:10: i3: int32(3)
cmplStd/test/lang/inlineMacros.ci:11: i6: int32(6)
cmplStd/test/lang/inlineMacros.ci:12: i2: int32(2)
cmplStd/test/lang/inlineMacros.ci:13: i8: int32(8)
cmplStd/test/lang/inlineMacros.ci:15: zeroVal: int32(0)
cmplStd/test/lang/inlineMacros.ci:16: zeroVar: int32(0)
cmplStd/test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
cmplStd/test/lang/inlineMacros.ci:19: lastVal: int32(6)
cmplStd/test/lang/inlineMacros.ci:20: lastVar: int32(6)
cmplStd/test/lang/inlineMacros.ci:21: lastXpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:23: sum2Val: int32(9)
cmplStd/test/lang/inlineMacros.ci:24: sum2Var: int32(9)
cmplStd/test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
cmplStd/test/lang/inlineMacros.ci:27: any2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:28: any2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:31: min2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:32: min2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:35: max2Val: int32(6)
cmplStd/test/lang/inlineMacros.ci:36: max2Var: int32(6)
cmplStd/test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:59: minRlVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:60: minLrVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:61: minRlVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:62: minLrVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
cmplStd/test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
cmplStd/test/lang/overload.inline.ci:9: overload1: float32(1.000000)
cmplStd/test/lang/overload.inline.ci:10: overload2: float32(2.000000)
cmplStd/test/lang/overload.inline.ci:11: overload3: float32(3.000000)
cmplStd/test/lang/overload.inline.ci:12: overload4: float32(4.000000)
cmplStd/test/lang/overload.inline.ci:13: overload5: float32(5.000000)
cmplStd/test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
cmplStd/test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
cmplStd/test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
cmplStd/test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
cmplStd/test/std/number.ci:3: pi64: float64(3.141593)
cmplStd/test/std/number.ci:4: e64: float64(2.718282)
cmplStd/test/std/number.ci:6: pi32: float32(3.141593)
cmplStd/test/std/number.ci:7: e32: float32(2.718282)
cmplStd/test/std/number.ci:14: r_comp: int32(112)
cmplStd/test/std/number.ci:15: g_comp: int32(252)
cmplStd/test/std/number.ci:16: b_comp: int32(248)
cmplStd/test/std/number.ci:18: r5g6b5: int32(30719)
cmplStd/test/std/number.ci:19: r8g8b8: int32(7404792)
cmplStd/test/std/number.ci:21: zxtR5: int32(14)
cmplStd/test/std/number.ci:22: zxtG6: int32(63)
cmplStd/test/std/number.ci:23: zxtB5: int32(31)
cmplStd/test/std/number.ci:25: sxtR5: int32(14)
cmplStd/test/std/number.ci:26: sxtG6: int32(-1)
cmplStd/test/std/number.ci:27: sxtB5: int32(-1)
cmplStd/test/std/number.ci:29: zxtR8: int32(112)
cmplStd/test/std/number.ci:30: zxtG8: int32(252)
cmplStd/test/std/number.ci:31: zxtB8: int32(248)
cmplStd/test/std/number.ci:33: sxtR8: int32(112)
cmplStd/test/std/number.ci:34: sxtG8: int32(-4)
cmplStd/test/std/number.ci:35: sxtB8: int32(-8)
cmplStd/test/std/number.ci:37: testSin_f64: float64(1.000000)
cmplStd/test/std/number.ci:38: testCos_f64: float64(0.000000)
cmplStd/test/std/number.ci:39: testTan_f64: float64(1.000000)
cmplStd/test/std/number.ci:40: testLog_f64: float64(3.000000)
cmplStd/test/std/number.ci:41: testExp_f64: float64(2.718282)
cmplStd/test/std/number.ci:42: testPow_f64: float64(3.141593)
cmplStd/test/std/number.ci:43: testSqrt_f64: float64(3.141593)
cmplStd/test/std/number.ci:44: testAtan_f64: float64(1.262627)
cmplStd/test/std/number.ci:46: testSin_f32: float32(1.000000)
cmplStd/test/std/number.ci:47: testCos_f32: float32(-0.000000)
cmplStd/test/std/number.ci:48: testTan_f32: float32(1.000000)
cmplStd/test/std/number.ci:49: testLog_f32: float32(3.000000)
cmplStd/test/std/number.ci:50: testExp_f32: float32(2.718282)
cmplStd/test/std/number.ci:51: testPow_f32: float32(3.141593)
cmplStd/test/std/number.ci:52: testSqrt_f32: float32(3.141593)
cmplStd/test/std/number.ci:53: testAtan_f32: float32(1.262627)
cmplStd/test/std/number.ci:55: testPopulation_u32: int32(14)
cmplStd/test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
cmplStd/test/std/number.ci:57: testBitScanReverse_u32: int32(14)
cmplStd/test/std/number.ci:58: testBitScanForward_u32: int32(0)
cmplStd/test/std/number.ci:59: testHighBit_u32: int32(16384)
cmplStd/test/std/number.ci:60: testLowBit_u32: int32(1)
cmplStd/test/std/number.ci:62: testZeroExtend_u32: int32(31)
cmplStd/test/std/number.ci:63: testSignExtend_u32: int32(-1)
cmplStd/test/std/number.ci:65: testZeroExtend_u64: int32(31)
cmplStd/test/std/number.ci:66: testSignExtend_u64: int32(-1)
cmplStd/test/std/memory.ci:7: p1: pointer(<?>)
cmplStd/test/std/memory.ci:8: p2: pointer(<?>)
cmplStd/test/std/memory.ci:9: p3: pointer(<?>)
cmplStd/test/std/memory.ci:10: p4: pointer(<?>)
cmplStd/test/std/memory.ci:23: val1: int64(0)
cmplStd/test/std/memory.ci:24: val2: int64(42)
cmplStd/test/std/tryExec.ci:11: noError: function(<noError>)
cmplStd/test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
cmplStd/test/std/tryExec.ci:20: divisionByZero: function(<divisionByZero>)
cmplStd/test/std/tryExec.ci:24: abortExecution: function(<abortExecution>)
cmplStd/test/std/tryExec.ci:38: invalidMemoryAccess: function(<invalidMemoryAccess>)
cmplStd/test/std/tryExec.ci:43: invalidInstruction: function(<invalidInstruction>)
cmplStd/test/std/tryExec.ci:47: tryExecErr0: int32(0)
cmplStd/test/std/tryExec.ci:48: tryExecErr1: int32(1)
cmplStd/test/std/tryExec.ci:49: tryExecErr2: int32(2)
cmplStd/test/std/tryExec.ci:50: tryExecErr3: int32(3)
cmplStd/test/std/tryExec.ci:51: tryExecErr4: int32(4)
cmplStd/test/std/tryExec.ci:52: tryExecErr5: int32(5)
cmplStd/test/std/tryExec.ci:53: tryExecErr6: int32(6)
cmplStd/test/lang/init.reference.ci:7: value: int64(42)
cmplStd/test/lang/init.reference.ci:8: valueRef: int64(42)
cmplStd/test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:12: fromRef: int64(42)
cmplStd/test/lang/init.reference.ci:13: fromPtr: int64(42)
cmplStd/test/lang/init.reference.ci:14: fromVar: int64(42)
cmplStd/test/lang/init.reference.ci:16: nullRef: int64(null)
cmplStd/test/lang/init.reference.ci:17: nullPtr: pointer(null)
cmplStd/test/lang/init.reference.ci:18: nullVar: variant(null)
cmplStd/test/lang/init.reference.ci:19: nullTyp: typename(null)
cmplStd/test/lang/init.reference.ci:20: nullFun: function(null)
cmplStd/test/lang/init.reference.ci:21: nullObj: object(null)
cmplStd/test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:27: local: int64(42)
cmplStd/test/lang/init.reference.ci:28: copyVal: int64(42)
cmplStd/test/lang/init.reference.ci:29: copyRef: int64(42)
cmplStd/test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
cmplStd/test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
cmplStd/test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
cmplStd/test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
cmplStd/test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
cmplStd/test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
cmplStd/test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
cmplStd/test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
cmplStd/test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
cmplStd/test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
cmplStd/test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
cmplStd/test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
cmplStd/test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
cmplStd/test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
cmplStd/test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
cmplStd/test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
cmplStd/test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
cmplStd/test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
cmplStd/test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
cmplStd/test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
cmplStd/test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
cmplStd/test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
cmplStd/test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
cmplStd/test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
cmplStd/test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
cmplStd/test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
cmplStd/test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
cmplStd/test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
cmplStd/test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
cmplStd/test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
cmplStd/test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
cmplStd/test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
cmplStd/test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
cmplStd/test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
cmplStd/test/lang/init.reference.ci:75: typVoid: typename(<void>)
cmplStd/test/lang/init.reference.ci:76: typBool: typename(<bool>)
cmplStd/test/lang/init.reference.ci:77: typChar: typename(<char>)
cmplStd/test/lang/init.reference.ci:78: typInt8: typename(<int8>)
cmplStd/test/lang/init.reference.ci:79: typInt16: typename(<int16>)
cmplStd/test/lang/init.reference.ci:80: typInt32: typename(<int32>)
cmplStd/test/lang/init.reference.ci:81: typInt64: typename(<int64>)
cmplStd/test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
cmplStd/test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
cmplStd/test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
cmplStd/test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
cmplStd/test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
cmplStd/test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
cmplStd/test/lang/init.reference.ci:88: typTypename: typename(<typename>)
cmplStd/test/lang/init.reference.ci:89: typFunction: typename(<function>)
cmplStd/test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
cmplStd/test/lang/init.reference.ci:91: typVariant: typename(<variant>)
cmplStd/test/lang/init.reference.ci:92: typObject: typename(<object>)
cmplStd/test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
cmplStd/test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
cmplStd/test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
cmplStd/test/lang/init.variable.ci:3: variable: int32(0)
cmplStd/test/lang/init.variable.ci:7: constant: int32(42)
cmplStd/test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
cmplStd/test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
cmplStd/test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
cmplStd/test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/function.ci:4: empty: function(<empty>)
cmplStd/test/lang/function.ci:7: funAdd: function(<funAdd>)
cmplStd/test/lang/function.ci:12: funAddResult: int32(9)
cmplStd/test/lang/function.ci:15: funAddRef: function(<funAdd>)
cmplStd/test/lang/function.ci:18: funAddRefResult: int32(10)
cmplStd/test/lang/function.ci:21: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:24: funMulResult: int32(12)
cmplStd/test/lang/function.ci:27: funMulRef: function(<funMul>)
cmplStd/test/lang/function.ci:30: funMulRefResult: int32(14)
cmplStd/test/lang/function.ci:33: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:38: fib: function(<fib>)
cmplStd/test/lang/function.ci:46: fibonacci_13: uint32(233)
cmplStd/test/lang/reflect.ci:3: sizeofVoid: int32(0)
cmplStd/test/lang/reflect.ci:4: sizeofBool: int32(1)
cmplStd/test/lang/reflect.ci:5: sizeofChar: int32(1)
cmplStd/test/lang/reflect.ci:6: sizeofInt8: int32(1)
cmplStd/test/lang/reflect.ci:7: sizeofInt16: int32(2)
cmplStd/test/lang/reflect.ci:8: sizeofInt32: int32(4)
cmplStd/test/lang/reflect.ci:9: sizeofInt64: int32(8)
cmplStd/test/lang/reflect.ci:10: sizeofUint8: int32(1)
cmplStd/test/lang/reflect.ci:11: sizeofUint16: int32(2)
cmplStd/test/lang/reflect.ci:12: sizeofUint32: int32(4)
cmplStd/test/lang/reflect.ci:13: sizeofUint64: int32(8)
cmplStd/test/lang/reflect.ci:14: sizeofFloat32: int32(4)
cmplStd/test/lang/reflect.ci:15: sizeofFloat64: int32(8)
cmplStd/test/lang/reflect.ci:16: sizeofPointer: int32(4)
cmplStd/test/lang/reflect.ci:17: sizeofVariant: int32(8)
cmplStd/test/lang/reflect.ci:18: sizeofTypename: int32(160)
cmplStd/test/lang/reflect.ci:19: sizeofFunction: int32(4)
cmplStd/test/lang/reflect.ci:20: sizeofObject: int32(4)
cmplStd/test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
cmplStd/test/lang/reflect.ci:32: offsetOfRecord: int32(308976)
cmplStd/test/lang/reflect.ci:33: sizeOfRecord: int32(16)
cmplStd/test/lang/reflect.ci:34: fileOfRecord: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:35: lineOfRecord: int32(26)
cmplStd/test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
cmplStd/test/lang/reflect.ci:39: offsetOfBase: int32(308656)
cmplStd/test/lang/reflect.ci:40: sizeOfBase: int32(12)
cmplStd/test/lang/reflect.ci:41: fileOfBase: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:42: lineOfBase: int32(22)
cmplStd/test/lang/reflect.ci:44: typeofBase1: typename(<object>)
cmplStd/test/lang/reflect.ci:45: offsetOfBase1: int32(2880)
cmplStd/test/lang/reflect.ci:46: sizeOfBase1: int32(4)
cmplStd/test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
cmplStd/test/lang/reflect.ci:49: offsetOfBase2: int32(8)
cmplStd/test/lang/reflect.ci:50: sizeOfBase2: int32(160)
cmplStd/test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
cmplStd/test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
cmplStd/test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
cmplStd/test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
cmplStd/test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
cmplStd/test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
cmplStd/test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
cmplStd/test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
cmplStd/test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
cmplStd/test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
cmplStd/test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
cmplStd/test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
cmplStd/test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
cmplStd/test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
cmplStd/test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
cmplStd/test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
cmplStd/test/lang/init.array.ci:11: arrFixedInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
cmplStd/test/lang/init.array.ci:18: arrArrayInitNull: int64[*](null)
cmplStd/test/lang/init.array.ci:19: arrSliceInitNull: int64[](null)
cmplStd/test/lang/init.array.ci:22: arrArrayInitFixed: int64[*]([0] {})
cmplStd/test/lang/init.array.ci:23: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
cmplStd/test/lang/init.array.ci:26: arrArrayInitSlice: int64[*]([0] {})
cmplStd/test/lang/init.array.ci:27: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
cmplStd/test/lang/init.array.ci:30: arrArrayInitPtr: int64[*]([0] {})
cmplStd/test/lang/init.array.ci:34: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
cmplStd/test/lang/init.array.ci:37: strArray: char[*]("string")
cmplStd/test/lang/init.array.ci:40: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
cmplStd/test/lang/init.array.ci:51: lenSlice: function(<lenSlice>)
cmplStd/test/lang/init.array.ci:52: nthFixed: function(<nthFixed>)
cmplStd/test/lang/init.array.ci:53: nthArray: function(<nthArray>)
cmplStd/test/lang/init.array.ci:54: nthSlice: function(<nthSlice>)
cmplStd/test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
cmplStd/test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
cmplStd/test/lang/recUnion.ci:16: color: typename(<color>)
cmplStd/test/lang/recUnion.ci:22: Color: typename(<Color>)
cmplStd/test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
cmplStd/test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535)
})
cmplStd/test/lang/recUnion.ci:31: blue: color({
	col: uint32(255)
})
cmplStd/test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
cmplStd/test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
cmplStd/test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
cmplStd/test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
cmplStd/test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
cmplStd/test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
cmplStd/test/lang/useOperator.ci:5: shift: int32(2)
cmplStd/test/lang/useOperator.ci:7: boolA: bool(1)
cmplStd/test/lang/useOperator.ci:8: boolB: bool(1)
cmplStd/test/lang/useOperator.ci:17: boolAnd: bool(1)
cmplStd/test/lang/useOperator.ci:18: boolIor: bool(1)
cmplStd/test/lang/useOperator.ci:19: boolXor: bool(0)
cmplStd/test/lang/useOperator.ci:22: boolNot: bool(0)
cmplStd/test/lang/useOperator.ci:23: boolCeq: bool(1)
cmplStd/test/lang/useOperator.ci:24: boolCne: bool(0)
cmplStd/test/lang/useOperator.ci:25: boolClt: bool(0)
cmplStd/test/lang/useOperator.ci:26: boolCle: bool(1)
cmplStd/test/lang/useOperator.ci:27: boolCgt: bool(0)
cmplStd/test/lang/useOperator.ci:28: boolCge: bool(1)
cmplStd/test/lang/useOperator.ci:30: chrA: char('a')
cmplStd/test/lang/useOperator.ci:31: chrB: char('b')
cmplStd/test/lang/useOperator.ci:32: chrPls: char('b')
cmplStd/test/lang/useOperator.ci:33: chrNeg: char('')
cmplStd/test/lang/useOperator.ci:34: chrCmt: char('')
cmplStd/test/lang/useOperator.ci:35: chrAdd: char('')
cmplStd/test/lang/useOperator.ci:36: chrSub: char('')
cmplStd/test/lang/useOperator.ci:37: chrMul: char('\"')
cmplStd/test/lang/useOperator.ci:38: chrDiv: char('')
cmplStd/test/lang/useOperator.ci:39: chrMod: char('a')
cmplStd/test/lang/useOperator.ci:40: chrAnd: char('`')
cmplStd/test/lang/useOperator.ci:41: chrIor: char('c')
cmplStd/test/lang/useOperator.ci:42: chrXor: char('')
cmplStd/test/lang/useOperator.ci:43: chrShl: char('')
cmplStd/test/lang/useOperator.ci:44: chrShr: char('')
cmplStd/test/lang/useOperator.ci:45: chrNot: bool(0)
cmplStd/test/lang/useOperator.ci:46: chrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:47: chrCne: bool(1)
cmplStd/test/lang/useOperator.ci:48: chrClt: bool(1)
cmplStd/test/lang/useOperator.ci:49: chrCle: bool(1)
cmplStd/test/lang/useOperator.ci:50: chrCgt: bool(0)
cmplStd/test/lang/useOperator.ci:51: chrCge: bool(0)
cmplStd/test/lang/useOperator.ci:53: i8A: int8(96)
cmplStd/test/lang/useOperator.ci:54: i8B: int8(42)
cmplStd/test/lang/useOperator.ci:55: i8Pls: int8(42)
cmplStd/test/lang/useOperator.ci:56: i8Neg: int8(-42)
cmplStd/test/lang/useOperator.ci:57: i8Cmt: int8(-43)
cmplStd/test/lang/useOperator.ci:58: i8Add: int8(-118)
cmplStd/test/lang/useOperator.ci:59: i8Sub: int8(54)
cmplStd/test/lang/useOperator.ci:60: i8Mul: int8(-64)
cmplStd/test/lang/useOperator.ci:61: i8Div: int8(2)
cmplStd/test/lang/useOperator.ci:62: i8Mod: int8(12)
cmplStd/test/lang/useOperator.ci:63: i8And: int8(32)
cmplStd/test/lang/useOperator.ci:64: i8Ior: int8(106)
cmplStd/test/lang/useOperator.ci:65: i8Xor: int8(74)
cmplStd/test/lang/useOperator.ci:66: i8Shl: int8(-128)
cmplStd/test/lang/useOperator.ci:67: i8Shr: int8(24)
cmplStd/test/lang/useOperator.ci:68: i8Not: bool(0)
cmplStd/test/lang/useOperator.ci:69: i8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:70: i8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:71: i8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:72: i8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:73: i8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:74: i8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:76: u8A: uint8(96)
cmplStd/test/lang/useOperator.ci:77: u8B: uint8(42)
cmplStd/test/lang/useOperator.ci:78: u8Pls: uint8(42)
cmplStd/test/lang/useOperator.ci:79: u8Neg: uint8(214)
cmplStd/test/lang/useOperator.ci:80: u8Cmt: uint8(213)
cmplStd/test/lang/useOperator.ci:81: u8Add: uint8(138)
cmplStd/test/lang/useOperator.ci:82: u8Sub: uint8(54)
cmplStd/test/lang/useOperator.ci:83: u8Mul: uint8(192)
cmplStd/test/lang/useOperator.ci:84: u8Div: uint8(2)
cmplStd/test/lang/useOperator.ci:85: u8Mod: uint8(12)
cmplStd/test/lang/useOperator.ci:86: u8And: uint8(32)
cmplStd/test/lang/useOperator.ci:87: u8Ior: uint8(106)
cmplStd/test/lang/useOperator.ci:88: u8Xor: uint8(74)
cmplStd/test/lang/useOperator.ci:89: u8Shl: uint8(128)
cmplStd/test/lang/useOperator.ci:90: u8Shr: uint8(24)
cmplStd/test/lang/useOperator.ci:91: u8Not: bool(0)
cmplStd/test/lang/useOperator.ci:92: u8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:93: u8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:94: u8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:95: u8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:96: u8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:97: u8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:99: i16A: int16(96)
cmplStd/test/lang/useOperator.ci:100: i16B: int16(42)
cmplStd/test/lang/useOperator.ci:101: i16Pls: int16(42)
cmplStd/test/lang/useOperator.ci:102: i16Neg: int16(-42)
cmplStd/test/lang/useOperator.ci:103: i16Cmt: int16(-43)
cmplStd/test/lang/useOperator.ci:104: i16Add: int16(138)
cmplStd/test/lang/useOperator.ci:105: i16Sub: int16(54)
cmplStd/test/lang/useOperator.ci:106: i16Mul: int16(4032)
cmplStd/test/lang/useOperator.ci:107: i16Div: int16(2)
cmplStd/test/lang/useOperator.ci:108: i16Mod: int16(12)
cmplStd/test/lang/useOperator.ci:109: i16And: int16(32)
cmplStd/test/lang/useOperator.ci:110: i16Ior: int16(106)
cmplStd/test/lang/useOperator.ci:111: i16Xor: int16(74)
cmplStd/test/lang/useOperator.ci:112: i16Shl: int16(384)
cmplStd/test/lang/useOperator.ci:113: i16Shr: int16(24)
cmplStd/test/lang/useOperator.ci:114: i16Not: bool(0)
cmplStd/test/lang/useOperator.ci:115: i16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:116: i16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:117: i16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:118: i16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:119: i16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:120: i16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:122: u16A: uint16(96)
cmplStd/test/lang/useOperator.ci:123: u16B: uint16(42)
cmplStd/test/lang/useOperator.ci:124: u16Pls: uint16(42)
cmplStd/test/lang/useOperator.ci:125: u16Neg: uint16(65494)
cmplStd/test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
cmplStd/test/lang/useOperator.ci:127: u16Add: uint16(138)
cmplStd/test/lang/useOperator.ci:128: u16Sub: uint16(54)
cmplStd/test/lang/useOperator.ci:129: u16Mul: uint16(4032)
cmplStd/test/lang/useOperator.ci:130: u16Div: uint16(2)
cmplStd/test/lang/useOperator.ci:131: u16Mod: uint16(12)
cmplStd/test/lang/useOperator.ci:132: u16And: uint16(32)
cmplStd/test/lang/useOperator.ci:133: u16Ior: uint16(106)
cmplStd/test/lang/useOperator.ci:134: u16Xor: uint16(74)
cmplStd/test/lang/useOperator.ci:135: u16Shl: uint16(384)
cmplStd/test/lang/useOperator.ci:136: u16Shr: uint16(24)
cmplStd/test/lang/useOperator.ci:137: u16Not: bool(0)
cmplStd/test/lang/useOperator.ci:138: u16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:139: u16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:140: u16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:141: u16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:142: u16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:143: u16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:145: i32A: int32(96)
cmplStd/test/lang/useOperator.ci:146: i32B: int32(42)
cmplStd/test/lang/useOperator.ci:147: i32Pls: int32(42)
cmplStd/test/lang/useOperator.ci:148: i32Neg: int32(-42)
cmplStd/test/lang/useOperator.ci:149: i32Cmt: int32(-43)
cmplStd/test/lang/useOperator.ci:150: i32Add: int32(138)
cmplStd/test/lang/useOperator.ci:151: i32Sub: int32(54)
cmplStd/test/lang/useOperator.ci:152: i32Mul: int32(4032)
cmplStd/test/lang/useOperator.ci:153: i32Div: int32(2)
cmplStd/test/lang/useOperator.ci:154: i32Mod: int32(12)
cmplStd/test/lang/useOperator.ci:155: i32And: int32(32)
cmplStd/test/lang/useOperator.ci:156: i32Ior: int32(106)
cmplStd/test/lang/useOperator.ci:157: i32Xor: int32(74)
cmplStd/test/lang/useOperator.ci:158: i32Shl: int32(384)
cmplStd/test/lang/useOperator.ci:159: i32Shr: int32(24)
cmplStd/test/lang/useOperator.ci:160: i32Not: bool(0)
cmplStd/test/lang/useOperator.ci:161: i32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:162: i32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:163: i32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:164: i32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:165: i32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:166: i32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:168: u32A: uint32(96)
cmplStd/test/lang/useOperator.ci:169: u32B: uint32(42)
cmplStd/test/lang/useOperator.ci:170: u32Pls: uint32(42)
cmplStd/test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
cmplStd/test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
cmplStd/test/lang/useOperator.ci:173: u32Add: uint32(138)
cmplStd/test/lang/useOperator.ci:174: u32Sub: uint32(54)
cmplStd/test/lang/useOperator.ci:175: u32Mul: uint32(4032)
cmplStd/test/lang/useOperator.ci:176: u32Div: uint32(2)
cmplStd/test/lang/useOperator.ci:177: u32Mod: uint32(12)
cmplStd/test/lang/useOperator.ci:178: u32And: uint32(32)
cmplStd/test/lang/useOperator.ci:179: u32Ior: uint32(106)
cmplStd/test/lang/useOperator.ci:180: u32Xor: uint32(74)
cmplStd/test/lang/useOperator.ci:181: u32Shl: uint32(384)
cmplStd/test/lang/useOperator.ci:182: u32Shr: uint32(24)
cmplStd/test/lang/useOperator.ci:183: u32Not: bool(0)
cmplStd/test/lang/useOperator.ci:184: u32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:185: u32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:186: u32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:187: u32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:188: u32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:189: u32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:191: i64A: int64(96)
cmplStd/test/lang/useOperator.ci:192: i64B: int64(42)
cmplStd/test/lang/useOperator.ci:193: i64Pls: int64(42)
cmplStd/test/lang/useOperator.ci:194: i64Neg: int64(-42)
cmplStd/test/lang/useOperator.ci:195: i64Cmt: int64(-43)
cmplStd/test/lang/useOperator.ci:196: i64Add: int64(138)
cmplStd/test/lang/useOperator.ci:197: i64Sub: int64(54)
cmplStd/test/lang/useOperator.ci:198: i64Mul: int64(4032)
cmplStd/test/lang/useOperator.ci:199: i64Div: int64(2)
cmplStd/test/lang/useOperator.ci:200: i64Mod: int64(12)
cmplStd/test/lang/useOperator.ci:201: i64And: int64(32)
cmplStd/test/lang/useOperator.ci:202: i64Ior: int64(106)
cmplStd/test/lang/useOperator.ci:203: i64Xor: int64(74)
cmplStd/test/lang/useOperator.ci:204: i64Shl: int64(384)
cmplStd/test/lang/useOperator.ci:205: i64Shr: int64(24)
cmplStd/test/lang/useOperator.ci:206: i64Not: bool(0)
cmplStd/test/lang/useOperator.ci:207: i64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:208: i64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:209: i64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:210: i64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:211: i64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:212: i64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:214: u64A: uint64(96)
cmplStd/test/lang/useOperator.ci:215: u64B: uint64(42)
cmplStd/test/lang/useOperator.ci:216: u64Pls: uint64(42)
cmplStd/test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
cmplStd/test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
cmplStd/test/lang/useOperator.ci:219: u64Add: uint64(138)
cmplStd/test/lang/useOperator.ci:220: u64Sub: uint64(54)
cmplStd/test/lang/useOperator.ci:221: u64Mul: uint64(4032)
cmplStd/test/lang/useOperator.ci:222: u64Div: uint64(2)
cmplStd/test/lang/useOperator.ci:223: u64Mod: uint64(12)
cmplStd/test/lang/useOperator.ci:224: u64And: uint64(32)
cmplStd/test/lang/useOperator.ci:225: u64Ior: uint64(106)
cmplStd/test/lang/useOperator.ci:226: u64Xor: uint64(74)
cmplStd/test/lang/useOperator.ci:227: u64Shl: uint64(384)
cmplStd/test/lang/useOperator.ci:228: u64Shr: uint64(24)
cmplStd/test/lang/useOperator.ci:229: u64Not: bool(0)
cmplStd/test/lang/useOperator.ci:230: u64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:231: u64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:232: u64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:233: u64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:234: u64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:235: u64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:237: f32A: float32(96.300003)
cmplStd/test/lang/useOperator.ci:238: f32B: float32(42.139999)
cmplStd/test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
cmplStd/test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
cmplStd/test/lang/useOperator.ci:242: f32Add: float32(138.440002)
cmplStd/test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
cmplStd/test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
cmplStd/test/lang/useOperator.ci:245: f32Div: float32(2.285240)
cmplStd/test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
cmplStd/test/lang/useOperator.ci:252: f32Not: bool(0)
cmplStd/test/lang/useOperator.ci:253: f32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:254: f32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:255: f32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:256: f32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:257: f32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:258: f32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:260: f64A: float64(96.300000)
cmplStd/test/lang/useOperator.ci:261: f64B: float64(42.140000)
cmplStd/test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
cmplStd/test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
cmplStd/test/lang/useOperator.ci:265: f64Add: float64(138.440000)
cmplStd/test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
cmplStd/test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
cmplStd/test/lang/useOperator.ci:268: f64Div: float64(2.285240)
cmplStd/test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
cmplStd/test/lang/useOperator.ci:275: f64Not: bool(0)
cmplStd/test/lang/useOperator.ci:276: f64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:277: f64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:278: f64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:279: f64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:280: f64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:281: f64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:283: ptrA: pointer(null)
cmplStd/test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
cmplStd/test/lang/useOperator.ci:299: ptrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:300: ptrCne: bool(1)
cmplStd/test/lang/stmt.if.ci:26: t: int32(0)
cmplStd/test/lang/stmt.for.ci:12: forIdx: int32(2)
cmplStd/test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
cmplStd/test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
cmplStd/test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
cmplStd/test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
cmplStd/test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
cmplStd/test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
cmplStd/test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
cmplStd/test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
cmplStd/test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
cmplStd/test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
cmplStd/test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
cmplStd/test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
cmplStd/test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
cmplStd/test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
cmplStd/test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
cmplStd/test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
cmplStd/test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
cmplStd/test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
cmplStd/test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
cmplStd/test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
cmplStd/test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
cmplStd/test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
cmplStd/test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
cmplStd/test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
cmplStd/test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
cmplStd/test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
cmplStd/test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
cmplStd/test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
cmplStd/test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
cmplStd/test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
cmplStd/test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
cmplStd/test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
cmplStd/test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
cmplStd/test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
cmplStd/test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
cmplStd/test/std/test.math.ci:67: testMathCmp_f32: bool(1)
cmplStd/test/std/test.math.ci:68: testMathCmp_f64: bool(1)
cmplStd/test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
cmplStd/test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
cmplStd/test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
cmplStd/test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
cmplStd/test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
cmplStd/test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
cmplStd/test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
cmplStd/test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
cmplStd/test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
cmplStd/test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
cmplStd/test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
cmplStd/test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
cmplStd/test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
cmplStd/test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
cmplStd/test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
cmplStd/test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
cmplStd/test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
cmplStd/test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
cmplStd/test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
cmplStd/test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
cmplStd/test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
cmplStd/test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194016(4.0 Mb)
memory[used] @000000; size: 422870(413.0 Kb)
memory[heap] @0673d6; size: 2722594(2.6 Mb)
memory[stack] @1fff40; size: 1048504(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 397432(388.1 Kb)
memory[code] @000000; size: 20275(19.8 Kb)
memory[data] @000000; size: 2698(2.6 Kb)

---------- heap memory:
memory[free] @0673f0; size: 2144(2.1 Kb)
memory[used] @067c60; size: 32(32.0 bytes)
memory[used] @067c90; size: 32(32.0 bytes)
memory[free] @067cc0; size: 2720288(2.6 Mb)

---------- Profile functions: 74/113, coverage: 65.49%
::[.005ed8, .005ed8): exec(2), time(0.010 ms): halt(): void
::[.006198, .006198): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006500, .006500): exec(3), time(0.045 ms): typename.base(type: typename): typename
::[.006718, .006718): exec(2), time(0.028 ms): typename.file(type: typename): .cstr
::[.006930, .006930): exec(2), time(0.029 ms): typename.line(type: typename): int32
::[.006b48, .006b48): exec(2), time(0.033 ms): typename.name(type: typename): .cstr
::[.006e08, .006e08): exec(2), time(0.030 ms): object.create(type: typename): pointer
::[.0070c0, .0070c0): exec(0), time(0.000 ms): object.as(this: object, type: typename): pointer
::[.0078e0, .0078e0): exec(37), time(0.899 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.008230, .008230): exec(7), time(1.898 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.0084f0, .0084f0): exec(8), time(0.093 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.008850, .008850): exec(2), time(0.025 ms): pointer.fill(dst: pointer, value: uint8, size: int32): pointer
::[.008bb0, .008bb0): exec(1), time(0.012 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008f08, .008f08): exec(1), time(0.012 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0091d0, .0091d0): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0093f0, .0093f0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.009568, .009568): exec(0), time(0.000 ms): System.rand(): int32
::[.0096e0, .0096e0): exec(0), time(0.000 ms): System.time(): int32
::[.009858, .009858): exec(0), time(0.000 ms): System.clock(): int32
::[.0099d0, .0099d0): exec(0), time(0.000 ms): System.millis(): int64
::[.009be8, .009be8): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.009f48, .009f48): exec(7), time(0.076 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.00a2a0, .00a2a0): exec(7), time(0.075 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.00a4b8, .00a4b8): exec(1), time(0.011 ms): uint32.pop(value: int32): int32
::[.00a6d0, .00a6d0): exec(1), time(0.010 ms): uint32.swap(value: int32): int32
::[.00a8e8, .00a8e8): exec(1), time(0.011 ms): uint32.bsr(value: int32): int32
::[.00ab00, .00ab00): exec(1), time(0.011 ms): uint32.bsf(value: int32): int32
::[.00ad18, .00ad18): exec(1), time(0.010 ms): uint32.hib(value: int32): int32
::[.00af30, .00af30): exec(1), time(0.011 ms): uint32.lob(value: int32): int32
::[.00b280, .00b280): exec(1), time(0.011 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00b5d0, .00b5d0): exec(1), time(0.011 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00b7e8, .00b7e8): exec(2), time(0.028 ms): float32.sin(x: float32): float32
::[.00ba00, .00ba00): exec(1), time(0.011 ms): float32.cos(x: float32): float32
::[.00bc18, .00bc18): exec(1), time(0.011 ms): float32.tan(x: float32): float32
::[.00be30, .00be30): exec(1), time(0.011 ms): float32.log(x: float32): float32
::[.00c048, .00c048): exec(1), time(0.011 ms): float32.exp(x: float32): float32
::[.00c300, .00c300): exec(1), time(0.011 ms): float32.pow(x: float32, y: float32): float32
::[.00c518, .00c518): exec(1), time(0.011 ms): float32.sqrt(x: float32): float32
::[.00c7d0, .00c7d0): exec(1), time(0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00c9e0, .00c9e0): exec(1), time(0.014 ms): float64.sin(x: float64): float64
::[.00cbf0, .00cbf0): exec(1), time(0.012 ms): float64.cos(x: float64): float64
::[.00ce00, .00ce00): exec(1), time(0.011 ms): float64.tan(x: float64): float64
::[.00d010, .00d010): exec(1), time(0.013 ms): float64.log(x: float64): float64
::[.00d220, .00d220): exec(5), time(0.052 ms): float64.exp(x: float64): float64
::[.00d4d0, .00d4d0): exec(1), time(0.011 ms): float64.pow(x: float64, y: float64): float64
::[.00d6e0, .00d6e0): exec(3), time(0.029 ms): float64.sqrt(x: float64): float64
::[.00d990, .00d990): exec(3), time(0.033 ms): float64.atan2(x: float64, y: float64): float64
cmplStd/lib/debug.ci:61:[.061078, .0610df): exec(8), time(0.056 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
cmplStd/lib/math.ci:22:[.0610e0, .061136): exec(10), time(0.061 ms): Math.modf(x: float64, intPart: float64): float64
cmplStd/lib/math.ci:47:[.061138, .061150): exec(6), time(0.111-0.056 ms): Math.floor(x: float64): float64
cmplStd/lib/math.ci:77:[.061150, .06116b): exec(11), time(0.066 ms): Math.absMod(val: float32, mod: float32): float32
cmplStd/lib/math.ci:85:[.061170, .06118b): exec(11), time(0.069 ms): Math.absMod(val: float64, mod: float64): float64
cmplStd/lib/math.ci:147:[.061190, .0611ae): exec(2), time(0.014 ms): Math.clamp(t: float32, a: float32, b: float32): float32
cmplStd/lib/math.ci:158:[.0611b0, .0611ce): exec(2), time(0.014 ms): Math.clamp(t: float64, a: float64, b: float64): float64
cmplStd/lib/math.ci:189:[.0611d0, .06121f): exec(2), time(0.027 ms): Math.min(data: float64[]): float64
cmplStd/lib/math.ci:203:[.061220, .06126f): exec(2), time(0.029 ms): Math.max(data: float64[]): float64
cmplStd/lib/math.ci:217:[.061270, .061298): exec(4), time(0.051 ms): Math.sum(data: float64[]): float64
cmplStd/lib/math.ci:226:[.061298, .0612ac): exec(0), time(0.000 ms): Math.mean(data: float64[]): float64
cmplStd/lib/math.ci:243:[.0612b0, .0612df): exec(3), time(0.043 ms): Math.eval(x: float64, polynomial: float64[]): float64
cmplStd/lib/math.ci:252:[.0612e0, .061319): exec(1), time(0.007 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
cmplStd/lib/math.ci:267:[.061320, .061359): exec(1), time(0.007 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
cmplStd/lib/math.ci:282:[.061360, .0614af): exec(2), time(0.036 ms): Math.sinCos(arg: float64, quad: int32): float64
cmplStd/lib/math.ci:339:[.0614b0, .06162a): exec(1), time(0.029-0.005 ms): Math.tan(arg: float64): float64
cmplStd/lib/math.ci:396:[.061630, .061721): exec(1), time(0.040-0.021 ms): Math.sinh(x: float64): float64
cmplStd/lib/math.ci:435:[.061728, .061773): exec(1), time(0.035-0.020 ms): Math.cosh(x: float64): float64
cmplStd/lib/math.ci:450:[.061778, .061825): exec(2), time(0.080-0.039 ms): Math.asin(x: float64): float64
cmplStd/lib/math/Complex.ci:24:[.061828, .06182f): exec(0), time(0.000 ms): Complex(re: float64): Complex
cmplStd/lib/math/Complex.ci:31:[.061830, .061837): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
cmplStd/lib/math/Complex.ci:86:[.061838, .0618c3): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
cmplStd/lib/math/Complex.ci:117:[.0618c8, .0618e7): exec(0), time(0.000 ms): inv(a: Complex): Complex
cmplStd/lib/math/Complex.ci:135:[.0618e8, .06194c): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
cmplStd/lib/math/Matrix4f.ci:62:[.061950, .061981): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:75:[.061988, .06199d): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
cmplStd/lib/math/Matrix4f.ci:87:[.0619a0, .0619d1): exec(0), time(0.000 ms): transpose(mat: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:97:[.0619d8, .061acd): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:111:[.061ad0, .061c96): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:163:[.061c98, .061cf0): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:173:[.061cf0, .061dc9): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Vector2d.ci:14:[.061dd0, .061dd7): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
cmplStd/lib/string.ci:4:[.061dd8, .061dfe): exec(0), time(0.000 ms): length(str: char[*]): int32
cmplStd/lib/string.ci:15:[.061e00, .061e32): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
cmplStd/lib/string.ci:25:[.061e38, .061e6a): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
cmplStd/lib/string.ci:36:[.061e70, .061eb9): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/string.ci:46:[.061ec0, .061f3e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/string.ci:61:[.061f40, .061f7f): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
cmplStd/lib/string.ci:74:[.061f80, .061fc7): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
cmplStd/lib/string.ci:73:[.061fc8, .061fec): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
cmplStd/lib/string.ci:88:[.061ff0, .061ffe): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
cmplStd/lib/string.ci:127:[.062000, .062054): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
cmplStd/lib/string.ci:144:[.062068, .06232b): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
cmplStd/lib/string.ci:234:[.062330, .06241c): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
cmplStd/lib/string.ci:262:[.062430, .06246f): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
cmplStd/test/std/tryExec.ci:11:[.062820, .062821): exec(1), time(0.010 ms): noError(ptr: pointer): void
cmplStd/test/std/tryExec.ci:14:[.062828, .062840): exec(128-128), time(1.686 ms): stackOverflow(ptr: pointer): void
cmplStd/test/std/tryExec.ci:20:[.062840, .06284c): exec(1-1), time(0.009 ms): divisionByZero(args: pointer): void
cmplStd/test/std/tryExec.ci:24:[.062850, .062894): exec(1-1), time(0.083-0.064 ms): abortExecution(args: pointer): void
cmplStd/test/std/tryExec.ci:38:[.062898, .0628a5): exec(1-1), time(0.010 ms): invalidMemoryAccess(args: pointer): void
cmplStd/test/std/tryExec.ci:43:[.0628a8, .0628aa): exec(1-1), time(0.009 ms): invalidInstruction(args: pointer): void
cmplStd/test/lang/function.ci:4:[.062ba8, .062ba9): exec(0), time(0.000 ms): empty(): void
cmplStd/test/lang/function.ci:7:[.062bb0, .062bb8): exec(2), time(0.021 ms): funAdd(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:33:[.062bf0, .062bf8): exec(2), time(0.020 ms): funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:38:[.062bf8, .062c2e): exec(753), time(12.075 ms): fib(n: uint32): uint32
cmplStd/test/lang/init.method.ci:10:[.062da8, .062dcf): exec(3), time(0.232-0.182 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:40:[.062dd8, .062dff): exec(4), time(0.301-0.234 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47:[.062e00, .062e27): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:57:[.062e28, .062e4f): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:84:[.062e60, .062ea2): exec(1), time(0.120-0.095 ms): staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:90:[.062ea8, .062ee7): exec(1), time(0.120-0.093 ms): virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.array.ci:51:[.062f70, .062f74): exec(5), time(0.054 ms): lenSlice(values: int64[]): int32
cmplStd/test/lang/init.array.ci:52:[.062f78, .062f84): exec(21), time(0.271 ms): nthFixed(idx: int32, values: int64[7]): int64
cmplStd/test/lang/init.array.ci:53:[.062f88, .062f94): exec(21), time(0.268 ms): nthArray(idx: int32, values: int64[*]): int64
cmplStd/test/lang/init.array.ci:54:[.062f98, .062fa4): exec(14), time(0.181 ms): nthSlice(idx: int32, values: int64[]): int64
::[.0639ec, .0673d6): exec(1), time(22.120-17.260 ms): .main

---------- Profile statements: 879/1237, coverage: 71.06%
cmplStd/lib/debug.ci:63:[.061081, .061082) exec(8), time(0.025-0.025 ms): <assertEq+9>
cmplStd/lib/debug.ci:62:[.061078, .061082) exec(8-8), time(0.000 ms): <assertEq+0>
cmplStd/lib/debug.ci:65:[.061086, .06108f) exec(0), time(0.000 ms): <assertEq+14>
cmplStd/lib/debug.ci:65:[.061082, .06108f) exec(0), time(0.000 ms): <assertEq+10>
cmplStd/lib/debug.ci:67:[.061093, .06109e) exec(0), time(0.000 ms): <assertEq+27>
cmplStd/lib/debug.ci:68:[.06109e, .0610a9) exec(0), time(0.000 ms): <assertEq+38>
cmplStd/lib/debug.ci:69:[.0610a9, .0610b4) exec(0), time(0.000 ms): <assertEq+49>
cmplStd/lib/debug.ci:66:[.06108f, .0610b4) exec(0), time(0.000 ms): <assertEq+23>
cmplStd/lib/debug.ci:71:[.0610b4, .0610da) exec(0), time(0.000 ms): <assertEq+60>
cmplStd/lib/math.ci:25:[.0610f8, .061109) exec(3), time(0.025-0.025 ms): <modf+24>
cmplStd/lib/math.ci:26:[.061109, .061110) exec(3), time(0.000 ms): <modf+41>
cmplStd/lib/math.ci:27:[.061110, .061113) exec(3), time(0.009-0.009 ms): <modf+48>
cmplStd/lib/math.ci:24:[.0610f0, .061117) exec(3-3), time(0.000 ms): <modf+16>
cmplStd/lib/math.ci:29:[.061117, .06111b) exec(0), time(0.000 ms): <modf+55>
cmplStd/lib/math.ci:30:[.06111b, .06111f) exec(0), time(0.000 ms): <modf+59>
cmplStd/lib/math.ci:23:[.0610e0, .06111f) exec(10-3), time(0.000 ms): <modf+0>
cmplStd/lib/math.ci:32:[.06111f, .06112b) exec(7), time(0.005-0.005 ms): <modf+63>
cmplStd/lib/math.ci:33:[.06112b, .061133) exec(7), time(0.000 ms): <modf+75>
cmplStd/lib/math.ci:34:[.061133, .061136) exec(7), time(0.021-0.021 ms): <modf+83>
cmplStd/lib/math.ci:48:[.061138, .061139) exec(6), time(0.000 ms): <floor+0>
cmplStd/lib/math.ci:49:[.061139, .06114d) exec(6), time(0.076-0.076 ms): <floor+1>
cmplStd/lib/math.ci:50:[.06114d, .061150) exec(6), time(0.017-0.017 ms): <floor+21>
cmplStd/lib/math.ci:79:[.06115f, .061167) exec(4), time(0.015-0.015 ms): <absMod+15>
cmplStd/lib/math.ci:78:[.061150, .061167) exec(11-4), time(0.001-0.001 ms): <absMod+0>
cmplStd/lib/math.ci:81:[.061167, .06116b) exec(7), time(0.025-0.025 ms): <absMod+23>
cmplStd/lib/math.ci:87:[.06117f, .061187) exec(4), time(0.014-0.014 ms): <absMod+15>
cmplStd/lib/math.ci:86:[.061170, .061187) exec(11-4), time(0.002-0.002 ms): <absMod+0>
cmplStd/lib/math.ci:89:[.061187, .06118b) exec(7), time(0.024-0.024 ms): <absMod+23>
cmplStd/lib/math.ci:149:[.061199, .06119d) exec(0), time(0.000 ms): <clamp+9>
cmplStd/lib/math.ci:148:[.061190, .06119d) exec(2), time(0.000 ms): <clamp+0>
cmplStd/lib/math.ci:152:[.0611a6, .0611aa) exec(1), time(0.003-0.003 ms): <clamp+22>
cmplStd/lib/math.ci:151:[.06119d, .0611aa) exec(2-1), time(0.000 ms): <clamp+13>
cmplStd/lib/math.ci:154:[.0611aa, .0611ae) exec(1), time(0.004-0.004 ms): <clamp+26>
cmplStd/lib/math.ci:160:[.0611b9, .0611bd) exec(0), time(0.000 ms): <clamp+9>
cmplStd/lib/math.ci:159:[.0611b0, .0611bd) exec(2), time(0.000 ms): <clamp+0>
cmplStd/lib/math.ci:163:[.0611c6, .0611ca) exec(1), time(0.003-0.003 ms): <clamp+22>
cmplStd/lib/math.ci:162:[.0611bd, .0611ca) exec(2-1), time(0.001-0.001 ms): <clamp+13>
cmplStd/lib/math.ci:165:[.0611ca, .0611ce) exec(1), time(0.003-0.003 ms): <clamp+26>
cmplStd/lib/math.ci:191:[.0611d8, .0611e4) exec(1), time(0.003-0.003 ms): <min+8>
cmplStd/lib/math.ci:190:[.0611d0, .0611e4) exec(2-1), time(0.000 ms): <min+0>
cmplStd/lib/math.ci:193:[.0611e4, .0611e7) exec(1), time(0.001-0.001 ms): <min+20>
cmplStd/lib/math.ci:196:[.061200, .06120b) exec(2), time(0.000 ms): <min+48>
cmplStd/lib/math.ci:195:[.0611f0, .06120b) exec(8-2), time(0.004-0.004 ms): <min+32>
cmplStd/lib/math.ci:194:[.06120b, .06120f) exec(8), time(0.002-0.002 ms): <min+59>
cmplStd/lib/math.ci:194:[.06120f, .061218) exec(9), time(0.002-0.002 ms): <min+63>
cmplStd/lib/math.ci:194:[.0611e7, .06121c) exec(1), time(0.001-0.001 ms): <min+23>
cmplStd/lib/math.ci:199:[.06121c, .06121f) exec(1), time(0.003-0.003 ms): <min+76>
cmplStd/lib/math.ci:205:[.061228, .061234) exec(1), time(0.004-0.004 ms): <max+8>
cmplStd/lib/math.ci:204:[.061220, .061234) exec(2-1), time(0.001-0.001 ms): <max+0>
cmplStd/lib/math.ci:207:[.061234, .061237) exec(1), time(0.000 ms): <max+20>
cmplStd/lib/math.ci:210:[.061250, .06125b) exec(2), time(0.000 ms): <max+48>
cmplStd/lib/math.ci:209:[.061240, .06125b) exec(8-2), time(0.003-0.003 ms): <max+32>
cmplStd/lib/math.ci:208:[.06125b, .06125f) exec(8), time(0.003-0.003 ms): <max+59>
cmplStd/lib/math.ci:208:[.06125f, .061268) exec(9), time(0.001-0.001 ms): <max+63>
cmplStd/lib/math.ci:208:[.061237, .06126c) exec(1), time(0.000 ms): <max+23>
cmplStd/lib/math.ci:213:[.06126c, .06126f) exec(1), time(0.004-0.004 ms): <max+76>
cmplStd/lib/math.ci:218:[.061270, .061271) exec(4), time(0.000 ms): <sum+0>
cmplStd/lib/math.ci:220:[.061276, .061284) exec(13), time(0.007-0.007 ms): <sum+6>
cmplStd/lib/math.ci:219:[.061284, .061288) exec(13), time(0.001-0.001 ms): <sum+20>
cmplStd/lib/math.ci:219:[.061288, .061291) exec(17), time(0.007-0.007 ms): <sum+24>
cmplStd/lib/math.ci:219:[.061271, .061295) exec(4), time(0.003-0.003 ms): <sum+1>
cmplStd/lib/math.ci:222:[.061295, .061298) exec(4), time(0.016-0.016 ms): <sum+37>
cmplStd/lib/math.ci:227:[.061298, .0612ac) exec(0), time(0.000 ms): <mean+0>
cmplStd/lib/math.ci:244:[.0612b0, .0612b1) exec(3), time(0.000 ms): <eval+0>
cmplStd/lib/math.ci:246:[.0612bb, .0612cc) exec(11), time(0.009-0.009 ms): <eval+11>
cmplStd/lib/math.ci:245:[.0612cc, .0612d0) exec(11), time(0.001-0.001 ms): <eval+28>
cmplStd/lib/math.ci:245:[.0612d0, .0612d8) exec(14), time(0.006-0.006 ms): <eval+32>
cmplStd/lib/math.ci:245:[.0612b1, .0612dc) exec(3), time(0.002-0.002 ms): <eval+1>
cmplStd/lib/math.ci:248:[.0612dc, .0612df) exec(3), time(0.011-0.011 ms): <eval+44>
cmplStd/lib/math.ci:255:[.0612f5, .0612fd) exec(0), time(0.000 ms): <cmp+21>
cmplStd/lib/math.ci:254:[.0612e9, .0612fd) exec(1), time(0.001-0.001 ms): <cmp+9>
cmplStd/lib/math.ci:260:[.06130d, .061315) exec(0), time(0.000 ms): <cmp+45>
cmplStd/lib/math.ci:259:[.061301, .061315) exec(0), time(0.000 ms): <cmp+33>
cmplStd/lib/math.ci:253:[.0612e0, .061315) exec(1), time(0.001-0.001 ms): <cmp+0>
cmplStd/lib/math.ci:263:[.061315, .061319) exec(1), time(0.003-0.003 ms): <cmp+53>
cmplStd/lib/math.ci:270:[.061335, .06133d) exec(0), time(0.000 ms): <cmp+21>
cmplStd/lib/math.ci:269:[.061329, .06133d) exec(1), time(0.001-0.001 ms): <cmp+9>
cmplStd/lib/math.ci:275:[.06134d, .061355) exec(0), time(0.000 ms): <cmp+45>
cmplStd/lib/math.ci:274:[.061341, .061355) exec(0), time(0.000 ms): <cmp+33>
cmplStd/lib/math.ci:268:[.061320, .061355) exec(1), time(0.001-0.001 ms): <cmp+0>
cmplStd/lib/math.ci:278:[.061355, .061359) exec(1), time(0.003-0.003 ms): <cmp+53>
cmplStd/lib/math.ci:296:[.061360, .061362) exec(2), time(0.002-0.002 ms): <sinCos+0>
cmplStd/lib/math.ci:298:[.06136a, .06136b) exec(0), time(0.000 ms): <sinCos+10>
cmplStd/lib/math.ci:299:[.06136b, .061373) exec(0), time(0.000 ms): <sinCos+11>
cmplStd/lib/math.ci:297:[.061362, .061373) exec(2), time(0.000 ms): <sinCos+2>
cmplStd/lib/math.ci:302:[.061373, .061374) exec(2), time(0.001-0.001 ms): <sinCos+19>
cmplStd/lib/math.ci:303:[.061374, .06138c) exec(2), time(0.001-0.001 ms): <sinCos+20>
cmplStd/lib/math.ci:305:[.06139c, .06139d) exec(0), time(0.000 ms): <sinCos+60>
cmplStd/lib/math.ci:306:[.06139d, .0613af) exec(0), time(0.000 ms): <sinCos+61>
cmplStd/lib/math.ci:307:[.0613af, .0613b3) exec(0), time(0.000 ms): <sinCos+79>
cmplStd/lib/math.ci:309:[.0613b3, .0613b4) exec(0), time(0.000 ms): <sinCos+83>
cmplStd/lib/math.ci:310:[.0613b4, .0613d2) exec(0), time(0.000 ms): <sinCos+84>
cmplStd/lib/math.ci:311:[.0613d2, .0613e4) exec(0), time(0.000 ms): <sinCos+114>
cmplStd/lib/math.ci:314:[.0613ec, .0613ef) exec(2), time(0.002-0.002 ms): <sinCos+140>
cmplStd/lib/math.ci:315:[.0613ef, .0613f7) exec(2), time(0.000 ms): <sinCos+143>
cmplStd/lib/math.ci:316:[.0613f7, .0613fe) exec(2), time(0.002-0.002 ms): <sinCos+151>
cmplStd/lib/math.ci:317:[.0613fe, .061404) exec(2), time(0.001-0.001 ms): <sinCos+158>
cmplStd/lib/math.ci:304:[.06138c, .061408) exec(2), time(0.002-0.002 ms): <sinCos+44>
cmplStd/lib/math.ci:320:[.061410, .06141e) exec(1), time(0.001-0.001 ms): <sinCos+176>
cmplStd/lib/math.ci:319:[.061408, .06141e) exec(2-1), time(0.000 ms): <sinCos+168>
cmplStd/lib/math.ci:323:[.06142a, .06142b) exec(1), time(0.000 ms): <sinCos+202>
cmplStd/lib/math.ci:322:[.06141e, .06142b) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
cmplStd/lib/math.ci:326:[.06142b, .061430) exec(2), time(0.000 ms): <sinCos+203>
cmplStd/lib/math.ci:327:[.061430, .061470) exec(2), time(0.004-0.004 ms): <sinCos+208>
cmplStd/lib/math.ci:328:[.061470, .0614a3) exec(2), time(0.003-0.003 ms): <sinCos+272>
cmplStd/lib/math.ci:329:[.0614a3, .0614af) exec(2), time(0.008-0.008 ms): <sinCos+323>
cmplStd/lib/math.ci:352:[.0614b0, .0614b1) exec(1), time(0.000 ms): <tan+0>
cmplStd/lib/math.ci:353:[.0614b1, .0614b2) exec(1), time(0.000 ms): <tan+1>
cmplStd/lib/math.ci:356:[.0614ba, .0614bf) exec(0), time(0.000 ms): <tan+10>
cmplStd/lib/math.ci:357:[.0614bf, .0614c9) exec(0), time(0.000 ms): <tan+15>
cmplStd/lib/math.ci:355:[.0614b2, .0614c9) exec(1), time(0.000 ms): <tan+2>
cmplStd/lib/math.ci:359:[.0614c9, .0614e1) exec(1), time(0.001-0.001 ms): <tan+25>
cmplStd/lib/math.ci:361:[.0614e1, .0614e2) exec(1), time(0.001-0.001 ms): <tan+49>
cmplStd/lib/math.ci:362:[.0614e2, .0614f2) exec(1), time(0.009-0.009 ms): <tan+50>
cmplStd/lib/math.ci:363:[.0614f2, .0614fb) exec(1), time(0.000 ms): <tan+66>
cmplStd/lib/math.ci:367:[.06150f, .06151d) exec(1), time(0.000 ms): <tan+95>
cmplStd/lib/math.ci:368:[.06151d, .061527) exec(1), time(0.000 ms): <tan+109>
cmplStd/lib/math.ci:371:[.061537, .061542) exec(0), time(0.000 ms): <tan+135>
cmplStd/lib/math.ci:372:[.061542, .06154c) exec(0), time(0.000 ms): <tan+146>
cmplStd/lib/math.ci:375:[.06155c, .06156a) exec(0), time(0.000 ms): <tan+172>
cmplStd/lib/math.ci:376:[.06156a, .061575) exec(0), time(0.000 ms): <tan+186>
cmplStd/lib/math.ci:374:[.061550, .061575) exec(0), time(0.000 ms): <tan+160>
cmplStd/lib/math.ci:370:[.06152b, .061575) exec(0), time(0.000 ms): <tan+123>
cmplStd/lib/math.ci:366:[.061503, .061575) exec(1), time(0.000 ms): <tan+83>
cmplStd/lib/math.ci:365:[.0614fb, .061575) exec(1-1), time(0.000 ms): <tan+75>
cmplStd/lib/math.ci:379:[.061575, .06157a) exec(1), time(0.000 ms): <tan+197>
cmplStd/lib/math.ci:380:[.06157a, .0615ba) exec(1), time(0.002-0.002 ms): <tan+202>
cmplStd/lib/math.ci:381:[.0615ba, .0615e1) exec(1), time(0.001-0.001 ms): <tan+266>
cmplStd/lib/math.ci:385:[.0615f2, .061602) exec(0), time(0.000 ms): <tan+322>
cmplStd/lib/math.ci:384:[.0615ea, .061602) exec(1), time(0.000 ms): <tan+314>
cmplStd/lib/math.ci:387:[.061602, .061610) exec(1), time(0.000 ms): <tan+338>
cmplStd/lib/math.ci:383:[.0615e1, .061610) exec(1-1), time(0.000 ms): <tan+305>
cmplStd/lib/math.ci:390:[.061619, .061623) exec(0), time(0.000 ms): <tan+361>
cmplStd/lib/math.ci:389:[.061610, .061623) exec(1), time(0.000 ms): <tan+352>
cmplStd/lib/math.ci:392:[.061623, .06162a) exec(1), time(0.004-0.004 ms): <tan+371>
cmplStd/lib/math.ci:408:[.061630, .061631) exec(1), time(0.000 ms): <sinh+0>
cmplStd/lib/math.ci:410:[.061639, .06163e) exec(0), time(0.000 ms): <sinh+9>
cmplStd/lib/math.ci:411:[.06163e, .061648) exec(0), time(0.000 ms): <sinh+14>
cmplStd/lib/math.ci:409:[.061631, .061648) exec(1), time(0.001-0.001 ms): <sinh+1>
cmplStd/lib/math.ci:415:[.061658, .06166f) exec(0), time(0.000 ms): <sinh+40>
cmplStd/lib/math.ci:414:[.061648, .06166f) exec(1), time(0.001-0.001 ms): <sinh+24>
cmplStd/lib/math.ci:418:[.06166f, .061670) exec(1), time(0.000 ms): <sinh+63>
cmplStd/lib/math.ci:420:[.061680, .06169a) exec(1), time(0.030-0.030 ms): <sinh+80>
cmplStd/lib/math.ci:423:[.06169e, .0616a3) exec(0), time(0.000 ms): <sinh+110>
cmplStd/lib/math.ci:424:[.0616a3, .0616d8) exec(0), time(0.000 ms): <sinh+115>
cmplStd/lib/math.ci:425:[.0616d8, .061703) exec(0), time(0.000 ms): <sinh+168>
cmplStd/lib/math.ci:419:[.061670, .061707) exec(1), time(0.030-0.030 ms): <sinh+64>
cmplStd/lib/math.ci:429:[.061710, .06171a) exec(0), time(0.000 ms): <sinh+224>
cmplStd/lib/math.ci:428:[.061707, .06171a) exec(1), time(0.000 ms): <sinh+215>
cmplStd/lib/math.ci:431:[.06171a, .061721) exec(1), time(0.004-0.004 ms): <sinh+234>
cmplStd/lib/math.ci:437:[.061730, .061735) exec(0), time(0.000 ms): <cosh+8>
cmplStd/lib/math.ci:436:[.061728, .061735) exec(1), time(0.000 ms): <cosh+0>
cmplStd/lib/math.ci:440:[.061745, .061758) exec(0), time(0.000 ms): <cosh+29>
cmplStd/lib/math.ci:439:[.061735, .061758) exec(1), time(0.000 ms): <cosh+13>
cmplStd/lib/math.ci:442:[.061758, .061773) exec(1), time(0.030-0.030 ms): <cosh+48>
cmplStd/lib/math.ci:453:[.061780, .061784) exec(0), time(0.000 ms): <asin+8>
cmplStd/lib/math.ci:451:[.061778, .061784) exec(2), time(0.001-0.001 ms): <asin+0>
cmplStd/lib/math.ci:456:[.061784, .061785) exec(2), time(0.000 ms): <asin+12>
cmplStd/lib/math.ci:458:[.06178d, .061797) exec(0), time(0.000 ms): <asin+21>
cmplStd/lib/math.ci:459:[.061797, .06179c) exec(0), time(0.000 ms): <asin+31>
cmplStd/lib/math.ci:457:[.061785, .06179c) exec(2), time(0.002-0.002 ms): <asin+13>
cmplStd/lib/math.ci:464:[.0617ac, .0617bc) exec(0), time(0.000 ms): <asin+52>
cmplStd/lib/math.ci:462:[.06179c, .0617bc) exec(2), time(0.002-0.002 ms): <asin+36>
cmplStd/lib/math.ci:467:[.0617bc, .0617cf) exec(2), time(0.028-0.028 ms): <asin+68>
cmplStd/lib/math.ci:469:[.0617df, .0617fd) exec(0), time(0.000 ms): <asin+103>
cmplStd/lib/math.ci:472:[.061801, .06180b) exec(2), time(0.029-0.029 ms): <asin+137>
cmplStd/lib/math.ci:468:[.0617cf, .06180b) exec(2-2), time(0.000 ms): <asin+87>
cmplStd/lib/math.ci:476:[.061814, .06181e) exec(0), time(0.000 ms): <asin+156>
cmplStd/lib/math.ci:475:[.06180b, .06181e) exec(2), time(0.001-0.001 ms): <asin+147>
cmplStd/lib/math.ci:478:[.06181e, .061825) exec(2), time(0.007-0.007 ms): <asin+166>
cmplStd/lib/math/Complex.ci:26:[.061828, .06182b) exec(0), time(0.000 ms): <Complex+0>
::[.06182b, .06182e) exec(0), time(0.000 ms): <Complex+3>
cmplStd/lib/math/Complex.ci:25:[.061828, .06182f) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:33:[.061830, .061833) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:34:[.061833, .061836) exec(0), time(0.000 ms): <Complex+3>
cmplStd/lib/math/Complex.ci:32:[.061830, .061837) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:91:[.061867, .06186c) exec(0), time(0.000 ms): <div+47>
cmplStd/lib/math/Complex.ci:92:[.06186c, .061874) exec(0), time(0.000 ms): <div+52>
cmplStd/lib/math/Complex.ci:94:[.061874, .061881) exec(0), time(0.000 ms): <div+60>
cmplStd/lib/math/Complex.ci:95:[.061881, .06188e) exec(0), time(0.000 ms): <div+73>
cmplStd/lib/math/Complex.ci:93:[.061874, .061893) exec(0), time(0.000 ms): <div+60>
cmplStd/lib/math/Complex.ci:90:[.061838, .061897) exec(0), time(0.000 ms): <div+0>
cmplStd/lib/math/Complex.ci:98:[.061897, .06189c) exec(0), time(0.000 ms): <div+95>
cmplStd/lib/math/Complex.ci:99:[.06189c, .0618a4) exec(0), time(0.000 ms): <div+100>
cmplStd/lib/math/Complex.ci:101:[.0618a4, .0618b1) exec(0), time(0.000 ms): <div+108>
cmplStd/lib/math/Complex.ci:102:[.0618b1, .0618be) exec(0), time(0.000 ms): <div+121>
cmplStd/lib/math/Complex.ci:100:[.0618a4, .0618c3) exec(0), time(0.000 ms): <div+108>
cmplStd/lib/math/Complex.ci:118:[.0618c8, .0618d3) exec(0), time(0.000 ms): <inv+0>
cmplStd/lib/math/Complex.ci:120:[.0618d3, .0618da) exec(0), time(0.000 ms): <inv+11>
cmplStd/lib/math/Complex.ci:121:[.0618da, .0618e2) exec(0), time(0.000 ms): <inv+18>
cmplStd/lib/math/Complex.ci:119:[.0618d3, .0618e7) exec(0), time(0.000 ms): <inv+11>
cmplStd/lib/math/Complex.ci:136:[.0618e8, .0618ff) exec(0), time(0.000 ms): <pow+0>
cmplStd/lib/math/Complex.ci:137:[.0618ff, .06190f) exec(0), time(0.000 ms): <pow+23>
cmplStd/lib/math/Complex.ci:138:[.06190f, .06191e) exec(0), time(0.000 ms): <pow+39>
cmplStd/lib/math/Complex.ci:139:[.06191e, .061931) exec(0), time(0.000 ms): <pow+54>
cmplStd/lib/math/Complex.ci:141:[.061931, .06193c) exec(0), time(0.000 ms): <pow+73>
cmplStd/lib/math/Complex.ci:142:[.06193c, .061947) exec(0), time(0.000 ms): <pow+84>
cmplStd/lib/math/Complex.ci:140:[.061931, .06194c) exec(0), time(0.000 ms): <pow+73>
cmplStd/lib/math/Matrix4f.ci:67:[.061950, .061953) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:67:[.061953, .061956) exec(0), time(0.000 ms): <mat4f+3>
cmplStd/lib/math/Matrix4f.ci:67:[.061956, .061959) exec(0), time(0.000 ms): <mat4f+6>
cmplStd/lib/math/Matrix4f.ci:67:[.061959, .06195c) exec(0), time(0.000 ms): <mat4f+9>
cmplStd/lib/math/Matrix4f.ci:68:[.06195c, .06195f) exec(0), time(0.000 ms): <mat4f+12>
cmplStd/lib/math/Matrix4f.ci:68:[.06195f, .061962) exec(0), time(0.000 ms): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:68:[.061962, .061965) exec(0), time(0.000 ms): <mat4f+18>
cmplStd/lib/math/Matrix4f.ci:68:[.061965, .061968) exec(0), time(0.000 ms): <mat4f+21>
cmplStd/lib/math/Matrix4f.ci:69:[.061968, .06196b) exec(0), time(0.000 ms): <mat4f+24>
cmplStd/lib/math/Matrix4f.ci:69:[.06196b, .06196e) exec(0), time(0.000 ms): <mat4f+27>
cmplStd/lib/math/Matrix4f.ci:69:[.06196e, .061971) exec(0), time(0.000 ms): <mat4f+30>
cmplStd/lib/math/Matrix4f.ci:69:[.061971, .061974) exec(0), time(0.000 ms): <mat4f+33>
cmplStd/lib/math/Matrix4f.ci:70:[.061974, .061977) exec(0), time(0.000 ms): <mat4f+36>
cmplStd/lib/math/Matrix4f.ci:70:[.061977, .06197a) exec(0), time(0.000 ms): <mat4f+39>
cmplStd/lib/math/Matrix4f.ci:70:[.06197a, .06197d) exec(0), time(0.000 ms): <mat4f+42>
cmplStd/lib/math/Matrix4f.ci:70:[.06197d, .061980) exec(0), time(0.000 ms): <mat4f+45>
cmplStd/lib/math/Matrix4f.ci:66:[.061950, .061981) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.061988, .06198d) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.06198d, .061992) exec(0), time(0.000 ms): <mat4f+5>
cmplStd/lib/math/Matrix4f.ci:76:[.061992, .061997) exec(0), time(0.000 ms): <mat4f+10>
cmplStd/lib/math/Matrix4f.ci:76:[.061997, .06199c) exec(0), time(0.000 ms): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:76:[.061988, .06199d) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:89:[.0619a0, .0619a3) exec(0), time(0.000 ms): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:89:[.0619a3, .0619a6) exec(0), time(0.000 ms): <transpose+3>
cmplStd/lib/math/Matrix4f.ci:89:[.0619a6, .0619a9) exec(0), time(0.000 ms): <transpose+6>
cmplStd/lib/math/Matrix4f.ci:89:[.0619a9, .0619ac) exec(0), time(0.000 ms): <transpose+9>
cmplStd/lib/math/Matrix4f.ci:90:[.0619ac, .0619af) exec(0), time(0.000 ms): <transpose+12>
cmplStd/lib/math/Matrix4f.ci:90:[.0619af, .0619b2) exec(0), time(0.000 ms): <transpose+15>
cmplStd/lib/math/Matrix4f.ci:90:[.0619b2, .0619b5) exec(0), time(0.000 ms): <transpose+18>
cmplStd/lib/math/Matrix4f.ci:90:[.0619b5, .0619b8) exec(0), time(0.000 ms): <transpose+21>
cmplStd/lib/math/Matrix4f.ci:91:[.0619b8, .0619bb) exec(0), time(0.000 ms): <transpose+24>
cmplStd/lib/math/Matrix4f.ci:91:[.0619bb, .0619be) exec(0), time(0.000 ms): <transpose+27>
cmplStd/lib/math/Matrix4f.ci:91:[.0619be, .0619c1) exec(0), time(0.000 ms): <transpose+30>
cmplStd/lib/math/Matrix4f.ci:91:[.0619c1, .0619c4) exec(0), time(0.000 ms): <transpose+33>
cmplStd/lib/math/Matrix4f.ci:92:[.0619c4, .0619c7) exec(0), time(0.000 ms): <transpose+36>
cmplStd/lib/math/Matrix4f.ci:92:[.0619c7, .0619ca) exec(0), time(0.000 ms): <transpose+39>
cmplStd/lib/math/Matrix4f.ci:92:[.0619ca, .0619cd) exec(0), time(0.000 ms): <transpose+42>
cmplStd/lib/math/Matrix4f.ci:92:[.0619cd, .0619d0) exec(0), time(0.000 ms): <transpose+45>
cmplStd/lib/math/Matrix4f.ci:88:[.0619a0, .0619d1) exec(0), time(0.000 ms): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:98:[.0619d8, .0619f4) exec(0), time(0.000 ms): <mul+0>
cmplStd/lib/math/Matrix4f.ci:100:[.0619f4, .061a26) exec(0), time(0.000 ms): <mul+28>
cmplStd/lib/math/Matrix4f.ci:101:[.061a26, .061a5c) exec(0), time(0.000 ms): <mul+78>
cmplStd/lib/math/Matrix4f.ci:102:[.061a5c, .061a92) exec(0), time(0.000 ms): <mul+132>
cmplStd/lib/math/Matrix4f.ci:103:[.061a92, .061ac8) exec(0), time(0.000 ms): <mul+186>
cmplStd/lib/math/Matrix4f.ci:99:[.0619f4, .061acd) exec(0), time(0.000 ms): <mul+28>
cmplStd/lib/math/Matrix4f.ci:112:[.061ad0, .061ae2) exec(0), time(0.000 ms): <rotation+0>
cmplStd/lib/math/Matrix4f.ci:114:[.061af3, .061b17) exec(0), time(0.000 ms): <rotation+35>
cmplStd/lib/math/Matrix4f.ci:116:[.061b17, .061b1d) exec(0), time(0.000 ms): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:117:[.061b1d, .061b23) exec(0), time(0.000 ms): <rotation+77>
cmplStd/lib/math/Matrix4f.ci:118:[.061b23, .061b29) exec(0), time(0.000 ms): <rotation+83>
cmplStd/lib/math/Matrix4f.ci:119:[.061b29, .061b2f) exec(0), time(0.000 ms): <rotation+89>
cmplStd/lib/math/Matrix4f.ci:115:[.061b17, .061b34) exec(0), time(0.000 ms): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:113:[.061ae2, .061b34) exec(0), time(0.000 ms): <rotation+18>
cmplStd/lib/math/Matrix4f.ci:122:[.061b34, .061b3a) exec(0), time(0.000 ms): <rotation+100>
cmplStd/lib/math/Matrix4f.ci:123:[.061b3a, .061b44) exec(0), time(0.000 ms): <rotation+106>
cmplStd/lib/math/Matrix4f.ci:124:[.061b44, .061b4e) exec(0), time(0.000 ms): <rotation+116>
cmplStd/lib/math/Matrix4f.ci:125:[.061b4e, .061b51) exec(0), time(0.000 ms): <rotation+126>
cmplStd/lib/math/Matrix4f.ci:126:[.061b51, .061b58) exec(0), time(0.000 ms): <rotation+129>
cmplStd/lib/math/Matrix4f.ci:127:[.061b58, .061b5f) exec(0), time(0.000 ms): <rotation+136>
cmplStd/lib/math/Matrix4f.ci:128:[.061b5f, .061b64) exec(0), time(0.000 ms): <rotation+143>
cmplStd/lib/math/Matrix4f.ci:129:[.061b64, .061b69) exec(0), time(0.000 ms): <rotation+148>
cmplStd/lib/math/Matrix4f.ci:130:[.061b69, .061b6e) exec(0), time(0.000 ms): <rotation+153>
cmplStd/lib/math/Matrix4f.ci:131:[.061b6e, .061b73) exec(0), time(0.000 ms): <rotation+158>
cmplStd/lib/math/Matrix4f.ci:132:[.061b73, .061b78) exec(0), time(0.000 ms): <rotation+163>
cmplStd/lib/math/Matrix4f.ci:133:[.061b78, .061b7d) exec(0), time(0.000 ms): <rotation+168>
cmplStd/lib/math/Matrix4f.ci:135:[.061b7d, .061b83) exec(0), time(0.000 ms): <rotation+173>
cmplStd/lib/math/Matrix4f.ci:136:[.061b83, .061b89) exec(0), time(0.000 ms): <rotation+179>
cmplStd/lib/math/Matrix4f.ci:137:[.061b89, .061b91) exec(0), time(0.000 ms): <rotation+185>
cmplStd/lib/math/Matrix4f.ci:140:[.061b91, .061b9e) exec(0), time(0.000 ms): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:141:[.061b9e, .061bab) exec(0), time(0.000 ms): <rotation+206>
cmplStd/lib/math/Matrix4f.ci:142:[.061bab, .061bb8) exec(0), time(0.000 ms): <rotation+219>
cmplStd/lib/math/Matrix4f.ci:143:[.061bb8, .061be3) exec(0), time(0.000 ms): <rotation+232>
cmplStd/lib/math/Matrix4f.ci:145:[.061be3, .061bf0) exec(0), time(0.000 ms): <rotation+275>
cmplStd/lib/math/Matrix4f.ci:146:[.061bf0, .061bfd) exec(0), time(0.000 ms): <rotation+288>
cmplStd/lib/math/Matrix4f.ci:147:[.061bfd, .061c0a) exec(0), time(0.000 ms): <rotation+301>
cmplStd/lib/math/Matrix4f.ci:148:[.061c0a, .061c35) exec(0), time(0.000 ms): <rotation+314>
cmplStd/lib/math/Matrix4f.ci:150:[.061c35, .061c42) exec(0), time(0.000 ms): <rotation+357>
cmplStd/lib/math/Matrix4f.ci:151:[.061c42, .061c4f) exec(0), time(0.000 ms): <rotation+370>
cmplStd/lib/math/Matrix4f.ci:152:[.061c4f, .061c5c) exec(0), time(0.000 ms): <rotation+383>
cmplStd/lib/math/Matrix4f.ci:153:[.061c5c, .061c87) exec(0), time(0.000 ms): <rotation+396>
cmplStd/lib/math/Matrix4f.ci:155:[.061c87, .061c91) exec(0), time(0.000 ms): <rotation+439>
cmplStd/lib/math/Matrix4f.ci:139:[.061b91, .061c96) exec(0), time(0.000 ms): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:165:[.061c98, .061c9f) exec(0), time(0.000 ms): <translation+0>
cmplStd/lib/math/Matrix4f.ci:165:[.061c9f, .061ca2) exec(0), time(0.000 ms): <translation+7>
cmplStd/lib/math/Matrix4f.ci:165:[.061ca2, .061ca5) exec(0), time(0.000 ms): <translation+10>
cmplStd/lib/math/Matrix4f.ci:165:[.061ca5, .061cad) exec(0), time(0.000 ms): <translation+13>
cmplStd/lib/math/Matrix4f.ci:166:[.061cad, .061cb0) exec(0), time(0.000 ms): <translation+21>
cmplStd/lib/math/Matrix4f.ci:166:[.061cb0, .061cb7) exec(0), time(0.000 ms): <translation+24>
cmplStd/lib/math/Matrix4f.ci:166:[.061cb7, .061cba) exec(0), time(0.000 ms): <translation+31>
cmplStd/lib/math/Matrix4f.ci:166:[.061cba, .061cc6) exec(0), time(0.000 ms): <translation+34>
cmplStd/lib/math/Matrix4f.ci:167:[.061cc6, .061cc9) exec(0), time(0.000 ms): <translation+46>
cmplStd/lib/math/Matrix4f.ci:167:[.061cc9, .061ccc) exec(0), time(0.000 ms): <translation+49>
cmplStd/lib/math/Matrix4f.ci:167:[.061ccc, .061cd3) exec(0), time(0.000 ms): <translation+52>
cmplStd/lib/math/Matrix4f.ci:167:[.061cd3, .061cdf) exec(0), time(0.000 ms): <translation+59>
cmplStd/lib/math/Matrix4f.ci:168:[.061cdf, .061ce2) exec(0), time(0.000 ms): <translation+71>
cmplStd/lib/math/Matrix4f.ci:168:[.061ce2, .061ce5) exec(0), time(0.000 ms): <translation+74>
cmplStd/lib/math/Matrix4f.ci:168:[.061ce5, .061ce8) exec(0), time(0.000 ms): <translation+77>
cmplStd/lib/math/Matrix4f.ci:168:[.061ce8, .061cef) exec(0), time(0.000 ms): <translation+80>
cmplStd/lib/math/Matrix4f.ci:164:[.061c98, .061cf0) exec(0), time(0.000 ms): <translation+0>
cmplStd/lib/math/Matrix4f.ci:176:[.061cf0, .061d27) exec(0), time(0.000 ms): <scale+0>
cmplStd/lib/math/Matrix4f.ci:176:[.061d27, .061d2a) exec(0), time(0.000 ms): <scale+55>
cmplStd/lib/math/Matrix4f.ci:176:[.061d2a, .061d2d) exec(0), time(0.000 ms): <scale+58>
cmplStd/lib/math/Matrix4f.ci:176:[.061d2d, .061d30) exec(0), time(0.000 ms): <scale+61>
cmplStd/lib/math/Matrix4f.ci:177:[.061d30, .061d33) exec(0), time(0.000 ms): <scale+64>
cmplStd/lib/math/Matrix4f.ci:177:[.061d33, .061d6e) exec(0), time(0.000 ms): <scale+67>
cmplStd/lib/math/Matrix4f.ci:177:[.061d6e, .061d71) exec(0), time(0.000 ms): <scale+126>
cmplStd/lib/math/Matrix4f.ci:177:[.061d71, .061d74) exec(0), time(0.000 ms): <scale+129>
cmplStd/lib/math/Matrix4f.ci:178:[.061d74, .061d77) exec(0), time(0.000 ms): <scale+132>
cmplStd/lib/math/Matrix4f.ci:178:[.061d77, .061d7a) exec(0), time(0.000 ms): <scale+135>
cmplStd/lib/math/Matrix4f.ci:178:[.061d7a, .061db5) exec(0), time(0.000 ms): <scale+138>
cmplStd/lib/math/Matrix4f.ci:178:[.061db5, .061db8) exec(0), time(0.000 ms): <scale+197>
cmplStd/lib/math/Matrix4f.ci:179:[.061db8, .061dbb) exec(0), time(0.000 ms): <scale+200>
cmplStd/lib/math/Matrix4f.ci:179:[.061dbb, .061dbe) exec(0), time(0.000 ms): <scale+203>
cmplStd/lib/math/Matrix4f.ci:179:[.061dbe, .061dc1) exec(0), time(0.000 ms): <scale+206>
cmplStd/lib/math/Matrix4f.ci:179:[.061dc1, .061dc8) exec(0), time(0.000 ms): <scale+209>
cmplStd/lib/math/Matrix4f.ci:175:[.061cf0, .061dc9) exec(0), time(0.000 ms): <scale+0>
cmplStd/lib/math/Vector2d.ci:16:[.061dd0, .061dd3) exec(0), time(0.000 ms): <vec2d+0>
cmplStd/lib/math/Vector2d.ci:17:[.061dd3, .061dd6) exec(0), time(0.000 ms): <vec2d+3>
cmplStd/lib/math/Vector2d.ci:15:[.061dd0, .061dd7) exec(0), time(0.000 ms): <vec2d+0>
cmplStd/lib/string.ci:6:[.061de4, .061de8) exec(0), time(0.000 ms): <length+12>
cmplStd/lib/string.ci:5:[.061dd8, .061de8) exec(0), time(0.000 ms): <length+0>
cmplStd/lib/string.ci:8:[.061de8, .061de9) exec(0), time(0.000 ms): <length+16>
cmplStd/lib/string.ci:9:[.061ded, .061df1) exec(0), time(0.000 ms): <length+21>
cmplStd/lib/string.ci:9:[.061df1, .061dfb) exec(0), time(0.000 ms): <length+25>
cmplStd/lib/string.ci:9:[.061de9, .061dfb) exec(0), time(0.000 ms): <length+17>
cmplStd/lib/string.ci:11:[.061dfb, .061dfe) exec(0), time(0.000 ms): <length+35>
cmplStd/lib/string.ci:18:[.061e15, .061e18) exec(0), time(0.000 ms): <indexOf+21>
cmplStd/lib/string.ci:17:[.061e05, .061e18) exec(0), time(0.000 ms): <indexOf+5>
cmplStd/lib/string.ci:16:[.061e18, .061e1c) exec(0), time(0.000 ms): <indexOf+24>
cmplStd/lib/string.ci:16:[.061e1c, .061e26) exec(0), time(0.000 ms): <indexOf+28>
cmplStd/lib/string.ci:16:[.061e00, .061e2a) exec(0), time(0.000 ms): <indexOf+0>
cmplStd/lib/string.ci:21:[.061e2a, .061e32) exec(0), time(0.000 ms): <indexOf+42>
cmplStd/lib/string.ci:26:[.061e38, .061e3d) exec(0), time(0.000 ms): <lastIndexOf+0>
cmplStd/lib/string.ci:29:[.061e52, .061e55) exec(0), time(0.000 ms): <lastIndexOf+26>
cmplStd/lib/string.ci:28:[.061e42, .061e55) exec(0), time(0.000 ms): <lastIndexOf+10>
cmplStd/lib/string.ci:27:[.061e55, .061e59) exec(0), time(0.000 ms): <lastIndexOf+29>
cmplStd/lib/string.ci:27:[.061e59, .061e63) exec(0), time(0.000 ms): <lastIndexOf+33>
cmplStd/lib/string.ci:27:[.061e3d, .061e67) exec(0), time(0.000 ms): <lastIndexOf+5>
cmplStd/lib/string.ci:32:[.061e67, .061e6a) exec(0), time(0.000 ms): <lastIndexOf+47>
cmplStd/lib/string.ci:39:[.061e8f, .061e9a) exec(0), time(0.000 ms): <startsWith+31>
cmplStd/lib/string.ci:38:[.061e75, .061e9a) exec(0), time(0.000 ms): <startsWith+5>
cmplStd/lib/string.ci:37:[.061e9a, .061e9e) exec(0), time(0.000 ms): <startsWith+42>
cmplStd/lib/string.ci:37:[.061e9e, .061eaa) exec(0), time(0.000 ms): <startsWith+46>
cmplStd/lib/string.ci:37:[.061e70, .061eae) exec(0), time(0.000 ms): <startsWith+0>
cmplStd/lib/string.ci:42:[.061eae, .061eb9) exec(0), time(0.000 ms): <startsWith+62>
cmplStd/lib/string.ci:47:[.061ec0, .061ecd) exec(0), time(0.000 ms): <endsWith+0>
cmplStd/lib/string.ci:48:[.061ecd, .061eda) exec(0), time(0.000 ms): <endsWith+13>
cmplStd/lib/string.ci:50:[.061ee3, .061eee) exec(0), time(0.000 ms): <endsWith+35>
cmplStd/lib/string.ci:49:[.061eda, .061eee) exec(0), time(0.000 ms): <endsWith+26>
cmplStd/lib/string.ci:54:[.061f13, .061f1e) exec(0), time(0.000 ms): <endsWith+83>
cmplStd/lib/string.ci:53:[.061ef3, .061f1e) exec(0), time(0.000 ms): <endsWith+51>
cmplStd/lib/string.ci:52:[.061f1e, .061f22) exec(0), time(0.000 ms): <endsWith+94>
cmplStd/lib/string.ci:52:[.061f22, .061f2b) exec(0), time(0.000 ms): <endsWith+98>
cmplStd/lib/string.ci:52:[.061eee, .061f2f) exec(0), time(0.000 ms): <endsWith+46>
cmplStd/lib/string.ci:57:[.061f2f, .061f3e) exec(0), time(0.000 ms): <endsWith+111>
cmplStd/lib/string.ci:62:[.061f40, .061f41) exec(0), time(0.000 ms): <compare+0>
cmplStd/lib/string.ci:64:[.061f46, .061f5c) exec(0), time(0.000 ms): <compare+6>
cmplStd/lib/string.ci:66:[.061f68, .061f6c) exec(0), time(0.000 ms): <compare+40>
cmplStd/lib/string.ci:65:[.061f5c, .061f6c) exec(0), time(0.000 ms): <compare+28>
cmplStd/lib/string.ci:63:[.061f6c, .061f70) exec(0), time(0.000 ms): <compare+44>
cmplStd/lib/string.ci:63:[.061f70, .061f78) exec(0), time(0.000 ms): <compare+48>
cmplStd/lib/string.ci:63:[.061f41, .061f7c) exec(0), time(0.000 ms): <compare+1>
cmplStd/lib/string.ci:69:[.061f7c, .061f7f) exec(0), time(0.000 ms): <compare+60>
cmplStd/lib/string.ci:76:[.061f8f, .061f9a) exec(0), time(0.000 ms): <ignCase+15>
cmplStd/lib/string.ci:75:[.061f80, .061f9a) exec(0), time(0.000 ms): <ignCase+0>
cmplStd/lib/string.ci:79:[.061fa9, .061fb4) exec(0), time(0.000 ms): <ignCase+41>
cmplStd/lib/string.ci:78:[.061f9a, .061fb4) exec(0), time(0.000 ms): <ignCase+26>
cmplStd/lib/string.ci:81:[.061fb4, .061fc7) exec(0), time(0.000 ms): <ignCase+52>
cmplStd/lib/string.ci:84:[.061fc8, .061fec) exec(0), time(0.000 ms): <ignCaseCmp+0>
cmplStd/lib/string.ci:89:[.061ff0, .061ffe) exec(0), time(0.000 ms): <caseCmp+0>
cmplStd/lib/string.ci:130:[.06200e, .062012) exec(0), time(0.000 ms): <append+14>
cmplStd/lib/string.ci:129:[.062005, .062012) exec(0), time(0.000 ms): <append+5>
cmplStd/lib/string.ci:132:[.062012, .06201e) exec(0), time(0.000 ms): <append+18>
cmplStd/lib/string.ci:133:[.06201e, .062026) exec(0), time(0.000 ms): <append+30>
cmplStd/lib/string.ci:128:[.062026, .06202a) exec(0), time(0.000 ms): <append+38>
cmplStd/lib/string.ci:128:[.06202a, .062034) exec(0), time(0.000 ms): <append+42>
cmplStd/lib/string.ci:128:[.062000, .062038) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:137:[.062041, .062049) exec(0), time(0.000 ms): <append+65>
cmplStd/lib/string.ci:136:[.062038, .062049) exec(0), time(0.000 ms): <append+56>
cmplStd/lib/string.ci:139:[.062049, .062050) exec(0), time(0.000 ms): <append+73>
cmplStd/lib/string.ci:140:[.062050, .062054) exec(0), time(0.000 ms): <append+80>
cmplStd/lib/string.ci:148:[.062068, .062069) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:149:[.062069, .06206d) exec(0), time(0.000 ms): <append+1>
cmplStd/lib/string.ci:153:[.06207f, .062089) exec(0), time(0.000 ms): <append+23>
cmplStd/lib/string.ci:152:[.062074, .062089) exec(0), time(0.000 ms): <append+12>
cmplStd/lib/string.ci:151:[.06206d, .062089) exec(0), time(0.000 ms): <append+5>
cmplStd/lib/string.ci:157:[.062089, .062090) exec(0), time(0.000 ms): <append+33>
cmplStd/lib/string.ci:159:[.062098, .06209f) exec(0), time(0.000 ms): <append+48>
cmplStd/lib/string.ci:158:[.062090, .06209f) exec(0), time(0.000 ms): <append+40>
cmplStd/lib/string.ci:161:[.06209f, .0620d5) exec(0), time(0.000 ms): <append+55>
cmplStd/lib/string.ci:162:[.0620d5, .06210a) exec(0), time(0.000 ms): <append+109>
cmplStd/lib/string.ci:166:[.06210e, .06212b) exec(0), time(0.000 ms): <append+166>
cmplStd/lib/string.ci:165:[.06212b, .062133) exec(0), time(0.000 ms): <append+195>
cmplStd/lib/string.ci:165:[.062133, .06213b) exec(0), time(0.000 ms): <append+203>
cmplStd/lib/string.ci:165:[.06210a, .06213b) exec(0), time(0.000 ms): <append+162>
cmplStd/lib/string.ci:169:[.062143, .062158) exec(0), time(0.000 ms): <append+219>
cmplStd/lib/string.ci:168:[.06213b, .062158) exec(0), time(0.000 ms): <append+211>
cmplStd/lib/string.ci:172:[.062158, .062162) exec(0), time(0.000 ms): <append+240>
cmplStd/lib/string.ci:174:[.062162, .062169) exec(0), time(0.000 ms): <append+250>
cmplStd/lib/string.ci:176:[.062174, .06217e) exec(0), time(0.000 ms): <append+268>
cmplStd/lib/string.ci:175:[.062169, .06217e) exec(0), time(0.000 ms): <append+257>
cmplStd/lib/string.ci:181:[.062189, .062191) exec(0), time(0.000 ms): <append+289>
cmplStd/lib/string.ci:185:[.0621af, .0621e3) exec(0), time(0.000 ms): <append+327>
cmplStd/lib/string.ci:186:[.0621e3, .0621ee) exec(0), time(0.000 ms): <append+379>
cmplStd/lib/string.ci:187:[.0621ee, .0621f6) exec(0), time(0.000 ms): <append+390>
cmplStd/lib/string.ci:184:[.0621f6, .0621fe) exec(0), time(0.000 ms): <append+398>
cmplStd/lib/string.ci:184:[.0621fe, .062206) exec(0), time(0.000 ms): <append+406>
cmplStd/lib/string.ci:184:[.0621ab, .062206) exec(0), time(0.000 ms): <append+323>
cmplStd/lib/string.ci:182:[.062191, .062206) exec(0), time(0.000 ms): <append+297>
cmplStd/lib/string.ci:190:[.062206, .06223a) exec(0), time(0.000 ms): <append+414>
cmplStd/lib/string.ci:191:[.06223a, .062245) exec(0), time(0.000 ms): <append+466>
cmplStd/lib/string.ci:192:[.062245, .06224d) exec(0), time(0.000 ms): <append+477>
cmplStd/lib/string.ci:180:[.06217e, .06224d) exec(0), time(0.000 ms): <append+278>
cmplStd/lib/string.ci:197:[.062251, .062285) exec(0), time(0.000 ms): <append+489>
cmplStd/lib/string.ci:198:[.062285, .062290) exec(0), time(0.000 ms): <append+541>
cmplStd/lib/string.ci:199:[.062290, .062298) exec(0), time(0.000 ms): <append+552>
cmplStd/lib/string.ci:196:[.062298, .0622a0) exec(0), time(0.000 ms): <append+560>
cmplStd/lib/string.ci:196:[.0622a0, .0622a8) exec(0), time(0.000 ms): <append+568>
cmplStd/lib/string.ci:196:[.06224d, .0622a8) exec(0), time(0.000 ms): <append+485>
cmplStd/lib/string.ci:204:[.0622ad, .0622e1) exec(0), time(0.000 ms): <append+581>
cmplStd/lib/string.ci:205:[.0622e1, .0622f2) exec(0), time(0.000 ms): <append+633>
cmplStd/lib/string.ci:206:[.0622f2, .0622fa) exec(0), time(0.000 ms): <append+650>
cmplStd/lib/string.ci:203:[.0622fa, .0622fe) exec(0), time(0.000 ms): <append+658>
cmplStd/lib/string.ci:203:[.0622fe, .062307) exec(0), time(0.000 ms): <append+662>
cmplStd/lib/string.ci:203:[.0622a8, .06230b) exec(0), time(0.000 ms): <append+576>
cmplStd/lib/string.ci:210:[.062314, .06231c) exec(0), time(0.000 ms): <append+684>
cmplStd/lib/string.ci:209:[.06230b, .06231c) exec(0), time(0.000 ms): <append+675>
cmplStd/lib/string.ci:212:[.06231c, .062323) exec(0), time(0.000 ms): <append+692>
cmplStd/lib/string.ci:213:[.062323, .06232b) exec(0), time(0.000 ms): <append+699>
cmplStd/lib/string.ci:236:[.062334, .06233c) exec(0), time(0.000 ms): <append+4>
cmplStd/lib/string.ci:237:[.06233c, .06233f) exec(0), time(0.000 ms): <append+12>
cmplStd/lib/string.ci:238:[.06233f, .06234b) exec(0), time(0.000 ms): <append+15>
cmplStd/lib/string.ci:239:[.06234b, .06235c) exec(0), time(0.000 ms): <append+27>
cmplStd/lib/string.ci:235:[.062330, .06235c) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:242:[.062360, .062366) exec(0), time(0.000 ms): <append+48>
cmplStd/lib/string.ci:243:[.062366, .062369) exec(0), time(0.000 ms): <append+54>
cmplStd/lib/string.ci:244:[.062369, .062373) exec(0), time(0.000 ms): <append+57>
cmplStd/lib/string.ci:245:[.062373, .06237c) exec(0), time(0.000 ms): <append+67>
cmplStd/lib/string.ci:241:[.06235c, .06237c) exec(0), time(0.000 ms): <append+44>
cmplStd/lib/string.ci:248:[.06237c, .06238e) exec(0), time(0.000 ms): <append+76>
cmplStd/lib/string.ci:249:[.06238e, .0623b2) exec(0), time(0.000 ms): <append+94>
cmplStd/lib/string.ci:250:[.0623b2, .0623cf) exec(0), time(0.000 ms): <append+130>
cmplStd/lib/string.ci:252:[.0623cf, .0623e5) exec(0), time(0.000 ms): <append+159>
cmplStd/lib/string.ci:253:[.0623e5, .0623fb) exec(0), time(0.000 ms): <append+181>
cmplStd/lib/string.ci:254:[.0623fb, .062414) exec(0), time(0.000 ms): <append+203>
cmplStd/lib/string.ci:255:[.062414, .06241c) exec(0), time(0.000 ms): <append+228>
cmplStd/lib/string.ci:264:[.062430, .06246f) exec(0), time(0.000 ms): <append+0>
cmplStd/test/std/tryExec.ci:16:[.062828, .06282c) exec(128-1), time(0.028-0.028 ms): <stackOverflow+0>
cmplStd/test/std/tryExec.ci:17:[.06282c, .06283b) exec(127-127), time(0.000 ms): <stackOverflow+4>
cmplStd/test/std/tryExec.ci:21:[.062840, .062847) exec(1-1), time(0.000 ms): <divisionByZero+0>
cmplStd/test/std/tryExec.ci:31:[.062854, .06285b) exec(1), time(0.001-0.001 ms): <abortExecution+4>
cmplStd/test/std/tryExec.ci:32:[.06285b, .062862) exec(1), time(0.001-0.001 ms): <abortExecution+11>
cmplStd/test/std/tryExec.ci:33:[.062862, .062869) exec(1), time(0.001-0.001 ms): <abortExecution+18>
cmplStd/test/std/tryExec.ci:30:[.062850, .062869) exec(1-1), time(0.000 ms): <abortExecution+0>
cmplStd/test/std/tryExec.ci:35:[.062869, .06288f) exec(1-1), time(0.000 ms): <abortExecution+25>
cmplStd/test/std/tryExec.ci:39:[.062898, .06289d) exec(1), time(0.000 ms): <invalidMemoryAccess+0>
cmplStd/test/std/tryExec.ci:40:[.06289d, .0628a0) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
cmplStd/test/std/tryExec.ci:44:[.0628a8, .0628aa) exec(1-1), time(0.000 ms): <invalidInstruction+0>
cmplStd/test/lang/function.ci:8:[.062bb0, .062bb8) exec(2), time(0.011-0.011 ms): <funAdd+0>
cmplStd/test/lang/function.ci:34:[.062bf0, .062bf8) exec(2), time(0.011-0.011 ms): <funMul+0>
cmplStd/test/lang/function.ci:40:[.062c04, .062c08) exec(377), time(1.568-1.568 ms): <fib+12>
cmplStd/test/lang/function.ci:39:[.062bf8, .062c08) exec(753-377), time(0.537-0.537 ms): <fib+0>
cmplStd/test/lang/function.ci:42:[.062c08, .062c2e) exec(376-375), time(12.068-12.068 ms): <fib+16>
cmplStd/test/lang/init.method.ci:11:[.062da8, .062dce) exec(3), time(0.202-0.202 ms): <staticMethod+0>
cmplStd/test/lang/init.method.ci:41:[.062dd8, .062dfe) exec(4), time(0.262-0.262 ms): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:48:[.062e00, .062e26) exec(0), time(0.000 ms): <forwardMethod+0>
cmplStd/test/lang/init.method.ci:58:[.062e28, .062e4e) exec(0), time(0.000 ms): <globalFunction+0>
cmplStd/test/lang/init.method.ci:85:[.062e60, .062e83) exec(1), time(0.018-0.018 ms): <staticMethod+0>
cmplStd/test/lang/init.method.ci:87:[.062e91, .062ea1) exec(1), time(0.091-0.091 ms): <staticMethod+49>
cmplStd/test/lang/init.method.ci:86:[.062e83, .062ea1) exec(1-1), time(0.000 ms): <staticMethod+35>
cmplStd/test/lang/init.method.ci:91:[.062ea8, .062ecb) exec(1), time(0.015-0.015 ms): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:93:[.062ed9, .062ee6) exec(1), time(0.091-0.091 ms): <virtualMethod+49>
cmplStd/test/lang/init.method.ci:92:[.062ecb, .062ee6) exec(1-1), time(0.000 ms): <virtualMethod+35>
cmplStd/test/lang/init.array.ci:51:[.062f70, .062f74) exec(5), time(0.020-0.020 ms): <lenSlice+0>
cmplStd/test/lang/init.array.ci:52:[.062f78, .062f84) exec(21), time(0.124-0.124 ms): <nthFixed+0>
cmplStd/test/lang/init.array.ci:53:[.062f88, .062f94) exec(21), time(0.125-0.125 ms): <nthArray+0>
cmplStd/test/lang/init.array.ci:54:[.062f98, .062fa4) exec(14), time(0.083-0.083 ms): <nthSlice+0>
cmplStd/lib/string.ci:145:[.0639ec, .0639fa) exec(1), time(0.001-0.001 ms): <.main+0>
cmplStd/lib/string.ci:146:[.0639fa, .063a08) exec(1), time(0.001-0.001 ms): <.main+14>
::[.063a08, .063a0f) exec(1), time(0.001-0.001 ms): <.main+28>
::[.063a0f, .063a14) exec(1), time(0.000 ms): <.main+35>
::[.063a14, .063a1b) exec(1), time(0.001-0.001 ms): <.main+40>
::[.063a1b, .063a20) exec(1), time(0.000 ms): <.main+47>
cmplStd/lib/string.ci:263:[.063a08, .063a20) exec(0), time(0.000 ms): <.main+28>
cmplStd/test/lang/emit.ci:3:[.063a20, .063a25) exec(1), time(0.000 ms): <.main+52>
cmplStd/test/lang/emit.ci:4:[.063a25, .063a2a) exec(1), time(0.000 ms): <.main+57>
cmplStd/test/lang/emit.ci:6:[.063a2a, .063a33) exec(1), time(0.000 ms): <.main+62>
cmplStd/test/lang/emit.ci:7:[.063a33, .063a3c) exec(1), time(0.001-0.001 ms): <.main+71>
cmplStd/test/lang/emit.ci:10:[.063a3c, .063a49) exec(1), time(0.001-0.001 ms): <.main+80>
cmplStd/test/lang/emit.ci:13:[.063a49, .063a58) exec(1), time(0.001-0.001 ms): <.main+93>
cmplStd/test/lang/emit.ci:16:[.063a58, .063a6b) exec(1), time(0.025-0.025 ms): <.main+108>
cmplStd/test/lang/emit.ci:23:[.063a6b, .063a74) exec(1), time(0.001-0.001 ms): <.main+127>
cmplStd/test/lang/emit.ci:24:[.063a74, .063a7e) exec(1), time(0.001-0.001 ms): <.main+136>
cmplStd/test/lang/emit.ci:25:[.063a7e, .063a8c) exec(1), time(0.001-0.001 ms): <.main+146>
cmplStd/test/lang/emit.ci:26:[.063a8c, .063a99) exec(1), time(0.001-0.001 ms): <.main+160>
cmplStd/test/lang/emit.ci:29:[.063a99, .063aa7) exec(1), time(0.001-0.001 ms): <.main+173>
cmplStd/test/lang/inlineMacros.ci:10:[.063aa7, .063ab0) exec(1), time(0.001-0.001 ms): <.main+187>
cmplStd/test/lang/inlineMacros.ci:11:[.063ab0, .063ab9) exec(1), time(0.001-0.001 ms): <.main+196>
cmplStd/test/lang/inlineMacros.ci:12:[.063ab9, .063ac2) exec(1), time(0.001-0.001 ms): <.main+205>
cmplStd/test/lang/inlineMacros.ci:13:[.063ac2, .063acb) exec(1), time(0.001-0.001 ms): <.main+214>
cmplStd/test/lang/inlineMacros.ci:15:[.063acb, .063ad0) exec(1), time(0.000 ms): <.main+223>
cmplStd/test/lang/inlineMacros.ci:16:[.063ad0, .063ad5) exec(1), time(0.000 ms): <.main+228>
cmplStd/test/lang/inlineMacros.ci:17:[.063ad5, .063ada) exec(1), time(0.000 ms): <.main+233>
cmplStd/test/lang/inlineMacros.ci:19:[.063ada, .063ae3) exec(1), time(0.000 ms): <.main+238>
cmplStd/test/lang/inlineMacros.ci:20:[.063ae3, .063aeb) exec(1), time(0.001-0.001 ms): <.main+247>
cmplStd/test/lang/inlineMacros.ci:21:[.063aeb, .063afb) exec(1), time(0.002-0.002 ms): <.main+255>
cmplStd/test/lang/inlineMacros.ci:23:[.063afb, .063b08) exec(1), time(0.001-0.001 ms): <.main+271>
cmplStd/test/lang/inlineMacros.ci:24:[.063b08, .063b15) exec(1), time(0.001-0.001 ms): <.main+284>
cmplStd/test/lang/inlineMacros.ci:25:[.063b15, .063b2e) exec(1), time(0.003-0.003 ms): <.main+297>
cmplStd/test/lang/inlineMacros.ci:27:[.063b2e, .063b4a) exec(1), time(0.003-0.003 ms): <.main+322>
cmplStd/test/lang/inlineMacros.ci:28:[.063b4a, .063b64) exec(1), time(0.003-0.003 ms): <.main+350>
cmplStd/test/lang/inlineMacros.ci:29:[.063b64, .063b8a) exec(1), time(0.003-0.003 ms): <.main+376>
cmplStd/test/lang/inlineMacros.ci:31:[.063b8a, .063baf) exec(1), time(0.004-0.004 ms): <.main+414>
cmplStd/test/lang/inlineMacros.ci:32:[.063baf, .063bd2) exec(1), time(0.004-0.004 ms): <.main+451>
cmplStd/test/lang/inlineMacros.ci:33:[.063bd2, .063c01) exec(1), time(0.005-0.005 ms): <.main+486>
cmplStd/test/lang/inlineMacros.ci:35:[.063c01, .063c26) exec(1), time(0.004-0.004 ms): <.main+533>
cmplStd/test/lang/inlineMacros.ci:36:[.063c26, .063c49) exec(1), time(0.004-0.004 ms): <.main+570>
cmplStd/test/lang/inlineMacros.ci:37:[.063c49, .063c78) exec(1), time(0.005-0.005 ms): <.main+605>
cmplStd/test/lang/inlineMacros.ci:41:[.063c78, .063c91) exec(1), time(0.003-0.003 ms): <.main+652>
cmplStd/test/lang/inlineMacros.ci:42:[.063c91, .063ca6) exec(1), time(0.002-0.002 ms): <.main+677>
cmplStd/test/lang/inlineMacros.ci:43:[.063ca6, .063cbd) exec(1), time(0.003-0.003 ms): <.main+698>
cmplStd/test/lang/inlineMacros.ci:44:[.063cbd, .063cd4) exec(1), time(0.003-0.003 ms): <.main+721>
cmplStd/test/lang/inlineMacros.ci:45:[.063cd4, .063cff) exec(1), time(0.005-0.005 ms): <.main+744>
cmplStd/test/lang/inlineMacros.ci:46:[.063cff, .063d2a) exec(1), time(0.005-0.005 ms): <.main+787>
cmplStd/test/lang/inlineMacros.ci:50:[.063d2a, .063d6c) exec(1), time(0.002-0.002 ms): <.main+830>
cmplStd/test/lang/inlineMacros.ci:51:[.063d6c, .063dae) exec(1), time(0.007-0.007 ms): <.main+896>
cmplStd/test/lang/inlineMacros.ci:52:[.063dae, .063dec) exec(1), time(0.002-0.002 ms): <.main+962>
cmplStd/test/lang/inlineMacros.ci:53:[.063dec, .063e2a) exec(1), time(0.007-0.007 ms): <.main+1024>
cmplStd/test/lang/inlineMacros.ci:54:[.063e2a, .063e7c) exec(1), time(0.003-0.003 ms): <.main+1086>
cmplStd/test/lang/inlineMacros.ci:55:[.063e7c, .063ece) exec(1), time(0.008-0.008 ms): <.main+1168>
cmplStd/test/lang/inlineMacros.ci:59:[.063ece, .063f2b) exec(1), time(0.012-0.012 ms): <.main+1250>
cmplStd/test/lang/inlineMacros.ci:60:[.063f2b, .063f88) exec(1), time(0.012-0.012 ms): <.main+1343>
cmplStd/test/lang/inlineMacros.ci:61:[.063f88, .063fe1) exec(1), time(0.012-0.012 ms): <.main+1436>
cmplStd/test/lang/inlineMacros.ci:62:[.063fe1, .06403a) exec(1), time(0.012-0.012 ms): <.main+1525>
cmplStd/test/lang/inlineMacros.ci:63:[.06403a, .0640a7) exec(1), time(0.014-0.014 ms): <.main+1614>
cmplStd/test/lang/inlineMacros.ci:64:[.0640a7, .064114) exec(1), time(0.014-0.014 ms): <.main+1723>
cmplStd/test/lang/inlineMacros.ci:68:[.064114, .064171) exec(1), time(0.011-0.011 ms): <.main+1832>
cmplStd/test/lang/inlineMacros.ci:69:[.064171, .0641ce) exec(1), time(0.011-0.011 ms): <.main+1925>
cmplStd/test/lang/inlineMacros.ci:70:[.0641ce, .064227) exec(1), time(0.011-0.011 ms): <.main+2018>
cmplStd/test/lang/inlineMacros.ci:71:[.064227, .064280) exec(1), time(0.011-0.011 ms): <.main+2107>
cmplStd/test/lang/inlineMacros.ci:72:[.064280, .0642ed) exec(1), time(0.013-0.013 ms): <.main+2196>
cmplStd/test/lang/inlineMacros.ci:73:[.0642ed, .06435a) exec(1), time(0.014-0.014 ms): <.main+2305>
cmplStd/test/lang/overload.inline.ci:9:[.06435a, .064363) exec(1), time(0.001-0.001 ms): <.main+2414>
cmplStd/test/lang/overload.inline.ci:10:[.064363, .06436c) exec(1), time(0.001-0.001 ms): <.main+2423>
cmplStd/test/lang/overload.inline.ci:11:[.06436c, .064375) exec(1), time(0.000 ms): <.main+2432>
cmplStd/test/lang/overload.inline.ci:12:[.064375, .06437e) exec(1), time(0.001-0.001 ms): <.main+2441>
cmplStd/test/lang/overload.inline.ci:13:[.06437e, .064387) exec(1), time(0.001-0.001 ms): <.main+2450>
cmplStd/test/lang/overload.inline.ci:28:[.064387, .064394) exec(1), time(0.001-0.001 ms): <.main+2459>
cmplStd/test/lang/overload.inline.ci:29:[.064394, .0643b0) exec(1), time(0.002-0.002 ms): <.main+2472>
cmplStd/test/std/number.ci:3:[.0643b0, .0643bd) exec(1), time(0.000 ms): <.main+2500>
cmplStd/test/std/number.ci:4:[.0643bd, .0643ca) exec(1), time(0.000 ms): <.main+2513>
cmplStd/test/std/number.ci:6:[.0643ca, .0643d3) exec(1), time(0.001-0.001 ms): <.main+2526>
cmplStd/test/std/number.ci:7:[.0643d3, .0643dc) exec(1), time(0.001-0.001 ms): <.main+2535>
cmplStd/test/std/number.ci:14:[.0643dc, .0643e7) exec(1), time(0.002-0.002 ms): <.main+2544>
cmplStd/test/std/number.ci:15:[.0643e7, .0643f2) exec(1), time(0.001-0.001 ms): <.main+2555>
cmplStd/test/std/number.ci:16:[.0643f2, .0643fd) exec(1), time(0.001-0.001 ms): <.main+2566>
cmplStd/test/std/number.ci:18:[.0643fd, .064423) exec(1), time(0.007-0.007 ms): <.main+2577>
cmplStd/test/std/number.ci:19:[.064423, .064447) exec(1), time(0.006-0.006 ms): <.main+2615>
cmplStd/test/std/number.ci:21:[.064447, .06445d) exec(1), time(0.019-0.019 ms): <.main+2651>
cmplStd/test/std/number.ci:22:[.06445d, .064473) exec(1), time(0.017-0.017 ms): <.main+2673>
cmplStd/test/std/number.ci:23:[.064473, .064485) exec(1), time(0.016-0.016 ms): <.main+2695>
cmplStd/test/std/number.ci:25:[.064485, .06449b) exec(1), time(0.017-0.017 ms): <.main+2713>
cmplStd/test/std/number.ci:26:[.06449b, .0644b1) exec(1), time(0.016-0.016 ms): <.main+2735>
cmplStd/test/std/number.ci:27:[.0644b1, .0644c3) exec(1), time(0.017-0.017 ms): <.main+2757>
cmplStd/test/std/number.ci:29:[.0644c3, .0644d9) exec(1), time(0.017-0.017 ms): <.main+2775>
cmplStd/test/std/number.ci:30:[.0644d9, .0644ef) exec(1), time(0.017-0.017 ms): <.main+2797>
cmplStd/test/std/number.ci:31:[.0644ef, .064501) exec(1), time(0.017-0.017 ms): <.main+2819>
cmplStd/test/std/number.ci:33:[.064501, .064517) exec(1), time(0.017-0.017 ms): <.main+2837>
cmplStd/test/std/number.ci:34:[.064517, .06452d) exec(1), time(0.017-0.017 ms): <.main+2859>
cmplStd/test/std/number.ci:35:[.06452d, .06453f) exec(1), time(0.016-0.016 ms): <.main+2881>
cmplStd/test/std/number.ci:37:[.06453f, .064555) exec(1), time(0.021-0.021 ms): <.main+2899>
cmplStd/test/std/number.ci:38:[.064555, .06456b) exec(1), time(0.018-0.018 ms): <.main+2921>
cmplStd/test/std/number.ci:39:[.06456b, .064581) exec(1), time(0.017-0.017 ms): <.main+2943>
cmplStd/test/std/number.ci:40:[.064581, .064597) exec(1), time(0.020-0.020 ms): <.main+2965>
cmplStd/test/std/number.ci:41:[.064597, .0645a8) exec(1), time(0.017-0.017 ms): <.main+2987>
cmplStd/test/std/number.ci:42:[.0645a8, .0645c2) exec(1), time(0.017-0.017 ms): <.main+3004>
cmplStd/test/std/number.ci:43:[.0645c2, .0645d3) exec(1), time(0.016-0.016 ms): <.main+3030>
cmplStd/test/std/number.ci:44:[.0645d3, .0645e8) exec(1), time(0.019-0.019 ms): <.main+3047>
cmplStd/test/std/number.ci:46:[.0645e8, .0645fa) exec(1), time(0.017-0.017 ms): <.main+3068>
cmplStd/test/std/number.ci:47:[.0645fa, .06460c) exec(1), time(0.017-0.017 ms): <.main+3086>
cmplStd/test/std/number.ci:48:[.06460c, .06461e) exec(1), time(0.017-0.017 ms): <.main+3104>
cmplStd/test/std/number.ci:49:[.06461e, .064634) exec(1), time(0.018-0.018 ms): <.main+3122>
cmplStd/test/std/number.ci:50:[.064634, .064641) exec(1), time(0.016-0.016 ms): <.main+3144>
cmplStd/test/std/number.ci:51:[.064641, .064657) exec(1), time(0.018-0.018 ms): <.main+3157>
cmplStd/test/std/number.ci:52:[.064657, .064668) exec(1), time(0.017-0.017 ms): <.main+3179>
cmplStd/test/std/number.ci:53:[.064668, .064679) exec(1), time(0.017-0.017 ms): <.main+3196>
cmplStd/test/std/number.ci:55:[.064679, .064685) exec(1), time(0.015-0.015 ms): <.main+3213>
cmplStd/test/std/number.ci:56:[.064685, .064691) exec(1), time(0.016-0.016 ms): <.main+3225>
cmplStd/test/std/number.ci:57:[.064691, .06469d) exec(1), time(0.016-0.016 ms): <.main+3237>
cmplStd/test/std/number.ci:58:[.06469d, .0646a9) exec(1), time(0.017-0.017 ms): <.main+3249>
cmplStd/test/std/number.ci:59:[.0646a9, .0646b5) exec(1), time(0.016-0.016 ms): <.main+3261>
cmplStd/test/std/number.ci:60:[.0646b5, .0646c1) exec(1), time(0.015-0.015 ms): <.main+3273>
cmplStd/test/std/number.ci:62:[.0646c1, .0646d3) exec(1), time(0.017-0.017 ms): <.main+3285>
cmplStd/test/std/number.ci:63:[.0646d3, .0646e5) exec(1), time(0.017-0.017 ms): <.main+3303>
cmplStd/test/std/number.ci:65:[.0646e5, .0646f9) exec(1), time(0.018-0.018 ms): <.main+3321>
cmplStd/test/std/number.ci:66:[.0646f9, .06470d) exec(1), time(0.018-0.018 ms): <.main+3341>
cmplStd/test/std/memory.ci:7:[.06470d, .06471f) exec(1), time(0.020-0.020 ms): <.main+3361>
cmplStd/test/std/memory.ci:8:[.06471f, .064731) exec(1), time(0.017-0.017 ms): <.main+3379>
cmplStd/test/std/memory.ci:9:[.064731, .064743) exec(1), time(0.016-0.016 ms): <.main+3397>
cmplStd/test/std/memory.ci:10:[.064743, .064755) exec(1), time(0.017-0.017 ms): <.main+3415>
cmplStd/test/std/memory.ci:23:[.064755, .064762) exec(1), time(0.000 ms): <.main+3433>
cmplStd/test/std/memory.ci:24:[.064762, .06476f) exec(1), time(0.001-0.001 ms): <.main+3446>
cmplStd/test/std/tryExec.ci:47:[.06476f, .064781) exec(1), time(0.038-0.038 ms): <.main+3459>
cmplStd/test/std/tryExec.ci:48:[.064781, .064793) exec(1), time(0.017-0.017 ms): <.main+3477>
cmplStd/test/std/tryExec.ci:49:[.064793, .0647a5) exec(1), time(1.702-1.702 ms): <.main+3495>
cmplStd/test/std/tryExec.ci:50:[.0647a5, .0647b7) exec(1), time(0.027-0.027 ms): <.main+3513>
cmplStd/test/std/tryExec.ci:51:[.0647b7, .0647c9) exec(1), time(0.025-0.025 ms): <.main+3531>
cmplStd/test/std/tryExec.ci:52:[.0647c9, .0647db) exec(1), time(0.027-0.027 ms): <.main+3549>
cmplStd/test/std/tryExec.ci:53:[.0647db, .0647ed) exec(1), time(0.099-0.099 ms): <.main+3567>
cmplStd/test/lang/init.reference.ci:7:[.0647ed, .0647fa) exec(1), time(0.001-0.001 ms): <.main+3585>
cmplStd/test/lang/init.reference.ci:8:[.0647fa, .064803) exec(1), time(0.001-0.001 ms): <.main+3598>
cmplStd/test/lang/init.reference.ci:9:[.064803, .06480c) exec(1), time(0.000 ms): <.main+3607>
cmplStd/test/lang/init.reference.ci:10:[.06480c, .06481a) exec(1), time(0.001-0.001 ms): <.main+3616>
cmplStd/test/lang/init.reference.ci:12:[.06481a, .064823) exec(1), time(0.001-0.001 ms): <.main+3630>
cmplStd/test/lang/init.reference.ci:13:[.064823, .06482b) exec(1), time(0.000 ms): <.main+3639>
cmplStd/test/lang/init.reference.ci:14:[.06482b, .064833) exec(1), time(0.001-0.001 ms): <.main+3647>
cmplStd/test/lang/init.reference.ci:16:[.064833, .06483c) exec(1), time(0.001-0.001 ms): <.main+3655>
cmplStd/test/lang/init.reference.ci:17:[.06483c, .064845) exec(1), time(0.001-0.001 ms): <.main+3664>
cmplStd/test/lang/init.reference.ci:18:[.064845, .064853) exec(1), time(0.001-0.001 ms): <.main+3673>
cmplStd/test/lang/init.reference.ci:19:[.064853, .06485c) exec(1), time(0.001-0.001 ms): <.main+3687>
cmplStd/test/lang/init.reference.ci:20:[.06485c, .064865) exec(1), time(0.000 ms): <.main+3696>
cmplStd/test/lang/init.reference.ci:21:[.064865, .06486e) exec(1), time(0.001-0.001 ms): <.main+3705>
cmplStd/test/lang/init.reference.ci:23:[.06486e, .064877) exec(1), time(0.001-0.001 ms): <.main+3714>
cmplStd/test/lang/init.reference.ci:24:[.064877, .064885) exec(1), time(0.001-0.001 ms): <.main+3723>
cmplStd/test/lang/init.reference.ci:25:[.064885, .06488e) exec(1), time(0.001-0.001 ms): <.main+3737>
cmplStd/test/lang/init.reference.ci:27:[.06488e, .064896) exec(1), time(0.000 ms): <.main+3746>
cmplStd/test/lang/init.reference.ci:28:[.064896, .06489e) exec(1), time(0.001-0.001 ms): <.main+3754>
cmplStd/test/lang/init.reference.ci:29:[.06489e, .0648a6) exec(1), time(0.001-0.001 ms): <.main+3762>
cmplStd/test/lang/init.reference.ci:30:[.0648a6, .0648ae) exec(1), time(0.000 ms): <.main+3770>
cmplStd/test/lang/init.reference.ci:31:[.0648ae, .0648b6) exec(1), time(0.000 ms): <.main+3778>
cmplStd/test/lang/init.reference.ci:32:[.0648b6, .0648be) exec(1), time(0.001-0.001 ms): <.main+3786>
cmplStd/test/lang/init.reference.ci:35:[.0648be, .0648c7) exec(1), time(0.001-0.001 ms): <.main+3794>
cmplStd/test/lang/init.reference.ci:36:[.0648c7, .0648d0) exec(1), time(0.000 ms): <.main+3803>
cmplStd/test/lang/init.reference.ci:37:[.0648d0, .0648d9) exec(1), time(0.001-0.001 ms): <.main+3812>
cmplStd/test/lang/init.reference.ci:38:[.0648d9, .0648e2) exec(1), time(0.001-0.001 ms): <.main+3821>
cmplStd/test/lang/init.reference.ci:39:[.0648e2, .0648eb) exec(1), time(0.000 ms): <.main+3830>
cmplStd/test/lang/init.reference.ci:40:[.0648eb, .0648f4) exec(1), time(0.001-0.001 ms): <.main+3839>
cmplStd/test/lang/init.reference.ci:41:[.0648f4, .0648fd) exec(1), time(0.001-0.001 ms): <.main+3848>
cmplStd/test/lang/init.reference.ci:42:[.0648fd, .064906) exec(1), time(0.000 ms): <.main+3857>
cmplStd/test/lang/init.reference.ci:43:[.064906, .06490f) exec(1), time(0.001-0.001 ms): <.main+3866>
cmplStd/test/lang/init.reference.ci:44:[.06490f, .064918) exec(1), time(0.001-0.001 ms): <.main+3875>
cmplStd/test/lang/init.reference.ci:45:[.064918, .064921) exec(1), time(0.000 ms): <.main+3884>
cmplStd/test/lang/init.reference.ci:46:[.064921, .06492a) exec(1), time(0.001-0.001 ms): <.main+3893>
cmplStd/test/lang/init.reference.ci:47:[.06492a, .064933) exec(1), time(0.001-0.001 ms): <.main+3902>
cmplStd/test/lang/init.reference.ci:48:[.064933, .06493c) exec(1), time(0.000 ms): <.main+3911>
cmplStd/test/lang/init.reference.ci:49:[.06493c, .064945) exec(1), time(0.001-0.001 ms): <.main+3920>
cmplStd/test/lang/init.reference.ci:50:[.064945, .06494e) exec(1), time(0.001-0.001 ms): <.main+3929>
cmplStd/test/lang/init.reference.ci:51:[.06494e, .064957) exec(1), time(0.000 ms): <.main+3938>
cmplStd/test/lang/init.reference.ci:52:[.064957, .064960) exec(1), time(0.001-0.001 ms): <.main+3947>
cmplStd/test/lang/init.reference.ci:55:[.064960, .06496e) exec(1), time(0.002-0.002 ms): <.main+3956>
cmplStd/test/lang/init.reference.ci:56:[.06496e, .06497c) exec(1), time(0.001-0.001 ms): <.main+3970>
cmplStd/test/lang/init.reference.ci:57:[.06497c, .06498a) exec(1), time(0.001-0.001 ms): <.main+3984>
cmplStd/test/lang/init.reference.ci:58:[.06498a, .064998) exec(1), time(0.001-0.001 ms): <.main+3998>
cmplStd/test/lang/init.reference.ci:59:[.064998, .0649a6) exec(1), time(0.001-0.001 ms): <.main+4012>
cmplStd/test/lang/init.reference.ci:60:[.0649a6, .0649b4) exec(1), time(0.001-0.001 ms): <.main+4026>
cmplStd/test/lang/init.reference.ci:61:[.0649b4, .0649c2) exec(1), time(0.001-0.001 ms): <.main+4040>
cmplStd/test/lang/init.reference.ci:62:[.0649c2, .0649d0) exec(1), time(0.002-0.002 ms): <.main+4054>
cmplStd/test/lang/init.reference.ci:63:[.0649d0, .0649de) exec(1), time(0.001-0.001 ms): <.main+4068>
cmplStd/test/lang/init.reference.ci:64:[.0649de, .0649ec) exec(1), time(0.001-0.001 ms): <.main+4082>
cmplStd/test/lang/init.reference.ci:65:[.0649ec, .0649fa) exec(1), time(0.001-0.001 ms): <.main+4096>
cmplStd/test/lang/init.reference.ci:66:[.0649fa, .064a08) exec(1), time(0.001-0.001 ms): <.main+4110>
cmplStd/test/lang/init.reference.ci:67:[.064a08, .064a16) exec(1), time(0.001-0.001 ms): <.main+4124>
cmplStd/test/lang/init.reference.ci:68:[.064a16, .064a24) exec(1), time(0.002-0.002 ms): <.main+4138>
cmplStd/test/lang/init.reference.ci:69:[.064a24, .064a32) exec(1), time(0.001-0.001 ms): <.main+4152>
cmplStd/test/lang/init.reference.ci:70:[.064a32, .064a40) exec(1), time(0.001-0.001 ms): <.main+4166>
cmplStd/test/lang/init.reference.ci:71:[.064a40, .064a4e) exec(1), time(0.001-0.001 ms): <.main+4180>
cmplStd/test/lang/init.reference.ci:72:[.064a4e, .064a5c) exec(1), time(0.001-0.001 ms): <.main+4194>
cmplStd/test/lang/init.reference.ci:75:[.064a5c, .064a65) exec(1), time(0.001-0.001 ms): <.main+4208>
cmplStd/test/lang/init.reference.ci:76:[.064a65, .064a6e) exec(1), time(0.001-0.001 ms): <.main+4217>
cmplStd/test/lang/init.reference.ci:77:[.064a6e, .064a77) exec(1), time(0.000 ms): <.main+4226>
cmplStd/test/lang/init.reference.ci:78:[.064a77, .064a80) exec(1), time(0.001-0.001 ms): <.main+4235>
cmplStd/test/lang/init.reference.ci:79:[.064a80, .064a89) exec(1), time(0.001-0.001 ms): <.main+4244>
cmplStd/test/lang/init.reference.ci:80:[.064a89, .064a92) exec(1), time(0.000 ms): <.main+4253>
cmplStd/test/lang/init.reference.ci:81:[.064a92, .064a9b) exec(1), time(0.001-0.001 ms): <.main+4262>
cmplStd/test/lang/init.reference.ci:82:[.064a9b, .064aa4) exec(1), time(0.000 ms): <.main+4271>
cmplStd/test/lang/init.reference.ci:83:[.064aa4, .064aad) exec(1), time(0.001-0.001 ms): <.main+4280>
cmplStd/test/lang/init.reference.ci:84:[.064aad, .064ab6) exec(1), time(0.001-0.001 ms): <.main+4289>
cmplStd/test/lang/init.reference.ci:85:[.064ab6, .064abf) exec(1), time(0.000 ms): <.main+4298>
cmplStd/test/lang/init.reference.ci:86:[.064abf, .064ac8) exec(1), time(0.001-0.001 ms): <.main+4307>
cmplStd/test/lang/init.reference.ci:87:[.064ac8, .064ad1) exec(1), time(0.001-0.001 ms): <.main+4316>
cmplStd/test/lang/init.reference.ci:88:[.064ad1, .064ada) exec(1), time(0.000 ms): <.main+4325>
cmplStd/test/lang/init.reference.ci:89:[.064ada, .064ae3) exec(1), time(0.001-0.001 ms): <.main+4334>
cmplStd/test/lang/init.reference.ci:90:[.064ae3, .064aec) exec(1), time(0.000 ms): <.main+4343>
cmplStd/test/lang/init.reference.ci:91:[.064aec, .064af5) exec(1), time(0.001-0.001 ms): <.main+4352>
cmplStd/test/lang/init.reference.ci:92:[.064af5, .064afe) exec(1), time(0.001-0.001 ms): <.main+4361>
cmplStd/test/lang/init.reference.ci:95:[.064afe, .064b07) exec(1), time(0.001-0.001 ms): <.main+4370>
cmplStd/test/lang/init.reference.ci:96:[.064b07, .064b15) exec(1), time(0.002-0.002 ms): <.main+4379>
cmplStd/test/lang/init.reference.ci:97:[.064b15, .064b1e) exec(1), time(0.001-0.001 ms): <.main+4393>
cmplStd/test/lang/init.reference.ci:99:[.064b1e, .064b27) exec(1), time(0.000 ms): <.main+4402>
cmplStd/test/lang/init.reference.ci:105:[.064b27, .064b34) exec(1), time(0.001-0.001 ms): <.main+4411>
cmplStd/test/lang/init.reference.ci:108:[.064b34, .064b3c) exec(1), time(0.001-0.001 ms): <.main+4424>
cmplStd/test/lang/init.variable.ci:3:[.064b3c, .064b41) exec(1), time(0.001-0.001 ms): <.main+4432>
cmplStd/test/lang/init.variable.ci:7:[.064b41, .064b4a) exec(1), time(0.001-0.001 ms): <.main+4437>
cmplStd/test/lang/init.variable.ci:24:[.064b4a, .064b57) exec(1), time(0.001-0.001 ms): <.main+4446>
::[.064b57, .064b5c) exec(1), time(0.000 ms): <.main+4459>
cmplStd/test/lang/init.variable.ci:24:[.064b4a, .064b5c) exec(0), time(0.000 ms): <.main+4446>
cmplStd/test/lang/init.variable.ci:33:[.064b5c, .064b69) exec(1), time(0.022-0.022 ms): <.main+4464>
cmplStd/test/lang/init.variable.ci:33:[.064b69, .064b7b) exec(1), time(0.002-0.002 ms): <.main+4477>
::[.064b7b, .064b85) exec(1), time(0.002-0.002 ms): <.main+4495>
cmplStd/test/lang/init.variable.ci:33:[.064b5c, .064b85) exec(0), time(0.000 ms): <.main+4464>
cmplStd/test/lang/init.variable.ci:41:[.064b85, .064b92) exec(1), time(0.020-0.020 ms): <.main+4505>
cmplStd/test/lang/init.variable.ci:41:[.064b92, .064ba4) exec(1), time(0.002-0.002 ms): <.main+4518>
::[.064ba4, .064bae) exec(1), time(0.002-0.002 ms): <.main+4536>
cmplStd/test/lang/init.variable.ci:41:[.064b85, .064bae) exec(0), time(0.000 ms): <.main+4505>
cmplStd/test/lang/function.ci:12:[.064bae, .064bc7) exec(1), time(0.018-0.018 ms): <.main+4546>
cmplStd/test/lang/function.ci:15:[.064bc7, .064bd0) exec(1), time(0.001-0.001 ms): <.main+4571>
cmplStd/test/lang/function.ci:18:[.064bd0, .064be8) exec(1), time(0.017-0.017 ms): <.main+4580>
cmplStd/test/lang/function.ci:21:[.064be8, .064bf1) exec(1), time(0.001-0.001 ms): <.main+4604>
cmplStd/test/lang/function.ci:24:[.064bf1, .064c09) exec(1), time(0.018-0.018 ms): <.main+4613>
cmplStd/test/lang/function.ci:27:[.064c09, .064c11) exec(1), time(0.001-0.001 ms): <.main+4637>
cmplStd/test/lang/function.ci:30:[.064c11, .064c29) exec(1), time(0.017-0.017 ms): <.main+4645>
cmplStd/test/lang/function.ci:46:[.064c29, .064c3d) exec(1), time(12.082-12.082 ms): <.main+4669>
cmplStd/test/lang/reflect.ci:3:[.064c3d, .064c45) exec(1), time(0.001-0.001 ms): <.main+4689>
cmplStd/test/lang/reflect.ci:4:[.064c45, .064c4d) exec(1), time(0.001-0.001 ms): <.main+4697>
cmplStd/test/lang/reflect.ci:5:[.064c4d, .064c55) exec(1), time(0.001-0.001 ms): <.main+4705>
cmplStd/test/lang/reflect.ci:6:[.064c55, .064c5d) exec(1), time(0.001-0.001 ms): <.main+4713>
cmplStd/test/lang/reflect.ci:7:[.064c5d, .064c65) exec(1), time(0.000 ms): <.main+4721>
cmplStd/test/lang/reflect.ci:8:[.064c65, .064c6d) exec(1), time(0.001-0.001 ms): <.main+4729>
cmplStd/test/lang/reflect.ci:9:[.064c6d, .064c75) exec(1), time(0.000 ms): <.main+4737>
cmplStd/test/lang/reflect.ci:10:[.064c75, .064c7d) exec(1), time(0.001-0.001 ms): <.main+4745>
cmplStd/test/lang/reflect.ci:11:[.064c7d, .064c85) exec(1), time(0.000 ms): <.main+4753>
cmplStd/test/lang/reflect.ci:12:[.064c85, .064c8d) exec(1), time(0.001-0.001 ms): <.main+4761>
cmplStd/test/lang/reflect.ci:13:[.064c8d, .064c95) exec(1), time(0.001-0.001 ms): <.main+4769>
cmplStd/test/lang/reflect.ci:14:[.064c95, .064c9d) exec(1), time(0.001-0.001 ms): <.main+4777>
cmplStd/test/lang/reflect.ci:15:[.064c9d, .064ca5) exec(1), time(0.001-0.001 ms): <.main+4785>
cmplStd/test/lang/reflect.ci:16:[.064ca5, .064cad) exec(1), time(0.001-0.001 ms): <.main+4793>
cmplStd/test/lang/reflect.ci:17:[.064cad, .064cb5) exec(1), time(0.001-0.001 ms): <.main+4801>
cmplStd/test/lang/reflect.ci:18:[.064cb5, .064cbd) exec(1), time(0.001-0.001 ms): <.main+4809>
cmplStd/test/lang/reflect.ci:19:[.064cbd, .064cc5) exec(1), time(0.001-0.001 ms): <.main+4817>
cmplStd/test/lang/reflect.ci:20:[.064cc5, .064ccd) exec(1), time(0.001-0.001 ms): <.main+4825>
cmplStd/test/lang/reflect.ci:30:[.064ccd, .064cd6) exec(1), time(0.001-0.001 ms): <.main+4833>
cmplStd/test/lang/reflect.ci:31:[.064cd6, .064ce2) exec(1), time(0.026-0.026 ms): <.main+4842>
cmplStd/test/lang/reflect.ci:32:[.064ce2, .064cef) exec(1), time(0.002-0.002 ms): <.main+4854>
cmplStd/test/lang/reflect.ci:33:[.064cef, .064cfc) exec(1), time(0.002-0.002 ms): <.main+4867>
cmplStd/test/lang/reflect.ci:34:[.064cfc, .064d08) exec(1), time(0.021-0.021 ms): <.main+4880>
cmplStd/test/lang/reflect.ci:35:[.064d08, .064d14) exec(1), time(0.021-0.021 ms): <.main+4892>
cmplStd/test/lang/reflect.ci:37:[.064d14, .064d20) exec(1), time(0.020-0.020 ms): <.main+4904>
cmplStd/test/lang/reflect.ci:38:[.064d20, .064d2c) exec(1), time(0.020-0.020 ms): <.main+4916>
cmplStd/test/lang/reflect.ci:39:[.064d2c, .064d39) exec(1), time(0.002-0.002 ms): <.main+4928>
cmplStd/test/lang/reflect.ci:40:[.064d39, .064d46) exec(1), time(0.002-0.002 ms): <.main+4941>
cmplStd/test/lang/reflect.ci:41:[.064d46, .064d52) exec(1), time(0.020-0.020 ms): <.main+4954>
cmplStd/test/lang/reflect.ci:42:[.064d52, .064d5e) exec(1), time(0.020-0.020 ms): <.main+4966>
cmplStd/test/lang/reflect.ci:44:[.064d5e, .064d6a) exec(1), time(0.027-0.027 ms): <.main+4978>
cmplStd/test/lang/reflect.ci:45:[.064d6a, .064d77) exec(1), time(0.002-0.002 ms): <.main+4990>
cmplStd/test/lang/reflect.ci:46:[.064d77, .064d84) exec(1), time(0.002-0.002 ms): <.main+5003>
cmplStd/test/lang/reflect.ci:48:[.064d84, .064d90) exec(1), time(0.017-0.017 ms): <.main+5016>
cmplStd/test/lang/reflect.ci:49:[.064d90, .064d9d) exec(1), time(0.002-0.002 ms): <.main+5028>
cmplStd/test/lang/reflect.ci:50:[.064d9d, .064daa) exec(1), time(0.002-0.002 ms): <.main+5041>
cmplStd/test/lang/init.member.ci:34:[.064daa, .064daf) exec(1), time(0.001-0.001 ms): <.main+5054>
cmplStd/test/lang/init.member.ci:37:[.064daf, .064db8) exec(1), time(0.001-0.001 ms): <.main+5059>
cmplStd/test/lang/init.member.ci:40:[.064db8, .064dc1) exec(1), time(0.001-0.001 ms): <.main+5068>
cmplStd/test/lang/init.member.ci:43:[.064dc1, .064dca) exec(1), time(0.000 ms): <.main+5077>
::[.064dca, .064dcf) exec(1), time(0.001-0.001 ms): <.main+5086>
cmplStd/test/lang/init.member.ci:43:[.064dc1, .064dcf) exec(0), time(0.000 ms): <.main+5077>
cmplStd/test/lang/init.member.ci:46:[.064dcf, .064dd8) exec(1), time(0.001-0.001 ms): <.main+5091>
cmplStd/test/lang/init.member.ci:46:[.064dd8, .064de1) exec(1), time(0.001-0.001 ms): <.main+5100>
cmplStd/test/lang/init.member.ci:46:[.064dcf, .064de1) exec(0), time(0.000 ms): <.main+5091>
cmplStd/test/lang/init.member.ci:49:[.064de1, .064dea) exec(1), time(0.000 ms): <.main+5109>
cmplStd/test/lang/init.member.ci:49:[.064dea, .064df3) exec(1), time(0.001-0.001 ms): <.main+5118>
cmplStd/test/lang/init.member.ci:49:[.064de1, .064df3) exec(0), time(0.000 ms): <.main+5109>
cmplStd/test/lang/init.member.ci:53:[.064df3, .064dfc) exec(1), time(0.000 ms): <.main+5127>
cmplStd/test/lang/init.member.ci:54:[.064dfc, .064e05) exec(1), time(0.001-0.001 ms): <.main+5136>
cmplStd/test/lang/init.member.ci:55:[.064e05, .064e0e) exec(1), time(0.000 ms): <.main+5145>
cmplStd/test/lang/init.member.ci:56:[.064e0e, .064e17) exec(1), time(0.001-0.001 ms): <.main+5154>
cmplStd/test/lang/init.member.ci:59:[.064e17, .064e20) exec(1), time(0.001-0.001 ms): <.main+5163>
cmplStd/test/lang/init.member.ci:60:[.064e20, .064e29) exec(1), time(0.001-0.001 ms): <.main+5172>
cmplStd/test/lang/init.member.ci:64:[.064e29, .064e32) exec(1), time(0.001-0.001 ms): <.main+5181>
cmplStd/test/lang/init.member.ci:65:[.064e32, .064e3b) exec(1), time(0.001-0.001 ms): <.main+5190>
cmplStd/test/lang/init.member.ci:52:[.064df3, .064e3b) exec(0), time(0.000 ms): <.main+5127>
cmplStd/test/lang/init.method.ci:18:[.064e3b, .064e44) exec(1), time(0.001-0.001 ms): <.main+5199>
cmplStd/test/lang/init.method.ci:64:[.064e44, .064e4d) exec(1), time(0.000 ms): <.main+5208>
::[.064e4d, .064e55) exec(1), time(0.001-0.001 ms): <.main+5217>
::[.064e55, .064e5e) exec(1), time(0.000 ms): <.main+5225>
cmplStd/test/lang/init.method.ci:62:[.064e44, .064e5e) exec(0), time(0.000 ms): <.main+5208>
cmplStd/test/lang/init.array.ci:11:[.064e5e, .064e6b) exec(1), time(0.001-0.001 ms): <.main+5234>
cmplStd/test/lang/init.array.ci:11:[.064e6b, .064e78) exec(1), time(0.001-0.001 ms): <.main+5247>
cmplStd/test/lang/init.array.ci:11:[.064e78, .064e85) exec(1), time(0.001-0.001 ms): <.main+5260>
cmplStd/test/lang/init.array.ci:11:[.064e85, .064e92) exec(1), time(0.001-0.001 ms): <.main+5273>
cmplStd/test/lang/init.array.ci:11:[.064e92, .064e9f) exec(1), time(0.001-0.001 ms): <.main+5286>
cmplStd/test/lang/init.array.ci:11:[.064e9f, .064eac) exec(1), time(0.001-0.001 ms): <.main+5299>
cmplStd/test/lang/init.array.ci:11:[.064eac, .064eb9) exec(1), time(0.000 ms): <.main+5312>
cmplStd/test/lang/init.array.ci:11:[.064e5e, .064eb9) exec(0), time(0.000 ms): <.main+5234>
cmplStd/test/lang/init.array.ci:18:[.064eb9, .064ec2) exec(1), time(0.001-0.001 ms): <.main+5325>
cmplStd/test/lang/init.array.ci:19:[.064ec2, .064ecc) exec(1), time(0.001-0.001 ms): <.main+5334>
cmplStd/test/lang/init.array.ci:22:[.064ecc, .064ed5) exec(1), time(0.001-0.001 ms): <.main+5344>
cmplStd/test/lang/init.array.ci:23:[.064ed5, .064ee3) exec(1), time(0.001-0.001 ms): <.main+5353>
cmplStd/test/lang/init.array.ci:26:[.064ee3, .064eeb) exec(1), time(0.001-0.001 ms): <.main+5367>
cmplStd/test/lang/init.array.ci:27:[.064eeb, .064ef3) exec(1), time(0.001-0.001 ms): <.main+5375>
cmplStd/test/lang/init.array.ci:30:[.064ef3, .064efb) exec(1), time(0.001-0.001 ms): <.main+5383>
cmplStd/test/lang/init.array.ci:34:[.064efb, .064f06) exec(1), time(0.001-0.001 ms): <.main+5391>
cmplStd/test/lang/init.array.ci:34:[.064f06, .064f11) exec(1), time(0.001-0.001 ms): <.main+5402>
cmplStd/test/lang/init.array.ci:34:[.064f11, .064f1c) exec(1), time(0.002-0.002 ms): <.main+5413>
cmplStd/test/lang/init.array.ci:34:[.064f1c, .064f27) exec(1), time(0.002-0.002 ms): <.main+5424>
cmplStd/test/lang/init.array.ci:34:[.064f27, .064f32) exec(1), time(0.001-0.001 ms): <.main+5435>
cmplStd/test/lang/init.array.ci:34:[.064f32, .064f3d) exec(1), time(0.001-0.001 ms): <.main+5446>
cmplStd/test/lang/init.array.ci:34:[.064f3d, .064f44) exec(1), time(0.002-0.002 ms): <.main+5457>
cmplStd/test/lang/init.array.ci:34:[.064efb, .064f44) exec(0), time(0.000 ms): <.main+5391>
cmplStd/test/lang/init.array.ci:37:[.064f44, .064f4d) exec(1), time(0.001-0.001 ms): <.main+5464>
cmplStd/test/lang/init.array.ci:40:[.064f4d, .064f5b) exec(1), time(0.001-0.001 ms): <.main+5473>
cmplStd/test/lang/recUnion.ci:26:[.064f5b, .064f62) exec(1), time(0.002-0.002 ms): <.main+5487>
cmplStd/test/lang/recUnion.ci:26:[.064f62, .064f69) exec(1), time(0.002-0.002 ms): <.main+5494>
cmplStd/test/lang/recUnion.ci:26:[.064f69, .064f70) exec(1), time(0.001-0.001 ms): <.main+5501>
cmplStd/test/lang/recUnion.ci:26:[.064f5b, .064f70) exec(0), time(0.000 ms): <.main+5487>
cmplStd/test/lang/recUnion.ci:27:[.064f70, .064f77) exec(1), time(0.002-0.002 ms): <.main+5508>
cmplStd/test/lang/recUnion.ci:27:[.064f77, .064f82) exec(1), time(0.002-0.002 ms): <.main+5515>
cmplStd/test/lang/recUnion.ci:27:[.064f82, .064f89) exec(1), time(0.001-0.001 ms): <.main+5526>
cmplStd/test/lang/recUnion.ci:27:[.064f70, .064f89) exec(0), time(0.000 ms): <.main+5508>
cmplStd/test/lang/recUnion.ci:28:[.064f89, .064f94) exec(1), time(0.001-0.001 ms): <.main+5533>
cmplStd/test/lang/recUnion.ci:28:[.064f94, .064f9f) exec(1), time(0.002-0.002 ms): <.main+5544>
cmplStd/test/lang/recUnion.ci:28:[.064f9f, .064faa) exec(1), time(0.001-0.001 ms): <.main+5555>
cmplStd/test/lang/recUnion.ci:28:[.064f89, .064faa) exec(0), time(0.000 ms): <.main+5533>
cmplStd/test/lang/recUnion.ci:30:[.064faa, .064fb3) exec(1), time(0.001-0.001 ms): <.main+5566>
cmplStd/test/lang/recUnion.ci:30:[.064faa, .064fb3) exec(0), time(0.000 ms): <.main+5566>
cmplStd/test/lang/recUnion.ci:31:[.064fb3, .064fba) exec(1), time(0.001-0.001 ms): <.main+5575>
cmplStd/test/lang/recUnion.ci:31:[.064fba, .064fc1) exec(1), time(0.001-0.001 ms): <.main+5582>
cmplStd/test/lang/recUnion.ci:31:[.064fc1, .064fcc) exec(1), time(0.002-0.002 ms): <.main+5589>
cmplStd/test/lang/recUnion.ci:31:[.064fb3, .064fcc) exec(0), time(0.000 ms): <.main+5575>
cmplStd/test/lang/useOperator.ci:5:[.064fcc, .064fd5) exec(1), time(0.001-0.001 ms): <.main+5600>
cmplStd/test/lang/useOperator.ci:7:[.064fd5, .064fe0) exec(1), time(0.002-0.002 ms): <.main+5609>
cmplStd/test/lang/useOperator.ci:8:[.064fe0, .064feb) exec(1), time(0.002-0.002 ms): <.main+5620>
cmplStd/test/lang/useOperator.ci:17:[.064feb, .064ffe) exec(1), time(0.004-0.004 ms): <.main+5631>
cmplStd/test/lang/useOperator.ci:18:[.064ffe, .065011) exec(1), time(0.005-0.005 ms): <.main+5650>
cmplStd/test/lang/useOperator.ci:19:[.065011, .065024) exec(1), time(0.004-0.004 ms): <.main+5669>
cmplStd/test/lang/useOperator.ci:22:[.065024, .065031) exec(1), time(0.003-0.003 ms): <.main+5688>
cmplStd/test/lang/useOperator.ci:23:[.065031, .065044) exec(1), time(0.004-0.004 ms): <.main+5701>
cmplStd/test/lang/useOperator.ci:24:[.065044, .065058) exec(1), time(0.004-0.004 ms): <.main+5720>
cmplStd/test/lang/useOperator.ci:25:[.065058, .06506b) exec(1), time(0.004-0.004 ms): <.main+5740>
cmplStd/test/lang/useOperator.ci:26:[.06506b, .06507f) exec(1), time(0.005-0.005 ms): <.main+5759>
cmplStd/test/lang/useOperator.ci:27:[.06507f, .065092) exec(1), time(0.005-0.005 ms): <.main+5779>
cmplStd/test/lang/useOperator.ci:28:[.065092, .0650a6) exec(1), time(0.005-0.005 ms): <.main+5798>
cmplStd/test/lang/useOperator.ci:30:[.0650a6, .0650b1) exec(1), time(0.002-0.002 ms): <.main+5818>
cmplStd/test/lang/useOperator.ci:31:[.0650b1, .0650bc) exec(1), time(0.002-0.002 ms): <.main+5829>
cmplStd/test/lang/useOperator.ci:32:[.0650bc, .0650c8) exec(1), time(0.002-0.002 ms): <.main+5840>
cmplStd/test/lang/useOperator.ci:33:[.0650c8, .0650d5) exec(1), time(0.003-0.003 ms): <.main+5852>
cmplStd/test/lang/useOperator.ci:34:[.0650d5, .0650e2) exec(1), time(0.003-0.003 ms): <.main+5865>
cmplStd/test/lang/useOperator.ci:35:[.0650e2, .0650f5) exec(1), time(0.004-0.004 ms): <.main+5878>
cmplStd/test/lang/useOperator.ci:36:[.0650f5, .065108) exec(1), time(0.004-0.004 ms): <.main+5897>
cmplStd/test/lang/useOperator.ci:37:[.065108, .06511b) exec(1), time(0.005-0.005 ms): <.main+5916>
cmplStd/test/lang/useOperator.ci:38:[.06511b, .06512e) exec(1), time(0.004-0.004 ms): <.main+5935>
cmplStd/test/lang/useOperator.ci:39:[.06512e, .065141) exec(1), time(0.004-0.004 ms): <.main+5954>
cmplStd/test/lang/useOperator.ci:40:[.065141, .065154) exec(1), time(0.004-0.004 ms): <.main+5973>
cmplStd/test/lang/useOperator.ci:41:[.065154, .065167) exec(1), time(0.004-0.004 ms): <.main+5992>
cmplStd/test/lang/useOperator.ci:42:[.065167, .06517a) exec(1), time(0.004-0.004 ms): <.main+6011>
cmplStd/test/lang/useOperator.ci:43:[.06517a, .06518b) exec(1), time(0.003-0.003 ms): <.main+6030>
cmplStd/test/lang/useOperator.ci:44:[.06518b, .06519c) exec(1), time(0.004-0.004 ms): <.main+6047>
cmplStd/test/lang/useOperator.ci:45:[.06519c, .0651aa) exec(1), time(0.004-0.004 ms): <.main+6064>
cmplStd/test/lang/useOperator.ci:46:[.0651aa, .0651bd) exec(1), time(0.004-0.004 ms): <.main+6078>
cmplStd/test/lang/useOperator.ci:47:[.0651bd, .0651d1) exec(1), time(0.005-0.005 ms): <.main+6097>
cmplStd/test/lang/useOperator.ci:48:[.0651d1, .0651e4) exec(1), time(0.004-0.004 ms): <.main+6117>
cmplStd/test/lang/useOperator.ci:49:[.0651e4, .0651f8) exec(1), time(0.005-0.005 ms): <.main+6136>
cmplStd/test/lang/useOperator.ci:50:[.0651f8, .06520b) exec(1), time(0.004-0.004 ms): <.main+6156>
cmplStd/test/lang/useOperator.ci:51:[.06520b, .06521f) exec(1), time(0.005-0.005 ms): <.main+6175>
cmplStd/test/lang/useOperator.ci:53:[.06521f, .06522a) exec(1), time(0.001-0.001 ms): <.main+6195>
cmplStd/test/lang/useOperator.ci:54:[.06522a, .065235) exec(1), time(0.002-0.002 ms): <.main+6206>
cmplStd/test/lang/useOperator.ci:55:[.065235, .065241) exec(1), time(0.002-0.002 ms): <.main+6217>
cmplStd/test/lang/useOperator.ci:56:[.065241, .06524e) exec(1), time(0.003-0.003 ms): <.main+6229>
cmplStd/test/lang/useOperator.ci:57:[.06524e, .06525b) exec(1), time(0.003-0.003 ms): <.main+6242>
cmplStd/test/lang/useOperator.ci:58:[.06525b, .06526e) exec(1), time(0.004-0.004 ms): <.main+6255>
cmplStd/test/lang/useOperator.ci:59:[.06526e, .065281) exec(1), time(0.004-0.004 ms): <.main+6274>
cmplStd/test/lang/useOperator.ci:60:[.065281, .065294) exec(1), time(0.004-0.004 ms): <.main+6293>
cmplStd/test/lang/useOperator.ci:61:[.065294, .0652a7) exec(1), time(0.004-0.004 ms): <.main+6312>
cmplStd/test/lang/useOperator.ci:62:[.0652a7, .0652ba) exec(1), time(0.004-0.004 ms): <.main+6331>
cmplStd/test/lang/useOperator.ci:63:[.0652ba, .0652cd) exec(1), time(0.004-0.004 ms): <.main+6350>
cmplStd/test/lang/useOperator.ci:64:[.0652cd, .0652e0) exec(1), time(0.004-0.004 ms): <.main+6369>
cmplStd/test/lang/useOperator.ci:65:[.0652e0, .0652f3) exec(1), time(0.004-0.004 ms): <.main+6388>
cmplStd/test/lang/useOperator.ci:66:[.0652f3, .065304) exec(1), time(0.003-0.003 ms): <.main+6407>
cmplStd/test/lang/useOperator.ci:67:[.065304, .065315) exec(1), time(0.004-0.004 ms): <.main+6424>
cmplStd/test/lang/useOperator.ci:68:[.065315, .065323) exec(1), time(0.004-0.004 ms): <.main+6441>
cmplStd/test/lang/useOperator.ci:69:[.065323, .065336) exec(1), time(0.004-0.004 ms): <.main+6455>
cmplStd/test/lang/useOperator.ci:70:[.065336, .06534a) exec(1), time(0.005-0.005 ms): <.main+6474>
cmplStd/test/lang/useOperator.ci:71:[.06534a, .06535d) exec(1), time(0.004-0.004 ms): <.main+6494>
cmplStd/test/lang/useOperator.ci:72:[.06535d, .065371) exec(1), time(0.004-0.004 ms): <.main+6513>
cmplStd/test/lang/useOperator.ci:73:[.065371, .065384) exec(1), time(0.004-0.004 ms): <.main+6533>
cmplStd/test/lang/useOperator.ci:74:[.065384, .065398) exec(1), time(0.005-0.005 ms): <.main+6552>
cmplStd/test/lang/useOperator.ci:76:[.065398, .0653a3) exec(1), time(0.002-0.002 ms): <.main+6572>
cmplStd/test/lang/useOperator.ci:77:[.0653a3, .0653ae) exec(1), time(0.001-0.001 ms): <.main+6583>
cmplStd/test/lang/useOperator.ci:78:[.0653ae, .0653ba) exec(1), time(0.002-0.002 ms): <.main+6594>
cmplStd/test/lang/useOperator.ci:79:[.0653ba, .0653c7) exec(1), time(0.002-0.002 ms): <.main+6606>
cmplStd/test/lang/useOperator.ci:80:[.0653c7, .0653d4) exec(1), time(0.003-0.003 ms): <.main+6619>
cmplStd/test/lang/useOperator.ci:81:[.0653d4, .0653e7) exec(1), time(0.004-0.004 ms): <.main+6632>
cmplStd/test/lang/useOperator.ci:82:[.0653e7, .0653fa) exec(1), time(0.004-0.004 ms): <.main+6651>
cmplStd/test/lang/useOperator.ci:83:[.0653fa, .06540d) exec(1), time(0.004-0.004 ms): <.main+6670>
cmplStd/test/lang/useOperator.ci:84:[.06540d, .065420) exec(1), time(0.004-0.004 ms): <.main+6689>
cmplStd/test/lang/useOperator.ci:85:[.065420, .065433) exec(1), time(0.004-0.004 ms): <.main+6708>
cmplStd/test/lang/useOperator.ci:86:[.065433, .065446) exec(1), time(0.004-0.004 ms): <.main+6727>
cmplStd/test/lang/useOperator.ci:87:[.065446, .065459) exec(1), time(0.004-0.004 ms): <.main+6746>
cmplStd/test/lang/useOperator.ci:88:[.065459, .06546c) exec(1), time(0.004-0.004 ms): <.main+6765>
cmplStd/test/lang/useOperator.ci:89:[.06546c, .06547d) exec(1), time(0.003-0.003 ms): <.main+6784>
cmplStd/test/lang/useOperator.ci:90:[.06547d, .06548e) exec(1), time(0.004-0.004 ms): <.main+6801>
cmplStd/test/lang/useOperator.ci:91:[.06548e, .06549c) exec(1), time(0.004-0.004 ms): <.main+6818>
cmplStd/test/lang/useOperator.ci:92:[.06549c, .0654af) exec(1), time(0.004-0.004 ms): <.main+6832>
cmplStd/test/lang/useOperator.ci:93:[.0654af, .0654c3) exec(1), time(0.004-0.004 ms): <.main+6851>
cmplStd/test/lang/useOperator.ci:94:[.0654c3, .0654d6) exec(1), time(0.005-0.005 ms): <.main+6871>
cmplStd/test/lang/useOperator.ci:95:[.0654d6, .0654ea) exec(1), time(0.005-0.005 ms): <.main+6890>
cmplStd/test/lang/useOperator.ci:96:[.0654ea, .0654fd) exec(1), time(0.004-0.004 ms): <.main+6910>
cmplStd/test/lang/useOperator.ci:97:[.0654fd, .065511) exec(1), time(0.005-0.005 ms): <.main+6929>
cmplStd/test/lang/useOperator.ci:99:[.065511, .06551c) exec(1), time(0.002-0.002 ms): <.main+6949>
cmplStd/test/lang/useOperator.ci:100:[.06551c, .065527) exec(1), time(0.002-0.002 ms): <.main+6960>
cmplStd/test/lang/useOperator.ci:101:[.065527, .065533) exec(1), time(0.002-0.002 ms): <.main+6971>
cmplStd/test/lang/useOperator.ci:102:[.065533, .065540) exec(1), time(0.003-0.003 ms): <.main+6983>
cmplStd/test/lang/useOperator.ci:103:[.065540, .06554d) exec(1), time(0.003-0.003 ms): <.main+6996>
cmplStd/test/lang/useOperator.ci:104:[.06554d, .065560) exec(1), time(0.004-0.004 ms): <.main+7009>
cmplStd/test/lang/useOperator.ci:105:[.065560, .065573) exec(1), time(0.004-0.004 ms): <.main+7028>
cmplStd/test/lang/useOperator.ci:106:[.065573, .065586) exec(1), time(0.004-0.004 ms): <.main+7047>
cmplStd/test/lang/useOperator.ci:107:[.065586, .065599) exec(1), time(0.005-0.005 ms): <.main+7066>
cmplStd/test/lang/useOperator.ci:108:[.065599, .0655ac) exec(1), time(0.005-0.005 ms): <.main+7085>
cmplStd/test/lang/useOperator.ci:109:[.0655ac, .0655bf) exec(1), time(0.004-0.004 ms): <.main+7104>
cmplStd/test/lang/useOperator.ci:110:[.0655bf, .0655d2) exec(1), time(0.004-0.004 ms): <.main+7123>
cmplStd/test/lang/useOperator.ci:111:[.0655d2, .0655e5) exec(1), time(0.005-0.005 ms): <.main+7142>
cmplStd/test/lang/useOperator.ci:112:[.0655e5, .0655f6) exec(1), time(0.004-0.004 ms): <.main+7161>
cmplStd/test/lang/useOperator.ci:113:[.0655f6, .065607) exec(1), time(0.004-0.004 ms): <.main+7178>
cmplStd/test/lang/useOperator.ci:114:[.065607, .065615) exec(1), time(0.003-0.003 ms): <.main+7195>
cmplStd/test/lang/useOperator.ci:115:[.065615, .065628) exec(1), time(0.005-0.005 ms): <.main+7209>
cmplStd/test/lang/useOperator.ci:116:[.065628, .06563c) exec(1), time(0.005-0.005 ms): <.main+7228>
cmplStd/test/lang/useOperator.ci:117:[.06563c, .06564f) exec(1), time(0.005-0.005 ms): <.main+7248>
cmplStd/test/lang/useOperator.ci:118:[.06564f, .065663) exec(1), time(0.006-0.006 ms): <.main+7267>
cmplStd/test/lang/useOperator.ci:119:[.065663, .065676) exec(1), time(0.004-0.004 ms): <.main+7287>
cmplStd/test/lang/useOperator.ci:120:[.065676, .06568a) exec(1), time(0.005-0.005 ms): <.main+7306>
cmplStd/test/lang/useOperator.ci:122:[.06568a, .065695) exec(1), time(0.001-0.001 ms): <.main+7326>
cmplStd/test/lang/useOperator.ci:123:[.065695, .0656a0) exec(1), time(0.002-0.002 ms): <.main+7337>
cmplStd/test/lang/useOperator.ci:124:[.0656a0, .0656ac) exec(1), time(0.002-0.002 ms): <.main+7348>
cmplStd/test/lang/useOperator.ci:125:[.0656ac, .0656b9) exec(1), time(0.003-0.003 ms): <.main+7360>
cmplStd/test/lang/useOperator.ci:126:[.0656b9, .0656c6) exec(1), time(0.002-0.002 ms): <.main+7373>
cmplStd/test/lang/useOperator.ci:127:[.0656c6, .0656d9) exec(1), time(0.005-0.005 ms): <.main+7386>
cmplStd/test/lang/useOperator.ci:128:[.0656d9, .0656ec) exec(1), time(0.004-0.004 ms): <.main+7405>
cmplStd/test/lang/useOperator.ci:129:[.0656ec, .0656ff) exec(1), time(0.005-0.005 ms): <.main+7424>
cmplStd/test/lang/useOperator.ci:130:[.0656ff, .065712) exec(1), time(0.004-0.004 ms): <.main+7443>
cmplStd/test/lang/useOperator.ci:131:[.065712, .065725) exec(1), time(0.005-0.005 ms): <.main+7462>
cmplStd/test/lang/useOperator.ci:132:[.065725, .065738) exec(1), time(0.004-0.004 ms): <.main+7481>
cmplStd/test/lang/useOperator.ci:133:[.065738, .06574b) exec(1), time(0.004-0.004 ms): <.main+7500>
cmplStd/test/lang/useOperator.ci:134:[.06574b, .06575e) exec(1), time(0.005-0.005 ms): <.main+7519>
cmplStd/test/lang/useOperator.ci:135:[.06575e, .06576f) exec(1), time(0.004-0.004 ms): <.main+7538>
cmplStd/test/lang/useOperator.ci:136:[.06576f, .065780) exec(1), time(0.003-0.003 ms): <.main+7555>
cmplStd/test/lang/useOperator.ci:137:[.065780, .06578e) exec(1), time(0.004-0.004 ms): <.main+7572>
cmplStd/test/lang/useOperator.ci:138:[.06578e, .0657a1) exec(1), time(0.004-0.004 ms): <.main+7586>
cmplStd/test/lang/useOperator.ci:139:[.0657a1, .0657b5) exec(1), time(0.005-0.005 ms): <.main+7605>
cmplStd/test/lang/useOperator.ci:140:[.0657b5, .0657c8) exec(1), time(0.004-0.004 ms): <.main+7625>
cmplStd/test/lang/useOperator.ci:141:[.0657c8, .0657dc) exec(1), time(0.005-0.005 ms): <.main+7644>
cmplStd/test/lang/useOperator.ci:142:[.0657dc, .0657ef) exec(1), time(0.004-0.004 ms): <.main+7664>
cmplStd/test/lang/useOperator.ci:143:[.0657ef, .065803) exec(1), time(0.005-0.005 ms): <.main+7683>
cmplStd/test/lang/useOperator.ci:145:[.065803, .06580c) exec(1), time(0.001-0.001 ms): <.main+7703>
cmplStd/test/lang/useOperator.ci:146:[.06580c, .065815) exec(1), time(0.001-0.001 ms): <.main+7712>
cmplStd/test/lang/useOperator.ci:147:[.065815, .06581d) exec(1), time(0.000 ms): <.main+7721>
cmplStd/test/lang/useOperator.ci:148:[.06581d, .065826) exec(1), time(0.002-0.002 ms): <.main+7729>
cmplStd/test/lang/useOperator.ci:149:[.065826, .06582f) exec(1), time(0.001-0.001 ms): <.main+7738>
cmplStd/test/lang/useOperator.ci:150:[.06582f, .06583c) exec(1), time(0.002-0.002 ms): <.main+7747>
cmplStd/test/lang/useOperator.ci:151:[.06583c, .065849) exec(1), time(0.003-0.003 ms): <.main+7760>
cmplStd/test/lang/useOperator.ci:152:[.065849, .065856) exec(1), time(0.002-0.002 ms): <.main+7773>
cmplStd/test/lang/useOperator.ci:153:[.065856, .065863) exec(1), time(0.002-0.002 ms): <.main+7786>
cmplStd/test/lang/useOperator.ci:154:[.065863, .065870) exec(1), time(0.003-0.003 ms): <.main+7799>
cmplStd/test/lang/useOperator.ci:155:[.065870, .06587d) exec(1), time(0.002-0.002 ms): <.main+7812>
cmplStd/test/lang/useOperator.ci:156:[.06587d, .06588a) exec(1), time(0.002-0.002 ms): <.main+7825>
cmplStd/test/lang/useOperator.ci:157:[.06588a, .065897) exec(1), time(0.003-0.003 ms): <.main+7838>
cmplStd/test/lang/useOperator.ci:158:[.065897, .0658a4) exec(1), time(0.003-0.003 ms): <.main+7851>
cmplStd/test/lang/useOperator.ci:159:[.0658a4, .0658b1) exec(1), time(0.002-0.002 ms): <.main+7864>
cmplStd/test/lang/useOperator.ci:160:[.0658b1, .0658bd) exec(1), time(0.003-0.003 ms): <.main+7877>
cmplStd/test/lang/useOperator.ci:161:[.0658bd, .0658cc) exec(1), time(0.003-0.003 ms): <.main+7889>
cmplStd/test/lang/useOperator.ci:162:[.0658cc, .0658dc) exec(1), time(0.004-0.004 ms): <.main+7904>
cmplStd/test/lang/useOperator.ci:163:[.0658dc, .0658eb) exec(1), time(0.003-0.003 ms): <.main+7920>
cmplStd/test/lang/useOperator.ci:164:[.0658eb, .0658fb) exec(1), time(0.004-0.004 ms): <.main+7935>
cmplStd/test/lang/useOperator.ci:165:[.0658fb, .06590a) exec(1), time(0.004-0.004 ms): <.main+7951>
cmplStd/test/lang/useOperator.ci:166:[.06590a, .06591a) exec(1), time(0.004-0.004 ms): <.main+7966>
cmplStd/test/lang/useOperator.ci:168:[.06591a, .065923) exec(1), time(0.001-0.001 ms): <.main+7982>
cmplStd/test/lang/useOperator.ci:169:[.065923, .06592c) exec(1), time(0.001-0.001 ms): <.main+7991>
cmplStd/test/lang/useOperator.ci:170:[.06592c, .065934) exec(1), time(0.001-0.001 ms): <.main+8000>
cmplStd/test/lang/useOperator.ci:171:[.065934, .06593d) exec(1), time(0.001-0.001 ms): <.main+8008>
cmplStd/test/lang/useOperator.ci:172:[.06593d, .065946) exec(1), time(0.002-0.002 ms): <.main+8017>
cmplStd/test/lang/useOperator.ci:173:[.065946, .065953) exec(1), time(0.003-0.003 ms): <.main+8026>
cmplStd/test/lang/useOperator.ci:174:[.065953, .065960) exec(1), time(0.002-0.002 ms): <.main+8039>
cmplStd/test/lang/useOperator.ci:175:[.065960, .06596d) exec(1), time(0.002-0.002 ms): <.main+8052>
cmplStd/test/lang/useOperator.ci:176:[.06596d, .06597a) exec(1), time(0.003-0.003 ms): <.main+8065>
cmplStd/test/lang/useOperator.ci:177:[.06597a, .065987) exec(1), time(0.002-0.002 ms): <.main+8078>
cmplStd/test/lang/useOperator.ci:178:[.065987, .065994) exec(1), time(0.002-0.002 ms): <.main+8091>
cmplStd/test/lang/useOperator.ci:179:[.065994, .0659a1) exec(1), time(0.003-0.003 ms): <.main+8104>
cmplStd/test/lang/useOperator.ci:180:[.0659a1, .0659ae) exec(1), time(0.002-0.002 ms): <.main+8117>
cmplStd/test/lang/useOperator.ci:181:[.0659ae, .0659bb) exec(1), time(0.002-0.002 ms): <.main+8130>
cmplStd/test/lang/useOperator.ci:182:[.0659bb, .0659c8) exec(1), time(0.003-0.003 ms): <.main+8143>
cmplStd/test/lang/useOperator.ci:183:[.0659c8, .0659d4) exec(1), time(0.003-0.003 ms): <.main+8156>
cmplStd/test/lang/useOperator.ci:184:[.0659d4, .0659e3) exec(1), time(0.003-0.003 ms): <.main+8168>
cmplStd/test/lang/useOperator.ci:185:[.0659e3, .0659f3) exec(1), time(0.004-0.004 ms): <.main+8183>
cmplStd/test/lang/useOperator.ci:186:[.0659f3, .065a02) exec(1), time(0.003-0.003 ms): <.main+8199>
cmplStd/test/lang/useOperator.ci:187:[.065a02, .065a12) exec(1), time(0.004-0.004 ms): <.main+8214>
cmplStd/test/lang/useOperator.ci:188:[.065a12, .065a21) exec(1), time(0.003-0.003 ms): <.main+8230>
cmplStd/test/lang/useOperator.ci:189:[.065a21, .065a31) exec(1), time(0.004-0.004 ms): <.main+8245>
cmplStd/test/lang/useOperator.ci:191:[.065a31, .065a3e) exec(1), time(0.001-0.001 ms): <.main+8261>
cmplStd/test/lang/useOperator.ci:192:[.065a3e, .065a4b) exec(1), time(0.001-0.001 ms): <.main+8274>
cmplStd/test/lang/useOperator.ci:193:[.065a4b, .065a53) exec(1), time(0.001-0.001 ms): <.main+8287>
cmplStd/test/lang/useOperator.ci:194:[.065a53, .065a5c) exec(1), time(0.002-0.002 ms): <.main+8295>
cmplStd/test/lang/useOperator.ci:195:[.065a5c, .065a65) exec(1), time(0.001-0.001 ms): <.main+8304>
cmplStd/test/lang/useOperator.ci:196:[.065a65, .065a72) exec(1), time(0.003-0.003 ms): <.main+8313>
cmplStd/test/lang/useOperator.ci:197:[.065a72, .065a7f) exec(1), time(0.003-0.003 ms): <.main+8326>
cmplStd/test/lang/useOperator.ci:198:[.065a7f, .065a8c) exec(1), time(0.002-0.002 ms): <.main+8339>
cmplStd/test/lang/useOperator.ci:199:[.065a8c, .065a99) exec(1), time(0.002-0.002 ms): <.main+8352>
cmplStd/test/lang/useOperator.ci:200:[.065a99, .065aa6) exec(1), time(0.003-0.003 ms): <.main+8365>
cmplStd/test/lang/useOperator.ci:201:[.065aa6, .065ab3) exec(1), time(0.002-0.002 ms): <.main+8378>
cmplStd/test/lang/useOperator.ci:202:[.065ab3, .065ac0) exec(1), time(0.002-0.002 ms): <.main+8391>
cmplStd/test/lang/useOperator.ci:203:[.065ac0, .065acd) exec(1), time(0.003-0.003 ms): <.main+8404>
cmplStd/test/lang/useOperator.ci:204:[.065acd, .065ada) exec(1), time(0.002-0.002 ms): <.main+8417>
cmplStd/test/lang/useOperator.ci:205:[.065ada, .065ae7) exec(1), time(0.003-0.003 ms): <.main+8430>
cmplStd/test/lang/useOperator.ci:206:[.065ae7, .065af3) exec(1), time(0.003-0.003 ms): <.main+8443>
cmplStd/test/lang/useOperator.ci:207:[.065af3, .065b02) exec(1), time(0.003-0.003 ms): <.main+8455>
cmplStd/test/lang/useOperator.ci:208:[.065b02, .065b12) exec(1), time(0.004-0.004 ms): <.main+8470>
cmplStd/test/lang/useOperator.ci:209:[.065b12, .065b21) exec(1), time(0.003-0.003 ms): <.main+8486>
cmplStd/test/lang/useOperator.ci:210:[.065b21, .065b31) exec(1), time(0.004-0.004 ms): <.main+8501>
cmplStd/test/lang/useOperator.ci:211:[.065b31, .065b40) exec(1), time(0.003-0.003 ms): <.main+8517>
cmplStd/test/lang/useOperator.ci:212:[.065b40, .065b50) exec(1), time(0.005-0.005 ms): <.main+8532>
cmplStd/test/lang/useOperator.ci:214:[.065b50, .065b5d) exec(1), time(0.001-0.001 ms): <.main+8548>
cmplStd/test/lang/useOperator.ci:215:[.065b5d, .065b6a) exec(1), time(0.001-0.001 ms): <.main+8561>
cmplStd/test/lang/useOperator.ci:216:[.065b6a, .065b72) exec(1), time(0.001-0.001 ms): <.main+8574>
cmplStd/test/lang/useOperator.ci:217:[.065b72, .065b7b) exec(1), time(0.002-0.002 ms): <.main+8582>
cmplStd/test/lang/useOperator.ci:218:[.065b7b, .065b84) exec(1), time(0.001-0.001 ms): <.main+8591>
cmplStd/test/lang/useOperator.ci:219:[.065b84, .065b91) exec(1), time(0.003-0.003 ms): <.main+8600>
cmplStd/test/lang/useOperator.ci:220:[.065b91, .065b9e) exec(1), time(0.002-0.002 ms): <.main+8613>
cmplStd/test/lang/useOperator.ci:221:[.065b9e, .065bab) exec(1), time(0.002-0.002 ms): <.main+8626>
cmplStd/test/lang/useOperator.ci:222:[.065bab, .065bb8) exec(1), time(0.003-0.003 ms): <.main+8639>
cmplStd/test/lang/useOperator.ci:223:[.065bb8, .065bc5) exec(1), time(0.002-0.002 ms): <.main+8652>
cmplStd/test/lang/useOperator.ci:224:[.065bc5, .065bd2) exec(1), time(0.003-0.003 ms): <.main+8665>
cmplStd/test/lang/useOperator.ci:225:[.065bd2, .065bdf) exec(1), time(0.002-0.002 ms): <.main+8678>
cmplStd/test/lang/useOperator.ci:226:[.065bdf, .065bec) exec(1), time(0.003-0.003 ms): <.main+8691>
cmplStd/test/lang/useOperator.ci:227:[.065bec, .065bf9) exec(1), time(0.003-0.003 ms): <.main+8704>
cmplStd/test/lang/useOperator.ci:228:[.065bf9, .065c06) exec(1), time(0.002-0.002 ms): <.main+8717>
cmplStd/test/lang/useOperator.ci:229:[.065c06, .065c12) exec(1), time(0.004-0.004 ms): <.main+8730>
cmplStd/test/lang/useOperator.ci:230:[.065c12, .065c21) exec(1), time(0.004-0.004 ms): <.main+8742>
cmplStd/test/lang/useOperator.ci:231:[.065c21, .065c31) exec(1), time(0.004-0.004 ms): <.main+8757>
cmplStd/test/lang/useOperator.ci:232:[.065c31, .065c40) exec(1), time(0.003-0.003 ms): <.main+8773>
cmplStd/test/lang/useOperator.ci:233:[.065c40, .065c50) exec(1), time(0.004-0.004 ms): <.main+8788>
cmplStd/test/lang/useOperator.ci:234:[.065c50, .065c5f) exec(1), time(0.004-0.004 ms): <.main+8804>
cmplStd/test/lang/useOperator.ci:235:[.065c5f, .065c6f) exec(1), time(0.005-0.005 ms): <.main+8819>
cmplStd/test/lang/useOperator.ci:237:[.065c6f, .065c78) exec(1), time(0.001-0.001 ms): <.main+8835>
cmplStd/test/lang/useOperator.ci:238:[.065c78, .065c81) exec(1), time(0.001-0.001 ms): <.main+8844>
cmplStd/test/lang/useOperator.ci:239:[.065c81, .065c89) exec(1), time(0.001-0.001 ms): <.main+8853>
cmplStd/test/lang/useOperator.ci:240:[.065c89, .065c92) exec(1), time(0.002-0.002 ms): <.main+8861>
cmplStd/test/lang/useOperator.ci:242:[.065c92, .065c9f) exec(1), time(0.002-0.002 ms): <.main+8870>
cmplStd/test/lang/useOperator.ci:243:[.065c9f, .065cac) exec(1), time(0.003-0.003 ms): <.main+8883>
cmplStd/test/lang/useOperator.ci:244:[.065cac, .065cb9) exec(1), time(0.002-0.002 ms): <.main+8896>
cmplStd/test/lang/useOperator.ci:245:[.065cb9, .065cc6) exec(1), time(0.003-0.003 ms): <.main+8909>
cmplStd/test/lang/useOperator.ci:246:[.065cc6, .065cd3) exec(1), time(0.003-0.003 ms): <.main+8922>
cmplStd/test/lang/useOperator.ci:252:[.065cd3, .065cdf) exec(1), time(0.003-0.003 ms): <.main+8935>
cmplStd/test/lang/useOperator.ci:253:[.065cdf, .065cee) exec(1), time(0.004-0.004 ms): <.main+8947>
cmplStd/test/lang/useOperator.ci:254:[.065cee, .065cfe) exec(1), time(0.005-0.005 ms): <.main+8962>
cmplStd/test/lang/useOperator.ci:255:[.065cfe, .065d0d) exec(1), time(0.003-0.003 ms): <.main+8978>
cmplStd/test/lang/useOperator.ci:256:[.065d0d, .065d1d) exec(1), time(0.004-0.004 ms): <.main+8993>
cmplStd/test/lang/useOperator.ci:257:[.065d1d, .065d2c) exec(1), time(0.004-0.004 ms): <.main+9009>
cmplStd/test/lang/useOperator.ci:258:[.065d2c, .065d3c) exec(1), time(0.005-0.005 ms): <.main+9024>
cmplStd/test/lang/useOperator.ci:260:[.065d3c, .065d49) exec(1), time(0.001-0.001 ms): <.main+9040>
cmplStd/test/lang/useOperator.ci:261:[.065d49, .065d56) exec(1), time(0.001-0.001 ms): <.main+9053>
cmplStd/test/lang/useOperator.ci:262:[.065d56, .065d5e) exec(1), time(0.001-0.001 ms): <.main+9066>
cmplStd/test/lang/useOperator.ci:263:[.065d5e, .065d67) exec(1), time(0.002-0.002 ms): <.main+9074>
cmplStd/test/lang/useOperator.ci:265:[.065d67, .065d74) exec(1), time(0.003-0.003 ms): <.main+9083>
cmplStd/test/lang/useOperator.ci:266:[.065d74, .065d81) exec(1), time(0.003-0.003 ms): <.main+9096>
cmplStd/test/lang/useOperator.ci:267:[.065d81, .065d8e) exec(1), time(0.002-0.002 ms): <.main+9109>
cmplStd/test/lang/useOperator.ci:268:[.065d8e, .065d9b) exec(1), time(0.003-0.003 ms): <.main+9122>
cmplStd/test/lang/useOperator.ci:269:[.065d9b, .065da8) exec(1), time(0.003-0.003 ms): <.main+9135>
cmplStd/test/lang/useOperator.ci:275:[.065da8, .065db4) exec(1), time(0.003-0.003 ms): <.main+9148>
cmplStd/test/lang/useOperator.ci:276:[.065db4, .065dc3) exec(1), time(0.004-0.004 ms): <.main+9160>
cmplStd/test/lang/useOperator.ci:277:[.065dc3, .065dd3) exec(1), time(0.004-0.004 ms): <.main+9175>
cmplStd/test/lang/useOperator.ci:278:[.065dd3, .065de2) exec(1), time(0.003-0.003 ms): <.main+9191>
cmplStd/test/lang/useOperator.ci:279:[.065de2, .065df2) exec(1), time(0.005-0.005 ms): <.main+9206>
cmplStd/test/lang/useOperator.ci:280:[.065df2, .065e01) exec(1), time(0.003-0.003 ms): <.main+9222>
cmplStd/test/lang/useOperator.ci:281:[.065e01, .065e11) exec(1), time(0.004-0.004 ms): <.main+9237>
cmplStd/test/lang/useOperator.ci:283:[.065e11, .065e1a) exec(1), time(0.001-0.001 ms): <.main+9253>
cmplStd/test/lang/useOperator.ci:284:[.065e1a, .065e23) exec(1), time(0.001-0.001 ms): <.main+9262>
cmplStd/test/lang/useOperator.ci:299:[.065e23, .065e32) exec(1), time(0.004-0.004 ms): <.main+9271>
cmplStd/test/lang/useOperator.ci:300:[.065e32, .065e42) exec(1), time(0.004-0.004 ms): <.main+9286>
cmplStd/test/lang/stmt.if.ci:26:[.065e42, .065e47) exec(1), time(0.001-0.001 ms): <.main+9302>
cmplStd/test/lang/stmt.for.ci:12:[.065e47, .065e4c) exec(1), time(0.001-0.001 ms): <.main+9307>
cmplStd/test/std/test.math.ci:3:[.065e4c, .065e64) exec(1), time(0.026-0.026 ms): <.main+9312>
cmplStd/test/std/test.math.ci:4:[.065e64, .065e7c) exec(1), time(0.022-0.022 ms): <.main+9336>
cmplStd/test/std/test.math.ci:5:[.065e7c, .065e94) exec(1), time(0.022-0.022 ms): <.main+9360>
cmplStd/test/std/test.math.ci:6:[.065e94, .065eac) exec(1), time(0.030-0.030 ms): <.main+9384>
cmplStd/test/std/test.math.ci:7:[.065eac, .065ec4) exec(1), time(0.030-0.030 ms): <.main+9408>
cmplStd/test/std/test.math.ci:8:[.065ec4, .065edc) exec(1), time(0.030-0.030 ms): <.main+9432>
cmplStd/test/std/test.math.ci:10:[.065edc, .065ef9) exec(1), time(0.009-0.009 ms): <.main+9456>
cmplStd/test/std/test.math.ci:11:[.065ef9, .065f0e) exec(1), time(0.010-0.010 ms): <.main+9485>
cmplStd/test/std/test.math.ci:12:[.065f0e, .065f2b) exec(1), time(0.009-0.009 ms): <.main+9506>
cmplStd/test/std/test.math.ci:13:[.065f2b, .065f40) exec(1), time(0.009-0.009 ms): <.main+9535>
cmplStd/test/std/test.math.ci:14:[.065f40, .065f51) exec(1), time(0.009-0.009 ms): <.main+9556>
cmplStd/test/std/test.math.ci:15:[.065f51, .065f66) exec(1), time(0.008-0.008 ms): <.main+9573>
cmplStd/test/std/test.math.ci:17:[.065f66, .065f86) exec(1), time(0.006-0.006 ms): <.main+9594>
cmplStd/test/std/test.math.ci:18:[.065f86, .065f9e) exec(1), time(0.006-0.006 ms): <.main+9626>
cmplStd/test/std/test.math.ci:19:[.065f9e, .065fbe) exec(1), time(0.008-0.008 ms): <.main+9650>
cmplStd/test/std/test.math.ci:20:[.065fbe, .065fdb) exec(1), time(0.007-0.007 ms): <.main+9682>
cmplStd/test/std/test.math.ci:21:[.065fdb, .065ff4) exec(1), time(0.007-0.007 ms): <.main+9711>
cmplStd/test/std/test.math.ci:22:[.065ff4, .066011) exec(1), time(0.009-0.009 ms): <.main+9736>
cmplStd/test/std/test.math.ci:24:[.066011, .066037) exec(1), time(0.009-0.009 ms): <.main+9765>
cmplStd/test/std/test.math.ci:25:[.066037, .06605d) exec(1), time(0.009-0.009 ms): <.main+9803>
cmplStd/test/std/test.math.ci:26:[.06605d, .06608a) exec(1), time(0.009-0.009 ms): <.main+9841>
cmplStd/test/std/test.math.ci:27:[.06608a, .0660b7) exec(1), time(0.007-0.007 ms): <.main+9886>
cmplStd/test/std/test.math.ci:29:[.0660b7, .0660d2) exec(1), time(0.018-0.018 ms): <.main+9931>
cmplStd/test/std/test.math.ci:30:[.0660d2, .0660f4) exec(1), time(0.016-0.016 ms): <.main+9958>
cmplStd/test/std/test.math.ci:32:[.0660f4, .06610d) exec(1), time(0.009-0.009 ms): <.main+9992>
cmplStd/test/std/test.math.ci:33:[.06610d, .06612d) exec(1), time(0.008-0.008 ms): <.main+10017>
cmplStd/test/std/test.math.ci:35:[.06612d, .06616d) exec(1), time(0.033-0.033 ms): <.main+10049>
cmplStd/test/std/test.math.ci:36:[.06616d, .0661bf) exec(1), time(0.031-0.031 ms): <.main+10113>
cmplStd/test/std/test.math.ci:38:[.0661bf, .0661d8) exec(1), time(0.017-0.017 ms): <.main+10195>
cmplStd/test/std/test.math.ci:39:[.0661d8, .066246) exec(1), time(0.039-0.039 ms): <.main+10220>
cmplStd/test/std/test.math.ci:40:[.066246, .06625f) exec(1), time(0.018-0.018 ms): <.main+10330>
cmplStd/test/std/test.math.ci:41:[.06625f, .0662cd) exec(1), time(0.040-0.040 ms): <.main+10355>
cmplStd/test/std/test.math.ci:43:[.0662cd, .0662e6) exec(1), time(0.019-0.019 ms): <.main+10465>
cmplStd/test/std/test.math.ci:44:[.0662e6, .06630c) exec(1), time(0.021-0.021 ms): <.main+10490>
cmplStd/test/std/test.math.ci:45:[.06630c, .06633b) exec(1), time(0.023-0.023 ms): <.main+10528>
cmplStd/test/std/test.math.ci:46:[.06633b, .0663b2) exec(1), time(0.043-0.043 ms): <.main+10575>
cmplStd/test/std/test.math.ci:48:[.0663b2, .0663bf) exec(1), time(0.001-0.001 ms): <.main+10694>
cmplStd/test/std/test.math.ci:49:[.0663bf, .0663dc) exec(1), time(0.020-0.020 ms): <.main+10707>
cmplStd/test/std/test.math.ci:50:[.0663dc, .0663e9) exec(1), time(0.001-0.001 ms): <.main+10736>
cmplStd/test/std/test.math.ci:51:[.0663e9, .066405) exec(1), time(0.004-0.004 ms): <.main+10749>
cmplStd/test/std/test.math.ci:52:[.066405, .066432) exec(1), time(0.010-0.010 ms): <.main+10777>
cmplStd/test/std/test.math.ci:53:[.066432, .066470) exec(1), time(0.015-0.015 ms): <.main+10822>
cmplStd/test/std/test.math.ci:54:[.066470, .0664be) exec(1), time(0.033-0.033 ms): <.main+10884>
cmplStd/test/std/test.math.ci:55:[.0664be, .066515) exec(1), time(0.035-0.035 ms): <.main+10962>
cmplStd/test/std/test.math.ci:57:[.066515, .066538) exec(1), time(0.029-0.029 ms): <.main+11049>
cmplStd/test/std/test.math.ci:58:[.066538, .066572) exec(1), time(0.034-0.034 ms): <.main+11084>
cmplStd/test/std/test.math.ci:59:[.066572, .066594) exec(1), time(0.039-0.039 ms): <.main+11142>
cmplStd/test/std/test.math.ci:60:[.066594, .0665b6) exec(1), time(0.050-0.050 ms): <.main+11176>
cmplStd/test/std/test.math.ci:61:[.0665b6, .0665d8) exec(1), time(0.045-0.045 ms): <.main+11210>
cmplStd/test/std/test.math.ci:63:[.0665d8, .0665f0) exec(1), time(0.049-0.049 ms): <.main+11244>
cmplStd/test/std/test.math.ci:64:[.0665f0, .06661c) exec(1), time(0.052-0.052 ms): <.main+11268>
cmplStd/test/std/test.math.ci:67:[.06661c, .06663e) exec(1), time(0.020-0.020 ms): <.main+11312>
cmplStd/test/std/test.math.ci:68:[.06663e, .06666c) exec(1), time(0.020-0.020 ms): <.main+11346>
cmplStd/test/std/test.math.ci:70:[.06666c, .06668d) exec(1), time(0.015-0.015 ms): <.main+11392>
cmplStd/test/std/test.math.ci:71:[.06668d, .0666a5) exec(1), time(0.014-0.014 ms): <.main+11425>
cmplStd/test/std/test.math.ci:72:[.0666a5, .0666c6) exec(1), time(0.015-0.015 ms): <.main+11449>
cmplStd/test/std/test.math.ci:74:[.0666c6, .0666e7) exec(1), time(0.015-0.015 ms): <.main+11482>
cmplStd/test/std/test.math.ci:75:[.0666e7, .066708) exec(1), time(0.017-0.017 ms): <.main+11515>
cmplStd/test/std/test.math.ci:76:[.066708, .066729) exec(1), time(0.014-0.014 ms): <.main+11548>
cmplStd/test/std/test.math.ci:77:[.066729, .06674a) exec(1), time(0.015-0.015 ms): <.main+11581>
cmplStd/test/std/test.math.ci:79:[.06674a, .06676b) exec(1), time(0.015-0.015 ms): <.main+11614>
cmplStd/test/std/test.math.ci:80:[.06676b, .06678c) exec(1), time(0.015-0.015 ms): <.main+11647>
cmplStd/test/std/test.math.ci:81:[.06678c, .0667ad) exec(1), time(0.015-0.015 ms): <.main+11680>
cmplStd/test/std/test.math.ci:82:[.0667ad, .0667ce) exec(1), time(0.015-0.015 ms): <.main+11713>
cmplStd/test/std/test.math.ci:84:[.0667ce, .0667e7) exec(1), time(0.016-0.016 ms): <.main+11746>
cmplStd/test/std/test.math.ci:85:[.0667e7, .0667fc) exec(1), time(0.015-0.015 ms): <.main+11771>
cmplStd/test/std/test.math.ci:86:[.0667fc, .066815) exec(1), time(0.015-0.015 ms): <.main+11792>
cmplStd/test/std/test.math.ci:88:[.066815, .06682e) exec(1), time(0.015-0.015 ms): <.main+11817>
cmplStd/test/std/test.math.ci:89:[.06682e, .066847) exec(1), time(0.015-0.015 ms): <.main+11842>
cmplStd/test/std/test.math.ci:90:[.066847, .066860) exec(1), time(0.015-0.015 ms): <.main+11867>
cmplStd/test/std/test.math.ci:91:[.066860, .066879) exec(1), time(0.020-0.020 ms): <.main+11892>
cmplStd/test/std/test.math.ci:93:[.066879, .066892) exec(1), time(0.015-0.015 ms): <.main+11917>
cmplStd/test/std/test.math.ci:94:[.066892, .0668ab) exec(1), time(0.015-0.015 ms): <.main+11942>
cmplStd/test/std/test.math.ci:95:[.0668ab, .0668c4) exec(1), time(0.015-0.015 ms): <.main+11967>
cmplStd/test/std/test.math.ci:96:[.0668c4, .0668dd) exec(1), time(0.014-0.014 ms): <.main+11992>
cmplStd/test/std/memory.ci:13:[.0668dd, .0668ef) exec(1), time(0.022-0.022 ms): <.main+12017>
cmplStd/test/std/memory.ci:14:[.0668ef, .066904) exec(1), time(0.021-0.021 ms): <.main+12035>
cmplStd/test/std/memory.ci:17:[.066904, .066911) exec(1), time(0.020-0.020 ms): <.main+12056>
cmplStd/test/std/memory.ci:18:[.066911, .06691e) exec(1), time(0.020-0.020 ms): <.main+12069>
cmplStd/test/std/memory.ci:19:[.06691e, .06692b) exec(1), time(0.020-0.020 ms): <.main+12082>
cmplStd/test/std/memory.ci:20:[.06692b, .066938) exec(1), time(0.020-0.020 ms): <.main+12095>
cmplStd/test/std/memory.ci:26:[.066938, .06695b) exec(1), time(0.026-0.026 ms): <.main+12108>
cmplStd/test/std/memory.ci:27:[.06695b, .06697e) exec(1), time(0.024-0.024 ms): <.main+12143>
cmplStd/test/std/memory.ci:29:[.06697e, .066994) exec(1), time(0.021-0.021 ms): <.main+12178>
cmplStd/test/std/memory.ci:30:[.066994, .0669a6) exec(1), time(0.021-0.021 ms): <.main+12200>
cmplStd/test/std/memory.ci:32:[.0669a6, .0669c9) exec(1), time(0.024-0.024 ms): <.main+12218>
cmplStd/test/std/memory.ci:33:[.0669c9, .0669ec) exec(1), time(0.024-0.024 ms): <.main+12253>
cmplStd/test/lang/init.method.ci:78:[.0669ec, .066a01) exec(1), time(0.085-0.085 ms): <.main+12288>
cmplStd/test/lang/init.method.ci:79:[.066a01, .066a15) exec(1), time(0.083-0.083 ms): <.main+12309>
cmplStd/test/lang/init.method.ci:97:[.066a15, .066a28) exec(1), time(0.128-0.128 ms): <.main+12329>
cmplStd/test/lang/init.method.ci:98:[.066a28, .066a3b) exec(1), time(0.129-0.129 ms): <.main+12348>
cmplStd/test/lang/init.method.ci:101:[.066a3b, .066a50) exec(1), time(0.082-0.082 ms): <.main+12367>
cmplStd/test/lang/init.method.ci:102:[.066a50, .066a65) exec(1), time(0.082-0.082 ms): <.main+12388>
cmplStd/test/lang/init.method.ci:103:[.066a65, .066a79) exec(1), time(0.082-0.082 ms): <.main+12409>
cmplStd/test/lang/init.array.ci:35:[.066a79, .066a9c) exec(1), time(0.051-0.051 ms): <.main+12429>
cmplStd/test/lang/init.array.ci:38:[.066a9c, .066abe) exec(1), time(0.027-0.027 ms): <.main+12464>
cmplStd/test/lang/init.array.ci:41:[.066abe, .066ae0) exec(1), time(0.026-0.026 ms): <.main+12498>
cmplStd/test/lang/init.array.ci:48:[.066ae0, .066b15) exec(1), time(0.004-0.004 ms): <.main+12532>
cmplStd/test/lang/init.array.ci:49:[.066b15, .066b52) exec(1), time(0.004-0.004 ms): <.main+12585>
cmplStd/test/lang/init.array.ci:56:[.066b52, .066b6b) exec(1), time(0.017-0.017 ms): <.main+12646>
cmplStd/test/lang/init.array.ci:57:[.066b6b, .066b83) exec(1), time(0.015-0.015 ms): <.main+12671>
cmplStd/test/lang/init.array.ci:58:[.066b83, .066b9b) exec(1), time(0.015-0.015 ms): <.main+12695>
cmplStd/test/lang/init.array.ci:60:[.066b9b, .066bbb) exec(1), time(0.034-0.034 ms): <.main+12719>
cmplStd/test/lang/init.array.ci:61:[.066bbb, .066bda) exec(1), time(0.035-0.035 ms): <.main+12751>
cmplStd/test/lang/init.array.ci:62:[.066bda, .066c03) exec(1), time(0.034-0.034 ms): <.main+12782>
cmplStd/test/lang/init.array.ci:63:[.066c03, .066c26) exec(1), time(0.034-0.034 ms): <.main+12823>
cmplStd/test/lang/init.array.ci:64:[.066c26, .066c49) exec(1), time(0.034-0.034 ms): <.main+12858>
cmplStd/test/lang/init.array.ci:67:[.066c4e, .066c57) exec(7), time(0.023-0.023 ms): <.main+12898>
cmplStd/test/lang/init.array.ci:68:[.066c57, .066c95) exec(7), time(0.047-0.047 ms): <.main+12907>
cmplStd/test/lang/init.array.ci:69:[.066c95, .066cd2) exec(7), time(0.048-0.048 ms): <.main+12969>
cmplStd/test/lang/init.array.ci:70:[.066cd2, .066d0f) exec(7), time(0.047-0.047 ms): <.main+13030>
cmplStd/test/lang/init.array.ci:72:[.066d0f, .066d53) exec(7), time(0.184-0.184 ms): <.main+13091>
cmplStd/test/lang/init.array.ci:73:[.066d53, .066d96) exec(7), time(0.183-0.183 ms): <.main+13159>
cmplStd/test/lang/init.array.ci:74:[.066d96, .066dd9) exec(7), time(0.178-0.178 ms): <.main+13226>
cmplStd/test/lang/init.array.ci:76:[.066dd9, .066e1d) exec(7), time(0.183-0.183 ms): <.main+13293>
cmplStd/test/lang/init.array.ci:77:[.066e1d, .066e60) exec(7), time(0.181-0.181 ms): <.main+13361>
cmplStd/test/lang/init.array.ci:78:[.066e60, .066ea3) exec(7), time(0.182-0.182 ms): <.main+13428>
cmplStd/test/lang/init.array.ci:80:[.066ea3, .066eec) exec(7), time(0.190-0.190 ms): <.main+13495>
cmplStd/test/lang/init.array.ci:82:[.066eec, .066f2f) exec(7), time(0.182-0.182 ms): <.main+13568>
cmplStd/test/lang/init.array.ci:84:[.066f2f, .066f6c) exec(7), time(0.049-0.049 ms): <.main+13635>
cmplStd/test/lang/init.array.ci:66:[.066f70, .066f74) exec(7), time(0.001-0.001 ms): <.main+13700>
cmplStd/test/lang/init.array.ci:66:[.066f74, .066f80) exec(8), time(0.025-0.025 ms): <.main+13704>
cmplStd/test/lang/init.array.ci:66:[.066c49, .066f84) exec(1), time(0.004-0.004 ms): <.main+12893>
cmplStd/test/lang/stmt.if.ci:4:[.066f84, .066fab) exec(1), time(0.023-0.023 ms): <.main+13720>
cmplStd/test/lang/stmt.if.ci:12:[.066fab, .066fd2) exec(1), time(0.026-0.026 ms): <.main+13759>
cmplStd/test/lang/stmt.if.ci:22:[.066fd2, .066ff9) exec(1), time(0.029-0.029 ms): <.main+13798>
cmplStd/test/lang/stmt.if.ci:29:[.067003, .06702a) exec(1), time(0.032-0.032 ms): <.main+13847>
cmplStd/test/lang/stmt.if.ci:28:[.066ff9, .06702a) exec(1-1), time(0.000 ms): <.main+13837>
cmplStd/test/lang/stmt.if.ci:33:[.067034, .06705b) exec(0), time(0.000 ms): <.main+13896>
cmplStd/test/lang/stmt.if.ci:32:[.06702a, .06705b) exec(1), time(0.003-0.003 ms): <.main+13886>
cmplStd/test/lang/stmt.if.ci:37:[.067065, .06708c) exec(1), time(0.028-0.028 ms): <.main+13945>
cmplStd/test/lang/stmt.if.ci:40:[.067090, .0670b7) exec(0), time(0.000 ms): <.main+13988>
cmplStd/test/lang/stmt.if.ci:36:[.06705b, .0670b7) exec(1), time(0.029-0.029 ms): <.main+13935>
cmplStd/test/lang/stmt.if.ci:44:[.0670c1, .0670e8) exec(0), time(0.000 ms): <.main+14037>
cmplStd/test/lang/stmt.if.ci:47:[.0670ec, .067113) exec(1), time(0.028-0.028 ms): <.main+14080>
cmplStd/test/lang/stmt.if.ci:43:[.0670b7, .067113) exec(1-1), time(0.000 ms): <.main+14027>
cmplStd/test/lang/stmt.if.ci:51:[.06711d, .067144) exec(1), time(0.028-0.028 ms): <.main+14129>
cmplStd/test/lang/stmt.if.ci:54:[.067156, .06717d) exec(0), time(0.000 ms): <.main+14186>
cmplStd/test/lang/stmt.if.ci:57:[.06718f, .0671b6) exec(0), time(0.000 ms): <.main+14243>
cmplStd/test/lang/stmt.if.ci:60:[.0671c8, .0671ef) exec(0), time(0.000 ms): <.main+14300>
cmplStd/test/lang/stmt.if.ci:63:[.067201, .067228) exec(0), time(0.000 ms): <.main+14357>
cmplStd/test/lang/stmt.if.ci:66:[.06723a, .067261) exec(0), time(0.000 ms): <.main+14414>
cmplStd/test/lang/stmt.if.ci:69:[.067265, .06728c) exec(0), time(0.000 ms): <.main+14457>
cmplStd/test/lang/stmt.if.ci:65:[.06722c, .06728c) exec(0), time(0.000 ms): <.main+14400>
cmplStd/test/lang/stmt.if.ci:62:[.0671f3, .06728c) exec(0), time(0.000 ms): <.main+14343>
cmplStd/test/lang/stmt.if.ci:59:[.0671ba, .06728c) exec(0), time(0.000 ms): <.main+14286>
cmplStd/test/lang/stmt.if.ci:56:[.067181, .06728c) exec(0), time(0.000 ms): <.main+14229>
cmplStd/test/lang/stmt.if.ci:53:[.067148, .06728c) exec(0), time(0.000 ms): <.main+14172>
cmplStd/test/lang/stmt.if.ci:50:[.067113, .06728c) exec(1), time(0.029-0.029 ms): <.main+14119>
cmplStd/test/lang/stmt.for.ci:4:[.067290, .0672b3) exec(1), time(0.022-0.022 ms): <.main+14500>
cmplStd/test/lang/stmt.for.ci:5:[.0672b3, .0672b7) exec(1), time(0.000 ms): <.main+14535>
::[.0672b7, .0672bb) exec(1), time(0.001-0.001 ms): <.main+14539>
cmplStd/test/lang/stmt.for.ci:3:[.06728c, .0672bb) exec(1-1), time(0.000 ms): <.main+14496>
cmplStd/test/lang/stmt.for.ci:9:[.0672c0, .0672e2) exec(2), time(0.049-0.049 ms): <.main+14548>
cmplStd/test/lang/stmt.for.ci:8:[.0672e2, .0672e6) exec(2), time(0.001-0.001 ms): <.main+14582>
cmplStd/test/lang/stmt.for.ci:8:[.0672e6, .0672f2) exec(3), time(0.009-0.009 ms): <.main+14586>
cmplStd/test/lang/stmt.for.ci:8:[.0672bb, .0672f6) exec(1), time(0.004-0.004 ms): <.main+14543>
cmplStd/test/lang/stmt.for.ci:14:[.0672ff, .067322) exec(2), time(0.049-0.049 ms): <.main+14611>
cmplStd/test/lang/stmt.for.ci:13:[.067322, .06732e) exec(2), time(0.005-0.005 ms): <.main+14646>
cmplStd/test/lang/stmt.for.ci:13:[.06732e, .06733c) exec(3), time(0.010-0.010 ms): <.main+14658>
cmplStd/test/lang/stmt.for.ci:13:[.0672f6, .06733c) exec(1-1), time(0.000 ms): <.main+14602>
cmplStd/test/lang/stmt.for.ci:19:[.06734d, .067351) exec(2), time(0.000 ms): <.main+14689>
cmplStd/test/lang/stmt.for.ci:18:[.067341, .067351) exec(7-2), time(0.016-0.016 ms): <.main+14677>
cmplStd/test/lang/stmt.for.ci:21:[.067351, .067373) exec(5), time(0.125-0.125 ms): <.main+14693>
cmplStd/test/lang/stmt.for.ci:17:[.067373, .067377) exec(7), time(0.002-0.002 ms): <.main+14727>
cmplStd/test/lang/stmt.for.ci:17:[.067377, .067383) exec(8), time(0.026-0.026 ms): <.main+14731>
cmplStd/test/lang/stmt.for.ci:17:[.06733c, .067387) exec(1), time(0.005-0.005 ms): <.main+14672>
cmplStd/test/lang/stmt.for.ci:26:[.067398, .06739c) exec(1), time(0.000 ms): <.main+14764>
cmplStd/test/lang/stmt.for.ci:25:[.06738c, .06739c) exec(4-1), time(0.010-0.010 ms): <.main+14752>
cmplStd/test/lang/stmt.for.ci:28:[.06739c, .0673be) exec(3), time(0.073-0.073 ms): <.main+14768>
cmplStd/test/lang/stmt.for.ci:24:[.0673be, .0673c2) exec(3), time(0.001-0.001 ms): <.main+14802>
cmplStd/test/lang/stmt.for.ci:24:[.0673c2, .0673ce) exec(4), time(0.013-0.013 ms): <.main+14806>
cmplStd/test/lang/stmt.for.ci:24:[.067387, .0673d2) exec(1), time(0.001-0.001 ms): <.main+14747>

---------- Exitcode: 0, time: 22.126 ms
