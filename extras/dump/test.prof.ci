
---------- Compile: `/cmplStd/stdlib.ci`
warn: variable `args` hides previous declaration
debug: inline file: `cmplStd/stdlib.ci`
cmplStd/stdlib.ci:40: debug: inline file: `cmplStd/lib/debug.ci`
cmplStd/lib/debug.ci:65: warn: adding implicit cast variant(message: char[*])
cmplStd/lib/debug.ci:67: warn: adding implicit cast variant(expected: int32)
cmplStd/lib/debug.ci:68: warn: adding implicit cast variant(returned: int32)
cmplStd/lib/debug.ci:69: warn: adding implicit cast variant[](extras: variant[1])
cmplStd/stdlib.ci:43: debug: inline file: `cmplStd/lib/math.ci`
cmplStd/lib/math.ci:17: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:18: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:23: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:24: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:29: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:32: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:67: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:67: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:70: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:73: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math.ci:76: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:76: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:79: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:79: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:83: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:91: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:101: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:110: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:113: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:196: warn: adding implicit cast float32(2: int32)
cmplStd/lib/math.ci:196: warn: adding implicit cast float32(3: int32)
cmplStd/lib/math.ci:197: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:197: warn: adding implicit cast float64(3: int32)
cmplStd/lib/math.ci:207: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:211: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:221: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:225: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:236: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:244: warn: adding implicit cast float64(signed(data.length): int32)
cmplStd/lib/math.ci:262: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math.ci:314: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:320: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:321: warn: adding implicit cast float64(32764: int32)
cmplStd/lib/math.ci:324: warn: adding implicit cast float64(quad: int32)
cmplStd/lib/math.ci:328: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math.ci:328: warn: adding implicit cast int32(e - (4) * f: float64)
cmplStd/lib/math.ci:332: warn: adding implicit cast float64(k: int32)
cmplStd/lib/math.ci:337: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:372: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:376: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:384: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:392: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:401: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:404: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:426: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:431: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:432: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:437: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:453: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:456: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:457: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:459: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:468: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:474: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:479: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:484: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:486: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:502: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:526: warn: adding implicit cast float64(180: int32)
cmplStd/lib/math.ci:529: warn: adding implicit cast float64(180: int32)
cmplStd/stdlib.ci:46: debug: inline file: `cmplStd/lib/math/Complex.ci`
cmplStd/lib/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
cmplStd/lib/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
cmplStd/stdlib.ci:47: debug: inline file: `cmplStd/lib/math/Vector4f.ci`
cmplStd/stdlib.ci:48: debug: inline file: `cmplStd/lib/math/Matrix4f.ci`
cmplStd/lib/math/Matrix4f.ci:113: warn: adding implicit cast float64(len: float32)
cmplStd/lib/math/Matrix4f.ci:137: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:169: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:181: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:186: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:197: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:197: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:197: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:198: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:198: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:198: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:198: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:208: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:208: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:208: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:209: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:209: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:209: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:209: warn: adding implicit cast float32(1: int32)
cmplStd/stdlib.ci:49: debug: inline file: `cmplStd/lib/math/Vector2d.ci`
cmplStd/stdlib.ci:54: debug: inline file: `cmplStd/lib/text/string.ci`
cmplStd/lib/text/string.ci:5: warn: adding implicit cast pointer(str: char[*])
cmplStd/lib/text/string.ci:37: warn: adding implicit cast int32(with[i]: char)
cmplStd/lib/text/string.ci:65: warn: adding implicit cast int32(str[i]: char)
cmplStd/lib/text/string.ci:124: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
cmplStd/lib/text/string.ci:130: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
cmplStd/lib/text/string.ci:135: warn: adding implicit cast pointer(value: char[*])
cmplStd/lib/text/string.ci:139: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:146: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:147: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/string.ci:147: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/string.ci:149: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/string.ci:162: warn: adding implicit cast int32(radixDigits.length: uint32)
cmplStd/lib/text/string.ci:165: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/text/string.ci:165: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/text/string.ci:166: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/text/string.ci:180: warn: adding implicit cast int32(format.sign: char)
cmplStd/lib/text/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:190: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:197: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:204: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:209: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/string.ci:210: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/string.ci:210: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/string.ci:212: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/string.ci:231: warn: adding implicit cast int64(0: int32)
cmplStd/lib/text/string.ci:236: warn: adding implicit cast int64(0: int32)
cmplStd/lib/text/string.ci:257: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/string.ci:121: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/string.ci:257: debug: using default field initializer: FormatFlags.precision := 0
cmplStd/lib/text/string.ci:257: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/string.ci:127: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/string.ci:257: debug: using default field initializer: FormatFlags.padLen := 0
cmplStd/lib/text/string.ci:259: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/string.ci:265: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/string.ci:277: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/string.ci:281: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/string.ci:281: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/string.ci:284: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/string.ci:295: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/string.ci:121: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/string.ci:295: debug: using default field initializer: FormatFlags.precision := 0
cmplStd/lib/text/string.ci:295: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/string.ci:127: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/string.ci:295: debug: using default field initializer: FormatFlags.padLen := 0
cmplStd/lib/text/string.ci:306: warn: adding implicit cast int32(value.length: uint32)
cmplStd/lib/text/string.ci:306: warn: adding implicit cast int32(value[i]: char)
cmplStd/lib/text/string.ci:309: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/string.ci:309: warn: adding implicit cast float64((chr - '0'): char)
cmplStd/lib/text/string.ci:310: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/string.ci:313: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/string.ci:317: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/string.ci:320: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/text/string.ci:323: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/string.ci:331: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/string.ci:332: warn: adding implicit cast uint32(0: int32)

---------- Compile: `cmplStd/test/test.ci`
cmplStd/test/test.ci:9: debug: inline file: `cmplStd/test/lang/emit.ci`
cmplStd/test/test.ci:10: debug: inline file: `cmplStd/test/lang/inlineMacros.ci`
cmplStd/test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
cmplStd/test/test.ci:11: debug: inline file: `cmplStd/test/lang/overload.inline.ci`
cmplStd/test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
cmplStd/test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
cmplStd/test/test.ci:14: debug: inline file: `cmplStd/test/std/number.ci`
cmplStd/test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
cmplStd/test/test.ci:15: debug: inline file: `cmplStd/test/std/memory.ci`
cmplStd/test/test.ci:16: debug: inline file: `cmplStd/test/std/tryExec.ci`
cmplStd/test/std/tryExec.ci:25: warn: variable `abortExecution.NotEquals` hides previous declaration
cmplStd/lib/debug.ci:48: warn: previously defined as `NotEquals`
cmplStd/test/std/tryExec.ci:25: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
cmplStd/test/std/tryExec.ci:31: warn: adding implicit cast char[*]("assertion failed": .cstr)
cmplStd/test/test.ci:20: debug: inline file: `cmplStd/test/lang/init.reference.ci`
cmplStd/test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:21: debug: inline file: `cmplStd/test/lang/init.variable.ci`
cmplStd/test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
cmplStd/test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:41: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/test.ci:24: debug: inline file: `cmplStd/test/lang/function.ci`
cmplStd/test/lang/function.ci:33: warn: Overwriting forward function: funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
cmplStd/test/test.ci:25: debug: inline file: `cmplStd/test/lang/reflect.ci`
cmplStd/test/test.ci:29: debug: inline file: `cmplStd/test/lang/init.member.ci`
cmplStd/test/lang/init.member.ci:81: warn: ignoring nested comment
cmplStd/test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
cmplStd/test/test.ci:30: debug: inline file: `cmplStd/test/lang/init.method.ci`
cmplStd/test/lang/init.method.ci:40: warn: Creating virtual method for: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47: warn: Overwriting forward function: RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
cmplStd/test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/test.ci:33: debug: inline file: `cmplStd/test/lang/recUnion.ci`
cmplStd/test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
cmplStd/test/test.ci:34: debug: inline file: `cmplStd/test/lang/recPacking.ci`
cmplStd/test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
cmplStd/test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
cmplStd/test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
cmplStd/test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
cmplStd/test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
cmplStd/test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
cmplStd/test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
cmplStd/test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
cmplStd/test/test.ci:41: debug: inline file: `cmplStd/test/lang/useOperator.ci`
cmplStd/test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
cmplStd/test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
cmplStd/test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
cmplStd/test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
cmplStd/test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
cmplStd/test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
cmplStd/test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
cmplStd/test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
cmplStd/test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
cmplStd/test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
cmplStd/test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
cmplStd/test/test.ci:45: debug: inline file: `cmplStd/test/lang/stmt.if.ci`
cmplStd/test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:46: debug: inline file: `cmplStd/test/lang/stmt.for.ci`
cmplStd/test/test.ci:49: debug: inline file: `cmplStd/test/std/test.math.ci`
cmplStd/test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
cmplStd/lib/math.ci:48: warn: using default type initializer: Math.floor.result := 0
cmplStd/lib/math.ci:319: warn: using default type initializer: Math.sinCos.y := 0
cmplStd/lib/math.ci:322: warn: using default type initializer: e := 0
cmplStd/lib/math.ci:326: warn: using default type initializer: f := 0
cmplStd/lib/math.ci:378: warn: using default type initializer: Math.tan.e := 0
cmplStd/lib/math.ci:435: warn: using default type initializer: Math.sinh.result := 0
cmplStd/lib/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
cmplStd/test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006500>, cast: static const inline)
.field file: function (size: 0, offs: <@006718>, cast: static const inline)
.field line: function (size: 0, offs: <@006930>, cast: static const inline)
.field name: function (size: 0, offs: <@006b48>, cast: static const inline)
.field size: function (size: 0, offs: <@006d58>, cast: static const inline)
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:42: referenced as `typename`
	cmplStd/test/lang/reflect.ci:41: referenced as `typename`
	cmplStd/test/lang/reflect.ci:38: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:35: referenced as `typename`
	cmplStd/test/lang/reflect.ci:34: referenced as `typename`
	cmplStd/test/lang/reflect.ci:31: referenced as `typename`
	cmplStd/test/lang/reflect.ci:30: referenced as `typename`
	cmplStd/test/lang/reflect.ci:18: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:92: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:91: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:90: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:89: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:87: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:86: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:85: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:84: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:83: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:82: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:81: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:80: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:79: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:78: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:77: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:76: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:75: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:68: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:48: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:32: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:25: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:19: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:3: referenced as `typename`
	cmplStd/stdlib.ci:39: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	internal usages: 12
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `size`
	cmplStd/test/lang/reflect.ci:46: referenced as `size`
	cmplStd/test/lang/reflect.ci:40: referenced as `size`
	cmplStd/test/lang/reflect.ci:33: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:49: referenced as `offset`
	cmplStd/test/lang/reflect.ci:45: referenced as `offset`
	cmplStd/test/lang/reflect.ci:39: referenced as `offset`
	cmplStd/test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006500>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `base`
	cmplStd/test/lang/reflect.ci:44: referenced as `base`
	cmplStd/test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006718>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	cmplStd/test/lang/reflect.ci:41: referenced as `file`
	cmplStd/test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006930>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	cmplStd/test/lang/reflect.ci:42: referenced as `line`
	cmplStd/test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b48>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	cmplStd/test/lang/reflect.ci:38: referenced as `name`
	cmplStd/test/lang/reflect.ci:31: referenced as `name`
}
typename.size(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006d58>
.name: 'size'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
	cmplStd/stdlib.ci:37: referenced as `size`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b8>
.name: 'void'
.usages:
	cmplStd/test/lang/init.method.ci:90: referenced as `void`
	cmplStd/test/lang/init.method.ci:84: referenced as `void`
	cmplStd/test/lang/init.method.ci:57: referenced as `void`
	cmplStd/test/lang/init.method.ci:47: referenced as `void`
	cmplStd/test/lang/init.method.ci:40: referenced as `void`
	cmplStd/test/lang/init.method.ci:32: referenced as `void`
	cmplStd/test/lang/init.method.ci:25: referenced as `void`
	cmplStd/test/lang/init.method.ci:18: referenced as `void`
	cmplStd/test/lang/init.method.ci:10: referenced as `void`
	cmplStd/test/lang/reflect.ci:3: referenced as `void`
	cmplStd/test/lang/function.ci:4: referenced as `void`
	cmplStd/test/lang/init.reference.ci:75: referenced as `void`
	cmplStd/test/lang/init.reference.ci:55: referenced as `void`
	cmplStd/test/lang/init.reference.ci:35: referenced as `void`
	cmplStd/test/std/tryExec.ci:43: referenced as `void`
	cmplStd/test/std/tryExec.ci:38: referenced as `void`
	cmplStd/test/std/tryExec.ci:24: referenced as `void`
	cmplStd/test/std/tryExec.ci:20: referenced as `void`
	cmplStd/test/std/tryExec.ci:14: referenced as `void`
	cmplStd/test/std/tryExec.ci:11: referenced as `void`
	cmplStd/lib/debug.ci:61: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	internal usages: 7
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000160>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `bool`
	cmplStd/test/std/test.math.ci:67: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:300: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:299: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:281: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:280: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:279: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:278: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:277: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:276: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:275: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:258: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:257: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:256: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:255: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:254: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:253: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:252: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:235: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:234: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:233: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:232: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:231: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:230: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:229: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:212: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:211: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:210: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:209: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:208: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:207: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:206: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:189: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:188: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:187: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:186: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:185: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:184: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:183: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:166: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:165: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:164: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:163: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:162: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:161: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:160: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:143: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:142: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:141: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:140: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:139: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:138: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:137: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:120: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:119: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:118: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:117: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:116: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:115: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:114: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:97: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:96: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:95: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:94: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:93: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:92: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:91: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:74: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:73: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:72: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:71: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:70: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:69: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:68: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:51: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:50: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:49: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:48: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:47: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:46: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:45: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:28: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:27: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:26: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:25: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:24: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:23: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:22: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:19: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:18: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:17: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:8: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:7: referenced as `bool`
	cmplStd/test/lang/reflect.ci:4: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:76: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:56: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:36: referenced as `bool`
	cmplStd/lib/text/string.ci:46: referenced as `bool`
	cmplStd/lib/text/string.ci:36: referenced as `bool`
	cmplStd/lib/math.ci:473: referenced as `bool`
	cmplStd/lib/math.ci:425: referenced as `bool`
	cmplStd/lib/math.ci:370: referenced as `bool`
	cmplStd/lib/math.ci:369: referenced as `bool`
	cmplStd/lib/debug.ci:45: referenced as `bool`
	cmplStd/lib/debug.ci:43: referenced as `bool`
	cmplStd/lib/debug.ci:41: referenced as `bool`
	cmplStd/stdlib.ci:3: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000208>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:44: referenced as `char`
	cmplStd/test/lang/useOperator.ci:43: referenced as `char`
	cmplStd/test/lang/useOperator.ci:42: referenced as `char`
	cmplStd/test/lang/useOperator.ci:41: referenced as `char`
	cmplStd/test/lang/useOperator.ci:40: referenced as `char`
	cmplStd/test/lang/useOperator.ci:39: referenced as `char`
	cmplStd/test/lang/useOperator.ci:38: referenced as `char`
	cmplStd/test/lang/useOperator.ci:37: referenced as `char`
	cmplStd/test/lang/useOperator.ci:36: referenced as `char`
	cmplStd/test/lang/useOperator.ci:35: referenced as `char`
	cmplStd/test/lang/useOperator.ci:34: referenced as `char`
	cmplStd/test/lang/useOperator.ci:33: referenced as `char`
	cmplStd/test/lang/useOperator.ci:32: referenced as `char`
	cmplStd/test/lang/useOperator.ci:31: referenced as `char`
	cmplStd/test/lang/useOperator.ci:30: referenced as `char`
	cmplStd/test/lang/reflect.ci:41: referenced as `char`
	cmplStd/test/lang/reflect.ci:38: referenced as `char`
	cmplStd/test/lang/reflect.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:31: referenced as `char`
	cmplStd/test/lang/reflect.ci:5: referenced as `char`
	cmplStd/test/lang/init.reference.ci:77: referenced as `char`
	cmplStd/test/lang/init.reference.ci:57: referenced as `char`
	cmplStd/test/lang/init.reference.ci:37: referenced as `char`
	cmplStd/test/std/tryExec.ci:26: referenced as `char`
	cmplStd/test/lang/emit.ci:29: referenced as `char`
	cmplStd/lib/text/string.ci:307: referenced as `char`
	cmplStd/lib/text/string.ci:300: referenced as `char`
	cmplStd/lib/text/string.ci:294: referenced as `char`
	cmplStd/lib/text/string.ci:291: referenced as `char`
	cmplStd/lib/text/string.ci:255: referenced as `char`
	cmplStd/lib/text/string.ci:252: referenced as `char`
	cmplStd/lib/text/string.ci:249: referenced as `char`
	cmplStd/lib/text/string.ci:246: referenced as `char`
	cmplStd/lib/text/string.ci:243: referenced as `char`
	cmplStd/lib/text/string.ci:229: referenced as `char`
	cmplStd/lib/text/string.ci:226: referenced as `char`
	cmplStd/lib/text/string.ci:223: referenced as `char`
	cmplStd/lib/text/string.ci:220: referenced as `char`
	cmplStd/lib/text/string.ci:217: referenced as `char`
	cmplStd/lib/text/string.ci:174: referenced as `char`
	cmplStd/lib/text/string.ci:159: referenced as `char`
	cmplStd/lib/text/string.ci:156: referenced as `char`
	cmplStd/lib/text/string.ci:155: referenced as `char`
	cmplStd/lib/text/string.ci:154: referenced as `char`
	cmplStd/lib/text/string.ci:134: referenced as `char`
	cmplStd/lib/text/string.ci:134: referenced as `char`
	cmplStd/lib/text/string.ci:127: referenced as `char`
	cmplStd/lib/text/string.ci:121: referenced as `char`
	cmplStd/lib/text/string.ci:105: referenced as `char`
	cmplStd/lib/text/string.ci:105: referenced as `char`
	cmplStd/lib/text/string.ci:102: referenced as `char`
	cmplStd/lib/text/string.ci:102: referenced as `char`
	cmplStd/lib/text/string.ci:100: referenced as `char`
	cmplStd/lib/text/string.ci:100: referenced as `char`
	cmplStd/lib/text/string.ci:98: referenced as `char`
	cmplStd/lib/text/string.ci:98: referenced as `char`
	cmplStd/lib/text/string.ci:96: referenced as `char`
	cmplStd/lib/text/string.ci:96: referenced as `char`
	cmplStd/lib/text/string.ci:88: referenced as `char`
	cmplStd/lib/text/string.ci:88: referenced as `char`
	cmplStd/lib/text/string.ci:74: referenced as `char`
	cmplStd/lib/text/string.ci:74: referenced as `char`
	cmplStd/lib/text/string.ci:73: referenced as `char`
	cmplStd/lib/text/string.ci:73: referenced as `char`
	cmplStd/lib/text/string.ci:61: referenced as `char`
	cmplStd/lib/text/string.ci:61: referenced as `char`
	cmplStd/lib/text/string.ci:61: referenced as `char`
	cmplStd/lib/text/string.ci:61: referenced as `char`
	cmplStd/lib/text/string.ci:46: referenced as `char`
	cmplStd/lib/text/string.ci:46: referenced as `char`
	cmplStd/lib/text/string.ci:46: referenced as `char`
	cmplStd/lib/text/string.ci:46: referenced as `char`
	cmplStd/lib/text/string.ci:36: referenced as `char`
	cmplStd/lib/text/string.ci:36: referenced as `char`
	cmplStd/lib/text/string.ci:36: referenced as `char`
	cmplStd/lib/text/string.ci:36: referenced as `char`
	cmplStd/lib/text/string.ci:25: referenced as `char`
	cmplStd/lib/text/string.ci:25: referenced as `char`
	cmplStd/lib/text/string.ci:15: referenced as `char`
	cmplStd/lib/text/string.ci:15: referenced as `char`
	cmplStd/lib/text/string.ci:4: referenced as `char`
	cmplStd/lib/debug.ci:61: referenced as `char`
	cmplStd/lib/debug.ci:43: referenced as `char`
	cmplStd/lib/debug.ci:41: referenced as `char`
	cmplStd/lib/debug.ci:36: referenced as `char`
	cmplStd/lib/debug.ci:34: referenced as `char`
	cmplStd/lib/debug.ci:31: referenced as `char`
	cmplStd/lib/debug.ci:29: referenced as `char`
	cmplStd/lib/debug.ci:26: referenced as `char`
	cmplStd/lib/debug.ci:24: referenced as `char`
	cmplStd/lib/debug.ci:21: referenced as `char`
	cmplStd/lib/debug.ci:19: referenced as `char`
	cmplStd/lib/debug.ci:16: referenced as `char`
	cmplStd/lib/debug.ci:14: referenced as `char`
	cmplStd/lib/debug.ci:11: referenced as `char`
	cmplStd/lib/debug.ci:9: referenced as `char`
	cmplStd/lib/debug.ci:6: referenced as `char`
	cmplStd/lib/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0002b0>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:67: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:66: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:65: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:64: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:63: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:62: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:61: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:60: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:59: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:58: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:57: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:56: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:55: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:54: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:53: referenced as `int8`
	cmplStd/test/lang/reflect.ci:6: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:78: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:58: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:38: referenced as `int8`
	cmplStd/lib/text/string.ci:252: referenced as `int8`
	cmplStd/stdlib.ci:25: referenced as `int8`
	cmplStd/stdlib.ci:13: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000358>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:113: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:112: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:111: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:110: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:109: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:108: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:107: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:106: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:105: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:104: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:103: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:102: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:101: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:100: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:99: referenced as `int16`
	cmplStd/test/lang/reflect.ci:7: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:79: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:59: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:39: referenced as `int16`
	cmplStd/lib/text/string.ci:249: referenced as `int16`
	cmplStd/stdlib.ci:28: referenced as `int16`
	cmplStd/stdlib.ci:16: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000400>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/stmt.for.ci:24: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:17: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:12: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:8: referenced as `int`
	cmplStd/test/lang/stmt.if.ci:26: referenced as `int`
	cmplStd/test/lang/useOperator.ci:159: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:158: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:157: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:156: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:155: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:154: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:153: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:152: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:151: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:150: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:149: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:148: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:147: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:146: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:145: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:5: referenced as `int32`
	cmplStd/test/lang/init.method.ci:90: referenced as `int`
	cmplStd/test/lang/init.method.ci:84: referenced as `int`
	cmplStd/test/lang/init.method.ci:57: referenced as `int`
	cmplStd/test/lang/init.method.ci:47: referenced as `int`
	cmplStd/test/lang/init.method.ci:40: referenced as `int`
	cmplStd/test/lang/init.method.ci:32: referenced as `int`
	cmplStd/test/lang/init.method.ci:25: referenced as `int`
	cmplStd/test/lang/init.method.ci:18: referenced as `int`
	cmplStd/test/lang/init.method.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:40: referenced as `int`
	cmplStd/test/lang/init.member.ci:37: referenced as `int`
	cmplStd/test/lang/init.member.ci:34: referenced as `int`
	cmplStd/test/lang/init.member.ci:19: referenced as `int`
	cmplStd/test/lang/init.member.ci:16: referenced as `int`
	cmplStd/test/lang/init.member.ci:13: referenced as `int`
	cmplStd/test/lang/init.member.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:6: referenced as `int`
	cmplStd/test/lang/init.member.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:50: referenced as `int`
	cmplStd/test/lang/reflect.ci:49: referenced as `int`
	cmplStd/test/lang/reflect.ci:46: referenced as `int`
	cmplStd/test/lang/reflect.ci:45: referenced as `int`
	cmplStd/test/lang/reflect.ci:42: referenced as `int`
	cmplStd/test/lang/reflect.ci:40: referenced as `int`
	cmplStd/test/lang/reflect.ci:39: referenced as `int`
	cmplStd/test/lang/reflect.ci:35: referenced as `int`
	cmplStd/test/lang/reflect.ci:33: referenced as `int`
	cmplStd/test/lang/reflect.ci:32: referenced as `int`
	cmplStd/test/lang/reflect.ci:27: referenced as `int32`
	cmplStd/test/lang/reflect.ci:20: referenced as `int`
	cmplStd/test/lang/reflect.ci:19: referenced as `int`
	cmplStd/test/lang/reflect.ci:18: referenced as `int`
	cmplStd/test/lang/reflect.ci:17: referenced as `int`
	cmplStd/test/lang/reflect.ci:16: referenced as `int`
	cmplStd/test/lang/reflect.ci:15: referenced as `int`
	cmplStd/test/lang/reflect.ci:14: referenced as `int`
	cmplStd/test/lang/reflect.ci:13: referenced as `int`
	cmplStd/test/lang/reflect.ci:12: referenced as `int`
	cmplStd/test/lang/reflect.ci:11: referenced as `int`
	cmplStd/test/lang/reflect.ci:10: referenced as `int`
	cmplStd/test/lang/reflect.ci:9: referenced as `int`
	cmplStd/test/lang/reflect.ci:8: referenced as `int32`
	cmplStd/test/lang/reflect.ci:8: referenced as `int`
	cmplStd/test/lang/reflect.ci:7: referenced as `int`
	cmplStd/test/lang/reflect.ci:6: referenced as `int`
	cmplStd/test/lang/reflect.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:4: referenced as `int`
	cmplStd/test/lang/reflect.ci:3: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:30: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:24: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:18: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:12: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:3: referenced as `int`
	cmplStd/test/lang/init.reference.ci:80: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:60: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:40: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:4: referenced as `int32`
	cmplStd/test/std/tryExec.ci:53: referenced as `int`
	cmplStd/test/std/tryExec.ci:52: referenced as `int`
	cmplStd/test/std/tryExec.ci:51: referenced as `int`
	cmplStd/test/std/tryExec.ci:50: referenced as `int`
	cmplStd/test/std/tryExec.ci:49: referenced as `int`
	cmplStd/test/std/tryExec.ci:48: referenced as `int`
	cmplStd/test/std/tryExec.ci:47: referenced as `int`
	cmplStd/test/std/tryExec.ci:40: referenced as `int`
	cmplStd/test/std/tryExec.ci:39: referenced as `int32`
	cmplStd/test/std/tryExec.ci:28: referenced as `int`
	cmplStd/test/std/tryExec.ci:27: referenced as `int`
	cmplStd/test/std/tryExec.ci:21: referenced as `int`
	cmplStd/test/std/memory.ci:4: referenced as `int`
	cmplStd/test/std/memory.ci:3: referenced as `int`
	cmplStd/test/std/number.ci:66: referenced as `int32`
	cmplStd/test/std/number.ci:65: referenced as `int32`
	cmplStd/test/std/number.ci:63: referenced as `int32`
	cmplStd/test/std/number.ci:62: referenced as `int32`
	cmplStd/test/std/number.ci:60: referenced as `int32`
	cmplStd/test/std/number.ci:59: referenced as `int32`
	cmplStd/test/std/number.ci:58: referenced as `int32`
	cmplStd/test/std/number.ci:57: referenced as `int32`
	cmplStd/test/std/number.ci:55: referenced as `int32`
	cmplStd/test/std/number.ci:35: referenced as `int32`
	cmplStd/test/std/number.ci:34: referenced as `int32`
	cmplStd/test/std/number.ci:33: referenced as `int32`
	cmplStd/test/std/number.ci:31: referenced as `int32`
	cmplStd/test/std/number.ci:30: referenced as `int32`
	cmplStd/test/std/number.ci:29: referenced as `int32`
	cmplStd/test/std/number.ci:27: referenced as `int32`
	cmplStd/test/std/number.ci:26: referenced as `int32`
	cmplStd/test/std/number.ci:25: referenced as `int32`
	cmplStd/test/std/number.ci:23: referenced as `int32`
	cmplStd/test/std/number.ci:22: referenced as `int32`
	cmplStd/test/std/number.ci:21: referenced as `int32`
	cmplStd/test/std/number.ci:19: referenced as `int32`
	cmplStd/test/std/number.ci:18: referenced as `int32`
	cmplStd/test/std/number.ci:16: referenced as `int`
	cmplStd/test/std/number.ci:15: referenced as `int`
	cmplStd/test/std/number.ci:14: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:5: referenced as `int32`
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:13: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:12: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:11: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:10: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/emit.ci:29: referenced as `int`
	cmplStd/test/lang/emit.ci:25: referenced as `int32`
	cmplStd/test/lang/emit.ci:23: referenced as `int32`
	cmplStd/test/lang/emit.ci:19: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:7: referenced as `int32`
	cmplStd/test/lang/emit.ci:6: referenced as `int32`
	cmplStd/test/lang/emit.ci:3: referenced as `int32`
	cmplStd/lib/text/string.ci:306: referenced as `int`
	cmplStd/lib/text/string.ci:294: referenced as `int`
	cmplStd/lib/text/string.ci:294: referenced as `int`
	cmplStd/lib/text/string.ci:294: referenced as `int`
	cmplStd/lib/text/string.ci:291: referenced as `int`
	cmplStd/lib/text/string.ci:277: referenced as `int`
	cmplStd/lib/text/string.ci:277: referenced as `int`
	cmplStd/lib/text/string.ci:265: referenced as `int`
	cmplStd/lib/text/string.ci:265: referenced as `int`
	cmplStd/lib/text/string.ci:255: referenced as `int`
	cmplStd/lib/text/string.ci:255: referenced as `int`
	cmplStd/lib/text/string.ci:252: referenced as `int`
	cmplStd/lib/text/string.ci:249: referenced as `int`
	cmplStd/lib/text/string.ci:246: referenced as `int32`
	cmplStd/lib/text/string.ci:246: referenced as `int`
	cmplStd/lib/text/string.ci:243: referenced as `int`
	cmplStd/lib/text/string.ci:229: referenced as `int`
	cmplStd/lib/text/string.ci:229: referenced as `int`
	cmplStd/lib/text/string.ci:229: referenced as `int`
	cmplStd/lib/text/string.ci:226: referenced as `int`
	cmplStd/lib/text/string.ci:223: referenced as `int`
	cmplStd/lib/text/string.ci:220: referenced as `int`
	cmplStd/lib/text/string.ci:217: referenced as `int`
	cmplStd/lib/text/string.ci:203: referenced as `int`
	cmplStd/lib/text/string.ci:172: referenced as `int`
	cmplStd/lib/text/string.ci:158: referenced as `int`
	cmplStd/lib/text/string.ci:154: referenced as `int`
	cmplStd/lib/text/string.ci:154: referenced as `int`
	cmplStd/lib/text/string.ci:154: referenced as `int`
	cmplStd/lib/text/string.ci:138: referenced as `int`
	cmplStd/lib/text/string.ci:134: referenced as `int`
	cmplStd/lib/text/string.ci:134: referenced as `int`
	cmplStd/lib/text/string.ci:130: referenced as `int`
	cmplStd/lib/text/string.ci:124: referenced as `int`
	cmplStd/lib/text/string.ci:93: referenced as `int`
	cmplStd/lib/text/string.ci:93: referenced as `int`
	cmplStd/lib/text/string.ci:88: referenced as `int`
	cmplStd/lib/text/string.ci:73: referenced as `int`
	cmplStd/lib/text/string.ci:63: referenced as `int`
	cmplStd/lib/text/string.ci:62: referenced as `int`
	cmplStd/lib/text/string.ci:61: referenced as `int`
	cmplStd/lib/text/string.ci:61: referenced as `int`
	cmplStd/lib/text/string.ci:52: referenced as `int`
	cmplStd/lib/text/string.ci:48: referenced as `int`
	cmplStd/lib/text/string.ci:47: referenced as `int`
	cmplStd/lib/text/string.ci:46: referenced as `int`
	cmplStd/lib/text/string.ci:37: referenced as `int`
	cmplStd/lib/text/string.ci:36: referenced as `int`
	cmplStd/lib/text/string.ci:27: referenced as `int`
	cmplStd/lib/text/string.ci:26: referenced as `int`
	cmplStd/lib/text/string.ci:25: referenced as `int`
	cmplStd/lib/text/string.ci:16: referenced as `int`
	cmplStd/lib/text/string.ci:15: referenced as `int`
	cmplStd/lib/text/string.ci:8: referenced as `int`
	cmplStd/lib/text/string.ci:4: referenced as `int`
	cmplStd/lib/math.ci:380: referenced as `int`
	cmplStd/lib/math.ci:380: referenced as `int`
	cmplStd/lib/math.ci:331: referenced as `int`
	cmplStd/lib/math.ci:299: referenced as `int`
	cmplStd/lib/math.ci:284: referenced as `int`
	cmplStd/lib/math.ci:269: referenced as `int`
	cmplStd/lib/math.ci:262: referenced as `int`
	cmplStd/lib/math.ci:236: referenced as `int`
	cmplStd/lib/math.ci:225: referenced as `int`
	cmplStd/lib/math.ci:211: referenced as `int`
	cmplStd/lib/math.ci:152: referenced as `int32`
	cmplStd/lib/math.ci:152: referenced as `int32`
	cmplStd/lib/math.ci:152: referenced as `int32`
	cmplStd/lib/math.ci:134: referenced as `int32`
	cmplStd/lib/math.ci:134: referenced as `int32`
	cmplStd/lib/math.ci:116: referenced as `int32`
	cmplStd/lib/math.ci:116: referenced as `int32`
	cmplStd/lib/math.ci:98: referenced as `int32`
	cmplStd/lib/math.ci:79: referenced as `int`
	cmplStd/lib/math.ci:79: referenced as `int`
	cmplStd/lib/math.ci:76: referenced as `int`
	cmplStd/lib/math.ci:76: referenced as `int`
	cmplStd/lib/math.ci:73: referenced as `int`
	cmplStd/lib/math.ci:70: referenced as `int`
	cmplStd/lib/math.ci:67: referenced as `int`
	cmplStd/lib/math.ci:67: referenced as `int`
	cmplStd/lib/math.ci:64: referenced as `int`
	cmplStd/lib/math.ci:64: referenced as `int`
	cmplStd/lib/math.ci:64: referenced as `int32`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/stdlib.ci:31: referenced as `int32`
	cmplStd/stdlib.ci:19: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@0004a8>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `integer`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `integer`
	cmplStd/test/lang/useOperator.ci:205: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:204: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:203: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:202: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:201: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:200: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:199: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:198: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:197: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:196: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:195: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:194: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:193: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:192: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:191: referenced as `int64`
	cmplStd/test/lang/reflect.ci:23: referenced as `int64`
	cmplStd/test/lang/reflect.ci:9: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:81: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:61: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:41: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:29: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:28: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:27: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:25: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:24: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:16: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:14: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:13: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:12: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:8: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:7: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:3: referenced as `integer`
	cmplStd/test/std/memory.ci:30: referenced as `int64`
	cmplStd/test/std/memory.ci:29: referenced as `int64`
	cmplStd/test/std/memory.ci:24: referenced as `int64`
	cmplStd/test/std/memory.ci:23: referenced as `int64`
	cmplStd/test/lang/emit.ci:26: referenced as `int64`
	cmplStd/test/lang/emit.ci:24: referenced as `int64`
	cmplStd/test/lang/emit.ci:21: referenced as `int64`
	cmplStd/test/lang/emit.ci:4: referenced as `int64`
	cmplStd/test/test.ci:5: referenced as `int64`
	cmplStd/lib/text/string.ci:285: referenced as `int64`
	cmplStd/lib/text/string.ci:268: referenced as `int64`
	cmplStd/lib/text/string.ci:252: referenced as `int64`
	cmplStd/lib/text/string.ci:249: referenced as `int64`
	cmplStd/lib/text/string.ci:246: referenced as `int64`
	cmplStd/lib/text/string.ci:243: referenced as `int64`
	cmplStd/lib/text/string.ci:243: referenced as `int64`
	cmplStd/lib/text/string.ci:229: referenced as `int64`
	cmplStd/lib/math.ci:155: referenced as `int64`
	cmplStd/lib/math.ci:155: referenced as `int64`
	cmplStd/lib/math.ci:155: referenced as `int64`
	cmplStd/lib/math.ci:137: referenced as `int64`
	cmplStd/lib/math.ci:137: referenced as `int64`
	cmplStd/lib/math.ci:119: referenced as `int64`
	cmplStd/lib/math.ci:119: referenced as `int64`
	cmplStd/lib/math.ci:101: referenced as `int64`
	cmplStd/lib/math.ci:67: referenced as `int64`
	cmplStd/stdlib.ci:34: referenced as `int64`
	cmplStd/stdlib.ci:22: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000550>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:90: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:89: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:88: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:87: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:86: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:85: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:84: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:83: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:82: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:81: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:80: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:79: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:78: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:77: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:76: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:57: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:55: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:53: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:47: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:45: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:43: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:37: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:35: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:33: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:27: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:25: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:23: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:17: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:15: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:13: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:7: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:5: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:3: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:12: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:11: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:10: referenced as `uint8`
	cmplStd/test/lang/reflect.ci:10: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:82: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:62: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:42: referenced as `uint8`
	cmplStd/test/std/tryExec.ci:16: referenced as `byte`
	cmplStd/lib/text/string.ci:226: referenced as `uint8`
	cmplStd/stdlib.ci:25: referenced as `uint8`
	cmplStd/stdlib.ci:13: referenced as `uint8`
	cmplStd/stdlib.ci:8: referenced as `uint8`
	internal usages: 1
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005f8>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:136: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:135: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:134: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:133: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:132: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:131: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:130: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:129: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:128: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:127: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:126: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:125: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:124: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:123: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:122: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:58: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:48: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:38: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:28: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:18: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:8: referenced as `uint16`
	cmplStd/test/lang/reflect.ci:11: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:83: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:63: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:43: referenced as `uint16`
	cmplStd/lib/text/string.ci:223: referenced as `uint16`
	cmplStd/stdlib.ci:28: referenced as `uint16`
	cmplStd/stdlib.ci:16: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0006a0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@00a560>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a8b8>, cast: static const inline)
.field pop: function (size: 0, offs: <@00aad0>, cast: static const inline)
.field swap: function (size: 0, offs: <@00ace8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00af00>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00b118>, cast: static const inline)
.field hib: function (size: 0, offs: <@00b330>, cast: static const inline)
.field lob: function (size: 0, offs: <@00b548>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:182: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:181: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:180: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:179: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:178: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:177: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:176: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:175: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:174: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:173: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:172: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:171: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:170: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:169: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:168: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:56: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:46: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:36: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:26: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:16: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:6: referenced as `uint32`
	cmplStd/test/lang/recUnion.ci:17: referenced as `uint32`
	cmplStd/test/lang/reflect.ci:12: referenced as `uint32`
	cmplStd/test/lang/function.ci:46: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:84: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:64: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:44: referenced as `uint32`
	cmplStd/test/std/number.ci:63: referenced as `uint32`
	cmplStd/test/std/number.ci:62: referenced as `uint32`
	cmplStd/test/std/number.ci:60: referenced as `uint32`
	cmplStd/test/std/number.ci:59: referenced as `uint32`
	cmplStd/test/std/number.ci:58: referenced as `uint32`
	cmplStd/test/std/number.ci:57: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:55: referenced as `uint32`
	cmplStd/test/std/number.ci:35: referenced as `uint32`
	cmplStd/test/std/number.ci:34: referenced as `uint32`
	cmplStd/test/std/number.ci:33: referenced as `uint32`
	cmplStd/test/std/number.ci:31: referenced as `uint32`
	cmplStd/test/std/number.ci:30: referenced as `uint32`
	cmplStd/test/std/number.ci:29: referenced as `uint32`
	cmplStd/test/std/number.ci:27: referenced as `uint32`
	cmplStd/test/std/number.ci:26: referenced as `uint32`
	cmplStd/test/std/number.ci:25: referenced as `uint32`
	cmplStd/test/std/number.ci:23: referenced as `uint32`
	cmplStd/test/std/number.ci:22: referenced as `uint32`
	cmplStd/test/std/number.ci:21: referenced as `uint32`
	cmplStd/lib/text/string.ci:220: referenced as `uint32`
	cmplStd/lib/math.ci:158: referenced as `uint32`
	cmplStd/lib/math.ci:158: referenced as `uint32`
	cmplStd/lib/math.ci:158: referenced as `uint32`
	cmplStd/lib/math.ci:140: referenced as `uint32`
	cmplStd/lib/math.ci:140: referenced as `uint32`
	cmplStd/lib/math.ci:122: referenced as `uint32`
	cmplStd/lib/math.ci:122: referenced as `uint32`
	cmplStd/lib/math.ci:104: referenced as `uint32`
	cmplStd/lib/math.ci:70: referenced as `uint32`
	cmplStd/stdlib.ci:31: referenced as `uint32`
	cmplStd/stdlib.ci:19: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a560>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(24)
.usages:
	cmplStd/test/std/number.ci:62: referenced as `zxt`
	cmplStd/test/std/number.ci:31: referenced as `zxt`
	cmplStd/test/std/number.ci:30: referenced as `zxt`
	cmplStd/test/std/number.ci:29: referenced as `zxt`
	cmplStd/test/std/number.ci:23: referenced as `zxt`
	cmplStd/test/std/number.ci:22: referenced as `zxt`
	cmplStd/test/std/number.ci:21: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a8b8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(25)
.usages:
	cmplStd/test/std/number.ci:63: referenced as `sxt`
	cmplStd/test/std/number.ci:35: referenced as `sxt`
	cmplStd/test/std/number.ci:34: referenced as `sxt`
	cmplStd/test/std/number.ci:33: referenced as `sxt`
	cmplStd/test/std/number.ci:27: referenced as `sxt`
	cmplStd/test/std/number.ci:26: referenced as `sxt`
	cmplStd/test/std/number.ci:25: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00aad0>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	cmplStd/test/std/number.ci:55: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ace8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	cmplStd/test/std/number.ci:56: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af00>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	cmplStd/test/std/number.ci:57: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b118>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(29)
.usages:
	cmplStd/test/std/number.ci:58: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b330>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(30)
.usages:
	cmplStd/test/std/number.ci:59: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b548>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(31)
.usages:
	cmplStd/test/std/number.ci:60: referenced as `lob`
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000748>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00b898>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00bbe8>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:228: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:227: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:226: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:225: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:224: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:223: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:222: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:221: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:220: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:219: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:218: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:217: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:216: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:215: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:214: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:54: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:44: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:34: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:24: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:14: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:4: referenced as `uint64`
	cmplStd/test/lang/reflect.ci:13: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:85: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:65: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:45: referenced as `uint64`
	cmplStd/test/std/number.ci:66: referenced as `uint64`
	cmplStd/test/std/number.ci:65: referenced as `uint64`
	cmplStd/lib/text/string.ci:285: referenced as `uint64`
	cmplStd/lib/text/string.ci:268: referenced as `uint64`
	cmplStd/lib/text/string.ci:239: referenced as `uint64`
	cmplStd/lib/text/string.ci:226: referenced as `uint64`
	cmplStd/lib/text/string.ci:223: referenced as `uint64`
	cmplStd/lib/text/string.ci:220: referenced as `uint64`
	cmplStd/lib/text/string.ci:217: referenced as `uint64`
	cmplStd/lib/text/string.ci:217: referenced as `uint64`
	cmplStd/lib/text/string.ci:154: referenced as `uint64`
	cmplStd/lib/math.ci:161: referenced as `uint64`
	cmplStd/lib/math.ci:161: referenced as `uint64`
	cmplStd/lib/math.ci:161: referenced as `uint64`
	cmplStd/lib/math.ci:143: referenced as `uint64`
	cmplStd/lib/math.ci:143: referenced as `uint64`
	cmplStd/lib/math.ci:125: referenced as `uint64`
	cmplStd/lib/math.ci:125: referenced as `uint64`
	cmplStd/lib/math.ci:107: referenced as `uint64`
	cmplStd/lib/math.ci:73: referenced as `uint64`
	cmplStd/stdlib.ci:34: referenced as `uint64`
	cmplStd/stdlib.ci:22: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b898>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(32)
.usages:
	cmplStd/test/std/number.ci:65: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bbe8>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(33)
.usages:
	cmplStd/test/std/number.ci:66: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00be00>, cast: static const inline)
.field cos: function (size: 0, offs: <@00c018>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c230>, cast: static const inline)
.field log: function (size: 0, offs: <@00c448>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c660>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c918>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00cb30>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00cde8>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `float32`
	cmplStd/test/std/test.math.ci:95: referenced as `float32`
	cmplStd/test/std/test.math.ci:94: referenced as `float32`
	cmplStd/test/std/test.math.ci:93: referenced as `float32`
	cmplStd/test/std/test.math.ci:91: referenced as `float32`
	cmplStd/test/std/test.math.ci:90: referenced as `float32`
	cmplStd/test/std/test.math.ci:89: referenced as `float32`
	cmplStd/test/std/test.math.ci:88: referenced as `float32`
	cmplStd/test/std/test.math.ci:86: referenced as `float32`
	cmplStd/test/std/test.math.ci:85: referenced as `float32`
	cmplStd/test/std/test.math.ci:84: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:246: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:245: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:244: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:243: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:242: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:240: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:239: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:238: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:237: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:5: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:4: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:3: referenced as `float32`
	cmplStd/test/lang/reflect.ci:14: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:86: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:66: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:7: referenced as `float32`
	cmplStd/test/std/number.ci:6: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:13: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:12: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:11: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:10: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:9: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:6: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/lib/text/string.ci:291: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:203: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:169: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float`
	cmplStd/lib/math/Matrix4f.ci:137: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:132: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math.ci:269: referenced as `float32`
	cmplStd/lib/math.ci:269: referenced as `float32`
	cmplStd/lib/math.ci:269: referenced as `float32`
	cmplStd/lib/math.ci:200: referenced as `float32`
	cmplStd/lib/math.ci:200: referenced as `float32`
	cmplStd/lib/math.ci:200: referenced as `float32`
	cmplStd/lib/math.ci:196: referenced as `float32`
	cmplStd/lib/math.ci:191: referenced as `float32`
	cmplStd/lib/math.ci:191: referenced as `float32`
	cmplStd/lib/math.ci:191: referenced as `float32`
	cmplStd/lib/math.ci:164: referenced as `float32`
	cmplStd/lib/math.ci:164: referenced as `float32`
	cmplStd/lib/math.ci:164: referenced as `float32`
	cmplStd/lib/math.ci:164: referenced as `float32`
	cmplStd/lib/math.ci:146: referenced as `float32`
	cmplStd/lib/math.ci:146: referenced as `float32`
	cmplStd/lib/math.ci:128: referenced as `float32`
	cmplStd/lib/math.ci:128: referenced as `float32`
	cmplStd/lib/math.ci:110: referenced as `float32`
	cmplStd/lib/math.ci:82: referenced as `float32`
	cmplStd/lib/math.ci:82: referenced as `float32`
	cmplStd/lib/math.ci:82: referenced as `float32`
	cmplStd/lib/math.ci:76: referenced as `float32`
	cmplStd/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be00>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	cmplStd/test/std/number.ci:46: referenced as `sin`
	cmplStd/test/lang/emit.ci:16: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c018>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	cmplStd/test/std/number.ci:47: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c230>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(36)
.usages:
	cmplStd/test/std/number.ci:48: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c448>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(37)
.usages:
	cmplStd/test/std/number.ci:49: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c660>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(38)
.usages:
	cmplStd/test/std/number.ci:50: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c918>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(39)
.usages:
	cmplStd/test/std/number.ci:51: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cb30>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(40)
.usages:
	cmplStd/test/std/number.ci:52: referenced as `sqrt`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cde8>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(41)
.usages:
	cmplStd/test/std/number.ci:53: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000898>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00cff8>, cast: static const inline)
.field cos: function (size: 0, offs: <@00d208>, cast: static const inline)
.field tan: function (size: 0, offs: <@00d418>, cast: static const inline)
.field log: function (size: 0, offs: <@00d628>, cast: static const inline)
.field exp: function (size: 0, offs: <@00d838>, cast: static const inline)
.field pow: function (size: 0, offs: <@00dae8>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00dcf8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00dfa8>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `float64`
	cmplStd/test/std/test.math.ci:81: referenced as `float64`
	cmplStd/test/std/test.math.ci:80: referenced as `float64`
	cmplStd/test/std/test.math.ci:79: referenced as `float64`
	cmplStd/test/std/test.math.ci:77: referenced as `float64`
	cmplStd/test/std/test.math.ci:76: referenced as `float64`
	cmplStd/test/std/test.math.ci:75: referenced as `float64`
	cmplStd/test/std/test.math.ci:74: referenced as `float64`
	cmplStd/test/std/test.math.ci:72: referenced as `float64`
	cmplStd/test/std/test.math.ci:71: referenced as `float64`
	cmplStd/test/std/test.math.ci:70: referenced as `float64`
	cmplStd/test/std/test.math.ci:64: referenced as `float64`
	cmplStd/test/std/test.math.ci:63: referenced as `float64`
	cmplStd/test/std/test.math.ci:61: referenced as `float64`
	cmplStd/test/std/test.math.ci:60: referenced as `float64`
	cmplStd/test/std/test.math.ci:59: referenced as `float64`
	cmplStd/test/std/test.math.ci:58: referenced as `float64`
	cmplStd/test/std/test.math.ci:57: referenced as `float64`
	cmplStd/test/std/test.math.ci:55: referenced as `float64`
	cmplStd/test/std/test.math.ci:54: referenced as `float64`
	cmplStd/test/std/test.math.ci:53: referenced as `float64`
	cmplStd/test/std/test.math.ci:52: referenced as `float64`
	cmplStd/test/std/test.math.ci:51: referenced as `float64`
	cmplStd/test/std/test.math.ci:50: referenced as `float64`
	cmplStd/test/std/test.math.ci:49: referenced as `float64`
	cmplStd/test/std/test.math.ci:48: referenced as `float64`
	cmplStd/test/std/test.math.ci:46: referenced as `float64`
	cmplStd/test/std/test.math.ci:45: referenced as `float64`
	cmplStd/test/std/test.math.ci:44: referenced as `float64`
	cmplStd/test/std/test.math.ci:43: referenced as `float64`
	cmplStd/test/std/test.math.ci:41: referenced as `float64`
	cmplStd/test/std/test.math.ci:40: referenced as `float64`
	cmplStd/test/std/test.math.ci:39: referenced as `float64`
	cmplStd/test/std/test.math.ci:38: referenced as `float64`
	cmplStd/test/std/test.math.ci:36: referenced as `float64`
	cmplStd/test/std/test.math.ci:35: referenced as `float64`
	cmplStd/test/std/test.math.ci:33: referenced as `float64`
	cmplStd/test/std/test.math.ci:32: referenced as `float64`
	cmplStd/test/std/test.math.ci:30: referenced as `float64`
	cmplStd/test/std/test.math.ci:29: referenced as `float64`
	cmplStd/test/std/test.math.ci:27: referenced as `float64`
	cmplStd/test/std/test.math.ci:26: referenced as `float64`
	cmplStd/test/std/test.math.ci:25: referenced as `float64`
	cmplStd/test/std/test.math.ci:24: referenced as `float64`
	cmplStd/test/std/test.math.ci:22: referenced as `float64`
	cmplStd/test/std/test.math.ci:21: referenced as `float64`
	cmplStd/test/std/test.math.ci:20: referenced as `float64`
	cmplStd/test/std/test.math.ci:19: referenced as `float64`
	cmplStd/test/std/test.math.ci:18: referenced as `float64`
	cmplStd/test/std/test.math.ci:17: referenced as `float64`
	cmplStd/test/std/test.math.ci:15: referenced as `float64`
	cmplStd/test/std/test.math.ci:14: referenced as `float64`
	cmplStd/test/std/test.math.ci:13: referenced as `float64`
	cmplStd/test/std/test.math.ci:12: referenced as `float64`
	cmplStd/test/std/test.math.ci:11: referenced as `float64`
	cmplStd/test/std/test.math.ci:10: referenced as `float64`
	cmplStd/test/std/test.math.ci:8: referenced as `float64`
	cmplStd/test/std/test.math.ci:7: referenced as `float64`
	cmplStd/test/std/test.math.ci:6: referenced as `float64`
	cmplStd/test/std/test.math.ci:5: referenced as `float64`
	cmplStd/test/std/test.math.ci:4: referenced as `float64`
	cmplStd/test/std/test.math.ci:3: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:269: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:268: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:267: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:266: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:265: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:263: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:262: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:261: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:260: referenced as `float64`
	cmplStd/test/lang/reflect.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:14: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:11: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:10: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:87: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:67: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:47: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:4: referenced as `float64`
	cmplStd/test/std/number.ci:3: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:16: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:15: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/lib/text/string.ci:303: referenced as `float64`
	cmplStd/lib/text/string.ci:302: referenced as `float64`
	cmplStd/lib/text/string.ci:301: referenced as `float64`
	cmplStd/lib/text/string.ci:300: referenced as `float64`
	cmplStd/lib/text/string.ci:291: referenced as `float64`
	cmplStd/lib/text/string.ci:270: referenced as `float64`
	cmplStd/lib/text/string.ci:267: referenced as `float64`
	cmplStd/lib/text/string.ci:255: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:146: referenced as `float64`
	cmplStd/lib/math/Complex.ci:142: referenced as `float64`
	cmplStd/lib/math/Complex.ci:141: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:137: referenced as `float64`
	cmplStd/lib/math/Complex.ci:136: referenced as `float64`
	cmplStd/lib/math/Complex.ci:132: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:118: referenced as `float64`
	cmplStd/lib/math/Complex.ci:114: referenced as `float64`
	cmplStd/lib/math/Complex.ci:112: referenced as `float64`
	cmplStd/lib/math/Complex.ci:109: referenced as `float64`
	cmplStd/lib/math/Complex.ci:107: referenced as `float64`
	cmplStd/lib/math/Complex.ci:99: referenced as `float64`
	cmplStd/lib/math/Complex.ci:98: referenced as `float64`
	cmplStd/lib/math/Complex.ci:92: referenced as `float64`
	cmplStd/lib/math/Complex.ci:91: referenced as `float64`
	cmplStd/lib/math/Complex.ci:83: referenced as `float64`
	cmplStd/lib/math/Complex.ci:81: referenced as `float64`
	cmplStd/lib/math/Complex.ci:73: referenced as `float64`
	cmplStd/lib/math/Complex.ci:71: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:64: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:24: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math.ci:529: referenced as `float64`
	cmplStd/lib/math.ci:529: referenced as `float64`
	cmplStd/lib/math.ci:526: referenced as `float64`
	cmplStd/lib/math.ci:526: referenced as `float64`
	cmplStd/lib/math.ci:502: referenced as `float64`
	cmplStd/lib/math.ci:489: referenced as `float64`
	cmplStd/lib/math.ci:486: referenced as `float64`
	cmplStd/lib/math.ci:484: referenced as `float64`
	cmplStd/lib/math.ci:484: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:459: referenced as `float64`
	cmplStd/lib/math.ci:459: referenced as `float64`
	cmplStd/lib/math.ci:457: referenced as `float64`
	cmplStd/lib/math.ci:452: referenced as `float64`
	cmplStd/lib/math.ci:452: referenced as `float64`
	cmplStd/lib/math.ci:440: referenced as `float64`
	cmplStd/lib/math.ci:437: referenced as `float64`
	cmplStd/lib/math.ci:437: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:432: referenced as `float64`
	cmplStd/lib/math.ci:415: referenced as `float64`
	cmplStd/lib/math.ci:413: referenced as `float64`
	cmplStd/lib/math.ci:413: referenced as `float64`
	cmplStd/lib/math.ci:397: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:379: referenced as `float64`
	cmplStd/lib/math.ci:378: referenced as `float64`
	cmplStd/lib/math.ci:357: referenced as `float64`
	cmplStd/lib/math.ci:356: referenced as `float64`
	cmplStd/lib/math.ci:356: referenced as `float64`
	cmplStd/lib/math.ci:353: referenced as `float64`
	cmplStd/lib/math.ci:350: referenced as `float64`
	cmplStd/lib/math.ci:345: referenced as `float64`
	cmplStd/lib/math.ci:344: referenced as `float64`
	cmplStd/lib/math.ci:343: referenced as `float64`
	cmplStd/lib/math.ci:326: referenced as `float64`
	cmplStd/lib/math.ci:322: referenced as `float64`
	cmplStd/lib/math.ci:319: referenced as `float64`
	cmplStd/lib/math.ci:313: referenced as `float64`
	cmplStd/lib/math.ci:300: referenced as `float64`
	cmplStd/lib/math.ci:299: referenced as `float64`
	cmplStd/lib/math.ci:299: referenced as `float64`
	cmplStd/lib/math.ci:284: referenced as `float64`
	cmplStd/lib/math.ci:284: referenced as `float64`
	cmplStd/lib/math.ci:284: referenced as `float64`
	cmplStd/lib/math.ci:261: referenced as `float64`
	cmplStd/lib/math.ci:260: referenced as `float64`
	cmplStd/lib/math.ci:260: referenced as `float64`
	cmplStd/lib/math.ci:260: referenced as `float64`
	cmplStd/lib/math.ci:257: referenced as `float64`
	cmplStd/lib/math.ci:257: referenced as `float64`
	cmplStd/lib/math.ci:257: referenced as `float64`
	cmplStd/lib/math.ci:257: referenced as `float64`
	cmplStd/lib/math.ci:257: referenced as `float64`
	cmplStd/lib/math.ci:254: referenced as `float64`
	cmplStd/lib/math.ci:254: referenced as `float64`
	cmplStd/lib/math.ci:254: referenced as `float64`
	cmplStd/lib/math.ci:254: referenced as `float64`
	cmplStd/lib/math.ci:251: referenced as `float64`
	cmplStd/lib/math.ci:251: referenced as `float64`
	cmplStd/lib/math.ci:251: referenced as `float64`
	cmplStd/lib/math.ci:248: referenced as `float64`
	cmplStd/lib/math.ci:248: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:235: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:224: referenced as `float64`
	cmplStd/lib/math.ci:220: referenced as `float64`
	cmplStd/lib/math.ci:220: referenced as `float64`
	cmplStd/lib/math.ci:210: referenced as `float64`
	cmplStd/lib/math.ci:206: referenced as `float64`
	cmplStd/lib/math.ci:206: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:197: referenced as `float64`
	cmplStd/lib/math.ci:194: referenced as `float64`
	cmplStd/lib/math.ci:194: referenced as `float64`
	cmplStd/lib/math.ci:194: referenced as `float64`
	cmplStd/lib/math.ci:175: referenced as `float64`
	cmplStd/lib/math.ci:175: referenced as `float64`
	cmplStd/lib/math.ci:175: referenced as `float64`
	cmplStd/lib/math.ci:175: referenced as `float64`
	cmplStd/lib/math.ci:149: referenced as `float64`
	cmplStd/lib/math.ci:149: referenced as `float64`
	cmplStd/lib/math.ci:131: referenced as `float64`
	cmplStd/lib/math.ci:131: referenced as `float64`
	cmplStd/lib/math.ci:113: referenced as `float64`
	cmplStd/lib/math.ci:90: referenced as `float64`
	cmplStd/lib/math.ci:90: referenced as `float64`
	cmplStd/lib/math.ci:90: referenced as `float64`
	cmplStd/lib/math.ci:79: referenced as `float64`
	cmplStd/lib/math.ci:57: referenced as `float64`
	cmplStd/lib/math.ci:54: referenced as `float64`
	cmplStd/lib/math.ci:48: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:32: referenced as `float64`
	cmplStd/lib/math.ci:25: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:5: referenced as `float64`
	cmplStd/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cff8>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	cmplStd/test/std/number.ci:37: referenced as `sin`
	cmplStd/lib/math/Complex.ci:187: referenced as `sin`
	cmplStd/lib/math/Complex.ci:151: referenced as `sin`
	cmplStd/lib/math/Complex.ci:149: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:129: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d208>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	cmplStd/test/std/number.ci:38: referenced as `cos`
	cmplStd/lib/math/Complex.ci:187: referenced as `cos`
	cmplStd/lib/math/Complex.ci:151: referenced as `cos`
	cmplStd/lib/math/Complex.ci:149: referenced as `cos`
	cmplStd/lib/math/Complex.ci:141: referenced as `cos`
	cmplStd/lib/math/Complex.ci:129: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d418>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(44)
.usages:
	cmplStd/test/std/number.ci:39: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d628>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(45)
.usages:
	cmplStd/test/std/number.ci:40: referenced as `log`
	cmplStd/lib/math/Complex.ci:138: referenced as `log`
	cmplStd/lib/math/Complex.ci:132: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d838>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(46)
.usages:
	cmplStd/test/std/number.ci:41: referenced as `exp`
	cmplStd/lib/math/Complex.ci:139: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math.ci:459: referenced as `exp`
	cmplStd/lib/math.ci:459: referenced as `exp`
	cmplStd/lib/math.ci:457: referenced as `exp`
	cmplStd/lib/math.ci:437: referenced as `exp`
	cmplStd/lib/math.ci:437: referenced as `exp`
	cmplStd/lib/math.ci:432: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00dae8>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(47)
.usages:
	cmplStd/test/std/number.ci:42: referenced as `pow`
	cmplStd/lib/math/Complex.ci:139: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00dcf8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(48)
.usages:
	cmplStd/test/std/number.ci:43: referenced as `sqrt`
	cmplStd/lib/math/Complex.ci:112: referenced as `sqrt`
	cmplStd/lib/math.ci:484: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00dfa8>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(49)
.usages:
	cmplStd/test/std/number.ci:44: referenced as `atan2`
	cmplStd/lib/math/Complex.ci:114: referenced as `atan2`
	cmplStd/lib/math.ci:489: referenced as `atan2`
	cmplStd/lib/math.ci:486: referenced as `atan2`
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000940>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@0089c0>, cast: static const inline)
.field fill: function (size: 0, offs: <@008d20>, cast: static const inline)
.field copy: function (size: 0, offs: <@009080>, cast: static const inline)
.field move: function (size: 0, offs: <@0093d8>, cast: static const inline)
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:283: referenced as `pointer`
	cmplStd/test/lang/reflect.ci:16: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:108: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:90: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:70: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:52: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:51: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:49: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:48: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:47: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:46: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:45: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:44: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:43: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:42: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:41: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:40: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:39: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:38: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:37: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:36: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:35: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:30: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:17: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:9: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:43: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:38: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:24: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:20: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:14: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:11: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:14: referenced as `pointer`
	cmplStd/test/std/memory.ci:13: referenced as `pointer`
	cmplStd/test/std/memory.ci:10: referenced as `pointer`
	cmplStd/test/std/memory.ci:9: referenced as `pointer`
	cmplStd/test/std/memory.ci:8: referenced as `pointer`
	cmplStd/test/std/memory.ci:7: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:4: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/emit.ci:29: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089c0>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(13)
.usages:
	cmplStd/test/std/memory.ci:5: referenced as `alloc`
	cmplStd/test/std/memory.ci:4: referenced as `alloc`
	cmplStd/test/std/memory.ci:3: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d20>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: uint8 (size: 4, offs: <+8>, cast: variable(u32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(14)
.usages:
	cmplStd/test/std/memory.ci:30: referenced as `fill`
	cmplStd/test/std/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009080>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(15)
.usages:
	cmplStd/test/std/memory.ci:14: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093d8>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(16)
.usages:
	cmplStd/test/std/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@0009e8>
.name: 'variant'
.field as: function (size: 0, offs: <@006198>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:17: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:105: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:91: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:72: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:70: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:69: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:68: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:67: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:66: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:65: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:64: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:63: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:62: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:61: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:60: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:59: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:58: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:57: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:56: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:55: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:51: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:31: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:24: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:18: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:10: referenced as `variant`
	cmplStd/lib/debug.ci:65: referenced as `variant`
	cmplStd/lib/debug.ci:56: referenced as `variant`
	cmplStd/lib/debug.ci:53: referenced as `variant`
	cmplStd/lib/debug.ci:50: referenced as `variant`
	cmplStd/lib/debug.ci:41: referenced as `variant`
	cmplStd/lib/debug.ci:34: referenced as `variant`
	cmplStd/lib/debug.ci:29: referenced as `variant`
	cmplStd/lib/debug.ci:24: referenced as `variant`
	cmplStd/lib/debug.ci:19: referenced as `variant`
	cmplStd/lib/debug.ci:14: referenced as `variant`
	cmplStd/lib/debug.ci:9: referenced as `variant`
	cmplStd/lib/debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006198>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a90>
.name: 'function'
.usages:
	cmplStd/test/lang/reflect.ci:19: referenced as `function`
	cmplStd/test/lang/init.reference.ci:89: referenced as `function`
	cmplStd/test/lang/init.reference.ci:69: referenced as `function`
	cmplStd/test/lang/init.reference.ci:49: referenced as `function`
	cmplStd/test/lang/init.reference.ci:20: referenced as `function`
	cmplStd/stdlib.ci:39: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000b40>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.field type: function (size: 0, offs: <@0076f8>, cast: static const inline)
.usages:
	cmplStd/test/lang/recUnion.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:20: referenced as `object`
	cmplStd/test/lang/init.variable.ci:41: referenced as `object`
	cmplStd/test/lang/init.variable.ci:13: referenced as `object`
	cmplStd/test/lang/init.reference.ci:92: referenced as `object`
	cmplStd/test/lang/init.reference.ci:72: referenced as `object`
	cmplStd/test/lang/init.reference.ci:52: referenced as `object`
	cmplStd/test/lang/init.reference.ci:21: referenced as `object`
	internal usages: 3
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0076f8>
.name: 'type'
.owner: object
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(10)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	cmplStd/test/lang/stmt.if.ci:73: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `null`
	cmplStd/test/lang/useOperator.ci:283: referenced as `null`
	cmplStd/test/lang/init.method.ci:92: referenced as `null`
	cmplStd/test/lang/init.method.ci:86: referenced as `null`
	cmplStd/test/lang/init.reference.ci:21: referenced as `null`
	cmplStd/test/lang/init.reference.ci:20: referenced as `null`
	cmplStd/test/lang/init.reference.ci:19: referenced as `null`
	cmplStd/test/lang/init.reference.ci:18: referenced as `null`
	cmplStd/test/lang/init.reference.ci:17: referenced as `null`
	cmplStd/test/lang/init.reference.ci:16: referenced as `null`
	cmplStd/test/lang/init.reference.ci:3: referenced as `null`
	cmplStd/test/std/tryExec.ci:53: referenced as `null`
	cmplStd/test/std/tryExec.ci:52: referenced as `null`
	cmplStd/test/std/tryExec.ci:51: referenced as `null`
	cmplStd/test/std/tryExec.ci:50: referenced as `null`
	cmplStd/test/std/tryExec.ci:49: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:47: referenced as `null`
	cmplStd/test/std/tryExec.ci:39: referenced as `null`
	cmplStd/test/std/memory.ci:4: referenced as `null`
	cmplStd/lib/text/string.ci:135: referenced as `null`
	cmplStd/lib/text/string.ci:5: referenced as `null`
	cmplStd/lib/debug.ci:74: referenced as `null`
	cmplStd/lib/debug.ci:56: referenced as `null`
	cmplStd/lib/debug.ci:38: referenced as `null`
	cmplStd/lib/debug.ci:36: referenced as `null`
	cmplStd/lib/debug.ci:31: referenced as `null`
	cmplStd/lib/debug.ci:26: referenced as `null`
	cmplStd/lib/debug.ci:21: referenced as `null`
	cmplStd/lib/debug.ci:16: referenced as `null`
	cmplStd/lib/debug.ci:11: referenced as `null`
	cmplStd/lib/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000de0>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000e88>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001278>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001320>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0015c0>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001ba8>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001f70>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@002168>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@002350>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002538>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002720>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002908>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002c30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@0030b8>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003520>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@003988>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f30>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044d8>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004940>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004da8>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005210>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005678>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005860>, cast: static const typename(void))
.field swz: typename (size: 0, offs: <@005a48>, cast: static const typename(void))
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:29: referenced as `emit`
	cmplStd/test/lang/emit.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:19: referenced as `emit`
	cmplStd/test/lang/emit.ci:16: referenced as `emit`
	cmplStd/test/lang/emit.ci:13: referenced as `emit`
	cmplStd/test/lang/emit.ci:10: referenced as `emit`
	cmplStd/test/lang/emit.ci:4: referenced as `emit`
	cmplStd/test/lang/emit.ci:3: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:76: referenced as `emit`
	cmplStd/lib/math/Complex.ci:69: referenced as `emit`
	cmplStd/lib/math/Complex.ci:62: referenced as `emit`
	cmplStd/lib/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001278>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:112: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:116: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001320>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0015c0>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `load`
	cmplStd/test/lang/emit.ci:4: referenced as `load`
	cmplStd/test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `z32`
	cmplStd/test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	cmplStd/test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001ba8>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f70>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002168>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002350>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002538>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002720>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002908>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002c30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0030b8>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `add`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:77: referenced as `add`
	cmplStd/lib/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003520>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:78: referenced as `sub`
	cmplStd/lib/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003988>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:78: referenced as `mul`
	cmplStd/lib/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:78: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f30>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `div`
	cmplStd/test/lang/emit.ci:13: referenced as `div`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	cmplStd/test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044d8>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004940>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004da8>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005210>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005678>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005860>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005a48>
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `swz`
	cmplStd/lib/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `x2`
	cmplStd/lib/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ed8>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007db0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(11)
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/stdlib.ci:39: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	cmplStd/lib/debug.ci:71: referenced as `abort`
	cmplStd/lib/debug.ci:38: referenced as `abort`
	cmplStd/lib/debug.ci:36: referenced as `abort`
	cmplStd/lib/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	cmplStd/lib/debug.ci:31: referenced as `error`
	cmplStd/lib/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	cmplStd/lib/debug.ci:26: referenced as `warn`
	cmplStd/lib/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	cmplStd/lib/debug.ci:21: referenced as `info`
	cmplStd/lib/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `debug`
	cmplStd/lib/debug.ci:16: referenced as `debug`
	cmplStd/lib/debug.ci:14: referenced as `debug`
	cmplStd/lib/debug.ci:11: referenced as `debug`
	cmplStd/lib/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	cmplStd/lib/debug.ci:6: referenced as `verbose`
	cmplStd/lib/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	cmplStd/lib/debug.ci:26: referenced as `noTrace`
	cmplStd/lib/debug.ci:24: referenced as `noTrace`
	cmplStd/lib/debug.ci:21: referenced as `noTrace`
	cmplStd/lib/debug.ci:19: referenced as `noTrace`
	cmplStd/lib/debug.ci:11: referenced as `noTrace`
	cmplStd/lib/debug.ci:9: referenced as `noTrace`
	cmplStd/lib/debug.ci:6: referenced as `noTrace`
	cmplStd/lib/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	cmplStd/lib/debug.ci:71: referenced as `defTrace`
	cmplStd/lib/debug.ci:38: referenced as `defTrace`
	cmplStd/lib/debug.ci:36: referenced as `defTrace`
	cmplStd/lib/debug.ci:34: referenced as `defTrace`
	cmplStd/lib/debug.ci:31: referenced as `defTrace`
	cmplStd/lib/debug.ci:29: referenced as `defTrace`
	cmplStd/lib/debug.ci:16: referenced as `defTrace`
	cmplStd/lib/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008700>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(12)
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:52: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:51: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:50: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:49: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:48: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:47: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@009408>
.name: 'System'
.field exit: function (size: 0, offs: <@0096a0>, cast: static const inline)
.field srand: function (size: 0, offs: <@0098c0>, cast: static const inline)
.field time: function (size: 0, offs: <@009a38>, cast: static const inline)
.field millis: function (size: 0, offs: <@009bb0>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009dc8>, cast: static const inline)
.field rand: function (size: 0, offs: <@009f40>, cast: static const inline)
.field clock: function (size: 0, offs: <@00a158>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096a0>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(17)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098c0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(18)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009a38>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(19)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009bb0>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(20)
.usages:
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009dc8>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(21)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009f40>
.name: 'rand'
.owner: System
.field max: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(22)
.usages:
}
System.rand.max: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'max'
.owner: System.rand(): int32
.value: 2147483647
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a158>
.name: 'clock'
.owner: System
.field perSec: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(23)
.usages:
}
System.clock.perSec: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'perSec'
.owner: System.clock(): int32
.value: 1000000
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.file: 'cmplStd/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	cmplStd/test/lang/useOperator.ci:7: referenced as `true`
	cmplStd/lib/text/string.ci:57: referenced as `true`
	cmplStd/lib/text/string.ci:42: referenced as `true`
	cmplStd/lib/math.ci:475: referenced as `true`
	cmplStd/lib/math.ci:428: referenced as `true`
	cmplStd/lib/math.ci:389: referenced as `true`
	cmplStd/lib/math.ci:385: referenced as `true`
	cmplStd/lib/math.ci:374: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.file: 'cmplStd/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:8: referenced as `false`
	cmplStd/lib/text/string.ci:54: referenced as `false`
	cmplStd/lib/text/string.ci:50: referenced as `false`
	cmplStd/lib/text/string.ci:39: referenced as `false`
	cmplStd/lib/math.ci:473: referenced as `false`
	cmplStd/lib/math.ci:425: referenced as `false`
	cmplStd/lib/math.ci:370: referenced as `false`
	cmplStd/lib/math.ci:369: referenced as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'cmplStd/stdlib.ci:8'
.value: uint8
.usages:
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'cmplStd/stdlib.ci:9'
.value: float32
.usages:
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'cmplStd/stdlib.ci:10'
.value: float64
.usages:
}
signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:13'
.param .result: int8 (size: 1, offs: <+0>, cast: i32)
.param value: uint8 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:16'
.param .result: int16 (size: 2, offs: <+0>, cast: i32)
.param value: uint16 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math.ci:244: referenced as `signed`
}
signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:22'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:25'
.param .result: uint8 (size: 1, offs: <+0>, cast: u32)
.param value: int8 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:28'
.param .result: uint16 (size: 2, offs: <+0>, cast: u32)
.param value: int16 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:31'
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param value: int32 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:34'
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param value: int64 (size: 8, offs: <+8>, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'cmplStd/stdlib.ci:37'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: typename.size(type)
.usages:
	cmplStd/test/lang/reflect.ci:20: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:19: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:18: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:17: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:16: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:15: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:14: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:13: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:12: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:11: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:10: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:9: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:8: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:7: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:6: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:5: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:4: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:3: referenced as `sizeof`
	cmplStd/test/std/memory.ci:30: referenced as `sizeof`
	cmplStd/test/std/memory.ci:29: referenced as `sizeof`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	cmplStd/test/lang/stmt.for.ci:28: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:21: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:14: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:9: referenced as `debug`
	cmplStd/test/std/memory.ci:33: referenced as `debug`
	cmplStd/test/std/memory.ci:32: referenced as `debug`
	cmplStd/test/std/memory.ci:27: referenced as `debug`
	cmplStd/test/std/memory.ci:26: referenced as `debug`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.for.ci:4: referenced as `debug`
	cmplStd/test/lang/init.method.ci:91: referenced as `debug`
	cmplStd/test/lang/init.method.ci:85: referenced as `debug`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/lang/init.method.ci:58: referenced as `trace`
	cmplStd/test/lang/init.method.ci:48: referenced as `trace`
	cmplStd/test/lang/init.method.ci:41: referenced as `trace`
	cmplStd/test/lang/init.method.ci:11: referenced as `trace`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `trace`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.if.ci:78: referenced as `error`
	cmplStd/test/lang/stmt.if.ci:74: referenced as `error`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/std/tryExec.ci:35: referenced as `abort`
	cmplStd/lib/debug.ci:41: referenced as `abort`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	cmplStd/lib/debug.ci:45: referenced as `abort`
	cmplStd/lib/debug.ci:43: referenced as `abort`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	cmplStd/lib/text/string.ci:162: referenced as `assert`
	cmplStd/lib/text/string.ci:161: referenced as `assert`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	cmplStd/lib/text/string.ci:204: referenced as `assert`
	cmplStd/lib/text/string.ci:197: referenced as `assert`
	cmplStd/lib/text/string.ci:190: referenced as `assert`
	cmplStd/lib/text/string.ci:185: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@012978>
.name: 'NotEquals'
.file: 'cmplStd/lib/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field extras: variant[] (size: 8, offs: <+16>, cast: const variable(arr))
.doc: '@public'
.usages:
	cmplStd/lib/debug.ci:66: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'cmplStd/lib/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/debug.ci:67: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'cmplStd/lib/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/debug.ci:68: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.offset: <+16>
.name: 'extras'
.file: 'cmplStd/lib/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	cmplStd/lib/debug.ci:69: referenced as `extras`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 103
.offset: <@061b20>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:61'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	extras: variant[1] := {
		void(extras[0] := (message));
	};
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.extras := (extras));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (103 bytes: <assertEq @061b20> - <assertEq+103 @061b87>)
	cmplStd/lib/debug.ci:62: (10 bytes: <assertEq @061b20> - <assertEq+10 @061b2a>): if (returned == expected)
	<assertEq @061b20>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @061b22>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @061b24>    : 57                         ceq.i32
	<assertEq+5 @061b25>    : 06 05 00 00                jz <assertEq+10 @061b2a>
	cmplStd/lib/debug.ci:63: (1 byte: <assertEq+9 @061b29> - <assertEq+10 @061b2a>): return;
	<assertEq+9 @061b29>    : 03                         ret
	cmplStd/lib/debug.ci:65: (13 bytes: <assertEq+10 @061b2a> - <assertEq+23 @061b37>): extras: variant[1] := {...}
	<assertEq+10 @061b2a>   : 09 08 00 00                inc.sp(+8)
	cmplStd/lib/debug.ci:65: (9 bytes: <assertEq+14 @061b2e> - <assertEq+23 @061b37>): extras[0] := (message);
	<assertEq+14 @061b2e>   : 1f 78 2e 01 00             load.ref <@012e78>
	<assertEq+19 @061b33>   : 10 04                      dup.x32 sp(4)
	<assertEq+21 @061b35>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:66: (37 bytes: <assertEq+23 @061b37> - <assertEq+60 @061b5c>): details: NotEquals := {...}
	<assertEq+23 @061b37>   : 09 18 00 00                inc.sp(+24)
	cmplStd/lib/debug.ci:67: (11 bytes: <assertEq+27 @061b3b> - <assertEq+38 @061b46>): details.expected := (expected);
	<assertEq+27 @061b3b>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+32 @061b40>   : 0a 30 00 00                load.sp(+48)
	<assertEq+36 @061b44>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:68: (11 bytes: <assertEq+38 @061b46> - <assertEq+49 @061b51>): details.returned := (returned);
	<assertEq+38 @061b46>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+43 @061b4b>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+47 @061b4f>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/debug.ci:69: (11 bytes: <assertEq+49 @061b51> - <assertEq+60 @061b5c>): details.extras := (extras);
	<assertEq+49 @061b51>   : 1c 01 00 00 00             load.c32 1
	<assertEq+54 @061b56>   : 0a 1c 00 00                load.sp(+28)
	<assertEq+58 @061b5a>   : 14 06                      set.x64 sp(6)
	cmplStd/lib/debug.ci:71: (38 bytes: <assertEq+60 @061b5c> - <assertEq+98 @061b82>): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+60 @061b5c>   : 1f 20 f5 00 00             load.ref <@00f520> ;"cmplStd/lib/debug.ci"
	<assertEq+65 @061b61>   : 1c 47 00 00 00             load.c32 71
	<assertEq+70 @061b66>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+75 @061b6b>   : 1c 80 00 00 00             load.c32 128
	<assertEq+80 @061b70>   : 1f 00 f8 00 00             load.ref <@00f800> ;"assertion failed"
	<assertEq+85 @061b75>   : 1f 78 29 01 00             load.ref <@012978> ;NotEquals
	<assertEq+90 @061b7a>   : 0a 18 00 00                load.sp(+24)
	<assertEq+94 @061b7e>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+98 @061b82>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+102 @061b86>  : 03                         ret
.usages:
	cmplStd/lib/debug.ci:74: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:74'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@013c50>
.name: 'Math'
.file: 'cmplStd/lib/math.ci:2'
.field pi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field e: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 0, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 0, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@061b88>, cast: static function)
.field floor: function (size: 24, offs: <@061be0>, cast: static function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field absMod: function (size: 27, offs: <@061bf8>, cast: static function)
.field absMod: function (size: 27, offs: <@061c18>, cast: static function)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 30, offs: <@061c38>, cast: static function)
.field clamp: function (size: 30, offs: <@061c58>, cast: static function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@061c78>, cast: static function)
.field max: function (size: 79, offs: <@061cc8>, cast: static function)
.field sum: function (size: 40, offs: <@061d18>, cast: static function)
.field mean: function (size: 20, offs: <@061d40>, cast: static function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@061d58>, cast: static function)
.field cmp: function (size: 57, offs: <@061d88>, cast: static function)
.field cmp: function (size: 57, offs: <@061dc8>, cast: static function)
.field sinCos: function (size: 335, offs: <@061e08>, cast: static function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@061f58>, cast: static function)
.field sinh: function (size: 241, offs: <@0620d8>, cast: static function)
.field cosh: function (size: 75, offs: <@0621d0>, cast: static function)
.field asin: function (size: 173, offs: <@062220>, cast: static function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `Math`
	cmplStd/test/std/test.math.ci:95: referenced as `Math`
	cmplStd/test/std/test.math.ci:94: referenced as `Math`
	cmplStd/test/std/test.math.ci:93: referenced as `Math`
	cmplStd/test/std/test.math.ci:91: referenced as `Math`
	cmplStd/test/std/test.math.ci:90: referenced as `Math`
	cmplStd/test/std/test.math.ci:89: referenced as `Math`
	cmplStd/test/std/test.math.ci:88: referenced as `Math`
	cmplStd/test/std/test.math.ci:86: referenced as `Math`
	cmplStd/test/std/test.math.ci:85: referenced as `Math`
	cmplStd/test/std/test.math.ci:84: referenced as `Math`
	cmplStd/test/std/test.math.ci:82: referenced as `Math`
	cmplStd/test/std/test.math.ci:81: referenced as `Math`
	cmplStd/test/std/test.math.ci:80: referenced as `Math`
	cmplStd/test/std/test.math.ci:79: referenced as `Math`
	cmplStd/test/std/test.math.ci:77: referenced as `Math`
	cmplStd/test/std/test.math.ci:76: referenced as `Math`
	cmplStd/test/std/test.math.ci:75: referenced as `Math`
	cmplStd/test/std/test.math.ci:74: referenced as `Math`
	cmplStd/test/std/test.math.ci:72: referenced as `Math`
	cmplStd/test/std/test.math.ci:71: referenced as `Math`
	cmplStd/test/std/test.math.ci:70: referenced as `Math`
	cmplStd/test/std/test.math.ci:68: referenced as `Math`
	cmplStd/test/std/test.math.ci:67: referenced as `Math`
	cmplStd/test/std/test.math.ci:64: referenced as `Math`
	cmplStd/test/std/test.math.ci:63: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:55: referenced as `Math`
	cmplStd/test/std/test.math.ci:54: referenced as `Math`
	cmplStd/test/std/test.math.ci:53: referenced as `Math`
	cmplStd/test/std/test.math.ci:52: referenced as `Math`
	cmplStd/test/std/test.math.ci:51: referenced as `Math`
	cmplStd/test/std/test.math.ci:50: referenced as `Math`
	cmplStd/test/std/test.math.ci:49: referenced as `Math`
	cmplStd/test/std/test.math.ci:46: referenced as `Math`
	cmplStd/test/std/test.math.ci:45: referenced as `Math`
	cmplStd/test/std/test.math.ci:44: referenced as `Math`
	cmplStd/test/std/test.math.ci:43: referenced as `Math`
	cmplStd/test/std/test.math.ci:41: referenced as `Math`
	cmplStd/test/std/test.math.ci:40: referenced as `Math`
	cmplStd/test/std/test.math.ci:39: referenced as `Math`
	cmplStd/test/std/test.math.ci:38: referenced as `Math`
	cmplStd/test/std/test.math.ci:36: referenced as `Math`
	cmplStd/test/std/test.math.ci:35: referenced as `Math`
	cmplStd/test/std/test.math.ci:33: referenced as `Math`
	cmplStd/test/std/test.math.ci:32: referenced as `Math`
	cmplStd/test/std/test.math.ci:30: referenced as `Math`
	cmplStd/test/std/test.math.ci:29: referenced as `Math`
	cmplStd/test/std/test.math.ci:27: referenced as `Math`
	cmplStd/test/std/test.math.ci:26: referenced as `Math`
	cmplStd/test/std/test.math.ci:25: referenced as `Math`
	cmplStd/test/std/test.math.ci:24: referenced as `Math`
	cmplStd/test/std/test.math.ci:22: referenced as `Math`
	cmplStd/test/std/test.math.ci:21: referenced as `Math`
	cmplStd/test/std/test.math.ci:20: referenced as `Math`
	cmplStd/test/std/test.math.ci:19: referenced as `Math`
	cmplStd/test/std/test.math.ci:18: referenced as `Math`
	cmplStd/test/std/test.math.ci:17: referenced as `Math`
	cmplStd/test/std/test.math.ci:15: referenced as `Math`
	cmplStd/test/std/test.math.ci:14: referenced as `Math`
	cmplStd/test/std/test.math.ci:13: referenced as `Math`
	cmplStd/test/std/test.math.ci:12: referenced as `Math`
	cmplStd/test/std/test.math.ci:11: referenced as `Math`
	cmplStd/test/std/test.math.ci:10: referenced as `Math`
	cmplStd/test/std/test.math.ci:8: referenced as `Math`
	cmplStd/test/std/test.math.ci:7: referenced as `Math`
	cmplStd/test/std/test.math.ci:6: referenced as `Math`
	cmplStd/test/std/test.math.ci:5: referenced as `Math`
	cmplStd/test/std/test.math.ci:4: referenced as `Math`
	cmplStd/test/std/test.math.ci:3: referenced as `Math`
	cmplStd/lib/text/string.ci:327: referenced as `Math`
	cmplStd/lib/text/string.ci:315: referenced as `Math`
	cmplStd/lib/text/string.ci:284: referenced as `Math`
	cmplStd/lib/text/string.ci:277: referenced as `Math`
	cmplStd/lib/text/string.ci:267: referenced as `Math`
	cmplStd/lib/text/string.ci:267: referenced as `Math`
	cmplStd/lib/text/string.ci:265: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'pi'
.file: 'cmplStd/lib/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `pi`
	cmplStd/test/std/test.math.ci:60: referenced as `pi`
	cmplStd/test/std/test.math.ci:59: referenced as `pi`
	cmplStd/test/std/test.math.ci:58: referenced as `pi`
	cmplStd/test/std/test.math.ci:57: referenced as `pi`
	cmplStd/lib/math.ci:529: referenced as `pi`
	cmplStd/lib/math.ci:526: referenced as `pi`
	cmplStd/lib/math.ci:502: referenced as `pi`
	cmplStd/lib/math.ci:486: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'e'
.file: 'cmplStd/lib/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln2'
.file: 'cmplStd/lib/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log2E'
.file: 'cmplStd/lib/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln10'
.file: 'cmplStd/lib/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log10E'
.file: 'cmplStd/lib/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'phi'
.file: 'cmplStd/lib/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrt2'
.file: 'cmplStd/lib/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtE'
.file: 'cmplStd/lib/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPi'
.file: 'cmplStd/lib/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'nan'
.file: 'cmplStd/lib/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/text/string.ci:327: referenced as `nan`
	cmplStd/lib/text/string.ci:315: referenced as `nan`
	cmplStd/lib/math.ci:481: referenced as `nan`
	cmplStd/lib/math.ci:402: referenced as `nan`
	cmplStd/lib/math.ci:222: referenced as `nan`
	cmplStd/lib/math.ci:208: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'inf'
.file: 'cmplStd/lib/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 86
.offset: <@061b88>
.name: 'modf'
.file: 'cmplStd/lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <modf @061b88> - <modf+86 @061bde>)
	cmplStd/lib/math.ci:23: (63 bytes: <modf @061b88> - <modf+63 @061bc7>): if (x < (1))
	<modf @061b88>      : 11 02                      dup.x64 sp(2)
	<modf+2 @061b8a>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @061b93>   : 88                         clt.f64
	<modf+12 @061b94>   : 06 33 00 00                jz <modf+63 @061bc7>
	cmplStd/lib/math.ci:24: (39 bytes: <modf+16 @061b98> - <modf+55 @061bbf>): if (x < (0))
	<modf+16 @061b98>   : 11 02                      dup.x64 sp(2)
	<modf+18 @061b9a>   : 1a                         load.z64
	<modf+19 @061b9b>   : 88                         clt.f64
	<modf+20 @061b9c>   : 06 23 00 00                jz <modf+55 @061bbf>
	cmplStd/lib/math.ci:25: (17 bytes: <modf+24 @061ba0> - <modf+41 @061bb1>): result: float64 := -modf(-x, &intPart)
	<modf+24 @061ba0>   : 1a                         load.z64
	<modf+25 @061ba1>   : 11 04                      dup.x64 sp(4)
	<modf+27 @061ba3>   : 80                         neg.f64
	<modf+28 @061ba4>   : 10 05                      dup.x32 sp(5)
	<modf+30 @061ba6>   : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @061bab>   : 02                         call
	<modf+36 @061bac>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @061bb0>   : 80                         neg.f64
	cmplStd/lib/math.ci:26: (7 bytes: <modf+41 @061bb1> - <modf+48 @061bb8>): intPart := -intPart;
	<modf+41 @061bb1>   : 10 03                      dup.x32 sp(3)
	<modf+43 @061bb3>   : 29                         load.i64
	<modf+44 @061bb4>   : 80                         neg.f64
	<modf+45 @061bb5>   : 10 05                      dup.x32 sp(5)
	<modf+47 @061bb7>   : 2e                         store.i64
	cmplStd/lib/math.ci:27: (3 bytes: <modf+48 @061bb8> - <modf+51 @061bbb>): return .result := result;
	<modf+48 @061bb8>   : 14 06                      set.x64 sp(6)
	<modf+50 @061bba>   : 03                         ret
	<modf+51 @061bbb>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:29: (4 bytes: <modf+55 @061bbf> - <modf+59 @061bc3>): intPart := (0);
	<modf+55 @061bbf>   : 1a                         load.z64
	<modf+56 @061bc0>   : 10 03                      dup.x32 sp(3)
	<modf+58 @061bc2>   : 2e                         store.i64
	cmplStd/lib/math.ci:30: (4 bytes: <modf+59 @061bc3> - <modf+63 @061bc7>): return .result := x;
	<modf+59 @061bc3>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @061bc6>   : 03                         ret
	cmplStd/lib/math.ci:32: (12 bytes: <modf+63 @061bc7> - <modf+75 @061bd3>): result: float64 := x % (1)
	<modf+63 @061bc7>   : 11 02                      dup.x64 sp(2)
	<modf+65 @061bc9>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @061bd2>   : 85                         mod.f64
	cmplStd/lib/math.ci:33: (8 bytes: <modf+75 @061bd3> - <modf+83 @061bdb>): intPart := x - result;
	<modf+75 @061bd3>   : 11 04                      dup.x64 sp(4)
	<modf+77 @061bd5>   : 11 02                      dup.x64 sp(2)
	<modf+79 @061bd7>   : 82                         sub.f64
	<modf+80 @061bd8>   : 10 05                      dup.x32 sp(5)
	<modf+82 @061bda>   : 2e                         store.i64
	cmplStd/lib/math.ci:34: (3 bytes: <modf+83 @061bdb> - <modf+86 @061bde>): return .result := result;
	<modf+83 @061bdb>   : 14 06                      set.x64 sp(6)
	<modf+85 @061bdd>   : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:284: referenced as `modf`
	cmplStd/lib/text/string.ci:267: referenced as `modf`
	cmplStd/lib/math.ci:379: referenced as `modf`
	cmplStd/lib/math.ci:327: referenced as `modf`
	cmplStd/lib/math.ci:323: referenced as `modf`
	cmplStd/lib/math.ci:49: referenced as `modf`
	cmplStd/lib/math.ci:25: referenced as `modf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@061be0>
.name: 'floor'
.file: 'cmplStd/lib/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <floor @061be0> - <floor+24 @061bf8>)
	cmplStd/lib/math.ci:48: (1 byte: <floor @061be0> - <floor+1 @061be1>): result: float64
	<floor @061be0>      : 1b                         load.z128
	cmplStd/lib/math.ci:49: (20 bytes: <floor+1 @061be1> - <floor+21 @061bf5>): modf(x, &result);
	<floor+1 @061be1>    : 11 05                      dup.x64 sp(5)
	<floor+3 @061be3>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @061be7>    : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @061bec>   : 02                         call
	<floor+13 @061bed>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @061bf1>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:50: (3 bytes: <floor+21 @061bf5> - <floor+24 @061bf8>): return .result := result;
	<floor+21 @061bf5>   : 14 05                      set.x64 sp(5)
	<floor+23 @061bf7>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:8: referenced as `floor`
	cmplStd/test/std/test.math.ci:7: referenced as `floor`
	cmplStd/test/std/test.math.ci:6: referenced as `floor`
	cmplStd/test/std/test.math.ci:5: referenced as `floor`
	cmplStd/test/std/test.math.ci:4: referenced as `floor`
	cmplStd/test/std/test.math.ci:3: referenced as `floor`
	cmplStd/lib/math.ci:57: referenced as `floor`
	cmplStd/lib/math.ci:54: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'cmplStd/lib/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'cmplStd/lib/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
}
Math.sign(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > 0)) - int32(bool(x < 0)))
.usages:
}
Math.sign(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int64 (size: 8, offs: <+8>, cast: variable(i64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
}
Math.sign(x: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:70'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'Returns the signum of the input (`0` if zero, `1` if positive)'
.value: int32(bool(x > (0)))
.usages:
}
Math.sign(x: uint64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:73'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'Returns the signum of the input (`0` if zero, `1` if positive)'
.value: int32(bool(x > (0)))
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:76'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:15: referenced as `sign`
	cmplStd/test/std/test.math.ci:14: referenced as `sign`
	cmplStd/test/std/test.math.ci:13: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:79'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:12: referenced as `sign`
	cmplStd/test/std/test.math.ci:11: referenced as `sign`
	cmplStd/test/std/test.math.ci:10: referenced as `sign`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@061bf8>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:82'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <absMod @061bf8> - <absMod+27 @061c13>)
	cmplStd/lib/math.ci:83: (23 bytes: <absMod @061bf8> - <absMod+23 @061c0f>): if ((val := val % mod) < (0))
	<absMod @061bf8>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @061bfa>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @061bfc>    : 75                         mod.f32
	<absMod+5 @061bfd>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @061bff>    : 13 04                      set.x32 sp(4)
	<absMod+9 @061c01>    : 19                         load.z32
	<absMod+10 @061c02>   : 78                         clt.f32
	<absMod+11 @061c03>   : 06 0c 00 00                jz <absMod+23 @061c0f>
	cmplStd/lib/math.ci:84: (8 bytes: <absMod+15 @061c07> - <absMod+23 @061c0f>): return .result := val + mod;
	<absMod+15 @061c07>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @061c09>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @061c0b>   : 71                         add.f32
	<absMod+20 @061c0c>   : 13 04                      set.x32 sp(4)
	<absMod+22 @061c0e>   : 03                         ret
	cmplStd/lib/math.ci:86: (4 bytes: <absMod+23 @061c0f> - <absMod+27 @061c13>): return .result := val;
	<absMod+23 @061c0f>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @061c12>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `absMod`
	cmplStd/test/std/test.math.ci:95: referenced as `absMod`
	cmplStd/test/std/test.math.ci:94: referenced as `absMod`
	cmplStd/test/std/test.math.ci:93: referenced as `absMod`
	cmplStd/test/std/test.math.ci:91: referenced as `absMod`
	cmplStd/test/std/test.math.ci:90: referenced as `absMod`
	cmplStd/test/std/test.math.ci:89: referenced as `absMod`
	cmplStd/test/std/test.math.ci:88: referenced as `absMod`
	cmplStd/test/std/test.math.ci:86: referenced as `absMod`
	cmplStd/test/std/test.math.ci:85: referenced as `absMod`
	cmplStd/test/std/test.math.ci:84: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@061c18>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:90'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <absMod @061c18> - <absMod+27 @061c33>)
	cmplStd/lib/math.ci:91: (23 bytes: <absMod @061c18> - <absMod+23 @061c2f>): if ((val := val % mod) < (0))
	<absMod @061c18>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @061c1a>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @061c1c>    : 85                         mod.f64
	<absMod+5 @061c1d>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @061c1f>    : 14 07                      set.x64 sp(7)
	<absMod+9 @061c21>    : 1a                         load.z64
	<absMod+10 @061c22>   : 88                         clt.f64
	<absMod+11 @061c23>   : 06 0c 00 00                jz <absMod+23 @061c2f>
	cmplStd/lib/math.ci:92: (8 bytes: <absMod+15 @061c27> - <absMod+23 @061c2f>): return .result := val + mod;
	<absMod+15 @061c27>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @061c29>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @061c2b>   : 81                         add.f64
	<absMod+20 @061c2c>   : 14 07                      set.x64 sp(7)
	<absMod+22 @061c2e>   : 03                         ret
	cmplStd/lib/math.ci:94: (4 bytes: <absMod+23 @061c2f> - <absMod+27 @061c33>): return .result := val;
	<absMod+23 @061c2f>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @061c32>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `absMod`
	cmplStd/test/std/test.math.ci:81: referenced as `absMod`
	cmplStd/test/std/test.math.ci:80: referenced as `absMod`
	cmplStd/test/std/test.math.ci:79: referenced as `absMod`
	cmplStd/test/std/test.math.ci:77: referenced as `absMod`
	cmplStd/test/std/test.math.ci:76: referenced as `absMod`
	cmplStd/test/std/test.math.ci:75: referenced as `absMod`
	cmplStd/test/std/test.math.ci:74: referenced as `absMod`
	cmplStd/test/std/test.math.ci:72: referenced as `absMod`
	cmplStd/test/std/test.math.ci:71: referenced as `absMod`
	cmplStd/test/std/test.math.ci:70: referenced as `absMod`
}
Math.abs(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:98'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'Returns the absolute value of the input'
.value: bool(x < 0) ? int32(-x) : x
.usages:
}
Math.abs(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:101'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param x: int64 (size: 8, offs: <+8>, cast: variable(i64))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? int64(-x) : x
.usages:
}
Math.abs(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:104'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param x: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:107'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param x: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:110'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? float32(-x) : x
.usages:
	cmplStd/test/std/test.math.ci:22: referenced as `abs`
	cmplStd/test/std/test.math.ci:21: referenced as `abs`
	cmplStd/test/std/test.math.ci:20: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:113'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? float64(-x) : x
.usages:
	cmplStd/test/std/test.math.ci:19: referenced as `abs`
	cmplStd/test/std/test.math.ci:18: referenced as `abs`
	cmplStd/test/std/test.math.ci:17: referenced as `abs`
	cmplStd/lib/text/string.ci:267: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math.ci:353: referenced as `abs`
}
Math.min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:116'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/lib/text/string.ci:277: referenced as `min`
	cmplStd/lib/text/string.ci:265: referenced as `min`
}
Math.min(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:119'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param a: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+16>, cast: variable(i64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:122'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param a: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:125'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:128'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:24: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:131'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:26: referenced as `min`
}
Math.max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:134'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:137'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param a: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+16>, cast: variable(i64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:140'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param a: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:143'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:146'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:25: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:149'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:27: referenced as `max`
}
Math.clamp(t: int32, a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:152'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param t: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: bool(t < a) ? a : bool(t > b) ? b : t
.usages:
}
Math.clamp(t: int64, a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:155'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param t: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param a: int64 (size: 8, offs: <+16>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+24>, cast: variable(i64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: bool(t < a) ? a : bool(t > b) ? b : t
.usages:
}
Math.clamp(t: uint32, a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:158'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param t: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param a: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: bool(t < a) ? a : bool(t > b) ? b : t
.usages:
}
Math.clamp(t: uint64, a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:161'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param t: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param a: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+24>, cast: variable(u64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: bool(t < a) ? a : bool(t > b) ? b : t
.usages:
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@061c38>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:164'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <clamp @061c38> - <clamp+30 @061c56>)
	cmplStd/lib/math.ci:165: (13 bytes: <clamp @061c38> - <clamp+13 @061c45>): if (t < a)
	<clamp @061c38>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @061c3a>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @061c3c>    : 78                         clt.f32
	<clamp+5 @061c3d>    : 06 08 00 00                jz <clamp+13 @061c45>
	cmplStd/lib/math.ci:166: (4 bytes: <clamp+9 @061c41> - <clamp+13 @061c45>): return .result := a;
	<clamp+9 @061c41>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @061c44>   : 03                         ret
	cmplStd/lib/math.ci:168: (13 bytes: <clamp+13 @061c45> - <clamp+26 @061c52>): if (t > b)
	<clamp+13 @061c45>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @061c47>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @061c49>   : 79                         cgt.f32
	<clamp+18 @061c4a>   : 06 08 00 00                jz <clamp+26 @061c52>
	cmplStd/lib/math.ci:169: (4 bytes: <clamp+22 @061c4e> - <clamp+26 @061c52>): return .result := b;
	<clamp+22 @061c4e>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @061c51>   : 03                         ret
	cmplStd/lib/math.ci:171: (4 bytes: <clamp+26 @061c52> - <clamp+30 @061c56>): return .result := t;
	<clamp+26 @061c52>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @061c55>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:29: referenced as `clamp`
	cmplStd/lib/math.ci:200: referenced as `clamp`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@061c58>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:175'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <clamp @061c58> - <clamp+30 @061c76>)
	cmplStd/lib/math.ci:176: (13 bytes: <clamp @061c58> - <clamp+13 @061c65>): if (t < a)
	<clamp @061c58>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @061c5a>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @061c5c>    : 88                         clt.f64
	<clamp+5 @061c5d>    : 06 08 00 00                jz <clamp+13 @061c65>
	cmplStd/lib/math.ci:177: (4 bytes: <clamp+9 @061c61> - <clamp+13 @061c65>): return .result := a;
	<clamp+9 @061c61>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @061c64>   : 03                         ret
	cmplStd/lib/math.ci:179: (13 bytes: <clamp+13 @061c65> - <clamp+26 @061c72>): if (t > b)
	<clamp+13 @061c65>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @061c67>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @061c69>   : 89                         cgt.f64
	<clamp+18 @061c6a>   : 06 08 00 00                jz <clamp+26 @061c72>
	cmplStd/lib/math.ci:180: (4 bytes: <clamp+22 @061c6e> - <clamp+26 @061c72>): return .result := b;
	<clamp+22 @061c6e>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @061c71>   : 03                         ret
	cmplStd/lib/math.ci:182: (4 bytes: <clamp+26 @061c72> - <clamp+30 @061c76>): return .result := t;
	<clamp+26 @061c72>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @061c75>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:30: referenced as `clamp`
	cmplStd/lib/math.ci:203: referenced as `clamp`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:32: referenced as `lerp`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:194'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:33: referenced as `lerp`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:196'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	cmplStd/lib/math.ci:200: referenced as `smooth`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:197'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	cmplStd/lib/math.ci:203: referenced as `smooth`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:200'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)))
.usages:
	cmplStd/test/std/test.math.ci:35: referenced as `smooth`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:203'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)))
.usages:
	cmplStd/test/std/test.math.ci:36: referenced as `smooth`
}
Math.min(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@061c78>
.name: 'min'
.file: 'cmplStd/lib/math.ci:206'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <min @061c78> - <min+79 @061cc7>)
	cmplStd/lib/math.ci:207: (20 bytes: <min @061c78> - <min+20 @061c8c>): if (data.length == (0))
	<min @061c78>      : 10 02                      dup.x32 sp(2)
	<min+2 @061c7a>    : 19                         load.z32
	<min+3 @061c7b>    : 57                         ceq.i32
	<min+4 @061c7c>    : 06 10 00 00                jz <min+20 @061c8c>
	cmplStd/lib/math.ci:208: (12 bytes: <min+8 @061c80> - <min+20 @061c8c>): return .result := nan;
	<min+8 @061c80>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @061c89>   : 14 05                      set.x64 sp(5)
	<min+19 @061c8b>   : 03                         ret
	cmplStd/lib/math.ci:210: (3 bytes: <min+20 @061c8c> - <min+23 @061c8f>): result: float64 := data[0]
	<min+20 @061c8c>   : 10 01                      dup.x32 sp(1)
	<min+22 @061c8e>   : 29                         load.i64
	cmplStd/lib/math.ci:211: (53 bytes: <min+23 @061c8f> - <min+76 @061cc4>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+23 @061c8f>   : 1c 01 00 00 00             load.c32 1
	<min+28 @061c94>   : 04 23 00 00                jmp <min+63 @061cb7>
	cmplStd/lib/math.ci:212: (27 bytes: <min+32 @061c98> - <min+59 @061cb3>): if (result > data[i])
	<min+32 @061c98>   : 11 01                      dup.x64 sp(1)
	<min+34 @061c9a>   : 10 06                      dup.x32 sp(6)
	<min+36 @061c9c>   : 10 03                      dup.x32 sp(3)
	<min+38 @061c9e>   : 0d 08 00 00                mad.u32 8
	<min+42 @061ca2>   : 29                         load.i64
	<min+43 @061ca3>   : 89                         cgt.f64
	<min+44 @061ca4>   : 06 0f 00 00                jz <min+59 @061cb3>
	cmplStd/lib/math.ci:213: (11 bytes: <min+48 @061ca8> - <min+59 @061cb3>): result := data[i];
	<min+48 @061ca8>   : 10 04                      dup.x32 sp(4)
	<min+50 @061caa>   : 10 01                      dup.x32 sp(1)
	<min+52 @061cac>   : 0d 08 00 00                mad.u32 8
	<min+56 @061cb0>   : 29                         load.i64
	<min+57 @061cb1>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:211: (4 bytes: <min+59 @061cb3> - <min+63 @061cb7>): i := i + 1
	<min+59 @061cb3>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:211: (9 bytes: <min+63 @061cb7> - <min+72 @061cc0>): i < (data.length)
	<min+63 @061cb7>   : 10 00                      dup.x32 sp(0)
	<min+65 @061cb9>   : 10 06                      dup.x32 sp(6)
	<min+67 @061cbb>   : 58                         clt.i32
	<min+68 @061cbc>   : 05 dc ff ff                jnz <min+32 @061c98>
	<min+72 @061cc0>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:216: (3 bytes: <min+76 @061cc4> - <min+79 @061cc7>): return .result := result;
	<min+76 @061cc4>   : 14 05                      set.x64 sp(5)
	<min+78 @061cc6>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:39: referenced as `min`
	cmplStd/test/std/test.math.ci:38: referenced as `min`
}
Math.max(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@061cc8>
.name: 'max'
.file: 'cmplStd/lib/math.ci:220'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <max @061cc8> - <max+79 @061d17>)
	cmplStd/lib/math.ci:221: (20 bytes: <max @061cc8> - <max+20 @061cdc>): if (data.length == (0))
	<max @061cc8>      : 10 02                      dup.x32 sp(2)
	<max+2 @061cca>    : 19                         load.z32
	<max+3 @061ccb>    : 57                         ceq.i32
	<max+4 @061ccc>    : 06 10 00 00                jz <max+20 @061cdc>
	cmplStd/lib/math.ci:222: (12 bytes: <max+8 @061cd0> - <max+20 @061cdc>): return .result := nan;
	<max+8 @061cd0>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @061cd9>   : 14 05                      set.x64 sp(5)
	<max+19 @061cdb>   : 03                         ret
	cmplStd/lib/math.ci:224: (3 bytes: <max+20 @061cdc> - <max+23 @061cdf>): result: float64 := data[0]
	<max+20 @061cdc>   : 10 01                      dup.x32 sp(1)
	<max+22 @061cde>   : 29                         load.i64
	cmplStd/lib/math.ci:225: (53 bytes: <max+23 @061cdf> - <max+76 @061d14>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+23 @061cdf>   : 1c 01 00 00 00             load.c32 1
	<max+28 @061ce4>   : 04 23 00 00                jmp <max+63 @061d07>
	cmplStd/lib/math.ci:226: (27 bytes: <max+32 @061ce8> - <max+59 @061d03>): if (result < data[i])
	<max+32 @061ce8>   : 11 01                      dup.x64 sp(1)
	<max+34 @061cea>   : 10 06                      dup.x32 sp(6)
	<max+36 @061cec>   : 10 03                      dup.x32 sp(3)
	<max+38 @061cee>   : 0d 08 00 00                mad.u32 8
	<max+42 @061cf2>   : 29                         load.i64
	<max+43 @061cf3>   : 88                         clt.f64
	<max+44 @061cf4>   : 06 0f 00 00                jz <max+59 @061d03>
	cmplStd/lib/math.ci:227: (11 bytes: <max+48 @061cf8> - <max+59 @061d03>): result := data[i];
	<max+48 @061cf8>   : 10 04                      dup.x32 sp(4)
	<max+50 @061cfa>   : 10 01                      dup.x32 sp(1)
	<max+52 @061cfc>   : 0d 08 00 00                mad.u32 8
	<max+56 @061d00>   : 29                         load.i64
	<max+57 @061d01>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:225: (4 bytes: <max+59 @061d03> - <max+63 @061d07>): i := i + 1
	<max+59 @061d03>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:225: (9 bytes: <max+63 @061d07> - <max+72 @061d10>): i < (data.length)
	<max+63 @061d07>   : 10 00                      dup.x32 sp(0)
	<max+65 @061d09>   : 10 06                      dup.x32 sp(6)
	<max+67 @061d0b>   : 58                         clt.i32
	<max+68 @061d0c>   : 05 dc ff ff                jnz <max+32 @061ce8>
	<max+72 @061d10>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:230: (3 bytes: <max+76 @061d14> - <max+79 @061d17>): return .result := result;
	<max+76 @061d14>   : 14 05                      set.x64 sp(5)
	<max+78 @061d16>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:41: referenced as `max`
	cmplStd/test/std/test.math.ci:40: referenced as `max`
}
Math.sum(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.offset: <@061d18>
.name: 'sum'
.file: 'cmplStd/lib/math.ci:234'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <sum @061d18> - <sum+40 @061d40>)
	cmplStd/lib/math.ci:235: (1 byte: <sum @061d18> - <sum+1 @061d19>): result: float64 := 0
	<sum @061d18>      : 1b                         load.z128
	cmplStd/lib/math.ci:236: (36 bytes: <sum+1 @061d19> - <sum+37 @061d3d>): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+1 @061d19>    : 6a                         i64.2i32
	<sum+2 @061d1a>    : 04 16 00 00                jmp <sum+24 @061d30>
	cmplStd/lib/math.ci:237: (14 bytes: <sum+6 @061d1e> - <sum+20 @061d2c>): result := result + data[i];
	<sum+6 @061d1e>    : 11 01                      dup.x64 sp(1)
	<sum+8 @061d20>    : 10 06                      dup.x32 sp(6)
	<sum+10 @061d22>   : 10 03                      dup.x32 sp(3)
	<sum+12 @061d24>   : 0d 08 00 00                mad.u32 8
	<sum+16 @061d28>   : 29                         load.i64
	<sum+17 @061d29>   : 81                         add.f64
	<sum+18 @061d2a>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:236: (4 bytes: <sum+20 @061d2c> - <sum+24 @061d30>): i := i + 1
	<sum+20 @061d2c>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:236: (9 bytes: <sum+24 @061d30> - <sum+33 @061d39>): i < (data.length)
	<sum+24 @061d30>   : 10 00                      dup.x32 sp(0)
	<sum+26 @061d32>   : 10 06                      dup.x32 sp(6)
	<sum+28 @061d34>   : 58                         clt.i32
	<sum+29 @061d35>   : 05 e9 ff ff                jnz <sum+6 @061d1e>
	<sum+33 @061d39>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:239: (3 bytes: <sum+37 @061d3d> - <sum+40 @061d40>): return .result := result;
	<sum+37 @061d3d>   : 14 05                      set.x64 sp(5)
	<sum+39 @061d3f>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:46: referenced as `sum`
	cmplStd/test/std/test.math.ci:45: referenced as `sum`
	cmplStd/test/std/test.math.ci:44: referenced as `sum`
	cmplStd/test/std/test.math.ci:43: referenced as `sum`
	cmplStd/lib/math.ci:244: referenced as `sum`
}
Math.mean(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.offset: <@061d40>
.name: 'mean'
.file: 'cmplStd/lib/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
}
.instructions: (20 bytes: <mean @061d40> - <mean+20 @061d54>)
	cmplStd/lib/math.ci:244: (20 bytes: <mean @061d40> - <mean+20 @061d54>): return .result := sum(...data) / (signed(data.length));
	<mean @061d40>      : 1a                         load.z64
	<mean+1 @061d41>    : 11 03                      dup.x64 sp(3)
	<mean+3 @061d43>    : 1f 18 1d 06 00             load.ref <@061d18> ;Math.sum(data: float64[]): float64
	<mean+8 @061d48>    : 02                         call
	<mean+9 @061d49>    : 09 f8 ff ff                inc.sp(-8)
	<mean+13 @061d4d>   : 10 04                      dup.x32 sp(4)
	<mean+15 @061d4f>   : 5d                         i32.2f64
	<mean+16 @061d50>   : 84                         div.f64
	<mean+17 @061d51>   : 14 05                      set.x64 sp(5)
	<mean+19 @061d53>   : 03                         ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:248'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	cmplStd/test/std/test.math.ci:50: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:251'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	cmplStd/test/std/test.math.ci:51: referenced as `eval`
	cmplStd/lib/math.ci:254: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:254'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	cmplStd/test/std/test.math.ci:52: referenced as `eval`
	cmplStd/lib/math.ci:257: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:257'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	cmplStd/test/std/test.math.ci:53: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.offset: <@061d58>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:260'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <eval @061d58> - <eval+47 @061d87>)
	cmplStd/lib/math.ci:261: (1 byte: <eval @061d58> - <eval+1 @061d59>): result: float64 := 0
	<eval @061d58>      : 1a                         load.z64
	cmplStd/lib/math.ci:262: (43 bytes: <eval+1 @061d59> - <eval+44 @061d84>): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+1 @061d59>    : 10 04                      dup.x32 sp(4)
	<eval+3 @061d5b>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @061d5f>    : 04 19 00 00                jmp <eval+32 @061d78>
	cmplStd/lib/math.ci:263: (17 bytes: <eval+11 @061d63> - <eval+28 @061d74>): result := result * x + polynomial[i];
	<eval+11 @061d63>   : 11 01                      dup.x64 sp(1)
	<eval+13 @061d65>   : 11 08                      dup.x64 sp(8)
	<eval+15 @061d67>   : 83                         mul.f64
	<eval+16 @061d68>   : 10 06                      dup.x32 sp(6)
	<eval+18 @061d6a>   : 10 03                      dup.x32 sp(3)
	<eval+20 @061d6c>   : 0d 08 00 00                mad.u32 8
	<eval+24 @061d70>   : 29                         load.i64
	<eval+25 @061d71>   : 81                         add.f64
	<eval+26 @061d72>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:262: (4 bytes: <eval+28 @061d74> - <eval+32 @061d78>): i := i - 1
	<eval+28 @061d74>   : 0c ff ff ff                inc.i32(-1)
	cmplStd/lib/math.ci:262: (8 bytes: <eval+32 @061d78> - <eval+40 @061d80>): i >= 0
	<eval+32 @061d78>   : 10 00                      dup.x32 sp(0)
	<eval+34 @061d7a>   : 19                         load.z32
	<eval+35 @061d7b>   : 58                         clt.i32
	<eval+36 @061d7c>   : 06 e7 ff ff                jz <eval+11 @061d63>
	<eval+40 @061d80>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:265: (3 bytes: <eval+44 @061d84> - <eval+47 @061d87>): return .result := result;
	<eval+44 @061d84>   : 14 07                      set.x64 sp(7)
	<eval+46 @061d86>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `eval`
	cmplStd/test/std/test.math.ci:54: referenced as `eval`
	cmplStd/test/std/test.math.ci:49: referenced as `eval`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@061d88>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:269'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float32(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @061d88> - <cmp+57 @061dc1>)
	cmplStd/lib/math.ci:270: (53 bytes: <cmp @061d88> - <cmp+53 @061dbd>): if (a < b)
	<cmp @061d88>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @061d8a>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @061d8c>    : 78                         clt.f32
	<cmp+5 @061d8d>    : 06 1c 00 00                jz <cmp+33 @061da9>
	cmplStd/lib/math.ci:271: (20 bytes: <cmp+9 @061d91> - <cmp+29 @061da5>): if (eps < (b - a))
	<cmp+9 @061d91>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @061d93>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @061d95>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @061d97>   : 72                         sub.f32
	<cmp+16 @061d98>   : 78                         clt.f32
	<cmp+17 @061d99>   : 06 0c 00 00                jz <cmp+29 @061da5>
	cmplStd/lib/math.ci:272: (8 bytes: <cmp+21 @061d9d> - <cmp+29 @061da5>): return .result := -1;
	<cmp+21 @061d9d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @061da2>   : 13 05                      set.x32 sp(5)
	<cmp+28 @061da4>   : 03                         ret
	<cmp+29 @061da5>   : 04 18 00 00                jmp <cmp+53 @061dbd>
	cmplStd/lib/math.ci:276: (20 bytes: <cmp+33 @061da9> - <cmp+53 @061dbd>): if (eps < (a - b))
	<cmp+33 @061da9>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @061dab>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @061dad>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @061daf>   : 72                         sub.f32
	<cmp+40 @061db0>   : 78                         clt.f32
	<cmp+41 @061db1>   : 06 0c 00 00                jz <cmp+53 @061dbd>
	cmplStd/lib/math.ci:277: (8 bytes: <cmp+45 @061db5> - <cmp+53 @061dbd>): return .result := +1;
	<cmp+45 @061db5>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @061dba>   : 13 05                      set.x32 sp(5)
	<cmp+52 @061dbc>   : 03                         ret
	cmplStd/lib/math.ci:280: (4 bytes: <cmp+53 @061dbd> - <cmp+57 @061dc1>): return .result := 0;
	<cmp+53 @061dbd>   : 19                         load.z32
	<cmp+54 @061dbe>   : 13 05                      set.x32 sp(5)
	<cmp+56 @061dc0>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:67: referenced as `cmp`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@061dc8>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:284'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float64(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @061dc8> - <cmp+57 @061e01>)
	cmplStd/lib/math.ci:285: (53 bytes: <cmp @061dc8> - <cmp+53 @061dfd>): if (a < b)
	<cmp @061dc8>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @061dca>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @061dcc>    : 88                         clt.f64
	<cmp+5 @061dcd>    : 06 1c 00 00                jz <cmp+33 @061de9>
	cmplStd/lib/math.ci:286: (20 bytes: <cmp+9 @061dd1> - <cmp+29 @061de5>): if (eps < (b - a))
	<cmp+9 @061dd1>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @061dd3>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @061dd5>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @061dd7>   : 82                         sub.f64
	<cmp+16 @061dd8>   : 88                         clt.f64
	<cmp+17 @061dd9>   : 06 0c 00 00                jz <cmp+29 @061de5>
	cmplStd/lib/math.ci:287: (8 bytes: <cmp+21 @061ddd> - <cmp+29 @061de5>): return .result := -1;
	<cmp+21 @061ddd>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @061de2>   : 13 08                      set.x32 sp(8)
	<cmp+28 @061de4>   : 03                         ret
	<cmp+29 @061de5>   : 04 18 00 00                jmp <cmp+53 @061dfd>
	cmplStd/lib/math.ci:291: (20 bytes: <cmp+33 @061de9> - <cmp+53 @061dfd>): if (eps < (a - b))
	<cmp+33 @061de9>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @061deb>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @061ded>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @061def>   : 82                         sub.f64
	<cmp+40 @061df0>   : 88                         clt.f64
	<cmp+41 @061df1>   : 06 0c 00 00                jz <cmp+53 @061dfd>
	cmplStd/lib/math.ci:292: (8 bytes: <cmp+45 @061df5> - <cmp+53 @061dfd>): return .result := +1;
	<cmp+45 @061df5>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @061dfa>   : 13 08                      set.x32 sp(8)
	<cmp+52 @061dfc>   : 03                         ret
	cmplStd/lib/math.ci:295: (4 bytes: <cmp+53 @061dfd> - <cmp+57 @061e01>): return .result := 0;
	<cmp+53 @061dfd>   : 19                         load.z32
	<cmp+54 @061dfe>   : 13 08                      set.x32 sp(8)
	<cmp+56 @061e00>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `cmp`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 335
.offset: <@061e08>
.name: 'sinCos'
.file: 'cmplStd/lib/math.ci:299'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <sinCos @061e08> - <sinCos+335 @061f57>)
	cmplStd/lib/math.ci:313: (2 bytes: <sinCos @061e08> - <sinCos+2 @061e0a>): x: float64 := arg
	<sinCos @061e08>      : 11 02                      dup.x64 sp(2)
	cmplStd/lib/math.ci:314: (17 bytes: <sinCos+2 @061e0a> - <sinCos+19 @061e1b>): if (x < (0))
	<sinCos+2 @061e0a>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @061e0c>    : 1a                         load.z64
	<sinCos+5 @061e0d>    : 88                         clt.f64
	<sinCos+6 @061e0e>    : 06 0d 00 00                jz <sinCos+19 @061e1b>
	cmplStd/lib/math.ci:315: (1 byte: <sinCos+10 @061e12> - <sinCos+11 @061e13>): x := -x;
	<sinCos+10 @061e12>   : 80                         neg.f64
	cmplStd/lib/math.ci:316: (8 bytes: <sinCos+11 @061e13> - <sinCos+19 @061e1b>): quad := quad + 2;
	<sinCos+11 @061e13>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @061e15>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @061e19>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math.ci:319: (1 byte: <sinCos+19 @061e1b> - <sinCos+20 @061e1c>): y: float64
	<sinCos+19 @061e1b>   : 1a                         load.z64
	cmplStd/lib/math.ci:320: (24 bytes: <sinCos+20 @061e1c> - <sinCos+44 @061e34>): x := x * (1) / PIO2;
	<sinCos+20 @061e1c>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @061e1e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @061e27>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @061e30>   : 84                         div.f64
	<sinCos+41 @061e31>   : 83                         mul.f64
	<sinCos+42 @061e32>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:321: (124 bytes: <sinCos+44 @061e34> - <sinCos+168 @061eb0>): if (x > (32764))
	<sinCos+44 @061e34>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @061e36>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @061e3f>   : 89                         cgt.f64
	<sinCos+56 @061e40>   : 06 54 00 00                jz <sinCos+140 @061e94>
	cmplStd/lib/math.ci:322: (1 byte: <sinCos+60 @061e44> - <sinCos+61 @061e45>): e: float64
	<sinCos+60 @061e44>   : 1b                         load.z128
	cmplStd/lib/math.ci:323: (18 bytes: <sinCos+61 @061e45> - <sinCos+79 @061e57>): y := modf(x, &e);
	<sinCos+61 @061e45>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @061e47>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @061e4b>   : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @061e50>   : 02                         call
	<sinCos+73 @061e51>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @061e55>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:324: (4 bytes: <sinCos+79 @061e57> - <sinCos+83 @061e5b>): e := e + (quad);
	<sinCos+79 @061e57>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @061e59>   : 5d                         i32.2f64
	<sinCos+82 @061e5a>   : 81                         add.f64
	cmplStd/lib/math.ci:326: (1 byte: <sinCos+83 @061e5b> - <sinCos+84 @061e5c>): f: float64
	<sinCos+83 @061e5b>   : 1b                         load.z128
	cmplStd/lib/math.ci:327: (30 bytes: <sinCos+84 @061e5c> - <sinCos+114 @061e7a>): modf(0.250000 * e, &f);
	<sinCos+84 @061e5c>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @061e65>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @061e67>   : 83                         mul.f64
	<sinCos+96 @061e68>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @061e6c>  : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @061e71>  : 02                         call
	<sinCos+106 @061e72>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @061e76>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:328: (18 bytes: <sinCos+114 @061e7a> - <sinCos+132 @061e8c>): quad := (e - (4) * f);
	<sinCos+114 @061e7a>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @061e7c>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @061e85>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @061e87>  : 83                         mul.f64
	<sinCos+128 @061e88>  : 82                         sub.f64
	<sinCos+129 @061e89>  : 8a                         f64.2i32
	<sinCos+130 @061e8a>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @061e8c>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @061e90>  : 04 20 00 00                jmp <sinCos+168 @061eb0>
	cmplStd/lib/math.ci:331: (3 bytes: <sinCos+140 @061e94> - <sinCos+143 @061e97>): k: int32 := x
	<sinCos+140 @061e94>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @061e96>  : 8a                         f64.2i32
	cmplStd/lib/math.ci:332: (8 bytes: <sinCos+143 @061e97> - <sinCos+151 @061e9f>): y := x - (k);
	<sinCos+143 @061e97>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @061e99>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @061e9b>  : 5d                         i32.2f64
	<sinCos+148 @061e9c>  : 82                         sub.f64
	<sinCos+149 @061e9d>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:333: (7 bytes: <sinCos+151 @061e9f> - <sinCos+158 @061ea6>): quad := quad + k;
	<sinCos+151 @061e9f>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @061ea1>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @061ea3>  : 51                         add.i32
	<sinCos+156 @061ea4>  : 13 07                      set.x32 sp(7)
	cmplStd/lib/math.ci:334: (6 bytes: <sinCos+158 @061ea6> - <sinCos+164 @061eac>): quad := quad & 3;
	<sinCos+158 @061ea6>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @061ea8>  : 3f 02                      b32.and 0x03
	<sinCos+162 @061eaa>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @061eac>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:336: (22 bytes: <sinCos+168 @061eb0> - <sinCos+190 @061ec6>): if (quad & 1)
	<sinCos+168 @061eb0>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @061eb2>  : 3f 01                      b32.and 0x01
	<sinCos+172 @061eb4>  : 06 12 00 00                jz <sinCos+190 @061ec6>
	cmplStd/lib/math.ci:337: (14 bytes: <sinCos+176 @061eb8> - <sinCos+190 @061ec6>): y := (1) - y;
	<sinCos+176 @061eb8>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @061ec1>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @061ec3>  : 82                         sub.f64
	<sinCos+188 @061ec4>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:339: (13 bytes: <sinCos+190 @061ec6> - <sinCos+203 @061ed3>): if (quad > 1)
	<sinCos+190 @061ec6>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @061ec8>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @061ecd>  : 59                         cgt.i32
	<sinCos+198 @061ece>  : 06 05 00 00                jz <sinCos+203 @061ed3>
	cmplStd/lib/math.ci:340: (1 byte: <sinCos+202 @061ed2> - <sinCos+203 @061ed3>): y := -y;
	<sinCos+202 @061ed2>  : 80                         neg.f64
	cmplStd/lib/math.ci:343: (5 bytes: <sinCos+203 @061ed3> - <sinCos+208 @061ed8>): ysq: float64 := y * y
	<sinCos+203 @061ed3>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @061ed5>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @061ed7>  : 83                         mul.f64
	cmplStd/lib/math.ci:344: (64 bytes: <sinCos+208 @061ed8> - <sinCos+272 @061f18>): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+208 @061ed8>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @061ee1>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @061ee3>  : 83                         mul.f64
	<sinCos+220 @061ee4>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @061eed>  : 81                         add.f64
	<sinCos+230 @061eee>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @061ef0>  : 83                         mul.f64
	<sinCos+233 @061ef1>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @061efa>  : 81                         add.f64
	<sinCos+243 @061efb>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @061efd>  : 83                         mul.f64
	<sinCos+246 @061efe>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @061f07>  : 81                         add.f64
	<sinCos+256 @061f08>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @061f0a>  : 83                         mul.f64
	<sinCos+259 @061f0b>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @061f14>  : 81                         add.f64
	<sinCos+269 @061f15>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @061f17>  : 83                         mul.f64
	cmplStd/lib/math.ci:345: (51 bytes: <sinCos+272 @061f18> - <sinCos+323 @061f4b>): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+272 @061f18>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @061f1a>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @061f23>  : 81                         add.f64
	<sinCos+284 @061f24>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @061f26>  : 83                         mul.f64
	<sinCos+287 @061f27>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @061f30>  : 81                         add.f64
	<sinCos+297 @061f31>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @061f33>  : 83                         mul.f64
	<sinCos+300 @061f34>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @061f3d>  : 81                         add.f64
	<sinCos+310 @061f3e>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @061f40>  : 83                         mul.f64
	<sinCos+313 @061f41>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @061f4a>  : 81                         add.f64
	cmplStd/lib/math.ci:346: (12 bytes: <sinCos+323 @061f4b> - <sinCos+335 @061f57>): return .result := temp1 / temp2;
	<sinCos+323 @061f4b>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @061f4d>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @061f4f>  : 84                         div.f64
	<sinCos+328 @061f50>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @061f52>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @061f56>  : 03                         ret
.usages:
	cmplStd/lib/math.ci:353: referenced as `sinCos`
	cmplStd/lib/math.ci:350: referenced as `sinCos`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math.ci:350'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	cmplStd/test/std/test.math.ci:57: referenced as `sin`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math.ci:353'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	cmplStd/test/std/test.math.ci:58: referenced as `cos`
}
Math.tan(arg: float64): float64: function {
.kind: static function
.base: `function`
.size: 378
.offset: <@061f58>
.name: 'tan'
.file: 'cmplStd/lib/math.ci:356'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else if (bool(i == 1)) {
		float64(x := float64((1) - x));
		bool(complement := true);
	}
	else if (bool(i == 2)) {
		bool(negate := bool(!negate));
		bool(complement := true);
	}
	else if (bool(i == 3)) {
		float64(x := float64((1) - x));
		bool(negate := bool(!negate));
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <tan @061f58> - <tan+378 @0620d2>)
	cmplStd/lib/math.ci:369: (1 byte: <tan @061f58> - <tan+1 @061f59>): complement: bool := false
	<tan @061f58>      : 19                         load.z32
	cmplStd/lib/math.ci:370: (1 byte: <tan+1 @061f59> - <tan+2 @061f5a>): negate: bool := false
	<tan+1 @061f59>    : 19                         load.z32
	cmplStd/lib/math.ci:372: (23 bytes: <tan+2 @061f5a> - <tan+25 @061f71>): if (arg < (0))
	<tan+2 @061f5a>    : 11 03                      dup.x64 sp(3)
	<tan+4 @061f5c>    : 1a                         load.z64
	<tan+5 @061f5d>    : 88                         clt.f64
	<tan+6 @061f5e>    : 06 13 00 00                jz <tan+25 @061f71>
	cmplStd/lib/math.ci:373: (5 bytes: <tan+10 @061f62> - <tan+15 @061f67>): arg := -arg;
	<tan+10 @061f62>   : 11 03                      dup.x64 sp(3)
	<tan+12 @061f64>   : 80                         neg.f64
	<tan+13 @061f65>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:374: (10 bytes: <tan+15 @061f67> - <tan+25 @061f71>): negate := true;
	<tan+15 @061f67>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @061f6c>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @061f70>   : 2b                         store.i8
	cmplStd/lib/math.ci:376: (24 bytes: <tan+25 @061f71> - <tan+49 @061f89>): arg := (2) * arg / PIO2;
	<tan+25 @061f71>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @061f7a>   : 11 05                      dup.x64 sp(5)
	<tan+36 @061f7c>   : 83                         mul.f64
	<tan+37 @061f7d>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @061f86>   : 84                         div.f64
	<tan+47 @061f87>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:378: (1 byte: <tan+49 @061f89> - <tan+50 @061f8a>): e: float64
	<tan+49 @061f89>   : 1b                         load.z128
	cmplStd/lib/math.ci:379: (16 bytes: <tan+50 @061f8a> - <tan+66 @061f9a>): x: float64 := modf(arg, &e)
	<tan+50 @061f8a>   : 11 07                      dup.x64 sp(7)
	<tan+52 @061f8c>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @061f90>   : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @061f95>   : 02                         call
	<tan+62 @061f96>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math.ci:380: (9 bytes: <tan+66 @061f9a> - <tan+75 @061fa3>): i: int32 := int32(e) % 4
	<tan+66 @061f9a>   : 11 02                      dup.x64 sp(2)
	<tan+68 @061f9c>   : 8a                         f64.2i32
	<tan+69 @061f9d>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @061fa2>   : 55                         mod.i32
	cmplStd/lib/math.ci:382: (122 bytes: <tan+75 @061fa3> - <tan+197 @06201d>): if (i == 0)
	<tan+75 @061fa3>   : 10 00                      dup.x32 sp(0)
	<tan+77 @061fa5>   : 19                         load.z32
	<tan+78 @061fa6>   : 57                         ceq.i32
	<tan+79 @061fa7>   : 05 76 00 00                jnz <tan+197 @06201d>
	cmplStd/lib/math.ci:383: (114 bytes: <tan+83 @061fab> - <tan+197 @06201d>): if (i == 1)
	<tan+83 @061fab>   : 10 00                      dup.x32 sp(0)
	<tan+85 @061fad>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @061fb2>   : 57                         ceq.i32
	<tan+91 @061fb3>   : 06 20 00 00                jz <tan+123 @061fd3>
	cmplStd/lib/math.ci:384: (14 bytes: <tan+95 @061fb7> - <tan+109 @061fc5>): x := (1) - x;
	<tan+95 @061fb7>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @061fc0>  : 11 03                      dup.x64 sp(3)
	<tan+106 @061fc2>  : 82                         sub.f64
	<tan+107 @061fc3>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:385: (10 bytes: <tan+109 @061fc5> - <tan+119 @061fcf>): complement := true;
	<tan+109 @061fc5>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @061fca>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @061fce>  : 2b                         store.i8
	<tan+119 @061fcf>  : 04 4e 00 00                jmp <tan+197 @06201d>
	cmplStd/lib/math.ci:387: (74 bytes: <tan+123 @061fd3> - <tan+197 @06201d>): if (i == 2)
	<tan+123 @061fd3>  : 10 00                      dup.x32 sp(0)
	<tan+125 @061fd5>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @061fda>  : 57                         ceq.i32
	<tan+131 @061fdb>  : 06 1d 00 00                jz <tan+160 @061ff8>
	cmplStd/lib/math.ci:388: (11 bytes: <tan+135 @061fdf> - <tan+146 @061fea>): negate := !negate;
	<tan+135 @061fdf>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @061fe3>  : 26                         load.i8
	<tan+140 @061fe4>  : 0b                         not.b32
	<tan+141 @061fe5>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @061fe9>  : 2b                         store.i8
	cmplStd/lib/math.ci:389: (10 bytes: <tan+146 @061fea> - <tan+156 @061ff4>): complement := true;
	<tan+146 @061fea>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @061fef>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @061ff3>  : 2b                         store.i8
	<tan+156 @061ff4>  : 04 29 00 00                jmp <tan+197 @06201d>
	cmplStd/lib/math.ci:391: (37 bytes: <tan+160 @061ff8> - <tan+197 @06201d>): if (i == 3)
	<tan+160 @061ff8>  : 10 00                      dup.x32 sp(0)
	<tan+162 @061ffa>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @061fff>  : 57                         ceq.i32
	<tan+168 @062000>  : 06 1d 00 00                jz <tan+197 @06201d>
	cmplStd/lib/math.ci:392: (14 bytes: <tan+172 @062004> - <tan+186 @062012>): x := (1) - x;
	<tan+172 @062004>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @06200d>  : 11 03                      dup.x64 sp(3)
	<tan+183 @06200f>  : 82                         sub.f64
	<tan+184 @062010>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:393: (11 bytes: <tan+186 @062012> - <tan+197 @06201d>): negate := !negate;
	<tan+186 @062012>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @062016>  : 26                         load.i8
	<tan+191 @062017>  : 0b                         not.b32
	<tan+192 @062018>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @06201c>  : 2b                         store.i8
	cmplStd/lib/math.ci:396: (5 bytes: <tan+197 @06201d> - <tan+202 @062022>): xsq: float64 := x * x
	<tan+197 @06201d>  : 11 01                      dup.x64 sp(1)
	<tan+199 @06201f>  : 11 03                      dup.x64 sp(3)
	<tan+201 @062021>  : 83                         mul.f64
	cmplStd/lib/math.ci:397: (64 bytes: <tan+202 @062022> - <tan+266 @062062>): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+202 @062022>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @06202b>  : 11 02                      dup.x64 sp(2)
	<tan+213 @06202d>  : 83                         mul.f64
	<tan+214 @06202e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @062037>  : 81                         add.f64
	<tan+224 @062038>  : 11 02                      dup.x64 sp(2)
	<tan+226 @06203a>  : 83                         mul.f64
	<tan+227 @06203b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @062044>  : 81                         add.f64
	<tan+237 @062045>  : 11 02                      dup.x64 sp(2)
	<tan+239 @062047>  : 83                         mul.f64
	<tan+240 @062048>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @062051>  : 81                         add.f64
	<tan+250 @062052>  : 11 02                      dup.x64 sp(2)
	<tan+252 @062054>  : 83                         mul.f64
	<tan+253 @062055>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @06205e>  : 81                         add.f64
	<tan+263 @06205f>  : 11 05                      dup.x64 sp(5)
	<tan+265 @062061>  : 83                         mul.f64
	cmplStd/lib/math.ci:398: (39 bytes: <tan+266 @062062> - <tan+305 @062089>): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+266 @062062>  : 11 02                      dup.x64 sp(2)
	<tan+268 @062064>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @06206d>  : 81                         add.f64
	<tan+278 @06206e>  : 11 04                      dup.x64 sp(4)
	<tan+280 @062070>  : 83                         mul.f64
	<tan+281 @062071>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @06207a>  : 81                         add.f64
	<tan+291 @06207b>  : 11 04                      dup.x64 sp(4)
	<tan+293 @06207d>  : 83                         mul.f64
	<tan+294 @06207e>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @062087>  : 81                         add.f64
	<tan+304 @062088>  : 84                         div.f64
	cmplStd/lib/math.ci:400: (47 bytes: <tan+305 @062089> - <tan+352 @0620b8>): if (complement)
	<tan+305 @062089>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @06208d>  : 26                         load.i8
	<tan+310 @06208e>  : 06 2a 00 00                jz <tan+352 @0620b8>
	cmplStd/lib/math.ci:401: (24 bytes: <tan+314 @062092> - <tan+338 @0620aa>): if (result == (0))
	<tan+314 @062092>  : 11 00                      dup.x64 sp(0)
	<tan+316 @062094>  : 1a                         load.z64
	<tan+317 @062095>  : 87                         ceq.f64
	<tan+318 @062096>  : 06 14 00 00                jz <tan+338 @0620aa>
	cmplStd/lib/math.ci:402: (16 bytes: <tan+322 @06209a> - <tan+338 @0620aa>): return .result := nan;
	<tan+322 @06209a>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @0620a3>  : 14 10                      set.x64 sp(16)
	<tan+333 @0620a5>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @0620a9>  : 03                         ret
	cmplStd/lib/math.ci:404: (14 bytes: <tan+338 @0620aa> - <tan+352 @0620b8>): result := (1) / result;
	<tan+338 @0620aa>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @0620b3>  : 11 02                      dup.x64 sp(2)
	<tan+349 @0620b5>  : 84                         div.f64
	<tan+350 @0620b6>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:406: (19 bytes: <tan+352 @0620b8> - <tan+371 @0620cb>): if (negate)
	<tan+352 @0620b8>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @0620bc>  : 26                         load.i8
	<tan+357 @0620bd>  : 06 0e 00 00                jz <tan+371 @0620cb>
	cmplStd/lib/math.ci:407: (10 bytes: <tan+361 @0620c1> - <tan+371 @0620cb>): return .result := -result;
	<tan+361 @0620c1>  : 11 00                      dup.x64 sp(0)
	<tan+363 @0620c3>  : 80                         neg.f64
	<tan+364 @0620c4>  : 14 10                      set.x64 sp(16)
	<tan+366 @0620c6>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @0620ca>  : 03                         ret
	cmplStd/lib/math.ci:409: (7 bytes: <tan+371 @0620cb> - <tan+378 @0620d2>): return .result := result;
	<tan+371 @0620cb>  : 14 0e                      set.x64 sp(14)
	<tan+373 @0620cd>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @0620d1>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:59: referenced as `tan`
}
Math.sinh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 241
.offset: <@0620d8>
.name: 'sinh'
.file: 'cmplStd/lib/math.ci:413'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <sinh @0620d8> - <sinh+241 @0621c9>)
	cmplStd/lib/math.ci:425: (1 byte: <sinh @0620d8> - <sinh+1 @0620d9>): negate: bool := false
	<sinh @0620d8>      : 19                         load.z32
	cmplStd/lib/math.ci:426: (23 bytes: <sinh+1 @0620d9> - <sinh+24 @0620f0>): if (x < (0))
	<sinh+1 @0620d9>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @0620db>    : 1a                         load.z64
	<sinh+4 @0620dc>    : 88                         clt.f64
	<sinh+5 @0620dd>    : 06 13 00 00                jz <sinh+24 @0620f0>
	cmplStd/lib/math.ci:427: (5 bytes: <sinh+9 @0620e1> - <sinh+14 @0620e6>): x := -x;
	<sinh+9 @0620e1>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @0620e3>   : 80                         neg.f64
	<sinh+12 @0620e4>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:428: (10 bytes: <sinh+14 @0620e6> - <sinh+24 @0620f0>): negate := true;
	<sinh+14 @0620e6>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @0620eb>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @0620ef>   : 2b                         store.i8
	cmplStd/lib/math.ci:431: (39 bytes: <sinh+24 @0620f0> - <sinh+63 @062117>): if (x > (21))
	<sinh+24 @0620f0>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @0620f2>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @0620fb>   : 89                         cgt.f64
	<sinh+36 @0620fc>   : 06 1b 00 00                jz <sinh+63 @062117>
	cmplStd/lib/math.ci:432: (23 bytes: <sinh+40 @062100> - <sinh+63 @062117>): return .result := float64.exp(x) / (2);
	<sinh+40 @062100>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @062102>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<sinh+46 @062106>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @06210f>   : 84                         div.f64
	<sinh+56 @062110>   : 14 06                      set.x64 sp(6)
	<sinh+58 @062112>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @062116>   : 03                         ret
	cmplStd/lib/math.ci:435: (1 byte: <sinh+63 @062117> - <sinh+64 @062118>): result: float64
	<sinh+63 @062117>   : 1a                         load.z64
	cmplStd/lib/math.ci:436: (151 bytes: <sinh+64 @062118> - <sinh+215 @0621af>): if (x > 0.500000)
	<sinh+64 @062118>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @06211a>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @062123>   : 89                         cgt.f64
	<sinh+76 @062124>   : 06 22 00 00                jz <sinh+110 @062146>
	cmplStd/lib/math.ci:437: (26 bytes: <sinh+80 @062128> - <sinh+106 @062142>): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+80 @062128>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @06212a>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<sinh+86 @06212e>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @062130>   : 80                         neg.f64
	<sinh+89 @062131>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<sinh+93 @062135>   : 82                         sub.f64
	<sinh+94 @062136>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @06213f>  : 84                         div.f64
	<sinh+104 @062140>  : 14 02                      set.x64 sp(2)
	<sinh+106 @062142>  : 04 6d 00 00                jmp <sinh+215 @0621af>
	cmplStd/lib/math.ci:440: (5 bytes: <sinh+110 @062146> - <sinh+115 @06214b>): sq: float64 := x * x
	<sinh+110 @062146>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @062148>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @06214a>  : 83                         mul.f64
	cmplStd/lib/math.ci:441: (53 bytes: <sinh+115 @06214b> - <sinh+168 @062180>): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+115 @06214b>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @062154>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @062156>  : 83                         mul.f64
	<sinh+127 @062157>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @062160>  : 81                         add.f64
	<sinh+137 @062161>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @062163>  : 83                         mul.f64
	<sinh+140 @062164>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @06216d>  : 81                         add.f64
	<sinh+150 @06216e>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @062170>  : 83                         mul.f64
	<sinh+153 @062171>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @06217a>  : 81                         add.f64
	<sinh+163 @06217b>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @06217d>  : 83                         mul.f64
	<sinh+166 @06217e>  : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:442: (43 bytes: <sinh+168 @062180> - <sinh+211 @0621ab>): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+168 @062180>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @062182>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @062184>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @06218d>  : 81                         add.f64
	<sinh+182 @06218e>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @062190>  : 83                         mul.f64
	<sinh+185 @062191>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @06219a>  : 81                         add.f64
	<sinh+195 @06219b>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @06219d>  : 83                         mul.f64
	<sinh+198 @06219e>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @0621a7>  : 81                         add.f64
	<sinh+208 @0621a8>  : 84                         div.f64
	<sinh+209 @0621a9>  : 14 04                      set.x64 sp(4)
	<sinh+211 @0621ab>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:445: (19 bytes: <sinh+215 @0621af> - <sinh+234 @0621c2>): if (negate)
	<sinh+215 @0621af>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @0621b3>  : 26                         load.i8
	<sinh+220 @0621b4>  : 06 0e 00 00                jz <sinh+234 @0621c2>
	cmplStd/lib/math.ci:446: (10 bytes: <sinh+224 @0621b8> - <sinh+234 @0621c2>): return .result := -result;
	<sinh+224 @0621b8>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @0621ba>  : 80                         neg.f64
	<sinh+227 @0621bb>  : 14 08                      set.x64 sp(8)
	<sinh+229 @0621bd>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @0621c1>  : 03                         ret
	cmplStd/lib/math.ci:448: (7 bytes: <sinh+234 @0621c2> - <sinh+241 @0621c9>): return .result := result;
	<sinh+234 @0621c2>  : 14 06                      set.x64 sp(6)
	<sinh+236 @0621c4>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @0621c8>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:60: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:151: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:149: referenced as `sinh`
}
Math.cosh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 75
.offset: <@0621d0>
.name: 'cosh'
.file: 'cmplStd/lib/math.ci:452'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <cosh @0621d0> - <cosh+75 @06221b>)
	cmplStd/lib/math.ci:453: (13 bytes: <cosh @0621d0> - <cosh+13 @0621dd>): if (x < (0))
	<cosh @0621d0>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @0621d2>    : 1a                         load.z64
	<cosh+3 @0621d3>    : 88                         clt.f64
	<cosh+4 @0621d4>    : 06 09 00 00                jz <cosh+13 @0621dd>
	cmplStd/lib/math.ci:454: (5 bytes: <cosh+8 @0621d8> - <cosh+13 @0621dd>): x := -x;
	<cosh+8 @0621d8>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @0621da>   : 80                         neg.f64
	<cosh+11 @0621db>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:456: (35 bytes: <cosh+13 @0621dd> - <cosh+48 @062200>): if (x > (21))
	<cosh+13 @0621dd>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @0621df>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @0621e8>   : 89                         cgt.f64
	<cosh+25 @0621e9>   : 06 17 00 00                jz <cosh+48 @062200>
	cmplStd/lib/math.ci:457: (19 bytes: <cosh+29 @0621ed> - <cosh+48 @062200>): return .result := float64.exp(x) / (2);
	<cosh+29 @0621ed>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @0621ef>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<cosh+35 @0621f3>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @0621fc>   : 84                         div.f64
	<cosh+45 @0621fd>   : 14 05                      set.x64 sp(5)
	<cosh+47 @0621ff>   : 03                         ret
	cmplStd/lib/math.ci:459: (27 bytes: <cosh+48 @062200> - <cosh+75 @06221b>): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+48 @062200>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @062202>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<cosh+54 @062206>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @062208>   : 80                         neg.f64
	<cosh+57 @062209>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<cosh+61 @06220d>   : 81                         add.f64
	<cosh+62 @06220e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @062217>   : 84                         div.f64
	<cosh+72 @062218>   : 14 05                      set.x64 sp(5)
	<cosh+74 @06221a>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:151: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:149: referenced as `cosh`
}
Math.asin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 173
.offset: <@062220>
.name: 'asin'
.file: 'cmplStd/lib/math.ci:467'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <asin @062220> - <asin+173 @0622cd>)
	cmplStd/lib/math.ci:468: (12 bytes: <asin @062220> - <asin+12 @06222c>): if (x == (0))
	<asin @062220>      : 11 01                      dup.x64 sp(1)
	<asin+2 @062222>    : 1a                         load.z64
	<asin+3 @062223>    : 87                         ceq.f64
	<asin+4 @062224>    : 06 08 00 00                jz <asin+12 @06222c>
	cmplStd/lib/math.ci:470: (4 bytes: <asin+8 @062228> - <asin+12 @06222c>): return .result := x;
	<asin+8 @062228>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @06222b>   : 03                         ret
	cmplStd/lib/math.ci:473: (1 byte: <asin+12 @06222c> - <asin+13 @06222d>): negate: bool := false
	<asin+12 @06222c>   : 19                         load.z32
	cmplStd/lib/math.ci:474: (23 bytes: <asin+13 @06222d> - <asin+36 @062244>): if (x < (0))
	<asin+13 @06222d>   : 11 02                      dup.x64 sp(2)
	<asin+15 @06222f>   : 1a                         load.z64
	<asin+16 @062230>   : 88                         clt.f64
	<asin+17 @062231>   : 06 13 00 00                jz <asin+36 @062244>
	cmplStd/lib/math.ci:475: (10 bytes: <asin+21 @062235> - <asin+31 @06223f>): negate := true;
	<asin+21 @062235>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @06223a>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @06223e>   : 2b                         store.i8
	cmplStd/lib/math.ci:476: (5 bytes: <asin+31 @06223f> - <asin+36 @062244>): x := -x;
	<asin+31 @06223f>   : 11 02                      dup.x64 sp(2)
	<asin+33 @062241>   : 80                         neg.f64
	<asin+34 @062242>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:479: (32 bytes: <asin+36 @062244> - <asin+68 @062264>): if (x > (1))
	<asin+36 @062244>   : 11 02                      dup.x64 sp(2)
	<asin+38 @062246>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @06224f>   : 89                         cgt.f64
	<asin+48 @062250>   : 06 14 00 00                jz <asin+68 @062264>
	cmplStd/lib/math.ci:481: (16 bytes: <asin+52 @062254> - <asin+68 @062264>): return .result := nan;
	<asin+52 @062254>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @06225d>   : 14 06                      set.x64 sp(6)
	<asin+63 @06225f>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @062263>   : 03                         ret
	cmplStd/lib/math.ci:484: (19 bytes: <asin+68 @062264> - <asin+87 @062277>): result: float64 := float64.sqrt((1) - x * x)
	<asin+68 @062264>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @06226d>   : 11 04                      dup.x64 sp(4)
	<asin+79 @06226f>   : 11 06                      dup.x64 sp(6)
	<asin+81 @062271>   : 83                         mul.f64
	<asin+82 @062272>   : 82                         sub.f64
	<asin+83 @062273>   : 01 30 00 00                nfc(48) ;float64.sqrt(x: float64): float64
	cmplStd/lib/math.ci:485: (60 bytes: <asin+87 @062277> - <asin+147 @0622b3>): if (x > 0.700000)
	<asin+87 @062277>   : 11 04                      dup.x64 sp(4)
	<asin+89 @062279>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @062282>   : 89                         cgt.f64
	<asin+99 @062283>   : 06 26 00 00                jz <asin+137 @0622a9>
	cmplStd/lib/math.ci:486: (30 bytes: <asin+103 @062287> - <asin+133 @0622a5>): result := pi / (2) - float64.atan2(result, x);
	<asin+103 @062287>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @062290>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @062299>  : 84                         div.f64
	<asin+122 @06229a>  : 11 02                      dup.x64 sp(2)
	<asin+124 @06229c>  : 11 08                      dup.x64 sp(8)
	<asin+126 @06229e>  : 01 31 00 00                nfc(49) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @0622a2>  : 82                         sub.f64
	<asin+131 @0622a3>  : 14 02                      set.x64 sp(2)
	<asin+133 @0622a5>  : 04 0e 00 00                jmp <asin+147 @0622b3>
	cmplStd/lib/math.ci:489: (10 bytes: <asin+137 @0622a9> - <asin+147 @0622b3>): result := float64.atan2(x, result);
	<asin+137 @0622a9>  : 11 04                      dup.x64 sp(4)
	<asin+139 @0622ab>  : 11 02                      dup.x64 sp(2)
	<asin+141 @0622ad>  : 01 31 00 00                nfc(49) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @0622b1>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:492: (19 bytes: <asin+147 @0622b3> - <asin+166 @0622c6>): if (negate)
	<asin+147 @0622b3>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @0622b7>  : 26                         load.i8
	<asin+152 @0622b8>  : 06 0e 00 00                jz <asin+166 @0622c6>
	cmplStd/lib/math.ci:493: (10 bytes: <asin+156 @0622bc> - <asin+166 @0622c6>): return .result := -result;
	<asin+156 @0622bc>  : 11 00                      dup.x64 sp(0)
	<asin+158 @0622be>  : 80                         neg.f64
	<asin+159 @0622bf>  : 14 08                      set.x64 sp(8)
	<asin+161 @0622c1>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @0622c5>  : 03                         ret
	cmplStd/lib/math.ci:495: (7 bytes: <asin+166 @0622c6> - <asin+173 @0622cd>): return .result := result;
	<asin+166 @0622c6>  : 14 06                      set.x64 sp(6)
	<asin+168 @0622c8>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @0622cc>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:63: referenced as `asin`
	cmplStd/lib/math.ci:502: referenced as `asin`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'cmplStd/lib/math.ci:502'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	cmplStd/test/std/test.math.ci:64: referenced as `acos`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'cmplStd/lib/math.ci:526'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'cmplStd/lib/math.ci:529'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@020390>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:184: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:182: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:180: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:178: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:175: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:173: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:171: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:169: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:166: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:164: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:114: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:112: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:31: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:24: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:141: referenced as `re`
	cmplStd/lib/math/Complex.ci:139: referenced as `re`
	cmplStd/lib/math/Complex.ci:138: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:126: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:114: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:102: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:99: referenced as `re`
	cmplStd/lib/math/Complex.ci:98: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:95: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:92: referenced as `re`
	cmplStd/lib/math/Complex.ci:91: referenced as `re`
	cmplStd/lib/math/Complex.ci:90: referenced as `re`
	cmplStd/lib/math/Complex.ci:83: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:73: referenced as `re`
	cmplStd/lib/math/Complex.ci:71: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:64: referenced as `re`
	cmplStd/lib/math/Complex.ci:33: referenced as `re`
	cmplStd/lib/math/Complex.ci:26: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:139: referenced as `im`
	cmplStd/lib/math/Complex.ci:138: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:126: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:114: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:101: referenced as `im`
	cmplStd/lib/math/Complex.ci:99: referenced as `im`
	cmplStd/lib/math/Complex.ci:98: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:94: referenced as `im`
	cmplStd/lib/math/Complex.ci:92: referenced as `im`
	cmplStd/lib/math/Complex.ci:91: referenced as `im`
	cmplStd/lib/math/Complex.ci:90: referenced as `im`
	cmplStd/lib/math/Complex.ci:83: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:73: referenced as `im`
	cmplStd/lib/math/Complex.ci:71: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:64: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	internal usages: 1
}
Complex(re: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@0622d0>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <Complex @0622d0> - <Complex+7 @0622d7>)
	cmplStd/lib/math/Complex.ci:25: (7 bytes: <Complex @0622d0> - <Complex+7 @0622d7>): return .result := {...};
	cmplStd/lib/math/Complex.ci:26: (3 bytes: <Complex @0622d0> - <Complex+3 @0622d3>): .result.re := re;
	<Complex @0622d0>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <Complex+3 @0622d3> - <Complex+6 @0622d6>): .result.im := (0);
	<Complex+3 @0622d3>    : 1a                         load.z64
	<Complex+4 @0622d4>    : 14 07                      set.x64 sp(7)
	<Complex+6 @0622d6>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@0622d8>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <Complex @0622d8> - <Complex+7 @0622df>)
	cmplStd/lib/math/Complex.ci:32: (7 bytes: <Complex @0622d8> - <Complex+7 @0622df>): return .result := {...};
	cmplStd/lib/math/Complex.ci:33: (3 bytes: <Complex @0622d8> - <Complex+3 @0622db>): .result.re := re;
	<Complex @0622d8>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:34: (3 bytes: <Complex+3 @0622db> - <Complex+6 @0622de>): .result.im := im;
	<Complex+3 @0622db>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @0622de>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(void(struct(a), neg.p2d)))
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:171: referenced as `neg`
	cmplStd/lib/math/Complex.ci:169: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `add`
	cmplStd/lib/math/Complex.ci:173: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:169: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `sub`
	cmplStd/lib/math/Complex.ci:173: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)))
.usages:
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 139
.offset: <@0622e0>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:86'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (139 bytes: <div @0622e0> - <div+139 @06236b>)
	cmplStd/lib/math/Complex.ci:90: (95 bytes: <div @0622e0> - <div+95 @06233f>): if (Math.abs(b.re) >= Math.abs(b.im))
	<div @0622e0>      : 11 01                      dup.x64 sp(1)
	<div+2 @0622e2>    : 11 00                      dup.x64 sp(0)
	<div+4 @0622e4>    : 1a                         load.z64
	<div+5 @0622e5>    : 88                         clt.f64
	<div+6 @0622e6>    : 06 0b 00 00                jz <div+17 @0622f1>
	<div+10 @0622ea>   : 11 00                      dup.x64 sp(0)
	<div+12 @0622ec>   : 80                         neg.f64
	<div+13 @0622ed>   : 04 06 00 00                jmp <div+19 @0622f3>
	<div+17 @0622f1>   : 11 00                      dup.x64 sp(0)
	<div+19 @0622f3>   : 14 02                      set.x64 sp(2)
	<div+21 @0622f5>   : 11 05                      dup.x64 sp(5)
	<div+23 @0622f7>   : 11 00                      dup.x64 sp(0)
	<div+25 @0622f9>   : 1a                         load.z64
	<div+26 @0622fa>   : 88                         clt.f64
	<div+27 @0622fb>   : 06 0b 00 00                jz <div+38 @062306>
	<div+31 @0622ff>   : 11 00                      dup.x64 sp(0)
	<div+33 @062301>   : 80                         neg.f64
	<div+34 @062302>   : 04 06 00 00                jmp <div+40 @062308>
	<div+38 @062306>   : 11 00                      dup.x64 sp(0)
	<div+40 @062308>   : 14 02                      set.x64 sp(2)
	<div+42 @06230a>   : 88                         clt.f64
	<div+43 @06230b>   : 05 34 00 00                jnz <div+95 @06233f>
	cmplStd/lib/math/Complex.ci:91: (5 bytes: <div+47 @06230f> - <div+52 @062314>): r: float64 := b.im / b.re
	<div+47 @06230f>   : 11 03                      dup.x64 sp(3)
	<div+49 @062311>   : 11 03                      dup.x64 sp(3)
	<div+51 @062313>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:92: (8 bytes: <div+52 @062314> - <div+60 @06231c>): den: float64 := b.re + r * b.im
	<div+52 @062314>   : 11 03                      dup.x64 sp(3)
	<div+54 @062316>   : 11 02                      dup.x64 sp(2)
	<div+56 @062318>   : 11 09                      dup.x64 sp(9)
	<div+58 @06231a>   : 83                         mul.f64
	<div+59 @06231b>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:93: (31 bytes: <div+60 @06231c> - <div+91 @06233b>): return .result := {...};
	cmplStd/lib/math/Complex.ci:94: (13 bytes: <div+60 @06231c> - <div+73 @062329>): .result.re := (a.re + r * a.im) / den;
	<div+60 @06231c>   : 11 09                      dup.x64 sp(9)
	<div+62 @06231e>   : 11 04                      dup.x64 sp(4)
	<div+64 @062320>   : 11 0f                      dup.x64 sp(15)
	<div+66 @062322>   : 83                         mul.f64
	<div+67 @062323>   : 81                         add.f64
	<div+68 @062324>   : 11 02                      dup.x64 sp(2)
	<div+70 @062326>   : 84                         div.f64
	<div+71 @062327>   : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:95: (13 bytes: <div+73 @062329> - <div+86 @062336>): .result.im := (a.im - r * a.re) / den;
	<div+73 @062329>   : 11 0b                      dup.x64 sp(11)
	<div+75 @06232b>   : 11 04                      dup.x64 sp(4)
	<div+77 @06232d>   : 11 0d                      dup.x64 sp(13)
	<div+79 @06232f>   : 83                         mul.f64
	<div+80 @062330>   : 82                         sub.f64
	<div+81 @062331>   : 11 02                      dup.x64 sp(2)
	<div+83 @062333>   : 84                         div.f64
	<div+84 @062334>   : 14 11                      set.x64 sp(17)
	<div+86 @062336>   : 09 f0 ff ff                inc.sp(-16)
	<div+90 @06233a>   : 03                         ret
	<div+91 @06233b>   : 09 f0 ff ff                inc.sp(-16)
	cmplStd/lib/math/Complex.ci:98: (5 bytes: <div+95 @06233f> - <div+100 @062344>): r: float64 := b.re / b.im
	<div+95 @06233f>   : 11 01                      dup.x64 sp(1)
	<div+97 @062341>   : 11 05                      dup.x64 sp(5)
	<div+99 @062343>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:99: (8 bytes: <div+100 @062344> - <div+108 @06234c>): den: float64 := b.im + r * b.re
	<div+100 @062344>  : 11 05                      dup.x64 sp(5)
	<div+102 @062346>  : 11 02                      dup.x64 sp(2)
	<div+104 @062348>  : 11 07                      dup.x64 sp(7)
	<div+106 @06234a>  : 83                         mul.f64
	<div+107 @06234b>  : 81                         add.f64
	cmplStd/lib/math/Complex.ci:100: (31 bytes: <div+108 @06234c> - <div+139 @06236b>): return .result := {...};
	cmplStd/lib/math/Complex.ci:101: (13 bytes: <div+108 @06234c> - <div+121 @062359>): .result.re := (a.re * r + a.im) / den;
	<div+108 @06234c>  : 11 09                      dup.x64 sp(9)
	<div+110 @06234e>  : 11 04                      dup.x64 sp(4)
	<div+112 @062350>  : 83                         mul.f64
	<div+113 @062351>  : 11 0d                      dup.x64 sp(13)
	<div+115 @062353>  : 81                         add.f64
	<div+116 @062354>  : 11 02                      dup.x64 sp(2)
	<div+118 @062356>  : 84                         div.f64
	<div+119 @062357>  : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:102: (13 bytes: <div+121 @062359> - <div+134 @062366>): .result.im := (a.im * r - a.re) / den;
	<div+121 @062359>  : 11 0b                      dup.x64 sp(11)
	<div+123 @06235b>  : 11 04                      dup.x64 sp(4)
	<div+125 @06235d>  : 83                         mul.f64
	<div+126 @06235e>  : 11 0b                      dup.x64 sp(11)
	<div+128 @062360>  : 82                         sub.f64
	<div+129 @062361>  : 11 02                      dup.x64 sp(2)
	<div+131 @062363>  : 84                         div.f64
	<div+132 @062364>  : 14 11                      set.x64 sp(17)
	<div+134 @062366>  : 09 f0 ff ff                inc.sp(-16)
	<div+138 @06236a>  : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `div`
	cmplStd/lib/math/Complex.ci:173: referenced as `div`
	cmplStd/lib/math/Complex.ci:166: referenced as `div`
	cmplStd/lib/math/Complex.ci:164: referenced as `div`
	cmplStd/lib/math/Complex.ci:109: referenced as `div`
	cmplStd/lib/math/Complex.ci:107: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:107'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `div`
	cmplStd/lib/math/Complex.ci:169: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:109'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:112'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `abs`
	cmplStd/lib/math/Complex.ci:136: referenced as `abs`
	cmplStd/lib/math/Complex.ci:132: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:114'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `arg`
	cmplStd/lib/math/Complex.ci:137: referenced as `arg`
	cmplStd/lib/math/Complex.ci:132: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.offset: <@062370>
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:117'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <inv @062370> - <inv+31 @06238f>)
	cmplStd/lib/math/Complex.ci:118: (11 bytes: <inv @062370> - <inv+11 @06237b>): d: float64 := a.re * a.re + a.im * a.im
	<inv @062370>      : 11 01                      dup.x64 sp(1)
	<inv+2 @062372>    : 11 03                      dup.x64 sp(3)
	<inv+4 @062374>    : 83                         mul.f64
	<inv+5 @062375>    : 11 05                      dup.x64 sp(5)
	<inv+7 @062377>    : 11 07                      dup.x64 sp(7)
	<inv+9 @062379>    : 83                         mul.f64
	<inv+10 @06237a>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:119: (20 bytes: <inv+11 @06237b> - <inv+31 @06238f>): return .result := {...};
	cmplStd/lib/math/Complex.ci:120: (7 bytes: <inv+11 @06237b> - <inv+18 @062382>): .result.re := +a.re / d;
	<inv+11 @06237b>   : 11 03                      dup.x64 sp(3)
	<inv+13 @06237d>   : 11 02                      dup.x64 sp(2)
	<inv+15 @06237f>   : 84                         div.f64
	<inv+16 @062380>   : 14 09                      set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:121: (8 bytes: <inv+18 @062382> - <inv+26 @06238a>): .result.im := -a.im / d;
	<inv+18 @062382>   : 11 05                      dup.x64 sp(5)
	<inv+20 @062384>   : 80                         neg.f64
	<inv+21 @062385>   : 11 02                      dup.x64 sp(2)
	<inv+23 @062387>   : 84                         div.f64
	<inv+24 @062388>   : 14 0b                      set.x64 sp(11)
	<inv+26 @06238a>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @06238e>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `inv`
	cmplStd/lib/math/Complex.ci:182: referenced as `inv`
	cmplStd/lib/math/Complex.ci:180: referenced as `inv`
	cmplStd/lib/math/Complex.ci:178: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 100
.offset: <@062390>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <pow @062390> - <pow+100 @0623f4>)
	cmplStd/lib/math/Complex.ci:136: (23 bytes: <pow @062390> - <pow+23 @0623a7>): r: float64 := abs(a)
	<pow @062390>      : 12 05                      dup.x128 sp(5)
	<pow+2 @062392>    : 11 00                      dup.x64 sp(0)
	<pow+4 @062394>    : 11 02                      dup.x64 sp(2)
	<pow+6 @062396>    : 83                         mul.f64
	<pow+7 @062397>    : 11 04                      dup.x64 sp(4)
	<pow+9 @062399>    : 11 06                      dup.x64 sp(6)
	<pow+11 @06239b>   : 83                         mul.f64
	<pow+12 @06239c>   : 81                         add.f64
	<pow+13 @06239d>   : 01 30 00 00                nfc(48) ;float64.sqrt(x: float64): float64
	<pow+17 @0623a1>   : 14 04                      set.x64 sp(4)
	<pow+19 @0623a3>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:137: (16 bytes: <pow+23 @0623a7> - <pow+39 @0623b7>): t: float64 := arg(a)
	<pow+23 @0623a7>   : 12 07                      dup.x128 sp(7)
	<pow+25 @0623a9>   : 11 00                      dup.x64 sp(0)
	<pow+27 @0623ab>   : 11 04                      dup.x64 sp(4)
	<pow+29 @0623ad>   : 01 31 00 00                nfc(49) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @0623b1>   : 14 04                      set.x64 sp(4)
	<pow+35 @0623b3>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:138: (15 bytes: <pow+39 @0623b7> - <pow+54 @0623c6>): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+39 @0623b7>   : 11 05                      dup.x64 sp(5)
	<pow+41 @0623b9>   : 11 02                      dup.x64 sp(2)
	<pow+43 @0623bb>   : 83                         mul.f64
	<pow+44 @0623bc>   : 11 09                      dup.x64 sp(9)
	<pow+46 @0623be>   : 11 06                      dup.x64 sp(6)
	<pow+48 @0623c0>   : 01 2d 00 00                nfc(45) ;float64.log(x: float64): float64
	<pow+52 @0623c4>   : 83                         mul.f64
	<pow+53 @0623c5>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:139: (19 bytes: <pow+54 @0623c6> - <pow+73 @0623d9>): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+54 @0623c6>   : 11 04                      dup.x64 sp(4)
	<pow+56 @0623c8>   : 11 09                      dup.x64 sp(9)
	<pow+58 @0623ca>   : 01 2f 00 00                nfc(47) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @0623ce>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @0623d0>   : 80                         neg.f64
	<pow+65 @0623d1>   : 11 06                      dup.x64 sp(6)
	<pow+67 @0623d3>   : 83                         mul.f64
	<pow+68 @0623d4>   : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<pow+72 @0623d8>   : 83                         mul.f64
	cmplStd/lib/math/Complex.ci:140: (27 bytes: <pow+73 @0623d9> - <pow+100 @0623f4>): return .result := {...};
	cmplStd/lib/math/Complex.ci:141: (11 bytes: <pow+73 @0623d9> - <pow+84 @0623e4>): .result.re := v * float64.cos(u);
	<pow+73 @0623d9>   : 11 00                      dup.x64 sp(0)
	<pow+75 @0623db>   : 11 04                      dup.x64 sp(4)
	<pow+77 @0623dd>   : 01 2b 00 00                nfc(43) ;float64.cos(x: float64): float64
	<pow+81 @0623e1>   : 83                         mul.f64
	<pow+82 @0623e2>   : 14 13                      set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:142: (11 bytes: <pow+84 @0623e4> - <pow+95 @0623ef>): .result.im := v * float64.sin(u);
	<pow+84 @0623e4>   : 11 00                      dup.x64 sp(0)
	<pow+86 @0623e6>   : 11 04                      dup.x64 sp(4)
	<pow+88 @0623e8>   : 01 2a 00 00                nfc(42) ;float64.sin(x: float64): float64
	<pow+92 @0623ec>   : 83                         mul.f64
	<pow+93 @0623ed>   : 14 15                      set.x64 sp(21)
	<pow+95 @0623ef>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @0623f3>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:149'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:180: referenced as `sin`
	cmplStd/lib/math/Complex.ci:166: referenced as `sin`
	cmplStd/lib/math/Complex.ci:164: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:151'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:178: referenced as `cos`
	cmplStd/lib/math/Complex.ci:166: referenced as `cos`
	cmplStd/lib/math/Complex.ci:164: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:164'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:169'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:171'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:182: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:173'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:178'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:180'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:182'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:187'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:189'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@025ed8>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplStd/lib/math/Matrix4f.ci:203: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:170: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:141'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:184: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:180: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:183: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:175: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:208: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:197: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.param w: float32 (size: 4, offs: <+16>, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:188: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:128: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(void(vec4f(a), b))
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(void(a, vec4f(b)))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(vec4f(a), b))
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(a, vec4f(b)))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(vec4f(a), b))
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(a, vec4f(b)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:170: referenced as `mul`
}
div(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(vec4f(a), b))
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(a, vec4f(b)))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:102'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: vec4f (size: 16, offs: <+32>, cast: val)
.param max: vec4f (size: 16, offs: <+48>, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(void(max(void(vec, min)), max))
.usages:
	cmplStd/lib/math/Vector4f.ci:108: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: float32 (size: 4, offs: <+20>, cast: f32)
.param max: float32 (size: 4, offs: <+24>, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(void(void(vec, vec4f(min)), vec4f(max)))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:112'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:116'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:120'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:126'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:128'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@02b378>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplStd/lib/math/Matrix4f.ci:203: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:212'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:188: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:212'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:175: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:142: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:180: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:147: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:181: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:208: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:197: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:183: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:208: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:197: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:184: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:208: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:197: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:185: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:152: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:208: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:197: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:186: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:209: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:198: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:209: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:198: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:209: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:198: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:209: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:198: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@0623f8>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
}
.instructions: (49 bytes: <mat4f @0623f8> - <mat4f+49 @062429>)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes: <mat4f @0623f8> - <mat4f+49 @062429>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f @0623f8> - <mat4f+3 @0623fb>): .result.xx := xx;
	<mat4f @0623f8>      : 16 11 10                   mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+3 @0623fb> - <mat4f+6 @0623fe>): .result.xy := xy;
	<mat4f+3 @0623fb>    : 16 12 0f                   mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+6 @0623fe> - <mat4f+9 @062401>): .result.xz := xz;
	<mat4f+6 @0623fe>    : 16 13 0e                   mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+9 @062401> - <mat4f+12 @062404>): .result.xw := xw;
	<mat4f+9 @062401>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+12 @062404> - <mat4f+15 @062407>): .result.yx := yx;
	<mat4f+12 @062404>   : 16 15 0c                   mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+15 @062407> - <mat4f+18 @06240a>): .result.yy := yy;
	<mat4f+15 @062407>   : 16 16 0b                   mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+18 @06240a> - <mat4f+21 @06240d>): .result.yz := yz;
	<mat4f+18 @06240a>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+21 @06240d> - <mat4f+24 @062410>): .result.yw := yw;
	<mat4f+21 @06240d>   : 16 18 09                   mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+24 @062410> - <mat4f+27 @062413>): .result.zx := zx;
	<mat4f+24 @062410>   : 16 19 08                   mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+27 @062413> - <mat4f+30 @062416>): .result.zy := zy;
	<mat4f+27 @062413>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+30 @062416> - <mat4f+33 @062419>): .result.zz := zz;
	<mat4f+30 @062416>   : 16 1b 06                   mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+33 @062419> - <mat4f+36 @06241c>): .result.zw := zw;
	<mat4f+33 @062419>   : 16 1c 05                   mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+36 @06241c> - <mat4f+39 @06241f>): .result.wx := wx;
	<mat4f+36 @06241c>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+39 @06241f> - <mat4f+42 @062422>): .result.wy := wy;
	<mat4f+39 @06241f>   : 16 1e 03                   mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+42 @062422> - <mat4f+45 @062425>): .result.wz := wz;
	<mat4f+42 @062422>   : 16 1f 02                   mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+45 @062425> - <mat4f+48 @062428>): .result.ww := ww;
	<mat4f+45 @062425>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @062428>   : 03                         ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.offset: <@062430>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <mat4f @062430> - <mat4f+21 @062445>)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes: <mat4f @062430> - <mat4f+21 @062445>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f @062430> - <mat4f+5 @062435>): .result.x := x;
	<mat4f @062430>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @062432>    : 2a                         load.i128
	<mat4f+3 @062433>    : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+5 @062435> - <mat4f+10 @06243a>): .result.y := y;
	<mat4f+5 @062435>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @062437>    : 2a                         load.i128
	<mat4f+8 @062438>    : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+10 @06243a> - <mat4f+15 @06243f>): .result.z := z;
	<mat4f+10 @06243a>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @06243c>   : 2a                         load.i128
	<mat4f+13 @06243d>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+15 @06243f> - <mat4f+20 @062444>): .result.w := w;
	<mat4f+15 @06243f>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @062441>   : 2a                         load.i128
	<mat4f+18 @062442>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @062444>   : 03                         ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@062448>
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param mat: mat4f (size: 64, offs: <+128>, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
}
.instructions: (49 bytes: <transpose @062448> - <transpose+49 @062479>)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes: <transpose @062448> - <transpose+49 @062479>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose @062448> - <transpose+3 @06244b>): .result.xx := mat.xx;
	<transpose @062448>      : 16 11 01                   mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+3 @06244b> - <transpose+6 @06244e>): .result.xy := mat.yx;
	<transpose+3 @06244b>    : 16 12 05                   mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+6 @06244e> - <transpose+9 @062451>): .result.xz := mat.zx;
	<transpose+6 @06244e>    : 16 13 09                   mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+9 @062451> - <transpose+12 @062454>): .result.xw := mat.wx;
	<transpose+9 @062451>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+12 @062454> - <transpose+15 @062457>): .result.yx := mat.xy;
	<transpose+12 @062454>   : 16 15 02                   mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+15 @062457> - <transpose+18 @06245a>): .result.yy := mat.yy;
	<transpose+15 @062457>   : 16 16 06                   mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+18 @06245a> - <transpose+21 @06245d>): .result.yz := mat.zy;
	<transpose+18 @06245a>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+21 @06245d> - <transpose+24 @062460>): .result.yw := mat.wy;
	<transpose+21 @06245d>   : 16 18 0e                   mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+24 @062460> - <transpose+27 @062463>): .result.zx := mat.xz;
	<transpose+24 @062460>   : 16 19 03                   mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+27 @062463> - <transpose+30 @062466>): .result.zy := mat.yz;
	<transpose+27 @062463>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+30 @062466> - <transpose+33 @062469>): .result.zz := mat.zz;
	<transpose+30 @062466>   : 16 1b 0b                   mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+33 @062469> - <transpose+36 @06246c>): .result.zw := mat.wz;
	<transpose+33 @062469>   : 16 1c 0f                   mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+36 @06246c> - <transpose+39 @06246f>): .result.wx := mat.xw;
	<transpose+36 @06246c>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+39 @06246f> - <transpose+42 @062472>): .result.wy := mat.yw;
	<transpose+39 @06246f>   : 16 1e 08                   mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+42 @062472> - <transpose+45 @062475>): .result.wz := mat.zw;
	<transpose+42 @062472>   : 16 1f 0c                   mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+45 @062475> - <transpose+48 @062478>): .result.ww := mat.ww;
	<transpose+45 @062475>   : 16 20 10                   mov.x32 sp(32, 16)
	<transpose+48 @062478>   : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 245
.offset: <@062480>
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (245 bytes: <mul @062480> - <mul+245 @062575>)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes: <mul @062480> - <mul+28 @06249c>): transposed: mat4f := transpose(rhs)
	<mul @062480>      : 09 40 00 00                inc.sp(+64)
	<mul+4 @062484>    : 10 11                      dup.x32 sp(17)
	<mul+6 @062486>    : 0a c4 ff ff                load.sp(-60)
	<mul+10 @06248a>   : 1e c0 ff ff                copy.mem -64
	<mul+14 @06248e>   : 09 40 00 00                inc.sp(+64)
	<mul+18 @062492>   : 1f 48 24 06 00             load.ref <@062448> ;transpose(mat: mat4f): mat4f
	<mul+23 @062497>   : 02                         call
	<mul+24 @062498>   : 09 c0 ff ff                inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (217 bytes: <mul+28 @06249c> - <mul+245 @062575>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (50 bytes: <mul+28 @06249c> - <mul+78 @0624ce>): .result.x := dp4(transposed, lhs.x);
	<mul+28 @06249c>   : 0a 00 00 00                load.sp(+0)
	<mul+32 @0624a0>   : 10 13                      dup.x32 sp(19)
	<mul+34 @0624a2>   : 10 01                      dup.x32 sp(1)
	<mul+36 @0624a4>   : 0c 30 00 00                inc.i32(+48)
	<mul+40 @0624a8>   : 2a                         load.i128
	<mul+41 @0624a9>   : 10 04                      dup.x32 sp(4)
	<mul+43 @0624ab>   : 2a                         load.i128
	<mul+44 @0624ac>   : 9b                         dp4.v4f
	<mul+45 @0624ad>   : 10 02                      dup.x32 sp(2)
	<mul+47 @0624af>   : 0c 20 00 00                inc.i32(+32)
	<mul+51 @0624b3>   : 2a                         load.i128
	<mul+52 @0624b4>   : 10 05                      dup.x32 sp(5)
	<mul+54 @0624b6>   : 2a                         load.i128
	<mul+55 @0624b7>   : 9b                         dp4.v4f
	<mul+56 @0624b8>   : 10 03                      dup.x32 sp(3)
	<mul+58 @0624ba>   : 0c 10 00 00                inc.i32(+16)
	<mul+62 @0624be>   : 2a                         load.i128
	<mul+63 @0624bf>   : 10 06                      dup.x32 sp(6)
	<mul+65 @0624c1>   : 2a                         load.i128
	<mul+66 @0624c2>   : 9b                         dp4.v4f
	<mul+67 @0624c3>   : 10 04                      dup.x32 sp(4)
	<mul+69 @0624c5>   : 2a                         load.i128
	<mul+70 @0624c6>   : 10 07                      dup.x32 sp(7)
	<mul+72 @0624c8>   : 2a                         load.i128
	<mul+73 @0624c9>   : 9b                         dp4.v4f
	<mul+74 @0624ca>   : 15 02                      set.x128 sp(2)
	<mul+76 @0624cc>   : 15 17                      set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (54 bytes: <mul+78 @0624ce> - <mul+132 @062504>): .result.y := dp4(transposed, lhs.y);
	<mul+78 @0624ce>   : 0a 00 00 00                load.sp(+0)
	<mul+82 @0624d2>   : 10 13                      dup.x32 sp(19)
	<mul+84 @0624d4>   : 0c 10 00 00                inc.i32(+16)
	<mul+88 @0624d8>   : 10 01                      dup.x32 sp(1)
	<mul+90 @0624da>   : 0c 30 00 00                inc.i32(+48)
	<mul+94 @0624de>   : 2a                         load.i128
	<mul+95 @0624df>   : 10 04                      dup.x32 sp(4)
	<mul+97 @0624e1>   : 2a                         load.i128
	<mul+98 @0624e2>   : 9b                         dp4.v4f
	<mul+99 @0624e3>   : 10 02                      dup.x32 sp(2)
	<mul+101 @0624e5>  : 0c 20 00 00                inc.i32(+32)
	<mul+105 @0624e9>  : 2a                         load.i128
	<mul+106 @0624ea>  : 10 05                      dup.x32 sp(5)
	<mul+108 @0624ec>  : 2a                         load.i128
	<mul+109 @0624ed>  : 9b                         dp4.v4f
	<mul+110 @0624ee>  : 10 03                      dup.x32 sp(3)
	<mul+112 @0624f0>  : 0c 10 00 00                inc.i32(+16)
	<mul+116 @0624f4>  : 2a                         load.i128
	<mul+117 @0624f5>  : 10 06                      dup.x32 sp(6)
	<mul+119 @0624f7>  : 2a                         load.i128
	<mul+120 @0624f8>  : 9b                         dp4.v4f
	<mul+121 @0624f9>  : 10 04                      dup.x32 sp(4)
	<mul+123 @0624fb>  : 2a                         load.i128
	<mul+124 @0624fc>  : 10 07                      dup.x32 sp(7)
	<mul+126 @0624fe>  : 2a                         load.i128
	<mul+127 @0624ff>  : 9b                         dp4.v4f
	<mul+128 @062500>  : 15 02                      set.x128 sp(2)
	<mul+130 @062502>  : 15 1b                      set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (54 bytes: <mul+132 @062504> - <mul+186 @06253a>): .result.z := dp4(transposed, lhs.z);
	<mul+132 @062504>  : 0a 00 00 00                load.sp(+0)
	<mul+136 @062508>  : 10 13                      dup.x32 sp(19)
	<mul+138 @06250a>  : 0c 20 00 00                inc.i32(+32)
	<mul+142 @06250e>  : 10 01                      dup.x32 sp(1)
	<mul+144 @062510>  : 0c 30 00 00                inc.i32(+48)
	<mul+148 @062514>  : 2a                         load.i128
	<mul+149 @062515>  : 10 04                      dup.x32 sp(4)
	<mul+151 @062517>  : 2a                         load.i128
	<mul+152 @062518>  : 9b                         dp4.v4f
	<mul+153 @062519>  : 10 02                      dup.x32 sp(2)
	<mul+155 @06251b>  : 0c 20 00 00                inc.i32(+32)
	<mul+159 @06251f>  : 2a                         load.i128
	<mul+160 @062520>  : 10 05                      dup.x32 sp(5)
	<mul+162 @062522>  : 2a                         load.i128
	<mul+163 @062523>  : 9b                         dp4.v4f
	<mul+164 @062524>  : 10 03                      dup.x32 sp(3)
	<mul+166 @062526>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @06252a>  : 2a                         load.i128
	<mul+171 @06252b>  : 10 06                      dup.x32 sp(6)
	<mul+173 @06252d>  : 2a                         load.i128
	<mul+174 @06252e>  : 9b                         dp4.v4f
	<mul+175 @06252f>  : 10 04                      dup.x32 sp(4)
	<mul+177 @062531>  : 2a                         load.i128
	<mul+178 @062532>  : 10 07                      dup.x32 sp(7)
	<mul+180 @062534>  : 2a                         load.i128
	<mul+181 @062535>  : 9b                         dp4.v4f
	<mul+182 @062536>  : 15 02                      set.x128 sp(2)
	<mul+184 @062538>  : 15 1f                      set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (54 bytes: <mul+186 @06253a> - <mul+240 @062570>): .result.w := dp4(transposed, lhs.w);
	<mul+186 @06253a>  : 0a 00 00 00                load.sp(+0)
	<mul+190 @06253e>  : 10 13                      dup.x32 sp(19)
	<mul+192 @062540>  : 0c 30 00 00                inc.i32(+48)
	<mul+196 @062544>  : 10 01                      dup.x32 sp(1)
	<mul+198 @062546>  : 0c 30 00 00                inc.i32(+48)
	<mul+202 @06254a>  : 2a                         load.i128
	<mul+203 @06254b>  : 10 04                      dup.x32 sp(4)
	<mul+205 @06254d>  : 2a                         load.i128
	<mul+206 @06254e>  : 9b                         dp4.v4f
	<mul+207 @06254f>  : 10 02                      dup.x32 sp(2)
	<mul+209 @062551>  : 0c 20 00 00                inc.i32(+32)
	<mul+213 @062555>  : 2a                         load.i128
	<mul+214 @062556>  : 10 05                      dup.x32 sp(5)
	<mul+216 @062558>  : 2a                         load.i128
	<mul+217 @062559>  : 9b                         dp4.v4f
	<mul+218 @06255a>  : 10 03                      dup.x32 sp(3)
	<mul+220 @06255c>  : 0c 10 00 00                inc.i32(+16)
	<mul+224 @062560>  : 2a                         load.i128
	<mul+225 @062561>  : 10 06                      dup.x32 sp(6)
	<mul+227 @062563>  : 2a                         load.i128
	<mul+228 @062564>  : 9b                         dp4.v4f
	<mul+229 @062565>  : 10 04                      dup.x32 sp(4)
	<mul+231 @062567>  : 2a                         load.i128
	<mul+232 @062568>  : 10 07                      dup.x32 sp(7)
	<mul+234 @06256a>  : 2a                         load.i128
	<mul+235 @06256b>  : 9b                         dp4.v4f
	<mul+236 @06256c>  : 15 02                      set.x128 sp(2)
	<mul+238 @06256e>  : 15 23                      set.x128 sp(35)
	<mul+240 @062570>  : 09 c0 ff ff                inc.sp(-64)
	<mul+244 @062574>  : 03                         ret
.usages:
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 454
.offset: <@062578>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (454 bytes: <rotation @062578> - <rotation+454 @06273e>)
	cmplStd/lib/math/Matrix4f.ci:112: (18 bytes: <rotation @062578> - <rotation+18 @06258a>): len: float32 := length(direction)
	<rotation @062578>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @06257a>    : 2a                         load.i128
	<rotation+3 @06257b>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @06257d>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @06257f>    : 9a                         dp3.v4f
	<rotation+8 @062580>    : 01 28 00 00                nfc(40) ;float32.sqrt(x: float32): float32
	<rotation+12 @062584>   : 13 04                      set.x32 sp(4)
	<rotation+14 @062586>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math/Matrix4f.ci:113: (82 bytes: <rotation+18 @06258a> - <rotation+100 @0625dc>): if ((len) < 0.000000)
	<rotation+18 @06258a>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @06258c>   : 7d                         f32.2f64
	<rotation+21 @06258d>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @062596>   : 88                         clt.f64
	<rotation+31 @062597>   : 06 45 00 00                jz <rotation+100 @0625dc>
	cmplStd/lib/math/Matrix4f.ci:114: (36 bytes: <rotation+35 @06259b> - <rotation+71 @0625bf>): trace("invalid direction of rotation", direction);
	<rotation+35 @06259b>   : 1f 20 b0 02 00             load.ref <@02b020> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+40 @0625a0>   : 1c 72 00 00 00             load.c32 114
	<rotation+45 @0625a5>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @0625aa>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @0625af>   : 1f dd b2 02 00             load.ref <@02b2dd> ;"invalid direction of rotation"
	<rotation+60 @0625b4>   : 1f d8 5e 02 00             load.ref <@025ed8> ;vec4f
	<rotation+65 @0625b9>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @0625bb>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/math/Matrix4f.ci:115: (29 bytes: <rotation+71 @0625bf> - <rotation+100 @0625dc>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes: <rotation+71 @0625bf> - <rotation+77 @0625c5>): .result.x := vec4f(0, 0, 0, 0);
	<rotation+71 @0625bf>   : 19                         load.z32
	<rotation+72 @0625c0>   : 19                         load.z32
	<rotation+73 @0625c1>   : 19                         load.z32
	<rotation+74 @0625c2>   : 19                         load.z32
	<rotation+75 @0625c3>   : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes: <rotation+77 @0625c5> - <rotation+83 @0625cb>): .result.y := vec4f(0, 0, 0, 0);
	<rotation+77 @0625c5>   : 19                         load.z32
	<rotation+78 @0625c6>   : 19                         load.z32
	<rotation+79 @0625c7>   : 19                         load.z32
	<rotation+80 @0625c8>   : 19                         load.z32
	<rotation+81 @0625c9>   : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:118: (6 bytes: <rotation+83 @0625cb> - <rotation+89 @0625d1>): .result.z := vec4f(0, 0, 0, 0);
	<rotation+83 @0625cb>   : 19                         load.z32
	<rotation+84 @0625cc>   : 19                         load.z32
	<rotation+85 @0625cd>   : 19                         load.z32
	<rotation+86 @0625ce>   : 19                         load.z32
	<rotation+87 @0625cf>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:119: (6 bytes: <rotation+89 @0625d1> - <rotation+95 @0625d7>): .result.w := vec4f(0, 0, 0, 0);
	<rotation+89 @0625d1>   : 19                         load.z32
	<rotation+90 @0625d2>   : 19                         load.z32
	<rotation+91 @0625d3>   : 19                         load.z32
	<rotation+92 @0625d4>   : 19                         load.z32
	<rotation+93 @0625d5>   : 15 15                      set.x128 sp(21)
	<rotation+95 @0625d7>   : 09 fc ff ff                inc.sp(-4)
	<rotation+99 @0625db>   : 03                         ret
	cmplStd/lib/math/Matrix4f.ci:122: (6 bytes: <rotation+100 @0625dc> - <rotation+106 @0625e2>): x: float32 := direction.x / len
	<rotation+100 @0625dc>  : 10 03                      dup.x32 sp(3)
	<rotation+102 @0625de>  : 28                         load.i32
	<rotation+103 @0625df>  : 10 01                      dup.x32 sp(1)
	<rotation+105 @0625e1>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (10 bytes: <rotation+106 @0625e2> - <rotation+116 @0625ec>): y: float32 := direction.y / len
	<rotation+106 @0625e2>  : 10 04                      dup.x32 sp(4)
	<rotation+108 @0625e4>  : 0c 04 00 00                inc.i32(+4)
	<rotation+112 @0625e8>  : 28                         load.i32
	<rotation+113 @0625e9>  : 10 02                      dup.x32 sp(2)
	<rotation+115 @0625eb>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:124: (10 bytes: <rotation+116 @0625ec> - <rotation+126 @0625f6>): z: float32 := direction.z / len
	<rotation+116 @0625ec>  : 10 05                      dup.x32 sp(5)
	<rotation+118 @0625ee>  : 0c 08 00 00                inc.i32(+8)
	<rotation+122 @0625f2>  : 28                         load.i32
	<rotation+123 @0625f3>  : 10 03                      dup.x32 sp(3)
	<rotation+125 @0625f5>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:125: (3 bytes: <rotation+126 @0625f6> - <rotation+129 @0625f9>): cx: float32 := center.x
	<rotation+126 @0625f6>  : 10 07                      dup.x32 sp(7)
	<rotation+128 @0625f8>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (7 bytes: <rotation+129 @0625f9> - <rotation+136 @062600>): cy: float32 := center.y
	<rotation+129 @0625f9>  : 10 08                      dup.x32 sp(8)
	<rotation+131 @0625fb>  : 0c 04 00 00                inc.i32(+4)
	<rotation+135 @0625ff>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:127: (7 bytes: <rotation+136 @062600> - <rotation+143 @062607>): cz: float32 := center.z
	<rotation+136 @062600>  : 10 09                      dup.x32 sp(9)
	<rotation+138 @062602>  : 0c 08 00 00                inc.i32(+8)
	<rotation+142 @062606>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes: <rotation+143 @062607> - <rotation+148 @06260c>): xx: float32 := x * x
	<rotation+143 @062607>  : 10 05                      dup.x32 sp(5)
	<rotation+145 @062609>  : 10 06                      dup.x32 sp(6)
	<rotation+147 @06260b>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes: <rotation+148 @06260c> - <rotation+153 @062611>): xy: float32 := x * y
	<rotation+148 @06260c>  : 10 06                      dup.x32 sp(6)
	<rotation+150 @06260e>  : 10 06                      dup.x32 sp(6)
	<rotation+152 @062610>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes: <rotation+153 @062611> - <rotation+158 @062616>): xz: float32 := x * z
	<rotation+153 @062611>  : 10 07                      dup.x32 sp(7)
	<rotation+155 @062613>  : 10 06                      dup.x32 sp(6)
	<rotation+157 @062615>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes: <rotation+158 @062616> - <rotation+163 @06261b>): yy: float32 := y * y
	<rotation+158 @062616>  : 10 07                      dup.x32 sp(7)
	<rotation+160 @062618>  : 10 08                      dup.x32 sp(8)
	<rotation+162 @06261a>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:132: (5 bytes: <rotation+163 @06261b> - <rotation+168 @062620>): yz: float32 := y * z
	<rotation+163 @06261b>  : 10 08                      dup.x32 sp(8)
	<rotation+165 @06261d>  : 10 08                      dup.x32 sp(8)
	<rotation+167 @06261f>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (5 bytes: <rotation+168 @062620> - <rotation+173 @062625>): zz: float32 := z * z
	<rotation+168 @062620>  : 10 08                      dup.x32 sp(8)
	<rotation+170 @062622>  : 10 09                      dup.x32 sp(9)
	<rotation+172 @062624>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:135: (6 bytes: <rotation+173 @062625> - <rotation+179 @06262b>): s: float32 := float32.sin(angle)
	<rotation+173 @062625>  : 10 0e                      dup.x32 sp(14)
	<rotation+175 @062627>  : 01 22 00 00                nfc(34) ;float32.sin(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:136: (6 bytes: <rotation+179 @06262b> - <rotation+185 @062631>): c: float32 := float32.cos(angle)
	<rotation+179 @06262b>  : 10 0f                      dup.x32 sp(15)
	<rotation+181 @06262d>  : 01 23 00 00                nfc(35) ;float32.cos(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:137: (8 bytes: <rotation+185 @062631> - <rotation+193 @062639>): k: float32 := (1) - c
	<rotation+185 @062631>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+190 @062636>  : 10 01                      dup.x32 sp(1)
	<rotation+192 @062638>  : 72                         sub.f32
	cmplStd/lib/math/Matrix4f.ci:139: (261 bytes: <rotation+193 @062639> - <rotation+454 @06273e>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes: <rotation+193 @062639> - <rotation+206 @062646>): .result.xx := xx + (yy + zz) * c;
	<rotation+193 @062639>  : 10 08                      dup.x32 sp(8)
	<rotation+195 @06263b>  : 10 06                      dup.x32 sp(6)
	<rotation+197 @06263d>  : 10 05                      dup.x32 sp(5)
	<rotation+199 @06263f>  : 71                         add.f32
	<rotation+200 @062640>  : 10 03                      dup.x32 sp(3)
	<rotation+202 @062642>  : 73                         mul.f32
	<rotation+203 @062643>  : 71                         add.f32
	<rotation+204 @062644>  : 13 15                      set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:141: (13 bytes: <rotation+206 @062646> - <rotation+219 @062653>): .result.xy := xy * k - z * s;
	<rotation+206 @062646>  : 10 07                      dup.x32 sp(7)
	<rotation+208 @062648>  : 10 01                      dup.x32 sp(1)
	<rotation+210 @06264a>  : 73                         mul.f32
	<rotation+211 @06264b>  : 10 0d                      dup.x32 sp(13)
	<rotation+213 @06264d>  : 10 04                      dup.x32 sp(4)
	<rotation+215 @06264f>  : 73                         mul.f32
	<rotation+216 @062650>  : 72                         sub.f32
	<rotation+217 @062651>  : 13 16                      set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:142: (13 bytes: <rotation+219 @062653> - <rotation+232 @062660>): .result.xz := xz * k + y * s;
	<rotation+219 @062653>  : 10 06                      dup.x32 sp(6)
	<rotation+221 @062655>  : 10 01                      dup.x32 sp(1)
	<rotation+223 @062657>  : 73                         mul.f32
	<rotation+224 @062658>  : 10 0e                      dup.x32 sp(14)
	<rotation+226 @06265a>  : 10 04                      dup.x32 sp(4)
	<rotation+228 @06265c>  : 73                         mul.f32
	<rotation+229 @06265d>  : 71                         add.f32
	<rotation+230 @06265e>  : 13 17                      set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:143: (43 bytes: <rotation+232 @062660> - <rotation+275 @06268b>): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+232 @062660>  : 10 0b                      dup.x32 sp(11)
	<rotation+234 @062662>  : 10 06                      dup.x32 sp(6)
	<rotation+236 @062664>  : 10 05                      dup.x32 sp(5)
	<rotation+238 @062666>  : 71                         add.f32
	<rotation+239 @062667>  : 73                         mul.f32
	<rotation+240 @062668>  : 10 0f                      dup.x32 sp(15)
	<rotation+242 @06266a>  : 10 0c                      dup.x32 sp(12)
	<rotation+244 @06266c>  : 10 10                      dup.x32 sp(16)
	<rotation+246 @06266e>  : 73                         mul.f32
	<rotation+247 @06266f>  : 10 0c                      dup.x32 sp(12)
	<rotation+249 @062671>  : 10 10                      dup.x32 sp(16)
	<rotation+251 @062673>  : 73                         mul.f32
	<rotation+252 @062674>  : 71                         add.f32
	<rotation+253 @062675>  : 73                         mul.f32
	<rotation+254 @062676>  : 72                         sub.f32
	<rotation+255 @062677>  : 10 01                      dup.x32 sp(1)
	<rotation+257 @062679>  : 73                         mul.f32
	<rotation+258 @06267a>  : 10 0b                      dup.x32 sp(11)
	<rotation+260 @06267c>  : 10 0e                      dup.x32 sp(14)
	<rotation+262 @06267e>  : 73                         mul.f32
	<rotation+263 @06267f>  : 10 0b                      dup.x32 sp(11)
	<rotation+265 @062681>  : 10 10                      dup.x32 sp(16)
	<rotation+267 @062683>  : 73                         mul.f32
	<rotation+268 @062684>  : 72                         sub.f32
	<rotation+269 @062685>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @062687>  : 73                         mul.f32
	<rotation+272 @062688>  : 71                         add.f32
	<rotation+273 @062689>  : 13 18                      set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes: <rotation+275 @06268b> - <rotation+288 @062698>): .result.yx := xy * k + z * s;
	<rotation+275 @06268b>  : 10 07                      dup.x32 sp(7)
	<rotation+277 @06268d>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @06268f>  : 73                         mul.f32
	<rotation+280 @062690>  : 10 0d                      dup.x32 sp(13)
	<rotation+282 @062692>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @062694>  : 73                         mul.f32
	<rotation+285 @062695>  : 71                         add.f32
	<rotation+286 @062696>  : 13 19                      set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:146: (13 bytes: <rotation+288 @062698> - <rotation+301 @0626a5>): .result.yy := yy + (xx + zz) * c;
	<rotation+288 @062698>  : 10 05                      dup.x32 sp(5)
	<rotation+290 @06269a>  : 10 09                      dup.x32 sp(9)
	<rotation+292 @06269c>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @06269e>  : 71                         add.f32
	<rotation+295 @06269f>  : 10 03                      dup.x32 sp(3)
	<rotation+297 @0626a1>  : 73                         mul.f32
	<rotation+298 @0626a2>  : 71                         add.f32
	<rotation+299 @0626a3>  : 13 1a                      set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:147: (13 bytes: <rotation+301 @0626a5> - <rotation+314 @0626b2>): .result.yz := yz * k - x * s;
	<rotation+301 @0626a5>  : 10 04                      dup.x32 sp(4)
	<rotation+303 @0626a7>  : 10 01                      dup.x32 sp(1)
	<rotation+305 @0626a9>  : 73                         mul.f32
	<rotation+306 @0626aa>  : 10 0f                      dup.x32 sp(15)
	<rotation+308 @0626ac>  : 10 04                      dup.x32 sp(4)
	<rotation+310 @0626ae>  : 73                         mul.f32
	<rotation+311 @0626af>  : 72                         sub.f32
	<rotation+312 @0626b0>  : 13 1b                      set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:148: (43 bytes: <rotation+314 @0626b2> - <rotation+357 @0626dd>): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+314 @0626b2>  : 10 0a                      dup.x32 sp(10)
	<rotation+316 @0626b4>  : 10 09                      dup.x32 sp(9)
	<rotation+318 @0626b6>  : 10 05                      dup.x32 sp(5)
	<rotation+320 @0626b8>  : 71                         add.f32
	<rotation+321 @0626b9>  : 73                         mul.f32
	<rotation+322 @0626ba>  : 10 0e                      dup.x32 sp(14)
	<rotation+324 @0626bc>  : 10 0d                      dup.x32 sp(13)
	<rotation+326 @0626be>  : 10 11                      dup.x32 sp(17)
	<rotation+328 @0626c0>  : 73                         mul.f32
	<rotation+329 @0626c1>  : 10 0c                      dup.x32 sp(12)
	<rotation+331 @0626c3>  : 10 10                      dup.x32 sp(16)
	<rotation+333 @0626c5>  : 73                         mul.f32
	<rotation+334 @0626c6>  : 71                         add.f32
	<rotation+335 @0626c7>  : 73                         mul.f32
	<rotation+336 @0626c8>  : 72                         sub.f32
	<rotation+337 @0626c9>  : 10 01                      dup.x32 sp(1)
	<rotation+339 @0626cb>  : 73                         mul.f32
	<rotation+340 @0626cc>  : 10 0a                      dup.x32 sp(10)
	<rotation+342 @0626ce>  : 10 10                      dup.x32 sp(16)
	<rotation+344 @0626d0>  : 73                         mul.f32
	<rotation+345 @0626d1>  : 10 0d                      dup.x32 sp(13)
	<rotation+347 @0626d3>  : 10 0f                      dup.x32 sp(15)
	<rotation+349 @0626d5>  : 73                         mul.f32
	<rotation+350 @0626d6>  : 72                         sub.f32
	<rotation+351 @0626d7>  : 10 04                      dup.x32 sp(4)
	<rotation+353 @0626d9>  : 73                         mul.f32
	<rotation+354 @0626da>  : 71                         add.f32
	<rotation+355 @0626db>  : 13 1c                      set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes: <rotation+357 @0626dd> - <rotation+370 @0626ea>): .result.zx := xz * k - y * s;
	<rotation+357 @0626dd>  : 10 06                      dup.x32 sp(6)
	<rotation+359 @0626df>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @0626e1>  : 73                         mul.f32
	<rotation+362 @0626e2>  : 10 0e                      dup.x32 sp(14)
	<rotation+364 @0626e4>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @0626e6>  : 73                         mul.f32
	<rotation+367 @0626e7>  : 72                         sub.f32
	<rotation+368 @0626e8>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:151: (13 bytes: <rotation+370 @0626ea> - <rotation+383 @0626f7>): .result.zy := yz * k + x * s;
	<rotation+370 @0626ea>  : 10 04                      dup.x32 sp(4)
	<rotation+372 @0626ec>  : 10 01                      dup.x32 sp(1)
	<rotation+374 @0626ee>  : 73                         mul.f32
	<rotation+375 @0626ef>  : 10 0f                      dup.x32 sp(15)
	<rotation+377 @0626f1>  : 10 04                      dup.x32 sp(4)
	<rotation+379 @0626f3>  : 73                         mul.f32
	<rotation+380 @0626f4>  : 71                         add.f32
	<rotation+381 @0626f5>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:152: (13 bytes: <rotation+383 @0626f7> - <rotation+396 @062704>): .result.zz := zz + (xx + yy) * c;
	<rotation+383 @0626f7>  : 10 03                      dup.x32 sp(3)
	<rotation+385 @0626f9>  : 10 09                      dup.x32 sp(9)
	<rotation+387 @0626fb>  : 10 07                      dup.x32 sp(7)
	<rotation+389 @0626fd>  : 71                         add.f32
	<rotation+390 @0626fe>  : 10 03                      dup.x32 sp(3)
	<rotation+392 @062700>  : 73                         mul.f32
	<rotation+393 @062701>  : 71                         add.f32
	<rotation+394 @062702>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:153: (43 bytes: <rotation+396 @062704> - <rotation+439 @06272f>): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+396 @062704>  : 10 09                      dup.x32 sp(9)
	<rotation+398 @062706>  : 10 09                      dup.x32 sp(9)
	<rotation+400 @062708>  : 10 07                      dup.x32 sp(7)
	<rotation+402 @06270a>  : 71                         add.f32
	<rotation+403 @06270b>  : 73                         mul.f32
	<rotation+404 @06270c>  : 10 0d                      dup.x32 sp(13)
	<rotation+406 @06270e>  : 10 0d                      dup.x32 sp(13)
	<rotation+408 @062710>  : 10 11                      dup.x32 sp(17)
	<rotation+410 @062712>  : 73                         mul.f32
	<rotation+411 @062713>  : 10 0d                      dup.x32 sp(13)
	<rotation+413 @062715>  : 10 11                      dup.x32 sp(17)
	<rotation+415 @062717>  : 73                         mul.f32
	<rotation+416 @062718>  : 71                         add.f32
	<rotation+417 @062719>  : 73                         mul.f32
	<rotation+418 @06271a>  : 72                         sub.f32
	<rotation+419 @06271b>  : 10 01                      dup.x32 sp(1)
	<rotation+421 @06271d>  : 73                         mul.f32
	<rotation+422 @06271e>  : 10 0c                      dup.x32 sp(12)
	<rotation+424 @062720>  : 10 0f                      dup.x32 sp(15)
	<rotation+426 @062722>  : 73                         mul.f32
	<rotation+427 @062723>  : 10 0c                      dup.x32 sp(12)
	<rotation+429 @062725>  : 10 11                      dup.x32 sp(17)
	<rotation+431 @062727>  : 73                         mul.f32
	<rotation+432 @062728>  : 72                         sub.f32
	<rotation+433 @062729>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @06272b>  : 73                         mul.f32
	<rotation+436 @06272c>  : 71                         add.f32
	<rotation+437 @06272d>  : 13 20                      set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:155: (10 bytes: <rotation+439 @06272f> - <rotation+449 @062739>): .result.w := vec4f(0, 0, 0, 1);
	<rotation+439 @06272f>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+444 @062734>  : 19                         load.z32
	<rotation+445 @062735>  : 19                         load.z32
	<rotation+446 @062736>  : 19                         load.z32
	<rotation+447 @062737>  : 15 24                      set.x128 sp(36)
	<rotation+449 @062739>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+453 @06273d>  : 03                         ret
.usages:
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 224
.offset: <@062740>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a rotation matrix'
.value: {
	xx: float32 := float32(direction.x * direction.x);
	yy: float32 := float32(direction.y * direction.y);
	zz: float32 := float32(direction.z * direction.z);
	xy: float32 := float32(direction.x * direction.y);
	xz: float32 := float32(direction.x * direction.z);
	yz: float32 := float32(direction.y * direction.z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	tmp: vec4f := mul(void(direction, s));
	return void(.result := {
			void(.result.xx := float32(float32(k * xx) + c));
			void(.result.xy := float32(float32(k * xy) - tmp.z));
			void(.result.xz := float32(float32(k * xz) + tmp.y));
			void(.result.xw := (0));
			void(.result.yx := float32(float32(k * xy) + tmp.z));
			void(.result.yy := float32(float32(k * yy) + c));
			void(.result.yz := float32(float32(k * yz) - tmp.x));
			void(.result.yw := (0));
			void(.result.zx := float32(float32(k * xz) - tmp.y));
			void(.result.zy := float32(float32(k * yz) + tmp.x));
			void(.result.zz := float32(float32(k * zz) + c));
			void(.result.zw := (0));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (224 bytes: <rotation @062740> - <rotation+224 @062820>)
	cmplStd/lib/math/Matrix4f.ci:161: (7 bytes: <rotation @062740> - <rotation+7 @062747>): xx: float32 := direction.x * direction.x
	<rotation @062740>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @062742>    : 28                         load.i32
	<rotation+3 @062743>    : 10 03                      dup.x32 sp(3)
	<rotation+5 @062745>    : 28                         load.i32
	<rotation+6 @062746>    : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:162: (15 bytes: <rotation+7 @062747> - <rotation+22 @062756>): yy: float32 := direction.y * direction.y
	<rotation+7 @062747>    : 10 03                      dup.x32 sp(3)
	<rotation+9 @062749>    : 0c 04 00 00                inc.i32(+4)
	<rotation+13 @06274d>   : 28                         load.i32
	<rotation+14 @06274e>   : 10 04                      dup.x32 sp(4)
	<rotation+16 @062750>   : 0c 04 00 00                inc.i32(+4)
	<rotation+20 @062754>   : 28                         load.i32
	<rotation+21 @062755>   : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:163: (15 bytes: <rotation+22 @062756> - <rotation+37 @062765>): zz: float32 := direction.z * direction.z
	<rotation+22 @062756>   : 10 04                      dup.x32 sp(4)
	<rotation+24 @062758>   : 0c 08 00 00                inc.i32(+8)
	<rotation+28 @06275c>   : 28                         load.i32
	<rotation+29 @06275d>   : 10 05                      dup.x32 sp(5)
	<rotation+31 @06275f>   : 0c 08 00 00                inc.i32(+8)
	<rotation+35 @062763>   : 28                         load.i32
	<rotation+36 @062764>   : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:164: (11 bytes: <rotation+37 @062765> - <rotation+48 @062770>): xy: float32 := direction.x * direction.y
	<rotation+37 @062765>   : 10 05                      dup.x32 sp(5)
	<rotation+39 @062767>   : 28                         load.i32
	<rotation+40 @062768>   : 10 06                      dup.x32 sp(6)
	<rotation+42 @06276a>   : 0c 04 00 00                inc.i32(+4)
	<rotation+46 @06276e>   : 28                         load.i32
	<rotation+47 @06276f>   : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:165: (11 bytes: <rotation+48 @062770> - <rotation+59 @06277b>): xz: float32 := direction.x * direction.z
	<rotation+48 @062770>   : 10 06                      dup.x32 sp(6)
	<rotation+50 @062772>   : 28                         load.i32
	<rotation+51 @062773>   : 10 07                      dup.x32 sp(7)
	<rotation+53 @062775>   : 0c 08 00 00                inc.i32(+8)
	<rotation+57 @062779>   : 28                         load.i32
	<rotation+58 @06277a>   : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:166: (15 bytes: <rotation+59 @06277b> - <rotation+74 @06278a>): yz: float32 := direction.y * direction.z
	<rotation+59 @06277b>   : 10 07                      dup.x32 sp(7)
	<rotation+61 @06277d>   : 0c 04 00 00                inc.i32(+4)
	<rotation+65 @062781>   : 28                         load.i32
	<rotation+66 @062782>   : 10 08                      dup.x32 sp(8)
	<rotation+68 @062784>   : 0c 08 00 00                inc.i32(+8)
	<rotation+72 @062788>   : 28                         load.i32
	<rotation+73 @062789>   : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:167: (6 bytes: <rotation+74 @06278a> - <rotation+80 @062790>): s: float32 := float32.sin(angle)
	<rotation+74 @06278a>   : 10 07                      dup.x32 sp(7)
	<rotation+76 @06278c>   : 01 22 00 00                nfc(34) ;float32.sin(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:168: (6 bytes: <rotation+80 @062790> - <rotation+86 @062796>): c: float32 := float32.cos(angle)
	<rotation+80 @062790>   : 10 08                      dup.x32 sp(8)
	<rotation+82 @062792>   : 01 23 00 00                nfc(35) ;float32.cos(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:169: (8 bytes: <rotation+86 @062796> - <rotation+94 @06279e>): k: float32 := (1) - c
	<rotation+86 @062796>   : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+91 @06279b>   : 10 01                      dup.x32 sp(1)
	<rotation+93 @06279d>   : 72                         sub.f32
	cmplStd/lib/math/Matrix4f.ci:170: (16 bytes: <rotation+94 @06279e> - <rotation+110 @0627ae>): tmp: vec4f := mul(direction, s)
	<rotation+94 @06279e>   : 10 0b                      dup.x32 sp(11)
	<rotation+96 @0627a0>   : 2a                         load.i128
	<rotation+97 @0627a1>   : 10 06                      dup.x32 sp(6)
	<rotation+99 @0627a3>   : 10 00                      dup.x32 sp(0)
	<rotation+101 @0627a5>  : 10 01                      dup.x32 sp(1)
	<rotation+103 @0627a7>  : 10 02                      dup.x32 sp(2)
	<rotation+105 @0627a9>  : 10 03                      dup.x32 sp(3)
	<rotation+107 @0627ab>  : 15 01                      set.x128 sp(1)
	<rotation+109 @0627ad>  : 93                         mul.v4f
	cmplStd/lib/math/Matrix4f.ci:172: (114 bytes: <rotation+110 @0627ae> - <rotation+224 @062820>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:173: (10 bytes: <rotation+110 @0627ae> - <rotation+120 @0627b8>): .result.xx := k * xx + c;
	<rotation+110 @0627ae>  : 10 04                      dup.x32 sp(4)
	<rotation+112 @0627b0>  : 10 0d                      dup.x32 sp(13)
	<rotation+114 @0627b2>  : 73                         mul.f32
	<rotation+115 @0627b3>  : 10 06                      dup.x32 sp(6)
	<rotation+117 @0627b5>  : 71                         add.f32
	<rotation+118 @0627b6>  : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:174: (10 bytes: <rotation+120 @0627b8> - <rotation+130 @0627c2>): .result.xy := k * xy - tmp.z;
	<rotation+120 @0627b8>  : 10 04                      dup.x32 sp(4)
	<rotation+122 @0627ba>  : 10 0a                      dup.x32 sp(10)
	<rotation+124 @0627bc>  : 73                         mul.f32
	<rotation+125 @0627bd>  : 10 03                      dup.x32 sp(3)
	<rotation+127 @0627bf>  : 72                         sub.f32
	<rotation+128 @0627c0>  : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:175: (10 bytes: <rotation+130 @0627c2> - <rotation+140 @0627cc>): .result.xz := k * xz + tmp.y;
	<rotation+130 @0627c2>  : 10 04                      dup.x32 sp(4)
	<rotation+132 @0627c4>  : 10 09                      dup.x32 sp(9)
	<rotation+134 @0627c6>  : 73                         mul.f32
	<rotation+135 @0627c7>  : 10 02                      dup.x32 sp(2)
	<rotation+137 @0627c9>  : 71                         add.f32
	<rotation+138 @0627ca>  : 13 13                      set.x32 sp(19)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <rotation+140 @0627cc> - <rotation+143 @0627cf>): .result.xw := (0);
	<rotation+140 @0627cc>  : 19                         load.z32
	<rotation+141 @0627cd>  : 13 14                      set.x32 sp(20)
	cmplStd/lib/math/Matrix4f.ci:178: (10 bytes: <rotation+143 @0627cf> - <rotation+153 @0627d9>): .result.yx := k * xy + tmp.z;
	<rotation+143 @0627cf>  : 10 04                      dup.x32 sp(4)
	<rotation+145 @0627d1>  : 10 0a                      dup.x32 sp(10)
	<rotation+147 @0627d3>  : 73                         mul.f32
	<rotation+148 @0627d4>  : 10 03                      dup.x32 sp(3)
	<rotation+150 @0627d6>  : 71                         add.f32
	<rotation+151 @0627d7>  : 13 15                      set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:179: (10 bytes: <rotation+153 @0627d9> - <rotation+163 @0627e3>): .result.yy := k * yy + c;
	<rotation+153 @0627d9>  : 10 04                      dup.x32 sp(4)
	<rotation+155 @0627db>  : 10 0c                      dup.x32 sp(12)
	<rotation+157 @0627dd>  : 73                         mul.f32
	<rotation+158 @0627de>  : 10 06                      dup.x32 sp(6)
	<rotation+160 @0627e0>  : 71                         add.f32
	<rotation+161 @0627e1>  : 13 16                      set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:180: (10 bytes: <rotation+163 @0627e3> - <rotation+173 @0627ed>): .result.yz := k * yz - tmp.x;
	<rotation+163 @0627e3>  : 10 04                      dup.x32 sp(4)
	<rotation+165 @0627e5>  : 10 08                      dup.x32 sp(8)
	<rotation+167 @0627e7>  : 73                         mul.f32
	<rotation+168 @0627e8>  : 10 01                      dup.x32 sp(1)
	<rotation+170 @0627ea>  : 72                         sub.f32
	<rotation+171 @0627eb>  : 13 17                      set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:181: (3 bytes: <rotation+173 @0627ed> - <rotation+176 @0627f0>): .result.yw := (0);
	<rotation+173 @0627ed>  : 19                         load.z32
	<rotation+174 @0627ee>  : 13 18                      set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:183: (10 bytes: <rotation+176 @0627f0> - <rotation+186 @0627fa>): .result.zx := k * xz - tmp.y;
	<rotation+176 @0627f0>  : 10 04                      dup.x32 sp(4)
	<rotation+178 @0627f2>  : 10 09                      dup.x32 sp(9)
	<rotation+180 @0627f4>  : 73                         mul.f32
	<rotation+181 @0627f5>  : 10 02                      dup.x32 sp(2)
	<rotation+183 @0627f7>  : 72                         sub.f32
	<rotation+184 @0627f8>  : 13 19                      set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:184: (10 bytes: <rotation+186 @0627fa> - <rotation+196 @062804>): .result.zy := k * yz + tmp.x;
	<rotation+186 @0627fa>  : 10 04                      dup.x32 sp(4)
	<rotation+188 @0627fc>  : 10 08                      dup.x32 sp(8)
	<rotation+190 @0627fe>  : 73                         mul.f32
	<rotation+191 @0627ff>  : 10 01                      dup.x32 sp(1)
	<rotation+193 @062801>  : 71                         add.f32
	<rotation+194 @062802>  : 13 1a                      set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:185: (10 bytes: <rotation+196 @062804> - <rotation+206 @06280e>): .result.zz := k * zz + c;
	<rotation+196 @062804>  : 10 04                      dup.x32 sp(4)
	<rotation+198 @062806>  : 10 0b                      dup.x32 sp(11)
	<rotation+200 @062808>  : 73                         mul.f32
	<rotation+201 @062809>  : 10 06                      dup.x32 sp(6)
	<rotation+203 @06280b>  : 71                         add.f32
	<rotation+204 @06280c>  : 13 1b                      set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:186: (3 bytes: <rotation+206 @06280e> - <rotation+209 @062811>): .result.zw := (0);
	<rotation+206 @06280e>  : 19                         load.z32
	<rotation+207 @06280f>  : 13 1c                      set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:188: (10 bytes: <rotation+209 @062811> - <rotation+219 @06281b>): .result.w := vec4f(0, 0, 0, 1);
	<rotation+209 @062811>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+214 @062816>  : 19                         load.z32
	<rotation+215 @062817>  : 19                         load.z32
	<rotation+216 @062818>  : 19                         load.z32
	<rotation+217 @062819>  : 15 20                      set.x128 sp(32)
	<rotation+219 @06281b>  : 09 cc ff ff                inc.sp(-52)
	<rotation+223 @06281f>  : 03                         ret
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.offset: <@062820>
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:193'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (88 bytes: <translation @062820> - <translation+88 @062878>)
	cmplStd/lib/math/Matrix4f.ci:194: (88 bytes: <translation @062820> - <translation+88 @062878>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:195: (7 bytes: <translation @062820> - <translation+7 @062827>): .result.xx := (1);
	<translation @062820>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @062825>    : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:195: (3 bytes: <translation+7 @062827> - <translation+10 @06282a>): .result.xy := (0);
	<translation+7 @062827>    : 19                         load.z32
	<translation+8 @062828>    : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:195: (3 bytes: <translation+10 @06282a> - <translation+13 @06282d>): .result.xz := (0);
	<translation+10 @06282a>   : 19                         load.z32
	<translation+11 @06282b>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:195: (8 bytes: <translation+13 @06282d> - <translation+21 @062835>): .result.xw := direction.x * amount;
	<translation+13 @06282d>   : 10 02                      dup.x32 sp(2)
	<translation+15 @06282f>   : 28                         load.i32
	<translation+16 @062830>   : 10 02                      dup.x32 sp(2)
	<translation+18 @062832>   : 73                         mul.f32
	<translation+19 @062833>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes: <translation+21 @062835> - <translation+24 @062838>): .result.yx := (0);
	<translation+21 @062835>   : 19                         load.z32
	<translation+22 @062836>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:196: (7 bytes: <translation+24 @062838> - <translation+31 @06283f>): .result.yy := (1);
	<translation+24 @062838>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @06283d>   : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes: <translation+31 @06283f> - <translation+34 @062842>): .result.yz := (0);
	<translation+31 @06283f>   : 19                         load.z32
	<translation+32 @062840>   : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:196: (12 bytes: <translation+34 @062842> - <translation+46 @06284e>): .result.yw := direction.y * amount;
	<translation+34 @062842>   : 10 02                      dup.x32 sp(2)
	<translation+36 @062844>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @062848>   : 28                         load.i32
	<translation+41 @062849>   : 10 02                      dup.x32 sp(2)
	<translation+43 @06284b>   : 73                         mul.f32
	<translation+44 @06284c>   : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:197: (3 bytes: <translation+46 @06284e> - <translation+49 @062851>): .result.zx := (0);
	<translation+46 @06284e>   : 19                         load.z32
	<translation+47 @06284f>   : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:197: (3 bytes: <translation+49 @062851> - <translation+52 @062854>): .result.zy := (0);
	<translation+49 @062851>   : 19                         load.z32
	<translation+50 @062852>   : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:197: (7 bytes: <translation+52 @062854> - <translation+59 @06285b>): .result.zz := (1);
	<translation+52 @062854>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @062859>   : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:197: (12 bytes: <translation+59 @06285b> - <translation+71 @062867>): .result.zw := direction.z * amount;
	<translation+59 @06285b>   : 10 02                      dup.x32 sp(2)
	<translation+61 @06285d>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @062861>   : 28                         load.i32
	<translation+66 @062862>   : 10 02                      dup.x32 sp(2)
	<translation+68 @062864>   : 73                         mul.f32
	<translation+69 @062865>   : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:198: (3 bytes: <translation+71 @062867> - <translation+74 @06286a>): .result.wx := (0);
	<translation+71 @062867>   : 19                         load.z32
	<translation+72 @062868>   : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:198: (3 bytes: <translation+74 @06286a> - <translation+77 @06286d>): .result.wy := (0);
	<translation+74 @06286a>   : 19                         load.z32
	<translation+75 @06286b>   : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:198: (3 bytes: <translation+77 @06286d> - <translation+80 @062870>): .result.wz := (0);
	<translation+77 @06286d>   : 19                         load.z32
	<translation+78 @06286e>   : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:198: (7 bytes: <translation+80 @062870> - <translation+87 @062877>): .result.ww := (1);
	<translation+80 @062870>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @062875>   : 13 13                      set.x32 sp(19)
	<translation+87 @062877>   : 03                         ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.offset: <@062878>
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:203'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (217 bytes: <scale @062878> - <scale+217 @062951>)
	cmplStd/lib/math/Matrix4f.ci:205: (217 bytes: <scale @062878> - <scale+217 @062951>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:206: (55 bytes: <scale @062878> - <scale+55 @0628af>): .result.xx := rcp(direction.x * amount);
	<scale @062878>      : 10 02                      dup.x32 sp(2)
	<scale+2 @06287a>    : 28                         load.i32
	<scale+3 @06287b>    : 10 02                      dup.x32 sp(2)
	<scale+5 @06287d>    : 73                         mul.f32
	<scale+6 @06287e>    : 10 00                      dup.x32 sp(0)
	<scale+8 @062880>    : 19                         load.z32
	<scale+9 @062881>    : 78                         clt.f32
	<scale+10 @062882>   : 06 0b 00 00                jz <scale+21 @06288d>
	<scale+14 @062886>   : 10 00                      dup.x32 sp(0)
	<scale+16 @062888>   : 70                         neg.f32
	<scale+17 @062889>   : 04 06 00 00                jmp <scale+23 @06288f>
	<scale+21 @06288d>   : 10 00                      dup.x32 sp(0)
	<scale+23 @06288f>   : 7d                         f32.2f64
	<scale+24 @062890>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @062899>   : 88                         clt.f64
	<scale+34 @06289a>   : 06 09 00 00                jz <scale+43 @0628a3>
	<scale+38 @06289e>   : 19                         load.z32
	<scale+39 @06289f>   : 04 0c 00 00                jmp <scale+51 @0628ab>
	<scale+43 @0628a3>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @0628a8>   : 10 01                      dup.x32 sp(1)
	<scale+50 @0628aa>   : 74                         div.f32
	<scale+51 @0628ab>   : 13 01                      set.x32 sp(1)
	<scale+53 @0628ad>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes: <scale+55 @0628af> - <scale+58 @0628b2>): .result.xy := (0);
	<scale+55 @0628af>   : 19                         load.z32
	<scale+56 @0628b0>   : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes: <scale+58 @0628b2> - <scale+61 @0628b5>): .result.xz := (0);
	<scale+58 @0628b2>   : 19                         load.z32
	<scale+59 @0628b3>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes: <scale+61 @0628b5> - <scale+64 @0628b8>): .result.xw := (0);
	<scale+61 @0628b5>   : 19                         load.z32
	<scale+62 @0628b6>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes: <scale+64 @0628b8> - <scale+67 @0628bb>): .result.yx := (0);
	<scale+64 @0628b8>   : 19                         load.z32
	<scale+65 @0628b9>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:207: (59 bytes: <scale+67 @0628bb> - <scale+126 @0628f6>): .result.yy := rcp(direction.y * amount);
	<scale+67 @0628bb>   : 10 02                      dup.x32 sp(2)
	<scale+69 @0628bd>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @0628c1>   : 28                         load.i32
	<scale+74 @0628c2>   : 10 02                      dup.x32 sp(2)
	<scale+76 @0628c4>   : 73                         mul.f32
	<scale+77 @0628c5>   : 10 00                      dup.x32 sp(0)
	<scale+79 @0628c7>   : 19                         load.z32
	<scale+80 @0628c8>   : 78                         clt.f32
	<scale+81 @0628c9>   : 06 0b 00 00                jz <scale+92 @0628d4>
	<scale+85 @0628cd>   : 10 00                      dup.x32 sp(0)
	<scale+87 @0628cf>   : 70                         neg.f32
	<scale+88 @0628d0>   : 04 06 00 00                jmp <scale+94 @0628d6>
	<scale+92 @0628d4>   : 10 00                      dup.x32 sp(0)
	<scale+94 @0628d6>   : 7d                         f32.2f64
	<scale+95 @0628d7>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @0628e0>  : 88                         clt.f64
	<scale+105 @0628e1>  : 06 09 00 00                jz <scale+114 @0628ea>
	<scale+109 @0628e5>  : 19                         load.z32
	<scale+110 @0628e6>  : 04 0c 00 00                jmp <scale+122 @0628f2>
	<scale+114 @0628ea>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @0628ef>  : 10 01                      dup.x32 sp(1)
	<scale+121 @0628f1>  : 74                         div.f32
	<scale+122 @0628f2>  : 13 01                      set.x32 sp(1)
	<scale+124 @0628f4>  : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes: <scale+126 @0628f6> - <scale+129 @0628f9>): .result.yz := (0);
	<scale+126 @0628f6>  : 19                         load.z32
	<scale+127 @0628f7>  : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes: <scale+129 @0628f9> - <scale+132 @0628fc>): .result.yw := (0);
	<scale+129 @0628f9>  : 19                         load.z32
	<scale+130 @0628fa>  : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:208: (3 bytes: <scale+132 @0628fc> - <scale+135 @0628ff>): .result.zx := (0);
	<scale+132 @0628fc>  : 19                         load.z32
	<scale+133 @0628fd>  : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:208: (3 bytes: <scale+135 @0628ff> - <scale+138 @062902>): .result.zy := (0);
	<scale+135 @0628ff>  : 19                         load.z32
	<scale+136 @062900>  : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:208: (59 bytes: <scale+138 @062902> - <scale+197 @06293d>): .result.zz := rcp(direction.z * amount);
	<scale+138 @062902>  : 10 02                      dup.x32 sp(2)
	<scale+140 @062904>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @062908>  : 28                         load.i32
	<scale+145 @062909>  : 10 02                      dup.x32 sp(2)
	<scale+147 @06290b>  : 73                         mul.f32
	<scale+148 @06290c>  : 10 00                      dup.x32 sp(0)
	<scale+150 @06290e>  : 19                         load.z32
	<scale+151 @06290f>  : 78                         clt.f32
	<scale+152 @062910>  : 06 0b 00 00                jz <scale+163 @06291b>
	<scale+156 @062914>  : 10 00                      dup.x32 sp(0)
	<scale+158 @062916>  : 70                         neg.f32
	<scale+159 @062917>  : 04 06 00 00                jmp <scale+165 @06291d>
	<scale+163 @06291b>  : 10 00                      dup.x32 sp(0)
	<scale+165 @06291d>  : 7d                         f32.2f64
	<scale+166 @06291e>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @062927>  : 88                         clt.f64
	<scale+176 @062928>  : 06 09 00 00                jz <scale+185 @062931>
	<scale+180 @06292c>  : 19                         load.z32
	<scale+181 @06292d>  : 04 0c 00 00                jmp <scale+193 @062939>
	<scale+185 @062931>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @062936>  : 10 01                      dup.x32 sp(1)
	<scale+192 @062938>  : 74                         div.f32
	<scale+193 @062939>  : 13 01                      set.x32 sp(1)
	<scale+195 @06293b>  : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:208: (3 bytes: <scale+197 @06293d> - <scale+200 @062940>): .result.zw := (0);
	<scale+197 @06293d>  : 19                         load.z32
	<scale+198 @06293e>  : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:209: (3 bytes: <scale+200 @062940> - <scale+203 @062943>): .result.wx := (0);
	<scale+200 @062940>  : 19                         load.z32
	<scale+201 @062941>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:209: (3 bytes: <scale+203 @062943> - <scale+206 @062946>): .result.wy := (0);
	<scale+203 @062943>  : 19                         load.z32
	<scale+204 @062944>  : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:209: (3 bytes: <scale+206 @062946> - <scale+209 @062949>): .result.wz := (0);
	<scale+206 @062946>  : 19                         load.z32
	<scale+207 @062947>  : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:209: (7 bytes: <scale+209 @062949> - <scale+216 @062950>): .result.ww := (1);
	<scale+209 @062949>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @06294e>  : 13 13                      set.x32 sp(19)
	<scale+216 @062950>  : 03                         ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@030e98>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@062958>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <vec2d @062958> - <vec2d+7 @06295f>)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes: <vec2d @062958> - <vec2d+7 @06295f>): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes: <vec2d @062958> - <vec2d+3 @06295b>): .result.x := x;
	<vec2d @062958>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes: <vec2d+3 @06295b> - <vec2d+6 @06295e>): .result.y := y;
	<vec2d+3 @06295b>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @06295e>    : 03                         ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), div.p2d)))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), min.p2d)))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), max.p2d)))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.offset: <@062960>
.name: 'length'
.file: 'cmplStd/lib/text/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <length @062960> - <length+38 @062986>)
	cmplStd/lib/text/string.ci:5: (16 bytes: <length @062960> - <length+16 @062970>): if ((str) == null)
	<length @062960>      : 10 01                      dup.x32 sp(1)
	<length+2 @062962>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @062967>    : 57                         ceq.i32
	<length+8 @062968>    : 06 08 00 00                jz <length+16 @062970>
	cmplStd/lib/text/string.ci:6: (4 bytes: <length+12 @06296c> - <length+16 @062970>): return .result := 0;
	<length+12 @06296c>   : 19                         load.z32
	<length+13 @06296d>   : 13 03                      set.x32 sp(3)
	<length+15 @06296f>   : 03                         ret
	cmplStd/lib/text/string.ci:8: (1 byte: <length+16 @062970> - <length+17 @062971>): result: int32 := 0
	<length+16 @062970>   : 19                         load.z32
	cmplStd/lib/text/string.ci:9: (18 bytes: <length+17 @062971> - <length+35 @062983>): for ( ; str[result]; result := result + 1)
	<length+17 @062971>   : 04 08 00 00                jmp <length+25 @062979>
	cmplStd/lib/text/string.ci:9: (4 bytes: <length+21 @062975> - <length+25 @062979>): result := result + 1
	<length+21 @062975>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:9: (10 bytes: <length+25 @062979> - <length+35 @062983>): str[result]
	<length+25 @062979>   : 10 02                      dup.x32 sp(2)
	<length+27 @06297b>   : 10 01                      dup.x32 sp(1)
	<length+29 @06297d>   : 51                         add.i32
	<length+30 @06297e>   : 26                         load.i8
	<length+31 @06297f>   : 05 f6 ff ff                jnz <length+21 @062975>
	cmplStd/lib/text/string.ci:11: (3 bytes: <length+35 @062983> - <length+38 @062986>): return .result := result;
	<length+35 @062983>   : 13 03                      set.x32 sp(3)
	<length+37 @062985>   : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:48: referenced as `length`
	cmplStd/lib/text/string.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@062988>
.name: 'indexOf'
.file: 'cmplStd/lib/text/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <indexOf @062988> - <indexOf+50 @0629ba>)
	cmplStd/lib/text/string.ci:16: (42 bytes: <indexOf @062988> - <indexOf+42 @0629b2>): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf @062988>      : 19                         load.z32
	<indexOf+1 @062989>    : 04 1b 00 00                jmp <indexOf+28 @0629a4>
	cmplStd/lib/text/string.ci:17: (19 bytes: <indexOf+5 @06298d> - <indexOf+24 @0629a0>): if (str[i] == chr)
	<indexOf+5 @06298d>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @06298f>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @062991>    : 51                         add.i32
	<indexOf+10 @062992>   : 26                         load.i8
	<indexOf+11 @062993>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @062997>   : 26                         load.i8
	<indexOf+16 @062998>   : 57                         ceq.i32
	<indexOf+17 @062999>   : 06 07 00 00                jz <indexOf+24 @0629a0>
	cmplStd/lib/text/string.ci:18: (3 bytes: <indexOf+21 @06299d> - <indexOf+24 @0629a0>): return .result := i;
	<indexOf+21 @06299d>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @06299f>   : 03                         ret
	cmplStd/lib/text/string.ci:16: (4 bytes: <indexOf+24 @0629a0> - <indexOf+28 @0629a4>): i := i + 1
	<indexOf+24 @0629a0>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:16: (10 bytes: <indexOf+28 @0629a4> - <indexOf+38 @0629ae>): str[i]
	<indexOf+28 @0629a4>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @0629a6>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @0629a8>   : 51                         add.i32
	<indexOf+33 @0629a9>   : 26                         load.i8
	<indexOf+34 @0629aa>   : 05 e3 ff ff                jnz <indexOf+5 @06298d>
	<indexOf+38 @0629ae>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:21: (8 bytes: <indexOf+42 @0629b2> - <indexOf+50 @0629ba>): return .result := -1;
	<indexOf+42 @0629b2>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @0629b7>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @0629b9>   : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:105: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@0629c0>
.name: 'lastIndexOf'
.file: 'cmplStd/lib/text/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <lastIndexOf @0629c0> - <lastIndexOf+50 @0629f2>)
	cmplStd/lib/text/string.ci:26: (5 bytes: <lastIndexOf @0629c0> - <lastIndexOf+5 @0629c5>): result: int32 := -1
	<lastIndexOf @0629c0>      : 1c ff ff ff ff             load.c32 -1
	cmplStd/lib/text/string.ci:27: (42 bytes: <lastIndexOf+5 @0629c5> - <lastIndexOf+47 @0629ef>): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+5 @0629c5>    : 19                         load.z32
	<lastIndexOf+6 @0629c6>    : 04 1b 00 00                jmp <lastIndexOf+33 @0629e1>
	cmplStd/lib/text/string.ci:28: (19 bytes: <lastIndexOf+10 @0629ca> - <lastIndexOf+29 @0629dd>): if (str[i] == chr)
	<lastIndexOf+10 @0629ca>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @0629cc>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @0629ce>   : 51                         add.i32
	<lastIndexOf+15 @0629cf>   : 26                         load.i8
	<lastIndexOf+16 @0629d0>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @0629d4>   : 26                         load.i8
	<lastIndexOf+21 @0629d5>   : 57                         ceq.i32
	<lastIndexOf+22 @0629d6>   : 06 07 00 00                jz <lastIndexOf+29 @0629dd>
	cmplStd/lib/text/string.ci:29: (3 bytes: <lastIndexOf+26 @0629da> - <lastIndexOf+29 @0629dd>): result := i;
	<lastIndexOf+26 @0629da>   : 16 01 00                   mov.x32 sp(1, 0)
	cmplStd/lib/text/string.ci:27: (4 bytes: <lastIndexOf+29 @0629dd> - <lastIndexOf+33 @0629e1>): i := i + 1
	<lastIndexOf+29 @0629dd>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:27: (10 bytes: <lastIndexOf+33 @0629e1> - <lastIndexOf+43 @0629eb>): str[i]
	<lastIndexOf+33 @0629e1>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @0629e3>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @0629e5>   : 51                         add.i32
	<lastIndexOf+38 @0629e6>   : 26                         load.i8
	<lastIndexOf+39 @0629e7>   : 05 e3 ff ff                jnz <lastIndexOf+10 @0629ca>
	<lastIndexOf+43 @0629eb>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:32: (3 bytes: <lastIndexOf+47 @0629ef> - <lastIndexOf+50 @0629f2>): return .result := result;
	<lastIndexOf+47 @0629ef>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @0629f1>   : 03                         ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.offset: <@0629f8>
.name: 'startsWith'
.file: 'cmplStd/lib/text/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <startsWith @0629f8> - <startsWith+73 @062a41>)
	cmplStd/lib/text/string.ci:37: (62 bytes: <startsWith @0629f8> - <startsWith+62 @062a36>): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith @0629f8>      : 19                         load.z32
	<startsWith+1 @0629f9>    : 04 2d 00 00                jmp <startsWith+46 @062a26>
	cmplStd/lib/text/string.ci:38: (37 bytes: <startsWith+5 @0629fd> - <startsWith+42 @062a22>): if (cmp(str[i], with[i]) != 0)
	<startsWith+5 @0629fd>    : 19                         load.z32
	<startsWith+6 @0629fe>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @062a00>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @062a02>   : 51                         add.i32
	<startsWith+11 @062a03>   : 26                         load.i8
	<startsWith+12 @062a04>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @062a06>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @062a08>   : 51                         add.i32
	<startsWith+17 @062a09>   : 26                         load.i8
	<startsWith+18 @062a0a>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @062a0c>   : 02                         call
	<startsWith+21 @062a0d>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @062a11>   : 19                         load.z32
	<startsWith+26 @062a12>   : 57                         ceq.i32
	<startsWith+27 @062a13>   : 05 0f 00 00                jnz <startsWith+42 @062a22>
	cmplStd/lib/text/string.ci:39: (11 bytes: <startsWith+31 @062a17> - <startsWith+42 @062a22>): return .result := false;
	<startsWith+31 @062a17>   : 19                         load.z32
	<startsWith+32 @062a18>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @062a1c>   : 2b                         store.i8
	<startsWith+37 @062a1d>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @062a21>   : 03                         ret
	cmplStd/lib/text/string.ci:37: (4 bytes: <startsWith+42 @062a22> - <startsWith+46 @062a26>): i := i + 1
	<startsWith+42 @062a22>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:37: (12 bytes: <startsWith+46 @062a26> - <startsWith+58 @062a32>): (with[i]) != 0
	<startsWith+46 @062a26>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @062a28>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @062a2a>   : 51                         add.i32
	<startsWith+51 @062a2b>   : 26                         load.i8
	<startsWith+52 @062a2c>   : 19                         load.z32
	<startsWith+53 @062a2d>   : 57                         ceq.i32
	<startsWith+54 @062a2e>   : 06 cf ff ff                jz <startsWith+5 @0629fd>
	<startsWith+58 @062a32>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:42: (11 bytes: <startsWith+62 @062a36> - <startsWith+73 @062a41>): return .result := true;
	<startsWith+62 @062a36>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @062a3b>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @062a3f>   : 2b                         store.i8
	<startsWith+72 @062a40>   : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:96: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.offset: <@062a48>
.name: 'endsWith'
.file: 'cmplStd/lib/text/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <endsWith @062a48> - <endsWith+126 @062ac6>)
	cmplStd/lib/text/string.ci:47: (13 bytes: <endsWith @062a48> - <endsWith+13 @062a55>): withLen: int32 := length(with)
	<endsWith @062a48>      : 19                         load.z32
	<endsWith+1 @062a49>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @062a4b>    : 1f 60 29 06 00             load.ref <@062960> ;length(str: char[*]): int32
	<endsWith+8 @062a50>    : 02                         call
	<endsWith+9 @062a51>    : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:48: (13 bytes: <endsWith+13 @062a55> - <endsWith+26 @062a62>): strLen: int32 := length(str)
	<endsWith+13 @062a55>   : 19                         load.z32
	<endsWith+14 @062a56>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @062a58>   : 1f 60 29 06 00             load.ref <@062960> ;length(str: char[*]): int32
	<endsWith+21 @062a5d>   : 02                         call
	<endsWith+22 @062a5e>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:49: (20 bytes: <endsWith+26 @062a62> - <endsWith+46 @062a76>): if (strLen < withLen)
	<endsWith+26 @062a62>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @062a64>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @062a66>   : 58                         clt.i32
	<endsWith+31 @062a67>   : 06 0f 00 00                jz <endsWith+46 @062a76>
	cmplStd/lib/text/string.ci:50: (11 bytes: <endsWith+35 @062a6b> - <endsWith+46 @062a76>): return .result := false;
	<endsWith+35 @062a6b>   : 19                         load.z32
	<endsWith+36 @062a6c>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @062a70>   : 2b                         store.i8
	<endsWith+41 @062a71>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @062a75>   : 03                         ret
	cmplStd/lib/text/string.ci:52: (65 bytes: <endsWith+46 @062a76> - <endsWith+111 @062ab7>): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+46 @062a76>   : 19                         load.z32
	<endsWith+47 @062a77>   : 04 33 00 00                jmp <endsWith+98 @062aaa>
	cmplStd/lib/text/string.ci:53: (43 bytes: <endsWith+51 @062a7b> - <endsWith+94 @062aa6>): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+51 @062a7b>   : 19                         load.z32
	<endsWith+52 @062a7c>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @062a7e>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @062a80>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @062a82>   : 52                         sub.i32
	<endsWith+59 @062a83>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @062a85>   : 51                         add.i32
	<endsWith+62 @062a86>   : 51                         add.i32
	<endsWith+63 @062a87>   : 26                         load.i8
	<endsWith+64 @062a88>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @062a8a>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @062a8c>   : 51                         add.i32
	<endsWith+69 @062a8d>   : 26                         load.i8
	<endsWith+70 @062a8e>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @062a90>   : 02                         call
	<endsWith+73 @062a91>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @062a95>   : 19                         load.z32
	<endsWith+78 @062a96>   : 57                         ceq.i32
	<endsWith+79 @062a97>   : 05 0f 00 00                jnz <endsWith+94 @062aa6>
	cmplStd/lib/text/string.ci:54: (11 bytes: <endsWith+83 @062a9b> - <endsWith+94 @062aa6>): return .result := false;
	<endsWith+83 @062a9b>   : 19                         load.z32
	<endsWith+84 @062a9c>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @062aa0>   : 2b                         store.i8
	<endsWith+89 @062aa1>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @062aa5>   : 03                         ret
	cmplStd/lib/text/string.ci:52: (4 bytes: <endsWith+94 @062aa6> - <endsWith+98 @062aaa>): i := i + 1
	<endsWith+94 @062aa6>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:52: (9 bytes: <endsWith+98 @062aaa> - <endsWith+107 @062ab3>): i < withLen
	<endsWith+98 @062aaa>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @062aac>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @062aae>  : 58                         clt.i32
	<endsWith+103 @062aaf>  : 05 cc ff ff                jnz <endsWith+51 @062a7b>
	<endsWith+107 @062ab3>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:57: (15 bytes: <endsWith+111 @062ab7> - <endsWith+126 @062ac6>): return .result := true;
	<endsWith+111 @062ab7>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @062abc>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @062ac0>  : 2b                         store.i8
	<endsWith+121 @062ac1>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @062ac5>  : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:98: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@062ac8>
.name: 'compare'
.file: 'cmplStd/lib/text/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, less or greater, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <compare @062ac8> - <compare+63 @062b07>)
	cmplStd/lib/text/string.ci:62: (1 byte: <compare @062ac8> - <compare+1 @062ac9>): result: int32 := 0
	<compare @062ac8>      : 19                         load.z32
	cmplStd/lib/text/string.ci:63: (59 bytes: <compare+1 @062ac9> - <compare+60 @062b04>): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+1 @062ac9>    : 19                         load.z32
	<compare+2 @062aca>    : 04 2e 00 00                jmp <compare+48 @062af8>
	cmplStd/lib/text/string.ci:64: (22 bytes: <compare+6 @062ace> - <compare+28 @062ae4>): result := cmp(str[i], with[i]);
	<compare+6 @062ace>    : 19                         load.z32
	<compare+7 @062acf>    : 10 06                      dup.x32 sp(6)
	<compare+9 @062ad1>    : 10 02                      dup.x32 sp(2)
	<compare+11 @062ad3>   : 51                         add.i32
	<compare+12 @062ad4>   : 26                         load.i8
	<compare+13 @062ad5>   : 10 06                      dup.x32 sp(6)
	<compare+15 @062ad7>   : 10 03                      dup.x32 sp(3)
	<compare+17 @062ad9>   : 51                         add.i32
	<compare+18 @062ada>   : 26                         load.i8
	<compare+19 @062adb>   : 10 06                      dup.x32 sp(6)
	<compare+21 @062add>   : 02                         call
	<compare+22 @062ade>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @062ae2>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/text/string.ci:65: (16 bytes: <compare+28 @062ae4> - <compare+44 @062af4>): if ((str[i]) == 0)
	<compare+28 @062ae4>   : 10 05                      dup.x32 sp(5)
	<compare+30 @062ae6>   : 10 01                      dup.x32 sp(1)
	<compare+32 @062ae8>   : 51                         add.i32
	<compare+33 @062ae9>   : 26                         load.i8
	<compare+34 @062aea>   : 19                         load.z32
	<compare+35 @062aeb>   : 57                         ceq.i32
	<compare+36 @062aec>   : 06 08 00 00                jz <compare+44 @062af4>
	cmplStd/lib/text/string.ci:66: (4 bytes: <compare+40 @062af0> - <compare+44 @062af4>): break;
	<compare+40 @062af0>   : 04 10 00 00                jmp <compare+56 @062b00>
	cmplStd/lib/text/string.ci:63: (4 bytes: <compare+44 @062af4> - <compare+48 @062af8>): i := i + 1
	<compare+44 @062af4>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:63: (8 bytes: <compare+48 @062af8> - <compare+56 @062b00>): result == 0
	<compare+48 @062af8>   : 10 01                      dup.x32 sp(1)
	<compare+50 @062afa>   : 19                         load.z32
	<compare+51 @062afb>   : 57                         ceq.i32
	<compare+52 @062afc>   : 05 d2 ff ff                jnz <compare+6 @062ace>
	<compare+56 @062b00>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:69: (3 bytes: <compare+60 @062b04> - <compare+63 @062b07>): return .result := result;
	<compare+60 @062b04>   : 13 05                      set.x32 sp(5)
	<compare+62 @062b06>   : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:102: referenced as `compare`
	cmplStd/lib/text/string.ci:100: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.offset: <@062b50>
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/text/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <ignCaseCmp @062b50> - <ignCaseCmp+36 @062b74>)
	cmplStd/lib/text/string.ci:84: (36 bytes: <ignCaseCmp @062b50> - <ignCaseCmp+36 @062b74>): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp @062b50>      : 19                         load.z32
	<ignCaseCmp+1 @062b51>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @062b55>    : 26                         load.i8
	<ignCaseCmp+6 @062b56>    : 1f 08 2b 06 00             load.ref <@062b08> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @062b5b>   : 02                         call
	<ignCaseCmp+12 @062b5c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @062b60>   : 19                         load.z32
	<ignCaseCmp+17 @062b61>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @062b65>   : 26                         load.i8
	<ignCaseCmp+22 @062b66>   : 1f 08 2b 06 00             load.ref <@062b08> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @062b6b>   : 02                         call
	<ignCaseCmp+28 @062b6c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @062b70>   : 52                         sub.i32
	<ignCaseCmp+33 @062b71>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @062b73>   : 03                         ret
.usages:
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.offset: <@062b78>
.name: 'caseCmp'
.file: 'cmplStd/lib/text/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <caseCmp @062b78> - <caseCmp+14 @062b86>)
	cmplStd/lib/text/string.ci:89: (14 bytes: <caseCmp @062b78> - <caseCmp+14 @062b86>): return .result := chr - with;
	<caseCmp @062b78>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @062b7c>    : 26                         load.i8
	<caseCmp+5 @062b7d>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @062b81>    : 26                         load.i8
	<caseCmp+10 @062b82>   : 52                         sub.i32
	<caseCmp+11 @062b83>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @062b85>   : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:102: referenced as `caseCmp`
	cmplStd/lib/text/string.ci:100: referenced as `caseCmp`
	cmplStd/lib/text/string.ci:98: referenced as `caseCmp`
	cmplStd/lib/text/string.ci:96: referenced as `caseCmp`
}
toHex(value: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toHex'
.file: 'cmplStd/lib/text/string.ci:93'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character'
.value: int32("0123456789abcdef"[int32(value & 15)])
.usages:
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'cmplStd/lib/text/string.ci:96'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if a string begins with a specified string, using case-sensitive comparison'
.value: startsWith(void(void(str, with), caseCmp))
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'cmplStd/lib/text/string.ci:98'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if a string ends in a specified string, using case-sensitive comparison'
.value: endsWith(void(void(str, with), caseCmp))
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'cmplStd/lib/text/string.ci:100'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if the two strings are equal, less or greater, using case-sensitive comparison'
.value: compare(void(void(str, with), caseCmp))
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'equals'
.file: 'cmplStd/lib/text/string.ci:102'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if the two strings are equal, using case-sensitive comparison'
.value: bool(compare(void(void(str, with), caseCmp)) == 0)
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'cmplStd/lib/text/string.ci:105'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	cmplStd/lib/text/string.ci:182: referenced as `contains`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@036d90>
.name: 'FormatFlags'
.file: 'cmplStd/lib/text/string.ci:119'
.field sign: char (size: 1, offs: <+0>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	cmplStd/lib/text/string.ci:295: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:291: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:258: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:257: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:255: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:252: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:249: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:246: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:243: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:230: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:229: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:226: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:223: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:220: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:217: referenced as `FormatFlags`
	cmplStd/lib/text/string.ci:154: referenced as `FormatFlags`
}
FormatFlags.sign: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+0>
.name: 'sign'
.file: 'cmplStd/lib/text/string.ci:121'
.owner: FormatFlags
.doc: 'forced show sign'
.value: 0
.usages:
	cmplStd/lib/text/string.ci:259: referenced as `sign`
	cmplStd/lib/text/string.ci:259: referenced as `sign`
	cmplStd/lib/text/string.ci:231: referenced as `sign`
	cmplStd/lib/text/string.ci:231: referenced as `sign`
	cmplStd/lib/text/string.ci:191: referenced as `sign`
	cmplStd/lib/text/string.ci:180: referenced as `sign`
	internal usages: 2
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'cmplStd/lib/text/string.ci:124'
.owner: FormatFlags
.doc: 'precision length'
.value: 0
.usages:
	cmplStd/lib/text/string.ci:279: referenced as `precision`
	cmplStd/lib/text/string.ci:277: referenced as `precision`
	cmplStd/lib/text/string.ci:260: referenced as `precision`
	cmplStd/lib/text/string.ci:262: referenced as `precision`
	cmplStd/lib/text/string.ci:232: referenced as `precision`
	cmplStd/lib/text/string.ci:232: referenced as `precision`
	internal usages: 2
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'cmplStd/lib/text/string.ci:127'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	cmplStd/lib/text/string.ci:261: referenced as `padChr`
	cmplStd/lib/text/string.ci:261: referenced as `padChr`
	cmplStd/lib/text/string.ci:234: referenced as `padChr`
	cmplStd/lib/text/string.ci:234: referenced as `padChr`
	cmplStd/lib/text/string.ci:174: referenced as `padChr`
	internal usages: 2
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'cmplStd/lib/text/string.ci:130'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/text/string.ci:265: referenced as `padLen`
	cmplStd/lib/text/string.ci:262: referenced as `padLen`
	cmplStd/lib/text/string.ci:262: referenced as `padLen`
	cmplStd/lib/text/string.ci:233: referenced as `padLen`
	cmplStd/lib/text/string.ci:233: referenced as `padLen`
	cmplStd/lib/text/string.ci:172: referenced as `padLen`
	internal usages: 2
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 119
.offset: <@062b88>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:134'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	if (bool((value) == null)) {
		return int32(.result := append(void(void(output, pos), "NULL")));
	}
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (119 bytes: <append @062b88> - <append+119 @062bff>)
	cmplStd/lib/text/string.ci:135: (35 bytes: <append @062b88> - <append+35 @062bab>): if ((value) == null)
	<append @062b88>      : 10 01                      dup.x32 sp(1)
	<append+2 @062b8a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+7 @062b8f>    : 57                         ceq.i32
	<append+8 @062b90>    : 06 1b 00 00                jz <append+35 @062bab>
	cmplStd/lib/text/string.ci:136: (23 bytes: <append+12 @062b94> - <append+35 @062bab>): return .result := append(output, pos, "NULL");
	<append+12 @062b94>   : 19                         load.z32
	<append+13 @062b95>   : 11 04                      dup.x64 sp(4)
	<append+15 @062b97>   : 10 05                      dup.x32 sp(5)
	<append+17 @062b99>   : 1f c6 2f 03 00             load.ref <@032fc6> ;"NULL"
	<append+22 @062b9e>   : 1f 88 2b 06 00             load.ref <@062b88> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+27 @062ba3>   : 02                         call
	<append+28 @062ba4>   : 09 f0 ff ff                inc.sp(-16)
	<append+32 @062ba8>   : 13 06                      set.x32 sp(6)
	<append+34 @062baa>   : 03                         ret
	cmplStd/lib/text/string.ci:138: (56 bytes: <append+35 @062bab> - <append+91 @062be3>): for (i: int32 := 0; value[i]; i := i + 1)
	<append+35 @062bab>   : 19                         load.z32
	<append+36 @062bac>   : 04 29 00 00                jmp <append+77 @062bd5>
	cmplStd/lib/text/string.ci:139: (13 bytes: <append+40 @062bb0> - <append+53 @062bbd>): if (pos >= (output.length))
	<append+40 @062bb0>   : 10 03                      dup.x32 sp(3)
	<append+42 @062bb2>   : 10 06                      dup.x32 sp(6)
	<append+44 @062bb4>   : 58                         clt.i32
	<append+45 @062bb5>   : 05 08 00 00                jnz <append+53 @062bbd>
	cmplStd/lib/text/string.ci:140: (4 bytes: <append+49 @062bb9> - <append+53 @062bbd>): break;
	<append+49 @062bb9>   : 04 26 00 00                jmp <append+87 @062bdf>
	cmplStd/lib/text/string.ci:142: (12 bytes: <append+53 @062bbd> - <append+65 @062bc9>): output[pos] := value[i];
	<append+53 @062bbd>   : 10 02                      dup.x32 sp(2)
	<append+55 @062bbf>   : 10 01                      dup.x32 sp(1)
	<append+57 @062bc1>   : 51                         add.i32
	<append+58 @062bc2>   : 26                         load.i8
	<append+59 @062bc3>   : 10 05                      dup.x32 sp(5)
	<append+61 @062bc5>   : 10 05                      dup.x32 sp(5)
	<append+63 @062bc7>   : 51                         add.i32
	<append+64 @062bc8>   : 2b                         store.i8
	cmplStd/lib/text/string.ci:143: (8 bytes: <append+65 @062bc9> - <append+73 @062bd1>): pos := pos + 1;
	<append+65 @062bc9>   : 10 03                      dup.x32 sp(3)
	<append+67 @062bcb>   : 0c 01 00 00                inc.i32(+1)
	<append+71 @062bcf>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/text/string.ci:138: (4 bytes: <append+73 @062bd1> - <append+77 @062bd5>): i := i + 1
	<append+73 @062bd1>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:138: (10 bytes: <append+77 @062bd5> - <append+87 @062bdf>): value[i]
	<append+77 @062bd5>   : 10 02                      dup.x32 sp(2)
	<append+79 @062bd7>   : 10 01                      dup.x32 sp(1)
	<append+81 @062bd9>   : 51                         add.i32
	<append+82 @062bda>   : 26                         load.i8
	<append+83 @062bdb>   : 05 d5 ff ff                jnz <append+40 @062bb0>
	<append+87 @062bdf>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:146: (17 bytes: <append+91 @062be3> - <append+108 @062bf4>): if (pos >= (output.length))
	<append+91 @062be3>   : 10 02                      dup.x32 sp(2)
	<append+93 @062be5>   : 10 05                      dup.x32 sp(5)
	<append+95 @062be7>   : 58                         clt.i32
	<append+96 @062be8>   : 05 0c 00 00                jnz <append+108 @062bf4>
	cmplStd/lib/text/string.ci:147: (8 bytes: <append+100 @062bec> - <append+108 @062bf4>): pos := (output.length - (1));
	<append+100 @062bec>  : 10 04                      dup.x32 sp(4)
	<append+102 @062bee>  : 0c ff ff ff                inc.i32(-1)
	<append+106 @062bf2>  : 13 03                      set.x32 sp(3)
	cmplStd/lib/text/string.ci:149: (7 bytes: <append+108 @062bf4> - <append+115 @062bfb>): output[pos] := (0);
	<append+108 @062bf4>  : 19                         load.z32
	<append+109 @062bf5>  : 10 04                      dup.x32 sp(4)
	<append+111 @062bf7>  : 10 04                      dup.x32 sp(4)
	<append+113 @062bf9>  : 51                         add.i32
	<append+114 @062bfa>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:150: (4 bytes: <append+115 @062bfb> - <append+119 @062bff>): return .result := pos;
	<append+115 @062bfb>  : 16 05 02                   mov.x32 sp(5, 2)
	<append+118 @062bfe>  : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:276: referenced as `append`
	cmplStd/lib/text/string.ci:136: referenced as `append`
}
append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 653
.offset: <@062c10>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:154'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param radix: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((format.sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := format.sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (653 bytes: <append @062c10> - <append+653 @062e9d>)
	cmplStd/lib/text/string.ci:158: (1 byte: <append @062c10> - <append+1 @062c11>): len: int32 := 0
	<append @062c10>      : 19                         load.z32
	cmplStd/lib/text/string.ci:159: (4 bytes: <append+1 @062c11> - <append+5 @062c15>): digits: char[80] := {...}
	<append+1 @062c11>    : 09 50 00 00                inc.sp(+80)
	cmplStd/lib/text/string.ci:161: (54 bytes: <append+5 @062c15> - <append+59 @062c4b>): assert(radix > 1, "radix is too small", radix);
	<append+5 @062c15>    : 10 19                      dup.x32 sp(25)
	<append+7 @062c17>    : 1c 01 00 00 00             load.c32 1
	<append+12 @062c1c>   : 59                         cgt.i32
	<append+13 @062c1d>   : 06 08 00 00                jz <append+21 @062c25>
	<append+17 @062c21>   : 04 2a 00 00                jmp <append+59 @062c4b>
	<append+21 @062c25>   : 1f b8 2a 03 00             load.ref <@032ab8> ;"cmplStd/lib/text/string.ci"
	<append+26 @062c2a>   : 1c a1 00 00 00             load.c32 161
	<append+31 @062c2f>   : 1c fe ff ff ff             load.c32 -2
	<append+36 @062c34>   : 1c 80 00 00 00             load.c32 128
	<append+41 @062c39>   : 1f 54 30 03 00             load.ref <@033054> ;"radix is too small"
	<append+46 @062c3e>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+51 @062c43>   : 0a 7c 00 00                load.sp(+124)
	<append+55 @062c47>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/text/string.ci:162: (53 bytes: <append+59 @062c4b> - <append+112 @062c80>): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+59 @062c4b>   : 10 19                      dup.x32 sp(25)
	<append+61 @062c4d>   : 20 0c 2c 06                load.m32 <@062c0c> ;append.radixDigits+4
	<append+65 @062c51>   : 58                         clt.i32
	<append+66 @062c52>   : 06 08 00 00                jz <append+74 @062c5a>
	<append+70 @062c56>   : 04 2a 00 00                jmp <append+112 @062c80>
	<append+74 @062c5a>   : 1f b8 2a 03 00             load.ref <@032ab8> ;"cmplStd/lib/text/string.ci"
	<append+79 @062c5f>   : 1c a2 00 00 00             load.c32 162
	<append+84 @062c64>   : 1c fe ff ff ff             load.c32 -2
	<append+89 @062c69>   : 1c 80 00 00 00             load.c32 128
	<append+94 @062c6e>   : 1f 67 30 03 00             load.ref <@033067> ;"radix is too big"
	<append+99 @062c73>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+104 @062c78>  : 0a 7c 00 00                load.sp(+124)
	<append+108 @062c7c>  : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/text/string.ci:165: (49 bytes: <append+112 @062c80> - <append+161 @062cb1>): for ( ; value > (0); value := value / (radix))
	<append+112 @062c80>  : 04 29 00 00                jmp <append+153 @062ca9>
	cmplStd/lib/text/string.ci:166: (29 bytes: <append+116 @062c84> - <append+145 @062ca1>): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+116 @062c84>  : 20 08 2c 06                load.m32 <@062c08> ;append.radixDigits
	<append+120 @062c88>  : 11 18                      dup.x64 sp(24)
	<append+122 @062c8a>  : 10 1c                      dup.x32 sp(28)
	<append+124 @062c8c>  : 5b                         i32.2i64
	<append+125 @062c8d>  : 45                         mod.u64
	<append+126 @062c8e>  : 6a                         i64.2i32
	<append+127 @062c8f>  : 51                         add.i32
	<append+128 @062c90>  : 26                         load.i8
	<append+129 @062c91>  : 0a 04 00 00                load.sp(+4)
	<append+133 @062c95>  : 10 16                      dup.x32 sp(22)
	<append+135 @062c97>  : 0c 01 00 00                inc.i32(+1)
	<append+139 @062c9b>  : 10 00                      dup.x32 sp(0)
	<append+141 @062c9d>  : 13 18                      set.x32 sp(24)
	<append+143 @062c9f>  : 51                         add.i32
	<append+144 @062ca0>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:165: (8 bytes: <append+145 @062ca1> - <append+153 @062ca9>): value := value / (radix)
	<append+145 @062ca1>  : 11 17                      dup.x64 sp(23)
	<append+147 @062ca3>  : 10 1b                      dup.x32 sp(27)
	<append+149 @062ca5>  : 5b                         i32.2i64
	<append+150 @062ca6>  : 44                         div.u64
	<append+151 @062ca7>  : 14 19                      set.x64 sp(25)
	cmplStd/lib/text/string.ci:165: (8 bytes: <append+153 @062ca9> - <append+161 @062cb1>): value > (0)
	<append+153 @062ca9>  : 11 17                      dup.x64 sp(23)
	<append+155 @062cab>  : 1a                         load.z64
	<append+156 @062cac>  : 49                         cgt.u64
	<append+157 @062cad>  : 05 d7 ff ff                jnz <append+116 @062c84>
	cmplStd/lib/text/string.ci:168: (29 bytes: <append+161 @062cb1> - <append+190 @062cce>): if (len == 0)
	<append+161 @062cb1>  : 10 14                      dup.x32 sp(20)
	<append+163 @062cb3>  : 19                         load.z32
	<append+164 @062cb4>  : 57                         ceq.i32
	<append+165 @062cb5>  : 06 19 00 00                jz <append+190 @062cce>
	cmplStd/lib/text/string.ci:169: (21 bytes: <append+169 @062cb9> - <append+190 @062cce>): digits[len := len + 1] := '0';
	<append+169 @062cb9>  : 1c 30 00 00 00             load.c32 48
	<append+174 @062cbe>  : 0a 04 00 00                load.sp(+4)
	<append+178 @062cc2>  : 10 16                      dup.x32 sp(22)
	<append+180 @062cc4>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @062cc8>  : 10 00                      dup.x32 sp(0)
	<append+186 @062cca>  : 13 18                      set.x32 sp(24)
	<append+188 @062ccc>  : 51                         add.i32
	<append+189 @062ccd>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:172: (10 bytes: <append+190 @062cce> - <append+200 @062cd8>): maxLen: int32 := format.padLen - len
	<append+190 @062cce>  : 10 16                      dup.x32 sp(22)
	<append+192 @062cd0>  : 0c 0c 00 00                inc.i32(+12)
	<append+196 @062cd4>  : 28                         load.i32
	<append+197 @062cd5>  : 10 15                      dup.x32 sp(21)
	<append+199 @062cd7>  : 52                         sub.i32
	cmplStd/lib/text/string.ci:174: (7 bytes: <append+200 @062cd8> - <append+207 @062cdf>): padChr: char := format.padChr
	<append+200 @062cd8>  : 10 17                      dup.x32 sp(23)
	<append+202 @062cda>  : 0c 08 00 00                inc.i32(+8)
	<append+206 @062cde>  : 26                         load.i8
	cmplStd/lib/text/string.ci:175: (21 bytes: <append+207 @062cdf> - <append+228 @062cf4>): if (padChr == '')
	<append+207 @062cdf>  : 0a 00 00 00                load.sp(+0)
	<append+211 @062ce3>  : 26                         load.i8
	<append+212 @062ce4>  : 19                         load.z32
	<append+213 @062ce5>  : 57                         ceq.i32
	<append+214 @062ce6>  : 06 0e 00 00                jz <append+228 @062cf4>
	cmplStd/lib/text/string.ci:176: (10 bytes: <append+218 @062cea> - <append+228 @062cf4>): padChr := ' ';
	<append+218 @062cea>  : 1c 20 00 00 00             load.c32 32
	<append+223 @062cef>  : 0a 04 00 00                load.sp(+4)
	<append+227 @062cf3>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:180: (203 bytes: <append+228 @062cf4> - <append+431 @062dbf>): if ((format.sign) != 0)
	<append+228 @062cf4>  : 10 18                      dup.x32 sp(24)
	<append+230 @062cf6>  : 26                         load.i8
	<append+231 @062cf7>  : 19                         load.z32
	<append+232 @062cf8>  : 57                         ceq.i32
	<append+233 @062cf9>  : 05 c6 00 00                jnz <append+431 @062dbf>
	cmplStd/lib/text/string.ci:181: (8 bytes: <append+237 @062cfd> - <append+245 @062d05>): maxLen := maxLen - 1;
	<append+237 @062cfd>  : 10 01                      dup.x32 sp(1)
	<append+239 @062cff>  : 0c ff ff ff                inc.i32(-1)
	<append+243 @062d03>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/text/string.ci:182: (117 bytes: <append+245 @062d05> - <append+362 @062d7a>): if (contains(whiteSpace, padChr))
	<append+245 @062d05>  : 19                         load.z32
	<append+246 @062d06>  : 20 00 2c 06                load.m32 <@062c00> ;append.whiteSpace
	<append+250 @062d0a>  : 0a 08 00 00                load.sp(+8)
	<append+254 @062d0e>  : 26                         load.i8
	<append+255 @062d0f>  : 1f 88 29 06 00             load.ref <@062988> ;indexOf(str: char[*], chr: char): int32
	<append+260 @062d14>  : 02                         call
	<append+261 @062d15>  : 09 f8 ff ff                inc.sp(-8)
	<append+265 @062d19>  : 19                         load.z32
	<append+266 @062d1a>  : 58                         clt.i32
	<append+267 @062d1b>  : 05 5f 00 00                jnz <append+362 @062d7a>
	cmplStd/lib/text/string.ci:184: (91 bytes: <append+271 @062d1f> - <append+362 @062d7a>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+271 @062d1f>  : 04 53 00 00                jmp <append+354 @062d72>
	cmplStd/lib/text/string.ci:185: (52 bytes: <append+275 @062d23> - <append+327 @062d57>): assert(pos < (output.length));
	<append+275 @062d23>  : 10 1c                      dup.x32 sp(28)
	<append+277 @062d25>  : 10 1f                      dup.x32 sp(31)
	<append+279 @062d27>  : 58                         clt.i32
	<append+280 @062d28>  : 06 08 00 00                jz <append+288 @062d30>
	<append+284 @062d2c>  : 04 2b 00 00                jmp <append+327 @062d57>
	<append+288 @062d30>  : 1f b8 2a 03 00             load.ref <@032ab8> ;"cmplStd/lib/text/string.ci"
	<append+293 @062d35>  : 1c b9 00 00 00             load.c32 185
	<append+298 @062d3a>  : 1c fe ff ff ff             load.c32 -2
	<append+303 @062d3f>  : 1c 80 00 00 00             load.c32 128
	<append+308 @062d44>  : 1f 08 f7 00 00             load.ref <@00f708> ;"assertion failed!"
	<append+313 @062d49>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+318 @062d4e>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+323 @062d53>  : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/text/string.ci:186: (11 bytes: <append+327 @062d57> - <append+338 @062d62>): output[pos] := padChr;
	<append+327 @062d57>  : 0a 00 00 00                load.sp(+0)
	<append+331 @062d5b>  : 26                         load.i8
	<append+332 @062d5c>  : 10 1e                      dup.x32 sp(30)
	<append+334 @062d5e>  : 10 1e                      dup.x32 sp(30)
	<append+336 @062d60>  : 51                         add.i32
	<append+337 @062d61>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:187: (8 bytes: <append+338 @062d62> - <append+346 @062d6a>): pos := pos + 1;
	<append+338 @062d62>  : 10 1c                      dup.x32 sp(28)
	<append+340 @062d64>  : 0c 01 00 00                inc.i32(+1)
	<append+344 @062d68>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/text/string.ci:184: (8 bytes: <append+346 @062d6a> - <append+354 @062d72>): maxLen := maxLen - 1
	<append+346 @062d6a>  : 10 01                      dup.x32 sp(1)
	<append+348 @062d6c>  : 0c ff ff ff                inc.i32(-1)
	<append+352 @062d70>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/text/string.ci:184: (8 bytes: <append+354 @062d72> - <append+362 @062d7a>): maxLen > 0
	<append+354 @062d72>  : 10 01                      dup.x32 sp(1)
	<append+356 @062d74>  : 19                         load.z32
	<append+357 @062d75>  : 59                         cgt.i32
	<append+358 @062d76>  : 05 ad ff ff                jnz <append+275 @062d23>
	cmplStd/lib/text/string.ci:190: (52 bytes: <append+362 @062d7a> - <append+414 @062dae>): assert(pos < (output.length));
	<append+362 @062d7a>  : 10 1c                      dup.x32 sp(28)
	<append+364 @062d7c>  : 10 1f                      dup.x32 sp(31)
	<append+366 @062d7e>  : 58                         clt.i32
	<append+367 @062d7f>  : 06 08 00 00                jz <append+375 @062d87>
	<append+371 @062d83>  : 04 2b 00 00                jmp <append+414 @062dae>
	<append+375 @062d87>  : 1f b8 2a 03 00             load.ref <@032ab8> ;"cmplStd/lib/text/string.ci"
	<append+380 @062d8c>  : 1c be 00 00 00             load.c32 190
	<append+385 @062d91>  : 1c fe ff ff ff             load.c32 -2
	<append+390 @062d96>  : 1c 80 00 00 00             load.c32 128
	<append+395 @062d9b>  : 1f 08 f7 00 00             load.ref <@00f708> ;"assertion failed!"
	<append+400 @062da0>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+405 @062da5>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+410 @062daa>  : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/text/string.ci:191: (9 bytes: <append+414 @062dae> - <append+423 @062db7>): output[pos] := format.sign;
	<append+414 @062dae>  : 10 18                      dup.x32 sp(24)
	<append+416 @062db0>  : 26                         load.i8
	<append+417 @062db1>  : 10 1e                      dup.x32 sp(30)
	<append+419 @062db3>  : 10 1e                      dup.x32 sp(30)
	<append+421 @062db5>  : 51                         add.i32
	<append+422 @062db6>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:192: (8 bytes: <append+423 @062db7> - <append+431 @062dbf>): pos := pos + 1;
	<append+423 @062db7>  : 10 1c                      dup.x32 sp(28)
	<append+425 @062db9>  : 0c 01 00 00                inc.i32(+1)
	<append+429 @062dbd>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/text/string.ci:196: (91 bytes: <append+431 @062dbf> - <append+522 @062e1a>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+431 @062dbf>  : 04 53 00 00                jmp <append+514 @062e12>
	cmplStd/lib/text/string.ci:197: (52 bytes: <append+435 @062dc3> - <append+487 @062df7>): assert(pos < (output.length));
	<append+435 @062dc3>  : 10 1c                      dup.x32 sp(28)
	<append+437 @062dc5>  : 10 1f                      dup.x32 sp(31)
	<append+439 @062dc7>  : 58                         clt.i32
	<append+440 @062dc8>  : 06 08 00 00                jz <append+448 @062dd0>
	<append+444 @062dcc>  : 04 2b 00 00                jmp <append+487 @062df7>
	<append+448 @062dd0>  : 1f b8 2a 03 00             load.ref <@032ab8> ;"cmplStd/lib/text/string.ci"
	<append+453 @062dd5>  : 1c c5 00 00 00             load.c32 197
	<append+458 @062dda>  : 1c fe ff ff ff             load.c32 -2
	<append+463 @062ddf>  : 1c 80 00 00 00             load.c32 128
	<append+468 @062de4>  : 1f 08 f7 00 00             load.ref <@00f708> ;"assertion failed!"
	<append+473 @062de9>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+478 @062dee>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+483 @062df3>  : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/text/string.ci:198: (11 bytes: <append+487 @062df7> - <append+498 @062e02>): output[pos] := padChr;
	<append+487 @062df7>  : 0a 00 00 00                load.sp(+0)
	<append+491 @062dfb>  : 26                         load.i8
	<append+492 @062dfc>  : 10 1e                      dup.x32 sp(30)
	<append+494 @062dfe>  : 10 1e                      dup.x32 sp(30)
	<append+496 @062e00>  : 51                         add.i32
	<append+497 @062e01>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:199: (8 bytes: <append+498 @062e02> - <append+506 @062e0a>): pos := pos + 1;
	<append+498 @062e02>  : 10 1c                      dup.x32 sp(28)
	<append+500 @062e04>  : 0c 01 00 00                inc.i32(+1)
	<append+504 @062e08>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/text/string.ci:196: (8 bytes: <append+506 @062e0a> - <append+514 @062e12>): maxLen := maxLen - 1
	<append+506 @062e0a>  : 10 01                      dup.x32 sp(1)
	<append+508 @062e0c>  : 0c ff ff ff                inc.i32(-1)
	<append+512 @062e10>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/text/string.ci:196: (8 bytes: <append+514 @062e12> - <append+522 @062e1a>): maxLen > 0
	<append+514 @062e12>  : 10 01                      dup.x32 sp(1)
	<append+516 @062e14>  : 19                         load.z32
	<append+517 @062e15>  : 59                         cgt.i32
	<append+518 @062e16>  : 05 ad ff ff                jnz <append+435 @062dc3>
	cmplStd/lib/text/string.ci:203: (99 bytes: <append+522 @062e1a> - <append+621 @062e7d>): for (i: int32 := 0; i < len; i := i + 1)
	<append+522 @062e1a>  : 19                         load.z32
	<append+523 @062e1b>  : 04 55 00 00                jmp <append+608 @062e70>
	cmplStd/lib/text/string.ci:204: (52 bytes: <append+527 @062e1f> - <append+579 @062e53>): assert(i < (output.length));
	<append+527 @062e1f>  : 10 00                      dup.x32 sp(0)
	<append+529 @062e21>  : 10 20                      dup.x32 sp(32)
	<append+531 @062e23>  : 58                         clt.i32
	<append+532 @062e24>  : 06 08 00 00                jz <append+540 @062e2c>
	<append+536 @062e28>  : 04 2b 00 00                jmp <append+579 @062e53>
	<append+540 @062e2c>  : 1f b8 2a 03 00             load.ref <@032ab8> ;"cmplStd/lib/text/string.ci"
	<append+545 @062e31>  : 1c cc 00 00 00             load.c32 204
	<append+550 @062e36>  : 1c fe ff ff ff             load.c32 -2
	<append+555 @062e3b>  : 1c 80 00 00 00             load.c32 128
	<append+560 @062e40>  : 1f 08 f7 00 00             load.ref <@00f708> ;"assertion failed!"
	<append+565 @062e45>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+570 @062e4a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+575 @062e4f>  : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/text/string.ci:205: (17 bytes: <append+579 @062e53> - <append+596 @062e64>): output[pos] := digits[len - i];
	<append+579 @062e53>  : 0a 0c 00 00                load.sp(+12)
	<append+583 @062e57>  : 10 18                      dup.x32 sp(24)
	<append+585 @062e59>  : 10 02                      dup.x32 sp(2)
	<append+587 @062e5b>  : 52                         sub.i32
	<append+588 @062e5c>  : 51                         add.i32
	<append+589 @062e5d>  : 26                         load.i8
	<append+590 @062e5e>  : 10 1f                      dup.x32 sp(31)
	<append+592 @062e60>  : 10 1f                      dup.x32 sp(31)
	<append+594 @062e62>  : 51                         add.i32
	<append+595 @062e63>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:206: (8 bytes: <append+596 @062e64> - <append+604 @062e6c>): pos := pos + 1;
	<append+596 @062e64>  : 10 1d                      dup.x32 sp(29)
	<append+598 @062e66>  : 0c 01 00 00                inc.i32(+1)
	<append+602 @062e6a>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/text/string.ci:203: (4 bytes: <append+604 @062e6c> - <append+608 @062e70>): i := i + 1
	<append+604 @062e6c>  : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:203: (9 bytes: <append+608 @062e70> - <append+617 @062e79>): i < len
	<append+608 @062e70>  : 10 00                      dup.x32 sp(0)
	<append+610 @062e72>  : 10 18                      dup.x32 sp(24)
	<append+612 @062e74>  : 58                         clt.i32
	<append+613 @062e75>  : 05 aa ff ff                jnz <append+527 @062e1f>
	<append+617 @062e79>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:209: (17 bytes: <append+621 @062e7d> - <append+638 @062e8e>): if (pos >= (output.length))
	<append+621 @062e7d>  : 10 1c                      dup.x32 sp(28)
	<append+623 @062e7f>  : 10 1f                      dup.x32 sp(31)
	<append+625 @062e81>  : 58                         clt.i32
	<append+626 @062e82>  : 05 0c 00 00                jnz <append+638 @062e8e>
	cmplStd/lib/text/string.ci:210: (8 bytes: <append+630 @062e86> - <append+638 @062e8e>): pos := (output.length - (1));
	<append+630 @062e86>  : 10 1e                      dup.x32 sp(30)
	<append+632 @062e88>  : 0c ff ff ff                inc.i32(-1)
	<append+636 @062e8c>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/text/string.ci:212: (7 bytes: <append+638 @062e8e> - <append+645 @062e95>): output[pos] := (0);
	<append+638 @062e8e>  : 19                         load.z32
	<append+639 @062e8f>  : 10 1e                      dup.x32 sp(30)
	<append+641 @062e91>  : 10 1e                      dup.x32 sp(30)
	<append+643 @062e93>  : 51                         add.i32
	<append+644 @062e94>  : 2b                         store.i8
	cmplStd/lib/text/string.ci:213: (8 bytes: <append+645 @062e95> - <append+653 @062e9d>): return .result := pos;
	<append+645 @062e95>  : 16 1f 1c                   mov.x32 sp(31, 28)
	<append+648 @062e98>  : 09 a4 ff ff                inc.sp(-92)
	<append+652 @062e9c>  : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:239: referenced as `append`
	cmplStd/lib/text/string.ci:226: referenced as `append`
	cmplStd/lib/text/string.ci:223: referenced as `append`
	cmplStd/lib/text/string.ci:220: referenced as `append`
	cmplStd/lib/text/string.ci:217: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:217'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), uint64(value)), format))
.usages:
	cmplStd/lib/text/string.ci:285: referenced as `append`
	cmplStd/lib/text/string.ci:268: referenced as `append`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:220'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:223'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:226'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 102
.offset: <@062ea0>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:229'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param radix: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param value: int64 (size: 8, offs: <+28>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	signedFormat: FormatFlags := {
		void(signedFormat.sign := bool(value < (0)) ? '-' : format.sign);
		void(signedFormat.precision := format.precision);
		void(signedFormat.padLen := format.padLen);
		void(signedFormat.padChr := format.padChr);
	};
	if (bool(value < (0))) {
		int64(value := int64(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), radix), uint64(value)), signedFormat)));
}
.instructions: (102 bytes: <append @062ea0> - <append+102 @062f06>)
	cmplStd/lib/text/string.ci:230: (59 bytes: <append @062ea0> - <append+59 @062edb>): signedFormat: FormatFlags := {...}
	<append @062ea0>      : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/text/string.ci:231: (25 bytes: <append+4 @062ea4> - <append+29 @062ebd>): signedFormat.sign := value < (0) ? '-' : format.sign;
	<append+4 @062ea4>    : 11 06                      dup.x64 sp(6)
	<append+6 @062ea6>    : 1a                         load.z64
	<append+7 @062ea7>    : 68                         clt.i64
	<append+8 @062ea8>    : 06 0d 00 00                jz <append+21 @062eb5>
	<append+12 @062eac>   : 1c 2d 00 00 00             load.c32 45
	<append+17 @062eb1>   : 04 07 00 00                jmp <append+24 @062eb8>
	<append+21 @062eb5>   : 10 05                      dup.x32 sp(5)
	<append+23 @062eb7>   : 26                         load.i8
	<append+24 @062eb8>   : 0a 04 00 00                load.sp(+4)
	<append+28 @062ebc>   : 2b                         store.i8
	cmplStd/lib/text/string.ci:232: (9 bytes: <append+29 @062ebd> - <append+38 @062ec6>): signedFormat.precision := format.precision;
	<append+29 @062ebd>   : 10 05                      dup.x32 sp(5)
	<append+31 @062ebf>   : 0c 04 00 00                inc.i32(+4)
	<append+35 @062ec3>   : 28                         load.i32
	<append+36 @062ec4>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/text/string.ci:233: (9 bytes: <append+38 @062ec6> - <append+47 @062ecf>): signedFormat.padLen := format.padLen;
	<append+38 @062ec6>   : 10 05                      dup.x32 sp(5)
	<append+40 @062ec8>   : 0c 0c 00 00                inc.i32(+12)
	<append+44 @062ecc>   : 28                         load.i32
	<append+45 @062ecd>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/text/string.ci:234: (12 bytes: <append+47 @062ecf> - <append+59 @062edb>): signedFormat.padChr := format.padChr;
	<append+47 @062ecf>   : 10 05                      dup.x32 sp(5)
	<append+49 @062ed1>   : 0c 08 00 00                inc.i32(+8)
	<append+53 @062ed5>   : 26                         load.i8
	<append+54 @062ed6>   : 0a 0c 00 00                load.sp(+12)
	<append+58 @062eda>   : 2b                         store.i8
	cmplStd/lib/text/string.ci:236: (13 bytes: <append+59 @062edb> - <append+72 @062ee8>): if (value < (0))
	<append+59 @062edb>   : 11 06                      dup.x64 sp(6)
	<append+61 @062edd>   : 1a                         load.z64
	<append+62 @062ede>   : 68                         clt.i64
	<append+63 @062edf>   : 06 09 00 00                jz <append+72 @062ee8>
	cmplStd/lib/text/string.ci:237: (5 bytes: <append+67 @062ee3> - <append+72 @062ee8>): value := -value;
	<append+67 @062ee3>   : 11 06                      dup.x64 sp(6)
	<append+69 @062ee5>   : 60                         neg.i64
	<append+70 @062ee6>   : 14 08                      set.x64 sp(8)
	cmplStd/lib/text/string.ci:239: (30 bytes: <append+72 @062ee8> - <append+102 @062f06>): return .result := append(output, pos, radix, uint64(value), signedFormat);
	<append+72 @062ee8>   : 19                         load.z32
	<append+73 @062ee9>   : 11 0b                      dup.x64 sp(11)
	<append+75 @062eeb>   : 10 0c                      dup.x32 sp(12)
	<append+77 @062eed>   : 10 0c                      dup.x32 sp(12)
	<append+79 @062eef>   : 11 0b                      dup.x64 sp(11)
	<append+81 @062ef1>   : 0a 1c 00 00                load.sp(+28)
	<append+85 @062ef5>   : 1f 10 2c 06 00             load.ref <@062c10> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+90 @062efa>   : 02                         call
	<append+91 @062efb>   : 09 e4 ff ff                inc.sp(-28)
	<append+95 @062eff>   : 13 0d                      set.x32 sp(13)
	<append+97 @062f01>   : 09 f0 ff ff                inc.sp(-16)
	<append+101 @062f05>  : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:252: referenced as `append`
	cmplStd/lib/text/string.ci:249: referenced as `append`
	cmplStd/lib/text/string.ci:246: referenced as `append`
	cmplStd/lib/text/string.ci:243: referenced as `append`
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:243'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+20>, cast: i64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), int64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:246'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+16>, cast: i32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), int64(value)), format))
.usages:
	cmplStd/lib/text/string.ci:296: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:249'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+16>, cast: i32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), int64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:252'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+16>, cast: i32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 10), int64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 402
.offset: <@062f20>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:255'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	static const formatDec: FormatFlags := {
		void(formatDec.sign := (0));
		void(formatDec.precision := 0);
		void(formatDec.padChr := (0));
		void(formatDec.padLen := 0);
	};
	formatInt: FormatFlags := {
		void(formatInt.sign := bool(value < (0)) ? '-' : format.sign);
		void(formatInt.precision := 10);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(int32(format.padLen - format.precision) - 1));
	};
	end: int32 := Math.min(void(int32(uint32(output.length - (1))), int32(pos + format.padLen)));
	fraction: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(pos, uint64(int64(value))), formatInt))));
	static const eps: float64 := 0.000010;
	if (bool(bool(fraction < eps) && bool(pos >= end))) {
		return int32(.result := pos);
	}
	int32(pos := append(void(output, void(pos, "."))));
	max: int32 := Math.min(void(int32(uint32(output.length - (1))), int32(pos + format.precision)));
	if (bool(format.precision == 0)) {
		int32(max := (uint32(output.length - (1))));
	}
	for ( ; bool((bool(bool(fraction > eps) && bool(pos < max))) || bool(pos < end)); ) {
		float64(fraction := Math.modf(void(float64(fraction * (10)), float64(&value))));
		int32(pos := append(void(output, void(void(pos, uint64(int64(value))), formatDec))));
	}
	return int32(.result := pos);
}
.instructions: (402 bytes: <append @062f20> - <append+402 @0630b2>)
	cmplStd/lib/text/string.ci:258: (69 bytes: <append @062f20> - <append+69 @062f65>): formatInt: FormatFlags := {...}
	<append @062f20>      : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/text/string.ci:259: (25 bytes: <append+4 @062f24> - <append+29 @062f3d>): formatInt.sign := value < (0) ? '-' : format.sign;
	<append+4 @062f24>    : 11 06                      dup.x64 sp(6)
	<append+6 @062f26>    : 1a                         load.z64
	<append+7 @062f27>    : 88                         clt.f64
	<append+8 @062f28>    : 06 0d 00 00                jz <append+21 @062f35>
	<append+12 @062f2c>   : 1c 2d 00 00 00             load.c32 45
	<append+17 @062f31>   : 04 07 00 00                jmp <append+24 @062f38>
	<append+21 @062f35>   : 10 05                      dup.x32 sp(5)
	<append+23 @062f37>   : 26                         load.i8
	<append+24 @062f38>   : 0a 04 00 00                load.sp(+4)
	<append+28 @062f3c>   : 2b                         store.i8
	cmplStd/lib/text/string.ci:260: (7 bytes: <append+29 @062f3d> - <append+36 @062f44>): formatInt.precision := 10;
	<append+29 @062f3d>   : 1c 0a 00 00 00             load.c32 10
	<append+34 @062f42>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/text/string.ci:261: (12 bytes: <append+36 @062f44> - <append+48 @062f50>): formatInt.padChr := format.padChr;
	<append+36 @062f44>   : 10 05                      dup.x32 sp(5)
	<append+38 @062f46>   : 0c 08 00 00                inc.i32(+8)
	<append+42 @062f4a>   : 26                         load.i8
	<append+43 @062f4b>   : 0a 0c 00 00                load.sp(+12)
	<append+47 @062f4f>   : 2b                         store.i8
	cmplStd/lib/text/string.ci:262: (21 bytes: <append+48 @062f50> - <append+69 @062f65>): formatInt.padLen := format.padLen - format.precision - 1;
	<append+48 @062f50>   : 10 05                      dup.x32 sp(5)
	<append+50 @062f52>   : 0c 0c 00 00                inc.i32(+12)
	<append+54 @062f56>   : 28                         load.i32
	<append+55 @062f57>   : 10 06                      dup.x32 sp(6)
	<append+57 @062f59>   : 0c 04 00 00                inc.i32(+4)
	<append+61 @062f5d>   : 28                         load.i32
	<append+62 @062f5e>   : 52                         sub.i32
	<append+63 @062f5f>   : 0c ff ff ff                inc.i32(-1)
	<append+67 @062f63>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/text/string.ci:265: (39 bytes: <append+69 @062f65> - <append+108 @062f8c>): end: int32 := Math.min(int32(output.length - (1)), pos + format.padLen)
	<append+69 @062f65>   : 10 0a                      dup.x32 sp(10)
	<append+71 @062f67>   : 0c ff ff ff                inc.i32(-1)
	<append+75 @062f6b>   : 10 09                      dup.x32 sp(9)
	<append+77 @062f6d>   : 10 07                      dup.x32 sp(7)
	<append+79 @062f6f>   : 0c 0c 00 00                inc.i32(+12)
	<append+83 @062f73>   : 28                         load.i32
	<append+84 @062f74>   : 51                         add.i32
	<append+85 @062f75>   : 10 01                      dup.x32 sp(1)
	<append+87 @062f77>   : 10 01                      dup.x32 sp(1)
	<append+89 @062f79>   : 58                         clt.i32
	<append+90 @062f7a>   : 06 0a 00 00                jz <append+100 @062f84>
	<append+94 @062f7e>   : 10 01                      dup.x32 sp(1)
	<append+96 @062f80>   : 04 06 00 00                jmp <append+102 @062f86>
	<append+100 @062f84>  : 10 00                      dup.x32 sp(0)
	<append+102 @062f86>  : 13 02                      set.x32 sp(2)
	<append+104 @062f88>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:267: (36 bytes: <append+108 @062f8c> - <append+144 @062fb0>): fraction: float64 := Math.modf(Math.abs(value), &value)
	<append+108 @062f8c>  : 1a                         load.z64
	<append+109 @062f8d>  : 11 09                      dup.x64 sp(9)
	<append+111 @062f8f>  : 11 00                      dup.x64 sp(0)
	<append+113 @062f91>  : 1a                         load.z64
	<append+114 @062f92>  : 88                         clt.f64
	<append+115 @062f93>  : 06 0b 00 00                jz <append+126 @062f9e>
	<append+119 @062f97>  : 11 00                      dup.x64 sp(0)
	<append+121 @062f99>  : 80                         neg.f64
	<append+122 @062f9a>  : 04 06 00 00                jmp <append+128 @062fa0>
	<append+126 @062f9e>  : 11 00                      dup.x64 sp(0)
	<append+128 @062fa0>  : 14 02                      set.x64 sp(2)
	<append+130 @062fa2>  : 0a 2c 00 00                load.sp(+44)
	<append+134 @062fa6>  : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<append+139 @062fab>  : 02                         call
	<append+140 @062fac>  : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/text/string.ci:268: (29 bytes: <append+144 @062fb0> - <append+173 @062fcd>): pos := append(output, pos, uint64(int64(value)), formatInt);
	<append+144 @062fb0>  : 19                         load.z32
	<append+145 @062fb1>  : 11 0d                      dup.x64 sp(13)
	<append+147 @062fb3>  : 10 0e                      dup.x32 sp(14)
	<append+149 @062fb5>  : 1c 0a 00 00 00             load.c32 10
	<append+154 @062fba>  : 11 0e                      dup.x64 sp(14)
	<append+156 @062fbc>  : 8b                         f64.2i64
	<append+157 @062fbd>  : 0a 28 00 00                load.sp(+40)
	<append+161 @062fc1>  : 1f 10 2c 06 00             load.ref <@062c10> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+166 @062fc6>  : 02                         call
	<append+167 @062fc7>  : 09 e4 ff ff                inc.sp(-28)
	<append+171 @062fcb>  : 13 0c                      set.x32 sp(12)
	cmplStd/lib/text/string.ci:271: (35 bytes: <append+173 @062fcd> - <append+208 @062ff0>): if (fraction < eps && pos >= end)
	<append+173 @062fcd>  : 11 00                      dup.x64 sp(0)
	<append+175 @062fcf>  : 21 18 2f 06                load.m64 <@062f18> ;append.eps
	<append+179 @062fd3>  : 88                         clt.f64
	<append+180 @062fd4>  : 10 00                      dup.x32 sp(0)
	<append+182 @062fd6>  : 06 0e 00 00                jz <append+196 @062fe4>
	<append+186 @062fda>  : 09 fc ff ff                inc.sp(-4)
	<append+190 @062fde>  : 10 0b                      dup.x32 sp(11)
	<append+192 @062fe0>  : 10 03                      dup.x32 sp(3)
	<append+194 @062fe2>  : 58                         clt.i32
	<append+195 @062fe3>  : 0b                         not.b32
	<append+196 @062fe4>  : 06 0c 00 00                jz <append+208 @062ff0>
	cmplStd/lib/text/string.ci:272: (8 bytes: <append+200 @062fe8> - <append+208 @062ff0>): return .result := pos;
	<append+200 @062fe8>  : 16 0e 0b                   mov.x32 sp(14, 11)
	<append+203 @062feb>  : 09 e4 ff ff                inc.sp(-28)
	<append+207 @062fef>  : 03                         ret
	cmplStd/lib/text/string.ci:276: (22 bytes: <append+208 @062ff0> - <append+230 @063006>): pos := append(output, pos, ".");
	<append+208 @062ff0>  : 19                         load.z32
	<append+209 @062ff1>  : 11 0d                      dup.x64 sp(13)
	<append+211 @062ff3>  : 10 0e                      dup.x32 sp(14)
	<append+213 @062ff5>  : 1f ad 30 03 00             load.ref <@0330ad> ;"."
	<append+218 @062ffa>  : 1f 88 2b 06 00             load.ref <@062b88> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+223 @062fff>  : 02                         call
	<append+224 @063000>  : 09 f0 ff ff                inc.sp(-16)
	<append+228 @063004>  : 13 0c                      set.x32 sp(12)
	cmplStd/lib/text/string.ci:277: (39 bytes: <append+230 @063006> - <append+269 @06302d>): max: int32 := Math.min(int32(output.length - (1)), pos + format.precision)
	<append+230 @063006>  : 10 0d                      dup.x32 sp(13)
	<append+232 @063008>  : 0c ff ff ff                inc.i32(-1)
	<append+236 @06300c>  : 10 0c                      dup.x32 sp(12)
	<append+238 @06300e>  : 10 0a                      dup.x32 sp(10)
	<append+240 @063010>  : 0c 04 00 00                inc.i32(+4)
	<append+244 @063014>  : 28                         load.i32
	<append+245 @063015>  : 51                         add.i32
	<append+246 @063016>  : 10 01                      dup.x32 sp(1)
	<append+248 @063018>  : 10 01                      dup.x32 sp(1)
	<append+250 @06301a>  : 58                         clt.i32
	<append+251 @06301b>  : 06 0a 00 00                jz <append+261 @063025>
	<append+255 @06301f>  : 10 01                      dup.x32 sp(1)
	<append+257 @063021>  : 04 06 00 00                jmp <append+263 @063027>
	<append+261 @063025>  : 10 00                      dup.x32 sp(0)
	<append+263 @063027>  : 13 02                      set.x32 sp(2)
	<append+265 @063029>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:279: (21 bytes: <append+269 @06302d> - <append+290 @063042>): if (format.precision == 0)
	<append+269 @06302d>  : 10 09                      dup.x32 sp(9)
	<append+271 @06302f>  : 0c 04 00 00                inc.i32(+4)
	<append+275 @063033>  : 28                         load.i32
	<append+276 @063034>  : 19                         load.z32
	<append+277 @063035>  : 57                         ceq.i32
	<append+278 @063036>  : 06 0c 00 00                jz <append+290 @063042>
	cmplStd/lib/text/string.ci:281: (8 bytes: <append+282 @06303a> - <append+290 @063042>): max := (output.length - (1));
	<append+282 @06303a>  : 10 0e                      dup.x32 sp(14)
	<append+284 @06303c>  : 0c ff ff ff                inc.i32(-1)
	<append+288 @063040>  : 13 01                      set.x32 sp(1)
	cmplStd/lib/text/string.ci:283: (104 bytes: <append+290 @063042> - <append+394 @0630aa>): for ( ; (fraction > eps && pos < max) || pos < end; )
	<append+290 @063042>  : 04 3f 00 00                jmp <append+353 @063081>
	cmplStd/lib/text/string.ci:284: (29 bytes: <append+294 @063046> - <append+323 @063063>): fraction := Math.modf(fraction * (10), &value);
	<append+294 @063046>  : 1a                         load.z64
	<append+295 @063047>  : 11 03                      dup.x64 sp(3)
	<append+297 @063049>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+306 @063052>  : 83                         mul.f64
	<append+307 @063053>  : 0a 38 00 00                load.sp(+56)
	<append+311 @063057>  : 1f 88 1b 06 00             load.ref <@061b88> ;Math.modf(x: float64, intPart: float64): float64
	<append+316 @06305c>  : 02                         call
	<append+317 @06305d>  : 09 f4 ff ff                inc.sp(-12)
	<append+321 @063061>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/text/string.ci:285: (30 bytes: <append+323 @063063> - <append+353 @063081>): pos := append(output, pos, uint64(int64(value)), formatDec);
	<append+323 @063063>  : 19                         load.z32
	<append+324 @063064>  : 11 0e                      dup.x64 sp(14)
	<append+326 @063066>  : 10 0f                      dup.x32 sp(15)
	<append+328 @063068>  : 1c 0a 00 00 00             load.c32 10
	<append+333 @06306d>  : 11 0f                      dup.x64 sp(15)
	<append+335 @06306f>  : 8b                         f64.2i64
	<append+336 @063070>  : 1f 08 2f 06 00             load.ref <@062f08> ;append.formatDec
	<append+341 @063075>  : 1f 10 2c 06 00             load.ref <@062c10> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+346 @06307a>  : 02                         call
	<append+347 @06307b>  : 09 e4 ff ff                inc.sp(-28)
	<append+351 @06307f>  : 13 0d                      set.x32 sp(13)
	cmplStd/lib/text/string.ci:283: (41 bytes: <append+353 @063081> - <append+394 @0630aa>): (fraction > eps && pos < max) || pos < end
	<append+353 @063081>  : 11 01                      dup.x64 sp(1)
	<append+355 @063083>  : 21 18 2f 06                load.m64 <@062f18> ;append.eps
	<append+359 @063087>  : 89                         cgt.f64
	<append+360 @063088>  : 10 00                      dup.x32 sp(0)
	<append+362 @06308a>  : 06 0d 00 00                jz <append+375 @063097>
	<append+366 @06308e>  : 09 fc ff ff                inc.sp(-4)
	<append+370 @063092>  : 10 0c                      dup.x32 sp(12)
	<append+372 @063094>  : 10 01                      dup.x32 sp(1)
	<append+374 @063096>  : 58                         clt.i32
	<append+375 @063097>  : 10 00                      dup.x32 sp(0)
	<append+377 @063099>  : 05 0d 00 00                jnz <append+390 @0630a6>
	<append+381 @06309d>  : 09 fc ff ff                inc.sp(-4)
	<append+385 @0630a1>  : 10 0c                      dup.x32 sp(12)
	<append+387 @0630a3>  : 10 04                      dup.x32 sp(4)
	<append+389 @0630a5>  : 58                         clt.i32
	<append+390 @0630a6>  : 05 a0 ff ff                jnz <append+294 @063046>
	cmplStd/lib/text/string.ci:287: (8 bytes: <append+394 @0630aa> - <append+402 @0630b2>): return .result := pos;
	<append+394 @0630aa>  : 16 0f 0c                   mov.x32 sp(15, 12)
	<append+397 @0630ad>  : 09 e0 ff ff                inc.sp(-32)
	<append+401 @0630b1>  : 03                         ret
.usages:
	cmplStd/lib/text/string.ci:291: referenced as `append`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:291'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 31
.offset: <@0630c8>
.name: 'append'
.file: 'cmplStd/lib/text/string.ci:294'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.sign := (0));
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (31 bytes: <append @0630c8> - <append+31 @0630e7>)
	cmplStd/lib/text/string.ci:296: (31 bytes: <append @0630c8> - <append+31 @0630e7>): return .result := append(output, pos, value, format);
	<append @0630c8>      : 19                         load.z32
	<append+1 @0630c9>    : 11 04                      dup.x64 sp(4)
	<append+3 @0630cb>    : 10 05                      dup.x32 sp(5)
	<append+5 @0630cd>    : 1c 0a 00 00 00             load.c32 10
	<append+10 @0630d2>   : 10 06                      dup.x32 sp(6)
	<append+12 @0630d4>   : 5b                         i32.2i64
	<append+13 @0630d5>   : 1f b8 30 06 00             load.ref <@0630b8> ;append.format
	<append+18 @0630da>   : 1f a0 2e 06 00             load.ref <@062ea0> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<append+23 @0630df>   : 02                         call
	<append+24 @0630e0>   : 09 e4 ff ff                inc.sp(-28)
	<append+28 @0630e4>   : 13 06                      set.x32 sp(6)
	<append+30 @0630e6>   : 03                         ret
.usages:
}
float64(value: char[]): float64: function {
.kind: static function
.base: `function`
.size: 343
.offset: <@0630e8>
.name: 'float64'
.file: 'cmplStd/lib/text/string.ci:300'
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param value: char[] (size: 8, offs: <+16>, cast: const variable(arr))
.doc: 'Convert a string to a 64 bit floating point value'
.value: {
	sign: float64 := 1;
	result: float64 := 0;
	decimal: float64 := 0;
	for (i: int32 := 0; bool(bool(i < (value.length)) && bool((value[i]) != 0)); int32(i := int32(i + 1))) {
		chr: char := value[i];
		if (bool(bool(chr >= '0') && bool(chr <= '9'))) {
			float64(result := float64(float64(result * (10)) + ((char(chr - '0')))));
			float64(decimal := float64(decimal * (10)));
		}
		else if (bool(chr == '.')) {
			if (bool(decimal != (0))) {
				return float64(.result := Math.nan);
			}
			float64(decimal := (1));
		}
		else if (bool(bool(chr == '-') && bool(i == 0))) {
			float64(sign := (int32(-1)));
		}
		else if (bool(bool(chr == '+') && bool(i == 0))) {
			float64(sign := (1));
		}
		else {
			return float64(.result := Math.nan);
		}
	}
	if (bool(decimal == (0))) {
		if (bool(value.length > (0))) {
			return float64(.result := float64(sign * result));
		}
	}
	return float64(.result := float64(float64(sign * result) / decimal));
}
.instructions: (343 bytes: <float64 @0630e8> - <float64+343 @06323f>)
	cmplStd/lib/text/string.ci:301: (9 bytes: <float64 @0630e8> - <float64+9 @0630f1>): sign: float64 := 1
	<float64 @0630e8>      : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	cmplStd/lib/text/string.ci:302: (1 byte: <float64+9 @0630f1> - <float64+10 @0630f2>): result: float64 := 0
	<float64+9 @0630f1>    : 1b                         load.z128
	cmplStd/lib/text/string.ci:306: (290 bytes: <float64+10 @0630f2> - <float64+300 @063214>): for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1)
	<float64+10 @0630f2>   : 19                         load.z32
	<float64+11 @0630f3>   : 04 01 01 00                jmp <float64+268 @0631f4>
	cmplStd/lib/text/string.ci:307: (6 bytes: <float64+15 @0630f7> - <float64+21 @0630fd>): chr: char := value[i]
	<float64+15 @0630f7>   : 10 08                      dup.x32 sp(8)
	<float64+17 @0630f9>   : 10 01                      dup.x32 sp(1)
	<float64+19 @0630fb>   : 51                         add.i32
	<float64+20 @0630fc>   : 26                         load.i8
	cmplStd/lib/text/string.ci:308: (239 bytes: <float64+21 @0630fd> - <float64+260 @0631ec>): if (chr >= '0' && chr <= '9')
	<float64+21 @0630fd>   : 0a 00 00 00                load.sp(+0)
	<float64+25 @063101>   : 26                         load.i8
	<float64+26 @063102>   : 1c 30 00 00 00             load.c32 48
	<float64+31 @063107>   : 58                         clt.i32
	<float64+32 @063108>   : 0b                         not.b32
	<float64+33 @063109>   : 10 00                      dup.x32 sp(0)
	<float64+35 @06310b>   : 06 14 00 00                jz <float64+55 @06311f>
	<float64+39 @06310f>   : 09 fc ff ff                inc.sp(-4)
	<float64+43 @063113>   : 0a 00 00 00                load.sp(+0)
	<float64+47 @063117>   : 26                         load.i8
	<float64+48 @063118>   : 1c 39 00 00 00             load.c32 57
	<float64+53 @06311d>   : 59                         cgt.i32
	<float64+54 @06311e>   : 0b                         not.b32
	<float64+55 @06311f>   : 06 2f 00 00                jz <float64+102 @06314e>
	cmplStd/lib/text/string.ci:309: (25 bytes: <float64+59 @063123> - <float64+84 @06313c>): result := result * (10) + ((chr - '0'));
	<float64+59 @063123>   : 11 04                      dup.x64 sp(4)
	<float64+61 @063125>   : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<float64+70 @06312e>   : 83                         mul.f64
	<float64+71 @06312f>   : 0a 08 00 00                load.sp(+8)
	<float64+75 @063133>   : 26                         load.i8
	<float64+76 @063134>   : 0c d0 ff ff                inc.i32(-48)
	<float64+80 @063138>   : 5d                         i32.2f64
	<float64+81 @063139>   : 81                         add.f64
	<float64+82 @06313a>   : 14 06                      set.x64 sp(6)
	cmplStd/lib/text/string.ci:310: (14 bytes: <float64+84 @06313c> - <float64+98 @06314a>): decimal := decimal * (10);
	<float64+84 @06313c>   : 11 02                      dup.x64 sp(2)
	<float64+86 @06313e>   : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<float64+95 @063147>   : 83                         mul.f64
	<float64+96 @063148>   : 14 04                      set.x64 sp(4)
	<float64+98 @06314a>   : 04 a2 00 00                jmp <float64+260 @0631ec>
	cmplStd/lib/text/string.ci:312: (158 bytes: <float64+102 @06314e> - <float64+260 @0631ec>): if (chr == '.')
	<float64+102 @06314e>  : 0a 00 00 00                load.sp(+0)
	<float64+106 @063152>  : 26                         load.i8
	<float64+107 @063153>  : 1c 2e 00 00 00             load.c32 46
	<float64+112 @063158>  : 57                         ceq.i32
	<float64+113 @063159>  : 06 2b 00 00                jz <float64+156 @063184>
	cmplStd/lib/text/string.ci:313: (24 bytes: <float64+117 @06315d> - <float64+141 @063175>): if (decimal != (0))
	<float64+117 @06315d>  : 11 02                      dup.x64 sp(2)
	<float64+119 @06315f>  : 1a                         load.z64
	<float64+120 @063160>  : 87                         ceq.f64
	<float64+121 @063161>  : 05 14 00 00                jnz <float64+141 @063175>
	cmplStd/lib/text/string.ci:315: (16 bytes: <float64+125 @063165> - <float64+141 @063175>): return .result := Math.nan;
	<float64+125 @063165>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<float64+134 @06316e>  : 14 0d                      set.x64 sp(13)
	<float64+136 @063170>  : 09 e0 ff ff                inc.sp(-32)
	<float64+140 @063174>  : 03                         ret
	cmplStd/lib/text/string.ci:317: (11 bytes: <float64+141 @063175> - <float64+152 @063180>): decimal := (1);
	<float64+141 @063175>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<float64+150 @06317e>  : 14 04                      set.x64 sp(4)
	<float64+152 @063180>  : 04 6c 00 00                jmp <float64+260 @0631ec>
	cmplStd/lib/text/string.ci:319: (104 bytes: <float64+156 @063184> - <float64+260 @0631ec>): if (chr == '-' && i == 0)
	<float64+156 @063184>  : 0a 00 00 00                load.sp(+0)
	<float64+160 @063188>  : 26                         load.i8
	<float64+161 @063189>  : 1c 2d 00 00 00             load.c32 45
	<float64+166 @06318e>  : 57                         ceq.i32
	<float64+167 @06318f>  : 10 00                      dup.x32 sp(0)
	<float64+169 @063191>  : 06 0c 00 00                jz <float64+181 @06319d>
	<float64+173 @063195>  : 09 fc ff ff                inc.sp(-4)
	<float64+177 @063199>  : 10 01                      dup.x32 sp(1)
	<float64+179 @06319b>  : 19                         load.z32
	<float64+180 @06319c>  : 57                         ceq.i32
	<float64+181 @06319d>  : 06 13 00 00                jz <float64+200 @0631b0>
	cmplStd/lib/text/string.ci:320: (11 bytes: <float64+185 @0631a1> - <float64+196 @0631ac>): sign := (-1);
	<float64+185 @0631a1>  : 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<float64+194 @0631aa>  : 14 08                      set.x64 sp(8)
	<float64+196 @0631ac>  : 04 40 00 00                jmp <float64+260 @0631ec>
	cmplStd/lib/text/string.ci:322: (60 bytes: <float64+200 @0631b0> - <float64+260 @0631ec>): if (chr == '+' && i == 0)
	<float64+200 @0631b0>  : 0a 00 00 00                load.sp(+0)
	<float64+204 @0631b4>  : 26                         load.i8
	<float64+205 @0631b5>  : 1c 2b 00 00 00             load.c32 43
	<float64+210 @0631ba>  : 57                         ceq.i32
	<float64+211 @0631bb>  : 10 00                      dup.x32 sp(0)
	<float64+213 @0631bd>  : 06 0c 00 00                jz <float64+225 @0631c9>
	<float64+217 @0631c1>  : 09 fc ff ff                inc.sp(-4)
	<float64+221 @0631c5>  : 10 01                      dup.x32 sp(1)
	<float64+223 @0631c7>  : 19                         load.z32
	<float64+224 @0631c8>  : 57                         ceq.i32
	<float64+225 @0631c9>  : 06 13 00 00                jz <float64+244 @0631dc>
	cmplStd/lib/text/string.ci:323: (11 bytes: <float64+229 @0631cd> - <float64+240 @0631d8>): sign := (1);
	<float64+229 @0631cd>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<float64+238 @0631d6>  : 14 08                      set.x64 sp(8)
	<float64+240 @0631d8>  : 04 14 00 00                jmp <float64+260 @0631ec>
	cmplStd/lib/text/string.ci:327: (16 bytes: <float64+244 @0631dc> - <float64+260 @0631ec>): return .result := Math.nan;
	<float64+244 @0631dc>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<float64+253 @0631e5>  : 14 0d                      set.x64 sp(13)
	<float64+255 @0631e7>  : 09 e0 ff ff                inc.sp(-32)
	<float64+259 @0631eb>  : 03                         ret
	<float64+260 @0631ec>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:306: (4 bytes: <float64+264 @0631f0> - <float64+268 @0631f4>): i := i + 1
	<float64+264 @0631f0>  : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/text/string.ci:306: (28 bytes: <float64+268 @0631f4> - <float64+296 @063210>): i < (value.length) && (value[i]) != 0
	<float64+268 @0631f4>  : 10 00                      dup.x32 sp(0)
	<float64+270 @0631f6>  : 10 0a                      dup.x32 sp(10)
	<float64+272 @0631f8>  : 58                         clt.i32
	<float64+273 @0631f9>  : 10 00                      dup.x32 sp(0)
	<float64+275 @0631fb>  : 06 11 00 00                jz <float64+292 @06320c>
	<float64+279 @0631ff>  : 09 fc ff ff                inc.sp(-4)
	<float64+283 @063203>  : 10 08                      dup.x32 sp(8)
	<float64+285 @063205>  : 10 01                      dup.x32 sp(1)
	<float64+287 @063207>  : 51                         add.i32
	<float64+288 @063208>  : 26                         load.i8
	<float64+289 @063209>  : 19                         load.z32
	<float64+290 @06320a>  : 57                         ceq.i32
	<float64+291 @06320b>  : 0b                         not.b32
	<float64+292 @06320c>  : 05 eb fe ff                jnz <float64+15 @0630f7>
	<float64+296 @063210>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/text/string.ci:331: (28 bytes: <float64+300 @063214> - <float64+328 @063230>): if (decimal == (0))
	<float64+300 @063214>  : 11 00                      dup.x64 sp(0)
	<float64+302 @063216>  : 1a                         load.z64
	<float64+303 @063217>  : 87                         ceq.f64
	<float64+304 @063218>  : 06 18 00 00                jz <float64+328 @063230>
	cmplStd/lib/text/string.ci:332: (20 bytes: <float64+308 @06321c> - <float64+328 @063230>): if (value.length > (0))
	<float64+308 @06321c>  : 10 08                      dup.x32 sp(8)
	<float64+310 @06321e>  : 19                         load.z32
	<float64+311 @06321f>  : 39                         cgt.u32
	<float64+312 @063220>  : 06 10 00 00                jz <float64+328 @063230>
	cmplStd/lib/text/string.ci:333: (12 bytes: <float64+316 @063224> - <float64+328 @063230>): return .result := sign * result;
	<float64+316 @063224>  : 11 04                      dup.x64 sp(4)
	<float64+318 @063226>  : 11 04                      dup.x64 sp(4)
	<float64+320 @063228>  : 83                         mul.f64
	<float64+321 @063229>  : 14 0b                      set.x64 sp(11)
	<float64+323 @06322b>  : 09 e8 ff ff                inc.sp(-24)
	<float64+327 @06322f>  : 03                         ret
	cmplStd/lib/text/string.ci:336: (15 bytes: <float64+328 @063230> - <float64+343 @06323f>): return .result := sign * result / decimal;
	<float64+328 @063230>  : 11 04                      dup.x64 sp(4)
	<float64+330 @063232>  : 11 04                      dup.x64 sp(4)
	<float64+332 @063234>  : 83                         mul.f64
	<float64+333 @063235>  : 11 02                      dup.x64 sp(2)
	<float64+335 @063237>  : 84                         div.f64
	<float64+336 @063238>  : 14 0b                      set.x64 sp(11)
	<float64+338 @06323a>  : 09 e8 ff ff                inc.sp(-24)
	<float64+342 @06323e>  : 03                         ret
.usages:
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'cmplStd/test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063240>
.name: 'emitldz32'
.file: 'cmplStd/test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063248>
.name: 'emitldz64'
.file: 'cmplStd/test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063250>
.name: 'emitA'
.file: 'cmplStd/test/lang/emit.ci:6'
.value: 42
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063258>
.name: 'emitB'
.file: 'cmplStd/test/lang/emit.ci:7'
.value: 96
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063260>
.name: 'emitAddI32'
.file: 'cmplStd/test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063268>
.name: 'emitDivI32'
.file: 'cmplStd/test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
}
emitNfcF32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063270>
.name: 'emitNfcF32'
.file: 'cmplStd/test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin))
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'cmplStd/test/lang/emit.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	cmplStd/test/lang/emit.ci:24: referenced as `floatAsInt32`
	cmplStd/test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'cmplStd/test/lang/emit.ci:21'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	cmplStd/test/lang/emit.ci:26: referenced as `floatAsInt64`
	cmplStd/test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063278>
.name: 'emitFloatAsInt1'
.file: 'cmplStd/test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063280>
.name: 'emitFloatAsInt2'
.file: 'cmplStd/test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063288>
.name: 'emitFloatAsInt3'
.file: 'cmplStd/test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063290>
.name: 'emitFloatAsInt4'
.file: 'cmplStd/test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@063298>
.name: 'emitSlice'
.file: 'cmplStd/test/lang/emit.ci:29'
.value: emit(void(int32(3), pointer("string")))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'cmplStd/test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'cmplStd/test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'cmplStd/test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'cmplStd/test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632a0>
.name: 'i3'
.file: 'cmplStd/test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632a8>
.name: 'i6'
.file: 'cmplStd/test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632b0>
.name: 'i2'
.file: 'cmplStd/test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632b8>
.name: 'i8'
.file: 'cmplStd/test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632c0>
.name: 'zeroVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632c8>
.name: 'zeroVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632d0>
.name: 'zeroXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632d8>
.name: 'lastVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632e0>
.name: 'lastVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632e8>
.name: 'lastXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632f0>
.name: 'sum2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0632f8>
.name: 'sum2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063300>
.name: 'sum2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063308>
.name: 'any2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063310>
.name: 'any2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063318>
.name: 'any2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063320>
.name: 'min2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063328>
.name: 'min2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063330>
.name: 'min2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063338>
.name: 'max2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063340>
.name: 'max2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063348>
.name: 'max2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063350>
.name: 'sumRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063358>
.name: 'sumLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063360>
.name: 'sumRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063368>
.name: 'sumLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063370>
.name: 'sumRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063378>
.name: 'sumLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063380>
.name: 'anyRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063388>
.name: 'anyLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063390>
.name: 'anyRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063398>
.name: 'anyLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633a0>
.name: 'anyRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633a8>
.name: 'anyLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633b0>
.name: 'minRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633b8>
.name: 'minLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633c0>
.name: 'minRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633c8>
.name: 'minLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633d0>
.name: 'minRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633d8>
.name: 'minLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633e0>
.name: 'maxRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633e8>
.name: 'maxLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633f0>
.name: 'maxRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0633f8>
.name: 'maxLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063400>
.name: 'maxRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063408>
.name: 'maxLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:3'
.value: 1
.usages:
	cmplStd/test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	cmplStd/test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	cmplStd/test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	cmplStd/test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	cmplStd/test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063410>
.name: 'overload1'
.file: 'cmplStd/test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063418>
.name: 'overload2'
.file: 'cmplStd/test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063420>
.name: 'overload3'
.file: 'cmplStd/test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063428>
.name: 'overload4'
.file: 'cmplStd/test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063430>
.name: 'overload5'
.file: 'cmplStd/test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0427b0>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0428f0>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	cmplStd/test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@063438>
.name: 'boilC'
.file: 'cmplStd/test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@063440>
.name: 'boilF'
.file: 'cmplStd/test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063448>
.name: 'pi64'
.file: 'cmplStd/test/std/number.ci:3'
.value: 3.141593
.usages:
	cmplStd/test/std/number.ci:44: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:39: referenced as `pi64`
	cmplStd/test/std/number.ci:38: referenced as `pi64`
	cmplStd/test/std/number.ci:37: referenced as `pi64`
	cmplStd/test/std/number.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063450>
.name: 'e64'
.file: 'cmplStd/test/std/number.ci:4'
.value: 2.718282
.usages:
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063458>
.name: 'pi32'
.file: 'cmplStd/test/std/number.ci:6'
.value: pi64
.usages:
	cmplStd/test/std/number.ci:53: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:48: referenced as `pi32`
	cmplStd/test/std/number.ci:47: referenced as `pi32`
	cmplStd/test/std/number.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063460>
.name: 'e32'
.file: 'cmplStd/test/std/number.ci:7'
.value: e64
.usages:
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'cmplStd/test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	cmplStd/test/std/number.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'cmplStd/test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	cmplStd/test/std/number.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063468>
.name: 'r_comp'
.file: 'cmplStd/test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `r_comp`
	cmplStd/test/std/number.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063470>
.name: 'g_comp'
.file: 'cmplStd/test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `g_comp`
	cmplStd/test/std/number.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063478>
.name: 'b_comp'
.file: 'cmplStd/test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `b_comp`
	cmplStd/test/std/number.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063480>
.name: 'r5g6b5'
.file: 'cmplStd/test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:66: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:65: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:63: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:62: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:60: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:59: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:58: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:57: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:56: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:55: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:27: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:26: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:25: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:23: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:22: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063488>
.name: 'r8g8b8'
.file: 'cmplStd/test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:35: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:34: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:33: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:31: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:30: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063490>
.name: 'zxtR5'
.file: 'cmplStd/test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063498>
.name: 'zxtG6'
.file: 'cmplStd/test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634a0>
.name: 'zxtB5'
.file: 'cmplStd/test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634a8>
.name: 'sxtR5'
.file: 'cmplStd/test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634b0>
.name: 'sxtG6'
.file: 'cmplStd/test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634b8>
.name: 'sxtB5'
.file: 'cmplStd/test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634c0>
.name: 'zxtR8'
.file: 'cmplStd/test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634c8>
.name: 'zxtG8'
.file: 'cmplStd/test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634d0>
.name: 'zxtB8'
.file: 'cmplStd/test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634d8>
.name: 'sxtR8'
.file: 'cmplStd/test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634e0>
.name: 'sxtG8'
.file: 'cmplStd/test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0634e8>
.name: 'sxtB8'
.file: 'cmplStd/test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0634f0>
.name: 'testSin_f64'
.file: 'cmplStd/test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0634f8>
.name: 'testCos_f64'
.file: 'cmplStd/test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063500>
.name: 'testTan_f64'
.file: 'cmplStd/test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063508>
.name: 'testLog_f64'
.file: 'cmplStd/test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063510>
.name: 'testExp_f64'
.file: 'cmplStd/test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063518>
.name: 'testPow_f64'
.file: 'cmplStd/test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063520>
.name: 'testSqrt_f64'
.file: 'cmplStd/test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@063528>
.name: 'testAtan_f64'
.file: 'cmplStd/test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063530>
.name: 'testSin_f32'
.file: 'cmplStd/test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063538>
.name: 'testCos_f32'
.file: 'cmplStd/test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063540>
.name: 'testTan_f32'
.file: 'cmplStd/test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063548>
.name: 'testLog_f32'
.file: 'cmplStd/test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063550>
.name: 'testExp_f32'
.file: 'cmplStd/test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063558>
.name: 'testPow_f32'
.file: 'cmplStd/test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063560>
.name: 'testSqrt_f32'
.file: 'cmplStd/test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@063568>
.name: 'testAtan_f32'
.file: 'cmplStd/test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063570>
.name: 'testPopulation_u32'
.file: 'cmplStd/test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063578>
.name: 'testSwapBits_u32'
.file: 'cmplStd/test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063580>
.name: 'testBitScanReverse_u32'
.file: 'cmplStd/test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063588>
.name: 'testBitScanForward_u32'
.file: 'cmplStd/test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063590>
.name: 'testHighBit_u32'
.file: 'cmplStd/test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063598>
.name: 'testLowBit_u32'
.file: 'cmplStd/test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0635a0>
.name: 'testZeroExtend_u32'
.file: 'cmplStd/test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0635a8>
.name: 'testSignExtend_u32'
.file: 'cmplStd/test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0635b0>
.name: 'testZeroExtend_u64'
.file: 'cmplStd/test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0635b8>
.name: 'testSignExtend_u64'
.file: 'cmplStd/test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'cmplStd/test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'cmplStd/test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	cmplStd/test/std/memory.ci:10: referenced as `malloc`
	cmplStd/test/std/memory.ci:9: referenced as `malloc`
	cmplStd/test/std/memory.ci:8: referenced as `malloc`
	cmplStd/test/std/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'cmplStd/test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `free`
	cmplStd/test/std/memory.ci:19: referenced as `free`
	cmplStd/test/std/memory.ci:18: referenced as `free`
	cmplStd/test/std/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0635c0>
.name: 'p1'
.file: 'cmplStd/test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	cmplStd/test/std/memory.ci:17: referenced as `p1`
	cmplStd/test/std/memory.ci:14: referenced as `p1`
	cmplStd/test/std/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0635c8>
.name: 'p2'
.file: 'cmplStd/test/std/memory.ci:8'
.value: malloc(80)
.usages:
	cmplStd/test/std/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0635d0>
.name: 'p3'
.file: 'cmplStd/test/std/memory.ci:9'
.value: malloc(160)
.usages:
	cmplStd/test/std/memory.ci:19: referenced as `p3`
	cmplStd/test/std/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0635d8>
.name: 'p4'
.file: 'cmplStd/test/std/memory.ci:10'
.value: malloc(820)
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0635e0>
.name: 'val1'
.file: 'cmplStd/test/std/memory.ci:23'
.value: 42
.usages:
	cmplStd/test/std/memory.ci:32: referenced as `val1`
	cmplStd/test/std/memory.ci:30: referenced as `val1`
	cmplStd/test/std/memory.ci:29: referenced as `val1`
	cmplStd/test/std/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0635e8>
.name: 'val2'
.file: 'cmplStd/test/std/memory.ci:24'
.value: 96
.usages:
	cmplStd/test/std/memory.ci:33: referenced as `val2`
	cmplStd/test/std/memory.ci:29: referenced as `val2`
	cmplStd/test/std/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@0635f0>
.name: 'noError'
.file: 'cmplStd/test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <noError @0635f0> - <noError+1 @0635f1>)
	<noError @0635f0>      : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:47: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@0635f8>
.name: 'stackOverflow'
.file: 'cmplStd/test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes: <stackOverflow @0635f8> - <stackOverflow+24 @063610>)
	cmplStd/test/std/tryExec.ci:16: (4 bytes: <stackOverflow @0635f8> - <stackOverflow+4 @0635fc>): data: uint8[8192] := {...}
	<stackOverflow @0635f8>      : 09 00 20 00                inc.sp(+8192)
	cmplStd/test/std/tryExec.ci:17: (15 bytes: <stackOverflow+4 @0635fc> - <stackOverflow+19 @06360b>): stackOverflow(ptr);
	<stackOverflow+4 @0635fc>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @063600>    : 28                         load.i32
	<stackOverflow+9 @063601>    : 1f f8 35 06 00             load.ref <@0635f8> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @063606>   : 02                         call
	<stackOverflow+15 @063607>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @06360b>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @06360f>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:49: referenced as `stackOverflow`
	cmplStd/test/std/tryExec.ci:17: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@063610>
.name: 'divisionByZero'
.file: 'cmplStd/test/std/tryExec.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <divisionByZero @063610> - <divisionByZero+12 @06361c>)
	cmplStd/test/std/tryExec.ci:21: (7 bytes: <divisionByZero @063610> - <divisionByZero+7 @063617>): value: int32 := 3 / 0
	<divisionByZero @063610>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @063615>    : 19                         load.z32
	<divisionByZero+6 @063616>    : 54                         div.i32
	<divisionByZero+7 @063617>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @06361b>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:50: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 68
.offset: <@063620>
.name: 'abortExecution'
.file: 'cmplStd/test/std/tryExec.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <abortExecution @063620> - <abortExecution+68 @063664>)
	cmplStd/test/std/tryExec.ci:30: (25 bytes: <abortExecution @063620> - <abortExecution+25 @063639>): details: NotEquals := {...}
	<abortExecution @063620>      : 09 10 00 00                inc.sp(+16)
	cmplStd/test/std/tryExec.ci:31: (7 bytes: <abortExecution+4 @063624> - <abortExecution+11 @06362b>): details.message := ("assertion failed");
	<abortExecution+4 @063624>    : 1f 00 f8 00 00             load.ref <@00f800> ;"assertion failed"
	<abortExecution+9 @063629>    : 13 01                      set.x32 sp(1)
	cmplStd/test/std/tryExec.ci:32: (7 bytes: <abortExecution+11 @06362b> - <abortExecution+18 @063632>): details.expected := 97;
	<abortExecution+11 @06362b>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @063630>   : 13 02                      set.x32 sp(2)
	cmplStd/test/std/tryExec.ci:33: (7 bytes: <abortExecution+18 @063632> - <abortExecution+25 @063639>): details.returned := 77;
	<abortExecution+18 @063632>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @063637>   : 13 03                      set.x32 sp(3)
	cmplStd/test/std/tryExec.ci:35: (38 bytes: <abortExecution+25 @063639> - <abortExecution+63 @06365f>): abort("fatal error", details);
	<abortExecution+25 @063639>   : 1f 78 63 04 00             load.ref <@046378> ;"cmplStd/test/std/tryExec.ci"
	<abortExecution+30 @06363e>   : 1c 23 00 00 00             load.c32 35
	<abortExecution+35 @063643>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @063648>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @06364d>   : 1f c8 63 04 00             load.ref <@0463c8> ;"fatal error"
	<abortExecution+50 @063652>   : 1f 60 6e 04 00             load.ref <@046e60> ;abortExecution.NotEquals
	<abortExecution+55 @063657>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @06365b>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @06365f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @063663>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 13
.offset: <@063668>
.name: 'invalidMemoryAccess'
.file: 'cmplStd/test/std/tryExec.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <invalidMemoryAccess @063668> - <invalidMemoryAccess+13 @063675>)
	cmplStd/test/std/tryExec.ci:39: (5 bytes: <invalidMemoryAccess @063668> - <invalidMemoryAccess+5 @06366d>): i32Ref: int32 := null
	<invalidMemoryAccess @063668>      : 1f 00 00 00 00             load.ref <@000000> ;null
	cmplStd/test/std/tryExec.ci:40: (3 bytes: <invalidMemoryAccess+5 @06366d> - <invalidMemoryAccess+8 @063670>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @06366d>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @06366f>    : 28                         load.i32
	<invalidMemoryAccess+8 @063670>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @063674>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:52: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 2
.offset: <@063678>
.name: 'invalidInstruction'
.file: 'cmplStd/test/std/tryExec.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <invalidInstruction @063678> - <invalidInstruction+2 @06367a>)
	cmplStd/test/std/tryExec.ci:44: (2 bytes: <invalidInstruction @063678> - <invalidInstruction+2 @06367a>): emit(load.z32, ret);
	<invalidInstruction @063678>      : 19                         load.z32
	<invalidInstruction+1 @063679>    : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:51: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063680>
.name: 'tryExecErr0'
.file: 'cmplStd/test/std/tryExec.ci:47'
.value: tryExec(void(null, noError))
.usages:
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063688>
.name: 'tryExecErr1'
.file: 'cmplStd/test/std/tryExec.ci:48'
.value: tryExec(void(null, null))
.usages:
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063690>
.name: 'tryExecErr2'
.file: 'cmplStd/test/std/tryExec.ci:49'
.value: tryExec(void(null, stackOverflow))
.usages:
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063698>
.name: 'tryExecErr3'
.file: 'cmplStd/test/std/tryExec.ci:50'
.value: tryExec(void(null, divisionByZero))
.usages:
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0636a0>
.name: 'tryExecErr4'
.file: 'cmplStd/test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidInstruction))
.usages:
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0636a8>
.name: 'tryExecErr5'
.file: 'cmplStd/test/std/tryExec.ci:52'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0636b0>
.name: 'tryExecErr6'
.file: 'cmplStd/test/std/tryExec.ci:53'
.value: tryExec(void(null, abortExecution))
.usages:
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0636b8>
.name: 'value'
.file: 'cmplStd/test/lang/init.reference.ci:7'
.value: 42
.usages:
	cmplStd/test/lang/init.reference.ci:99: referenced as `value`
	cmplStd/test/lang/init.reference.ci:97: referenced as `value`
	cmplStd/test/lang/init.reference.ci:96: referenced as `value`
	cmplStd/test/lang/init.reference.ci:95: referenced as `value`
	cmplStd/test/lang/init.reference.ci:27: referenced as `value`
	cmplStd/test/lang/init.reference.ci:10: referenced as `value`
	cmplStd/test/lang/init.reference.ci:9: referenced as `value`
	cmplStd/test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0636c0>
.name: 'valueRef'
.file: 'cmplStd/test/lang/init.reference.ci:8'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:29: referenced as `valueRef`
	cmplStd/test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0636c8>
.name: 'valuePtr'
.file: 'cmplStd/test/lang/init.reference.ci:9'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:30: referenced as `valuePtr`
	cmplStd/test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0636d0>
.name: 'valueVar'
.file: 'cmplStd/test/lang/init.reference.ci:10'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:31: referenced as `valueVar`
	cmplStd/test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0636d8>
.name: 'fromRef'
.file: 'cmplStd/test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0636e0>
.name: 'fromPtr'
.file: 'cmplStd/test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0636e8>
.name: 'fromVar'
.file: 'cmplStd/test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0636f0>
.name: 'nullRef'
.file: 'cmplStd/test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0636f8>
.name: 'nullPtr'
.file: 'cmplStd/test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063700>
.name: 'nullVar'
.file: 'cmplStd/test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063708>
.name: 'nullTyp'
.file: 'cmplStd/test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@063710>
.name: 'nullFun'
.file: 'cmplStd/test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@063718>
.name: 'nullObj'
.file: 'cmplStd/test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063720>
.name: 'typePtr'
.file: 'cmplStd/test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063728>
.name: 'typeVar'
.file: 'cmplStd/test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063730>
.name: 'typeTyp'
.file: 'cmplStd/test/lang/init.reference.ci:25'
.value: int64
.usages:
	cmplStd/test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063738>
.name: 'local'
.file: 'cmplStd/test/lang/init.reference.ci:27'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@063740>
.name: 'copyVal'
.file: 'cmplStd/test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@063748>
.name: 'copyRef'
.file: 'cmplStd/test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063750>
.name: 'copyPtr'
.file: 'cmplStd/test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063758>
.name: 'copyVar'
.file: 'cmplStd/test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063760>
.name: 'copyTyp'
.file: 'cmplStd/test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063768>
.name: 'ptrVoid'
.file: 'cmplStd/test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063770>
.name: 'ptrBool'
.file: 'cmplStd/test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063778>
.name: 'ptrChar'
.file: 'cmplStd/test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063780>
.name: 'ptrInt8'
.file: 'cmplStd/test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063788>
.name: 'ptrInt16'
.file: 'cmplStd/test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063790>
.name: 'ptrInt32'
.file: 'cmplStd/test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063798>
.name: 'ptrInt64'
.file: 'cmplStd/test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637a0>
.name: 'ptrUint8'
.file: 'cmplStd/test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637a8>
.name: 'ptrUint16'
.file: 'cmplStd/test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637b0>
.name: 'ptrUint32'
.file: 'cmplStd/test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637b8>
.name: 'ptrUint64'
.file: 'cmplStd/test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637c0>
.name: 'ptrFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637c8>
.name: 'ptrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:47'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637d0>
.name: 'ptrTypename'
.file: 'cmplStd/test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637d8>
.name: 'ptrFunction'
.file: 'cmplStd/test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637e0>
.name: 'ptrPointer'
.file: 'cmplStd/test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637e8>
.name: 'ptrVariant'
.file: 'cmplStd/test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0637f0>
.name: 'ptrObject'
.file: 'cmplStd/test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0637f8>
.name: 'varVoid'
.file: 'cmplStd/test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063800>
.name: 'varBool'
.file: 'cmplStd/test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063808>
.name: 'varChar'
.file: 'cmplStd/test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063810>
.name: 'varInt8'
.file: 'cmplStd/test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063818>
.name: 'varInt16'
.file: 'cmplStd/test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063820>
.name: 'varInt32'
.file: 'cmplStd/test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063828>
.name: 'varInt64'
.file: 'cmplStd/test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063830>
.name: 'varUint8'
.file: 'cmplStd/test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063838>
.name: 'varUint16'
.file: 'cmplStd/test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063840>
.name: 'varUint32'
.file: 'cmplStd/test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063848>
.name: 'varUint64'
.file: 'cmplStd/test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063850>
.name: 'varFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063858>
.name: 'varFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:67'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063860>
.name: 'varTypename'
.file: 'cmplStd/test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063868>
.name: 'varFunction'
.file: 'cmplStd/test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063870>
.name: 'varPointer'
.file: 'cmplStd/test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063878>
.name: 'varVariant'
.file: 'cmplStd/test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063880>
.name: 'varObject'
.file: 'cmplStd/test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063888>
.name: 'typVoid'
.file: 'cmplStd/test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063890>
.name: 'typBool'
.file: 'cmplStd/test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063898>
.name: 'typChar'
.file: 'cmplStd/test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638a0>
.name: 'typInt8'
.file: 'cmplStd/test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638a8>
.name: 'typInt16'
.file: 'cmplStd/test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638b0>
.name: 'typInt32'
.file: 'cmplStd/test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638b8>
.name: 'typInt64'
.file: 'cmplStd/test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638c0>
.name: 'typUint8'
.file: 'cmplStd/test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638c8>
.name: 'typUint16'
.file: 'cmplStd/test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638d0>
.name: 'typUint32'
.file: 'cmplStd/test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638d8>
.name: 'typUint64'
.file: 'cmplStd/test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638e0>
.name: 'typFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638e8>
.name: 'typFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638f0>
.name: 'typTypename'
.file: 'cmplStd/test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0638f8>
.name: 'typFunction'
.file: 'cmplStd/test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063900>
.name: 'typPointer'
.file: 'cmplStd/test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063908>
.name: 'typVariant'
.file: 'cmplStd/test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063910>
.name: 'typObject'
.file: 'cmplStd/test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063918>
.name: 'valueOfPtr'
.file: 'cmplStd/test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063920>
.name: 'valueOfVar'
.file: 'cmplStd/test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063928>
.name: 'valueOfTyp'
.file: 'cmplStd/test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063930>
.name: 'typeOfValue'
.file: 'cmplStd/test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@063938>
.name: 'copyPtrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@063940>
.name: 'copyVarFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063948>
.name: 'variable'
.file: 'cmplStd/test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@063950>
.name: 'constant'
.file: 'cmplStd/test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04b700>
.name: 'ComplexVal'
.file: 'cmplStd/test/lang/init.variable.ci:9'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
	internal usages: 1
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@04b8e0>
.name: 'ComplexObj'
.file: 'cmplStd/test/lang/init.variable.ci:13'
.field re: float64 (size: 8, offs: <+4>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+12>, cast: const variable(f64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.field type: function (size: 0, offs: <@0076f8>, cast: static const inline)
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `ComplexObj`
	cmplStd/test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+4>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `re`
	cmplStd/test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+12>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
	internal usages: 2
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0076f8>
.name: 'type'
.owner: object
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(10)
.usages:
}
valInitImplicit: ComplexVal {
.kind: static variable(val)
.base: `ComplexVal`
.size: 16
.offset: <@063958>
.name: 'valInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	void(valInitImplicit.re := (8));
	void(valInitImplicit.im := (0));
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: static variable(ref)
.base: `ComplexObj`
.size: 4
.offset: <@063968>
.name: 'objInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	void(objInitImplicit := create(ComplexObj));
	void(objInitImplicit.re := (8));
	void(objInitImplicit.im := (0));
}
.usages:
}
objInitExplicit: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@063970>
.name: 'objInitExplicit'
.file: 'cmplStd/test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	void(objInitExplicit := create(ComplexObj));
	void(objInitExplicit.re := (8));
	void(objInitExplicit.im := (0));
}
.usages:
}
empty(): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@063978>
.name: 'empty'
.file: 'cmplStd/test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <empty @063978> - <empty+1 @063979>)
	<empty @063978>      : 03                         ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@063980>
.name: 'funAdd'
.file: 'cmplStd/test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <funAdd @063980> - <funAdd+8 @063988>)
	cmplStd/test/lang/function.ci:8: (8 bytes: <funAdd @063980> - <funAdd+8 @063988>): return .result := x + y;
	<funAdd @063980>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @063982>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @063984>    : 51                         add.i32
	<funAdd+5 @063985>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @063987>    : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:15: referenced as `funAdd`
	cmplStd/test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063988>
.name: 'funAddResult'
.file: 'cmplStd/test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@063990>
.name: 'funAddRef'
.file: 'cmplStd/test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	cmplStd/test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063998>
.name: 'funAddRefResult'
.file: 'cmplStd/test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0639a0>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:27: referenced as `funMul`
	cmplStd/test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0639a8>
.name: 'funMulResult'
.file: 'cmplStd/test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0639b0>
.name: 'funMulRef'
.file: 'cmplStd/test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0639b8>
.name: 'funMulRefResult'
.file: 'cmplStd/test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@0639c0>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <funMul @0639c0> - <funMul+8 @0639c8>)
	cmplStd/test/lang/function.ci:34: (8 bytes: <funMul @0639c0> - <funMul+8 @0639c8>): return .result := x * y;
	<funMul @0639c0>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @0639c2>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @0639c4>    : 53                         mul.i32
	<funMul+5 @0639c5>    : 13 04                      set.x32 sp(4)
	<funMul+7 @0639c7>    : 03                         ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 54
.offset: <@0639c8>
.name: 'fib'
.file: 'cmplStd/test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <fib @0639c8> - <fib+54 @0639fe>)
	cmplStd/test/lang/function.ci:39: (16 bytes: <fib @0639c8> - <fib+16 @0639d8>): if (n <= (1))
	<fib @0639c8>      : 10 01                      dup.x32 sp(1)
	<fib+2 @0639ca>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @0639cf>    : 39                         cgt.u32
	<fib+8 @0639d0>    : 05 08 00 00                jnz <fib+16 @0639d8>
	cmplStd/test/lang/function.ci:40: (4 bytes: <fib+12 @0639d4> - <fib+16 @0639d8>): return .result := n;
	<fib+12 @0639d4>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @0639d7>   : 03                         ret
	cmplStd/test/lang/function.ci:42: (38 bytes: <fib+16 @0639d8> - <fib+54 @0639fe>): return .result := fib(n - (1)) + fib(n - (2));
	<fib+16 @0639d8>   : 19                         load.z32
	<fib+17 @0639d9>   : 10 02                      dup.x32 sp(2)
	<fib+19 @0639db>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @0639df>   : 1f c8 39 06 00             load.ref <@0639c8> ;fib(n: uint32): uint32
	<fib+28 @0639e4>   : 02                         call
	<fib+29 @0639e5>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @0639e9>   : 19                         load.z32
	<fib+34 @0639ea>   : 10 03                      dup.x32 sp(3)
	<fib+36 @0639ec>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @0639f0>   : 1f c8 39 06 00             load.ref <@0639c8> ;fib(n: uint32): uint32
	<fib+45 @0639f5>   : 02                         call
	<fib+46 @0639f6>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @0639fa>   : 51                         add.i32
	<fib+51 @0639fb>   : 13 03                      set.x32 sp(3)
	<fib+53 @0639fd>   : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:46: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@063a00>
.name: 'fibonacci_13'
.file: 'cmplStd/test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a08>
.name: 'sizeofVoid'
.file: 'cmplStd/test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a10>
.name: 'sizeofBool'
.file: 'cmplStd/test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a18>
.name: 'sizeofChar'
.file: 'cmplStd/test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a20>
.name: 'sizeofInt8'
.file: 'cmplStd/test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a28>
.name: 'sizeofInt16'
.file: 'cmplStd/test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a30>
.name: 'sizeofInt32'
.file: 'cmplStd/test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a38>
.name: 'sizeofInt64'
.file: 'cmplStd/test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a40>
.name: 'sizeofUint8'
.file: 'cmplStd/test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a48>
.name: 'sizeofUint16'
.file: 'cmplStd/test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a50>
.name: 'sizeofUint32'
.file: 'cmplStd/test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a58>
.name: 'sizeofUint64'
.file: 'cmplStd/test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a60>
.name: 'sizeofFloat32'
.file: 'cmplStd/test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a68>
.name: 'sizeofFloat64'
.file: 'cmplStd/test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a70>
.name: 'sizeofPointer'
.file: 'cmplStd/test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a78>
.name: 'sizeofVariant'
.file: 'cmplStd/test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a80>
.name: 'sizeofTypename'
.file: 'cmplStd/test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a88>
.name: 'sizeofFunction'
.file: 'cmplStd/test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063a90>
.name: 'sizeofObject'
.file: 'cmplStd/test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@04deb0>
.name: 'RecordSizeof'
.file: 'cmplStd/test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.field type: function (size: 0, offs: <@0076f8>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0076f8>
.name: 'type'
.owner: object
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(10)
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@04dff0>
.name: 'RecordSizeofExt'
.file: 'cmplStd/test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.field type: function (size: 0, offs: <@0076f8>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'cmplStd/test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0076f8>
.name: 'type'
.owner: object
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(10)
.usages:
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063a98>
.name: 'typeofRecord'
.file: 'cmplStd/test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	cmplStd/test/lang/reflect.ci:37: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:35: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:34: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:33: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:32: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@063aa0>
.name: 'nameOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063aa8>
.name: 'offsetOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063ab0>
.name: 'sizeOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:33'
.value: typeofRecord.size
.usages:
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@063ab8>
.name: 'fileOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063ac0>
.name: 'lineOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063ac8>
.name: 'typeofBase'
.file: 'cmplStd/test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	cmplStd/test/lang/reflect.ci:44: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:42: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:41: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:40: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:39: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@063ad0>
.name: 'nameOfBase'
.file: 'cmplStd/test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063ad8>
.name: 'offsetOfBase'
.file: 'cmplStd/test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063ae0>
.name: 'sizeOfBase'
.file: 'cmplStd/test/lang/reflect.ci:40'
.value: typeofBase.size
.usages:
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@063ae8>
.name: 'fileOfBase'
.file: 'cmplStd/test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063af0>
.name: 'lineOfBase'
.file: 'cmplStd/test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063af8>
.name: 'typeofBase1'
.file: 'cmplStd/test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:46: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063b00>
.name: 'offsetOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063b08>
.name: 'sizeOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@063b10>
.name: 'typeofBase2'
.file: 'cmplStd/test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `typeofBase2`
	cmplStd/test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063b18>
.name: 'offsetOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063b20>
.name: 'sizeOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@04eff0>
.name: 'RecordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:2'
.field Inner: typename (size: 8, offs: <@04f090>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@063b28>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@063b30>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@063b38>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@063b40>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@063b48>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@063b50>, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	cmplStd/test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04f090>
.name: 'Inner'
.file: 'cmplStd/test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	cmplStd/test/lang/init.member.ci:49: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:46: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:43: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:25: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:64: referenced as `member`
	cmplStd/test/lang/init.member.ci:59: referenced as `member`
	cmplStd/test/lang/init.member.ci:49: referenced as `member`
	cmplStd/test/lang/init.member.ci:46: referenced as `member`
	internal usages: 1
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:65: referenced as `constant`
	cmplStd/test/lang/init.member.ci:60: referenced as `constant`
	cmplStd/test/lang/init.member.ci:49: referenced as `constant`
	cmplStd/test/lang/init.member.ci:46: referenced as `constant`
	cmplStd/test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'cmplStd/test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	cmplStd/test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'cmplStd/test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	cmplStd/test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'cmplStd/test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'cmplStd/test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063b28>
.name: 'global'
.file: 'cmplStd/test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063b30>
.name: 'globalInit'
.file: 'cmplStd/test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@063b38>
.name: 'globalConstant'
.file: 'cmplStd/test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@063b40>
.name: 'globalRec'
.file: 'cmplStd/test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	void(globalRec.constant := 4);
	void(globalRec.member := (0));
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@063b48>
.name: 'globalRecInit'
.file: 'cmplStd/test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@063b50>
.name: 'globalConstantRec'
.file: 'cmplStd/test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@063b58>
.name: 'recordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:52'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04ff08>
.name: 'RecordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:4'
.field staticMethod: function (size: 39, offs: <@063b78>, cast: static function)
.field forwardMethod: function (size: 4, offs: <@063ba0>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 39, offs: <@063ba8>, cast: static function)
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field forwardMethod: function (size: 39, offs: <@063bd0>, cast: static function)
.doc: 'static, virtual and abstract methods'
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@063b78>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <staticMethod @063b78> - <staticMethod+39 @063b9f>)
	cmplStd/test/lang/init.method.ci:11: (38 bytes: <staticMethod @063b78> - <staticMethod+38 @063b9e>): trace("staticMethod", x);
	<staticMethod @063b78>      : 1f 90 fa 04 00             load.ref <@04fa90> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @063b7d>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @063b82>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @063b87>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @063b8c>   : 1f 3a fb 04 00             load.ref <@04fb3a> ;"staticMethod"
	<staticMethod+25 @063b91>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<staticMethod+30 @063b96>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @063b9a>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @063b9e>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:101: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:87: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@063ba0>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	cmplStd/test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'cmplStd/test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'cmplStd/test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	internal usages: 1
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@063ba8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <virtualMethod @063ba8> - <virtualMethod+39 @063bcf>)
	cmplStd/test/lang/init.method.ci:41: (38 bytes: <virtualMethod @063ba8> - <virtualMethod+38 @063bce>): trace("virtualMethod", x);
	<virtualMethod @063ba8>      : 1f 90 fa 04 00             load.ref <@04fa90> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @063bad>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @063bb2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @063bb7>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @063bbc>   : 1f 26 fe 04 00             load.ref <@04fe26> ;"virtualMethod"
	<virtualMethod+25 @063bc1>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<virtualMethod+30 @063bc6>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @063bca>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @063bce>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:93: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:79: referenced as `virtualMethod`
	internal usages: 1
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@063bd0>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <forwardMethod @063bd0> - <forwardMethod+39 @063bf7>)
	cmplStd/test/lang/init.method.ci:48: (38 bytes: <forwardMethod @063bd0> - <forwardMethod+38 @063bf6>): trace("forwardMethod", x);
	<forwardMethod @063bd0>      : 1f 90 fa 04 00             load.ref <@04fa90> ;"cmplStd/test/lang/init.method.ci"
	<forwardMethod+5 @063bd5>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @063bda>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @063bdf>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @063be4>   : 1f ad fb 04 00             load.ref <@04fbad> ;"forwardMethod"
	<forwardMethod+25 @063be9>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<forwardMethod+30 @063bee>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @063bf2>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @063bf6>   : 03                         ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@063bf8>
.name: 'globalFunction'
.file: 'cmplStd/test/lang/init.method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <globalFunction @063bf8> - <globalFunction+39 @063c1f>)
	cmplStd/test/lang/init.method.ci:58: (38 bytes: <globalFunction @063bf8> - <globalFunction+38 @063c1e>): trace("globalFunction", x);
	<globalFunction @063bf8>      : 1f 90 fa 04 00             load.ref <@04fa90> ;"cmplStd/test/lang/init.method.ci"
	<globalFunction+5 @063bfd>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @063c02>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @063c07>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @063c0c>   : 1f 59 fe 04 00             load.ref <@04fe59> ;"globalFunction"
	<globalFunction+25 @063c11>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<globalFunction+30 @063c16>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @063c1a>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @063c1e>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@063c20>
.name: 'recordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:102: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:98: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:97: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:79: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 66
.offset: <@063c30>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <staticMethod @063c30> - <staticMethod+66 @063c72>)
	cmplStd/test/lang/init.method.ci:85: (35 bytes: <staticMethod @063c30> - <staticMethod+35 @063c53>): debug("extension.staticMethod");
	<staticMethod @063c30>      : 1f 90 fa 04 00             load.ref <@04fa90> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @063c35>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @063c3a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @063c3f>   : 19                         load.z32
	<staticMethod+16 @063c40>   : 1f d5 fe 04 00             load.ref <@04fed5> ;"extension.staticMethod"
	<staticMethod+21 @063c45>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<staticMethod+26 @063c4a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @063c4f>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:86: (30 bytes: <staticMethod+35 @063c53> - <staticMethod+65 @063c71>): if ((this) != null)
	<staticMethod+35 @063c53>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @063c57>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @063c5c>   : 57                         ceq.i32
	<staticMethod+45 @063c5d>   : 05 14 00 00                jnz <staticMethod+65 @063c71>
	cmplStd/test/lang/init.method.ci:87: (16 bytes: <staticMethod+49 @063c61> - <staticMethod+65 @063c71>): RecordMethodTest.staticMethod(this, x);
	<staticMethod+49 @063c61>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @063c63>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @063c65>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @063c67>   : 1f 78 3b 06 00             load.ref <@063b78> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @063c6c>   : 02                         call
	<staticMethod+61 @063c6d>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @063c71>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@063c78>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <virtualMethod @063c78> - <virtualMethod+63 @063cb7>)
	cmplStd/test/lang/init.method.ci:91: (35 bytes: <virtualMethod @063c78> - <virtualMethod+35 @063c9b>): debug("extension.virtualMethod");
	<virtualMethod @063c78>      : 1f 90 fa 04 00             load.ref <@04fa90> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @063c7d>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @063c82>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @063c87>   : 19                         load.z32
	<virtualMethod+16 @063c88>   : 1f ec fe 04 00             load.ref <@04feec> ;"extension.virtualMethod"
	<virtualMethod+21 @063c8d>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<virtualMethod+26 @063c92>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @063c97>   : 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:92: (27 bytes: <virtualMethod+35 @063c9b> - <virtualMethod+62 @063cb6>): if ((this) != null)
	<virtualMethod+35 @063c9b>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @063c9f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @063ca4>   : 57                         ceq.i32
	<virtualMethod+45 @063ca5>   : 05 11 00 00                jnz <virtualMethod+62 @063cb6>
	cmplStd/test/lang/init.method.ci:93: (13 bytes: <virtualMethod+49 @063ca9> - <virtualMethod+62 @063cb6>): this.virtualMethod(this, x);
	<virtualMethod+49 @063ca9>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @063cab>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @063cad>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @063caf>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @063cb1>   : 02                         call
	<virtualMethod+58 @063cb2>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @063cb6>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:98: referenced as `virtualMethod`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0517c8>
.name: 'rgbF32'
.file: 'cmplStd/test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	cmplStd/test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@051a48>
.name: 'rgbU8'
.file: 'cmplStd/test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	cmplStd/test/lang/recUnion.ci:28: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:27: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:26: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `b`
	cmplStd/test/lang/recUnion.ci:28: referenced as `b`
	cmplStd/test/lang/recUnion.ci:27: referenced as `b`
	cmplStd/test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `g`
	cmplStd/test/lang/recUnion.ci:28: referenced as `g`
	cmplStd/test/lang/recUnion.ci:27: referenced as `g`
	cmplStd/test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `r`
	cmplStd/test/lang/recUnion.ci:28: referenced as `r`
	cmplStd/test/lang/recUnion.ci:27: referenced as `r`
	cmplStd/test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@051cc8>
.name: 'color'
.file: 'cmplStd/test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `color`
	cmplStd/test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'cmplStd/test/lang/recUnion.ci:17'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'cmplStd/test/lang/recUnion.ci:18'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@051ea8>
.name: 'Color'
.file: 'cmplStd/test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.field type: function (size: 0, offs: <@0076f8>, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'cmplStd/test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0076f8>
.name: 'type'
.owner: object
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(10)
.usages:
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@063cb8>
.name: 'black'
.file: 'cmplStd/test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@063cc0>
.name: 'green'
.file: 'cmplStd/test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@063cc8>
.name: 'white'
.file: 'cmplStd/test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@063cd0>
.name: 'cyan'
.file: 'cmplStd/test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@063cd8>
.name: 'blue'
.file: 'cmplStd/test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@052388>
.name: 'record_pack0'
.file: 'cmplStd/test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@0527e8>
.name: 'record_pack1'
.file: 'cmplStd/test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@052c48>
.name: 'record_pack2'
.file: 'cmplStd/test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@0530a8>
.name: 'record_pack4'
.file: 'cmplStd/test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@053508>
.name: 'record_pack8'
.file: 'cmplStd/test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@053968>
.name: 'record_packDef'
.file: 'cmplStd/test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'cmplStd/test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	cmplStd/test/lang/useOperator.ci:260: referenced as `a`
	cmplStd/test/lang/useOperator.ci:237: referenced as `a`
	cmplStd/test/lang/useOperator.ci:214: referenced as `a`
	cmplStd/test/lang/useOperator.ci:191: referenced as `a`
	cmplStd/test/lang/useOperator.ci:168: referenced as `a`
	cmplStd/test/lang/useOperator.ci:145: referenced as `a`
	cmplStd/test/lang/useOperator.ci:122: referenced as `a`
	cmplStd/test/lang/useOperator.ci:99: referenced as `a`
	cmplStd/test/lang/useOperator.ci:76: referenced as `a`
	cmplStd/test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'cmplStd/test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	cmplStd/test/lang/useOperator.ci:261: referenced as `b`
	cmplStd/test/lang/useOperator.ci:238: referenced as `b`
	cmplStd/test/lang/useOperator.ci:215: referenced as `b`
	cmplStd/test/lang/useOperator.ci:192: referenced as `b`
	cmplStd/test/lang/useOperator.ci:169: referenced as `b`
	cmplStd/test/lang/useOperator.ci:146: referenced as `b`
	cmplStd/test/lang/useOperator.ci:123: referenced as `b`
	cmplStd/test/lang/useOperator.ci:100: referenced as `b`
	cmplStd/test/lang/useOperator.ci:77: referenced as `b`
	cmplStd/test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@063ce0>
.name: 'shift'
.file: 'cmplStd/test/lang/useOperator.ci:5'
.value: 2
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:228: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:227: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:205: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:204: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:182: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:181: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:159: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:158: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:136: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:135: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:113: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:112: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:90: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:89: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:67: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:66: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:44: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063ce8>
.name: 'boolA'
.file: 'cmplStd/test/lang/useOperator.ci:7'
.value: true
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063cf0>
.name: 'boolB'
.file: 'cmplStd/test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:22: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063cf8>
.name: 'boolAnd'
.file: 'cmplStd/test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d00>
.name: 'boolIor'
.file: 'cmplStd/test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d08>
.name: 'boolXor'
.file: 'cmplStd/test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d10>
.name: 'boolNot'
.file: 'cmplStd/test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d18>
.name: 'boolCeq'
.file: 'cmplStd/test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d20>
.name: 'boolCne'
.file: 'cmplStd/test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d28>
.name: 'boolClt'
.file: 'cmplStd/test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d30>
.name: 'boolCle'
.file: 'cmplStd/test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d38>
.name: 'boolCgt'
.file: 'cmplStd/test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063d40>
.name: 'boolCge'
.file: 'cmplStd/test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d48>
.name: 'chrA'
.file: 'cmplStd/test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:44: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:43: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d50>
.name: 'chrB'
.file: 'cmplStd/test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:45: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:34: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:33: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d58>
.name: 'chrPls'
.file: 'cmplStd/test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d60>
.name: 'chrNeg'
.file: 'cmplStd/test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d68>
.name: 'chrCmt'
.file: 'cmplStd/test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d70>
.name: 'chrAdd'
.file: 'cmplStd/test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d78>
.name: 'chrSub'
.file: 'cmplStd/test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d80>
.name: 'chrMul'
.file: 'cmplStd/test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d88>
.name: 'chrDiv'
.file: 'cmplStd/test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d90>
.name: 'chrMod'
.file: 'cmplStd/test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063d98>
.name: 'chrAnd'
.file: 'cmplStd/test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063da0>
.name: 'chrIor'
.file: 'cmplStd/test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063da8>
.name: 'chrXor'
.file: 'cmplStd/test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063db0>
.name: 'chrShl'
.file: 'cmplStd/test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@063db8>
.name: 'chrShr'
.file: 'cmplStd/test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063dc0>
.name: 'chrNot'
.file: 'cmplStd/test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063dc8>
.name: 'chrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063dd0>
.name: 'chrCne'
.file: 'cmplStd/test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063dd8>
.name: 'chrClt'
.file: 'cmplStd/test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063de0>
.name: 'chrCle'
.file: 'cmplStd/test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063de8>
.name: 'chrCgt'
.file: 'cmplStd/test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063df0>
.name: 'chrCge'
.file: 'cmplStd/test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063df8>
.name: 'i8A'
.file: 'cmplStd/test/lang/useOperator.ci:53'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:67: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:66: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e00>
.name: 'i8B'
.file: 'cmplStd/test/lang/useOperator.ci:54'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:68: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:57: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:56: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e08>
.name: 'i8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e10>
.name: 'i8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e18>
.name: 'i8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e20>
.name: 'i8Add'
.file: 'cmplStd/test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e28>
.name: 'i8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e30>
.name: 'i8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e38>
.name: 'i8Div'
.file: 'cmplStd/test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e40>
.name: 'i8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e48>
.name: 'i8And'
.file: 'cmplStd/test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e50>
.name: 'i8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e58>
.name: 'i8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e60>
.name: 'i8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@063e68>
.name: 'i8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063e70>
.name: 'i8Not'
.file: 'cmplStd/test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063e78>
.name: 'i8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063e80>
.name: 'i8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063e88>
.name: 'i8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063e90>
.name: 'i8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063e98>
.name: 'i8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063ea0>
.name: 'i8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ea8>
.name: 'u8A'
.file: 'cmplStd/test/lang/useOperator.ci:76'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:90: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:89: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063eb0>
.name: 'u8B'
.file: 'cmplStd/test/lang/useOperator.ci:77'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:91: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:80: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:79: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063eb8>
.name: 'u8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ec0>
.name: 'u8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ec8>
.name: 'u8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ed0>
.name: 'u8Add'
.file: 'cmplStd/test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ed8>
.name: 'u8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ee0>
.name: 'u8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ee8>
.name: 'u8Div'
.file: 'cmplStd/test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ef0>
.name: 'u8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063ef8>
.name: 'u8And'
.file: 'cmplStd/test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063f00>
.name: 'u8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063f08>
.name: 'u8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063f10>
.name: 'u8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@063f18>
.name: 'u8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f20>
.name: 'u8Not'
.file: 'cmplStd/test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f28>
.name: 'u8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f30>
.name: 'u8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f38>
.name: 'u8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f40>
.name: 'u8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f48>
.name: 'u8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063f50>
.name: 'u8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f58>
.name: 'i16A'
.file: 'cmplStd/test/lang/useOperator.ci:99'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:113: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:112: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f60>
.name: 'i16B'
.file: 'cmplStd/test/lang/useOperator.ci:100'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:114: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:103: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:102: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f68>
.name: 'i16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f70>
.name: 'i16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f78>
.name: 'i16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f80>
.name: 'i16Add'
.file: 'cmplStd/test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f88>
.name: 'i16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f90>
.name: 'i16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063f98>
.name: 'i16Div'
.file: 'cmplStd/test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063fa0>
.name: 'i16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063fa8>
.name: 'i16And'
.file: 'cmplStd/test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063fb0>
.name: 'i16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063fb8>
.name: 'i16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063fc0>
.name: 'i16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@063fc8>
.name: 'i16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063fd0>
.name: 'i16Not'
.file: 'cmplStd/test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063fd8>
.name: 'i16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063fe0>
.name: 'i16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063fe8>
.name: 'i16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063ff0>
.name: 'i16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@063ff8>
.name: 'i16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064000>
.name: 'i16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064008>
.name: 'u16A'
.file: 'cmplStd/test/lang/useOperator.ci:122'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:136: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:135: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064010>
.name: 'u16B'
.file: 'cmplStd/test/lang/useOperator.ci:123'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:137: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:126: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:125: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064018>
.name: 'u16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064020>
.name: 'u16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064028>
.name: 'u16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064030>
.name: 'u16Add'
.file: 'cmplStd/test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064038>
.name: 'u16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064040>
.name: 'u16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064048>
.name: 'u16Div'
.file: 'cmplStd/test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064050>
.name: 'u16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064058>
.name: 'u16And'
.file: 'cmplStd/test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064060>
.name: 'u16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064068>
.name: 'u16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064070>
.name: 'u16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@064078>
.name: 'u16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064080>
.name: 'u16Not'
.file: 'cmplStd/test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064088>
.name: 'u16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064090>
.name: 'u16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064098>
.name: 'u16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0640a0>
.name: 'u16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0640a8>
.name: 'u16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0640b0>
.name: 'u16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640b8>
.name: 'i32A'
.file: 'cmplStd/test/lang/useOperator.ci:145'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:159: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:158: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640c0>
.name: 'i32B'
.file: 'cmplStd/test/lang/useOperator.ci:146'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:160: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:149: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:148: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640c8>
.name: 'i32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640d0>
.name: 'i32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640d8>
.name: 'i32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640e0>
.name: 'i32Add'
.file: 'cmplStd/test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640e8>
.name: 'i32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640f0>
.name: 'i32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0640f8>
.name: 'i32Div'
.file: 'cmplStd/test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064100>
.name: 'i32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064108>
.name: 'i32And'
.file: 'cmplStd/test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064110>
.name: 'i32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064118>
.name: 'i32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064120>
.name: 'i32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064128>
.name: 'i32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064130>
.name: 'i32Not'
.file: 'cmplStd/test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064138>
.name: 'i32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064140>
.name: 'i32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064148>
.name: 'i32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064150>
.name: 'i32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064158>
.name: 'i32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064160>
.name: 'i32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064168>
.name: 'u32A'
.file: 'cmplStd/test/lang/useOperator.ci:168'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:182: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:181: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064170>
.name: 'u32B'
.file: 'cmplStd/test/lang/useOperator.ci:169'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:183: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:172: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:171: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064178>
.name: 'u32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064180>
.name: 'u32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064188>
.name: 'u32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064190>
.name: 'u32Add'
.file: 'cmplStd/test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@064198>
.name: 'u32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641a0>
.name: 'u32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641a8>
.name: 'u32Div'
.file: 'cmplStd/test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641b0>
.name: 'u32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641b8>
.name: 'u32And'
.file: 'cmplStd/test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641c0>
.name: 'u32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641c8>
.name: 'u32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641d0>
.name: 'u32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0641d8>
.name: 'u32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0641e0>
.name: 'u32Not'
.file: 'cmplStd/test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0641e8>
.name: 'u32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0641f0>
.name: 'u32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0641f8>
.name: 'u32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064200>
.name: 'u32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064208>
.name: 'u32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064210>
.name: 'u32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064218>
.name: 'i64A'
.file: 'cmplStd/test/lang/useOperator.ci:191'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:205: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:204: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064220>
.name: 'i64B'
.file: 'cmplStd/test/lang/useOperator.ci:192'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:206: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:195: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:194: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064228>
.name: 'i64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064230>
.name: 'i64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064238>
.name: 'i64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064240>
.name: 'i64Add'
.file: 'cmplStd/test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064248>
.name: 'i64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064250>
.name: 'i64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064258>
.name: 'i64Div'
.file: 'cmplStd/test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064260>
.name: 'i64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064268>
.name: 'i64And'
.file: 'cmplStd/test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064270>
.name: 'i64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064278>
.name: 'i64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064280>
.name: 'i64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@064288>
.name: 'i64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064290>
.name: 'i64Not'
.file: 'cmplStd/test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064298>
.name: 'i64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0642a0>
.name: 'i64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0642a8>
.name: 'i64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0642b0>
.name: 'i64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0642b8>
.name: 'i64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0642c0>
.name: 'i64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642c8>
.name: 'u64A'
.file: 'cmplStd/test/lang/useOperator.ci:214'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:228: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:227: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642d0>
.name: 'u64B'
.file: 'cmplStd/test/lang/useOperator.ci:215'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:229: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:218: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:217: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642d8>
.name: 'u64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642e0>
.name: 'u64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642e8>
.name: 'u64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642f0>
.name: 'u64Add'
.file: 'cmplStd/test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0642f8>
.name: 'u64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064300>
.name: 'u64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064308>
.name: 'u64Div'
.file: 'cmplStd/test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064310>
.name: 'u64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064318>
.name: 'u64And'
.file: 'cmplStd/test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064320>
.name: 'u64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064328>
.name: 'u64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064330>
.name: 'u64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@064338>
.name: 'u64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064340>
.name: 'u64Not'
.file: 'cmplStd/test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064348>
.name: 'u64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064350>
.name: 'u64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064358>
.name: 'u64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064360>
.name: 'u64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064368>
.name: 'u64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064370>
.name: 'u64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@064378>
.name: 'f32A'
.file: 'cmplStd/test/lang/useOperator.ci:237'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@064380>
.name: 'f32B'
.file: 'cmplStd/test/lang/useOperator.ci:238'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:252: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:240: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@064388>
.name: 'f32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@064390>
.name: 'f32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@064398>
.name: 'f32Add'
.file: 'cmplStd/test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0643a0>
.name: 'f32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0643a8>
.name: 'f32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0643b0>
.name: 'f32Div'
.file: 'cmplStd/test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0643b8>
.name: 'f32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643c0>
.name: 'f32Not'
.file: 'cmplStd/test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643c8>
.name: 'f32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643d0>
.name: 'f32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643d8>
.name: 'f32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643e0>
.name: 'f32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643e8>
.name: 'f32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0643f0>
.name: 'f32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0643f8>
.name: 'f64A'
.file: 'cmplStd/test/lang/useOperator.ci:260'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064400>
.name: 'f64B'
.file: 'cmplStd/test/lang/useOperator.ci:261'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:275: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:263: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064408>
.name: 'f64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064410>
.name: 'f64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064418>
.name: 'f64Add'
.file: 'cmplStd/test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064420>
.name: 'f64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064428>
.name: 'f64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064430>
.name: 'f64Div'
.file: 'cmplStd/test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064438>
.name: 'f64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064440>
.name: 'f64Not'
.file: 'cmplStd/test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064448>
.name: 'f64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064450>
.name: 'f64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064458>
.name: 'f64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064460>
.name: 'f64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064468>
.name: 'f64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064470>
.name: 'f64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@064478>
.name: 'ptrA'
.file: 'cmplStd/test/lang/useOperator.ci:283'
.value: null
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrA`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@064480>
.name: 'ptrB'
.file: 'cmplStd/test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrB`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064488>
.name: 'ptrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064490>
.name: 'ptrCne'
.file: 'cmplStd/test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@064498>
.name: 't'
.file: 'cmplStd/test/lang/stmt.if.ci:26'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:65: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:62: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:59: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:56: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:53: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:50: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:43: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:36: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:32: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0644a0>
.name: 'forIdx'
.file: 'cmplStd/test/lang/stmt.for.ci:12'
.usages:
	cmplStd/test/lang/stmt.for.ci:14: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644a8>
.name: 'testMathFloor_1'
.file: 'cmplStd/test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644b0>
.name: 'testMathFloor_2'
.file: 'cmplStd/test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644b8>
.name: 'testMathFloor_3'
.file: 'cmplStd/test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644c0>
.name: 'testMathFloor_4'
.file: 'cmplStd/test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644c8>
.name: 'testMathFloor_5'
.file: 'cmplStd/test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644d0>
.name: 'testMathFloor_6'
.file: 'cmplStd/test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644d8>
.name: 'testMathSign_1F'
.file: 'cmplStd/test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644e0>
.name: 'testMathSign_2F'
.file: 'cmplStd/test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644e8>
.name: 'testMathSign_3F'
.file: 'cmplStd/test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644f0>
.name: 'testMathSign_1f'
.file: 'cmplStd/test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0644f8>
.name: 'testMathSign_2f'
.file: 'cmplStd/test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064500>
.name: 'testMathSign_3f'
.file: 'cmplStd/test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064508>
.name: 'testMathAbs_1F'
.file: 'cmplStd/test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064510>
.name: 'testMathAbs_2F'
.file: 'cmplStd/test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064518>
.name: 'testMathAbs_3F'
.file: 'cmplStd/test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064520>
.name: 'testMathAbs_1f'
.file: 'cmplStd/test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064528>
.name: 'testMathAbs_2f'
.file: 'cmplStd/test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064530>
.name: 'testMathAbs_3f'
.file: 'cmplStd/test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064538>
.name: 'testMathMin_1f'
.file: 'cmplStd/test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064540>
.name: 'testMathMax_2f'
.file: 'cmplStd/test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064548>
.name: 'testMathMin_1F'
.file: 'cmplStd/test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064550>
.name: 'testMathMax_2F'
.file: 'cmplStd/test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064558>
.name: 'testMathClamp_1f'
.file: 'cmplStd/test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064560>
.name: 'testMathClamp_1F'
.file: 'cmplStd/test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064568>
.name: 'testMathLerp_1f'
.file: 'cmplStd/test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064570>
.name: 'testMathLerp_1F'
.file: 'cmplStd/test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064578>
.name: 'testMathSmooth_1f'
.file: 'cmplStd/test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064580>
.name: 'testMathSmooth_1F'
.file: 'cmplStd/test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064588>
.name: 'testMathMin_nan'
.file: 'cmplStd/test/std/test.math.ci:38'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064590>
.name: 'testMathMin_1'
.file: 'cmplStd/test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064598>
.name: 'testMathMax_nan'
.file: 'cmplStd/test/std/test.math.ci:40'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645a0>
.name: 'testMathMax_9'
.file: 'cmplStd/test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645a8>
.name: 'testMathSum_0'
.file: 'cmplStd/test/std/test.math.ci:43'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645b0>
.name: 'testMathSum_1'
.file: 'cmplStd/test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645b8>
.name: 'testMathSum_3'
.file: 'cmplStd/test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645c0>
.name: 'testMathSum_55'
.file: 'cmplStd/test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645c8>
.name: 'testMathEval_x'
.file: 'cmplStd/test/std/test.math.ci:48'
.value: 10
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:54: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:53: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:52: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:51: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:50: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:49: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645d0>
.name: 'testMathEval_0'
.file: 'cmplStd/test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645d8>
.name: 'testMathEval_1'
.file: 'cmplStd/test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645e0>
.name: 'testMathEval_2'
.file: 'cmplStd/test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645e8>
.name: 'testMathEval_3'
.file: 'cmplStd/test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645f0>
.name: 'testMathEval_4'
.file: 'cmplStd/test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0645f8>
.name: 'testMathEval_5'
.file: 'cmplStd/test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064600>
.name: 'testMathEval_6'
.file: 'cmplStd/test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064608>
.name: 'testMathSin_f64'
.file: 'cmplStd/test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064610>
.name: 'testMathCos_f64'
.file: 'cmplStd/test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064618>
.name: 'testMathTan_f64'
.file: 'cmplStd/test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064620>
.name: 'testMathSinh_f64'
.file: 'cmplStd/test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064628>
.name: 'testMathCosh_f64'
.file: 'cmplStd/test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064630>
.name: 'testMathAsin_f64'
.file: 'cmplStd/test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064638>
.name: 'testMathAcos_f64'
.file: 'cmplStd/test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064640>
.name: 'testMathCmp_f32'
.file: 'cmplStd/test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@064648>
.name: 'testMathCmp_f64'
.file: 'cmplStd/test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064650>
.name: 'testMathAbsMod_f64_0a'
.file: 'cmplStd/test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064658>
.name: 'testMathAbsMod_f64_0b'
.file: 'cmplStd/test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064660>
.name: 'testMathAbsMod_f64_0c'
.file: 'cmplStd/test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064668>
.name: 'testMathAbsMod_f64_9a'
.file: 'cmplStd/test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064670>
.name: 'testMathAbsMod_f64_9b'
.file: 'cmplStd/test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064678>
.name: 'testMathAbsMod_f64_9c'
.file: 'cmplStd/test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064680>
.name: 'testMathAbsMod_f64_9d'
.file: 'cmplStd/test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064688>
.name: 'testMathAbsMod_f64_8a'
.file: 'cmplStd/test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064690>
.name: 'testMathAbsMod_f64_8b'
.file: 'cmplStd/test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@064698>
.name: 'testMathAbsMod_f64_8c'
.file: 'cmplStd/test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0646a0>
.name: 'testMathAbsMod_f64_8d'
.file: 'cmplStd/test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646a8>
.name: 'testMathAbsMod_f32_0a'
.file: 'cmplStd/test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646b0>
.name: 'testMathAbsMod_f32_0b'
.file: 'cmplStd/test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646b8>
.name: 'testMathAbsMod_f32_0c'
.file: 'cmplStd/test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646c0>
.name: 'testMathAbsMod_f32_9a'
.file: 'cmplStd/test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646c8>
.name: 'testMathAbsMod_f32_9b'
.file: 'cmplStd/test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646d0>
.name: 'testMathAbsMod_f32_9c'
.file: 'cmplStd/test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646d8>
.name: 'testMathAbsMod_f32_9d'
.file: 'cmplStd/test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646e0>
.name: 'testMathAbsMod_f32_8a'
.file: 'cmplStd/test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646e8>
.name: 'testMathAbsMod_f32_8b'
.file: 'cmplStd/test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646f0>
.name: 'testMathAbsMod_f32_8c'
.file: 'cmplStd/test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0646f8>
.name: 'testMathAbsMod_f32_8d'
.file: 'cmplStd/test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 13419
.offset: <@0646fc>
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b8>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000160>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@000208>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@0002b0>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000358>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000400>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@0004a8>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000550>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005f8>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0006a0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000748>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0007f0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000898>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@000940>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@0009e8>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a90>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000b40>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000de0>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000e88>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005ed8>, cast: static const inline)
.field raise: function (size: 0, offs: <@007db0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@008700>, cast: static const inline)
.field System: typename (size: 0, offs: <@009408>, cast: static const typename(void))
.field true: bool (size: 0, offs: <@000000>, cast: static const val)
.field false: bool (size: 0, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 24, offs: <@012978>, cast: static const typename(val))
.field assertEq: function (size: 103, offs: <@061b20>, cast: static function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@013c50>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@020390>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@0622d0>, cast: static function)
.field Complex: function (size: 7, offs: <@0622d8>, cast: static function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 139, offs: <@0622e0>, cast: static function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@062370>, cast: static function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@062390>, cast: static function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@025ed8>, cast: static const typename(val))
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@02b378>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@0623f8>, cast: static function)
.field mat4f: function (size: 21, offs: <@062430>, cast: static function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field transpose: function (size: 49, offs: <@062448>, cast: static function)
.field mul: function (size: 245, offs: <@062480>, cast: static function)
.field rotation: function (size: 454, offs: <@062578>, cast: static function)
.field rotation: function (size: 224, offs: <@062740>, cast: static function)
.field translation: function (size: 88, offs: <@062820>, cast: static function)
.field scale: function (size: 217, offs: <@062878>, cast: static function)
.field vec2d: typename (size: 16, offs: <@030e98>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@062958>, cast: static function)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field ceq: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@062960>, cast: static function)
.field indexOf: function (size: 50, offs: <@062988>, cast: static function)
.field lastIndexOf: function (size: 50, offs: <@0629c0>, cast: static function)
.field startsWith: function (size: 73, offs: <@0629f8>, cast: static function)
.field endsWith: function (size: 126, offs: <@062a48>, cast: static function)
.field compare: function (size: 63, offs: <@062ac8>, cast: static function)
.field ignCaseCmp: function (size: 36, offs: <@062b50>, cast: static function)
.field caseCmp: function (size: 14, offs: <@062b78>, cast: static function)
.field toHex: function (size: 0, offs: <@000000>, cast: static inline)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field equals: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@036d90>, cast: static const typename(val))
.field append: function (size: 119, offs: <@062b88>, cast: static function)
.field append: function (size: 653, offs: <@062c10>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 102, offs: <@062ea0>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 402, offs: <@062f20>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 31, offs: <@0630c8>, cast: static function)
.field float64: function (size: 343, offs: <@0630e8>, cast: static function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@063240>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@063248>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@063250>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@063258>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@063260>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@063268>, cast: static variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <@063270>, cast: static variable(f32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@063278>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@063280>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@063288>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@063290>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@063298>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@0632a0>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@0632a8>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@0632b0>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@0632b8>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@0632c0>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@0632c8>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@0632d0>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@0632d8>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@0632e0>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@0632e8>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@0632f0>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@0632f8>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@063300>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@063308>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@063310>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@063318>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@063320>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@063328>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@063330>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@063338>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@063340>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@063348>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@063350>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@063358>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@063360>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@063368>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@063370>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@063378>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@063380>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@063388>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@063390>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@063398>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@0633a0>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@0633a8>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@0633b0>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@0633b8>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@0633c0>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@0633c8>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@0633d0>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@0633d8>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@0633e0>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@0633e8>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@0633f0>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@0633f8>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@063400>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@063408>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@063410>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@063418>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@063420>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@063428>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@063430>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@0427b0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@0428f0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@063438>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@063440>, cast: static variable(val))
.field pi64: float64 (size: 8, offs: <@063448>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@063450>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@063458>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@063460>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@063468>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@063470>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@063478>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@063480>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@063488>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@063490>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@063498>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@0634a0>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@0634a8>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@0634b0>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@0634b8>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@0634c0>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@0634c8>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@0634d0>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@0634d8>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@0634e0>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@0634e8>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@0634f0>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@0634f8>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@063500>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@063508>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@063510>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@063518>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@063520>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@063528>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@063530>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@063538>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@063540>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@063548>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@063550>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@063558>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@063560>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@063568>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@063570>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@063578>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@063580>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@063588>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@063590>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@063598>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@0635a0>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@0635a8>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@0635b0>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@0635b8>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@0635c0>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@0635c8>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@0635d0>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@0635d8>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@0635e0>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@0635e8>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@0635f0>, cast: static function)
.field stackOverflow: function (size: 24, offs: <@0635f8>, cast: static function)
.field divisionByZero: function (size: 12, offs: <@063610>, cast: static function)
.field abortExecution: function (size: 68, offs: <@063620>, cast: static function)
.field invalidMemoryAccess: function (size: 13, offs: <@063668>, cast: static function)
.field invalidInstruction: function (size: 2, offs: <@063678>, cast: static function)
.field tryExecErr0: int32 (size: 4, offs: <@063680>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@063688>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@063690>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@063698>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@0636a0>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@0636a8>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@0636b0>, cast: static variable(i32))
.field value: int64 (size: 8, offs: <@0636b8>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@0636c0>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@0636c8>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@0636d0>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@0636d8>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@0636e0>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@0636e8>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@0636f0>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@0636f8>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@063700>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@063708>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@063710>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@063718>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@063720>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@063728>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@063730>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@063738>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@063740>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@063748>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@063750>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@063758>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@063760>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@063768>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@063770>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@063778>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@063780>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@063788>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@063790>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@063798>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@0637a0>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@0637a8>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@0637b0>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@0637b8>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@0637c0>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@0637c8>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@0637d0>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@0637d8>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@0637e0>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@0637e8>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@0637f0>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@0637f8>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@063800>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@063808>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@063810>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@063818>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@063820>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@063828>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@063830>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@063838>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@063840>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@063848>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@063850>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@063858>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@063860>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@063868>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@063870>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@063878>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@063880>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@063888>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@063890>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@063898>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@0638a0>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@0638a8>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@0638b0>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@0638b8>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@0638c0>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@0638c8>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@0638d0>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@0638d8>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@0638e0>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@0638e8>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@0638f0>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@0638f8>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@063900>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@063908>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@063910>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@063918>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@063920>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@063928>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@063930>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@063938>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@063940>, cast: static variable(ref))
.field variable: int32 (size: 4, offs: <@063948>, cast: static variable(i32))
.field constant: int32 (size: 4, offs: <@063950>, cast: static const variable(i32))
.field ComplexVal: typename (size: 16, offs: <@04b700>, cast: static const typename(val))
.field ComplexObj: object (size: 20, offs: <@04b8e0>, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, offs: <@063958>, cast: static variable(val))
.field objInitImplicit: ComplexObj (size: 4, offs: <@063968>, cast: static variable(ref))
.field objInitExplicit: object (size: 4, offs: <@063970>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@063978>, cast: static function)
.field funAdd: function (size: 8, offs: <@063980>, cast: static function)
.field funAddResult: int32 (size: 4, offs: <@063988>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@063990>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@063998>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@0639a0>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@0639a8>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@0639b0>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@0639b8>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@0639c0>, cast: static function)
.field fib: function (size: 54, offs: <@0639c8>, cast: static function)
.field fibonacci_13: uint32 (size: 4, offs: <@063a00>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@063a08>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@063a10>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@063a18>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@063a20>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@063a28>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@063a30>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@063a38>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@063a40>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@063a48>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@063a50>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@063a58>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@063a60>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@063a68>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@063a70>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@063a78>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@063a80>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@063a88>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@063a90>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@04deb0>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@04dff0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@063a98>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@063aa0>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@063aa8>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@063ab0>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@063ab8>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@063ac0>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@063ac8>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@063ad0>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@063ad8>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@063ae0>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@063ae8>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@063af0>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@063af8>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@063b00>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@063b08>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@063b10>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@063b18>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@063b20>, cast: static variable(i32))
.field RecordMemberTest: typename (size: 32, offs: <@04eff0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@063b58>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@04ff08>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@063bf8>, cast: static function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@063c20>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@063c30>, cast: static function)
.field virtualMethod: function (size: 63, offs: <@063c78>, cast: static function)
.field rgbF32: typename (size: 16, offs: <@0517c8>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@051a48>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@051cc8>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@051ea8>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@063cb8>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@063cc0>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@063cc8>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@063cd0>, cast: static variable(val))
.field blue: color (size: 4, offs: <@063cd8>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@052388>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@0527e8>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@052c48>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@0530a8>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@053508>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@053968>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@063ce0>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@063ce8>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@063cf0>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@063cf8>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@063d00>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@063d08>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@063d10>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@063d18>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@063d20>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@063d28>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@063d30>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@063d38>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@063d40>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@063d48>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@063d50>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@063d58>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@063d60>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@063d68>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@063d70>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@063d78>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@063d80>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@063d88>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@063d90>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@063d98>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@063da0>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@063da8>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@063db0>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@063db8>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@063dc0>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@063dc8>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@063dd0>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@063dd8>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@063de0>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@063de8>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@063df0>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@063df8>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@063e00>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@063e08>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@063e10>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@063e18>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@063e20>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@063e28>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@063e30>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@063e38>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@063e40>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@063e48>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@063e50>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@063e58>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@063e60>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@063e68>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@063e70>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@063e78>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@063e80>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@063e88>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@063e90>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@063e98>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@063ea0>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@063ea8>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@063eb0>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@063eb8>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@063ec0>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@063ec8>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@063ed0>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@063ed8>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@063ee0>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@063ee8>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@063ef0>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@063ef8>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@063f00>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@063f08>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@063f10>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@063f18>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@063f20>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@063f28>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@063f30>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@063f38>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@063f40>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@063f48>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@063f50>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@063f58>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@063f60>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@063f68>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@063f70>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@063f78>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@063f80>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@063f88>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@063f90>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@063f98>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@063fa0>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@063fa8>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@063fb0>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@063fb8>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@063fc0>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@063fc8>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@063fd0>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@063fd8>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@063fe0>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@063fe8>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@063ff0>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@063ff8>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@064000>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@064008>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@064010>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@064018>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@064020>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@064028>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@064030>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@064038>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@064040>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@064048>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@064050>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@064058>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@064060>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@064068>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@064070>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@064078>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@064080>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@064088>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@064090>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@064098>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@0640a0>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@0640a8>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@0640b0>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@0640b8>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@0640c0>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@0640c8>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@0640d0>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@0640d8>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@0640e0>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@0640e8>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@0640f0>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@0640f8>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@064100>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@064108>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@064110>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@064118>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@064120>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@064128>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@064130>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@064138>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@064140>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@064148>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@064150>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@064158>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@064160>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@064168>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@064170>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@064178>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@064180>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@064188>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@064190>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@064198>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@0641a0>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@0641a8>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@0641b0>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@0641b8>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@0641c0>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@0641c8>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@0641d0>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@0641d8>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@0641e0>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@0641e8>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@0641f0>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@0641f8>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@064200>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@064208>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@064210>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@064218>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@064220>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@064228>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@064230>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@064238>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@064240>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@064248>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@064250>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@064258>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@064260>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@064268>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@064270>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@064278>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@064280>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@064288>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@064290>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@064298>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@0642a0>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@0642a8>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@0642b0>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@0642b8>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@0642c0>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@0642c8>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@0642d0>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@0642d8>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@0642e0>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@0642e8>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@0642f0>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@0642f8>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@064300>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@064308>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@064310>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@064318>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@064320>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@064328>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@064330>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@064338>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@064340>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@064348>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@064350>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@064358>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@064360>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@064368>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@064370>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@064378>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@064380>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@064388>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@064390>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@064398>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@0643a0>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@0643a8>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@0643b0>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@0643b8>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@0643c0>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@0643c8>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@0643d0>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@0643d8>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@0643e0>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@0643e8>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@0643f0>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@0643f8>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@064400>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@064408>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@064410>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@064418>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@064420>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@064428>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@064430>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@064438>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@064440>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@064448>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@064450>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@064458>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@064460>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@064468>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@064470>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@064478>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@064480>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@064488>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@064490>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@064498>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@0644a0>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@0644a8>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@0644b0>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@0644b8>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@0644c0>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@0644c8>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@0644d0>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@0644d8>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@0644e0>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@0644e8>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@0644f0>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@0644f8>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@064500>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@064508>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@064510>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@064518>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@064520>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@064528>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@064530>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@064538>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@064540>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@064548>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@064550>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@064558>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@064560>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@064568>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@064570>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@064578>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@064580>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@064588>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@064590>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@064598>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@0645a0>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@0645a8>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@0645b0>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@0645b8>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@0645c0>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@0645c8>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@0645d0>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@0645d8>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@0645e0>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@0645e8>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@0645f0>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@0645f8>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@064600>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@064608>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@064610>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@064618>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@064620>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@064628>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@064630>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@064638>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@064640>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@064648>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@064650>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@064658>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@064660>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@064668>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@064670>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@064678>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@064680>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@064688>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@064690>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@064698>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@0646a0>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@0646a8>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@0646b0>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@0646b8>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@0646c0>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@0646c8>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@0646d0>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@0646d8>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@0646e0>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@0646e8>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@0646f0>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@0646f8>, cast: static variable(f32))
.field .main: function (size: 13419, offs: <@0646fc>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static signed(value: uint8): int8 := int8(value);
		static signed(value: uint16): int16 := int16(value);
		static signed(value: uint32): int32 := int32(value);
		static signed(value: uint64): int64 := int64(value);
		static unsigned(value: int8): uint8 := uint8(value);
		static unsigned(value: int16): uint16 := uint16(value);
		static unsigned(value: int32): uint32 := uint32(value);
		static unsigned(value: int64): uint64 := uint64(value);
		static sizeof(type: typename): int32 := typename.size(type);
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[] := null;
			};
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				extras: variant[1] := {
					void(extras[0] := (message));
				};
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.extras := (extras));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: int32): int32 := int32(int32(bool(x > 0)) - int32(bool(x < 0)));
			static sign(x: int64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: uint32): int32 := int32(bool(x > (0)));
			static sign(x: uint64): int32 := int32(bool(x > (0)));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static abs(x: int32): int32 := bool(x < 0) ? int32(-x) : x;
			static abs(x: int64): int64 := bool(x < (0)) ? int64(-x) : x;
			static abs(x: uint32): uint32 := x;
			static abs(x: uint64): uint64 := x;
			static abs(x: float32): float32 := bool(x < (0)) ? float32(-x) : x;
			static abs(x: float64): float64 := bool(x < (0)) ? float64(-x) : x;
			static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
			static min(a: int64, b: int64): int64 := bool(a < b) ? a : b;
			static min(a: uint32, b: uint32): uint32 := bool(a < b) ? a : b;
			static min(a: uint64, b: uint64): uint64 := bool(a < b) ? a : b;
			static min(a: float32, b: float32): float32 := bool(a < b) ? a : b;
			static min(a: float64, b: float64): float64 := bool(a < b) ? a : b;
			static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
			static max(a: int64, b: int64): int64 := bool(a > b) ? a : b;
			static max(a: uint32, b: uint32): uint32 := bool(a > b) ? a : b;
			static max(a: uint64, b: uint64): uint64 := bool(a > b) ? a : b;
			static max(a: float32, b: float32): float32 := bool(a > b) ? a : b;
			static max(a: float64, b: float64): float64 := bool(a > b) ? a : b;
			static clamp(t: int32, a: int32, b: int32): int32 := bool(t < a) ? a : bool(t > b) ? b : t;
			static clamp(t: int64, a: int64, b: int64): int64 := bool(t < a) ? a : bool(t > b) ? b : t;
			static clamp(t: uint32, a: uint32, b: uint32): uint32 := bool(t < a) ? a : bool(t > b) ? b : t;
			static clamp(t: uint64, a: uint64, b: uint64): uint64 := bool(t < a) ? a : bool(t > b) ? b : t;
			static clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
			static min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static mean(data: float64[]): float64 := {
				return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float32(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float64(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else if (bool(i == 1)) {
					float64(x := float64((1) - x));
					bool(complement := true);
				}
				else if (bool(i == 2)) {
					bool(negate := bool(!negate));
					bool(complement := true);
				}
				else if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(emit(void(struct(a), neg.p2d)));
		static add(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), add.p2d)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static inv(a: Complex): Complex := {
			d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		static vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))));
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static add(a: float32, b: vec4f): vec4f := add(void(vec4f(a), b));
		static add(a: vec4f, b: float32): vec4f := add(void(a, vec4f(b)));
		static sub(a: float32, b: vec4f): vec4f := sub(void(vec4f(a), b));
		static sub(a: vec4f, b: float32): vec4f := sub(void(a, vec4f(b)));
		static mul(a: float32, b: vec4f): vec4f := mul(void(vec4f(a), b));
		static mul(a: vec4f, b: float32): vec4f := mul(void(a, vec4f(b)));
		static div(a: float32, b: vec4f): vec4f := div(void(vec4f(a), b));
		static div(a: vec4f, b: float32): vec4f := div(void(a, vec4f(b)));
		static min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(void(max(void(vec, min)), max));
		static clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(void(void(vec, vec4f(min)), vec4f(max)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static transpose(const mat: mat4f): mat4f := {
			return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := {
			xx: float32 := float32(direction.x * direction.x);
			yy: float32 := float32(direction.y * direction.y);
			zz: float32 := float32(direction.z * direction.z);
			xy: float32 := float32(direction.x * direction.y);
			xz: float32 := float32(direction.x * direction.z);
			yz: float32 := float32(direction.y * direction.z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			tmp: vec4f := mul(void(direction, s));
			return void(.result := {
			void(.result.xx := float32(float32(k * xx) + c));
			void(.result.xy := float32(float32(k * xy) - tmp.z));
			void(.result.xz := float32(float32(k * xz) + tmp.y));
			void(.result.xw := (0));
			void(.result.yx := float32(float32(k * xy) + tmp.z));
			void(.result.yy := float32(float32(k * yy) + c));
			void(.result.yz := float32(float32(k * yz) - tmp.x));
			void(.result.yw := (0));
			void(.result.zx := float32(float32(k * xz) - tmp.y));
			void(.result.zy := float32(float32(k * yz) + tmp.x));
			void(.result.zz := float32(float32(k * zz) + c));
			void(.result.zw := (0));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static add(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), add.p2d)));
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)));
		static div(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), div.p2d)));
		static min(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), min.p2d)));
		static max(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), max.p2d)));
		static ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static toHex(value: int32): int32 := int32("0123456789abcdef"[int32(value & 15)]);
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static equals(const str: char[*], const with: char[*]): bool := bool(compare(void(void(str, with), caseCmp)) == 0);
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const sign: char := 0;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			if (bool((value) == null)) {
				return int32(.result := append(void(void(output, pos), "NULL")));
			}
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, radix: int32, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((format.sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := format.sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), uint64(value)), format));
		static append(output: char[], pos: int32, radix: int32, value: int64, const format: FormatFlags): int32 := {
			signedFormat: FormatFlags := {
				void(signedFormat.sign := bool(value < (0)) ? '-' : format.sign);
				void(signedFormat.precision := format.precision);
				void(signedFormat.padLen := format.padLen);
				void(signedFormat.padChr := format.padChr);
			};
			if (bool(value < (0))) {
				int64(value := int64(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), radix), uint64(value)), signedFormat)));
		};
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), int64(value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), int64(value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), int64(value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 10), int64(value)), format));
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			static const formatDec: FormatFlags := {
				void(formatDec.sign := (0));
				void(formatDec.precision := 0);
				void(formatDec.padChr := (0));
				void(formatDec.padLen := 0);
			};
			formatInt: FormatFlags := {
				void(formatInt.sign := bool(value < (0)) ? '-' : format.sign);
				void(formatInt.precision := 10);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(int32(format.padLen - format.precision) - 1));
			};
			end: int32 := Math.min(void(int32(uint32(output.length - (1))), int32(pos + format.padLen)));
			fraction: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(pos, uint64(int64(value))), formatInt))));
			static const eps: float64 := 0.000010;
			if (bool(bool(fraction < eps) && bool(pos >= end))) {
				return int32(.result := pos);
			}
			int32(pos := append(void(output, void(pos, "."))));
			max: int32 := Math.min(void(int32(uint32(output.length - (1))), int32(pos + format.precision)));
			if (bool(format.precision == 0)) {
				int32(max := (uint32(output.length - (1))));
			}
			for ( ; bool((bool(bool(fraction > eps) && bool(pos < max))) || bool(pos < end)); ) {
				float64(fraction := Math.modf(void(float64(fraction * (10)), float64(&value))));
				int32(pos := append(void(output, void(void(pos, uint64(int64(value))), formatDec))));
			}
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.sign := (0));
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static float64(const value: char[]): float64 := {
			sign: float64 := 1;
			result: float64 := 0;
			decimal: float64 := 0;
			for (i: int32 := 0; bool(bool(i < (value.length)) && bool((value[i]) != 0)); int32(i := int32(i + 1))) {
				chr: char := value[i];
				if (bool(bool(chr >= '0') && bool(chr <= '9'))) {
					float64(result := float64(float64(result * (10)) + ((char(chr - '0')))));
					float64(decimal := float64(decimal * (10)));
				}
				else if (bool(chr == '.')) {
					if (bool(decimal != (0))) {
						return float64(.result := Math.nan);
					}
					float64(decimal := (1));
				}
				else if (bool(bool(chr == '-') && bool(i == 0))) {
					float64(sign := (int32(-1)));
				}
				else if (bool(bool(chr == '+') && bool(i == 0))) {
					float64(sign := (1));
				}
				else {
					return float64(.result := Math.nan);
				}
			}
			if (bool(decimal == (0))) {
				if (bool(value.length > (0))) {
					return float64(.result := float64(sign * result));
				}
			}
			return float64(.result := float64(float64(sign * result) / decimal));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static emitNfcF32: float32 := emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static noError(ptr: pointer): void := {
		};
		static stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static variable: int32;
		static const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static valInitImplicit: ComplexVal := {
			void(valInitImplicit.re := (8));
			void(valInitImplicit.im := (0));
		};
		static objInitImplicit: ComplexObj := {
			void(objInitImplicit := create(ComplexObj));
			void(objInitImplicit.re := (8));
			void(objInitImplicit.im := (0));
		};
		static objInitExplicit: object := {
			void(objInitExplicit := create(ComplexObj));
			void(objInitExplicit.re := (8));
			void(objInitExplicit.im := (0));
		};
		static empty(): void := {
		};
		static funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := typeofRecord.size;
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := typeofBase.size;
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				void(globalRec.constant := 4);
				void(globalRec.member := (0));
			};
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			static virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		RecordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else if (bool(t == 1)) {
				raise(void(void(void(raise.debug, 10), "t == 1"), t));
			}
			else if (bool(t == 2)) {
				raise(void(void(void(raise.debug, 10), "t == 2"), t));
			}
			else if (bool(t == 3)) {
				raise(void(void(void(raise.debug, 10), "t == 3"), t));
			}
			else if (bool(t == 4)) {
				raise(void(void(void(raise.debug, 10), "t == 4"), t));
			}
			else if (bool(t == 5)) {
				raise(void(void(void(raise.debug, 10), "t == 5"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (13419 bytes: <.main @0646fc> - <.main+13419 @067b67>)
	cmplStd/lib/text/string.ci:155: (14 bytes: <.main @0646fc> - <.main+14 @06470a>): static const whiteSpace: char[] := " \t\n\r"
	<.main @0646fc>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @064701>    : 1f 17 30 03 00             load.ref <@033017> ;" \t\n\r"
	<.main+10 @064706>   : 23 00 2c 06                store.m64 <@062c00> ;append.whiteSpace
	cmplStd/lib/text/string.ci:156: (14 bytes: <.main+14 @06470a> - <.main+28 @064718>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @06470a>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @06470f>   : 1f 28 30 03 00             load.ref <@033028> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @064714>   : 23 08 2c 06                store.m64 <@062c08> ;append.radixDigits
	cmplStd/lib/text/string.ci:257: (24 bytes: <.main+28 @064718> - <.main+52 @064730>): static const formatDec: FormatFlags := {...}
	:: (7 bytes: <.main+28 @064718> - <.main+35 @06471f>): formatDec.sign := (0);
	<.main+28 @064718>   : 19                         load.z32
	<.main+29 @064719>   : 1f 08 2f 06 00             load.ref <@062f08> ;append.formatDec
	<.main+34 @06471e>   : 2b                         store.i8
	:: (5 bytes: <.main+35 @06471f> - <.main+40 @064724>): formatDec.precision := 0;
	<.main+35 @06471f>   : 19                         load.z32
	<.main+36 @064720>   : 24 0c 2f 06                store.m32 <@062f0c> ;append.formatDec+4
	:: (7 bytes: <.main+40 @064724> - <.main+47 @06472b>): formatDec.padChr := (0);
	<.main+40 @064724>   : 19                         load.z32
	<.main+41 @064725>   : 1f 10 2f 06 00             load.ref <@062f10> ;append.formatDec+8
	<.main+46 @06472a>   : 2b                         store.i8
	:: (5 bytes: <.main+47 @06472b> - <.main+52 @064730>): formatDec.padLen := 0;
	<.main+47 @06472b>   : 19                         load.z32
	<.main+48 @06472c>   : 24 14 2f 06                store.m32 <@062f14> ;append.formatDec+12
	cmplStd/lib/text/string.ci:270: (13 bytes: <.main+52 @064730> - <.main+65 @06473d>): static const eps: float64 := 0.000010
	<.main+52 @064730>   : 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+61 @064739>   : 23 18 2f 06                store.m64 <@062f18> ;append.eps
	cmplStd/lib/text/string.ci:295: (24 bytes: <.main+65 @06473d> - <.main+89 @064755>): static const format: FormatFlags := {...}
	:: (7 bytes: <.main+65 @06473d> - <.main+72 @064744>): format.sign := (0);
	<.main+65 @06473d>   : 19                         load.z32
	<.main+66 @06473e>   : 1f b8 30 06 00             load.ref <@0630b8> ;append.format
	<.main+71 @064743>   : 2b                         store.i8
	:: (5 bytes: <.main+72 @064744> - <.main+77 @064749>): format.precision := 0;
	<.main+72 @064744>   : 19                         load.z32
	<.main+73 @064745>   : 24 bc 30 06                store.m32 <@0630bc> ;append.format+4
	:: (7 bytes: <.main+77 @064749> - <.main+84 @064750>): format.padChr := (0);
	<.main+77 @064749>   : 19                         load.z32
	<.main+78 @06474a>   : 1f c0 30 06 00             load.ref <@0630c0> ;append.format+8
	<.main+83 @06474f>   : 2b                         store.i8
	:: (5 bytes: <.main+84 @064750> - <.main+89 @064755>): format.padLen := 0;
	<.main+84 @064750>   : 19                         load.z32
	<.main+85 @064751>   : 24 c4 30 06                store.m32 <@0630c4> ;append.format+12
	cmplStd/test/lang/emit.ci:3: (5 bytes: <.main+89 @064755> - <.main+94 @06475a>): static emitldz32: int32 := emit(load.z32)
	<.main+89 @064755>   : 19                         load.z32
	<.main+90 @064756>   : 24 40 32 06                store.m32 <@063240> ;emitldz32
	cmplStd/test/lang/emit.ci:4: (5 bytes: <.main+94 @06475a> - <.main+99 @06475f>): static emitldz64: int64 := emit(load.z64)
	<.main+94 @06475a>   : 1a                         load.z64
	<.main+95 @06475b>   : 23 48 32 06                store.m64 <@063248> ;emitldz64
	cmplStd/test/lang/emit.ci:6: (9 bytes: <.main+99 @06475f> - <.main+108 @064768>): static emitA: int32 := 42
	<.main+99 @06475f>   : 1c 2a 00 00 00             load.c32 42
	<.main+104 @064764>  : 24 50 32 06                store.m32 <@063250> ;emitA
	cmplStd/test/lang/emit.ci:7: (9 bytes: <.main+108 @064768> - <.main+117 @064771>): static emitB: int32 := 96
	<.main+108 @064768>  : 1c 60 00 00 00             load.c32 96
	<.main+113 @06476d>  : 24 58 32 06                store.m32 <@063258> ;emitB
	cmplStd/test/lang/emit.ci:10: (13 bytes: <.main+117 @064771> - <.main+130 @06477e>): static emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+117 @064771>  : 20 50 32 06                load.m32 <@063250> ;emitA
	<.main+121 @064775>  : 20 58 32 06                load.m32 <@063258> ;emitB
	<.main+125 @064779>  : 51                         add.i32
	<.main+126 @06477a>  : 24 60 32 06                store.m32 <@063260> ;emitAddI32
	cmplStd/test/lang/emit.ci:13: (15 bytes: <.main+130 @06477e> - <.main+145 @06478d>): static emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+130 @06477e>  : 1c 0a 00 00 00             load.c32 10
	<.main+135 @064783>  : 1c 05 00 00 00             load.c32 5
	<.main+140 @064788>  : 54                         div.i32
	<.main+141 @064789>  : 24 68 32 06                store.m32 <@063268> ;emitDivI32
	cmplStd/test/lang/emit.ci:16: (19 bytes: <.main+145 @06478d> - <.main+164 @0647a0>): static emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+145 @06478d>  : 7f c3 f5 48 40             load.f32 3.140000
	<.main+150 @064792>  : 7f 00 00 00 40             load.f32 2.000000
	<.main+155 @064797>  : 74                         div.f32
	<.main+156 @064798>  : 01 22 00 00                nfc(34) ;float32.sin(x: float32): float32
	<.main+160 @06479c>  : 24 70 32 06                store.m32 <@063270> ;emitNfcF32
	cmplStd/test/lang/emit.ci:23: (9 bytes: <.main+164 @0647a0> - <.main+173 @0647a9>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+164 @0647a0>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+169 @0647a5>  : 24 78 32 06                store.m32 <@063278> ;emitFloatAsInt1
	cmplStd/test/lang/emit.ci:24: (10 bytes: <.main+173 @0647a9> - <.main+183 @0647b3>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+173 @0647a9>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+178 @0647ae>  : 5b                         i32.2i64
	<.main+179 @0647af>  : 23 80 32 06                store.m64 <@063280> ;emitFloatAsInt2
	cmplStd/test/lang/emit.ci:25: (14 bytes: <.main+183 @0647b3> - <.main+197 @0647c1>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+183 @0647b3>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+192 @0647bc>  : 6a                         i64.2i32
	<.main+193 @0647bd>  : 24 88 32 06                store.m32 <@063288> ;emitFloatAsInt3
	cmplStd/test/lang/emit.ci:26: (13 bytes: <.main+197 @0647c1> - <.main+210 @0647ce>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+197 @0647c1>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+206 @0647ca>  : 23 90 32 06                store.m64 <@063290> ;emitFloatAsInt4
	cmplStd/test/lang/emit.ci:29: (14 bytes: <.main+210 @0647ce> - <.main+224 @0647dc>): static emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+210 @0647ce>  : 1c 03 00 00 00             load.c32 3
	<.main+215 @0647d3>  : 1f 6d c4 03 00             load.ref <@03c46d> ;"string"
	<.main+220 @0647d8>  : 23 98 32 06                store.m64 <@063298> ;emitSlice
	cmplStd/test/lang/inlineMacros.ci:10: (9 bytes: <.main+224 @0647dc> - <.main+233 @0647e5>): static i3: int32 := 3
	<.main+224 @0647dc>  : 1c 03 00 00 00             load.c32 3
	<.main+229 @0647e1>  : 24 a0 32 06                store.m32 <@0632a0> ;i3
	cmplStd/test/lang/inlineMacros.ci:11: (9 bytes: <.main+233 @0647e5> - <.main+242 @0647ee>): static i6: int32 := 6
	<.main+233 @0647e5>  : 1c 06 00 00 00             load.c32 6
	<.main+238 @0647ea>  : 24 a8 32 06                store.m32 <@0632a8> ;i6
	cmplStd/test/lang/inlineMacros.ci:12: (9 bytes: <.main+242 @0647ee> - <.main+251 @0647f7>): static i2: int32 := 2
	<.main+242 @0647ee>  : 1c 02 00 00 00             load.c32 2
	<.main+247 @0647f3>  : 24 b0 32 06                store.m32 <@0632b0> ;i2
	cmplStd/test/lang/inlineMacros.ci:13: (9 bytes: <.main+251 @0647f7> - <.main+260 @064800>): static i8: int32 := 8
	<.main+251 @0647f7>  : 1c 08 00 00 00             load.c32 8
	<.main+256 @0647fc>  : 24 b8 32 06                store.m32 <@0632b8> ;i8
	cmplStd/test/lang/inlineMacros.ci:15: (5 bytes: <.main+260 @064800> - <.main+265 @064805>): static zeroVal: int32 := zero(3, 6)
	<.main+260 @064800>  : 19                         load.z32
	<.main+261 @064801>  : 24 c0 32 06                store.m32 <@0632c0> ;zeroVal
	cmplStd/test/lang/inlineMacros.ci:16: (5 bytes: <.main+265 @064805> - <.main+270 @06480a>): static zeroVar: int32 := zero(i3, i6)
	<.main+265 @064805>  : 19                         load.z32
	<.main+266 @064806>  : 24 c8 32 06                store.m32 <@0632c8> ;zeroVar
	cmplStd/test/lang/inlineMacros.ci:17: (5 bytes: <.main+270 @06480a> - <.main+275 @06480f>): static zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+270 @06480a>  : 19                         load.z32
	<.main+271 @06480b>  : 24 d0 32 06                store.m32 <@0632d0> ;zeroXpr
	cmplStd/test/lang/inlineMacros.ci:19: (9 bytes: <.main+275 @06480f> - <.main+284 @064818>): static lastVal: int32 := last(3, 6)
	<.main+275 @06480f>  : 1c 06 00 00 00             load.c32 6
	<.main+280 @064814>  : 24 d8 32 06                store.m32 <@0632d8> ;lastVal
	cmplStd/test/lang/inlineMacros.ci:20: (8 bytes: <.main+284 @064818> - <.main+292 @064820>): static lastVar: int32 := last(i3, i6)
	<.main+284 @064818>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+288 @06481c>  : 24 e0 32 06                store.m32 <@0632e0> ;lastVar
	cmplStd/test/lang/inlineMacros.ci:21: (16 bytes: <.main+292 @064820> - <.main+308 @064830>): static lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+292 @064820>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+296 @064824>  : 0c 01 00 00                inc.i32(+1)
	<.main+300 @064828>  : 0c ff ff ff                inc.i32(-1)
	<.main+304 @06482c>  : 24 e8 32 06                store.m32 <@0632e8> ;lastXpr
	cmplStd/test/lang/inlineMacros.ci:23: (13 bytes: <.main+308 @064830> - <.main+321 @06483d>): static sum2Val: int32 := sum(3, 6)
	<.main+308 @064830>  : 1c 03 00 00 00             load.c32 3
	<.main+313 @064835>  : 0c 06 00 00                inc.i32(+6)
	<.main+317 @064839>  : 24 f0 32 06                store.m32 <@0632f0> ;sum2Val
	cmplStd/test/lang/inlineMacros.ci:24: (13 bytes: <.main+321 @06483d> - <.main+334 @06484a>): static sum2Var: int32 := sum(i3, i6)
	<.main+321 @06483d>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+325 @064841>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+329 @064845>  : 51                         add.i32
	<.main+330 @064846>  : 24 f8 32 06                store.m32 <@0632f8> ;sum2Var
	cmplStd/test/lang/inlineMacros.ci:25: (25 bytes: <.main+334 @06484a> - <.main+359 @064863>): static sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+334 @06484a>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+338 @06484e>  : 0c 01 00 00                inc.i32(+1)
	<.main+342 @064852>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+346 @064856>  : 0c 01 00 00                inc.i32(+1)
	<.main+350 @06485a>  : 51                         add.i32
	<.main+351 @06485b>  : 0c fe ff ff                inc.i32(-2)
	<.main+355 @06485f>  : 24 00 33 06                store.m32 <@063300> ;sum2Xpr
	cmplStd/test/lang/inlineMacros.ci:27: (28 bytes: <.main+359 @064863> - <.main+387 @06487f>): static any2Val: int32 := any(3, 6)
	<.main+359 @064863>  : 1c 03 00 00 00             load.c32 3
	<.main+364 @064868>  : 10 00                      dup.x32 sp(0)
	<.main+366 @06486a>  : 06 0a 00 00                jz <.main+376 @064874>
	<.main+370 @06486e>  : 10 00                      dup.x32 sp(0)
	<.main+372 @064870>  : 04 09 00 00                jmp <.main+381 @064879>
	<.main+376 @064874>  : 1c 06 00 00 00             load.c32 6
	<.main+381 @064879>  : 13 01                      set.x32 sp(1)
	<.main+383 @06487b>  : 24 08 33 06                store.m32 <@063308> ;any2Val
	cmplStd/test/lang/inlineMacros.ci:28: (26 bytes: <.main+387 @06487f> - <.main+413 @064899>): static any2Var: int32 := any(i3, i6)
	<.main+387 @06487f>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+391 @064883>  : 10 00                      dup.x32 sp(0)
	<.main+393 @064885>  : 06 0a 00 00                jz <.main+403 @06488f>
	<.main+397 @064889>  : 10 00                      dup.x32 sp(0)
	<.main+399 @06488b>  : 04 08 00 00                jmp <.main+407 @064893>
	<.main+403 @06488f>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+407 @064893>  : 13 01                      set.x32 sp(1)
	<.main+409 @064895>  : 24 10 33 06                store.m32 <@063310> ;any2Var
	cmplStd/test/lang/inlineMacros.ci:29: (38 bytes: <.main+413 @064899> - <.main+451 @0648bf>): static any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+413 @064899>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+417 @06489d>  : 0c 01 00 00                inc.i32(+1)
	<.main+421 @0648a1>  : 10 00                      dup.x32 sp(0)
	<.main+423 @0648a3>  : 06 0a 00 00                jz <.main+433 @0648ad>
	<.main+427 @0648a7>  : 10 00                      dup.x32 sp(0)
	<.main+429 @0648a9>  : 04 0c 00 00                jmp <.main+441 @0648b5>
	<.main+433 @0648ad>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+437 @0648b1>  : 0c 01 00 00                inc.i32(+1)
	<.main+441 @0648b5>  : 13 01                      set.x32 sp(1)
	<.main+443 @0648b7>  : 0c ff ff ff                inc.i32(-1)
	<.main+447 @0648bb>  : 24 18 33 06                store.m32 <@063318> ;any2Xpr
	cmplStd/test/lang/inlineMacros.ci:31: (37 bytes: <.main+451 @0648bf> - <.main+488 @0648e4>): static min2Val: int32 := min(3, 6)
	<.main+451 @0648bf>  : 1c 03 00 00 00             load.c32 3
	<.main+456 @0648c4>  : 1c 06 00 00 00             load.c32 6
	<.main+461 @0648c9>  : 10 01                      dup.x32 sp(1)
	<.main+463 @0648cb>  : 10 01                      dup.x32 sp(1)
	<.main+465 @0648cd>  : 58                         clt.i32
	<.main+466 @0648ce>  : 06 0a 00 00                jz <.main+476 @0648d8>
	<.main+470 @0648d2>  : 10 01                      dup.x32 sp(1)
	<.main+472 @0648d4>  : 04 06 00 00                jmp <.main+478 @0648da>
	<.main+476 @0648d8>  : 10 00                      dup.x32 sp(0)
	<.main+478 @0648da>  : 13 02                      set.x32 sp(2)
	<.main+480 @0648dc>  : 09 fc ff ff                inc.sp(-4)
	<.main+484 @0648e0>  : 24 20 33 06                store.m32 <@063320> ;min2Val
	cmplStd/test/lang/inlineMacros.ci:32: (35 bytes: <.main+488 @0648e4> - <.main+523 @064907>): static min2Var: int32 := min(i3, i6)
	<.main+488 @0648e4>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+492 @0648e8>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+496 @0648ec>  : 10 01                      dup.x32 sp(1)
	<.main+498 @0648ee>  : 10 01                      dup.x32 sp(1)
	<.main+500 @0648f0>  : 58                         clt.i32
	<.main+501 @0648f1>  : 06 0a 00 00                jz <.main+511 @0648fb>
	<.main+505 @0648f5>  : 10 01                      dup.x32 sp(1)
	<.main+507 @0648f7>  : 04 06 00 00                jmp <.main+513 @0648fd>
	<.main+511 @0648fb>  : 10 00                      dup.x32 sp(0)
	<.main+513 @0648fd>  : 13 02                      set.x32 sp(2)
	<.main+515 @0648ff>  : 09 fc ff ff                inc.sp(-4)
	<.main+519 @064903>  : 24 28 33 06                store.m32 <@063328> ;min2Var
	cmplStd/test/lang/inlineMacros.ci:33: (47 bytes: <.main+523 @064907> - <.main+570 @064936>): static min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+523 @064907>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+527 @06490b>  : 0c 01 00 00                inc.i32(+1)
	<.main+531 @06490f>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+535 @064913>  : 0c 01 00 00                inc.i32(+1)
	<.main+539 @064917>  : 10 01                      dup.x32 sp(1)
	<.main+541 @064919>  : 10 01                      dup.x32 sp(1)
	<.main+543 @06491b>  : 58                         clt.i32
	<.main+544 @06491c>  : 06 0a 00 00                jz <.main+554 @064926>
	<.main+548 @064920>  : 10 01                      dup.x32 sp(1)
	<.main+550 @064922>  : 04 06 00 00                jmp <.main+556 @064928>
	<.main+554 @064926>  : 10 00                      dup.x32 sp(0)
	<.main+556 @064928>  : 13 02                      set.x32 sp(2)
	<.main+558 @06492a>  : 09 fc ff ff                inc.sp(-4)
	<.main+562 @06492e>  : 0c ff ff ff                inc.i32(-1)
	<.main+566 @064932>  : 24 30 33 06                store.m32 <@063330> ;min2Xpr
	cmplStd/test/lang/inlineMacros.ci:35: (37 bytes: <.main+570 @064936> - <.main+607 @06495b>): static max2Val: int32 := max(3, 6)
	<.main+570 @064936>  : 1c 03 00 00 00             load.c32 3
	<.main+575 @06493b>  : 1c 06 00 00 00             load.c32 6
	<.main+580 @064940>  : 10 01                      dup.x32 sp(1)
	<.main+582 @064942>  : 10 01                      dup.x32 sp(1)
	<.main+584 @064944>  : 59                         cgt.i32
	<.main+585 @064945>  : 06 0a 00 00                jz <.main+595 @06494f>
	<.main+589 @064949>  : 10 01                      dup.x32 sp(1)
	<.main+591 @06494b>  : 04 06 00 00                jmp <.main+597 @064951>
	<.main+595 @06494f>  : 10 00                      dup.x32 sp(0)
	<.main+597 @064951>  : 13 02                      set.x32 sp(2)
	<.main+599 @064953>  : 09 fc ff ff                inc.sp(-4)
	<.main+603 @064957>  : 24 38 33 06                store.m32 <@063338> ;max2Val
	cmplStd/test/lang/inlineMacros.ci:36: (35 bytes: <.main+607 @06495b> - <.main+642 @06497e>): static max2Var: int32 := max(i3, i6)
	<.main+607 @06495b>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+611 @06495f>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+615 @064963>  : 10 01                      dup.x32 sp(1)
	<.main+617 @064965>  : 10 01                      dup.x32 sp(1)
	<.main+619 @064967>  : 59                         cgt.i32
	<.main+620 @064968>  : 06 0a 00 00                jz <.main+630 @064972>
	<.main+624 @06496c>  : 10 01                      dup.x32 sp(1)
	<.main+626 @06496e>  : 04 06 00 00                jmp <.main+632 @064974>
	<.main+630 @064972>  : 10 00                      dup.x32 sp(0)
	<.main+632 @064974>  : 13 02                      set.x32 sp(2)
	<.main+634 @064976>  : 09 fc ff ff                inc.sp(-4)
	<.main+638 @06497a>  : 24 40 33 06                store.m32 <@063340> ;max2Var
	cmplStd/test/lang/inlineMacros.ci:37: (47 bytes: <.main+642 @06497e> - <.main+689 @0649ad>): static max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+642 @06497e>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+646 @064982>  : 0c 01 00 00                inc.i32(+1)
	<.main+650 @064986>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+654 @06498a>  : 0c 01 00 00                inc.i32(+1)
	<.main+658 @06498e>  : 10 01                      dup.x32 sp(1)
	<.main+660 @064990>  : 10 01                      dup.x32 sp(1)
	<.main+662 @064992>  : 59                         cgt.i32
	<.main+663 @064993>  : 06 0a 00 00                jz <.main+673 @06499d>
	<.main+667 @064997>  : 10 01                      dup.x32 sp(1)
	<.main+669 @064999>  : 04 06 00 00                jmp <.main+675 @06499f>
	<.main+673 @06499d>  : 10 00                      dup.x32 sp(0)
	<.main+675 @06499f>  : 13 02                      set.x32 sp(2)
	<.main+677 @0649a1>  : 09 fc ff ff                inc.sp(-4)
	<.main+681 @0649a5>  : 0c ff ff ff                inc.i32(-1)
	<.main+685 @0649a9>  : 24 48 33 06                store.m32 <@063348> ;max2Xpr
	cmplStd/test/lang/inlineMacros.ci:41: (25 bytes: <.main+689 @0649ad> - <.main+714 @0649c6>): static sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+689 @0649ad>  : 1c 03 00 00 00             load.c32 3
	<.main+694 @0649b2>  : 1c 06 00 00 00             load.c32 6
	<.main+699 @0649b7>  : 1c 02 00 00 00             load.c32 2
	<.main+704 @0649bc>  : 0c 08 00 00                inc.i32(+8)
	<.main+708 @0649c0>  : 51                         add.i32
	<.main+709 @0649c1>  : 51                         add.i32
	<.main+710 @0649c2>  : 24 50 33 06                store.m32 <@063350> ;sumRlVal
	cmplStd/test/lang/inlineMacros.ci:42: (21 bytes: <.main+714 @0649c6> - <.main+735 @0649db>): static sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+714 @0649c6>  : 1c 03 00 00 00             load.c32 3
	<.main+719 @0649cb>  : 0c 06 00 00                inc.i32(+6)
	<.main+723 @0649cf>  : 0c 02 00 00                inc.i32(+2)
	<.main+727 @0649d3>  : 0c 08 00 00                inc.i32(+8)
	<.main+731 @0649d7>  : 24 58 33 06                store.m32 <@063358> ;sumLrVal
	cmplStd/test/lang/inlineMacros.ci:43: (23 bytes: <.main+735 @0649db> - <.main+758 @0649f2>): static sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+735 @0649db>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+739 @0649df>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+743 @0649e3>  : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+747 @0649e7>  : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+751 @0649eb>  : 51                         add.i32
	<.main+752 @0649ec>  : 51                         add.i32
	<.main+753 @0649ed>  : 51                         add.i32
	<.main+754 @0649ee>  : 24 60 33 06                store.m32 <@063360> ;sumRlVar
	cmplStd/test/lang/inlineMacros.ci:44: (23 bytes: <.main+758 @0649f2> - <.main+781 @064a09>): static sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+758 @0649f2>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+762 @0649f6>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+766 @0649fa>  : 51                         add.i32
	<.main+767 @0649fb>  : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+771 @0649ff>  : 51                         add.i32
	<.main+772 @064a00>  : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+776 @064a04>  : 51                         add.i32
	<.main+777 @064a05>  : 24 68 33 06                store.m32 <@063368> ;sumLrVar
	cmplStd/test/lang/inlineMacros.ci:45: (43 bytes: <.main+781 @064a09> - <.main+824 @064a34>): static sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+781 @064a09>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+785 @064a0d>  : 0c 01 00 00                inc.i32(+1)
	<.main+789 @064a11>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+793 @064a15>  : 0c 01 00 00                inc.i32(+1)
	<.main+797 @064a19>  : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+801 @064a1d>  : 0c 01 00 00                inc.i32(+1)
	<.main+805 @064a21>  : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+809 @064a25>  : 0c 01 00 00                inc.i32(+1)
	<.main+813 @064a29>  : 51                         add.i32
	<.main+814 @064a2a>  : 51                         add.i32
	<.main+815 @064a2b>  : 51                         add.i32
	<.main+816 @064a2c>  : 0c fc ff ff                inc.i32(-4)
	<.main+820 @064a30>  : 24 70 33 06                store.m32 <@063370> ;sumRlXpr
	cmplStd/test/lang/inlineMacros.ci:46: (43 bytes: <.main+824 @064a34> - <.main+867 @064a5f>): static sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+824 @064a34>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+828 @064a38>  : 0c 01 00 00                inc.i32(+1)
	<.main+832 @064a3c>  : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+836 @064a40>  : 0c 01 00 00                inc.i32(+1)
	<.main+840 @064a44>  : 51                         add.i32
	<.main+841 @064a45>  : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+845 @064a49>  : 0c 01 00 00                inc.i32(+1)
	<.main+849 @064a4d>  : 51                         add.i32
	<.main+850 @064a4e>  : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+854 @064a52>  : 0c 01 00 00                inc.i32(+1)
	<.main+858 @064a56>  : 51                         add.i32
	<.main+859 @064a57>  : 0c fc ff ff                inc.i32(-4)
	<.main+863 @064a5b>  : 24 78 33 06                store.m32 <@063378> ;sumLrXpr
	cmplStd/test/lang/inlineMacros.ci:50: (66 bytes: <.main+867 @064a5f> - <.main+933 @064aa1>): static anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+867 @064a5f>  : 1c 03 00 00 00             load.c32 3
	<.main+872 @064a64>  : 10 00                      dup.x32 sp(0)
	<.main+874 @064a66>  : 06 0a 00 00                jz <.main+884 @064a70>
	<.main+878 @064a6a>  : 10 00                      dup.x32 sp(0)
	<.main+880 @064a6c>  : 04 2f 00 00                jmp <.main+927 @064a9b>
	<.main+884 @064a70>  : 1c 06 00 00 00             load.c32 6
	<.main+889 @064a75>  : 10 00                      dup.x32 sp(0)
	<.main+891 @064a77>  : 06 0a 00 00                jz <.main+901 @064a81>
	<.main+895 @064a7b>  : 10 00                      dup.x32 sp(0)
	<.main+897 @064a7d>  : 04 1c 00 00                jmp <.main+925 @064a99>
	<.main+901 @064a81>  : 1c 02 00 00 00             load.c32 2
	<.main+906 @064a86>  : 10 00                      dup.x32 sp(0)
	<.main+908 @064a88>  : 06 0a 00 00                jz <.main+918 @064a92>
	<.main+912 @064a8c>  : 10 00                      dup.x32 sp(0)
	<.main+914 @064a8e>  : 04 09 00 00                jmp <.main+923 @064a97>
	<.main+918 @064a92>  : 1c 08 00 00 00             load.c32 8
	<.main+923 @064a97>  : 13 01                      set.x32 sp(1)
	<.main+925 @064a99>  : 13 01                      set.x32 sp(1)
	<.main+927 @064a9b>  : 13 01                      set.x32 sp(1)
	<.main+929 @064a9d>  : 24 80 33 06                store.m32 <@063380> ;anyRlVal
	cmplStd/test/lang/inlineMacros.ci:51: (66 bytes: <.main+933 @064aa1> - <.main+999 @064ae3>): static anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+933 @064aa1>  : 1c 03 00 00 00             load.c32 3
	<.main+938 @064aa6>  : 10 00                      dup.x32 sp(0)
	<.main+940 @064aa8>  : 06 0a 00 00                jz <.main+950 @064ab2>
	<.main+944 @064aac>  : 10 00                      dup.x32 sp(0)
	<.main+946 @064aae>  : 04 09 00 00                jmp <.main+955 @064ab7>
	<.main+950 @064ab2>  : 1c 06 00 00 00             load.c32 6
	<.main+955 @064ab7>  : 13 01                      set.x32 sp(1)
	<.main+957 @064ab9>  : 10 00                      dup.x32 sp(0)
	<.main+959 @064abb>  : 06 0a 00 00                jz <.main+969 @064ac5>
	<.main+963 @064abf>  : 10 00                      dup.x32 sp(0)
	<.main+965 @064ac1>  : 04 09 00 00                jmp <.main+974 @064aca>
	<.main+969 @064ac5>  : 1c 02 00 00 00             load.c32 2
	<.main+974 @064aca>  : 13 01                      set.x32 sp(1)
	<.main+976 @064acc>  : 10 00                      dup.x32 sp(0)
	<.main+978 @064ace>  : 06 0a 00 00                jz <.main+988 @064ad8>
	<.main+982 @064ad2>  : 10 00                      dup.x32 sp(0)
	<.main+984 @064ad4>  : 04 09 00 00                jmp <.main+993 @064add>
	<.main+988 @064ad8>  : 1c 08 00 00 00             load.c32 8
	<.main+993 @064add>  : 13 01                      set.x32 sp(1)
	<.main+995 @064adf>  : 24 88 33 06                store.m32 <@063388> ;anyLrVal
	cmplStd/test/lang/inlineMacros.ci:52: (62 bytes: <.main+999 @064ae3> - <.main+1061 @064b21>): static anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+999 @064ae3>  : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1003 @064ae7> : 10 00                      dup.x32 sp(0)
	<.main+1005 @064ae9> : 06 0a 00 00                jz <.main+1015 @064af3>
	<.main+1009 @064aed> : 10 00                      dup.x32 sp(0)
	<.main+1011 @064aef> : 04 2c 00 00                jmp <.main+1055 @064b1b>
	<.main+1015 @064af3> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1019 @064af7> : 10 00                      dup.x32 sp(0)
	<.main+1021 @064af9> : 06 0a 00 00                jz <.main+1031 @064b03>
	<.main+1025 @064afd> : 10 00                      dup.x32 sp(0)
	<.main+1027 @064aff> : 04 1a 00 00                jmp <.main+1053 @064b19>
	<.main+1031 @064b03> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1035 @064b07> : 10 00                      dup.x32 sp(0)
	<.main+1037 @064b09> : 06 0a 00 00                jz <.main+1047 @064b13>
	<.main+1041 @064b0d> : 10 00                      dup.x32 sp(0)
	<.main+1043 @064b0f> : 04 08 00 00                jmp <.main+1051 @064b17>
	<.main+1047 @064b13> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1051 @064b17> : 13 01                      set.x32 sp(1)
	<.main+1053 @064b19> : 13 01                      set.x32 sp(1)
	<.main+1055 @064b1b> : 13 01                      set.x32 sp(1)
	<.main+1057 @064b1d> : 24 90 33 06                store.m32 <@063390> ;anyRlVar
	cmplStd/test/lang/inlineMacros.ci:53: (62 bytes: <.main+1061 @064b21> - <.main+1123 @064b5f>): static anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+1061 @064b21> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1065 @064b25> : 10 00                      dup.x32 sp(0)
	<.main+1067 @064b27> : 06 0a 00 00                jz <.main+1077 @064b31>
	<.main+1071 @064b2b> : 10 00                      dup.x32 sp(0)
	<.main+1073 @064b2d> : 04 08 00 00                jmp <.main+1081 @064b35>
	<.main+1077 @064b31> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1081 @064b35> : 13 01                      set.x32 sp(1)
	<.main+1083 @064b37> : 10 00                      dup.x32 sp(0)
	<.main+1085 @064b39> : 06 0a 00 00                jz <.main+1095 @064b43>
	<.main+1089 @064b3d> : 10 00                      dup.x32 sp(0)
	<.main+1091 @064b3f> : 04 08 00 00                jmp <.main+1099 @064b47>
	<.main+1095 @064b43> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1099 @064b47> : 13 01                      set.x32 sp(1)
	<.main+1101 @064b49> : 10 00                      dup.x32 sp(0)
	<.main+1103 @064b4b> : 06 0a 00 00                jz <.main+1113 @064b55>
	<.main+1107 @064b4f> : 10 00                      dup.x32 sp(0)
	<.main+1109 @064b51> : 04 08 00 00                jmp <.main+1117 @064b59>
	<.main+1113 @064b55> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1117 @064b59> : 13 01                      set.x32 sp(1)
	<.main+1119 @064b5b> : 24 98 33 06                store.m32 <@063398> ;anyLrVar
	cmplStd/test/lang/inlineMacros.ci:54: (82 bytes: <.main+1123 @064b5f> - <.main+1205 @064bb1>): static anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1123 @064b5f> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1127 @064b63> : 0c 01 00 00                inc.i32(+1)
	<.main+1131 @064b67> : 10 00                      dup.x32 sp(0)
	<.main+1133 @064b69> : 06 0a 00 00                jz <.main+1143 @064b73>
	<.main+1137 @064b6d> : 10 00                      dup.x32 sp(0)
	<.main+1139 @064b6f> : 04 38 00 00                jmp <.main+1195 @064ba7>
	<.main+1143 @064b73> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1147 @064b77> : 0c 01 00 00                inc.i32(+1)
	<.main+1151 @064b7b> : 10 00                      dup.x32 sp(0)
	<.main+1153 @064b7d> : 06 0a 00 00                jz <.main+1163 @064b87>
	<.main+1157 @064b81> : 10 00                      dup.x32 sp(0)
	<.main+1159 @064b83> : 04 22 00 00                jmp <.main+1193 @064ba5>
	<.main+1163 @064b87> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1167 @064b8b> : 0c 01 00 00                inc.i32(+1)
	<.main+1171 @064b8f> : 10 00                      dup.x32 sp(0)
	<.main+1173 @064b91> : 06 0a 00 00                jz <.main+1183 @064b9b>
	<.main+1177 @064b95> : 10 00                      dup.x32 sp(0)
	<.main+1179 @064b97> : 04 0c 00 00                jmp <.main+1191 @064ba3>
	<.main+1183 @064b9b> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1187 @064b9f> : 0c 01 00 00                inc.i32(+1)
	<.main+1191 @064ba3> : 13 01                      set.x32 sp(1)
	<.main+1193 @064ba5> : 13 01                      set.x32 sp(1)
	<.main+1195 @064ba7> : 13 01                      set.x32 sp(1)
	<.main+1197 @064ba9> : 0c ff ff ff                inc.i32(-1)
	<.main+1201 @064bad> : 24 a0 33 06                store.m32 <@0633a0> ;anyRlXpr
	cmplStd/test/lang/inlineMacros.ci:55: (82 bytes: <.main+1205 @064bb1> - <.main+1287 @064c03>): static anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1205 @064bb1> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1209 @064bb5> : 0c 01 00 00                inc.i32(+1)
	<.main+1213 @064bb9> : 10 00                      dup.x32 sp(0)
	<.main+1215 @064bbb> : 06 0a 00 00                jz <.main+1225 @064bc5>
	<.main+1219 @064bbf> : 10 00                      dup.x32 sp(0)
	<.main+1221 @064bc1> : 04 0c 00 00                jmp <.main+1233 @064bcd>
	<.main+1225 @064bc5> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1229 @064bc9> : 0c 01 00 00                inc.i32(+1)
	<.main+1233 @064bcd> : 13 01                      set.x32 sp(1)
	<.main+1235 @064bcf> : 10 00                      dup.x32 sp(0)
	<.main+1237 @064bd1> : 06 0a 00 00                jz <.main+1247 @064bdb>
	<.main+1241 @064bd5> : 10 00                      dup.x32 sp(0)
	<.main+1243 @064bd7> : 04 0c 00 00                jmp <.main+1255 @064be3>
	<.main+1247 @064bdb> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1251 @064bdf> : 0c 01 00 00                inc.i32(+1)
	<.main+1255 @064be3> : 13 01                      set.x32 sp(1)
	<.main+1257 @064be5> : 10 00                      dup.x32 sp(0)
	<.main+1259 @064be7> : 06 0a 00 00                jz <.main+1269 @064bf1>
	<.main+1263 @064beb> : 10 00                      dup.x32 sp(0)
	<.main+1265 @064bed> : 04 0c 00 00                jmp <.main+1277 @064bf9>
	<.main+1269 @064bf1> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1273 @064bf5> : 0c 01 00 00                inc.i32(+1)
	<.main+1277 @064bf9> : 13 01                      set.x32 sp(1)
	<.main+1279 @064bfb> : 0c ff ff ff                inc.i32(-1)
	<.main+1283 @064bff> : 24 a8 33 06                store.m32 <@0633a8> ;anyLrXpr
	cmplStd/test/lang/inlineMacros.ci:59: (93 bytes: <.main+1287 @064c03> - <.main+1380 @064c60>): static minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+1287 @064c03> : 1c 03 00 00 00             load.c32 3
	<.main+1292 @064c08> : 1c 06 00 00 00             load.c32 6
	<.main+1297 @064c0d> : 1c 02 00 00 00             load.c32 2
	<.main+1302 @064c12> : 1c 08 00 00 00             load.c32 8
	<.main+1307 @064c17> : 10 01                      dup.x32 sp(1)
	<.main+1309 @064c19> : 10 01                      dup.x32 sp(1)
	<.main+1311 @064c1b> : 58                         clt.i32
	<.main+1312 @064c1c> : 06 0a 00 00                jz <.main+1322 @064c26>
	<.main+1316 @064c20> : 10 01                      dup.x32 sp(1)
	<.main+1318 @064c22> : 04 06 00 00                jmp <.main+1324 @064c28>
	<.main+1322 @064c26> : 10 00                      dup.x32 sp(0)
	<.main+1324 @064c28> : 13 02                      set.x32 sp(2)
	<.main+1326 @064c2a> : 09 fc ff ff                inc.sp(-4)
	<.main+1330 @064c2e> : 10 01                      dup.x32 sp(1)
	<.main+1332 @064c30> : 10 01                      dup.x32 sp(1)
	<.main+1334 @064c32> : 58                         clt.i32
	<.main+1335 @064c33> : 06 0a 00 00                jz <.main+1345 @064c3d>
	<.main+1339 @064c37> : 10 01                      dup.x32 sp(1)
	<.main+1341 @064c39> : 04 06 00 00                jmp <.main+1347 @064c3f>
	<.main+1345 @064c3d> : 10 00                      dup.x32 sp(0)
	<.main+1347 @064c3f> : 13 02                      set.x32 sp(2)
	<.main+1349 @064c41> : 09 fc ff ff                inc.sp(-4)
	<.main+1353 @064c45> : 10 01                      dup.x32 sp(1)
	<.main+1355 @064c47> : 10 01                      dup.x32 sp(1)
	<.main+1357 @064c49> : 58                         clt.i32
	<.main+1358 @064c4a> : 06 0a 00 00                jz <.main+1368 @064c54>
	<.main+1362 @064c4e> : 10 01                      dup.x32 sp(1)
	<.main+1364 @064c50> : 04 06 00 00                jmp <.main+1370 @064c56>
	<.main+1368 @064c54> : 10 00                      dup.x32 sp(0)
	<.main+1370 @064c56> : 13 02                      set.x32 sp(2)
	<.main+1372 @064c58> : 09 fc ff ff                inc.sp(-4)
	<.main+1376 @064c5c> : 24 b0 33 06                store.m32 <@0633b0> ;minRlVal
	cmplStd/test/lang/inlineMacros.ci:60: (93 bytes: <.main+1380 @064c60> - <.main+1473 @064cbd>): static minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+1380 @064c60> : 1c 03 00 00 00             load.c32 3
	<.main+1385 @064c65> : 1c 06 00 00 00             load.c32 6
	<.main+1390 @064c6a> : 10 01                      dup.x32 sp(1)
	<.main+1392 @064c6c> : 10 01                      dup.x32 sp(1)
	<.main+1394 @064c6e> : 58                         clt.i32
	<.main+1395 @064c6f> : 06 0a 00 00                jz <.main+1405 @064c79>
	<.main+1399 @064c73> : 10 01                      dup.x32 sp(1)
	<.main+1401 @064c75> : 04 06 00 00                jmp <.main+1407 @064c7b>
	<.main+1405 @064c79> : 10 00                      dup.x32 sp(0)
	<.main+1407 @064c7b> : 13 02                      set.x32 sp(2)
	<.main+1409 @064c7d> : 09 fc ff ff                inc.sp(-4)
	<.main+1413 @064c81> : 1c 02 00 00 00             load.c32 2
	<.main+1418 @064c86> : 10 01                      dup.x32 sp(1)
	<.main+1420 @064c88> : 10 01                      dup.x32 sp(1)
	<.main+1422 @064c8a> : 58                         clt.i32
	<.main+1423 @064c8b> : 06 0a 00 00                jz <.main+1433 @064c95>
	<.main+1427 @064c8f> : 10 01                      dup.x32 sp(1)
	<.main+1429 @064c91> : 04 06 00 00                jmp <.main+1435 @064c97>
	<.main+1433 @064c95> : 10 00                      dup.x32 sp(0)
	<.main+1435 @064c97> : 13 02                      set.x32 sp(2)
	<.main+1437 @064c99> : 09 fc ff ff                inc.sp(-4)
	<.main+1441 @064c9d> : 1c 08 00 00 00             load.c32 8
	<.main+1446 @064ca2> : 10 01                      dup.x32 sp(1)
	<.main+1448 @064ca4> : 10 01                      dup.x32 sp(1)
	<.main+1450 @064ca6> : 58                         clt.i32
	<.main+1451 @064ca7> : 06 0a 00 00                jz <.main+1461 @064cb1>
	<.main+1455 @064cab> : 10 01                      dup.x32 sp(1)
	<.main+1457 @064cad> : 04 06 00 00                jmp <.main+1463 @064cb3>
	<.main+1461 @064cb1> : 10 00                      dup.x32 sp(0)
	<.main+1463 @064cb3> : 13 02                      set.x32 sp(2)
	<.main+1465 @064cb5> : 09 fc ff ff                inc.sp(-4)
	<.main+1469 @064cb9> : 24 b8 33 06                store.m32 <@0633b8> ;minLrVal
	cmplStd/test/lang/inlineMacros.ci:61: (89 bytes: <.main+1473 @064cbd> - <.main+1562 @064d16>): static minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+1473 @064cbd> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1477 @064cc1> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1481 @064cc5> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1485 @064cc9> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1489 @064ccd> : 10 01                      dup.x32 sp(1)
	<.main+1491 @064ccf> : 10 01                      dup.x32 sp(1)
	<.main+1493 @064cd1> : 58                         clt.i32
	<.main+1494 @064cd2> : 06 0a 00 00                jz <.main+1504 @064cdc>
	<.main+1498 @064cd6> : 10 01                      dup.x32 sp(1)
	<.main+1500 @064cd8> : 04 06 00 00                jmp <.main+1506 @064cde>
	<.main+1504 @064cdc> : 10 00                      dup.x32 sp(0)
	<.main+1506 @064cde> : 13 02                      set.x32 sp(2)
	<.main+1508 @064ce0> : 09 fc ff ff                inc.sp(-4)
	<.main+1512 @064ce4> : 10 01                      dup.x32 sp(1)
	<.main+1514 @064ce6> : 10 01                      dup.x32 sp(1)
	<.main+1516 @064ce8> : 58                         clt.i32
	<.main+1517 @064ce9> : 06 0a 00 00                jz <.main+1527 @064cf3>
	<.main+1521 @064ced> : 10 01                      dup.x32 sp(1)
	<.main+1523 @064cef> : 04 06 00 00                jmp <.main+1529 @064cf5>
	<.main+1527 @064cf3> : 10 00                      dup.x32 sp(0)
	<.main+1529 @064cf5> : 13 02                      set.x32 sp(2)
	<.main+1531 @064cf7> : 09 fc ff ff                inc.sp(-4)
	<.main+1535 @064cfb> : 10 01                      dup.x32 sp(1)
	<.main+1537 @064cfd> : 10 01                      dup.x32 sp(1)
	<.main+1539 @064cff> : 58                         clt.i32
	<.main+1540 @064d00> : 06 0a 00 00                jz <.main+1550 @064d0a>
	<.main+1544 @064d04> : 10 01                      dup.x32 sp(1)
	<.main+1546 @064d06> : 04 06 00 00                jmp <.main+1552 @064d0c>
	<.main+1550 @064d0a> : 10 00                      dup.x32 sp(0)
	<.main+1552 @064d0c> : 13 02                      set.x32 sp(2)
	<.main+1554 @064d0e> : 09 fc ff ff                inc.sp(-4)
	<.main+1558 @064d12> : 24 c0 33 06                store.m32 <@0633c0> ;minRlVar
	cmplStd/test/lang/inlineMacros.ci:62: (89 bytes: <.main+1562 @064d16> - <.main+1651 @064d6f>): static minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+1562 @064d16> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1566 @064d1a> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1570 @064d1e> : 10 01                      dup.x32 sp(1)
	<.main+1572 @064d20> : 10 01                      dup.x32 sp(1)
	<.main+1574 @064d22> : 58                         clt.i32
	<.main+1575 @064d23> : 06 0a 00 00                jz <.main+1585 @064d2d>
	<.main+1579 @064d27> : 10 01                      dup.x32 sp(1)
	<.main+1581 @064d29> : 04 06 00 00                jmp <.main+1587 @064d2f>
	<.main+1585 @064d2d> : 10 00                      dup.x32 sp(0)
	<.main+1587 @064d2f> : 13 02                      set.x32 sp(2)
	<.main+1589 @064d31> : 09 fc ff ff                inc.sp(-4)
	<.main+1593 @064d35> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1597 @064d39> : 10 01                      dup.x32 sp(1)
	<.main+1599 @064d3b> : 10 01                      dup.x32 sp(1)
	<.main+1601 @064d3d> : 58                         clt.i32
	<.main+1602 @064d3e> : 06 0a 00 00                jz <.main+1612 @064d48>
	<.main+1606 @064d42> : 10 01                      dup.x32 sp(1)
	<.main+1608 @064d44> : 04 06 00 00                jmp <.main+1614 @064d4a>
	<.main+1612 @064d48> : 10 00                      dup.x32 sp(0)
	<.main+1614 @064d4a> : 13 02                      set.x32 sp(2)
	<.main+1616 @064d4c> : 09 fc ff ff                inc.sp(-4)
	<.main+1620 @064d50> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1624 @064d54> : 10 01                      dup.x32 sp(1)
	<.main+1626 @064d56> : 10 01                      dup.x32 sp(1)
	<.main+1628 @064d58> : 58                         clt.i32
	<.main+1629 @064d59> : 06 0a 00 00                jz <.main+1639 @064d63>
	<.main+1633 @064d5d> : 10 01                      dup.x32 sp(1)
	<.main+1635 @064d5f> : 04 06 00 00                jmp <.main+1641 @064d65>
	<.main+1639 @064d63> : 10 00                      dup.x32 sp(0)
	<.main+1641 @064d65> : 13 02                      set.x32 sp(2)
	<.main+1643 @064d67> : 09 fc ff ff                inc.sp(-4)
	<.main+1647 @064d6b> : 24 c8 33 06                store.m32 <@0633c8> ;minLrVar
	cmplStd/test/lang/inlineMacros.ci:63: (109 bytes: <.main+1651 @064d6f> - <.main+1760 @064ddc>): static minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1651 @064d6f> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1655 @064d73> : 0c 01 00 00                inc.i32(+1)
	<.main+1659 @064d77> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1663 @064d7b> : 0c 01 00 00                inc.i32(+1)
	<.main+1667 @064d7f> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1671 @064d83> : 0c 01 00 00                inc.i32(+1)
	<.main+1675 @064d87> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1679 @064d8b> : 0c 01 00 00                inc.i32(+1)
	<.main+1683 @064d8f> : 10 01                      dup.x32 sp(1)
	<.main+1685 @064d91> : 10 01                      dup.x32 sp(1)
	<.main+1687 @064d93> : 58                         clt.i32
	<.main+1688 @064d94> : 06 0a 00 00                jz <.main+1698 @064d9e>
	<.main+1692 @064d98> : 10 01                      dup.x32 sp(1)
	<.main+1694 @064d9a> : 04 06 00 00                jmp <.main+1700 @064da0>
	<.main+1698 @064d9e> : 10 00                      dup.x32 sp(0)
	<.main+1700 @064da0> : 13 02                      set.x32 sp(2)
	<.main+1702 @064da2> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @064da6> : 10 01                      dup.x32 sp(1)
	<.main+1708 @064da8> : 10 01                      dup.x32 sp(1)
	<.main+1710 @064daa> : 58                         clt.i32
	<.main+1711 @064dab> : 06 0a 00 00                jz <.main+1721 @064db5>
	<.main+1715 @064daf> : 10 01                      dup.x32 sp(1)
	<.main+1717 @064db1> : 04 06 00 00                jmp <.main+1723 @064db7>
	<.main+1721 @064db5> : 10 00                      dup.x32 sp(0)
	<.main+1723 @064db7> : 13 02                      set.x32 sp(2)
	<.main+1725 @064db9> : 09 fc ff ff                inc.sp(-4)
	<.main+1729 @064dbd> : 10 01                      dup.x32 sp(1)
	<.main+1731 @064dbf> : 10 01                      dup.x32 sp(1)
	<.main+1733 @064dc1> : 58                         clt.i32
	<.main+1734 @064dc2> : 06 0a 00 00                jz <.main+1744 @064dcc>
	<.main+1738 @064dc6> : 10 01                      dup.x32 sp(1)
	<.main+1740 @064dc8> : 04 06 00 00                jmp <.main+1746 @064dce>
	<.main+1744 @064dcc> : 10 00                      dup.x32 sp(0)
	<.main+1746 @064dce> : 13 02                      set.x32 sp(2)
	<.main+1748 @064dd0> : 09 fc ff ff                inc.sp(-4)
	<.main+1752 @064dd4> : 0c ff ff ff                inc.i32(-1)
	<.main+1756 @064dd8> : 24 d0 33 06                store.m32 <@0633d0> ;minRlXpr
	cmplStd/test/lang/inlineMacros.ci:64: (109 bytes: <.main+1760 @064ddc> - <.main+1869 @064e49>): static minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1760 @064ddc> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+1764 @064de0> : 0c 01 00 00                inc.i32(+1)
	<.main+1768 @064de4> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+1772 @064de8> : 0c 01 00 00                inc.i32(+1)
	<.main+1776 @064dec> : 10 01                      dup.x32 sp(1)
	<.main+1778 @064dee> : 10 01                      dup.x32 sp(1)
	<.main+1780 @064df0> : 58                         clt.i32
	<.main+1781 @064df1> : 06 0a 00 00                jz <.main+1791 @064dfb>
	<.main+1785 @064df5> : 10 01                      dup.x32 sp(1)
	<.main+1787 @064df7> : 04 06 00 00                jmp <.main+1793 @064dfd>
	<.main+1791 @064dfb> : 10 00                      dup.x32 sp(0)
	<.main+1793 @064dfd> : 13 02                      set.x32 sp(2)
	<.main+1795 @064dff> : 09 fc ff ff                inc.sp(-4)
	<.main+1799 @064e03> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+1803 @064e07> : 0c 01 00 00                inc.i32(+1)
	<.main+1807 @064e0b> : 10 01                      dup.x32 sp(1)
	<.main+1809 @064e0d> : 10 01                      dup.x32 sp(1)
	<.main+1811 @064e0f> : 58                         clt.i32
	<.main+1812 @064e10> : 06 0a 00 00                jz <.main+1822 @064e1a>
	<.main+1816 @064e14> : 10 01                      dup.x32 sp(1)
	<.main+1818 @064e16> : 04 06 00 00                jmp <.main+1824 @064e1c>
	<.main+1822 @064e1a> : 10 00                      dup.x32 sp(0)
	<.main+1824 @064e1c> : 13 02                      set.x32 sp(2)
	<.main+1826 @064e1e> : 09 fc ff ff                inc.sp(-4)
	<.main+1830 @064e22> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+1834 @064e26> : 0c 01 00 00                inc.i32(+1)
	<.main+1838 @064e2a> : 10 01                      dup.x32 sp(1)
	<.main+1840 @064e2c> : 10 01                      dup.x32 sp(1)
	<.main+1842 @064e2e> : 58                         clt.i32
	<.main+1843 @064e2f> : 06 0a 00 00                jz <.main+1853 @064e39>
	<.main+1847 @064e33> : 10 01                      dup.x32 sp(1)
	<.main+1849 @064e35> : 04 06 00 00                jmp <.main+1855 @064e3b>
	<.main+1853 @064e39> : 10 00                      dup.x32 sp(0)
	<.main+1855 @064e3b> : 13 02                      set.x32 sp(2)
	<.main+1857 @064e3d> : 09 fc ff ff                inc.sp(-4)
	<.main+1861 @064e41> : 0c ff ff ff                inc.i32(-1)
	<.main+1865 @064e45> : 24 d8 33 06                store.m32 <@0633d8> ;minLrXpr
	cmplStd/test/lang/inlineMacros.ci:68: (93 bytes: <.main+1869 @064e49> - <.main+1962 @064ea6>): static maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+1869 @064e49> : 1c 03 00 00 00             load.c32 3
	<.main+1874 @064e4e> : 1c 06 00 00 00             load.c32 6
	<.main+1879 @064e53> : 1c 02 00 00 00             load.c32 2
	<.main+1884 @064e58> : 1c 08 00 00 00             load.c32 8
	<.main+1889 @064e5d> : 10 01                      dup.x32 sp(1)
	<.main+1891 @064e5f> : 10 01                      dup.x32 sp(1)
	<.main+1893 @064e61> : 59                         cgt.i32
	<.main+1894 @064e62> : 06 0a 00 00                jz <.main+1904 @064e6c>
	<.main+1898 @064e66> : 10 01                      dup.x32 sp(1)
	<.main+1900 @064e68> : 04 06 00 00                jmp <.main+1906 @064e6e>
	<.main+1904 @064e6c> : 10 00                      dup.x32 sp(0)
	<.main+1906 @064e6e> : 13 02                      set.x32 sp(2)
	<.main+1908 @064e70> : 09 fc ff ff                inc.sp(-4)
	<.main+1912 @064e74> : 10 01                      dup.x32 sp(1)
	<.main+1914 @064e76> : 10 01                      dup.x32 sp(1)
	<.main+1916 @064e78> : 59                         cgt.i32
	<.main+1917 @064e79> : 06 0a 00 00                jz <.main+1927 @064e83>
	<.main+1921 @064e7d> : 10 01                      dup.x32 sp(1)
	<.main+1923 @064e7f> : 04 06 00 00                jmp <.main+1929 @064e85>
	<.main+1927 @064e83> : 10 00                      dup.x32 sp(0)
	<.main+1929 @064e85> : 13 02                      set.x32 sp(2)
	<.main+1931 @064e87> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @064e8b> : 10 01                      dup.x32 sp(1)
	<.main+1937 @064e8d> : 10 01                      dup.x32 sp(1)
	<.main+1939 @064e8f> : 59                         cgt.i32
	<.main+1940 @064e90> : 06 0a 00 00                jz <.main+1950 @064e9a>
	<.main+1944 @064e94> : 10 01                      dup.x32 sp(1)
	<.main+1946 @064e96> : 04 06 00 00                jmp <.main+1952 @064e9c>
	<.main+1950 @064e9a> : 10 00                      dup.x32 sp(0)
	<.main+1952 @064e9c> : 13 02                      set.x32 sp(2)
	<.main+1954 @064e9e> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @064ea2> : 24 e0 33 06                store.m32 <@0633e0> ;maxRlVal
	cmplStd/test/lang/inlineMacros.ci:69: (93 bytes: <.main+1962 @064ea6> - <.main+2055 @064f03>): static maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+1962 @064ea6> : 1c 03 00 00 00             load.c32 3
	<.main+1967 @064eab> : 1c 06 00 00 00             load.c32 6
	<.main+1972 @064eb0> : 10 01                      dup.x32 sp(1)
	<.main+1974 @064eb2> : 10 01                      dup.x32 sp(1)
	<.main+1976 @064eb4> : 59                         cgt.i32
	<.main+1977 @064eb5> : 06 0a 00 00                jz <.main+1987 @064ebf>
	<.main+1981 @064eb9> : 10 01                      dup.x32 sp(1)
	<.main+1983 @064ebb> : 04 06 00 00                jmp <.main+1989 @064ec1>
	<.main+1987 @064ebf> : 10 00                      dup.x32 sp(0)
	<.main+1989 @064ec1> : 13 02                      set.x32 sp(2)
	<.main+1991 @064ec3> : 09 fc ff ff                inc.sp(-4)
	<.main+1995 @064ec7> : 1c 02 00 00 00             load.c32 2
	<.main+2000 @064ecc> : 10 01                      dup.x32 sp(1)
	<.main+2002 @064ece> : 10 01                      dup.x32 sp(1)
	<.main+2004 @064ed0> : 59                         cgt.i32
	<.main+2005 @064ed1> : 06 0a 00 00                jz <.main+2015 @064edb>
	<.main+2009 @064ed5> : 10 01                      dup.x32 sp(1)
	<.main+2011 @064ed7> : 04 06 00 00                jmp <.main+2017 @064edd>
	<.main+2015 @064edb> : 10 00                      dup.x32 sp(0)
	<.main+2017 @064edd> : 13 02                      set.x32 sp(2)
	<.main+2019 @064edf> : 09 fc ff ff                inc.sp(-4)
	<.main+2023 @064ee3> : 1c 08 00 00 00             load.c32 8
	<.main+2028 @064ee8> : 10 01                      dup.x32 sp(1)
	<.main+2030 @064eea> : 10 01                      dup.x32 sp(1)
	<.main+2032 @064eec> : 59                         cgt.i32
	<.main+2033 @064eed> : 06 0a 00 00                jz <.main+2043 @064ef7>
	<.main+2037 @064ef1> : 10 01                      dup.x32 sp(1)
	<.main+2039 @064ef3> : 04 06 00 00                jmp <.main+2045 @064ef9>
	<.main+2043 @064ef7> : 10 00                      dup.x32 sp(0)
	<.main+2045 @064ef9> : 13 02                      set.x32 sp(2)
	<.main+2047 @064efb> : 09 fc ff ff                inc.sp(-4)
	<.main+2051 @064eff> : 24 e8 33 06                store.m32 <@0633e8> ;maxLrVal
	cmplStd/test/lang/inlineMacros.ci:70: (89 bytes: <.main+2055 @064f03> - <.main+2144 @064f5c>): static maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+2055 @064f03> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+2059 @064f07> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+2063 @064f0b> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+2067 @064f0f> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+2071 @064f13> : 10 01                      dup.x32 sp(1)
	<.main+2073 @064f15> : 10 01                      dup.x32 sp(1)
	<.main+2075 @064f17> : 59                         cgt.i32
	<.main+2076 @064f18> : 06 0a 00 00                jz <.main+2086 @064f22>
	<.main+2080 @064f1c> : 10 01                      dup.x32 sp(1)
	<.main+2082 @064f1e> : 04 06 00 00                jmp <.main+2088 @064f24>
	<.main+2086 @064f22> : 10 00                      dup.x32 sp(0)
	<.main+2088 @064f24> : 13 02                      set.x32 sp(2)
	<.main+2090 @064f26> : 09 fc ff ff                inc.sp(-4)
	<.main+2094 @064f2a> : 10 01                      dup.x32 sp(1)
	<.main+2096 @064f2c> : 10 01                      dup.x32 sp(1)
	<.main+2098 @064f2e> : 59                         cgt.i32
	<.main+2099 @064f2f> : 06 0a 00 00                jz <.main+2109 @064f39>
	<.main+2103 @064f33> : 10 01                      dup.x32 sp(1)
	<.main+2105 @064f35> : 04 06 00 00                jmp <.main+2111 @064f3b>
	<.main+2109 @064f39> : 10 00                      dup.x32 sp(0)
	<.main+2111 @064f3b> : 13 02                      set.x32 sp(2)
	<.main+2113 @064f3d> : 09 fc ff ff                inc.sp(-4)
	<.main+2117 @064f41> : 10 01                      dup.x32 sp(1)
	<.main+2119 @064f43> : 10 01                      dup.x32 sp(1)
	<.main+2121 @064f45> : 59                         cgt.i32
	<.main+2122 @064f46> : 06 0a 00 00                jz <.main+2132 @064f50>
	<.main+2126 @064f4a> : 10 01                      dup.x32 sp(1)
	<.main+2128 @064f4c> : 04 06 00 00                jmp <.main+2134 @064f52>
	<.main+2132 @064f50> : 10 00                      dup.x32 sp(0)
	<.main+2134 @064f52> : 13 02                      set.x32 sp(2)
	<.main+2136 @064f54> : 09 fc ff ff                inc.sp(-4)
	<.main+2140 @064f58> : 24 f0 33 06                store.m32 <@0633f0> ;maxRlVar
	cmplStd/test/lang/inlineMacros.ci:71: (89 bytes: <.main+2144 @064f5c> - <.main+2233 @064fb5>): static maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+2144 @064f5c> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+2148 @064f60> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+2152 @064f64> : 10 01                      dup.x32 sp(1)
	<.main+2154 @064f66> : 10 01                      dup.x32 sp(1)
	<.main+2156 @064f68> : 59                         cgt.i32
	<.main+2157 @064f69> : 06 0a 00 00                jz <.main+2167 @064f73>
	<.main+2161 @064f6d> : 10 01                      dup.x32 sp(1)
	<.main+2163 @064f6f> : 04 06 00 00                jmp <.main+2169 @064f75>
	<.main+2167 @064f73> : 10 00                      dup.x32 sp(0)
	<.main+2169 @064f75> : 13 02                      set.x32 sp(2)
	<.main+2171 @064f77> : 09 fc ff ff                inc.sp(-4)
	<.main+2175 @064f7b> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+2179 @064f7f> : 10 01                      dup.x32 sp(1)
	<.main+2181 @064f81> : 10 01                      dup.x32 sp(1)
	<.main+2183 @064f83> : 59                         cgt.i32
	<.main+2184 @064f84> : 06 0a 00 00                jz <.main+2194 @064f8e>
	<.main+2188 @064f88> : 10 01                      dup.x32 sp(1)
	<.main+2190 @064f8a> : 04 06 00 00                jmp <.main+2196 @064f90>
	<.main+2194 @064f8e> : 10 00                      dup.x32 sp(0)
	<.main+2196 @064f90> : 13 02                      set.x32 sp(2)
	<.main+2198 @064f92> : 09 fc ff ff                inc.sp(-4)
	<.main+2202 @064f96> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+2206 @064f9a> : 10 01                      dup.x32 sp(1)
	<.main+2208 @064f9c> : 10 01                      dup.x32 sp(1)
	<.main+2210 @064f9e> : 59                         cgt.i32
	<.main+2211 @064f9f> : 06 0a 00 00                jz <.main+2221 @064fa9>
	<.main+2215 @064fa3> : 10 01                      dup.x32 sp(1)
	<.main+2217 @064fa5> : 04 06 00 00                jmp <.main+2223 @064fab>
	<.main+2221 @064fa9> : 10 00                      dup.x32 sp(0)
	<.main+2223 @064fab> : 13 02                      set.x32 sp(2)
	<.main+2225 @064fad> : 09 fc ff ff                inc.sp(-4)
	<.main+2229 @064fb1> : 24 f8 33 06                store.m32 <@0633f8> ;maxLrVar
	cmplStd/test/lang/inlineMacros.ci:72: (109 bytes: <.main+2233 @064fb5> - <.main+2342 @065022>): static maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2233 @064fb5> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+2237 @064fb9> : 0c 01 00 00                inc.i32(+1)
	<.main+2241 @064fbd> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+2245 @064fc1> : 0c 01 00 00                inc.i32(+1)
	<.main+2249 @064fc5> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+2253 @064fc9> : 0c 01 00 00                inc.i32(+1)
	<.main+2257 @064fcd> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+2261 @064fd1> : 0c 01 00 00                inc.i32(+1)
	<.main+2265 @064fd5> : 10 01                      dup.x32 sp(1)
	<.main+2267 @064fd7> : 10 01                      dup.x32 sp(1)
	<.main+2269 @064fd9> : 59                         cgt.i32
	<.main+2270 @064fda> : 06 0a 00 00                jz <.main+2280 @064fe4>
	<.main+2274 @064fde> : 10 01                      dup.x32 sp(1)
	<.main+2276 @064fe0> : 04 06 00 00                jmp <.main+2282 @064fe6>
	<.main+2280 @064fe4> : 10 00                      dup.x32 sp(0)
	<.main+2282 @064fe6> : 13 02                      set.x32 sp(2)
	<.main+2284 @064fe8> : 09 fc ff ff                inc.sp(-4)
	<.main+2288 @064fec> : 10 01                      dup.x32 sp(1)
	<.main+2290 @064fee> : 10 01                      dup.x32 sp(1)
	<.main+2292 @064ff0> : 59                         cgt.i32
	<.main+2293 @064ff1> : 06 0a 00 00                jz <.main+2303 @064ffb>
	<.main+2297 @064ff5> : 10 01                      dup.x32 sp(1)
	<.main+2299 @064ff7> : 04 06 00 00                jmp <.main+2305 @064ffd>
	<.main+2303 @064ffb> : 10 00                      dup.x32 sp(0)
	<.main+2305 @064ffd> : 13 02                      set.x32 sp(2)
	<.main+2307 @064fff> : 09 fc ff ff                inc.sp(-4)
	<.main+2311 @065003> : 10 01                      dup.x32 sp(1)
	<.main+2313 @065005> : 10 01                      dup.x32 sp(1)
	<.main+2315 @065007> : 59                         cgt.i32
	<.main+2316 @065008> : 06 0a 00 00                jz <.main+2326 @065012>
	<.main+2320 @06500c> : 10 01                      dup.x32 sp(1)
	<.main+2322 @06500e> : 04 06 00 00                jmp <.main+2328 @065014>
	<.main+2326 @065012> : 10 00                      dup.x32 sp(0)
	<.main+2328 @065014> : 13 02                      set.x32 sp(2)
	<.main+2330 @065016> : 09 fc ff ff                inc.sp(-4)
	<.main+2334 @06501a> : 0c ff ff ff                inc.i32(-1)
	<.main+2338 @06501e> : 24 00 34 06                store.m32 <@063400> ;maxRlXpr
	cmplStd/test/lang/inlineMacros.ci:73: (109 bytes: <.main+2342 @065022> - <.main+2451 @06508f>): static maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2342 @065022> : 20 a0 32 06                load.m32 <@0632a0> ;i3
	<.main+2346 @065026> : 0c 01 00 00                inc.i32(+1)
	<.main+2350 @06502a> : 20 a8 32 06                load.m32 <@0632a8> ;i6
	<.main+2354 @06502e> : 0c 01 00 00                inc.i32(+1)
	<.main+2358 @065032> : 10 01                      dup.x32 sp(1)
	<.main+2360 @065034> : 10 01                      dup.x32 sp(1)
	<.main+2362 @065036> : 59                         cgt.i32
	<.main+2363 @065037> : 06 0a 00 00                jz <.main+2373 @065041>
	<.main+2367 @06503b> : 10 01                      dup.x32 sp(1)
	<.main+2369 @06503d> : 04 06 00 00                jmp <.main+2375 @065043>
	<.main+2373 @065041> : 10 00                      dup.x32 sp(0)
	<.main+2375 @065043> : 13 02                      set.x32 sp(2)
	<.main+2377 @065045> : 09 fc ff ff                inc.sp(-4)
	<.main+2381 @065049> : 20 b0 32 06                load.m32 <@0632b0> ;i2
	<.main+2385 @06504d> : 0c 01 00 00                inc.i32(+1)
	<.main+2389 @065051> : 10 01                      dup.x32 sp(1)
	<.main+2391 @065053> : 10 01                      dup.x32 sp(1)
	<.main+2393 @065055> : 59                         cgt.i32
	<.main+2394 @065056> : 06 0a 00 00                jz <.main+2404 @065060>
	<.main+2398 @06505a> : 10 01                      dup.x32 sp(1)
	<.main+2400 @06505c> : 04 06 00 00                jmp <.main+2406 @065062>
	<.main+2404 @065060> : 10 00                      dup.x32 sp(0)
	<.main+2406 @065062> : 13 02                      set.x32 sp(2)
	<.main+2408 @065064> : 09 fc ff ff                inc.sp(-4)
	<.main+2412 @065068> : 20 b8 32 06                load.m32 <@0632b8> ;i8
	<.main+2416 @06506c> : 0c 01 00 00                inc.i32(+1)
	<.main+2420 @065070> : 10 01                      dup.x32 sp(1)
	<.main+2422 @065072> : 10 01                      dup.x32 sp(1)
	<.main+2424 @065074> : 59                         cgt.i32
	<.main+2425 @065075> : 06 0a 00 00                jz <.main+2435 @06507f>
	<.main+2429 @065079> : 10 01                      dup.x32 sp(1)
	<.main+2431 @06507b> : 04 06 00 00                jmp <.main+2437 @065081>
	<.main+2435 @06507f> : 10 00                      dup.x32 sp(0)
	<.main+2437 @065081> : 13 02                      set.x32 sp(2)
	<.main+2439 @065083> : 09 fc ff ff                inc.sp(-4)
	<.main+2443 @065087> : 0c ff ff ff                inc.i32(-1)
	<.main+2447 @06508b> : 24 08 34 06                store.m32 <@063408> ;maxLrXpr
	cmplStd/test/lang/overload.inline.ci:9: (9 bytes: <.main+2451 @06508f> - <.main+2460 @065098>): static overload1: float32 := overload
	<.main+2451 @06508f> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2456 @065094> : 24 10 34 06                store.m32 <@063410> ;overload1
	cmplStd/test/lang/overload.inline.ci:10: (9 bytes: <.main+2460 @065098> - <.main+2469 @0650a1>): static overload2: float32 := overload()
	<.main+2460 @065098> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2465 @06509d> : 24 18 34 06                store.m32 <@063418> ;overload2
	cmplStd/test/lang/overload.inline.ci:11: (9 bytes: <.main+2469 @0650a1> - <.main+2478 @0650aa>): static overload3: float32 := overload(0)
	<.main+2469 @0650a1> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2474 @0650a6> : 24 20 34 06                store.m32 <@063420> ;overload3
	cmplStd/test/lang/overload.inline.ci:12: (9 bytes: <.main+2478 @0650aa> - <.main+2487 @0650b3>): static overload4: float32 := overload(0.000000)
	<.main+2478 @0650aa> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2483 @0650af> : 24 28 34 06                store.m32 <@063428> ;overload4
	cmplStd/test/lang/overload.inline.ci:13: (9 bytes: <.main+2487 @0650b3> - <.main+2496 @0650bc>): static overload5: float32 := overload(0, 0)
	<.main+2487 @0650b3> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2492 @0650b8> : 24 30 34 06                store.m32 <@063430> ;overload5
	cmplStd/test/lang/overload.inline.ci:28: (13 bytes: <.main+2496 @0650bc> - <.main+2509 @0650c9>): static boilC: Celsius := Celsius(100.000000)
	<.main+2496 @0650bc> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2505 @0650c5> : 23 38 34 06                store.m64 <@063438> ;boilC
	cmplStd/test/lang/overload.inline.ci:29: (28 bytes: <.main+2509 @0650c9> - <.main+2537 @0650e5>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2509 @0650c9> : 21 38 34 06                load.m64 <@063438> ;boilC
	<.main+2513 @0650cd> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2522 @0650d6> : 83                         mul.f64
	<.main+2523 @0650d7> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2532 @0650e0> : 81                         add.f64
	<.main+2533 @0650e1> : 23 40 34 06                store.m64 <@063440> ;boilF
	cmplStd/test/std/number.ci:3: (13 bytes: <.main+2537 @0650e5> - <.main+2550 @0650f2>): static pi64: float64 := 3.141593
	<.main+2537 @0650e5> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+2546 @0650ee> : 23 48 34 06                store.m64 <@063448> ;pi64
	cmplStd/test/std/number.ci:4: (13 bytes: <.main+2550 @0650f2> - <.main+2563 @0650ff>): static e64: float64 := 2.718282
	<.main+2550 @0650f2> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+2559 @0650fb> : 23 50 34 06                store.m64 <@063450> ;e64
	cmplStd/test/std/number.ci:6: (9 bytes: <.main+2563 @0650ff> - <.main+2572 @065108>): static pi32: float32 := pi64
	<.main+2563 @0650ff> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+2567 @065103> : 8c                         f64.2f32
	<.main+2568 @065104> : 24 58 34 06                store.m32 <@063458> ;pi32
	cmplStd/test/std/number.ci:7: (9 bytes: <.main+2572 @065108> - <.main+2581 @065111>): static e32: float32 := e64
	<.main+2572 @065108> : 21 50 34 06                load.m64 <@063450> ;e64
	<.main+2576 @06510c> : 8c                         f64.2f32
	<.main+2577 @06510d> : 24 60 34 06                store.m32 <@063460> ;e32
	cmplStd/test/std/number.ci:14: (11 bytes: <.main+2581 @065111> - <.main+2592 @06511c>): static r_comp: int32 := 14 << 3
	<.main+2581 @065111> : 1c 0e 00 00 00             load.c32 14
	<.main+2586 @065116> : 3f 43                      b32.shl 0x03
	<.main+2588 @065118> : 24 68 34 06                store.m32 <@063468> ;r_comp
	cmplStd/test/std/number.ci:15: (11 bytes: <.main+2592 @06511c> - <.main+2603 @065127>): static g_comp: int32 := 63 << 2
	<.main+2592 @06511c> : 1c 3f 00 00 00             load.c32 63
	<.main+2597 @065121> : 3f 42                      b32.shl 0x02
	<.main+2599 @065123> : 24 70 34 06                store.m32 <@063470> ;g_comp
	cmplStd/test/std/number.ci:16: (11 bytes: <.main+2603 @065127> - <.main+2614 @065132>): static b_comp: int32 := 31 << 3
	<.main+2603 @065127> : 1c 1f 00 00 00             load.c32 31
	<.main+2608 @06512c> : 3f 43                      b32.shl 0x03
	<.main+2610 @06512e> : 24 78 34 06                store.m32 <@063478> ;b_comp
	cmplStd/test/std/number.ci:18: (38 bytes: <.main+2614 @065132> - <.main+2652 @065158>): static r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+2614 @065132> : 20 68 34 06                load.m32 <@063468> ;r_comp
	<.main+2618 @065136> : 3f 48                      b32.shl 0x08
	<.main+2620 @065138> : 1c 00 f8 00 00             load.c32 63488
	<.main+2625 @06513d> : 31                         and.b32
	<.main+2626 @06513e> : 20 70 34 06                load.m32 <@063470> ;g_comp
	<.main+2630 @065142> : 3f 43                      b32.shl 0x03
	<.main+2632 @065144> : 1c e0 07 00 00             load.c32 2016
	<.main+2637 @065149> : 31                         and.b32
	<.main+2638 @06514a> : 32                         or.b32
	<.main+2639 @06514b> : 20 78 34 06                load.m32 <@063478> ;b_comp
	<.main+2643 @06514f> : 3f c3                      b32.sar 0x03
	<.main+2645 @065151> : 3f 05                      b32.and 0x1f
	<.main+2647 @065153> : 32                         or.b32
	<.main+2648 @065154> : 24 80 34 06                store.m32 <@063480> ;r5g6b5
	cmplStd/test/std/number.ci:19: (36 bytes: <.main+2652 @065158> - <.main+2688 @06517c>): static r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+2652 @065158> : 20 68 34 06                load.m32 <@063468> ;r_comp
	<.main+2656 @06515c> : 3f 50                      b32.shl 0x10
	<.main+2658 @06515e> : 1c 00 00 ff 00             load.c32 16711680
	<.main+2663 @065163> : 31                         and.b32
	<.main+2664 @065164> : 20 70 34 06                load.m32 <@063470> ;g_comp
	<.main+2668 @065168> : 3f 48                      b32.shl 0x08
	<.main+2670 @06516a> : 1c 00 ff 00 00             load.c32 65280
	<.main+2675 @06516f> : 31                         and.b32
	<.main+2676 @065170> : 32                         or.b32
	<.main+2677 @065171> : 20 78 34 06                load.m32 <@063478> ;b_comp
	<.main+2681 @065175> : 3f 08                      b32.and 0xff
	<.main+2683 @065177> : 32                         or.b32
	<.main+2684 @065178> : 24 88 34 06                store.m32 <@063488> ;r8g8b8
	cmplStd/test/std/number.ci:21: (22 bytes: <.main+2688 @06517c> - <.main+2710 @065192>): static zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+2688 @06517c> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+2692 @065180> : 1c 0b 00 00 00             load.c32 11
	<.main+2697 @065185> : 1c 05 00 00 00             load.c32 5
	<.main+2702 @06518a> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2706 @06518e> : 24 90 34 06                store.m32 <@063490> ;zxtR5
	cmplStd/test/std/number.ci:22: (22 bytes: <.main+2710 @065192> - <.main+2732 @0651a8>): static zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+2710 @065192> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+2714 @065196> : 1c 05 00 00 00             load.c32 5
	<.main+2719 @06519b> : 1c 06 00 00 00             load.c32 6
	<.main+2724 @0651a0> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2728 @0651a4> : 24 98 34 06                store.m32 <@063498> ;zxtG6
	cmplStd/test/std/number.ci:23: (18 bytes: <.main+2732 @0651a8> - <.main+2750 @0651ba>): static zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+2732 @0651a8> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+2736 @0651ac> : 19                         load.z32
	<.main+2737 @0651ad> : 1c 05 00 00 00             load.c32 5
	<.main+2742 @0651b2> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2746 @0651b6> : 24 a0 34 06                store.m32 <@0634a0> ;zxtB5
	cmplStd/test/std/number.ci:25: (22 bytes: <.main+2750 @0651ba> - <.main+2772 @0651d0>): static sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+2750 @0651ba> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+2754 @0651be> : 1c 0b 00 00 00             load.c32 11
	<.main+2759 @0651c3> : 1c 05 00 00 00             load.c32 5
	<.main+2764 @0651c8> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2768 @0651cc> : 24 a8 34 06                store.m32 <@0634a8> ;sxtR5
	cmplStd/test/std/number.ci:26: (22 bytes: <.main+2772 @0651d0> - <.main+2794 @0651e6>): static sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+2772 @0651d0> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+2776 @0651d4> : 1c 05 00 00 00             load.c32 5
	<.main+2781 @0651d9> : 1c 06 00 00 00             load.c32 6
	<.main+2786 @0651de> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2790 @0651e2> : 24 b0 34 06                store.m32 <@0634b0> ;sxtG6
	cmplStd/test/std/number.ci:27: (18 bytes: <.main+2794 @0651e6> - <.main+2812 @0651f8>): static sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+2794 @0651e6> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+2798 @0651ea> : 19                         load.z32
	<.main+2799 @0651eb> : 1c 05 00 00 00             load.c32 5
	<.main+2804 @0651f0> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2808 @0651f4> : 24 b8 34 06                store.m32 <@0634b8> ;sxtB5
	cmplStd/test/std/number.ci:29: (22 bytes: <.main+2812 @0651f8> - <.main+2834 @06520e>): static zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+2812 @0651f8> : 20 88 34 06                load.m32 <@063488> ;r8g8b8
	<.main+2816 @0651fc> : 1c 10 00 00 00             load.c32 16
	<.main+2821 @065201> : 1c 08 00 00 00             load.c32 8
	<.main+2826 @065206> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2830 @06520a> : 24 c0 34 06                store.m32 <@0634c0> ;zxtR8
	cmplStd/test/std/number.ci:30: (22 bytes: <.main+2834 @06520e> - <.main+2856 @065224>): static zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+2834 @06520e> : 20 88 34 06                load.m32 <@063488> ;r8g8b8
	<.main+2838 @065212> : 1c 08 00 00 00             load.c32 8
	<.main+2843 @065217> : 1c 08 00 00 00             load.c32 8
	<.main+2848 @06521c> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2852 @065220> : 24 c8 34 06                store.m32 <@0634c8> ;zxtG8
	cmplStd/test/std/number.ci:31: (18 bytes: <.main+2856 @065224> - <.main+2874 @065236>): static zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+2856 @065224> : 20 88 34 06                load.m32 <@063488> ;r8g8b8
	<.main+2860 @065228> : 19                         load.z32
	<.main+2861 @065229> : 1c 08 00 00 00             load.c32 8
	<.main+2866 @06522e> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2870 @065232> : 24 d0 34 06                store.m32 <@0634d0> ;zxtB8
	cmplStd/test/std/number.ci:33: (22 bytes: <.main+2874 @065236> - <.main+2896 @06524c>): static sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+2874 @065236> : 20 88 34 06                load.m32 <@063488> ;r8g8b8
	<.main+2878 @06523a> : 1c 10 00 00 00             load.c32 16
	<.main+2883 @06523f> : 1c 08 00 00 00             load.c32 8
	<.main+2888 @065244> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2892 @065248> : 24 d8 34 06                store.m32 <@0634d8> ;sxtR8
	cmplStd/test/std/number.ci:34: (22 bytes: <.main+2896 @06524c> - <.main+2918 @065262>): static sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+2896 @06524c> : 20 88 34 06                load.m32 <@063488> ;r8g8b8
	<.main+2900 @065250> : 1c 08 00 00 00             load.c32 8
	<.main+2905 @065255> : 1c 08 00 00 00             load.c32 8
	<.main+2910 @06525a> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2914 @06525e> : 24 e0 34 06                store.m32 <@0634e0> ;sxtG8
	cmplStd/test/std/number.ci:35: (18 bytes: <.main+2918 @065262> - <.main+2936 @065274>): static sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+2918 @065262> : 20 88 34 06                load.m32 <@063488> ;r8g8b8
	<.main+2922 @065266> : 19                         load.z32
	<.main+2923 @065267> : 1c 08 00 00 00             load.c32 8
	<.main+2928 @06526c> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2932 @065270> : 24 e8 34 06                store.m32 <@0634e8> ;sxtB8
	cmplStd/test/std/number.ci:37: (22 bytes: <.main+2936 @065274> - <.main+2958 @06528a>): static testSin_f64: float64 := float64.sin(pi64 / (2))
	<.main+2936 @065274> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+2940 @065278> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2949 @065281> : 84                         div.f64
	<.main+2950 @065282> : 01 2a 00 00                nfc(42) ;float64.sin(x: float64): float64
	<.main+2954 @065286> : 23 f0 34 06                store.m64 <@0634f0> ;testSin_f64
	cmplStd/test/std/number.ci:38: (22 bytes: <.main+2958 @06528a> - <.main+2980 @0652a0>): static testCos_f64: float64 := float64.cos(pi64 / (2))
	<.main+2958 @06528a> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+2962 @06528e> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2971 @065297> : 84                         div.f64
	<.main+2972 @065298> : 01 2b 00 00                nfc(43) ;float64.cos(x: float64): float64
	<.main+2976 @06529c> : 23 f8 34 06                store.m64 <@0634f8> ;testCos_f64
	cmplStd/test/std/number.ci:39: (22 bytes: <.main+2980 @0652a0> - <.main+3002 @0652b6>): static testTan_f64: float64 := float64.tan(pi64 / (4))
	<.main+2980 @0652a0> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+2984 @0652a4> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+2993 @0652ad> : 84                         div.f64
	<.main+2994 @0652ae> : 01 2c 00 00                nfc(44) ;float64.tan(x: float64): float64
	<.main+2998 @0652b2> : 23 00 35 06                store.m64 <@063500> ;testTan_f64
	cmplStd/test/std/number.ci:40: (22 bytes: <.main+3002 @0652b6> - <.main+3024 @0652cc>): static testLog_f64: float64 := float64.log(e64 * e64 * e64)
	<.main+3002 @0652b6> : 21 50 34 06                load.m64 <@063450> ;e64
	<.main+3006 @0652ba> : 21 50 34 06                load.m64 <@063450> ;e64
	<.main+3010 @0652be> : 83                         mul.f64
	<.main+3011 @0652bf> : 21 50 34 06                load.m64 <@063450> ;e64
	<.main+3015 @0652c3> : 83                         mul.f64
	<.main+3016 @0652c4> : 01 2d 00 00                nfc(45) ;float64.log(x: float64): float64
	<.main+3020 @0652c8> : 23 08 35 06                store.m64 <@063508> ;testLog_f64
	cmplStd/test/std/number.ci:41: (17 bytes: <.main+3024 @0652cc> - <.main+3041 @0652dd>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+3024 @0652cc> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3033 @0652d5> : 01 2e 00 00                nfc(46) ;float64.exp(x: float64): float64
	<.main+3037 @0652d9> : 23 10 35 06                store.m64 <@063510> ;testExp_f64
	cmplStd/test/std/number.ci:42: (26 bytes: <.main+3041 @0652dd> - <.main+3067 @0652f7>): static testPow_f64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+3041 @0652dd> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+3045 @0652e1> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+3049 @0652e5> : 83                         mul.f64
	<.main+3050 @0652e6> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3059 @0652ef> : 01 2f 00 00                nfc(47) ;float64.pow(x: float64, y: float64): float64
	<.main+3063 @0652f3> : 23 18 35 06                store.m64 <@063518> ;testPow_f64
	cmplStd/test/std/number.ci:43: (17 bytes: <.main+3067 @0652f7> - <.main+3084 @065308>): static testSqrt_f64: float64 := float64.sqrt(pi64 * pi64)
	<.main+3067 @0652f7> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+3071 @0652fb> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+3075 @0652ff> : 83                         mul.f64
	<.main+3076 @065300> : 01 30 00 00                nfc(48) ;float64.sqrt(x: float64): float64
	<.main+3080 @065304> : 23 20 35 06                store.m64 <@063520> ;testSqrt_f64
	cmplStd/test/std/number.ci:44: (21 bytes: <.main+3084 @065308> - <.main+3105 @06531d>): static testAtan_f64: float64 := float64.atan2(pi64, 1.000000)
	<.main+3084 @065308> : 21 48 34 06                load.m64 <@063448> ;pi64
	<.main+3088 @06530c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3097 @065315> : 01 31 00 00                nfc(49) ;float64.atan2(x: float64, y: float64): float64
	<.main+3101 @065319> : 23 28 35 06                store.m64 <@063528> ;testAtan_f64
	cmplStd/test/std/number.ci:46: (18 bytes: <.main+3105 @06531d> - <.main+3123 @06532f>): static testSin_f32: float32 := float32.sin(pi32 / (2))
	<.main+3105 @06531d> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3109 @065321> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3114 @065326> : 74                         div.f32
	<.main+3115 @065327> : 01 22 00 00                nfc(34) ;float32.sin(x: float32): float32
	<.main+3119 @06532b> : 24 30 35 06                store.m32 <@063530> ;testSin_f32
	cmplStd/test/std/number.ci:47: (18 bytes: <.main+3123 @06532f> - <.main+3141 @065341>): static testCos_f32: float32 := float32.cos(pi32 / (2))
	<.main+3123 @06532f> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3127 @065333> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3132 @065338> : 74                         div.f32
	<.main+3133 @065339> : 01 23 00 00                nfc(35) ;float32.cos(x: float32): float32
	<.main+3137 @06533d> : 24 38 35 06                store.m32 <@063538> ;testCos_f32
	cmplStd/test/std/number.ci:48: (18 bytes: <.main+3141 @065341> - <.main+3159 @065353>): static testTan_f32: float32 := float32.tan(pi32 / (4))
	<.main+3141 @065341> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3145 @065345> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3150 @06534a> : 74                         div.f32
	<.main+3151 @06534b> : 01 24 00 00                nfc(36) ;float32.tan(x: float32): float32
	<.main+3155 @06534f> : 24 40 35 06                store.m32 <@063540> ;testTan_f32
	cmplStd/test/std/number.ci:49: (22 bytes: <.main+3159 @065353> - <.main+3181 @065369>): static testLog_f32: float32 := float32.log(e32 * e32 * e32)
	<.main+3159 @065353> : 20 60 34 06                load.m32 <@063460> ;e32
	<.main+3163 @065357> : 20 60 34 06                load.m32 <@063460> ;e32
	<.main+3167 @06535b> : 73                         mul.f32
	<.main+3168 @06535c> : 20 60 34 06                load.m32 <@063460> ;e32
	<.main+3172 @065360> : 73                         mul.f32
	<.main+3173 @065361> : 01 25 00 00                nfc(37) ;float32.log(x: float32): float32
	<.main+3177 @065365> : 24 48 35 06                store.m32 <@063548> ;testLog_f32
	cmplStd/test/std/number.ci:50: (13 bytes: <.main+3181 @065369> - <.main+3194 @065376>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+3181 @065369> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3186 @06536e> : 01 26 00 00                nfc(38) ;float32.exp(x: float32): float32
	<.main+3190 @065372> : 24 50 35 06                store.m32 <@063550> ;testExp_f32
	cmplStd/test/std/number.ci:51: (22 bytes: <.main+3194 @065376> - <.main+3216 @06538c>): static testPow_f32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+3194 @065376> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3198 @06537a> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3202 @06537e> : 73                         mul.f32
	<.main+3203 @06537f> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3208 @065384> : 01 27 00 00                nfc(39) ;float32.pow(x: float32, y: float32): float32
	<.main+3212 @065388> : 24 58 35 06                store.m32 <@063558> ;testPow_f32
	cmplStd/test/std/number.ci:52: (17 bytes: <.main+3216 @06538c> - <.main+3233 @06539d>): static testSqrt_f32: float32 := float32.sqrt(pi32 * pi32)
	<.main+3216 @06538c> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3220 @065390> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3224 @065394> : 73                         mul.f32
	<.main+3225 @065395> : 01 28 00 00                nfc(40) ;float32.sqrt(x: float32): float32
	<.main+3229 @065399> : 24 60 35 06                store.m32 <@063560> ;testSqrt_f32
	cmplStd/test/std/number.ci:53: (17 bytes: <.main+3233 @06539d> - <.main+3250 @0653ae>): static testAtan_f32: float32 := float32.atan2(pi32, 1.000000)
	<.main+3233 @06539d> : 20 58 34 06                load.m32 <@063458> ;pi32
	<.main+3237 @0653a1> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3242 @0653a6> : 01 29 00 00                nfc(41) ;float32.atan2(x: float32, y: float32): float32
	<.main+3246 @0653aa> : 24 68 35 06                store.m32 <@063568> ;testAtan_f32
	cmplStd/test/std/number.ci:55: (12 bytes: <.main+3250 @0653ae> - <.main+3262 @0653ba>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3250 @0653ae> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3254 @0653b2> : 01 1a 00 00                nfc(26) ;uint32.pop(value: int32): int32
	<.main+3258 @0653b6> : 24 70 35 06                store.m32 <@063570> ;testPopulation_u32
	cmplStd/test/std/number.ci:56: (12 bytes: <.main+3262 @0653ba> - <.main+3274 @0653c6>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3262 @0653ba> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3266 @0653be> : 01 1b 00 00                nfc(27) ;uint32.swap(value: int32): int32
	<.main+3270 @0653c2> : 24 78 35 06                store.m32 <@063578> ;testSwapBits_u32
	cmplStd/test/std/number.ci:57: (12 bytes: <.main+3274 @0653c6> - <.main+3286 @0653d2>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3274 @0653c6> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3278 @0653ca> : 01 1c 00 00                nfc(28) ;uint32.bsr(value: int32): int32
	<.main+3282 @0653ce> : 24 80 35 06                store.m32 <@063580> ;testBitScanReverse_u32
	cmplStd/test/std/number.ci:58: (12 bytes: <.main+3286 @0653d2> - <.main+3298 @0653de>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3286 @0653d2> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3290 @0653d6> : 01 1d 00 00                nfc(29) ;uint32.bsf(value: int32): int32
	<.main+3294 @0653da> : 24 88 35 06                store.m32 <@063588> ;testBitScanForward_u32
	cmplStd/test/std/number.ci:59: (12 bytes: <.main+3298 @0653de> - <.main+3310 @0653ea>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3298 @0653de> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3302 @0653e2> : 01 1e 00 00                nfc(30) ;uint32.hib(value: int32): int32
	<.main+3306 @0653e6> : 24 90 35 06                store.m32 <@063590> ;testHighBit_u32
	cmplStd/test/std/number.ci:60: (12 bytes: <.main+3310 @0653ea> - <.main+3322 @0653f6>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3310 @0653ea> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3314 @0653ee> : 01 1f 00 00                nfc(31) ;uint32.lob(value: int32): int32
	<.main+3318 @0653f2> : 24 98 35 06                store.m32 <@063598> ;testLowBit_u32
	cmplStd/test/std/number.ci:62: (18 bytes: <.main+3322 @0653f6> - <.main+3340 @065408>): static testZeroExtend_u32: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+3322 @0653f6> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3326 @0653fa> : 19                         load.z32
	<.main+3327 @0653fb> : 1c 05 00 00 00             load.c32 5
	<.main+3332 @065400> : 01 18 00 00                nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+3336 @065404> : 24 a0 35 06                store.m32 <@0635a0> ;testZeroExtend_u32
	cmplStd/test/std/number.ci:63: (18 bytes: <.main+3340 @065408> - <.main+3358 @06541a>): static testSignExtend_u32: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+3340 @065408> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3344 @06540c> : 19                         load.z32
	<.main+3345 @06540d> : 1c 05 00 00 00             load.c32 5
	<.main+3350 @065412> : 01 19 00 00                nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+3354 @065416> : 24 a8 35 06                store.m32 <@0635a8> ;testSignExtend_u32
	cmplStd/test/std/number.ci:65: (20 bytes: <.main+3358 @06541a> - <.main+3378 @06542e>): static testZeroExtend_u64: int32 := uint64.zxt(r5g6b5, 0, 5)
	<.main+3358 @06541a> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3362 @06541e> : 5b                         i32.2i64
	<.main+3363 @06541f> : 19                         load.z32
	<.main+3364 @065420> : 1c 05 00 00 00             load.c32 5
	<.main+3369 @065425> : 01 20 00 00                nfc(32) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3373 @065429> : 6a                         i64.2i32
	<.main+3374 @06542a> : 24 b0 35 06                store.m32 <@0635b0> ;testZeroExtend_u64
	cmplStd/test/std/number.ci:66: (20 bytes: <.main+3378 @06542e> - <.main+3398 @065442>): static testSignExtend_u64: int32 := uint64.sxt(r5g6b5, 0, 5)
	<.main+3378 @06542e> : 20 80 34 06                load.m32 <@063480> ;r5g6b5
	<.main+3382 @065432> : 5b                         i32.2i64
	<.main+3383 @065433> : 19                         load.z32
	<.main+3384 @065434> : 1c 05 00 00 00             load.c32 5
	<.main+3389 @065439> : 01 21 00 00                nfc(33) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3393 @06543d> : 6a                         i64.2i32
	<.main+3394 @06543e> : 24 b8 35 06                store.m32 <@0635b8> ;testSignExtend_u64
	cmplStd/test/std/memory.ci:7: (18 bytes: <.main+3398 @065442> - <.main+3416 @065454>): static p1: pointer := malloc(1024)
	<.main+3398 @065442> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3403 @065447> : 1c 00 04 00 00             load.c32 1024
	<.main+3408 @06544c> : 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3412 @065450> : 24 c0 35 06                store.m32 <@0635c0> ;p1
	cmplStd/test/std/memory.ci:8: (18 bytes: <.main+3416 @065454> - <.main+3434 @065466>): static p2: pointer := malloc(80)
	<.main+3416 @065454> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3421 @065459> : 1c 50 00 00 00             load.c32 80
	<.main+3426 @06545e> : 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3430 @065462> : 24 c8 35 06                store.m32 <@0635c8> ;p2
	cmplStd/test/std/memory.ci:9: (18 bytes: <.main+3434 @065466> - <.main+3452 @065478>): static p3: pointer := malloc(160)
	<.main+3434 @065466> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3439 @06546b> : 1c a0 00 00 00             load.c32 160
	<.main+3444 @065470> : 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3448 @065474> : 24 d0 35 06                store.m32 <@0635d0> ;p3
	cmplStd/test/std/memory.ci:10: (18 bytes: <.main+3452 @065478> - <.main+3470 @06548a>): static p4: pointer := malloc(820)
	<.main+3452 @065478> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3457 @06547d> : 1c 34 03 00 00             load.c32 820
	<.main+3462 @065482> : 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3466 @065486> : 24 d8 35 06                store.m32 <@0635d8> ;p4
	cmplStd/test/std/memory.ci:23: (13 bytes: <.main+3470 @06548a> - <.main+3483 @065497>): static val1: int64 := 42
	<.main+3470 @06548a> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3479 @065493> : 23 e0 35 06                store.m64 <@0635e0> ;val1
	cmplStd/test/std/memory.ci:24: (13 bytes: <.main+3483 @065497> - <.main+3496 @0654a4>): static val2: int64 := 96
	<.main+3483 @065497> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+3492 @0654a0> : 23 e8 35 06                store.m64 <@0635e8> ;val2
	cmplStd/test/std/tryExec.ci:47: (18 bytes: <.main+3496 @0654a4> - <.main+3514 @0654b6>): static tryExecErr0: int32 := tryExec(null, noError)
	<.main+3496 @0654a4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3501 @0654a9> : 1f f0 35 06 00             load.ref <@0635f0> ;noError(ptr: pointer): void
	<.main+3506 @0654ae> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3510 @0654b2> : 24 80 36 06                store.m32 <@063680> ;tryExecErr0
	cmplStd/test/std/tryExec.ci:48: (18 bytes: <.main+3514 @0654b6> - <.main+3532 @0654c8>): static tryExecErr1: int32 := tryExec(null, null)
	<.main+3514 @0654b6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3519 @0654bb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3524 @0654c0> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3528 @0654c4> : 24 88 36 06                store.m32 <@063688> ;tryExecErr1
	cmplStd/test/std/tryExec.ci:49: (18 bytes: <.main+3532 @0654c8> - <.main+3550 @0654da>): static tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+3532 @0654c8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3537 @0654cd> : 1f f8 35 06 00             load.ref <@0635f8> ;stackOverflow(ptr: pointer): void
	<.main+3542 @0654d2> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3546 @0654d6> : 24 90 36 06                store.m32 <@063690> ;tryExecErr2
	cmplStd/test/std/tryExec.ci:50: (18 bytes: <.main+3550 @0654da> - <.main+3568 @0654ec>): static tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+3550 @0654da> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3555 @0654df> : 1f 10 36 06 00             load.ref <@063610> ;divisionByZero(args: pointer): void
	<.main+3560 @0654e4> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3564 @0654e8> : 24 98 36 06                store.m32 <@063698> ;tryExecErr3
	cmplStd/test/std/tryExec.ci:51: (18 bytes: <.main+3568 @0654ec> - <.main+3586 @0654fe>): static tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+3568 @0654ec> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3573 @0654f1> : 1f 78 36 06 00             load.ref <@063678> ;invalidInstruction(args: pointer): void
	<.main+3578 @0654f6> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3582 @0654fa> : 24 a0 36 06                store.m32 <@0636a0> ;tryExecErr4
	cmplStd/test/std/tryExec.ci:52: (18 bytes: <.main+3586 @0654fe> - <.main+3604 @065510>): static tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+3586 @0654fe> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3591 @065503> : 1f 68 36 06 00             load.ref <@063668> ;invalidMemoryAccess(args: pointer): void
	<.main+3596 @065508> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3600 @06550c> : 24 a8 36 06                store.m32 <@0636a8> ;tryExecErr5
	cmplStd/test/std/tryExec.ci:53: (18 bytes: <.main+3604 @065510> - <.main+3622 @065522>): static tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+3604 @065510> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3609 @065515> : 1f 20 36 06 00             load.ref <@063620> ;abortExecution(args: pointer): void
	<.main+3614 @06551a> : 01 0c 00 00                nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3618 @06551e> : 24 b0 36 06                store.m32 <@0636b0> ;tryExecErr6
	cmplStd/test/lang/init.reference.ci:7: (13 bytes: <.main+3622 @065522> - <.main+3635 @06552f>): static value: int64 := 42
	<.main+3622 @065522> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3631 @06552b> : 23 b8 36 06                store.m64 <@0636b8> ;value
	cmplStd/test/lang/init.reference.ci:8: (9 bytes: <.main+3635 @06552f> - <.main+3644 @065538>): static valueRef: int64 := value
	<.main+3635 @06552f> : 1f b8 36 06 00             load.ref <@0636b8> ;value
	<.main+3640 @065534> : 24 c0 36 06                store.m32 <@0636c0> ;valueRef
	cmplStd/test/lang/init.reference.ci:9: (9 bytes: <.main+3644 @065538> - <.main+3653 @065541>): static valuePtr: pointer := value
	<.main+3644 @065538> : 1f b8 36 06 00             load.ref <@0636b8> ;value
	<.main+3649 @06553d> : 24 c8 36 06                store.m32 <@0636c8> ;valuePtr
	cmplStd/test/lang/init.reference.ci:10: (14 bytes: <.main+3653 @065541> - <.main+3667 @06554f>): static valueVar: variant := value
	<.main+3653 @065541> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3658 @065546> : 1f b8 36 06 00             load.ref <@0636b8> ;value
	<.main+3663 @06554b> : 23 d0 36 06                store.m64 <@0636d0> ;valueVar
	cmplStd/test/lang/init.reference.ci:12: (9 bytes: <.main+3667 @06554f> - <.main+3676 @065558>): static fromRef: int64 := valueRef
	<.main+3667 @06554f> : 20 c0 36 06                load.m32 <@0636c0> ;valueRef
	<.main+3671 @065553> : 29                         load.i64
	<.main+3672 @065554> : 23 d8 36 06                store.m64 <@0636d8> ;fromRef
	cmplStd/test/lang/init.reference.ci:13: (8 bytes: <.main+3676 @065558> - <.main+3684 @065560>): static fromPtr: int64 := valuePtr
	<.main+3676 @065558> : 20 c8 36 06                load.m32 <@0636c8> ;valuePtr
	<.main+3680 @06555c> : 24 e0 36 06                store.m32 <@0636e0> ;fromPtr
	cmplStd/test/lang/init.reference.ci:14: (8 bytes: <.main+3684 @065560> - <.main+3692 @065568>): static fromVar: int64 := valueVar
	<.main+3684 @065560> : 20 d0 36 06                load.m32 <@0636d0> ;valueVar
	<.main+3688 @065564> : 24 e8 36 06                store.m32 <@0636e8> ;fromVar
	cmplStd/test/lang/init.reference.ci:16: (9 bytes: <.main+3692 @065568> - <.main+3701 @065571>): static nullRef: int64 := null
	<.main+3692 @065568> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3697 @06556d> : 24 f0 36 06                store.m32 <@0636f0> ;nullRef
	cmplStd/test/lang/init.reference.ci:17: (9 bytes: <.main+3701 @065571> - <.main+3710 @06557a>): static nullPtr: pointer := null
	<.main+3701 @065571> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3706 @065576> : 24 f8 36 06                store.m32 <@0636f8> ;nullPtr
	cmplStd/test/lang/init.reference.ci:18: (14 bytes: <.main+3710 @06557a> - <.main+3724 @065588>): static nullVar: variant := null
	<.main+3710 @06557a> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3715 @06557f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3720 @065584> : 23 00 37 06                store.m64 <@063700> ;nullVar
	cmplStd/test/lang/init.reference.ci:19: (9 bytes: <.main+3724 @065588> - <.main+3733 @065591>): static nullTyp: typename := null
	<.main+3724 @065588> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3729 @06558d> : 24 08 37 06                store.m32 <@063708> ;nullTyp
	cmplStd/test/lang/init.reference.ci:20: (9 bytes: <.main+3733 @065591> - <.main+3742 @06559a>): static nullFun: function := null
	<.main+3733 @065591> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3738 @065596> : 24 10 37 06                store.m32 <@063710> ;nullFun
	cmplStd/test/lang/init.reference.ci:21: (9 bytes: <.main+3742 @06559a> - <.main+3751 @0655a3>): static nullObj: object := null
	<.main+3742 @06559a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3747 @06559f> : 24 18 37 06                store.m32 <@063718> ;nullObj
	cmplStd/test/lang/init.reference.ci:23: (9 bytes: <.main+3751 @0655a3> - <.main+3760 @0655ac>): static typePtr: pointer := int64
	<.main+3751 @0655a3> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3756 @0655a8> : 24 20 37 06                store.m32 <@063720> ;typePtr
	cmplStd/test/lang/init.reference.ci:24: (14 bytes: <.main+3760 @0655ac> - <.main+3774 @0655ba>): static typeVar: variant := int64
	<.main+3760 @0655ac> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3765 @0655b1> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3770 @0655b6> : 23 28 37 06                store.m64 <@063728> ;typeVar
	cmplStd/test/lang/init.reference.ci:25: (9 bytes: <.main+3774 @0655ba> - <.main+3783 @0655c3>): static typeTyp: typename := int64
	<.main+3774 @0655ba> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3779 @0655bf> : 24 30 37 06                store.m32 <@063730> ;typeTyp
	cmplStd/test/lang/init.reference.ci:27: (8 bytes: <.main+3783 @0655c3> - <.main+3791 @0655cb>): static local: int64 := value
	<.main+3783 @0655c3> : 21 b8 36 06                load.m64 <@0636b8> ;value
	<.main+3787 @0655c7> : 23 38 37 06                store.m64 <@063738> ;local
	cmplStd/test/lang/init.reference.ci:28: (8 bytes: <.main+3791 @0655cb> - <.main+3799 @0655d3>): static copyVal: int64 := local
	<.main+3791 @0655cb> : 21 38 37 06                load.m64 <@063738> ;local
	<.main+3795 @0655cf> : 23 40 37 06                store.m64 <@063740> ;copyVal
	cmplStd/test/lang/init.reference.ci:29: (8 bytes: <.main+3799 @0655d3> - <.main+3807 @0655db>): static copyRef: int64 := valueRef
	<.main+3799 @0655d3> : 20 c0 36 06                load.m32 <@0636c0> ;valueRef
	<.main+3803 @0655d7> : 24 48 37 06                store.m32 <@063748> ;copyRef
	cmplStd/test/lang/init.reference.ci:30: (8 bytes: <.main+3807 @0655db> - <.main+3815 @0655e3>): static copyPtr: pointer := valuePtr
	<.main+3807 @0655db> : 20 c8 36 06                load.m32 <@0636c8> ;valuePtr
	<.main+3811 @0655df> : 24 50 37 06                store.m32 <@063750> ;copyPtr
	cmplStd/test/lang/init.reference.ci:31: (8 bytes: <.main+3815 @0655e3> - <.main+3823 @0655eb>): static copyVar: variant := valueVar
	<.main+3815 @0655e3> : 21 d0 36 06                load.m64 <@0636d0> ;valueVar
	<.main+3819 @0655e7> : 23 58 37 06                store.m64 <@063758> ;copyVar
	cmplStd/test/lang/init.reference.ci:32: (8 bytes: <.main+3823 @0655eb> - <.main+3831 @0655f3>): static copyTyp: typename := typeTyp
	<.main+3823 @0655eb> : 20 30 37 06                load.m32 <@063730> ;typeTyp
	<.main+3827 @0655ef> : 24 60 37 06                store.m32 <@063760> ;copyTyp
	cmplStd/test/lang/init.reference.ci:35: (9 bytes: <.main+3831 @0655f3> - <.main+3840 @0655fc>): static ptrVoid: pointer := void
	<.main+3831 @0655f3> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3836 @0655f8> : 24 68 37 06                store.m32 <@063768> ;ptrVoid
	cmplStd/test/lang/init.reference.ci:36: (9 bytes: <.main+3840 @0655fc> - <.main+3849 @065605>): static ptrBool: pointer := bool
	<.main+3840 @0655fc> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3845 @065601> : 24 70 37 06                store.m32 <@063770> ;ptrBool
	cmplStd/test/lang/init.reference.ci:37: (9 bytes: <.main+3849 @065605> - <.main+3858 @06560e>): static ptrChar: pointer := char
	<.main+3849 @065605> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3854 @06560a> : 24 78 37 06                store.m32 <@063778> ;ptrChar
	cmplStd/test/lang/init.reference.ci:38: (9 bytes: <.main+3858 @06560e> - <.main+3867 @065617>): static ptrInt8: pointer := int8
	<.main+3858 @06560e> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+3863 @065613> : 24 80 37 06                store.m32 <@063780> ;ptrInt8
	cmplStd/test/lang/init.reference.ci:39: (9 bytes: <.main+3867 @065617> - <.main+3876 @065620>): static ptrInt16: pointer := int16
	<.main+3867 @065617> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+3872 @06561c> : 24 88 37 06                store.m32 <@063788> ;ptrInt16
	cmplStd/test/lang/init.reference.ci:40: (9 bytes: <.main+3876 @065620> - <.main+3885 @065629>): static ptrInt32: pointer := int32
	<.main+3876 @065620> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+3881 @065625> : 24 90 37 06                store.m32 <@063790> ;ptrInt32
	cmplStd/test/lang/init.reference.ci:41: (9 bytes: <.main+3885 @065629> - <.main+3894 @065632>): static ptrInt64: pointer := int64
	<.main+3885 @065629> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3890 @06562e> : 24 98 37 06                store.m32 <@063798> ;ptrInt64
	cmplStd/test/lang/init.reference.ci:42: (9 bytes: <.main+3894 @065632> - <.main+3903 @06563b>): static ptrUint8: pointer := uint8
	<.main+3894 @065632> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+3899 @065637> : 24 a0 37 06                store.m32 <@0637a0> ;ptrUint8
	cmplStd/test/lang/init.reference.ci:43: (9 bytes: <.main+3903 @06563b> - <.main+3912 @065644>): static ptrUint16: pointer := uint16
	<.main+3903 @06563b> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+3908 @065640> : 24 a8 37 06                store.m32 <@0637a8> ;ptrUint16
	cmplStd/test/lang/init.reference.ci:44: (9 bytes: <.main+3912 @065644> - <.main+3921 @06564d>): static ptrUint32: pointer := uint32
	<.main+3912 @065644> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+3917 @065649> : 24 b0 37 06                store.m32 <@0637b0> ;ptrUint32
	cmplStd/test/lang/init.reference.ci:45: (9 bytes: <.main+3921 @06564d> - <.main+3930 @065656>): static ptrUint64: pointer := uint64
	<.main+3921 @06564d> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+3926 @065652> : 24 b8 37 06                store.m32 <@0637b8> ;ptrUint64
	cmplStd/test/lang/init.reference.ci:46: (9 bytes: <.main+3930 @065656> - <.main+3939 @06565f>): static ptrFloat32: pointer := float32
	<.main+3930 @065656> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+3935 @06565b> : 24 c0 37 06                store.m32 <@0637c0> ;ptrFloat32
	cmplStd/test/lang/init.reference.ci:47: (9 bytes: <.main+3939 @06565f> - <.main+3948 @065668>): static ptrFloat64: pointer := float64
	<.main+3939 @06565f> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+3944 @065664> : 24 c8 37 06                store.m32 <@0637c8> ;ptrFloat64
	cmplStd/test/lang/init.reference.ci:48: (9 bytes: <.main+3948 @065668> - <.main+3957 @065671>): static ptrTypename: pointer := typename
	<.main+3948 @065668> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3953 @06566d> : 24 d0 37 06                store.m32 <@0637d0> ;ptrTypename
	cmplStd/test/lang/init.reference.ci:49: (9 bytes: <.main+3957 @065671> - <.main+3966 @06567a>): static ptrFunction: pointer := function
	<.main+3957 @065671> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+3962 @065676> : 24 d8 37 06                store.m32 <@0637d8> ;ptrFunction
	cmplStd/test/lang/init.reference.ci:50: (9 bytes: <.main+3966 @06567a> - <.main+3975 @065683>): static ptrPointer: pointer := pointer
	<.main+3966 @06567a> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3971 @06567f> : 24 e0 37 06                store.m32 <@0637e0> ;ptrPointer
	cmplStd/test/lang/init.reference.ci:51: (9 bytes: <.main+3975 @065683> - <.main+3984 @06568c>): static ptrVariant: pointer := variant
	<.main+3975 @065683> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+3980 @065688> : 24 e8 37 06                store.m32 <@0637e8> ;ptrVariant
	cmplStd/test/lang/init.reference.ci:52: (9 bytes: <.main+3984 @06568c> - <.main+3993 @065695>): static ptrObject: pointer := object
	<.main+3984 @06568c> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+3989 @065691> : 24 f0 37 06                store.m32 <@0637f0> ;ptrObject
	cmplStd/test/lang/init.reference.ci:55: (14 bytes: <.main+3993 @065695> - <.main+4007 @0656a3>): static varVoid: variant := void
	<.main+3993 @065695> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3998 @06569a> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4003 @06569f> : 23 f8 37 06                store.m64 <@0637f8> ;varVoid
	cmplStd/test/lang/init.reference.ci:56: (14 bytes: <.main+4007 @0656a3> - <.main+4021 @0656b1>): static varBool: variant := bool
	<.main+4007 @0656a3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4012 @0656a8> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4017 @0656ad> : 23 00 38 06                store.m64 <@063800> ;varBool
	cmplStd/test/lang/init.reference.ci:57: (14 bytes: <.main+4021 @0656b1> - <.main+4035 @0656bf>): static varChar: variant := char
	<.main+4021 @0656b1> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4026 @0656b6> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4031 @0656bb> : 23 08 38 06                store.m64 <@063808> ;varChar
	cmplStd/test/lang/init.reference.ci:58: (14 bytes: <.main+4035 @0656bf> - <.main+4049 @0656cd>): static varInt8: variant := int8
	<.main+4035 @0656bf> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4040 @0656c4> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4045 @0656c9> : 23 10 38 06                store.m64 <@063810> ;varInt8
	cmplStd/test/lang/init.reference.ci:59: (14 bytes: <.main+4049 @0656cd> - <.main+4063 @0656db>): static varInt16: variant := int16
	<.main+4049 @0656cd> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4054 @0656d2> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4059 @0656d7> : 23 18 38 06                store.m64 <@063818> ;varInt16
	cmplStd/test/lang/init.reference.ci:60: (14 bytes: <.main+4063 @0656db> - <.main+4077 @0656e9>): static varInt32: variant := int32
	<.main+4063 @0656db> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4068 @0656e0> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4073 @0656e5> : 23 20 38 06                store.m64 <@063820> ;varInt32
	cmplStd/test/lang/init.reference.ci:61: (14 bytes: <.main+4077 @0656e9> - <.main+4091 @0656f7>): static varInt64: variant := int64
	<.main+4077 @0656e9> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4082 @0656ee> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4087 @0656f3> : 23 28 38 06                store.m64 <@063828> ;varInt64
	cmplStd/test/lang/init.reference.ci:62: (14 bytes: <.main+4091 @0656f7> - <.main+4105 @065705>): static varUint8: variant := uint8
	<.main+4091 @0656f7> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4096 @0656fc> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4101 @065701> : 23 30 38 06                store.m64 <@063830> ;varUint8
	cmplStd/test/lang/init.reference.ci:63: (14 bytes: <.main+4105 @065705> - <.main+4119 @065713>): static varUint16: variant := uint16
	<.main+4105 @065705> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4110 @06570a> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4115 @06570f> : 23 38 38 06                store.m64 <@063838> ;varUint16
	cmplStd/test/lang/init.reference.ci:64: (14 bytes: <.main+4119 @065713> - <.main+4133 @065721>): static varUint32: variant := uint32
	<.main+4119 @065713> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4124 @065718> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4129 @06571d> : 23 40 38 06                store.m64 <@063840> ;varUint32
	cmplStd/test/lang/init.reference.ci:65: (14 bytes: <.main+4133 @065721> - <.main+4147 @06572f>): static varUint64: variant := uint64
	<.main+4133 @065721> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4138 @065726> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4143 @06572b> : 23 48 38 06                store.m64 <@063848> ;varUint64
	cmplStd/test/lang/init.reference.ci:66: (14 bytes: <.main+4147 @06572f> - <.main+4161 @06573d>): static varFloat32: variant := float32
	<.main+4147 @06572f> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4152 @065734> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4157 @065739> : 23 50 38 06                store.m64 <@063850> ;varFloat32
	cmplStd/test/lang/init.reference.ci:67: (14 bytes: <.main+4161 @06573d> - <.main+4175 @06574b>): static varFloat64: variant := float64
	<.main+4161 @06573d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4166 @065742> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4171 @065747> : 23 58 38 06                store.m64 <@063858> ;varFloat64
	cmplStd/test/lang/init.reference.ci:68: (14 bytes: <.main+4175 @06574b> - <.main+4189 @065759>): static varTypename: variant := typename
	<.main+4175 @06574b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4180 @065750> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4185 @065755> : 23 60 38 06                store.m64 <@063860> ;varTypename
	cmplStd/test/lang/init.reference.ci:69: (14 bytes: <.main+4189 @065759> - <.main+4203 @065767>): static varFunction: variant := function
	<.main+4189 @065759> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4194 @06575e> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4199 @065763> : 23 68 38 06                store.m64 <@063868> ;varFunction
	cmplStd/test/lang/init.reference.ci:70: (14 bytes: <.main+4203 @065767> - <.main+4217 @065775>): static varPointer: variant := pointer
	<.main+4203 @065767> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4208 @06576c> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4213 @065771> : 23 70 38 06                store.m64 <@063870> ;varPointer
	cmplStd/test/lang/init.reference.ci:71: (14 bytes: <.main+4217 @065775> - <.main+4231 @065783>): static varVariant: variant := variant
	<.main+4217 @065775> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4222 @06577a> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4227 @06577f> : 23 78 38 06                store.m64 <@063878> ;varVariant
	cmplStd/test/lang/init.reference.ci:72: (14 bytes: <.main+4231 @065783> - <.main+4245 @065791>): static varObject: variant := object
	<.main+4231 @065783> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4236 @065788> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4241 @06578d> : 23 80 38 06                store.m64 <@063880> ;varObject
	cmplStd/test/lang/init.reference.ci:75: (9 bytes: <.main+4245 @065791> - <.main+4254 @06579a>): static typVoid: typename := void
	<.main+4245 @065791> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4250 @065796> : 24 88 38 06                store.m32 <@063888> ;typVoid
	cmplStd/test/lang/init.reference.ci:76: (9 bytes: <.main+4254 @06579a> - <.main+4263 @0657a3>): static typBool: typename := bool
	<.main+4254 @06579a> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4259 @06579f> : 24 90 38 06                store.m32 <@063890> ;typBool
	cmplStd/test/lang/init.reference.ci:77: (9 bytes: <.main+4263 @0657a3> - <.main+4272 @0657ac>): static typChar: typename := char
	<.main+4263 @0657a3> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4268 @0657a8> : 24 98 38 06                store.m32 <@063898> ;typChar
	cmplStd/test/lang/init.reference.ci:78: (9 bytes: <.main+4272 @0657ac> - <.main+4281 @0657b5>): static typInt8: typename := int8
	<.main+4272 @0657ac> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4277 @0657b1> : 24 a0 38 06                store.m32 <@0638a0> ;typInt8
	cmplStd/test/lang/init.reference.ci:79: (9 bytes: <.main+4281 @0657b5> - <.main+4290 @0657be>): static typInt16: typename := int16
	<.main+4281 @0657b5> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4286 @0657ba> : 24 a8 38 06                store.m32 <@0638a8> ;typInt16
	cmplStd/test/lang/init.reference.ci:80: (9 bytes: <.main+4290 @0657be> - <.main+4299 @0657c7>): static typInt32: typename := int32
	<.main+4290 @0657be> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4295 @0657c3> : 24 b0 38 06                store.m32 <@0638b0> ;typInt32
	cmplStd/test/lang/init.reference.ci:81: (9 bytes: <.main+4299 @0657c7> - <.main+4308 @0657d0>): static typInt64: typename := int64
	<.main+4299 @0657c7> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4304 @0657cc> : 24 b8 38 06                store.m32 <@0638b8> ;typInt64
	cmplStd/test/lang/init.reference.ci:82: (9 bytes: <.main+4308 @0657d0> - <.main+4317 @0657d9>): static typUint8: typename := uint8
	<.main+4308 @0657d0> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4313 @0657d5> : 24 c0 38 06                store.m32 <@0638c0> ;typUint8
	cmplStd/test/lang/init.reference.ci:83: (9 bytes: <.main+4317 @0657d9> - <.main+4326 @0657e2>): static typUint16: typename := uint16
	<.main+4317 @0657d9> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4322 @0657de> : 24 c8 38 06                store.m32 <@0638c8> ;typUint16
	cmplStd/test/lang/init.reference.ci:84: (9 bytes: <.main+4326 @0657e2> - <.main+4335 @0657eb>): static typUint32: typename := uint32
	<.main+4326 @0657e2> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4331 @0657e7> : 24 d0 38 06                store.m32 <@0638d0> ;typUint32
	cmplStd/test/lang/init.reference.ci:85: (9 bytes: <.main+4335 @0657eb> - <.main+4344 @0657f4>): static typUint64: typename := uint64
	<.main+4335 @0657eb> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4340 @0657f0> : 24 d8 38 06                store.m32 <@0638d8> ;typUint64
	cmplStd/test/lang/init.reference.ci:86: (9 bytes: <.main+4344 @0657f4> - <.main+4353 @0657fd>): static typFloat32: typename := float32
	<.main+4344 @0657f4> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4349 @0657f9> : 24 e0 38 06                store.m32 <@0638e0> ;typFloat32
	cmplStd/test/lang/init.reference.ci:87: (9 bytes: <.main+4353 @0657fd> - <.main+4362 @065806>): static typFloat64: typename := float64
	<.main+4353 @0657fd> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4358 @065802> : 24 e8 38 06                store.m32 <@0638e8> ;typFloat64
	cmplStd/test/lang/init.reference.ci:88: (9 bytes: <.main+4362 @065806> - <.main+4371 @06580f>): static typTypename: typename := typename
	<.main+4362 @065806> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4367 @06580b> : 24 f0 38 06                store.m32 <@0638f0> ;typTypename
	cmplStd/test/lang/init.reference.ci:89: (9 bytes: <.main+4371 @06580f> - <.main+4380 @065818>): static typFunction: typename := function
	<.main+4371 @06580f> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4376 @065814> : 24 f8 38 06                store.m32 <@0638f8> ;typFunction
	cmplStd/test/lang/init.reference.ci:90: (9 bytes: <.main+4380 @065818> - <.main+4389 @065821>): static typPointer: typename := pointer
	<.main+4380 @065818> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4385 @06581d> : 24 00 39 06                store.m32 <@063900> ;typPointer
	cmplStd/test/lang/init.reference.ci:91: (9 bytes: <.main+4389 @065821> - <.main+4398 @06582a>): static typVariant: typename := variant
	<.main+4389 @065821> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4394 @065826> : 24 08 39 06                store.m32 <@063908> ;typVariant
	cmplStd/test/lang/init.reference.ci:92: (9 bytes: <.main+4398 @06582a> - <.main+4407 @065833>): static typObject: typename := object
	<.main+4398 @06582a> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4403 @06582f> : 24 10 39 06                store.m32 <@063910> ;typObject
	cmplStd/test/lang/init.reference.ci:95: (9 bytes: <.main+4407 @065833> - <.main+4416 @06583c>): static valueOfPtr: pointer := pointer(value)
	<.main+4407 @065833> : 1f b8 36 06 00             load.ref <@0636b8> ;value
	<.main+4412 @065838> : 24 18 39 06                store.m32 <@063918> ;valueOfPtr
	cmplStd/test/lang/init.reference.ci:96: (14 bytes: <.main+4416 @06583c> - <.main+4430 @06584a>): static valueOfVar: variant := variant(value)
	<.main+4416 @06583c> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4421 @065841> : 1f b8 36 06 00             load.ref <@0636b8> ;value
	<.main+4426 @065846> : 23 20 39 06                store.m64 <@063920> ;valueOfVar
	cmplStd/test/lang/init.reference.ci:97: (9 bytes: <.main+4430 @06584a> - <.main+4439 @065853>): static valueOfTyp: typename := typename(value)
	<.main+4430 @06584a> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4435 @06584f> : 24 28 39 06                store.m32 <@063928> ;valueOfTyp
	cmplStd/test/lang/init.reference.ci:99: (9 bytes: <.main+4439 @065853> - <.main+4448 @06585c>): static typeOfValue: typename := typename(value)
	<.main+4439 @065853> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4444 @065858> : 24 30 39 06                store.m32 <@063930> ;typeOfValue
	cmplStd/test/lang/init.reference.ci:105: (13 bytes: <.main+4448 @06585c> - <.main+4461 @065869>): static copyPtrFloat64: variant := ptrFloat64
	<.main+4448 @06585c> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4453 @065861> : 20 c8 37 06                load.m32 <@0637c8> ;ptrFloat64
	<.main+4457 @065865> : 23 38 39 06                store.m64 <@063938> ;copyPtrFloat64
	cmplStd/test/lang/init.reference.ci:108: (8 bytes: <.main+4461 @065869> - <.main+4469 @065871>): static copyVarFloat64: pointer := varFloat64
	<.main+4461 @065869> : 20 58 38 06                load.m32 <@063858> ;varFloat64
	<.main+4465 @06586d> : 24 40 39 06                store.m32 <@063940> ;copyVarFloat64
	cmplStd/test/lang/init.variable.ci:3: (5 bytes: <.main+4469 @065871> - <.main+4474 @065876>): static variable: int32
	<.main+4469 @065871> : 19                         load.z32
	<.main+4470 @065872> : 24 48 39 06                store.m32 <@063948> ;variable
	cmplStd/test/lang/init.variable.ci:7: (9 bytes: <.main+4474 @065876> - <.main+4483 @06587f>): static const constant: int32 := 42
	<.main+4474 @065876> : 1c 2a 00 00 00             load.c32 42
	<.main+4479 @06587b> : 24 50 39 06                store.m32 <@063950> ;constant
	cmplStd/test/lang/init.variable.ci:24: (18 bytes: <.main+4483 @06587f> - <.main+4501 @065891>): static valInitImplicit: ComplexVal := {...}
	cmplStd/test/lang/init.variable.ci:24: (13 bytes: <.main+4483 @06587f> - <.main+4496 @06588c>): valInitImplicit.re := (8);
	<.main+4483 @06587f> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4492 @065888> : 23 58 39 06                store.m64 <@063958> ;valInitImplicit
	:: (5 bytes: <.main+4496 @06588c> - <.main+4501 @065891>): valInitImplicit.im := (0);
	<.main+4496 @06588c> : 1a                         load.z64
	<.main+4497 @06588d> : 23 60 39 06                store.m64 <@063960> ;valInitImplicit+8
	cmplStd/test/lang/init.variable.ci:33: (41 bytes: <.main+4501 @065891> - <.main+4542 @0658ba>): static objInitImplicit: ComplexObj := {...}
	cmplStd/test/lang/init.variable.ci:33: (13 bytes: <.main+4501 @065891> - <.main+4514 @06589e>): objInitImplicit := create(ComplexObj);
	<.main+4501 @065891> : 1f e0 b8 04 00             load.ref <@04b8e0> ;ComplexObj
	<.main+4506 @065896> : 01 07 00 00                nfc(7) ;object.create(type: typename): pointer
	<.main+4510 @06589a> : 24 68 39 06                store.m32 <@063968> ;objInitImplicit
	cmplStd/test/lang/init.variable.ci:33: (18 bytes: <.main+4514 @06589e> - <.main+4532 @0658b0>): objInitImplicit.re := (8);
	<.main+4514 @06589e> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4523 @0658a7> : 20 68 39 06                load.m32 <@063968> ;objInitImplicit
	<.main+4527 @0658ab> : 0c 04 00 00                inc.i32(+4)
	<.main+4531 @0658af> : 2e                         store.i64
	:: (10 bytes: <.main+4532 @0658b0> - <.main+4542 @0658ba>): objInitImplicit.im := (0);
	<.main+4532 @0658b0> : 1a                         load.z64
	<.main+4533 @0658b1> : 20 68 39 06                load.m32 <@063968> ;objInitImplicit
	<.main+4537 @0658b5> : 0c 0c 00 00                inc.i32(+12)
	<.main+4541 @0658b9> : 2e                         store.i64
	cmplStd/test/lang/init.variable.ci:41: (41 bytes: <.main+4542 @0658ba> - <.main+4583 @0658e3>): static objInitExplicit: object := {...}
	cmplStd/test/lang/init.variable.ci:41: (13 bytes: <.main+4542 @0658ba> - <.main+4555 @0658c7>): objInitExplicit := create(ComplexObj);
	<.main+4542 @0658ba> : 1f e0 b8 04 00             load.ref <@04b8e0> ;ComplexObj
	<.main+4547 @0658bf> : 01 07 00 00                nfc(7) ;object.create(type: typename): pointer
	<.main+4551 @0658c3> : 24 70 39 06                store.m32 <@063970> ;objInitExplicit
	cmplStd/test/lang/init.variable.ci:41: (18 bytes: <.main+4555 @0658c7> - <.main+4573 @0658d9>): objInitExplicit.re := (8);
	<.main+4555 @0658c7> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4564 @0658d0> : 20 70 39 06                load.m32 <@063970> ;objInitExplicit
	<.main+4568 @0658d4> : 0c 04 00 00                inc.i32(+4)
	<.main+4572 @0658d8> : 2e                         store.i64
	:: (10 bytes: <.main+4573 @0658d9> - <.main+4583 @0658e3>): objInitExplicit.im := (0);
	<.main+4573 @0658d9> : 1a                         load.z64
	<.main+4574 @0658da> : 20 70 39 06                load.m32 <@063970> ;objInitExplicit
	<.main+4578 @0658de> : 0c 0c 00 00                inc.i32(+12)
	<.main+4582 @0658e2> : 2e                         store.i64
	cmplStd/test/lang/function.ci:12: (25 bytes: <.main+4583 @0658e3> - <.main+4608 @0658fc>): static funAddResult: int32 := funAdd(2, 7)
	<.main+4583 @0658e3> : 19                         load.z32
	<.main+4584 @0658e4> : 1c 02 00 00 00             load.c32 2
	<.main+4589 @0658e9> : 1c 07 00 00 00             load.c32 7
	<.main+4594 @0658ee> : 1f 80 39 06 00             load.ref <@063980> ;funAdd(x: int32, y: int32): int32
	<.main+4599 @0658f3> : 02                         call
	<.main+4600 @0658f4> : 09 f8 ff ff                inc.sp(-8)
	<.main+4604 @0658f8> : 24 88 39 06                store.m32 <@063988> ;funAddResult
	cmplStd/test/lang/function.ci:15: (9 bytes: <.main+4608 @0658fc> - <.main+4617 @065905>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+4608 @0658fc> : 1f 80 39 06 00             load.ref <@063980> ;funAdd(x: int32, y: int32): int32
	<.main+4613 @065901> : 24 90 39 06                store.m32 <@063990> ;funAddRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:18: (24 bytes: <.main+4617 @065905> - <.main+4641 @06591d>): static funAddRefResult: int32 := funAddRef(2, 8)
	<.main+4617 @065905> : 19                         load.z32
	<.main+4618 @065906> : 1c 02 00 00 00             load.c32 2
	<.main+4623 @06590b> : 1c 08 00 00 00             load.c32 8
	<.main+4628 @065910> : 20 90 39 06                load.m32 <@063990> ;funAddRef(x: int32, y: int32): int32
	<.main+4632 @065914> : 02                         call
	<.main+4633 @065915> : 09 f8 ff ff                inc.sp(-8)
	<.main+4637 @065919> : 24 98 39 06                store.m32 <@063998> ;funAddRefResult
	cmplStd/test/lang/function.ci:21: (9 bytes: <.main+4641 @06591d> - <.main+4650 @065926>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+4641 @06591d> : 1f c0 39 06 00             load.ref <@0639c0> ;funMul(x: int32, y: int32): int32
	<.main+4646 @065922> : 24 a0 39 06                store.m32 <@0639a0> ;funMul(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:24: (24 bytes: <.main+4650 @065926> - <.main+4674 @06593e>): static funMulResult: int32 := funMul(2, 6)
	<.main+4650 @065926> : 19                         load.z32
	<.main+4651 @065927> : 1c 02 00 00 00             load.c32 2
	<.main+4656 @06592c> : 1c 06 00 00 00             load.c32 6
	<.main+4661 @065931> : 20 a0 39 06                load.m32 <@0639a0> ;funMul(x: int32, y: int32): int32
	<.main+4665 @065935> : 02                         call
	<.main+4666 @065936> : 09 f8 ff ff                inc.sp(-8)
	<.main+4670 @06593a> : 24 a8 39 06                store.m32 <@0639a8> ;funMulResult
	cmplStd/test/lang/function.ci:27: (8 bytes: <.main+4674 @06593e> - <.main+4682 @065946>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+4674 @06593e> : 20 a0 39 06                load.m32 <@0639a0> ;funMul(x: int32, y: int32): int32
	<.main+4678 @065942> : 24 b0 39 06                store.m32 <@0639b0> ;funMulRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:30: (24 bytes: <.main+4682 @065946> - <.main+4706 @06595e>): static funMulRefResult: int32 := funMulRef(2, 7)
	<.main+4682 @065946> : 19                         load.z32
	<.main+4683 @065947> : 1c 02 00 00 00             load.c32 2
	<.main+4688 @06594c> : 1c 07 00 00 00             load.c32 7
	<.main+4693 @065951> : 20 b0 39 06                load.m32 <@0639b0> ;funMulRef(x: int32, y: int32): int32
	<.main+4697 @065955> : 02                         call
	<.main+4698 @065956> : 09 f8 ff ff                inc.sp(-8)
	<.main+4702 @06595a> : 24 b8 39 06                store.m32 <@0639b8> ;funMulRefResult
	cmplStd/test/lang/function.ci:46: (20 bytes: <.main+4706 @06595e> - <.main+4726 @065972>): static fibonacci_13: uint32 := fib(13)
	<.main+4706 @06595e> : 19                         load.z32
	<.main+4707 @06595f> : 1c 0d 00 00 00             load.c32 13
	<.main+4712 @065964> : 1f c8 39 06 00             load.ref <@0639c8> ;fib(n: uint32): uint32
	<.main+4717 @065969> : 02                         call
	<.main+4718 @06596a> : 09 fc ff ff                inc.sp(-4)
	<.main+4722 @06596e> : 24 00 3a 06                store.m32 <@063a00> ;fibonacci_13
	cmplStd/test/lang/reflect.ci:3: (13 bytes: <.main+4726 @065972> - <.main+4739 @06597f>): static sizeofVoid: int32 := sizeof(void)
	<.main+4726 @065972> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4731 @065977> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4735 @06597b> : 24 08 3a 06                store.m32 <@063a08> ;sizeofVoid
	cmplStd/test/lang/reflect.ci:4: (13 bytes: <.main+4739 @06597f> - <.main+4752 @06598c>): static sizeofBool: int32 := sizeof(bool)
	<.main+4739 @06597f> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4744 @065984> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4748 @065988> : 24 10 3a 06                store.m32 <@063a10> ;sizeofBool
	cmplStd/test/lang/reflect.ci:5: (13 bytes: <.main+4752 @06598c> - <.main+4765 @065999>): static sizeofChar: int32 := sizeof(char)
	<.main+4752 @06598c> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4757 @065991> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4761 @065995> : 24 18 3a 06                store.m32 <@063a18> ;sizeofChar
	cmplStd/test/lang/reflect.ci:6: (13 bytes: <.main+4765 @065999> - <.main+4778 @0659a6>): static sizeofInt8: int32 := sizeof(int8)
	<.main+4765 @065999> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4770 @06599e> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4774 @0659a2> : 24 20 3a 06                store.m32 <@063a20> ;sizeofInt8
	cmplStd/test/lang/reflect.ci:7: (13 bytes: <.main+4778 @0659a6> - <.main+4791 @0659b3>): static sizeofInt16: int32 := sizeof(int16)
	<.main+4778 @0659a6> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4783 @0659ab> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4787 @0659af> : 24 28 3a 06                store.m32 <@063a28> ;sizeofInt16
	cmplStd/test/lang/reflect.ci:8: (13 bytes: <.main+4791 @0659b3> - <.main+4804 @0659c0>): static sizeofInt32: int32 := sizeof(int32)
	<.main+4791 @0659b3> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4796 @0659b8> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4800 @0659bc> : 24 30 3a 06                store.m32 <@063a30> ;sizeofInt32
	cmplStd/test/lang/reflect.ci:9: (13 bytes: <.main+4804 @0659c0> - <.main+4817 @0659cd>): static sizeofInt64: int32 := sizeof(int64)
	<.main+4804 @0659c0> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4809 @0659c5> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4813 @0659c9> : 24 38 3a 06                store.m32 <@063a38> ;sizeofInt64
	cmplStd/test/lang/reflect.ci:10: (13 bytes: <.main+4817 @0659cd> - <.main+4830 @0659da>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+4817 @0659cd> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4822 @0659d2> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4826 @0659d6> : 24 40 3a 06                store.m32 <@063a40> ;sizeofUint8
	cmplStd/test/lang/reflect.ci:11: (13 bytes: <.main+4830 @0659da> - <.main+4843 @0659e7>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+4830 @0659da> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4835 @0659df> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4839 @0659e3> : 24 48 3a 06                store.m32 <@063a48> ;sizeofUint16
	cmplStd/test/lang/reflect.ci:12: (13 bytes: <.main+4843 @0659e7> - <.main+4856 @0659f4>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+4843 @0659e7> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4848 @0659ec> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4852 @0659f0> : 24 50 3a 06                store.m32 <@063a50> ;sizeofUint32
	cmplStd/test/lang/reflect.ci:13: (13 bytes: <.main+4856 @0659f4> - <.main+4869 @065a01>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+4856 @0659f4> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4861 @0659f9> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4865 @0659fd> : 24 58 3a 06                store.m32 <@063a58> ;sizeofUint64
	cmplStd/test/lang/reflect.ci:14: (13 bytes: <.main+4869 @065a01> - <.main+4882 @065a0e>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+4869 @065a01> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4874 @065a06> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4878 @065a0a> : 24 60 3a 06                store.m32 <@063a60> ;sizeofFloat32
	cmplStd/test/lang/reflect.ci:15: (13 bytes: <.main+4882 @065a0e> - <.main+4895 @065a1b>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+4882 @065a0e> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4887 @065a13> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4891 @065a17> : 24 68 3a 06                store.m32 <@063a68> ;sizeofFloat64
	cmplStd/test/lang/reflect.ci:16: (13 bytes: <.main+4895 @065a1b> - <.main+4908 @065a28>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+4895 @065a1b> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4900 @065a20> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4904 @065a24> : 24 70 3a 06                store.m32 <@063a70> ;sizeofPointer
	cmplStd/test/lang/reflect.ci:17: (13 bytes: <.main+4908 @065a28> - <.main+4921 @065a35>): static sizeofVariant: int32 := sizeof(variant)
	<.main+4908 @065a28> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4913 @065a2d> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4917 @065a31> : 24 78 3a 06                store.m32 <@063a78> ;sizeofVariant
	cmplStd/test/lang/reflect.ci:18: (13 bytes: <.main+4921 @065a35> - <.main+4934 @065a42>): static sizeofTypename: int32 := sizeof(typename)
	<.main+4921 @065a35> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4926 @065a3a> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4930 @065a3e> : 24 80 3a 06                store.m32 <@063a80> ;sizeofTypename
	cmplStd/test/lang/reflect.ci:19: (13 bytes: <.main+4934 @065a42> - <.main+4947 @065a4f>): static sizeofFunction: int32 := sizeof(function)
	<.main+4934 @065a42> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4939 @065a47> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4943 @065a4b> : 24 88 3a 06                store.m32 <@063a88> ;sizeofFunction
	cmplStd/test/lang/reflect.ci:20: (13 bytes: <.main+4947 @065a4f> - <.main+4960 @065a5c>): static sizeofObject: int32 := sizeof(object)
	<.main+4947 @065a4f> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4952 @065a54> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4956 @065a58> : 24 90 3a 06                store.m32 <@063a90> ;sizeofObject
	cmplStd/test/lang/reflect.ci:30: (9 bytes: <.main+4960 @065a5c> - <.main+4969 @065a65>): static typeofRecord: typename := RecordSizeofExt
	<.main+4960 @065a5c> : 1f f0 df 04 00             load.ref <@04dff0> ;RecordSizeofExt
	<.main+4965 @065a61> : 24 98 3a 06                store.m32 <@063a98> ;typeofRecord
	cmplStd/test/lang/reflect.ci:31: (12 bytes: <.main+4969 @065a65> - <.main+4981 @065a71>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+4969 @065a65> : 20 98 3a 06                load.m32 <@063a98> ;typeofRecord
	<.main+4973 @065a69> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4977 @065a6d> : 24 a0 3a 06                store.m32 <@063aa0> ;nameOfRecord
	cmplStd/test/lang/reflect.ci:32: (13 bytes: <.main+4981 @065a71> - <.main+4994 @065a7e>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+4981 @065a71> : 20 98 3a 06                load.m32 <@063a98> ;typeofRecord
	<.main+4985 @065a75> : 0c 28 00 00                inc.i32(+40)
	<.main+4989 @065a79> : 28                         load.i32
	<.main+4990 @065a7a> : 24 a8 3a 06                store.m32 <@063aa8> ;offsetOfRecord
	cmplStd/test/lang/reflect.ci:33: (13 bytes: <.main+4994 @065a7e> - <.main+5007 @065a8b>): static sizeOfRecord: int32 := typeofRecord.size
	<.main+4994 @065a7e> : 20 98 3a 06                load.m32 <@063a98> ;typeofRecord
	<.main+4998 @065a82> : 0c 20 00 00                inc.i32(+32)
	<.main+5002 @065a86> : 28                         load.i32
	<.main+5003 @065a87> : 24 b0 3a 06                store.m32 <@063ab0> ;sizeOfRecord
	cmplStd/test/lang/reflect.ci:34: (12 bytes: <.main+5007 @065a8b> - <.main+5019 @065a97>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+5007 @065a8b> : 20 98 3a 06                load.m32 <@063a98> ;typeofRecord
	<.main+5011 @065a8f> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+5015 @065a93> : 24 b8 3a 06                store.m32 <@063ab8> ;fileOfRecord
	cmplStd/test/lang/reflect.ci:35: (12 bytes: <.main+5019 @065a97> - <.main+5031 @065aa3>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+5019 @065a97> : 20 98 3a 06                load.m32 <@063a98> ;typeofRecord
	<.main+5023 @065a9b> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+5027 @065a9f> : 24 c0 3a 06                store.m32 <@063ac0> ;lineOfRecord
	cmplStd/test/lang/reflect.ci:37: (12 bytes: <.main+5031 @065aa3> - <.main+5043 @065aaf>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+5031 @065aa3> : 20 98 3a 06                load.m32 <@063a98> ;typeofRecord
	<.main+5035 @065aa7> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5039 @065aab> : 24 c8 3a 06                store.m32 <@063ac8> ;typeofBase
	cmplStd/test/lang/reflect.ci:38: (12 bytes: <.main+5043 @065aaf> - <.main+5055 @065abb>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+5043 @065aaf> : 20 c8 3a 06                load.m32 <@063ac8> ;typeofBase
	<.main+5047 @065ab3> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+5051 @065ab7> : 24 d0 3a 06                store.m32 <@063ad0> ;nameOfBase
	cmplStd/test/lang/reflect.ci:39: (13 bytes: <.main+5055 @065abb> - <.main+5068 @065ac8>): static offsetOfBase: int32 := typeofBase.offset
	<.main+5055 @065abb> : 20 c8 3a 06                load.m32 <@063ac8> ;typeofBase
	<.main+5059 @065abf> : 0c 28 00 00                inc.i32(+40)
	<.main+5063 @065ac3> : 28                         load.i32
	<.main+5064 @065ac4> : 24 d8 3a 06                store.m32 <@063ad8> ;offsetOfBase
	cmplStd/test/lang/reflect.ci:40: (13 bytes: <.main+5068 @065ac8> - <.main+5081 @065ad5>): static sizeOfBase: int32 := typeofBase.size
	<.main+5068 @065ac8> : 20 c8 3a 06                load.m32 <@063ac8> ;typeofBase
	<.main+5072 @065acc> : 0c 20 00 00                inc.i32(+32)
	<.main+5076 @065ad0> : 28                         load.i32
	<.main+5077 @065ad1> : 24 e0 3a 06                store.m32 <@063ae0> ;sizeOfBase
	cmplStd/test/lang/reflect.ci:41: (12 bytes: <.main+5081 @065ad5> - <.main+5093 @065ae1>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+5081 @065ad5> : 20 c8 3a 06                load.m32 <@063ac8> ;typeofBase
	<.main+5085 @065ad9> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+5089 @065add> : 24 e8 3a 06                store.m32 <@063ae8> ;fileOfBase
	cmplStd/test/lang/reflect.ci:42: (12 bytes: <.main+5093 @065ae1> - <.main+5105 @065aed>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+5093 @065ae1> : 20 c8 3a 06                load.m32 <@063ac8> ;typeofBase
	<.main+5097 @065ae5> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+5101 @065ae9> : 24 f0 3a 06                store.m32 <@063af0> ;lineOfBase
	cmplStd/test/lang/reflect.ci:44: (12 bytes: <.main+5105 @065aed> - <.main+5117 @065af9>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+5105 @065aed> : 20 c8 3a 06                load.m32 <@063ac8> ;typeofBase
	<.main+5109 @065af1> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5113 @065af5> : 24 f8 3a 06                store.m32 <@063af8> ;typeofBase1
	cmplStd/test/lang/reflect.ci:45: (13 bytes: <.main+5117 @065af9> - <.main+5130 @065b06>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+5117 @065af9> : 20 f8 3a 06                load.m32 <@063af8> ;typeofBase1
	<.main+5121 @065afd> : 0c 28 00 00                inc.i32(+40)
	<.main+5125 @065b01> : 28                         load.i32
	<.main+5126 @065b02> : 24 00 3b 06                store.m32 <@063b00> ;offsetOfBase1
	cmplStd/test/lang/reflect.ci:46: (13 bytes: <.main+5130 @065b06> - <.main+5143 @065b13>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+5130 @065b06> : 20 f8 3a 06                load.m32 <@063af8> ;typeofBase1
	<.main+5134 @065b0a> : 0c 20 00 00                inc.i32(+32)
	<.main+5138 @065b0e> : 28                         load.i32
	<.main+5139 @065b0f> : 24 08 3b 06                store.m32 <@063b08> ;sizeOfBase1
	cmplStd/test/lang/reflect.ci:48: (12 bytes: <.main+5143 @065b13> - <.main+5155 @065b1f>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+5143 @065b13> : 20 f8 3a 06                load.m32 <@063af8> ;typeofBase1
	<.main+5147 @065b17> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5151 @065b1b> : 24 10 3b 06                store.m32 <@063b10> ;typeofBase2
	cmplStd/test/lang/reflect.ci:49: (13 bytes: <.main+5155 @065b1f> - <.main+5168 @065b2c>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+5155 @065b1f> : 20 10 3b 06                load.m32 <@063b10> ;typeofBase2
	<.main+5159 @065b23> : 0c 28 00 00                inc.i32(+40)
	<.main+5163 @065b27> : 28                         load.i32
	<.main+5164 @065b28> : 24 18 3b 06                store.m32 <@063b18> ;offsetOfBase2
	cmplStd/test/lang/reflect.ci:50: (13 bytes: <.main+5168 @065b2c> - <.main+5181 @065b39>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+5168 @065b2c> : 20 10 3b 06                load.m32 <@063b10> ;typeofBase2
	<.main+5172 @065b30> : 0c 20 00 00                inc.i32(+32)
	<.main+5176 @065b34> : 28                         load.i32
	<.main+5177 @065b35> : 24 20 3b 06                store.m32 <@063b20> ;sizeOfBase2
	cmplStd/test/lang/init.member.ci:34: (5 bytes: <.main+5181 @065b39> - <.main+5186 @065b3e>): static global: int32
	<.main+5181 @065b39> : 19                         load.z32
	<.main+5182 @065b3a> : 24 28 3b 06                store.m32 <@063b28> ;RecordMemberTest.global
	cmplStd/test/lang/init.member.ci:37: (9 bytes: <.main+5186 @065b3e> - <.main+5195 @065b47>): static globalInit: int32 := 1
	<.main+5186 @065b3e> : 1c 01 00 00 00             load.c32 1
	<.main+5191 @065b43> : 24 30 3b 06                store.m32 <@063b30> ;RecordMemberTest.globalInit
	cmplStd/test/lang/init.member.ci:40: (9 bytes: <.main+5195 @065b47> - <.main+5204 @065b50>): static const globalConstant: int32 := 2
	<.main+5195 @065b47> : 1c 02 00 00 00             load.c32 2
	<.main+5200 @065b4c> : 24 38 3b 06                store.m32 <@063b38> ;RecordMemberTest.globalConstant
	cmplStd/test/lang/init.member.ci:43: (14 bytes: <.main+5204 @065b50> - <.main+5218 @065b5e>): static globalRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:43: (9 bytes: <.main+5204 @065b50> - <.main+5213 @065b59>): globalRec.constant := 4;
	<.main+5204 @065b50> : 1c 04 00 00 00             load.c32 4
	<.main+5209 @065b55> : 24 44 3b 06                store.m32 <@063b44> ;RecordMemberTest.globalRec+4
	:: (5 bytes: <.main+5213 @065b59> - <.main+5218 @065b5e>): globalRec.member := (0);
	<.main+5213 @065b59> : 19                         load.z32
	<.main+5214 @065b5a> : 24 40 3b 06                store.m32 <@063b40> ;RecordMemberTest.globalRec
	cmplStd/test/lang/init.member.ci:46: (18 bytes: <.main+5218 @065b5e> - <.main+5236 @065b70>): static globalRecInit: Inner := {...}
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5218 @065b5e> - <.main+5227 @065b67>): globalRecInit.member := 4;
	<.main+5218 @065b5e> : 1c 04 00 00 00             load.c32 4
	<.main+5223 @065b63> : 24 48 3b 06                store.m32 <@063b48> ;RecordMemberTest.globalRecInit
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5227 @065b67> - <.main+5236 @065b70>): globalRecInit.constant := 5;
	<.main+5227 @065b67> : 1c 05 00 00 00             load.c32 5
	<.main+5232 @065b6c> : 24 4c 3b 06                store.m32 <@063b4c> ;RecordMemberTest.globalRecInit+4
	cmplStd/test/lang/init.member.ci:49: (18 bytes: <.main+5236 @065b70> - <.main+5254 @065b82>): static const globalConstantRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5236 @065b70> - <.main+5245 @065b79>): globalConstantRec.member := 6;
	<.main+5236 @065b70> : 1c 06 00 00 00             load.c32 6
	<.main+5241 @065b75> : 24 50 3b 06                store.m32 <@063b50> ;RecordMemberTest.globalConstantRec
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5245 @065b79> - <.main+5254 @065b82>): globalConstantRec.constant := 7;
	<.main+5245 @065b79> : 1c 07 00 00 00             load.c32 7
	<.main+5250 @065b7e> : 24 54 3b 06                store.m32 <@063b54> ;RecordMemberTest.globalConstantRec+4
	cmplStd/test/lang/init.member.ci:52: (72 bytes: <.main+5254 @065b82> - <.main+5326 @065bca>): static recordMemberTest: RecordMemberTest := {...}
	cmplStd/test/lang/init.member.ci:53: (9 bytes: <.main+5254 @065b82> - <.main+5263 @065b8b>): recordMemberTest.member := 10;
	<.main+5254 @065b82> : 1c 0a 00 00 00             load.c32 10
	<.main+5259 @065b87> : 24 58 3b 06                store.m32 <@063b58> ;recordMemberTest
	cmplStd/test/lang/init.member.ci:54: (9 bytes: <.main+5263 @065b8b> - <.main+5272 @065b94>): recordMemberTest.constant := 11;
	<.main+5263 @065b8b> : 1c 0b 00 00 00             load.c32 11
	<.main+5268 @065b90> : 24 5c 3b 06                store.m32 <@063b5c> ;recordMemberTest+4
	cmplStd/test/lang/init.member.ci:55: (9 bytes: <.main+5272 @065b94> - <.main+5281 @065b9d>): recordMemberTest.memberInit := 12;
	<.main+5272 @065b94> : 1c 0c 00 00 00             load.c32 12
	<.main+5277 @065b99> : 24 60 3b 06                store.m32 <@063b60> ;recordMemberTest+8
	cmplStd/test/lang/init.member.ci:56: (9 bytes: <.main+5281 @065b9d> - <.main+5290 @065ba6>): recordMemberTest.constantInit := 13;
	<.main+5281 @065b9d> : 1c 0d 00 00 00             load.c32 13
	<.main+5286 @065ba2> : 24 64 3b 06                store.m32 <@063b64> ;recordMemberTest+12
	cmplStd/test/lang/init.member.ci:59: (9 bytes: <.main+5290 @065ba6> - <.main+5299 @065baf>): recordMemberTest.memberRec.member := 14;
	<.main+5290 @065ba6> : 1c 0e 00 00 00             load.c32 14
	<.main+5295 @065bab> : 24 68 3b 06                store.m32 <@063b68> ;recordMemberTest+16
	cmplStd/test/lang/init.member.ci:60: (9 bytes: <.main+5299 @065baf> - <.main+5308 @065bb8>): recordMemberTest.memberRec.constant := 15;
	<.main+5299 @065baf> : 1c 0f 00 00 00             load.c32 15
	<.main+5304 @065bb4> : 24 6c 3b 06                store.m32 <@063b6c> ;recordMemberTest+20
	cmplStd/test/lang/init.member.ci:64: (9 bytes: <.main+5308 @065bb8> - <.main+5317 @065bc1>): recordMemberTest.constantRec.member := 16;
	<.main+5308 @065bb8> : 1c 10 00 00 00             load.c32 16
	<.main+5313 @065bbd> : 24 70 3b 06                store.m32 <@063b70> ;recordMemberTest+24
	cmplStd/test/lang/init.member.ci:65: (9 bytes: <.main+5317 @065bc1> - <.main+5326 @065bca>): recordMemberTest.constantRec.constant := 17;
	<.main+5317 @065bc1> : 1c 11 00 00 00             load.c32 17
	<.main+5322 @065bc6> : 24 74 3b 06                store.m32 <@063b74> ;recordMemberTest+28
	cmplStd/test/lang/init.method.ci:18: (9 bytes: <.main+5326 @065bca> - <.main+5335 @065bd3>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5326 @065bca> : 1f d0 3b 06 00             load.ref <@063bd0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5331 @065bcf> : 24 a0 3b 06                store.m32 <@063ba0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	cmplStd/test/lang/init.method.ci:62: (26 bytes: <.main+5335 @065bd3> - <.main+5361 @065bed>): static recordMethodTest: RecordMethodTest := {...}
	cmplStd/test/lang/init.method.ci:64: (9 bytes: <.main+5335 @065bd3> - <.main+5344 @065bdc>): recordMethodTest.abstractMethod := globalFunction;
	<.main+5335 @065bd3> : 1f f8 3b 06 00             load.ref <@063bf8> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5340 @065bd8> : 24 20 3c 06                store.m32 <@063c20> ;recordMethodTest
	:: (8 bytes: <.main+5344 @065bdc> - <.main+5352 @065be4>): recordMethodTest.delegateMethod := forwardMethod;
	<.main+5344 @065bdc> : 20 a0 3b 06                load.m32 <@063ba0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5348 @065be0> : 24 24 3c 06                store.m32 <@063c24> ;recordMethodTest+4
	:: (9 bytes: <.main+5352 @065be4> - <.main+5361 @065bed>): recordMethodTest.virtualMethod := virtualMethod;
	<.main+5352 @065be4> : 1f a8 3b 06 00             load.ref <@063ba8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5357 @065be9> : 24 28 3c 06                store.m32 <@063c28> ;recordMethodTest+8
	cmplStd/test/lang/recUnion.ci:26: (21 bytes: <.main+5361 @065bed> - <.main+5382 @065c02>): static black: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5361 @065bed> - <.main+5368 @065bf4>): black.r := (0);
	<.main+5361 @065bed> : 19                         load.z32
	<.main+5362 @065bee> : 1f ba 3c 06 00             load.ref <@063cba> ;black+2
	<.main+5367 @065bf3> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5368 @065bf4> - <.main+5375 @065bfb>): black.g := (0);
	<.main+5368 @065bf4> : 19                         load.z32
	<.main+5369 @065bf5> : 1f b9 3c 06 00             load.ref <@063cb9> ;black+1
	<.main+5374 @065bfa> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5375 @065bfb> - <.main+5382 @065c02>): black.b := (0);
	<.main+5375 @065bfb> : 19                         load.z32
	<.main+5376 @065bfc> : 1f b8 3c 06 00             load.ref <@063cb8> ;black
	<.main+5381 @065c01> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (25 bytes: <.main+5382 @065c02> - <.main+5407 @065c1b>): static green: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5382 @065c02> - <.main+5389 @065c09>): green.r := (0);
	<.main+5382 @065c02> : 19                         load.z32
	<.main+5383 @065c03> : 1f c2 3c 06 00             load.ref <@063cc2> ;green+2
	<.main+5388 @065c08> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (11 bytes: <.main+5389 @065c09> - <.main+5400 @065c14>): green.g := (255);
	<.main+5389 @065c09> : 1c ff 00 00 00             load.c32 255
	<.main+5394 @065c0e> : 1f c1 3c 06 00             load.ref <@063cc1> ;green+1
	<.main+5399 @065c13> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5400 @065c14> - <.main+5407 @065c1b>): green.b := (0);
	<.main+5400 @065c14> : 19                         load.z32
	<.main+5401 @065c15> : 1f c0 3c 06 00             load.ref <@063cc0> ;green
	<.main+5406 @065c1a> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (33 bytes: <.main+5407 @065c1b> - <.main+5440 @065c3c>): static white: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5407 @065c1b> - <.main+5418 @065c26>): white.r := (255);
	<.main+5407 @065c1b> : 1c ff 00 00 00             load.c32 255
	<.main+5412 @065c20> : 1f ca 3c 06 00             load.ref <@063cca> ;white+2
	<.main+5417 @065c25> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5418 @065c26> - <.main+5429 @065c31>): white.g := (255);
	<.main+5418 @065c26> : 1c ff 00 00 00             load.c32 255
	<.main+5423 @065c2b> : 1f c9 3c 06 00             load.ref <@063cc9> ;white+1
	<.main+5428 @065c30> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5429 @065c31> - <.main+5440 @065c3c>): white.b := (255);
	<.main+5429 @065c31> : 1c ff 00 00 00             load.c32 255
	<.main+5434 @065c36> : 1f c8 3c 06 00             load.ref <@063cc8> ;white
	<.main+5439 @065c3b> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5440 @065c3c> - <.main+5449 @065c45>): cyan.col := (65535);
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5440 @065c3c> - <.main+5449 @065c45>): static cyan: color := {...}
	<.main+5440 @065c3c> : 1c ff ff 00 00             load.c32 65535
	<.main+5445 @065c41> : 24 d0 3c 06                store.m32 <@063cd0> ;cyan
	cmplStd/test/lang/recUnion.ci:31: (25 bytes: <.main+5449 @065c45> - <.main+5474 @065c5e>): static blue: color := {...}
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5449 @065c45> - <.main+5456 @065c4c>): blue.rgb.r := (0);
	<.main+5449 @065c45> : 19                         load.z32
	<.main+5450 @065c46> : 1f da 3c 06 00             load.ref <@063cda> ;blue+2
	<.main+5455 @065c4b> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5456 @065c4c> - <.main+5463 @065c53>): blue.rgb.g := (0);
	<.main+5456 @065c4c> : 19                         load.z32
	<.main+5457 @065c4d> : 1f d9 3c 06 00             load.ref <@063cd9> ;blue+1
	<.main+5462 @065c52> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (11 bytes: <.main+5463 @065c53> - <.main+5474 @065c5e>): blue.rgb.b := (255);
	<.main+5463 @065c53> : 1c ff 00 00 00             load.c32 255
	<.main+5468 @065c58> : 1f d8 3c 06 00             load.ref <@063cd8> ;blue
	<.main+5473 @065c5d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:5: (9 bytes: <.main+5474 @065c5e> - <.main+5483 @065c67>): static shift: int32 := 2
	<.main+5474 @065c5e> : 1c 02 00 00 00             load.c32 2
	<.main+5479 @065c63> : 24 e0 3c 06                store.m32 <@063ce0> ;shift
	cmplStd/test/lang/useOperator.ci:7: (11 bytes: <.main+5483 @065c67> - <.main+5494 @065c72>): static boolA: bool := true
	<.main+5483 @065c67> : 1c 01 00 00 00             load.c32 1
	<.main+5488 @065c6c> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5493 @065c71> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:8: (11 bytes: <.main+5494 @065c72> - <.main+5505 @065c7d>): static boolB: bool := !false
	<.main+5494 @065c72> : 1c 01 00 00 00             load.c32 1
	<.main+5499 @065c77> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5504 @065c7c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:17: (19 bytes: <.main+5505 @065c7d> - <.main+5524 @065c90>): static boolAnd: bool := boolA & boolB
	<.main+5505 @065c7d> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5510 @065c82> : 26                         load.i8
	<.main+5511 @065c83> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5516 @065c88> : 26                         load.i8
	<.main+5517 @065c89> : 31                         and.b32
	<.main+5518 @065c8a> : 1f f8 3c 06 00             load.ref <@063cf8> ;boolAnd
	<.main+5523 @065c8f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:18: (19 bytes: <.main+5524 @065c90> - <.main+5543 @065ca3>): static boolIor: bool := boolA | boolB
	<.main+5524 @065c90> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5529 @065c95> : 26                         load.i8
	<.main+5530 @065c96> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5535 @065c9b> : 26                         load.i8
	<.main+5536 @065c9c> : 32                         or.b32
	<.main+5537 @065c9d> : 1f 00 3d 06 00             load.ref <@063d00> ;boolIor
	<.main+5542 @065ca2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:19: (19 bytes: <.main+5543 @065ca3> - <.main+5562 @065cb6>): static boolXor: bool := boolA ^ boolB
	<.main+5543 @065ca3> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5548 @065ca8> : 26                         load.i8
	<.main+5549 @065ca9> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5554 @065cae> : 26                         load.i8
	<.main+5555 @065caf> : 36                         xor.b32
	<.main+5556 @065cb0> : 1f 08 3d 06 00             load.ref <@063d08> ;boolXor
	<.main+5561 @065cb5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:22: (13 bytes: <.main+5562 @065cb6> - <.main+5575 @065cc3>): static boolNot: bool := !boolB
	<.main+5562 @065cb6> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5567 @065cbb> : 26                         load.i8
	<.main+5568 @065cbc> : 0b                         not.b32
	<.main+5569 @065cbd> : 1f 10 3d 06 00             load.ref <@063d10> ;boolNot
	<.main+5574 @065cc2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:23: (19 bytes: <.main+5575 @065cc3> - <.main+5594 @065cd6>): static boolCeq: bool := boolA == boolB
	<.main+5575 @065cc3> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5580 @065cc8> : 26                         load.i8
	<.main+5581 @065cc9> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5586 @065cce> : 26                         load.i8
	<.main+5587 @065ccf> : 57                         ceq.i32
	<.main+5588 @065cd0> : 1f 18 3d 06 00             load.ref <@063d18> ;boolCeq
	<.main+5593 @065cd5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:24: (20 bytes: <.main+5594 @065cd6> - <.main+5614 @065cea>): static boolCne: bool := boolA != boolB
	<.main+5594 @065cd6> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5599 @065cdb> : 26                         load.i8
	<.main+5600 @065cdc> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5605 @065ce1> : 26                         load.i8
	<.main+5606 @065ce2> : 57                         ceq.i32
	<.main+5607 @065ce3> : 0b                         not.b32
	<.main+5608 @065ce4> : 1f 20 3d 06 00             load.ref <@063d20> ;boolCne
	<.main+5613 @065ce9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:25: (19 bytes: <.main+5614 @065cea> - <.main+5633 @065cfd>): static boolClt: bool := boolA < boolB
	<.main+5614 @065cea> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5619 @065cef> : 26                         load.i8
	<.main+5620 @065cf0> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5625 @065cf5> : 26                         load.i8
	<.main+5626 @065cf6> : 58                         clt.i32
	<.main+5627 @065cf7> : 1f 28 3d 06 00             load.ref <@063d28> ;boolClt
	<.main+5632 @065cfc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:26: (20 bytes: <.main+5633 @065cfd> - <.main+5653 @065d11>): static boolCle: bool := boolA <= boolB
	<.main+5633 @065cfd> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5638 @065d02> : 26                         load.i8
	<.main+5639 @065d03> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5644 @065d08> : 26                         load.i8
	<.main+5645 @065d09> : 59                         cgt.i32
	<.main+5646 @065d0a> : 0b                         not.b32
	<.main+5647 @065d0b> : 1f 30 3d 06 00             load.ref <@063d30> ;boolCle
	<.main+5652 @065d10> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:27: (19 bytes: <.main+5653 @065d11> - <.main+5672 @065d24>): static boolCgt: bool := boolA > boolB
	<.main+5653 @065d11> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5658 @065d16> : 26                         load.i8
	<.main+5659 @065d17> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5664 @065d1c> : 26                         load.i8
	<.main+5665 @065d1d> : 59                         cgt.i32
	<.main+5666 @065d1e> : 1f 38 3d 06 00             load.ref <@063d38> ;boolCgt
	<.main+5671 @065d23> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:28: (20 bytes: <.main+5672 @065d24> - <.main+5692 @065d38>): static boolCge: bool := boolA >= boolB
	<.main+5672 @065d24> : 1f e8 3c 06 00             load.ref <@063ce8> ;boolA
	<.main+5677 @065d29> : 26                         load.i8
	<.main+5678 @065d2a> : 1f f0 3c 06 00             load.ref <@063cf0> ;boolB
	<.main+5683 @065d2f> : 26                         load.i8
	<.main+5684 @065d30> : 58                         clt.i32
	<.main+5685 @065d31> : 0b                         not.b32
	<.main+5686 @065d32> : 1f 40 3d 06 00             load.ref <@063d40> ;boolCge
	<.main+5691 @065d37> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:30: (11 bytes: <.main+5692 @065d38> - <.main+5703 @065d43>): static chrA: char := 'a'
	<.main+5692 @065d38> : 1c 61 00 00 00             load.c32 97
	<.main+5697 @065d3d> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5702 @065d42> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:31: (11 bytes: <.main+5703 @065d43> - <.main+5714 @065d4e>): static chrB: char := 'b'
	<.main+5703 @065d43> : 1c 62 00 00 00             load.c32 98
	<.main+5708 @065d48> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5713 @065d4d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:32: (12 bytes: <.main+5714 @065d4e> - <.main+5726 @065d5a>): static chrPls: char := +chrB
	<.main+5714 @065d4e> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5719 @065d53> : 26                         load.i8
	<.main+5720 @065d54> : 1f 58 3d 06 00             load.ref <@063d58> ;chrPls
	<.main+5725 @065d59> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:33: (13 bytes: <.main+5726 @065d5a> - <.main+5739 @065d67>): static chrNeg: char := -chrB
	<.main+5726 @065d5a> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5731 @065d5f> : 26                         load.i8
	<.main+5732 @065d60> : 50                         neg.i32
	<.main+5733 @065d61> : 1f 60 3d 06 00             load.ref <@063d60> ;chrNeg
	<.main+5738 @065d66> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:34: (13 bytes: <.main+5739 @065d67> - <.main+5752 @065d74>): static chrCmt: char := ~chrB
	<.main+5739 @065d67> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5744 @065d6c> : 26                         load.i8
	<.main+5745 @065d6d> : 30                         cmt.b32
	<.main+5746 @065d6e> : 1f 68 3d 06 00             load.ref <@063d68> ;chrCmt
	<.main+5751 @065d73> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:35: (19 bytes: <.main+5752 @065d74> - <.main+5771 @065d87>): static chrAdd: char := chrA + chrB
	<.main+5752 @065d74> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5757 @065d79> : 26                         load.i8
	<.main+5758 @065d7a> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5763 @065d7f> : 26                         load.i8
	<.main+5764 @065d80> : 51                         add.i32
	<.main+5765 @065d81> : 1f 70 3d 06 00             load.ref <@063d70> ;chrAdd
	<.main+5770 @065d86> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:36: (19 bytes: <.main+5771 @065d87> - <.main+5790 @065d9a>): static chrSub: char := chrA - chrB
	<.main+5771 @065d87> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5776 @065d8c> : 26                         load.i8
	<.main+5777 @065d8d> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5782 @065d92> : 26                         load.i8
	<.main+5783 @065d93> : 52                         sub.i32
	<.main+5784 @065d94> : 1f 78 3d 06 00             load.ref <@063d78> ;chrSub
	<.main+5789 @065d99> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:37: (19 bytes: <.main+5790 @065d9a> - <.main+5809 @065dad>): static chrMul: char := chrA * chrB
	<.main+5790 @065d9a> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5795 @065d9f> : 26                         load.i8
	<.main+5796 @065da0> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5801 @065da5> : 26                         load.i8
	<.main+5802 @065da6> : 53                         mul.i32
	<.main+5803 @065da7> : 1f 80 3d 06 00             load.ref <@063d80> ;chrMul
	<.main+5808 @065dac> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:38: (19 bytes: <.main+5809 @065dad> - <.main+5828 @065dc0>): static chrDiv: char := chrA / chrB
	<.main+5809 @065dad> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5814 @065db2> : 26                         load.i8
	<.main+5815 @065db3> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5820 @065db8> : 26                         load.i8
	<.main+5821 @065db9> : 54                         div.i32
	<.main+5822 @065dba> : 1f 88 3d 06 00             load.ref <@063d88> ;chrDiv
	<.main+5827 @065dbf> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:39: (19 bytes: <.main+5828 @065dc0> - <.main+5847 @065dd3>): static chrMod: char := chrA % chrB
	<.main+5828 @065dc0> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5833 @065dc5> : 26                         load.i8
	<.main+5834 @065dc6> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5839 @065dcb> : 26                         load.i8
	<.main+5840 @065dcc> : 55                         mod.i32
	<.main+5841 @065dcd> : 1f 90 3d 06 00             load.ref <@063d90> ;chrMod
	<.main+5846 @065dd2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:40: (19 bytes: <.main+5847 @065dd3> - <.main+5866 @065de6>): static chrAnd: char := chrA & chrB
	<.main+5847 @065dd3> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5852 @065dd8> : 26                         load.i8
	<.main+5853 @065dd9> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5858 @065dde> : 26                         load.i8
	<.main+5859 @065ddf> : 31                         and.b32
	<.main+5860 @065de0> : 1f 98 3d 06 00             load.ref <@063d98> ;chrAnd
	<.main+5865 @065de5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:41: (19 bytes: <.main+5866 @065de6> - <.main+5885 @065df9>): static chrIor: char := chrA | chrB
	<.main+5866 @065de6> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5871 @065deb> : 26                         load.i8
	<.main+5872 @065dec> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5877 @065df1> : 26                         load.i8
	<.main+5878 @065df2> : 32                         or.b32
	<.main+5879 @065df3> : 1f a0 3d 06 00             load.ref <@063da0> ;chrIor
	<.main+5884 @065df8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:42: (19 bytes: <.main+5885 @065df9> - <.main+5904 @065e0c>): static chrXor: char := chrA ^ chrB
	<.main+5885 @065df9> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5890 @065dfe> : 26                         load.i8
	<.main+5891 @065dff> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5896 @065e04> : 26                         load.i8
	<.main+5897 @065e05> : 36                         xor.b32
	<.main+5898 @065e06> : 1f a8 3d 06 00             load.ref <@063da8> ;chrXor
	<.main+5903 @065e0b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:43: (17 bytes: <.main+5904 @065e0c> - <.main+5921 @065e1d>): static chrShl: char := (chrA) << shift
	<.main+5904 @065e0c> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5909 @065e11> : 26                         load.i8
	<.main+5910 @065e12> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+5914 @065e16> : 3a                         shl.b32
	<.main+5915 @065e17> : 1f b0 3d 06 00             load.ref <@063db0> ;chrShl
	<.main+5920 @065e1c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:44: (17 bytes: <.main+5921 @065e1d> - <.main+5938 @065e2e>): static chrShr: char := (chrA) >> shift
	<.main+5921 @065e1d> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5926 @065e22> : 26                         load.i8
	<.main+5927 @065e23> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+5931 @065e27> : 3c                         sar.b32
	<.main+5932 @065e28> : 1f b8 3d 06 00             load.ref <@063db8> ;chrShr
	<.main+5937 @065e2d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:45: (14 bytes: <.main+5938 @065e2e> - <.main+5952 @065e3c>): static chrNot: bool := !(chrB)
	<.main+5938 @065e2e> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5943 @065e33> : 26                         load.i8
	<.main+5944 @065e34> : 5a                         i32.2bool
	<.main+5945 @065e35> : 0b                         not.b32
	<.main+5946 @065e36> : 1f c0 3d 06 00             load.ref <@063dc0> ;chrNot
	<.main+5951 @065e3b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:46: (19 bytes: <.main+5952 @065e3c> - <.main+5971 @065e4f>): static chrCeq: bool := chrA == chrB
	<.main+5952 @065e3c> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5957 @065e41> : 26                         load.i8
	<.main+5958 @065e42> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5963 @065e47> : 26                         load.i8
	<.main+5964 @065e48> : 57                         ceq.i32
	<.main+5965 @065e49> : 1f c8 3d 06 00             load.ref <@063dc8> ;chrCeq
	<.main+5970 @065e4e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:47: (20 bytes: <.main+5971 @065e4f> - <.main+5991 @065e63>): static chrCne: bool := chrA != chrB
	<.main+5971 @065e4f> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5976 @065e54> : 26                         load.i8
	<.main+5977 @065e55> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+5982 @065e5a> : 26                         load.i8
	<.main+5983 @065e5b> : 57                         ceq.i32
	<.main+5984 @065e5c> : 0b                         not.b32
	<.main+5985 @065e5d> : 1f d0 3d 06 00             load.ref <@063dd0> ;chrCne
	<.main+5990 @065e62> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:48: (19 bytes: <.main+5991 @065e63> - <.main+6010 @065e76>): static chrClt: bool := chrA < chrB
	<.main+5991 @065e63> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+5996 @065e68> : 26                         load.i8
	<.main+5997 @065e69> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+6002 @065e6e> : 26                         load.i8
	<.main+6003 @065e6f> : 58                         clt.i32
	<.main+6004 @065e70> : 1f d8 3d 06 00             load.ref <@063dd8> ;chrClt
	<.main+6009 @065e75> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:49: (20 bytes: <.main+6010 @065e76> - <.main+6030 @065e8a>): static chrCle: bool := chrA <= chrB
	<.main+6010 @065e76> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+6015 @065e7b> : 26                         load.i8
	<.main+6016 @065e7c> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+6021 @065e81> : 26                         load.i8
	<.main+6022 @065e82> : 59                         cgt.i32
	<.main+6023 @065e83> : 0b                         not.b32
	<.main+6024 @065e84> : 1f e0 3d 06 00             load.ref <@063de0> ;chrCle
	<.main+6029 @065e89> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:50: (19 bytes: <.main+6030 @065e8a> - <.main+6049 @065e9d>): static chrCgt: bool := chrA > chrB
	<.main+6030 @065e8a> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+6035 @065e8f> : 26                         load.i8
	<.main+6036 @065e90> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+6041 @065e95> : 26                         load.i8
	<.main+6042 @065e96> : 59                         cgt.i32
	<.main+6043 @065e97> : 1f e8 3d 06 00             load.ref <@063de8> ;chrCgt
	<.main+6048 @065e9c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:51: (20 bytes: <.main+6049 @065e9d> - <.main+6069 @065eb1>): static chrCge: bool := chrA >= chrB
	<.main+6049 @065e9d> : 1f 48 3d 06 00             load.ref <@063d48> ;chrA
	<.main+6054 @065ea2> : 26                         load.i8
	<.main+6055 @065ea3> : 1f 50 3d 06 00             load.ref <@063d50> ;chrB
	<.main+6060 @065ea8> : 26                         load.i8
	<.main+6061 @065ea9> : 58                         clt.i32
	<.main+6062 @065eaa> : 0b                         not.b32
	<.main+6063 @065eab> : 1f f0 3d 06 00             load.ref <@063df0> ;chrCge
	<.main+6068 @065eb0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:53: (11 bytes: <.main+6069 @065eb1> - <.main+6080 @065ebc>): static i8A: int8 := a
	<.main+6069 @065eb1> : 1c 60 00 00 00             load.c32 96
	<.main+6074 @065eb6> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6079 @065ebb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:54: (11 bytes: <.main+6080 @065ebc> - <.main+6091 @065ec7>): static i8B: int8 := b
	<.main+6080 @065ebc> : 1c 2a 00 00 00             load.c32 42
	<.main+6085 @065ec1> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6090 @065ec6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:55: (12 bytes: <.main+6091 @065ec7> - <.main+6103 @065ed3>): static i8Pls: int8 := +i8B
	<.main+6091 @065ec7> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6096 @065ecc> : 26                         load.i8
	<.main+6097 @065ecd> : 1f 08 3e 06 00             load.ref <@063e08> ;i8Pls
	<.main+6102 @065ed2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:56: (13 bytes: <.main+6103 @065ed3> - <.main+6116 @065ee0>): static i8Neg: int8 := -i8B
	<.main+6103 @065ed3> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6108 @065ed8> : 26                         load.i8
	<.main+6109 @065ed9> : 50                         neg.i32
	<.main+6110 @065eda> : 1f 10 3e 06 00             load.ref <@063e10> ;i8Neg
	<.main+6115 @065edf> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:57: (13 bytes: <.main+6116 @065ee0> - <.main+6129 @065eed>): static i8Cmt: int8 := ~i8B
	<.main+6116 @065ee0> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6121 @065ee5> : 26                         load.i8
	<.main+6122 @065ee6> : 30                         cmt.b32
	<.main+6123 @065ee7> : 1f 18 3e 06 00             load.ref <@063e18> ;i8Cmt
	<.main+6128 @065eec> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:58: (19 bytes: <.main+6129 @065eed> - <.main+6148 @065f00>): static i8Add: int8 := i8A + i8B
	<.main+6129 @065eed> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6134 @065ef2> : 26                         load.i8
	<.main+6135 @065ef3> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6140 @065ef8> : 26                         load.i8
	<.main+6141 @065ef9> : 51                         add.i32
	<.main+6142 @065efa> : 1f 20 3e 06 00             load.ref <@063e20> ;i8Add
	<.main+6147 @065eff> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:59: (19 bytes: <.main+6148 @065f00> - <.main+6167 @065f13>): static i8Sub: int8 := i8A - i8B
	<.main+6148 @065f00> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6153 @065f05> : 26                         load.i8
	<.main+6154 @065f06> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6159 @065f0b> : 26                         load.i8
	<.main+6160 @065f0c> : 52                         sub.i32
	<.main+6161 @065f0d> : 1f 28 3e 06 00             load.ref <@063e28> ;i8Sub
	<.main+6166 @065f12> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:60: (19 bytes: <.main+6167 @065f13> - <.main+6186 @065f26>): static i8Mul: int8 := i8A * i8B
	<.main+6167 @065f13> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6172 @065f18> : 26                         load.i8
	<.main+6173 @065f19> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6178 @065f1e> : 26                         load.i8
	<.main+6179 @065f1f> : 53                         mul.i32
	<.main+6180 @065f20> : 1f 30 3e 06 00             load.ref <@063e30> ;i8Mul
	<.main+6185 @065f25> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:61: (19 bytes: <.main+6186 @065f26> - <.main+6205 @065f39>): static i8Div: int8 := i8A / i8B
	<.main+6186 @065f26> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6191 @065f2b> : 26                         load.i8
	<.main+6192 @065f2c> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6197 @065f31> : 26                         load.i8
	<.main+6198 @065f32> : 54                         div.i32
	<.main+6199 @065f33> : 1f 38 3e 06 00             load.ref <@063e38> ;i8Div
	<.main+6204 @065f38> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:62: (19 bytes: <.main+6205 @065f39> - <.main+6224 @065f4c>): static i8Mod: int8 := i8A % i8B
	<.main+6205 @065f39> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6210 @065f3e> : 26                         load.i8
	<.main+6211 @065f3f> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6216 @065f44> : 26                         load.i8
	<.main+6217 @065f45> : 55                         mod.i32
	<.main+6218 @065f46> : 1f 40 3e 06 00             load.ref <@063e40> ;i8Mod
	<.main+6223 @065f4b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:63: (19 bytes: <.main+6224 @065f4c> - <.main+6243 @065f5f>): static i8And: int8 := i8A & i8B
	<.main+6224 @065f4c> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6229 @065f51> : 26                         load.i8
	<.main+6230 @065f52> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6235 @065f57> : 26                         load.i8
	<.main+6236 @065f58> : 31                         and.b32
	<.main+6237 @065f59> : 1f 48 3e 06 00             load.ref <@063e48> ;i8And
	<.main+6242 @065f5e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:64: (19 bytes: <.main+6243 @065f5f> - <.main+6262 @065f72>): static i8Ior: int8 := i8A | i8B
	<.main+6243 @065f5f> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6248 @065f64> : 26                         load.i8
	<.main+6249 @065f65> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6254 @065f6a> : 26                         load.i8
	<.main+6255 @065f6b> : 32                         or.b32
	<.main+6256 @065f6c> : 1f 50 3e 06 00             load.ref <@063e50> ;i8Ior
	<.main+6261 @065f71> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:65: (19 bytes: <.main+6262 @065f72> - <.main+6281 @065f85>): static i8Xor: int8 := i8A ^ i8B
	<.main+6262 @065f72> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6267 @065f77> : 26                         load.i8
	<.main+6268 @065f78> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6273 @065f7d> : 26                         load.i8
	<.main+6274 @065f7e> : 36                         xor.b32
	<.main+6275 @065f7f> : 1f 58 3e 06 00             load.ref <@063e58> ;i8Xor
	<.main+6280 @065f84> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:66: (17 bytes: <.main+6281 @065f85> - <.main+6298 @065f96>): static i8Shl: int8 := (i8A) << shift
	<.main+6281 @065f85> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6286 @065f8a> : 26                         load.i8
	<.main+6287 @065f8b> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+6291 @065f8f> : 3a                         shl.b32
	<.main+6292 @065f90> : 1f 60 3e 06 00             load.ref <@063e60> ;i8Shl
	<.main+6297 @065f95> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:67: (17 bytes: <.main+6298 @065f96> - <.main+6315 @065fa7>): static i8Shr: int8 := (i8A) >> shift
	<.main+6298 @065f96> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6303 @065f9b> : 26                         load.i8
	<.main+6304 @065f9c> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+6308 @065fa0> : 3c                         sar.b32
	<.main+6309 @065fa1> : 1f 68 3e 06 00             load.ref <@063e68> ;i8Shr
	<.main+6314 @065fa6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:68: (14 bytes: <.main+6315 @065fa7> - <.main+6329 @065fb5>): static i8Not: bool := !(i8B)
	<.main+6315 @065fa7> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6320 @065fac> : 26                         load.i8
	<.main+6321 @065fad> : 5a                         i32.2bool
	<.main+6322 @065fae> : 0b                         not.b32
	<.main+6323 @065faf> : 1f 70 3e 06 00             load.ref <@063e70> ;i8Not
	<.main+6328 @065fb4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:69: (19 bytes: <.main+6329 @065fb5> - <.main+6348 @065fc8>): static i8Ceq: bool := i8A == i8B
	<.main+6329 @065fb5> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6334 @065fba> : 26                         load.i8
	<.main+6335 @065fbb> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6340 @065fc0> : 26                         load.i8
	<.main+6341 @065fc1> : 57                         ceq.i32
	<.main+6342 @065fc2> : 1f 78 3e 06 00             load.ref <@063e78> ;i8Ceq
	<.main+6347 @065fc7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:70: (20 bytes: <.main+6348 @065fc8> - <.main+6368 @065fdc>): static i8Cne: bool := i8A != i8B
	<.main+6348 @065fc8> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6353 @065fcd> : 26                         load.i8
	<.main+6354 @065fce> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6359 @065fd3> : 26                         load.i8
	<.main+6360 @065fd4> : 57                         ceq.i32
	<.main+6361 @065fd5> : 0b                         not.b32
	<.main+6362 @065fd6> : 1f 80 3e 06 00             load.ref <@063e80> ;i8Cne
	<.main+6367 @065fdb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:71: (19 bytes: <.main+6368 @065fdc> - <.main+6387 @065fef>): static i8Clt: bool := i8A < i8B
	<.main+6368 @065fdc> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6373 @065fe1> : 26                         load.i8
	<.main+6374 @065fe2> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6379 @065fe7> : 26                         load.i8
	<.main+6380 @065fe8> : 58                         clt.i32
	<.main+6381 @065fe9> : 1f 88 3e 06 00             load.ref <@063e88> ;i8Clt
	<.main+6386 @065fee> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:72: (20 bytes: <.main+6387 @065fef> - <.main+6407 @066003>): static i8Cle: bool := i8A <= i8B
	<.main+6387 @065fef> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6392 @065ff4> : 26                         load.i8
	<.main+6393 @065ff5> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6398 @065ffa> : 26                         load.i8
	<.main+6399 @065ffb> : 59                         cgt.i32
	<.main+6400 @065ffc> : 0b                         not.b32
	<.main+6401 @065ffd> : 1f 90 3e 06 00             load.ref <@063e90> ;i8Cle
	<.main+6406 @066002> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:73: (19 bytes: <.main+6407 @066003> - <.main+6426 @066016>): static i8Cgt: bool := i8A > i8B
	<.main+6407 @066003> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6412 @066008> : 26                         load.i8
	<.main+6413 @066009> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6418 @06600e> : 26                         load.i8
	<.main+6419 @06600f> : 59                         cgt.i32
	<.main+6420 @066010> : 1f 98 3e 06 00             load.ref <@063e98> ;i8Cgt
	<.main+6425 @066015> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:74: (20 bytes: <.main+6426 @066016> - <.main+6446 @06602a>): static i8Cge: bool := i8A >= i8B
	<.main+6426 @066016> : 1f f8 3d 06 00             load.ref <@063df8> ;i8A
	<.main+6431 @06601b> : 26                         load.i8
	<.main+6432 @06601c> : 1f 00 3e 06 00             load.ref <@063e00> ;i8B
	<.main+6437 @066021> : 26                         load.i8
	<.main+6438 @066022> : 58                         clt.i32
	<.main+6439 @066023> : 0b                         not.b32
	<.main+6440 @066024> : 1f a0 3e 06 00             load.ref <@063ea0> ;i8Cge
	<.main+6445 @066029> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:76: (11 bytes: <.main+6446 @06602a> - <.main+6457 @066035>): static u8A: uint8 := a
	<.main+6446 @06602a> : 1c 60 00 00 00             load.c32 96
	<.main+6451 @06602f> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6456 @066034> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:77: (11 bytes: <.main+6457 @066035> - <.main+6468 @066040>): static u8B: uint8 := b
	<.main+6457 @066035> : 1c 2a 00 00 00             load.c32 42
	<.main+6462 @06603a> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6467 @06603f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:78: (12 bytes: <.main+6468 @066040> - <.main+6480 @06604c>): static u8Pls: uint8 := +u8B
	<.main+6468 @066040> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6473 @066045> : 26                         load.i8
	<.main+6474 @066046> : 1f b8 3e 06 00             load.ref <@063eb8> ;u8Pls
	<.main+6479 @06604b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:79: (13 bytes: <.main+6480 @06604c> - <.main+6493 @066059>): static u8Neg: uint8 := -u8B
	<.main+6480 @06604c> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6485 @066051> : 26                         load.i8
	<.main+6486 @066052> : 50                         neg.i32
	<.main+6487 @066053> : 1f c0 3e 06 00             load.ref <@063ec0> ;u8Neg
	<.main+6492 @066058> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:80: (13 bytes: <.main+6493 @066059> - <.main+6506 @066066>): static u8Cmt: uint8 := ~u8B
	<.main+6493 @066059> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6498 @06605e> : 26                         load.i8
	<.main+6499 @06605f> : 30                         cmt.b32
	<.main+6500 @066060> : 1f c8 3e 06 00             load.ref <@063ec8> ;u8Cmt
	<.main+6505 @066065> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:81: (19 bytes: <.main+6506 @066066> - <.main+6525 @066079>): static u8Add: uint8 := u8A + u8B
	<.main+6506 @066066> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6511 @06606b> : 26                         load.i8
	<.main+6512 @06606c> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6517 @066071> : 26                         load.i8
	<.main+6518 @066072> : 51                         add.i32
	<.main+6519 @066073> : 1f d0 3e 06 00             load.ref <@063ed0> ;u8Add
	<.main+6524 @066078> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:82: (19 bytes: <.main+6525 @066079> - <.main+6544 @06608c>): static u8Sub: uint8 := u8A - u8B
	<.main+6525 @066079> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6530 @06607e> : 26                         load.i8
	<.main+6531 @06607f> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6536 @066084> : 26                         load.i8
	<.main+6537 @066085> : 52                         sub.i32
	<.main+6538 @066086> : 1f d8 3e 06 00             load.ref <@063ed8> ;u8Sub
	<.main+6543 @06608b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:83: (19 bytes: <.main+6544 @06608c> - <.main+6563 @06609f>): static u8Mul: uint8 := u8A * u8B
	<.main+6544 @06608c> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6549 @066091> : 26                         load.i8
	<.main+6550 @066092> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6555 @066097> : 26                         load.i8
	<.main+6556 @066098> : 33                         mul.u32
	<.main+6557 @066099> : 1f e0 3e 06 00             load.ref <@063ee0> ;u8Mul
	<.main+6562 @06609e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:84: (19 bytes: <.main+6563 @06609f> - <.main+6582 @0660b2>): static u8Div: uint8 := u8A / u8B
	<.main+6563 @06609f> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6568 @0660a4> : 26                         load.i8
	<.main+6569 @0660a5> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6574 @0660aa> : 26                         load.i8
	<.main+6575 @0660ab> : 34                         div.u32
	<.main+6576 @0660ac> : 1f e8 3e 06 00             load.ref <@063ee8> ;u8Div
	<.main+6581 @0660b1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:85: (19 bytes: <.main+6582 @0660b2> - <.main+6601 @0660c5>): static u8Mod: uint8 := u8A % u8B
	<.main+6582 @0660b2> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6587 @0660b7> : 26                         load.i8
	<.main+6588 @0660b8> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6593 @0660bd> : 26                         load.i8
	<.main+6594 @0660be> : 35                         mod.u32
	<.main+6595 @0660bf> : 1f f0 3e 06 00             load.ref <@063ef0> ;u8Mod
	<.main+6600 @0660c4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:86: (19 bytes: <.main+6601 @0660c5> - <.main+6620 @0660d8>): static u8And: uint8 := u8A & u8B
	<.main+6601 @0660c5> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6606 @0660ca> : 26                         load.i8
	<.main+6607 @0660cb> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6612 @0660d0> : 26                         load.i8
	<.main+6613 @0660d1> : 31                         and.b32
	<.main+6614 @0660d2> : 1f f8 3e 06 00             load.ref <@063ef8> ;u8And
	<.main+6619 @0660d7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:87: (19 bytes: <.main+6620 @0660d8> - <.main+6639 @0660eb>): static u8Ior: uint8 := u8A | u8B
	<.main+6620 @0660d8> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6625 @0660dd> : 26                         load.i8
	<.main+6626 @0660de> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6631 @0660e3> : 26                         load.i8
	<.main+6632 @0660e4> : 32                         or.b32
	<.main+6633 @0660e5> : 1f 00 3f 06 00             load.ref <@063f00> ;u8Ior
	<.main+6638 @0660ea> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:88: (19 bytes: <.main+6639 @0660eb> - <.main+6658 @0660fe>): static u8Xor: uint8 := u8A ^ u8B
	<.main+6639 @0660eb> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6644 @0660f0> : 26                         load.i8
	<.main+6645 @0660f1> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6650 @0660f6> : 26                         load.i8
	<.main+6651 @0660f7> : 36                         xor.b32
	<.main+6652 @0660f8> : 1f 08 3f 06 00             load.ref <@063f08> ;u8Xor
	<.main+6657 @0660fd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:89: (17 bytes: <.main+6658 @0660fe> - <.main+6675 @06610f>): static u8Shl: uint8 := (u8A) << shift
	<.main+6658 @0660fe> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6663 @066103> : 26                         load.i8
	<.main+6664 @066104> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+6668 @066108> : 3a                         shl.b32
	<.main+6669 @066109> : 1f 10 3f 06 00             load.ref <@063f10> ;u8Shl
	<.main+6674 @06610e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:90: (17 bytes: <.main+6675 @06610f> - <.main+6692 @066120>): static u8Shr: uint8 := (u8A) >> shift
	<.main+6675 @06610f> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6680 @066114> : 26                         load.i8
	<.main+6681 @066115> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+6685 @066119> : 3c                         sar.b32
	<.main+6686 @06611a> : 1f 18 3f 06 00             load.ref <@063f18> ;u8Shr
	<.main+6691 @06611f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:91: (14 bytes: <.main+6692 @066120> - <.main+6706 @06612e>): static u8Not: bool := !(u8B)
	<.main+6692 @066120> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6697 @066125> : 26                         load.i8
	<.main+6698 @066126> : 5a                         i32.2bool
	<.main+6699 @066127> : 0b                         not.b32
	<.main+6700 @066128> : 1f 20 3f 06 00             load.ref <@063f20> ;u8Not
	<.main+6705 @06612d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:92: (19 bytes: <.main+6706 @06612e> - <.main+6725 @066141>): static u8Ceq: bool := u8A == u8B
	<.main+6706 @06612e> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6711 @066133> : 26                         load.i8
	<.main+6712 @066134> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6717 @066139> : 26                         load.i8
	<.main+6718 @06613a> : 57                         ceq.i32
	<.main+6719 @06613b> : 1f 28 3f 06 00             load.ref <@063f28> ;u8Ceq
	<.main+6724 @066140> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:93: (20 bytes: <.main+6725 @066141> - <.main+6745 @066155>): static u8Cne: bool := u8A != u8B
	<.main+6725 @066141> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6730 @066146> : 26                         load.i8
	<.main+6731 @066147> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6736 @06614c> : 26                         load.i8
	<.main+6737 @06614d> : 57                         ceq.i32
	<.main+6738 @06614e> : 0b                         not.b32
	<.main+6739 @06614f> : 1f 30 3f 06 00             load.ref <@063f30> ;u8Cne
	<.main+6744 @066154> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:94: (19 bytes: <.main+6745 @066155> - <.main+6764 @066168>): static u8Clt: bool := u8A < u8B
	<.main+6745 @066155> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6750 @06615a> : 26                         load.i8
	<.main+6751 @06615b> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6756 @066160> : 26                         load.i8
	<.main+6757 @066161> : 38                         clt.u32
	<.main+6758 @066162> : 1f 38 3f 06 00             load.ref <@063f38> ;u8Clt
	<.main+6763 @066167> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:95: (20 bytes: <.main+6764 @066168> - <.main+6784 @06617c>): static u8Cle: bool := u8A <= u8B
	<.main+6764 @066168> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6769 @06616d> : 26                         load.i8
	<.main+6770 @06616e> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6775 @066173> : 26                         load.i8
	<.main+6776 @066174> : 39                         cgt.u32
	<.main+6777 @066175> : 0b                         not.b32
	<.main+6778 @066176> : 1f 40 3f 06 00             load.ref <@063f40> ;u8Cle
	<.main+6783 @06617b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:96: (19 bytes: <.main+6784 @06617c> - <.main+6803 @06618f>): static u8Cgt: bool := u8A > u8B
	<.main+6784 @06617c> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6789 @066181> : 26                         load.i8
	<.main+6790 @066182> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6795 @066187> : 26                         load.i8
	<.main+6796 @066188> : 39                         cgt.u32
	<.main+6797 @066189> : 1f 48 3f 06 00             load.ref <@063f48> ;u8Cgt
	<.main+6802 @06618e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:97: (20 bytes: <.main+6803 @06618f> - <.main+6823 @0661a3>): static u8Cge: bool := u8A >= u8B
	<.main+6803 @06618f> : 1f a8 3e 06 00             load.ref <@063ea8> ;u8A
	<.main+6808 @066194> : 26                         load.i8
	<.main+6809 @066195> : 1f b0 3e 06 00             load.ref <@063eb0> ;u8B
	<.main+6814 @06619a> : 26                         load.i8
	<.main+6815 @06619b> : 38                         clt.u32
	<.main+6816 @06619c> : 0b                         not.b32
	<.main+6817 @06619d> : 1f 50 3f 06 00             load.ref <@063f50> ;u8Cge
	<.main+6822 @0661a2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:99: (11 bytes: <.main+6823 @0661a3> - <.main+6834 @0661ae>): static i16A: int16 := a
	<.main+6823 @0661a3> : 1c 60 00 00 00             load.c32 96
	<.main+6828 @0661a8> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6833 @0661ad> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:100: (11 bytes: <.main+6834 @0661ae> - <.main+6845 @0661b9>): static i16B: int16 := b
	<.main+6834 @0661ae> : 1c 2a 00 00 00             load.c32 42
	<.main+6839 @0661b3> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6844 @0661b8> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:101: (12 bytes: <.main+6845 @0661b9> - <.main+6857 @0661c5>): static i16Pls: int16 := +i16B
	<.main+6845 @0661b9> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6850 @0661be> : 27                         load.i16
	<.main+6851 @0661bf> : 1f 68 3f 06 00             load.ref <@063f68> ;i16Pls
	<.main+6856 @0661c4> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:102: (13 bytes: <.main+6857 @0661c5> - <.main+6870 @0661d2>): static i16Neg: int16 := -i16B
	<.main+6857 @0661c5> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6862 @0661ca> : 27                         load.i16
	<.main+6863 @0661cb> : 50                         neg.i32
	<.main+6864 @0661cc> : 1f 70 3f 06 00             load.ref <@063f70> ;i16Neg
	<.main+6869 @0661d1> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:103: (13 bytes: <.main+6870 @0661d2> - <.main+6883 @0661df>): static i16Cmt: int16 := ~i16B
	<.main+6870 @0661d2> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6875 @0661d7> : 27                         load.i16
	<.main+6876 @0661d8> : 30                         cmt.b32
	<.main+6877 @0661d9> : 1f 78 3f 06 00             load.ref <@063f78> ;i16Cmt
	<.main+6882 @0661de> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:104: (19 bytes: <.main+6883 @0661df> - <.main+6902 @0661f2>): static i16Add: int16 := i16A + i16B
	<.main+6883 @0661df> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6888 @0661e4> : 27                         load.i16
	<.main+6889 @0661e5> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6894 @0661ea> : 27                         load.i16
	<.main+6895 @0661eb> : 51                         add.i32
	<.main+6896 @0661ec> : 1f 80 3f 06 00             load.ref <@063f80> ;i16Add
	<.main+6901 @0661f1> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:105: (19 bytes: <.main+6902 @0661f2> - <.main+6921 @066205>): static i16Sub: int16 := i16A - i16B
	<.main+6902 @0661f2> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6907 @0661f7> : 27                         load.i16
	<.main+6908 @0661f8> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6913 @0661fd> : 27                         load.i16
	<.main+6914 @0661fe> : 52                         sub.i32
	<.main+6915 @0661ff> : 1f 88 3f 06 00             load.ref <@063f88> ;i16Sub
	<.main+6920 @066204> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:106: (19 bytes: <.main+6921 @066205> - <.main+6940 @066218>): static i16Mul: int16 := i16A * i16B
	<.main+6921 @066205> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6926 @06620a> : 27                         load.i16
	<.main+6927 @06620b> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6932 @066210> : 27                         load.i16
	<.main+6933 @066211> : 53                         mul.i32
	<.main+6934 @066212> : 1f 90 3f 06 00             load.ref <@063f90> ;i16Mul
	<.main+6939 @066217> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:107: (19 bytes: <.main+6940 @066218> - <.main+6959 @06622b>): static i16Div: int16 := i16A / i16B
	<.main+6940 @066218> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6945 @06621d> : 27                         load.i16
	<.main+6946 @06621e> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6951 @066223> : 27                         load.i16
	<.main+6952 @066224> : 54                         div.i32
	<.main+6953 @066225> : 1f 98 3f 06 00             load.ref <@063f98> ;i16Div
	<.main+6958 @06622a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:108: (19 bytes: <.main+6959 @06622b> - <.main+6978 @06623e>): static i16Mod: int16 := i16A % i16B
	<.main+6959 @06622b> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6964 @066230> : 27                         load.i16
	<.main+6965 @066231> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6970 @066236> : 27                         load.i16
	<.main+6971 @066237> : 55                         mod.i32
	<.main+6972 @066238> : 1f a0 3f 06 00             load.ref <@063fa0> ;i16Mod
	<.main+6977 @06623d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:109: (19 bytes: <.main+6978 @06623e> - <.main+6997 @066251>): static i16And: int16 := i16A & i16B
	<.main+6978 @06623e> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+6983 @066243> : 27                         load.i16
	<.main+6984 @066244> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+6989 @066249> : 27                         load.i16
	<.main+6990 @06624a> : 31                         and.b32
	<.main+6991 @06624b> : 1f a8 3f 06 00             load.ref <@063fa8> ;i16And
	<.main+6996 @066250> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:110: (19 bytes: <.main+6997 @066251> - <.main+7016 @066264>): static i16Ior: int16 := i16A | i16B
	<.main+6997 @066251> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7002 @066256> : 27                         load.i16
	<.main+7003 @066257> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7008 @06625c> : 27                         load.i16
	<.main+7009 @06625d> : 32                         or.b32
	<.main+7010 @06625e> : 1f b0 3f 06 00             load.ref <@063fb0> ;i16Ior
	<.main+7015 @066263> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:111: (19 bytes: <.main+7016 @066264> - <.main+7035 @066277>): static i16Xor: int16 := i16A ^ i16B
	<.main+7016 @066264> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7021 @066269> : 27                         load.i16
	<.main+7022 @06626a> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7027 @06626f> : 27                         load.i16
	<.main+7028 @066270> : 36                         xor.b32
	<.main+7029 @066271> : 1f b8 3f 06 00             load.ref <@063fb8> ;i16Xor
	<.main+7034 @066276> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:112: (17 bytes: <.main+7035 @066277> - <.main+7052 @066288>): static i16Shl: int16 := (i16A) << shift
	<.main+7035 @066277> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7040 @06627c> : 27                         load.i16
	<.main+7041 @06627d> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+7045 @066281> : 3a                         shl.b32
	<.main+7046 @066282> : 1f c0 3f 06 00             load.ref <@063fc0> ;i16Shl
	<.main+7051 @066287> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:113: (17 bytes: <.main+7052 @066288> - <.main+7069 @066299>): static i16Shr: int16 := (i16A) >> shift
	<.main+7052 @066288> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7057 @06628d> : 27                         load.i16
	<.main+7058 @06628e> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+7062 @066292> : 3c                         sar.b32
	<.main+7063 @066293> : 1f c8 3f 06 00             load.ref <@063fc8> ;i16Shr
	<.main+7068 @066298> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:114: (14 bytes: <.main+7069 @066299> - <.main+7083 @0662a7>): static i16Not: bool := !(i16B)
	<.main+7069 @066299> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7074 @06629e> : 27                         load.i16
	<.main+7075 @06629f> : 5a                         i32.2bool
	<.main+7076 @0662a0> : 0b                         not.b32
	<.main+7077 @0662a1> : 1f d0 3f 06 00             load.ref <@063fd0> ;i16Not
	<.main+7082 @0662a6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:115: (19 bytes: <.main+7083 @0662a7> - <.main+7102 @0662ba>): static i16Ceq: bool := i16A == i16B
	<.main+7083 @0662a7> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7088 @0662ac> : 27                         load.i16
	<.main+7089 @0662ad> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7094 @0662b2> : 27                         load.i16
	<.main+7095 @0662b3> : 57                         ceq.i32
	<.main+7096 @0662b4> : 1f d8 3f 06 00             load.ref <@063fd8> ;i16Ceq
	<.main+7101 @0662b9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:116: (20 bytes: <.main+7102 @0662ba> - <.main+7122 @0662ce>): static i16Cne: bool := i16A != i16B
	<.main+7102 @0662ba> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7107 @0662bf> : 27                         load.i16
	<.main+7108 @0662c0> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7113 @0662c5> : 27                         load.i16
	<.main+7114 @0662c6> : 57                         ceq.i32
	<.main+7115 @0662c7> : 0b                         not.b32
	<.main+7116 @0662c8> : 1f e0 3f 06 00             load.ref <@063fe0> ;i16Cne
	<.main+7121 @0662cd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:117: (19 bytes: <.main+7122 @0662ce> - <.main+7141 @0662e1>): static i16Clt: bool := i16A < i16B
	<.main+7122 @0662ce> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7127 @0662d3> : 27                         load.i16
	<.main+7128 @0662d4> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7133 @0662d9> : 27                         load.i16
	<.main+7134 @0662da> : 58                         clt.i32
	<.main+7135 @0662db> : 1f e8 3f 06 00             load.ref <@063fe8> ;i16Clt
	<.main+7140 @0662e0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:118: (20 bytes: <.main+7141 @0662e1> - <.main+7161 @0662f5>): static i16Cle: bool := i16A <= i16B
	<.main+7141 @0662e1> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7146 @0662e6> : 27                         load.i16
	<.main+7147 @0662e7> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7152 @0662ec> : 27                         load.i16
	<.main+7153 @0662ed> : 59                         cgt.i32
	<.main+7154 @0662ee> : 0b                         not.b32
	<.main+7155 @0662ef> : 1f f0 3f 06 00             load.ref <@063ff0> ;i16Cle
	<.main+7160 @0662f4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:119: (19 bytes: <.main+7161 @0662f5> - <.main+7180 @066308>): static i16Cgt: bool := i16A > i16B
	<.main+7161 @0662f5> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7166 @0662fa> : 27                         load.i16
	<.main+7167 @0662fb> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7172 @066300> : 27                         load.i16
	<.main+7173 @066301> : 59                         cgt.i32
	<.main+7174 @066302> : 1f f8 3f 06 00             load.ref <@063ff8> ;i16Cgt
	<.main+7179 @066307> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:120: (20 bytes: <.main+7180 @066308> - <.main+7200 @06631c>): static i16Cge: bool := i16A >= i16B
	<.main+7180 @066308> : 1f 58 3f 06 00             load.ref <@063f58> ;i16A
	<.main+7185 @06630d> : 27                         load.i16
	<.main+7186 @06630e> : 1f 60 3f 06 00             load.ref <@063f60> ;i16B
	<.main+7191 @066313> : 27                         load.i16
	<.main+7192 @066314> : 58                         clt.i32
	<.main+7193 @066315> : 0b                         not.b32
	<.main+7194 @066316> : 1f 00 40 06 00             load.ref <@064000> ;i16Cge
	<.main+7199 @06631b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:122: (11 bytes: <.main+7200 @06631c> - <.main+7211 @066327>): static u16A: uint16 := a
	<.main+7200 @06631c> : 1c 60 00 00 00             load.c32 96
	<.main+7205 @066321> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7210 @066326> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:123: (11 bytes: <.main+7211 @066327> - <.main+7222 @066332>): static u16B: uint16 := b
	<.main+7211 @066327> : 1c 2a 00 00 00             load.c32 42
	<.main+7216 @06632c> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7221 @066331> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:124: (12 bytes: <.main+7222 @066332> - <.main+7234 @06633e>): static u16Pls: uint16 := +u16B
	<.main+7222 @066332> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7227 @066337> : 27                         load.i16
	<.main+7228 @066338> : 1f 18 40 06 00             load.ref <@064018> ;u16Pls
	<.main+7233 @06633d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:125: (13 bytes: <.main+7234 @06633e> - <.main+7247 @06634b>): static u16Neg: uint16 := -u16B
	<.main+7234 @06633e> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7239 @066343> : 27                         load.i16
	<.main+7240 @066344> : 50                         neg.i32
	<.main+7241 @066345> : 1f 20 40 06 00             load.ref <@064020> ;u16Neg
	<.main+7246 @06634a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:126: (13 bytes: <.main+7247 @06634b> - <.main+7260 @066358>): static u16Cmt: uint16 := ~u16B
	<.main+7247 @06634b> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7252 @066350> : 27                         load.i16
	<.main+7253 @066351> : 30                         cmt.b32
	<.main+7254 @066352> : 1f 28 40 06 00             load.ref <@064028> ;u16Cmt
	<.main+7259 @066357> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:127: (19 bytes: <.main+7260 @066358> - <.main+7279 @06636b>): static u16Add: uint16 := u16A + u16B
	<.main+7260 @066358> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7265 @06635d> : 27                         load.i16
	<.main+7266 @06635e> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7271 @066363> : 27                         load.i16
	<.main+7272 @066364> : 51                         add.i32
	<.main+7273 @066365> : 1f 30 40 06 00             load.ref <@064030> ;u16Add
	<.main+7278 @06636a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:128: (19 bytes: <.main+7279 @06636b> - <.main+7298 @06637e>): static u16Sub: uint16 := u16A - u16B
	<.main+7279 @06636b> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7284 @066370> : 27                         load.i16
	<.main+7285 @066371> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7290 @066376> : 27                         load.i16
	<.main+7291 @066377> : 52                         sub.i32
	<.main+7292 @066378> : 1f 38 40 06 00             load.ref <@064038> ;u16Sub
	<.main+7297 @06637d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:129: (19 bytes: <.main+7298 @06637e> - <.main+7317 @066391>): static u16Mul: uint16 := u16A * u16B
	<.main+7298 @06637e> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7303 @066383> : 27                         load.i16
	<.main+7304 @066384> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7309 @066389> : 27                         load.i16
	<.main+7310 @06638a> : 33                         mul.u32
	<.main+7311 @06638b> : 1f 40 40 06 00             load.ref <@064040> ;u16Mul
	<.main+7316 @066390> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:130: (19 bytes: <.main+7317 @066391> - <.main+7336 @0663a4>): static u16Div: uint16 := u16A / u16B
	<.main+7317 @066391> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7322 @066396> : 27                         load.i16
	<.main+7323 @066397> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7328 @06639c> : 27                         load.i16
	<.main+7329 @06639d> : 34                         div.u32
	<.main+7330 @06639e> : 1f 48 40 06 00             load.ref <@064048> ;u16Div
	<.main+7335 @0663a3> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:131: (19 bytes: <.main+7336 @0663a4> - <.main+7355 @0663b7>): static u16Mod: uint16 := u16A % u16B
	<.main+7336 @0663a4> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7341 @0663a9> : 27                         load.i16
	<.main+7342 @0663aa> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7347 @0663af> : 27                         load.i16
	<.main+7348 @0663b0> : 35                         mod.u32
	<.main+7349 @0663b1> : 1f 50 40 06 00             load.ref <@064050> ;u16Mod
	<.main+7354 @0663b6> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:132: (19 bytes: <.main+7355 @0663b7> - <.main+7374 @0663ca>): static u16And: uint16 := u16A & u16B
	<.main+7355 @0663b7> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7360 @0663bc> : 27                         load.i16
	<.main+7361 @0663bd> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7366 @0663c2> : 27                         load.i16
	<.main+7367 @0663c3> : 31                         and.b32
	<.main+7368 @0663c4> : 1f 58 40 06 00             load.ref <@064058> ;u16And
	<.main+7373 @0663c9> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:133: (19 bytes: <.main+7374 @0663ca> - <.main+7393 @0663dd>): static u16Ior: uint16 := u16A | u16B
	<.main+7374 @0663ca> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7379 @0663cf> : 27                         load.i16
	<.main+7380 @0663d0> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7385 @0663d5> : 27                         load.i16
	<.main+7386 @0663d6> : 32                         or.b32
	<.main+7387 @0663d7> : 1f 60 40 06 00             load.ref <@064060> ;u16Ior
	<.main+7392 @0663dc> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:134: (19 bytes: <.main+7393 @0663dd> - <.main+7412 @0663f0>): static u16Xor: uint16 := u16A ^ u16B
	<.main+7393 @0663dd> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7398 @0663e2> : 27                         load.i16
	<.main+7399 @0663e3> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7404 @0663e8> : 27                         load.i16
	<.main+7405 @0663e9> : 36                         xor.b32
	<.main+7406 @0663ea> : 1f 68 40 06 00             load.ref <@064068> ;u16Xor
	<.main+7411 @0663ef> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:135: (17 bytes: <.main+7412 @0663f0> - <.main+7429 @066401>): static u16Shl: uint16 := (u16A) << shift
	<.main+7412 @0663f0> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7417 @0663f5> : 27                         load.i16
	<.main+7418 @0663f6> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+7422 @0663fa> : 3a                         shl.b32
	<.main+7423 @0663fb> : 1f 70 40 06 00             load.ref <@064070> ;u16Shl
	<.main+7428 @066400> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:136: (17 bytes: <.main+7429 @066401> - <.main+7446 @066412>): static u16Shr: uint16 := (u16A) >> shift
	<.main+7429 @066401> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7434 @066406> : 27                         load.i16
	<.main+7435 @066407> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+7439 @06640b> : 3c                         sar.b32
	<.main+7440 @06640c> : 1f 78 40 06 00             load.ref <@064078> ;u16Shr
	<.main+7445 @066411> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:137: (14 bytes: <.main+7446 @066412> - <.main+7460 @066420>): static u16Not: bool := !(u16B)
	<.main+7446 @066412> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7451 @066417> : 27                         load.i16
	<.main+7452 @066418> : 5a                         i32.2bool
	<.main+7453 @066419> : 0b                         not.b32
	<.main+7454 @06641a> : 1f 80 40 06 00             load.ref <@064080> ;u16Not
	<.main+7459 @06641f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:138: (19 bytes: <.main+7460 @066420> - <.main+7479 @066433>): static u16Ceq: bool := u16A == u16B
	<.main+7460 @066420> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7465 @066425> : 27                         load.i16
	<.main+7466 @066426> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7471 @06642b> : 27                         load.i16
	<.main+7472 @06642c> : 57                         ceq.i32
	<.main+7473 @06642d> : 1f 88 40 06 00             load.ref <@064088> ;u16Ceq
	<.main+7478 @066432> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:139: (20 bytes: <.main+7479 @066433> - <.main+7499 @066447>): static u16Cne: bool := u16A != u16B
	<.main+7479 @066433> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7484 @066438> : 27                         load.i16
	<.main+7485 @066439> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7490 @06643e> : 27                         load.i16
	<.main+7491 @06643f> : 57                         ceq.i32
	<.main+7492 @066440> : 0b                         not.b32
	<.main+7493 @066441> : 1f 90 40 06 00             load.ref <@064090> ;u16Cne
	<.main+7498 @066446> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:140: (19 bytes: <.main+7499 @066447> - <.main+7518 @06645a>): static u16Clt: bool := u16A < u16B
	<.main+7499 @066447> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7504 @06644c> : 27                         load.i16
	<.main+7505 @06644d> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7510 @066452> : 27                         load.i16
	<.main+7511 @066453> : 38                         clt.u32
	<.main+7512 @066454> : 1f 98 40 06 00             load.ref <@064098> ;u16Clt
	<.main+7517 @066459> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:141: (20 bytes: <.main+7518 @06645a> - <.main+7538 @06646e>): static u16Cle: bool := u16A <= u16B
	<.main+7518 @06645a> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7523 @06645f> : 27                         load.i16
	<.main+7524 @066460> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7529 @066465> : 27                         load.i16
	<.main+7530 @066466> : 39                         cgt.u32
	<.main+7531 @066467> : 0b                         not.b32
	<.main+7532 @066468> : 1f a0 40 06 00             load.ref <@0640a0> ;u16Cle
	<.main+7537 @06646d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:142: (19 bytes: <.main+7538 @06646e> - <.main+7557 @066481>): static u16Cgt: bool := u16A > u16B
	<.main+7538 @06646e> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7543 @066473> : 27                         load.i16
	<.main+7544 @066474> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7549 @066479> : 27                         load.i16
	<.main+7550 @06647a> : 39                         cgt.u32
	<.main+7551 @06647b> : 1f a8 40 06 00             load.ref <@0640a8> ;u16Cgt
	<.main+7556 @066480> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:143: (20 bytes: <.main+7557 @066481> - <.main+7577 @066495>): static u16Cge: bool := u16A >= u16B
	<.main+7557 @066481> : 1f 08 40 06 00             load.ref <@064008> ;u16A
	<.main+7562 @066486> : 27                         load.i16
	<.main+7563 @066487> : 1f 10 40 06 00             load.ref <@064010> ;u16B
	<.main+7568 @06648c> : 27                         load.i16
	<.main+7569 @06648d> : 38                         clt.u32
	<.main+7570 @06648e> : 0b                         not.b32
	<.main+7571 @06648f> : 1f b0 40 06 00             load.ref <@0640b0> ;u16Cge
	<.main+7576 @066494> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:145: (9 bytes: <.main+7577 @066495> - <.main+7586 @06649e>): static i32A: int32 := a
	<.main+7577 @066495> : 1c 60 00 00 00             load.c32 96
	<.main+7582 @06649a> : 24 b8 40 06                store.m32 <@0640b8> ;i32A
	cmplStd/test/lang/useOperator.ci:146: (9 bytes: <.main+7586 @06649e> - <.main+7595 @0664a7>): static i32B: int32 := b
	<.main+7586 @06649e> : 1c 2a 00 00 00             load.c32 42
	<.main+7591 @0664a3> : 24 c0 40 06                store.m32 <@0640c0> ;i32B
	cmplStd/test/lang/useOperator.ci:147: (8 bytes: <.main+7595 @0664a7> - <.main+7603 @0664af>): static i32Pls: int32 := +i32B
	<.main+7595 @0664a7> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7599 @0664ab> : 24 c8 40 06                store.m32 <@0640c8> ;i32Pls
	cmplStd/test/lang/useOperator.ci:148: (9 bytes: <.main+7603 @0664af> - <.main+7612 @0664b8>): static i32Neg: int32 := -i32B
	<.main+7603 @0664af> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7607 @0664b3> : 50                         neg.i32
	<.main+7608 @0664b4> : 24 d0 40 06                store.m32 <@0640d0> ;i32Neg
	cmplStd/test/lang/useOperator.ci:149: (9 bytes: <.main+7612 @0664b8> - <.main+7621 @0664c1>): static i32Cmt: int32 := ~i32B
	<.main+7612 @0664b8> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7616 @0664bc> : 30                         cmt.b32
	<.main+7617 @0664bd> : 24 d8 40 06                store.m32 <@0640d8> ;i32Cmt
	cmplStd/test/lang/useOperator.ci:150: (13 bytes: <.main+7621 @0664c1> - <.main+7634 @0664ce>): static i32Add: int32 := i32A + i32B
	<.main+7621 @0664c1> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7625 @0664c5> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7629 @0664c9> : 51                         add.i32
	<.main+7630 @0664ca> : 24 e0 40 06                store.m32 <@0640e0> ;i32Add
	cmplStd/test/lang/useOperator.ci:151: (13 bytes: <.main+7634 @0664ce> - <.main+7647 @0664db>): static i32Sub: int32 := i32A - i32B
	<.main+7634 @0664ce> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7638 @0664d2> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7642 @0664d6> : 52                         sub.i32
	<.main+7643 @0664d7> : 24 e8 40 06                store.m32 <@0640e8> ;i32Sub
	cmplStd/test/lang/useOperator.ci:152: (13 bytes: <.main+7647 @0664db> - <.main+7660 @0664e8>): static i32Mul: int32 := i32A * i32B
	<.main+7647 @0664db> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7651 @0664df> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7655 @0664e3> : 53                         mul.i32
	<.main+7656 @0664e4> : 24 f0 40 06                store.m32 <@0640f0> ;i32Mul
	cmplStd/test/lang/useOperator.ci:153: (13 bytes: <.main+7660 @0664e8> - <.main+7673 @0664f5>): static i32Div: int32 := i32A / i32B
	<.main+7660 @0664e8> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7664 @0664ec> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7668 @0664f0> : 54                         div.i32
	<.main+7669 @0664f1> : 24 f8 40 06                store.m32 <@0640f8> ;i32Div
	cmplStd/test/lang/useOperator.ci:154: (13 bytes: <.main+7673 @0664f5> - <.main+7686 @066502>): static i32Mod: int32 := i32A % i32B
	<.main+7673 @0664f5> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7677 @0664f9> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7681 @0664fd> : 55                         mod.i32
	<.main+7682 @0664fe> : 24 00 41 06                store.m32 <@064100> ;i32Mod
	cmplStd/test/lang/useOperator.ci:155: (13 bytes: <.main+7686 @066502> - <.main+7699 @06650f>): static i32And: int32 := i32A & i32B
	<.main+7686 @066502> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7690 @066506> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7694 @06650a> : 31                         and.b32
	<.main+7695 @06650b> : 24 08 41 06                store.m32 <@064108> ;i32And
	cmplStd/test/lang/useOperator.ci:156: (13 bytes: <.main+7699 @06650f> - <.main+7712 @06651c>): static i32Ior: int32 := i32A | i32B
	<.main+7699 @06650f> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7703 @066513> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7707 @066517> : 32                         or.b32
	<.main+7708 @066518> : 24 10 41 06                store.m32 <@064110> ;i32Ior
	cmplStd/test/lang/useOperator.ci:157: (13 bytes: <.main+7712 @06651c> - <.main+7725 @066529>): static i32Xor: int32 := i32A ^ i32B
	<.main+7712 @06651c> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7716 @066520> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7720 @066524> : 36                         xor.b32
	<.main+7721 @066525> : 24 18 41 06                store.m32 <@064118> ;i32Xor
	cmplStd/test/lang/useOperator.ci:158: (13 bytes: <.main+7725 @066529> - <.main+7738 @066536>): static i32Shl: int32 := i32A << shift
	<.main+7725 @066529> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7729 @06652d> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+7733 @066531> : 3a                         shl.b32
	<.main+7734 @066532> : 24 20 41 06                store.m32 <@064120> ;i32Shl
	cmplStd/test/lang/useOperator.ci:159: (13 bytes: <.main+7738 @066536> - <.main+7751 @066543>): static i32Shr: int32 := i32A >> shift
	<.main+7738 @066536> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7742 @06653a> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+7746 @06653e> : 3c                         sar.b32
	<.main+7747 @06653f> : 24 28 41 06                store.m32 <@064128> ;i32Shr
	cmplStd/test/lang/useOperator.ci:160: (12 bytes: <.main+7751 @066543> - <.main+7763 @06654f>): static i32Not: bool := !(i32B)
	<.main+7751 @066543> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7755 @066547> : 5a                         i32.2bool
	<.main+7756 @066548> : 0b                         not.b32
	<.main+7757 @066549> : 1f 30 41 06 00             load.ref <@064130> ;i32Not
	<.main+7762 @06654e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:161: (15 bytes: <.main+7763 @06654f> - <.main+7778 @06655e>): static i32Ceq: bool := i32A == i32B
	<.main+7763 @06654f> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7767 @066553> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7771 @066557> : 57                         ceq.i32
	<.main+7772 @066558> : 1f 38 41 06 00             load.ref <@064138> ;i32Ceq
	<.main+7777 @06655d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:162: (16 bytes: <.main+7778 @06655e> - <.main+7794 @06656e>): static i32Cne: bool := i32A != i32B
	<.main+7778 @06655e> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7782 @066562> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7786 @066566> : 57                         ceq.i32
	<.main+7787 @066567> : 0b                         not.b32
	<.main+7788 @066568> : 1f 40 41 06 00             load.ref <@064140> ;i32Cne
	<.main+7793 @06656d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:163: (15 bytes: <.main+7794 @06656e> - <.main+7809 @06657d>): static i32Clt: bool := i32A < i32B
	<.main+7794 @06656e> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7798 @066572> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7802 @066576> : 58                         clt.i32
	<.main+7803 @066577> : 1f 48 41 06 00             load.ref <@064148> ;i32Clt
	<.main+7808 @06657c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:164: (16 bytes: <.main+7809 @06657d> - <.main+7825 @06658d>): static i32Cle: bool := i32A <= i32B
	<.main+7809 @06657d> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7813 @066581> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7817 @066585> : 59                         cgt.i32
	<.main+7818 @066586> : 0b                         not.b32
	<.main+7819 @066587> : 1f 50 41 06 00             load.ref <@064150> ;i32Cle
	<.main+7824 @06658c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:165: (15 bytes: <.main+7825 @06658d> - <.main+7840 @06659c>): static i32Cgt: bool := i32A > i32B
	<.main+7825 @06658d> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7829 @066591> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7833 @066595> : 59                         cgt.i32
	<.main+7834 @066596> : 1f 58 41 06 00             load.ref <@064158> ;i32Cgt
	<.main+7839 @06659b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:166: (16 bytes: <.main+7840 @06659c> - <.main+7856 @0665ac>): static i32Cge: bool := i32A >= i32B
	<.main+7840 @06659c> : 20 b8 40 06                load.m32 <@0640b8> ;i32A
	<.main+7844 @0665a0> : 20 c0 40 06                load.m32 <@0640c0> ;i32B
	<.main+7848 @0665a4> : 58                         clt.i32
	<.main+7849 @0665a5> : 0b                         not.b32
	<.main+7850 @0665a6> : 1f 60 41 06 00             load.ref <@064160> ;i32Cge
	<.main+7855 @0665ab> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:168: (9 bytes: <.main+7856 @0665ac> - <.main+7865 @0665b5>): static u32A: uint32 := a
	<.main+7856 @0665ac> : 1c 60 00 00 00             load.c32 96
	<.main+7861 @0665b1> : 24 68 41 06                store.m32 <@064168> ;u32A
	cmplStd/test/lang/useOperator.ci:169: (9 bytes: <.main+7865 @0665b5> - <.main+7874 @0665be>): static u32B: uint32 := b
	<.main+7865 @0665b5> : 1c 2a 00 00 00             load.c32 42
	<.main+7870 @0665ba> : 24 70 41 06                store.m32 <@064170> ;u32B
	cmplStd/test/lang/useOperator.ci:170: (8 bytes: <.main+7874 @0665be> - <.main+7882 @0665c6>): static u32Pls: uint32 := +u32B
	<.main+7874 @0665be> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7878 @0665c2> : 24 78 41 06                store.m32 <@064178> ;u32Pls
	cmplStd/test/lang/useOperator.ci:171: (9 bytes: <.main+7882 @0665c6> - <.main+7891 @0665cf>): static u32Neg: uint32 := -u32B
	<.main+7882 @0665c6> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7886 @0665ca> : 50                         neg.i32
	<.main+7887 @0665cb> : 24 80 41 06                store.m32 <@064180> ;u32Neg
	cmplStd/test/lang/useOperator.ci:172: (9 bytes: <.main+7891 @0665cf> - <.main+7900 @0665d8>): static u32Cmt: uint32 := ~u32B
	<.main+7891 @0665cf> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7895 @0665d3> : 30                         cmt.b32
	<.main+7896 @0665d4> : 24 88 41 06                store.m32 <@064188> ;u32Cmt
	cmplStd/test/lang/useOperator.ci:173: (13 bytes: <.main+7900 @0665d8> - <.main+7913 @0665e5>): static u32Add: uint32 := u32A + u32B
	<.main+7900 @0665d8> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7904 @0665dc> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7908 @0665e0> : 51                         add.i32
	<.main+7909 @0665e1> : 24 90 41 06                store.m32 <@064190> ;u32Add
	cmplStd/test/lang/useOperator.ci:174: (13 bytes: <.main+7913 @0665e5> - <.main+7926 @0665f2>): static u32Sub: uint32 := u32A - u32B
	<.main+7913 @0665e5> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7917 @0665e9> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7921 @0665ed> : 52                         sub.i32
	<.main+7922 @0665ee> : 24 98 41 06                store.m32 <@064198> ;u32Sub
	cmplStd/test/lang/useOperator.ci:175: (13 bytes: <.main+7926 @0665f2> - <.main+7939 @0665ff>): static u32Mul: uint32 := u32A * u32B
	<.main+7926 @0665f2> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7930 @0665f6> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7934 @0665fa> : 33                         mul.u32
	<.main+7935 @0665fb> : 24 a0 41 06                store.m32 <@0641a0> ;u32Mul
	cmplStd/test/lang/useOperator.ci:176: (13 bytes: <.main+7939 @0665ff> - <.main+7952 @06660c>): static u32Div: uint32 := u32A / u32B
	<.main+7939 @0665ff> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7943 @066603> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7947 @066607> : 34                         div.u32
	<.main+7948 @066608> : 24 a8 41 06                store.m32 <@0641a8> ;u32Div
	cmplStd/test/lang/useOperator.ci:177: (13 bytes: <.main+7952 @06660c> - <.main+7965 @066619>): static u32Mod: uint32 := u32A % u32B
	<.main+7952 @06660c> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7956 @066610> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7960 @066614> : 35                         mod.u32
	<.main+7961 @066615> : 24 b0 41 06                store.m32 <@0641b0> ;u32Mod
	cmplStd/test/lang/useOperator.ci:178: (13 bytes: <.main+7965 @066619> - <.main+7978 @066626>): static u32And: uint32 := u32A & u32B
	<.main+7965 @066619> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7969 @06661d> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7973 @066621> : 31                         and.b32
	<.main+7974 @066622> : 24 b8 41 06                store.m32 <@0641b8> ;u32And
	cmplStd/test/lang/useOperator.ci:179: (13 bytes: <.main+7978 @066626> - <.main+7991 @066633>): static u32Ior: uint32 := u32A | u32B
	<.main+7978 @066626> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7982 @06662a> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7986 @06662e> : 32                         or.b32
	<.main+7987 @06662f> : 24 c0 41 06                store.m32 <@0641c0> ;u32Ior
	cmplStd/test/lang/useOperator.ci:180: (13 bytes: <.main+7991 @066633> - <.main+8004 @066640>): static u32Xor: uint32 := u32A ^ u32B
	<.main+7991 @066633> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+7995 @066637> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+7999 @06663b> : 36                         xor.b32
	<.main+8000 @06663c> : 24 c8 41 06                store.m32 <@0641c8> ;u32Xor
	cmplStd/test/lang/useOperator.ci:181: (13 bytes: <.main+8004 @066640> - <.main+8017 @06664d>): static u32Shl: uint32 := u32A << shift
	<.main+8004 @066640> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8008 @066644> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+8012 @066648> : 3a                         shl.b32
	<.main+8013 @066649> : 24 d0 41 06                store.m32 <@0641d0> ;u32Shl
	cmplStd/test/lang/useOperator.ci:182: (13 bytes: <.main+8017 @06664d> - <.main+8030 @06665a>): static u32Shr: uint32 := u32A >> shift
	<.main+8017 @06664d> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8021 @066651> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+8025 @066655> : 3b                         shr.b32
	<.main+8026 @066656> : 24 d8 41 06                store.m32 <@0641d8> ;u32Shr
	cmplStd/test/lang/useOperator.ci:183: (12 bytes: <.main+8030 @06665a> - <.main+8042 @066666>): static u32Not: bool := !(u32B)
	<.main+8030 @06665a> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8034 @06665e> : 5a                         i32.2bool
	<.main+8035 @06665f> : 0b                         not.b32
	<.main+8036 @066660> : 1f e0 41 06 00             load.ref <@0641e0> ;u32Not
	<.main+8041 @066665> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:184: (15 bytes: <.main+8042 @066666> - <.main+8057 @066675>): static u32Ceq: bool := u32A == u32B
	<.main+8042 @066666> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8046 @06666a> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8050 @06666e> : 57                         ceq.i32
	<.main+8051 @06666f> : 1f e8 41 06 00             load.ref <@0641e8> ;u32Ceq
	<.main+8056 @066674> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:185: (16 bytes: <.main+8057 @066675> - <.main+8073 @066685>): static u32Cne: bool := u32A != u32B
	<.main+8057 @066675> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8061 @066679> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8065 @06667d> : 57                         ceq.i32
	<.main+8066 @06667e> : 0b                         not.b32
	<.main+8067 @06667f> : 1f f0 41 06 00             load.ref <@0641f0> ;u32Cne
	<.main+8072 @066684> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:186: (15 bytes: <.main+8073 @066685> - <.main+8088 @066694>): static u32Clt: bool := u32A < u32B
	<.main+8073 @066685> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8077 @066689> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8081 @06668d> : 38                         clt.u32
	<.main+8082 @06668e> : 1f f8 41 06 00             load.ref <@0641f8> ;u32Clt
	<.main+8087 @066693> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:187: (16 bytes: <.main+8088 @066694> - <.main+8104 @0666a4>): static u32Cle: bool := u32A <= u32B
	<.main+8088 @066694> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8092 @066698> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8096 @06669c> : 39                         cgt.u32
	<.main+8097 @06669d> : 0b                         not.b32
	<.main+8098 @06669e> : 1f 00 42 06 00             load.ref <@064200> ;u32Cle
	<.main+8103 @0666a3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:188: (15 bytes: <.main+8104 @0666a4> - <.main+8119 @0666b3>): static u32Cgt: bool := u32A > u32B
	<.main+8104 @0666a4> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8108 @0666a8> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8112 @0666ac> : 39                         cgt.u32
	<.main+8113 @0666ad> : 1f 08 42 06 00             load.ref <@064208> ;u32Cgt
	<.main+8118 @0666b2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:189: (16 bytes: <.main+8119 @0666b3> - <.main+8135 @0666c3>): static u32Cge: bool := u32A >= u32B
	<.main+8119 @0666b3> : 20 68 41 06                load.m32 <@064168> ;u32A
	<.main+8123 @0666b7> : 20 70 41 06                load.m32 <@064170> ;u32B
	<.main+8127 @0666bb> : 38                         clt.u32
	<.main+8128 @0666bc> : 0b                         not.b32
	<.main+8129 @0666bd> : 1f 10 42 06 00             load.ref <@064210> ;u32Cge
	<.main+8134 @0666c2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:191: (13 bytes: <.main+8135 @0666c3> - <.main+8148 @0666d0>): static i64A: int64 := a
	<.main+8135 @0666c3> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8144 @0666cc> : 23 18 42 06                store.m64 <@064218> ;i64A
	cmplStd/test/lang/useOperator.ci:192: (13 bytes: <.main+8148 @0666d0> - <.main+8161 @0666dd>): static i64B: int64 := b
	<.main+8148 @0666d0> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8157 @0666d9> : 23 20 42 06                store.m64 <@064220> ;i64B
	cmplStd/test/lang/useOperator.ci:193: (8 bytes: <.main+8161 @0666dd> - <.main+8169 @0666e5>): static i64Pls: int64 := +i64B
	<.main+8161 @0666dd> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8165 @0666e1> : 23 28 42 06                store.m64 <@064228> ;i64Pls
	cmplStd/test/lang/useOperator.ci:194: (9 bytes: <.main+8169 @0666e5> - <.main+8178 @0666ee>): static i64Neg: int64 := -i64B
	<.main+8169 @0666e5> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8173 @0666e9> : 60                         neg.i64
	<.main+8174 @0666ea> : 23 30 42 06                store.m64 <@064230> ;i64Neg
	cmplStd/test/lang/useOperator.ci:195: (9 bytes: <.main+8178 @0666ee> - <.main+8187 @0666f7>): static i64Cmt: int64 := ~i64B
	<.main+8178 @0666ee> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8182 @0666f2> : 40                         cmt.b64
	<.main+8183 @0666f3> : 23 38 42 06                store.m64 <@064238> ;i64Cmt
	cmplStd/test/lang/useOperator.ci:196: (13 bytes: <.main+8187 @0666f7> - <.main+8200 @066704>): static i64Add: int64 := i64A + i64B
	<.main+8187 @0666f7> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8191 @0666fb> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8195 @0666ff> : 61                         add.i64
	<.main+8196 @066700> : 23 40 42 06                store.m64 <@064240> ;i64Add
	cmplStd/test/lang/useOperator.ci:197: (13 bytes: <.main+8200 @066704> - <.main+8213 @066711>): static i64Sub: int64 := i64A - i64B
	<.main+8200 @066704> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8204 @066708> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8208 @06670c> : 62                         sub.i64
	<.main+8209 @06670d> : 23 48 42 06                store.m64 <@064248> ;i64Sub
	cmplStd/test/lang/useOperator.ci:198: (13 bytes: <.main+8213 @066711> - <.main+8226 @06671e>): static i64Mul: int64 := i64A * i64B
	<.main+8213 @066711> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8217 @066715> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8221 @066719> : 63                         mul.i64
	<.main+8222 @06671a> : 23 50 42 06                store.m64 <@064250> ;i64Mul
	cmplStd/test/lang/useOperator.ci:199: (13 bytes: <.main+8226 @06671e> - <.main+8239 @06672b>): static i64Div: int64 := i64A / i64B
	<.main+8226 @06671e> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8230 @066722> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8234 @066726> : 64                         div.i64
	<.main+8235 @066727> : 23 58 42 06                store.m64 <@064258> ;i64Div
	cmplStd/test/lang/useOperator.ci:200: (13 bytes: <.main+8239 @06672b> - <.main+8252 @066738>): static i64Mod: int64 := i64A % i64B
	<.main+8239 @06672b> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8243 @06672f> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8247 @066733> : 65                         mod.i64
	<.main+8248 @066734> : 23 60 42 06                store.m64 <@064260> ;i64Mod
	cmplStd/test/lang/useOperator.ci:201: (13 bytes: <.main+8252 @066738> - <.main+8265 @066745>): static i64And: int64 := i64A & i64B
	<.main+8252 @066738> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8256 @06673c> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8260 @066740> : 41                         and.b64
	<.main+8261 @066741> : 23 68 42 06                store.m64 <@064268> ;i64And
	cmplStd/test/lang/useOperator.ci:202: (13 bytes: <.main+8265 @066745> - <.main+8278 @066752>): static i64Ior: int64 := i64A | i64B
	<.main+8265 @066745> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8269 @066749> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8273 @06674d> : 42                         or.b64
	<.main+8274 @06674e> : 23 70 42 06                store.m64 <@064270> ;i64Ior
	cmplStd/test/lang/useOperator.ci:203: (13 bytes: <.main+8278 @066752> - <.main+8291 @06675f>): static i64Xor: int64 := i64A ^ i64B
	<.main+8278 @066752> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8282 @066756> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8286 @06675a> : 46                         xor.b64
	<.main+8287 @06675b> : 23 78 42 06                store.m64 <@064278> ;i64Xor
	cmplStd/test/lang/useOperator.ci:204: (13 bytes: <.main+8291 @06675f> - <.main+8304 @06676c>): static i64Shl: int64 := i64A << shift
	<.main+8291 @06675f> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8295 @066763> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+8299 @066767> : 4a                         shl.b64
	<.main+8300 @066768> : 23 80 42 06                store.m64 <@064280> ;i64Shl
	cmplStd/test/lang/useOperator.ci:205: (13 bytes: <.main+8304 @06676c> - <.main+8317 @066779>): static i64Shr: int64 := i64A >> shift
	<.main+8304 @06676c> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8308 @066770> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+8312 @066774> : 4c                         sar.b64
	<.main+8313 @066775> : 23 88 42 06                store.m64 <@064288> ;i64Shr
	cmplStd/test/lang/useOperator.ci:206: (12 bytes: <.main+8317 @066779> - <.main+8329 @066785>): static i64Not: bool := !(i64B)
	<.main+8317 @066779> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8321 @06677d> : 6b                         i64.2bool
	<.main+8322 @06677e> : 0b                         not.b32
	<.main+8323 @06677f> : 1f 90 42 06 00             load.ref <@064290> ;i64Not
	<.main+8328 @066784> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:207: (15 bytes: <.main+8329 @066785> - <.main+8344 @066794>): static i64Ceq: bool := i64A == i64B
	<.main+8329 @066785> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8333 @066789> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8337 @06678d> : 67                         ceq.i64
	<.main+8338 @06678e> : 1f 98 42 06 00             load.ref <@064298> ;i64Ceq
	<.main+8343 @066793> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:208: (16 bytes: <.main+8344 @066794> - <.main+8360 @0667a4>): static i64Cne: bool := i64A != i64B
	<.main+8344 @066794> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8348 @066798> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8352 @06679c> : 67                         ceq.i64
	<.main+8353 @06679d> : 0b                         not.b32
	<.main+8354 @06679e> : 1f a0 42 06 00             load.ref <@0642a0> ;i64Cne
	<.main+8359 @0667a3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:209: (15 bytes: <.main+8360 @0667a4> - <.main+8375 @0667b3>): static i64Clt: bool := i64A < i64B
	<.main+8360 @0667a4> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8364 @0667a8> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8368 @0667ac> : 68                         clt.i64
	<.main+8369 @0667ad> : 1f a8 42 06 00             load.ref <@0642a8> ;i64Clt
	<.main+8374 @0667b2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:210: (16 bytes: <.main+8375 @0667b3> - <.main+8391 @0667c3>): static i64Cle: bool := i64A <= i64B
	<.main+8375 @0667b3> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8379 @0667b7> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8383 @0667bb> : 69                         cgt.i64
	<.main+8384 @0667bc> : 0b                         not.b32
	<.main+8385 @0667bd> : 1f b0 42 06 00             load.ref <@0642b0> ;i64Cle
	<.main+8390 @0667c2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:211: (15 bytes: <.main+8391 @0667c3> - <.main+8406 @0667d2>): static i64Cgt: bool := i64A > i64B
	<.main+8391 @0667c3> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8395 @0667c7> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8399 @0667cb> : 69                         cgt.i64
	<.main+8400 @0667cc> : 1f b8 42 06 00             load.ref <@0642b8> ;i64Cgt
	<.main+8405 @0667d1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:212: (16 bytes: <.main+8406 @0667d2> - <.main+8422 @0667e2>): static i64Cge: bool := i64A >= i64B
	<.main+8406 @0667d2> : 21 18 42 06                load.m64 <@064218> ;i64A
	<.main+8410 @0667d6> : 21 20 42 06                load.m64 <@064220> ;i64B
	<.main+8414 @0667da> : 68                         clt.i64
	<.main+8415 @0667db> : 0b                         not.b32
	<.main+8416 @0667dc> : 1f c0 42 06 00             load.ref <@0642c0> ;i64Cge
	<.main+8421 @0667e1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:214: (13 bytes: <.main+8422 @0667e2> - <.main+8435 @0667ef>): static u64A: uint64 := a
	<.main+8422 @0667e2> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8431 @0667eb> : 23 c8 42 06                store.m64 <@0642c8> ;u64A
	cmplStd/test/lang/useOperator.ci:215: (13 bytes: <.main+8435 @0667ef> - <.main+8448 @0667fc>): static u64B: uint64 := b
	<.main+8435 @0667ef> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8444 @0667f8> : 23 d0 42 06                store.m64 <@0642d0> ;u64B
	cmplStd/test/lang/useOperator.ci:216: (8 bytes: <.main+8448 @0667fc> - <.main+8456 @066804>): static u64Pls: uint64 := +u64B
	<.main+8448 @0667fc> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8452 @066800> : 23 d8 42 06                store.m64 <@0642d8> ;u64Pls
	cmplStd/test/lang/useOperator.ci:217: (9 bytes: <.main+8456 @066804> - <.main+8465 @06680d>): static u64Neg: uint64 := -u64B
	<.main+8456 @066804> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8460 @066808> : 60                         neg.i64
	<.main+8461 @066809> : 23 e0 42 06                store.m64 <@0642e0> ;u64Neg
	cmplStd/test/lang/useOperator.ci:218: (9 bytes: <.main+8465 @06680d> - <.main+8474 @066816>): static u64Cmt: uint64 := ~u64B
	<.main+8465 @06680d> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8469 @066811> : 40                         cmt.b64
	<.main+8470 @066812> : 23 e8 42 06                store.m64 <@0642e8> ;u64Cmt
	cmplStd/test/lang/useOperator.ci:219: (13 bytes: <.main+8474 @066816> - <.main+8487 @066823>): static u64Add: uint64 := u64A + u64B
	<.main+8474 @066816> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8478 @06681a> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8482 @06681e> : 61                         add.i64
	<.main+8483 @06681f> : 23 f0 42 06                store.m64 <@0642f0> ;u64Add
	cmplStd/test/lang/useOperator.ci:220: (13 bytes: <.main+8487 @066823> - <.main+8500 @066830>): static u64Sub: uint64 := u64A - u64B
	<.main+8487 @066823> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8491 @066827> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8495 @06682b> : 62                         sub.i64
	<.main+8496 @06682c> : 23 f8 42 06                store.m64 <@0642f8> ;u64Sub
	cmplStd/test/lang/useOperator.ci:221: (13 bytes: <.main+8500 @066830> - <.main+8513 @06683d>): static u64Mul: uint64 := u64A * u64B
	<.main+8500 @066830> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8504 @066834> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8508 @066838> : 43                         mul.u64
	<.main+8509 @066839> : 23 00 43 06                store.m64 <@064300> ;u64Mul
	cmplStd/test/lang/useOperator.ci:222: (13 bytes: <.main+8513 @06683d> - <.main+8526 @06684a>): static u64Div: uint64 := u64A / u64B
	<.main+8513 @06683d> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8517 @066841> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8521 @066845> : 44                         div.u64
	<.main+8522 @066846> : 23 08 43 06                store.m64 <@064308> ;u64Div
	cmplStd/test/lang/useOperator.ci:223: (13 bytes: <.main+8526 @06684a> - <.main+8539 @066857>): static u64Mod: uint64 := u64A % u64B
	<.main+8526 @06684a> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8530 @06684e> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8534 @066852> : 45                         mod.u64
	<.main+8535 @066853> : 23 10 43 06                store.m64 <@064310> ;u64Mod
	cmplStd/test/lang/useOperator.ci:224: (13 bytes: <.main+8539 @066857> - <.main+8552 @066864>): static u64And: uint64 := u64A & u64B
	<.main+8539 @066857> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8543 @06685b> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8547 @06685f> : 41                         and.b64
	<.main+8548 @066860> : 23 18 43 06                store.m64 <@064318> ;u64And
	cmplStd/test/lang/useOperator.ci:225: (13 bytes: <.main+8552 @066864> - <.main+8565 @066871>): static u64Ior: uint64 := u64A | u64B
	<.main+8552 @066864> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8556 @066868> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8560 @06686c> : 42                         or.b64
	<.main+8561 @06686d> : 23 20 43 06                store.m64 <@064320> ;u64Ior
	cmplStd/test/lang/useOperator.ci:226: (13 bytes: <.main+8565 @066871> - <.main+8578 @06687e>): static u64Xor: uint64 := u64A ^ u64B
	<.main+8565 @066871> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8569 @066875> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8573 @066879> : 46                         xor.b64
	<.main+8574 @06687a> : 23 28 43 06                store.m64 <@064328> ;u64Xor
	cmplStd/test/lang/useOperator.ci:227: (13 bytes: <.main+8578 @06687e> - <.main+8591 @06688b>): static u64Shl: uint64 := u64A << shift
	<.main+8578 @06687e> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8582 @066882> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+8586 @066886> : 4a                         shl.b64
	<.main+8587 @066887> : 23 30 43 06                store.m64 <@064330> ;u64Shl
	cmplStd/test/lang/useOperator.ci:228: (13 bytes: <.main+8591 @06688b> - <.main+8604 @066898>): static u64Shr: uint64 := u64A >> shift
	<.main+8591 @06688b> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8595 @06688f> : 20 e0 3c 06                load.m32 <@063ce0> ;shift
	<.main+8599 @066893> : 4b                         shr.b64
	<.main+8600 @066894> : 23 38 43 06                store.m64 <@064338> ;u64Shr
	cmplStd/test/lang/useOperator.ci:229: (12 bytes: <.main+8604 @066898> - <.main+8616 @0668a4>): static u64Not: bool := !(u64B)
	<.main+8604 @066898> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8608 @06689c> : 6b                         i64.2bool
	<.main+8609 @06689d> : 0b                         not.b32
	<.main+8610 @06689e> : 1f 40 43 06 00             load.ref <@064340> ;u64Not
	<.main+8615 @0668a3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:230: (15 bytes: <.main+8616 @0668a4> - <.main+8631 @0668b3>): static u64Ceq: bool := u64A == u64B
	<.main+8616 @0668a4> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8620 @0668a8> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8624 @0668ac> : 67                         ceq.i64
	<.main+8625 @0668ad> : 1f 48 43 06 00             load.ref <@064348> ;u64Ceq
	<.main+8630 @0668b2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:231: (16 bytes: <.main+8631 @0668b3> - <.main+8647 @0668c3>): static u64Cne: bool := u64A != u64B
	<.main+8631 @0668b3> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8635 @0668b7> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8639 @0668bb> : 67                         ceq.i64
	<.main+8640 @0668bc> : 0b                         not.b32
	<.main+8641 @0668bd> : 1f 50 43 06 00             load.ref <@064350> ;u64Cne
	<.main+8646 @0668c2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:232: (15 bytes: <.main+8647 @0668c3> - <.main+8662 @0668d2>): static u64Clt: bool := u64A < u64B
	<.main+8647 @0668c3> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8651 @0668c7> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8655 @0668cb> : 48                         clt.u64
	<.main+8656 @0668cc> : 1f 58 43 06 00             load.ref <@064358> ;u64Clt
	<.main+8661 @0668d1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:233: (16 bytes: <.main+8662 @0668d2> - <.main+8678 @0668e2>): static u64Cle: bool := u64A <= u64B
	<.main+8662 @0668d2> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8666 @0668d6> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8670 @0668da> : 49                         cgt.u64
	<.main+8671 @0668db> : 0b                         not.b32
	<.main+8672 @0668dc> : 1f 60 43 06 00             load.ref <@064360> ;u64Cle
	<.main+8677 @0668e1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:234: (15 bytes: <.main+8678 @0668e2> - <.main+8693 @0668f1>): static u64Cgt: bool := u64A > u64B
	<.main+8678 @0668e2> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8682 @0668e6> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8686 @0668ea> : 49                         cgt.u64
	<.main+8687 @0668eb> : 1f 68 43 06 00             load.ref <@064368> ;u64Cgt
	<.main+8692 @0668f0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:235: (16 bytes: <.main+8693 @0668f1> - <.main+8709 @066901>): static u64Cge: bool := u64A >= u64B
	<.main+8693 @0668f1> : 21 c8 42 06                load.m64 <@0642c8> ;u64A
	<.main+8697 @0668f5> : 21 d0 42 06                load.m64 <@0642d0> ;u64B
	<.main+8701 @0668f9> : 48                         clt.u64
	<.main+8702 @0668fa> : 0b                         not.b32
	<.main+8703 @0668fb> : 1f 70 43 06 00             load.ref <@064370> ;u64Cge
	<.main+8708 @066900> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:237: (9 bytes: <.main+8709 @066901> - <.main+8718 @06690a>): static f32A: float32 := a
	<.main+8709 @066901> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8714 @066906> : 24 78 43 06                store.m32 <@064378> ;f32A
	cmplStd/test/lang/useOperator.ci:238: (9 bytes: <.main+8718 @06690a> - <.main+8727 @066913>): static f32B: float32 := b
	<.main+8718 @06690a> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8723 @06690f> : 24 80 43 06                store.m32 <@064380> ;f32B
	cmplStd/test/lang/useOperator.ci:239: (8 bytes: <.main+8727 @066913> - <.main+8735 @06691b>): static f32Pls: float32 := +f32B
	<.main+8727 @066913> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8731 @066917> : 24 88 43 06                store.m32 <@064388> ;f32Pls
	cmplStd/test/lang/useOperator.ci:240: (9 bytes: <.main+8735 @06691b> - <.main+8744 @066924>): static f32Neg: float32 := -f32B
	<.main+8735 @06691b> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8739 @06691f> : 70                         neg.f32
	<.main+8740 @066920> : 24 90 43 06                store.m32 <@064390> ;f32Neg
	cmplStd/test/lang/useOperator.ci:242: (13 bytes: <.main+8744 @066924> - <.main+8757 @066931>): static f32Add: float32 := f32A + f32B
	<.main+8744 @066924> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8748 @066928> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8752 @06692c> : 71                         add.f32
	<.main+8753 @06692d> : 24 98 43 06                store.m32 <@064398> ;f32Add
	cmplStd/test/lang/useOperator.ci:243: (13 bytes: <.main+8757 @066931> - <.main+8770 @06693e>): static f32Sub: float32 := f32A - f32B
	<.main+8757 @066931> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8761 @066935> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8765 @066939> : 72                         sub.f32
	<.main+8766 @06693a> : 24 a0 43 06                store.m32 <@0643a0> ;f32Sub
	cmplStd/test/lang/useOperator.ci:244: (13 bytes: <.main+8770 @06693e> - <.main+8783 @06694b>): static f32Mul: float32 := f32A * f32B
	<.main+8770 @06693e> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8774 @066942> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8778 @066946> : 73                         mul.f32
	<.main+8779 @066947> : 24 a8 43 06                store.m32 <@0643a8> ;f32Mul
	cmplStd/test/lang/useOperator.ci:245: (13 bytes: <.main+8783 @06694b> - <.main+8796 @066958>): static f32Div: float32 := f32A / f32B
	<.main+8783 @06694b> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8787 @06694f> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8791 @066953> : 74                         div.f32
	<.main+8792 @066954> : 24 b0 43 06                store.m32 <@0643b0> ;f32Div
	cmplStd/test/lang/useOperator.ci:246: (13 bytes: <.main+8796 @066958> - <.main+8809 @066965>): static f32Mod: float32 := f32A % f32B
	<.main+8796 @066958> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8800 @06695c> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8804 @066960> : 75                         mod.f32
	<.main+8805 @066961> : 24 b8 43 06                store.m32 <@0643b8> ;f32Mod
	cmplStd/test/lang/useOperator.ci:252: (12 bytes: <.main+8809 @066965> - <.main+8821 @066971>): static f32Not: bool := !(f32B)
	<.main+8809 @066965> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8813 @066969> : 7c                         f32.2bool
	<.main+8814 @06696a> : 0b                         not.b32
	<.main+8815 @06696b> : 1f c0 43 06 00             load.ref <@0643c0> ;f32Not
	<.main+8820 @066970> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:253: (15 bytes: <.main+8821 @066971> - <.main+8836 @066980>): static f32Ceq: bool := f32A == f32B
	<.main+8821 @066971> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8825 @066975> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8829 @066979> : 77                         ceq.f32
	<.main+8830 @06697a> : 1f c8 43 06 00             load.ref <@0643c8> ;f32Ceq
	<.main+8835 @06697f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:254: (16 bytes: <.main+8836 @066980> - <.main+8852 @066990>): static f32Cne: bool := f32A != f32B
	<.main+8836 @066980> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8840 @066984> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8844 @066988> : 77                         ceq.f32
	<.main+8845 @066989> : 0b                         not.b32
	<.main+8846 @06698a> : 1f d0 43 06 00             load.ref <@0643d0> ;f32Cne
	<.main+8851 @06698f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:255: (15 bytes: <.main+8852 @066990> - <.main+8867 @06699f>): static f32Clt: bool := f32A < f32B
	<.main+8852 @066990> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8856 @066994> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8860 @066998> : 78                         clt.f32
	<.main+8861 @066999> : 1f d8 43 06 00             load.ref <@0643d8> ;f32Clt
	<.main+8866 @06699e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:256: (16 bytes: <.main+8867 @06699f> - <.main+8883 @0669af>): static f32Cle: bool := f32A <= f32B
	<.main+8867 @06699f> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8871 @0669a3> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8875 @0669a7> : 79                         cgt.f32
	<.main+8876 @0669a8> : 0b                         not.b32
	<.main+8877 @0669a9> : 1f e0 43 06 00             load.ref <@0643e0> ;f32Cle
	<.main+8882 @0669ae> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:257: (15 bytes: <.main+8883 @0669af> - <.main+8898 @0669be>): static f32Cgt: bool := f32A > f32B
	<.main+8883 @0669af> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8887 @0669b3> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8891 @0669b7> : 79                         cgt.f32
	<.main+8892 @0669b8> : 1f e8 43 06 00             load.ref <@0643e8> ;f32Cgt
	<.main+8897 @0669bd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:258: (16 bytes: <.main+8898 @0669be> - <.main+8914 @0669ce>): static f32Cge: bool := f32A >= f32B
	<.main+8898 @0669be> : 20 78 43 06                load.m32 <@064378> ;f32A
	<.main+8902 @0669c2> : 20 80 43 06                load.m32 <@064380> ;f32B
	<.main+8906 @0669c6> : 78                         clt.f32
	<.main+8907 @0669c7> : 0b                         not.b32
	<.main+8908 @0669c8> : 1f f0 43 06 00             load.ref <@0643f0> ;f32Cge
	<.main+8913 @0669cd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:260: (13 bytes: <.main+8914 @0669ce> - <.main+8927 @0669db>): static f64A: float64 := a
	<.main+8914 @0669ce> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8923 @0669d7> : 23 f8 43 06                store.m64 <@0643f8> ;f64A
	cmplStd/test/lang/useOperator.ci:261: (13 bytes: <.main+8927 @0669db> - <.main+8940 @0669e8>): static f64B: float64 := b
	<.main+8927 @0669db> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8936 @0669e4> : 23 00 44 06                store.m64 <@064400> ;f64B
	cmplStd/test/lang/useOperator.ci:262: (8 bytes: <.main+8940 @0669e8> - <.main+8948 @0669f0>): static f64Pls: float64 := +f64B
	<.main+8940 @0669e8> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+8944 @0669ec> : 23 08 44 06                store.m64 <@064408> ;f64Pls
	cmplStd/test/lang/useOperator.ci:263: (9 bytes: <.main+8948 @0669f0> - <.main+8957 @0669f9>): static f64Neg: float64 := -f64B
	<.main+8948 @0669f0> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+8952 @0669f4> : 80                         neg.f64
	<.main+8953 @0669f5> : 23 10 44 06                store.m64 <@064410> ;f64Neg
	cmplStd/test/lang/useOperator.ci:265: (13 bytes: <.main+8957 @0669f9> - <.main+8970 @066a06>): static f64Add: float64 := f64A + f64B
	<.main+8957 @0669f9> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+8961 @0669fd> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+8965 @066a01> : 81                         add.f64
	<.main+8966 @066a02> : 23 18 44 06                store.m64 <@064418> ;f64Add
	cmplStd/test/lang/useOperator.ci:266: (13 bytes: <.main+8970 @066a06> - <.main+8983 @066a13>): static f64Sub: float64 := f64A - f64B
	<.main+8970 @066a06> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+8974 @066a0a> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+8978 @066a0e> : 82                         sub.f64
	<.main+8979 @066a0f> : 23 20 44 06                store.m64 <@064420> ;f64Sub
	cmplStd/test/lang/useOperator.ci:267: (13 bytes: <.main+8983 @066a13> - <.main+8996 @066a20>): static f64Mul: float64 := f64A * f64B
	<.main+8983 @066a13> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+8987 @066a17> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+8991 @066a1b> : 83                         mul.f64
	<.main+8992 @066a1c> : 23 28 44 06                store.m64 <@064428> ;f64Mul
	cmplStd/test/lang/useOperator.ci:268: (13 bytes: <.main+8996 @066a20> - <.main+9009 @066a2d>): static f64Div: float64 := f64A / f64B
	<.main+8996 @066a20> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9000 @066a24> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9004 @066a28> : 84                         div.f64
	<.main+9005 @066a29> : 23 30 44 06                store.m64 <@064430> ;f64Div
	cmplStd/test/lang/useOperator.ci:269: (13 bytes: <.main+9009 @066a2d> - <.main+9022 @066a3a>): static f64Mod: float64 := f64A % f64B
	<.main+9009 @066a2d> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9013 @066a31> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9017 @066a35> : 85                         mod.f64
	<.main+9018 @066a36> : 23 38 44 06                store.m64 <@064438> ;f64Mod
	cmplStd/test/lang/useOperator.ci:275: (12 bytes: <.main+9022 @066a3a> - <.main+9034 @066a46>): static f64Not: bool := !(f64B)
	<.main+9022 @066a3a> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9026 @066a3e> : 8d                         f64.2bool
	<.main+9027 @066a3f> : 0b                         not.b32
	<.main+9028 @066a40> : 1f 40 44 06 00             load.ref <@064440> ;f64Not
	<.main+9033 @066a45> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:276: (15 bytes: <.main+9034 @066a46> - <.main+9049 @066a55>): static f64Ceq: bool := f64A == f64B
	<.main+9034 @066a46> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9038 @066a4a> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9042 @066a4e> : 87                         ceq.f64
	<.main+9043 @066a4f> : 1f 48 44 06 00             load.ref <@064448> ;f64Ceq
	<.main+9048 @066a54> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:277: (16 bytes: <.main+9049 @066a55> - <.main+9065 @066a65>): static f64Cne: bool := f64A != f64B
	<.main+9049 @066a55> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9053 @066a59> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9057 @066a5d> : 87                         ceq.f64
	<.main+9058 @066a5e> : 0b                         not.b32
	<.main+9059 @066a5f> : 1f 50 44 06 00             load.ref <@064450> ;f64Cne
	<.main+9064 @066a64> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:278: (15 bytes: <.main+9065 @066a65> - <.main+9080 @066a74>): static f64Clt: bool := f64A < f64B
	<.main+9065 @066a65> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9069 @066a69> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9073 @066a6d> : 88                         clt.f64
	<.main+9074 @066a6e> : 1f 58 44 06 00             load.ref <@064458> ;f64Clt
	<.main+9079 @066a73> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:279: (16 bytes: <.main+9080 @066a74> - <.main+9096 @066a84>): static f64Cle: bool := f64A <= f64B
	<.main+9080 @066a74> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9084 @066a78> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9088 @066a7c> : 89                         cgt.f64
	<.main+9089 @066a7d> : 0b                         not.b32
	<.main+9090 @066a7e> : 1f 60 44 06 00             load.ref <@064460> ;f64Cle
	<.main+9095 @066a83> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:280: (15 bytes: <.main+9096 @066a84> - <.main+9111 @066a93>): static f64Cgt: bool := f64A > f64B
	<.main+9096 @066a84> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9100 @066a88> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9104 @066a8c> : 89                         cgt.f64
	<.main+9105 @066a8d> : 1f 68 44 06 00             load.ref <@064468> ;f64Cgt
	<.main+9110 @066a92> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:281: (16 bytes: <.main+9111 @066a93> - <.main+9127 @066aa3>): static f64Cge: bool := f64A >= f64B
	<.main+9111 @066a93> : 21 f8 43 06                load.m64 <@0643f8> ;f64A
	<.main+9115 @066a97> : 21 00 44 06                load.m64 <@064400> ;f64B
	<.main+9119 @066a9b> : 88                         clt.f64
	<.main+9120 @066a9c> : 0b                         not.b32
	<.main+9121 @066a9d> : 1f 70 44 06 00             load.ref <@064470> ;f64Cge
	<.main+9126 @066aa2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:283: (9 bytes: <.main+9127 @066aa3> - <.main+9136 @066aac>): static ptrA: pointer := null
	<.main+9127 @066aa3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+9132 @066aa8> : 24 78 44 06                store.m32 <@064478> ;ptrA
	cmplStd/test/lang/useOperator.ci:284: (9 bytes: <.main+9136 @066aac> - <.main+9145 @066ab5>): static ptrB: pointer := pointer(shift)
	<.main+9136 @066aac> : 1f e0 3c 06 00             load.ref <@063ce0> ;shift
	<.main+9141 @066ab1> : 24 80 44 06                store.m32 <@064480> ;ptrB
	cmplStd/test/lang/useOperator.ci:299: (15 bytes: <.main+9145 @066ab5> - <.main+9160 @066ac4>): static ptrCeq: bool := ptrA == ptrB
	<.main+9145 @066ab5> : 20 78 44 06                load.m32 <@064478> ;ptrA
	<.main+9149 @066ab9> : 20 80 44 06                load.m32 <@064480> ;ptrB
	<.main+9153 @066abd> : 57                         ceq.i32
	<.main+9154 @066abe> : 1f 88 44 06 00             load.ref <@064488> ;ptrCeq
	<.main+9159 @066ac3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:300: (16 bytes: <.main+9160 @066ac4> - <.main+9176 @066ad4>): static ptrCne: bool := ptrA != ptrB
	<.main+9160 @066ac4> : 20 78 44 06                load.m32 <@064478> ;ptrA
	<.main+9164 @066ac8> : 20 80 44 06                load.m32 <@064480> ;ptrB
	<.main+9168 @066acc> : 57                         ceq.i32
	<.main+9169 @066acd> : 0b                         not.b32
	<.main+9170 @066ace> : 1f 90 44 06 00             load.ref <@064490> ;ptrCne
	<.main+9175 @066ad3> : 2b                         store.i8
	cmplStd/test/lang/stmt.if.ci:26: (5 bytes: <.main+9176 @066ad4> - <.main+9181 @066ad9>): static t: int32 := 0
	<.main+9176 @066ad4> : 19                         load.z32
	<.main+9177 @066ad5> : 24 98 44 06                store.m32 <@064498> ;t
	cmplStd/test/lang/stmt.for.ci:12: (5 bytes: <.main+9181 @066ad9> - <.main+9186 @066ade>): static forIdx: int32
	<.main+9181 @066ad9> : 19                         load.z32
	<.main+9182 @066ada> : 24 a0 44 06                store.m32 <@0644a0> ;forIdx
	cmplStd/test/std/test.math.ci:3: (24 bytes: <.main+9186 @066ade> - <.main+9210 @066af6>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9186 @066ade> : 1a                         load.z64
	<.main+9187 @066adf> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9196 @066ae8> : 1f e0 1b 06 00             load.ref <@061be0> ;Math.floor(x: float64): float64
	<.main+9201 @066aed> : 02                         call
	<.main+9202 @066aee> : 09 f8 ff ff                inc.sp(-8)
	<.main+9206 @066af2> : 23 a8 44 06                store.m64 <@0644a8> ;testMathFloor_1
	cmplStd/test/std/test.math.ci:4: (24 bytes: <.main+9210 @066af6> - <.main+9234 @066b0e>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9210 @066af6> : 1a                         load.z64
	<.main+9211 @066af7> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9220 @066b00> : 1f e0 1b 06 00             load.ref <@061be0> ;Math.floor(x: float64): float64
	<.main+9225 @066b05> : 02                         call
	<.main+9226 @066b06> : 09 f8 ff ff                inc.sp(-8)
	<.main+9230 @066b0a> : 23 b0 44 06                store.m64 <@0644b0> ;testMathFloor_2
	cmplStd/test/std/test.math.ci:5: (24 bytes: <.main+9234 @066b0e> - <.main+9258 @066b26>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9234 @066b0e> : 1a                         load.z64
	<.main+9235 @066b0f> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9244 @066b18> : 1f e0 1b 06 00             load.ref <@061be0> ;Math.floor(x: float64): float64
	<.main+9249 @066b1d> : 02                         call
	<.main+9250 @066b1e> : 09 f8 ff ff                inc.sp(-8)
	<.main+9254 @066b22> : 23 b8 44 06                store.m64 <@0644b8> ;testMathFloor_3
	cmplStd/test/std/test.math.ci:6: (24 bytes: <.main+9258 @066b26> - <.main+9282 @066b3e>): static testMathFloor_4: float64 := Math.floor(-3.200000)
	<.main+9258 @066b26> : 1a                         load.z64
	<.main+9259 @066b27> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9268 @066b30> : 1f e0 1b 06 00             load.ref <@061be0> ;Math.floor(x: float64): float64
	<.main+9273 @066b35> : 02                         call
	<.main+9274 @066b36> : 09 f8 ff ff                inc.sp(-8)
	<.main+9278 @066b3a> : 23 c0 44 06                store.m64 <@0644c0> ;testMathFloor_4
	cmplStd/test/std/test.math.ci:7: (24 bytes: <.main+9282 @066b3e> - <.main+9306 @066b56>): static testMathFloor_5: float64 := Math.floor(-3.500000)
	<.main+9282 @066b3e> : 1a                         load.z64
	<.main+9283 @066b3f> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9292 @066b48> : 1f e0 1b 06 00             load.ref <@061be0> ;Math.floor(x: float64): float64
	<.main+9297 @066b4d> : 02                         call
	<.main+9298 @066b4e> : 09 f8 ff ff                inc.sp(-8)
	<.main+9302 @066b52> : 23 c8 44 06                store.m64 <@0644c8> ;testMathFloor_5
	cmplStd/test/std/test.math.ci:8: (24 bytes: <.main+9306 @066b56> - <.main+9330 @066b6e>): static testMathFloor_6: float64 := Math.floor(-3.600000)
	<.main+9306 @066b56> : 1a                         load.z64
	<.main+9307 @066b57> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9316 @066b60> : 1f e0 1b 06 00             load.ref <@061be0> ;Math.floor(x: float64): float64
	<.main+9321 @066b65> : 02                         call
	<.main+9322 @066b66> : 09 f8 ff ff                inc.sp(-8)
	<.main+9326 @066b6a> : 23 d0 44 06                store.m64 <@0644d0> ;testMathFloor_6
	cmplStd/test/std/test.math.ci:10: (29 bytes: <.main+9330 @066b6e> - <.main+9359 @066b8b>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9330 @066b6e> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9339 @066b77> : 11 00                      dup.x64 sp(0)
	<.main+9341 @066b79> : 1a                         load.z64
	<.main+9342 @066b7a> : 89                         cgt.f64
	<.main+9343 @066b7b> : 11 01                      dup.x64 sp(1)
	<.main+9345 @066b7d> : 1a                         load.z64
	<.main+9346 @066b7e> : 88                         clt.f64
	<.main+9347 @066b7f> : 52                         sub.i32
	<.main+9348 @066b80> : 13 02                      set.x32 sp(2)
	<.main+9350 @066b82> : 09 fc ff ff                inc.sp(-4)
	<.main+9354 @066b86> : 5d                         i32.2f64
	<.main+9355 @066b87> : 23 d8 44 06                store.m64 <@0644d8> ;testMathSign_1F
	cmplStd/test/std/test.math.ci:11: (21 bytes: <.main+9359 @066b8b> - <.main+9380 @066ba0>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9359 @066b8b> : 1a                         load.z64
	<.main+9360 @066b8c> : 11 00                      dup.x64 sp(0)
	<.main+9362 @066b8e> : 1a                         load.z64
	<.main+9363 @066b8f> : 89                         cgt.f64
	<.main+9364 @066b90> : 11 01                      dup.x64 sp(1)
	<.main+9366 @066b92> : 1a                         load.z64
	<.main+9367 @066b93> : 88                         clt.f64
	<.main+9368 @066b94> : 52                         sub.i32
	<.main+9369 @066b95> : 13 02                      set.x32 sp(2)
	<.main+9371 @066b97> : 09 fc ff ff                inc.sp(-4)
	<.main+9375 @066b9b> : 5d                         i32.2f64
	<.main+9376 @066b9c> : 23 e0 44 06                store.m64 <@0644e0> ;testMathSign_2F
	cmplStd/test/std/test.math.ci:12: (29 bytes: <.main+9380 @066ba0> - <.main+9409 @066bbd>): static testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+9380 @066ba0> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9389 @066ba9> : 11 00                      dup.x64 sp(0)
	<.main+9391 @066bab> : 1a                         load.z64
	<.main+9392 @066bac> : 89                         cgt.f64
	<.main+9393 @066bad> : 11 01                      dup.x64 sp(1)
	<.main+9395 @066baf> : 1a                         load.z64
	<.main+9396 @066bb0> : 88                         clt.f64
	<.main+9397 @066bb1> : 52                         sub.i32
	<.main+9398 @066bb2> : 13 02                      set.x32 sp(2)
	<.main+9400 @066bb4> : 09 fc ff ff                inc.sp(-4)
	<.main+9404 @066bb8> : 5d                         i32.2f64
	<.main+9405 @066bb9> : 23 e8 44 06                store.m64 <@0644e8> ;testMathSign_3F
	cmplStd/test/std/test.math.ci:13: (21 bytes: <.main+9409 @066bbd> - <.main+9430 @066bd2>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9409 @066bbd> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9414 @066bc2> : 10 00                      dup.x32 sp(0)
	<.main+9416 @066bc4> : 19                         load.z32
	<.main+9417 @066bc5> : 79                         cgt.f32
	<.main+9418 @066bc6> : 10 01                      dup.x32 sp(1)
	<.main+9420 @066bc8> : 19                         load.z32
	<.main+9421 @066bc9> : 78                         clt.f32
	<.main+9422 @066bca> : 52                         sub.i32
	<.main+9423 @066bcb> : 13 01                      set.x32 sp(1)
	<.main+9425 @066bcd> : 5d                         i32.2f64
	<.main+9426 @066bce> : 23 f0 44 06                store.m64 <@0644f0> ;testMathSign_1f
	cmplStd/test/std/test.math.ci:14: (17 bytes: <.main+9430 @066bd2> - <.main+9447 @066be3>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9430 @066bd2> : 19                         load.z32
	<.main+9431 @066bd3> : 10 00                      dup.x32 sp(0)
	<.main+9433 @066bd5> : 19                         load.z32
	<.main+9434 @066bd6> : 79                         cgt.f32
	<.main+9435 @066bd7> : 10 01                      dup.x32 sp(1)
	<.main+9437 @066bd9> : 19                         load.z32
	<.main+9438 @066bda> : 78                         clt.f32
	<.main+9439 @066bdb> : 52                         sub.i32
	<.main+9440 @066bdc> : 13 01                      set.x32 sp(1)
	<.main+9442 @066bde> : 5d                         i32.2f64
	<.main+9443 @066bdf> : 23 f8 44 06                store.m64 <@0644f8> ;testMathSign_2f
	cmplStd/test/std/test.math.ci:15: (21 bytes: <.main+9447 @066be3> - <.main+9468 @066bf8>): static testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+9447 @066be3> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9452 @066be8> : 10 00                      dup.x32 sp(0)
	<.main+9454 @066bea> : 19                         load.z32
	<.main+9455 @066beb> : 79                         cgt.f32
	<.main+9456 @066bec> : 10 01                      dup.x32 sp(1)
	<.main+9458 @066bee> : 19                         load.z32
	<.main+9459 @066bef> : 78                         clt.f32
	<.main+9460 @066bf0> : 52                         sub.i32
	<.main+9461 @066bf1> : 13 01                      set.x32 sp(1)
	<.main+9463 @066bf3> : 5d                         i32.2f64
	<.main+9464 @066bf4> : 23 00 45 06                store.m64 <@064500> ;testMathSign_3f
	cmplStd/test/std/test.math.ci:17: (32 bytes: <.main+9468 @066bf8> - <.main+9500 @066c18>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9468 @066bf8> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9477 @066c01> : 11 00                      dup.x64 sp(0)
	<.main+9479 @066c03> : 1a                         load.z64
	<.main+9480 @066c04> : 88                         clt.f64
	<.main+9481 @066c05> : 06 0b 00 00                jz <.main+9492 @066c10>
	<.main+9485 @066c09> : 11 00                      dup.x64 sp(0)
	<.main+9487 @066c0b> : 80                         neg.f64
	<.main+9488 @066c0c> : 04 06 00 00                jmp <.main+9494 @066c12>
	<.main+9492 @066c10> : 11 00                      dup.x64 sp(0)
	<.main+9494 @066c12> : 14 02                      set.x64 sp(2)
	<.main+9496 @066c14> : 23 08 45 06                store.m64 <@064508> ;testMathAbs_1F
	cmplStd/test/std/test.math.ci:18: (24 bytes: <.main+9500 @066c18> - <.main+9524 @066c30>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9500 @066c18> : 1a                         load.z64
	<.main+9501 @066c19> : 11 00                      dup.x64 sp(0)
	<.main+9503 @066c1b> : 1a                         load.z64
	<.main+9504 @066c1c> : 88                         clt.f64
	<.main+9505 @066c1d> : 06 0b 00 00                jz <.main+9516 @066c28>
	<.main+9509 @066c21> : 11 00                      dup.x64 sp(0)
	<.main+9511 @066c23> : 80                         neg.f64
	<.main+9512 @066c24> : 04 06 00 00                jmp <.main+9518 @066c2a>
	<.main+9516 @066c28> : 11 00                      dup.x64 sp(0)
	<.main+9518 @066c2a> : 14 02                      set.x64 sp(2)
	<.main+9520 @066c2c> : 23 10 45 06                store.m64 <@064510> ;testMathAbs_2F
	cmplStd/test/std/test.math.ci:19: (32 bytes: <.main+9524 @066c30> - <.main+9556 @066c50>): static testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+9524 @066c30> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9533 @066c39> : 11 00                      dup.x64 sp(0)
	<.main+9535 @066c3b> : 1a                         load.z64
	<.main+9536 @066c3c> : 88                         clt.f64
	<.main+9537 @066c3d> : 06 0b 00 00                jz <.main+9548 @066c48>
	<.main+9541 @066c41> : 11 00                      dup.x64 sp(0)
	<.main+9543 @066c43> : 80                         neg.f64
	<.main+9544 @066c44> : 04 06 00 00                jmp <.main+9550 @066c4a>
	<.main+9548 @066c48> : 11 00                      dup.x64 sp(0)
	<.main+9550 @066c4a> : 14 02                      set.x64 sp(2)
	<.main+9552 @066c4c> : 23 18 45 06                store.m64 <@064518> ;testMathAbs_3F
	cmplStd/test/std/test.math.ci:20: (29 bytes: <.main+9556 @066c50> - <.main+9585 @066c6d>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9556 @066c50> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9561 @066c55> : 10 00                      dup.x32 sp(0)
	<.main+9563 @066c57> : 19                         load.z32
	<.main+9564 @066c58> : 78                         clt.f32
	<.main+9565 @066c59> : 06 0b 00 00                jz <.main+9576 @066c64>
	<.main+9569 @066c5d> : 10 00                      dup.x32 sp(0)
	<.main+9571 @066c5f> : 70                         neg.f32
	<.main+9572 @066c60> : 04 06 00 00                jmp <.main+9578 @066c66>
	<.main+9576 @066c64> : 10 00                      dup.x32 sp(0)
	<.main+9578 @066c66> : 13 01                      set.x32 sp(1)
	<.main+9580 @066c68> : 7d                         f32.2f64
	<.main+9581 @066c69> : 23 20 45 06                store.m64 <@064520> ;testMathAbs_1f
	cmplStd/test/std/test.math.ci:21: (25 bytes: <.main+9585 @066c6d> - <.main+9610 @066c86>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9585 @066c6d> : 19                         load.z32
	<.main+9586 @066c6e> : 10 00                      dup.x32 sp(0)
	<.main+9588 @066c70> : 19                         load.z32
	<.main+9589 @066c71> : 78                         clt.f32
	<.main+9590 @066c72> : 06 0b 00 00                jz <.main+9601 @066c7d>
	<.main+9594 @066c76> : 10 00                      dup.x32 sp(0)
	<.main+9596 @066c78> : 70                         neg.f32
	<.main+9597 @066c79> : 04 06 00 00                jmp <.main+9603 @066c7f>
	<.main+9601 @066c7d> : 10 00                      dup.x32 sp(0)
	<.main+9603 @066c7f> : 13 01                      set.x32 sp(1)
	<.main+9605 @066c81> : 7d                         f32.2f64
	<.main+9606 @066c82> : 23 28 45 06                store.m64 <@064528> ;testMathAbs_2f
	cmplStd/test/std/test.math.ci:22: (29 bytes: <.main+9610 @066c86> - <.main+9639 @066ca3>): static testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+9610 @066c86> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9615 @066c8b> : 10 00                      dup.x32 sp(0)
	<.main+9617 @066c8d> : 19                         load.z32
	<.main+9618 @066c8e> : 78                         clt.f32
	<.main+9619 @066c8f> : 06 0b 00 00                jz <.main+9630 @066c9a>
	<.main+9623 @066c93> : 10 00                      dup.x32 sp(0)
	<.main+9625 @066c95> : 70                         neg.f32
	<.main+9626 @066c96> : 04 06 00 00                jmp <.main+9632 @066c9c>
	<.main+9630 @066c9a> : 10 00                      dup.x32 sp(0)
	<.main+9632 @066c9c> : 13 01                      set.x32 sp(1)
	<.main+9634 @066c9e> : 7d                         f32.2f64
	<.main+9635 @066c9f> : 23 30 45 06                store.m64 <@064530> ;testMathAbs_3f
	cmplStd/test/std/test.math.ci:24: (38 bytes: <.main+9639 @066ca3> - <.main+9677 @066cc9>): static testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+9639 @066ca3> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9644 @066ca8> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9649 @066cad> : 10 01                      dup.x32 sp(1)
	<.main+9651 @066caf> : 10 01                      dup.x32 sp(1)
	<.main+9653 @066cb1> : 78                         clt.f32
	<.main+9654 @066cb2> : 06 0a 00 00                jz <.main+9664 @066cbc>
	<.main+9658 @066cb6> : 10 01                      dup.x32 sp(1)
	<.main+9660 @066cb8> : 04 06 00 00                jmp <.main+9666 @066cbe>
	<.main+9664 @066cbc> : 10 00                      dup.x32 sp(0)
	<.main+9666 @066cbe> : 13 02                      set.x32 sp(2)
	<.main+9668 @066cc0> : 09 fc ff ff                inc.sp(-4)
	<.main+9672 @066cc4> : 7d                         f32.2f64
	<.main+9673 @066cc5> : 23 38 45 06                store.m64 <@064538> ;testMathMin_1f
	cmplStd/test/std/test.math.ci:25: (38 bytes: <.main+9677 @066cc9> - <.main+9715 @066cef>): static testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+9677 @066cc9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9682 @066cce> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9687 @066cd3> : 10 01                      dup.x32 sp(1)
	<.main+9689 @066cd5> : 10 01                      dup.x32 sp(1)
	<.main+9691 @066cd7> : 79                         cgt.f32
	<.main+9692 @066cd8> : 06 0a 00 00                jz <.main+9702 @066ce2>
	<.main+9696 @066cdc> : 10 01                      dup.x32 sp(1)
	<.main+9698 @066cde> : 04 06 00 00                jmp <.main+9704 @066ce4>
	<.main+9702 @066ce2> : 10 00                      dup.x32 sp(0)
	<.main+9704 @066ce4> : 13 02                      set.x32 sp(2)
	<.main+9706 @066ce6> : 09 fc ff ff                inc.sp(-4)
	<.main+9710 @066cea> : 7d                         f32.2f64
	<.main+9711 @066ceb> : 23 40 45 06                store.m64 <@064540> ;testMathMax_2f
	cmplStd/test/std/test.math.ci:26: (45 bytes: <.main+9715 @066cef> - <.main+9760 @066d1c>): static testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+9715 @066cef> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9724 @066cf8> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9733 @066d01> : 11 02                      dup.x64 sp(2)
	<.main+9735 @066d03> : 11 02                      dup.x64 sp(2)
	<.main+9737 @066d05> : 88                         clt.f64
	<.main+9738 @066d06> : 06 0a 00 00                jz <.main+9748 @066d10>
	<.main+9742 @066d0a> : 11 02                      dup.x64 sp(2)
	<.main+9744 @066d0c> : 04 06 00 00                jmp <.main+9750 @066d12>
	<.main+9748 @066d10> : 11 00                      dup.x64 sp(0)
	<.main+9750 @066d12> : 14 04                      set.x64 sp(4)
	<.main+9752 @066d14> : 09 f8 ff ff                inc.sp(-8)
	<.main+9756 @066d18> : 23 48 45 06                store.m64 <@064548> ;testMathMin_1F
	cmplStd/test/std/test.math.ci:27: (45 bytes: <.main+9760 @066d1c> - <.main+9805 @066d49>): static testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+9760 @066d1c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9769 @066d25> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9778 @066d2e> : 11 02                      dup.x64 sp(2)
	<.main+9780 @066d30> : 11 02                      dup.x64 sp(2)
	<.main+9782 @066d32> : 89                         cgt.f64
	<.main+9783 @066d33> : 06 0a 00 00                jz <.main+9793 @066d3d>
	<.main+9787 @066d37> : 11 02                      dup.x64 sp(2)
	<.main+9789 @066d39> : 04 06 00 00                jmp <.main+9795 @066d3f>
	<.main+9793 @066d3d> : 11 00                      dup.x64 sp(0)
	<.main+9795 @066d3f> : 14 04                      set.x64 sp(4)
	<.main+9797 @066d41> : 09 f8 ff ff                inc.sp(-8)
	<.main+9801 @066d45> : 23 50 45 06                store.m64 <@064550> ;testMathMax_2F
	cmplStd/test/std/test.math.ci:29: (27 bytes: <.main+9805 @066d49> - <.main+9832 @066d64>): static testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9805 @066d49> : 19                         load.z32
	<.main+9806 @066d4a> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9811 @066d4f> : 19                         load.z32
	<.main+9812 @066d50> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9817 @066d55> : 1f 38 1c 06 00             load.ref <@061c38> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9822 @066d5a> : 02                         call
	<.main+9823 @066d5b> : 09 f4 ff ff                inc.sp(-12)
	<.main+9827 @066d5f> : 7d                         f32.2f64
	<.main+9828 @066d60> : 23 58 45 06                store.m64 <@064558> ;testMathClamp_1f
	cmplStd/test/std/test.math.ci:30: (34 bytes: <.main+9832 @066d64> - <.main+9866 @066d86>): static testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9832 @066d64> : 1a                         load.z64
	<.main+9833 @066d65> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9842 @066d6e> : 1a                         load.z64
	<.main+9843 @066d6f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9852 @066d78> : 1f 58 1c 06 00             load.ref <@061c58> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9857 @066d7d> : 02                         call
	<.main+9858 @066d7e> : 09 e8 ff ff                inc.sp(-24)
	<.main+9862 @066d82> : 23 60 45 06                store.m64 <@064560> ;testMathClamp_1F
	cmplStd/test/std/test.math.ci:32: (25 bytes: <.main+9866 @066d86> - <.main+9891 @066d9f>): static testMathLerp_1f: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9866 @066d86> : 19                         load.z32
	<.main+9867 @066d87> : 10 00                      dup.x32 sp(0)
	<.main+9869 @066d89> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9874 @066d8e> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9879 @066d93> : 10 03                      dup.x32 sp(3)
	<.main+9881 @066d95> : 72                         sub.f32
	<.main+9882 @066d96> : 73                         mul.f32
	<.main+9883 @066d97> : 71                         add.f32
	<.main+9884 @066d98> : 13 01                      set.x32 sp(1)
	<.main+9886 @066d9a> : 7d                         f32.2f64
	<.main+9887 @066d9b> : 23 68 45 06                store.m64 <@064568> ;testMathLerp_1f
	cmplStd/test/std/test.math.ci:33: (32 bytes: <.main+9891 @066d9f> - <.main+9923 @066dbf>): static testMathLerp_1F: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9891 @066d9f> : 1a                         load.z64
	<.main+9892 @066da0> : 11 00                      dup.x64 sp(0)
	<.main+9894 @066da2> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9903 @066dab> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9912 @066db4> : 11 06                      dup.x64 sp(6)
	<.main+9914 @066db6> : 82                         sub.f64
	<.main+9915 @066db7> : 83                         mul.f64
	<.main+9916 @066db8> : 81                         add.f64
	<.main+9917 @066db9> : 14 02                      set.x64 sp(2)
	<.main+9919 @066dbb> : 23 70 45 06                store.m64 <@064570> ;testMathLerp_1F
	cmplStd/test/std/test.math.ci:35: (64 bytes: <.main+9923 @066dbf> - <.main+9987 @066dff>): static testMathSmooth_1f: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+9923 @066dbf> : 19                         load.z32
	<.main+9924 @066dc0> : 19                         load.z32
	<.main+9925 @066dc1> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9930 @066dc6> : 10 02                      dup.x32 sp(2)
	<.main+9932 @066dc8> : 72                         sub.f32
	<.main+9933 @066dc9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9938 @066dce> : 10 03                      dup.x32 sp(3)
	<.main+9940 @066dd0> : 72                         sub.f32
	<.main+9941 @066dd1> : 74                         div.f32
	<.main+9942 @066dd2> : 19                         load.z32
	<.main+9943 @066dd3> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9948 @066dd8> : 1f 38 1c 06 00             load.ref <@061c38> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9953 @066ddd> : 02                         call
	<.main+9954 @066dde> : 09 f4 ff ff                inc.sp(-12)
	<.main+9958 @066de2> : 10 00                      dup.x32 sp(0)
	<.main+9960 @066de4> : 10 01                      dup.x32 sp(1)
	<.main+9962 @066de6> : 73                         mul.f32
	<.main+9963 @066de7> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9968 @066dec> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9973 @066df1> : 10 03                      dup.x32 sp(3)
	<.main+9975 @066df3> : 73                         mul.f32
	<.main+9976 @066df4> : 72                         sub.f32
	<.main+9977 @066df5> : 73                         mul.f32
	<.main+9978 @066df6> : 13 01                      set.x32 sp(1)
	<.main+9980 @066df8> : 13 01                      set.x32 sp(1)
	<.main+9982 @066dfa> : 7d                         f32.2f64
	<.main+9983 @066dfb> : 23 78 45 06                store.m64 <@064578> ;testMathSmooth_1f
	cmplStd/test/std/test.math.ci:36: (82 bytes: <.main+9987 @066dff> - <.main+10069 @066e51>): static testMathSmooth_1F: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+9987 @066dff> : 1b                         load.z128
	<.main+9988 @066e00> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9997 @066e09> : 11 04                      dup.x64 sp(4)
	<.main+9999 @066e0b> : 82                         sub.f64
	<.main+10000 @066e0c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10009 @066e15>: 11 06                      dup.x64 sp(6)
	<.main+10011 @066e17>: 82                         sub.f64
	<.main+10012 @066e18>: 84                         div.f64
	<.main+10013 @066e19>: 1a                         load.z64
	<.main+10014 @066e1a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10023 @066e23>: 1f 58 1c 06 00             load.ref <@061c58> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+10028 @066e28>: 02                         call
	<.main+10029 @066e29>: 09 e8 ff ff                inc.sp(-24)
	<.main+10033 @066e2d>: 11 00                      dup.x64 sp(0)
	<.main+10035 @066e2f>: 11 02                      dup.x64 sp(2)
	<.main+10037 @066e31>: 83                         mul.f64
	<.main+10038 @066e32>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10047 @066e3b>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10056 @066e44>: 11 06                      dup.x64 sp(6)
	<.main+10058 @066e46>: 83                         mul.f64
	<.main+10059 @066e47>: 82                         sub.f64
	<.main+10060 @066e48>: 83                         mul.f64
	<.main+10061 @066e49>: 14 02                      set.x64 sp(2)
	<.main+10063 @066e4b>: 14 02                      set.x64 sp(2)
	<.main+10065 @066e4d>: 23 80 45 06                store.m64 <@064580> ;testMathSmooth_1F
	cmplStd/test/std/test.math.ci:38: (25 bytes: <.main+10069 @066e51> - <.main+10094 @066e6a>): static testMathMin_nan: float64 := Math.min()
	<.main+10069 @066e51>: 19                         load.z32
	<.main+10070 @066e52>: 0a 04 00 00                load.sp(+4)
	<.main+10074 @066e56>: 1a                         load.z64
	<.main+10075 @066e57>: 11 02                      dup.x64 sp(2)
	<.main+10077 @066e59>: 1f 78 1c 06 00             load.ref <@061c78> ;Math.min(data: float64[]): float64
	<.main+10082 @066e5e>: 02                         call
	<.main+10083 @066e5f>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10086 @066e62>: 09 f0 ff ff                inc.sp(-16)
	<.main+10090 @066e66>: 23 88 45 06                store.m64 <@064588> ;testMathMin_nan
	cmplStd/test/std/test.math.ci:39: (110 bytes: <.main+10094 @066e6a> - <.main+10204 @066ed8>): static testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10094 @066e6a>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10103 @066e73>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10112 @066e7c>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10121 @066e85>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10130 @066e8e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10139 @066e97>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10148 @066ea0>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10157 @066ea9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10166 @066eb2>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10175 @066ebb>: 1c 09 00 00 00             load.c32 9
	<.main+10180 @066ec0>: 0a 04 00 00                load.sp(+4)
	<.main+10184 @066ec4>: 1a                         load.z64
	<.main+10185 @066ec5>: 11 02                      dup.x64 sp(2)
	<.main+10187 @066ec7>: 1f 78 1c 06 00             load.ref <@061c78> ;Math.min(data: float64[]): float64
	<.main+10192 @066ecc>: 02                         call
	<.main+10193 @066ecd>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10196 @066ed0>: 09 a8 ff ff                inc.sp(-88)
	<.main+10200 @066ed4>: 23 90 45 06                store.m64 <@064590> ;testMathMin_1
	cmplStd/test/std/test.math.ci:40: (25 bytes: <.main+10204 @066ed8> - <.main+10229 @066ef1>): static testMathMax_nan: float64 := Math.max()
	<.main+10204 @066ed8>: 19                         load.z32
	<.main+10205 @066ed9>: 0a 04 00 00                load.sp(+4)
	<.main+10209 @066edd>: 1a                         load.z64
	<.main+10210 @066ede>: 11 02                      dup.x64 sp(2)
	<.main+10212 @066ee0>: 1f c8 1c 06 00             load.ref <@061cc8> ;Math.max(data: float64[]): float64
	<.main+10217 @066ee5>: 02                         call
	<.main+10218 @066ee6>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10221 @066ee9>: 09 f0 ff ff                inc.sp(-16)
	<.main+10225 @066eed>: 23 98 45 06                store.m64 <@064598> ;testMathMax_nan
	cmplStd/test/std/test.math.ci:41: (110 bytes: <.main+10229 @066ef1> - <.main+10339 @066f5f>): static testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10229 @066ef1>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10238 @066efa>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10247 @066f03>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10256 @066f0c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10265 @066f15>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10274 @066f1e>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10283 @066f27>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10292 @066f30>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10301 @066f39>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10310 @066f42>: 1c 09 00 00 00             load.c32 9
	<.main+10315 @066f47>: 0a 04 00 00                load.sp(+4)
	<.main+10319 @066f4b>: 1a                         load.z64
	<.main+10320 @066f4c>: 11 02                      dup.x64 sp(2)
	<.main+10322 @066f4e>: 1f c8 1c 06 00             load.ref <@061cc8> ;Math.max(data: float64[]): float64
	<.main+10327 @066f53>: 02                         call
	<.main+10328 @066f54>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10331 @066f57>: 09 a8 ff ff                inc.sp(-88)
	<.main+10335 @066f5b>: 23 a0 45 06                store.m64 <@0645a0> ;testMathMax_9
	cmplStd/test/std/test.math.ci:43: (25 bytes: <.main+10339 @066f5f> - <.main+10364 @066f78>): static testMathSum_0: float64 := Math.sum()
	<.main+10339 @066f5f>: 19                         load.z32
	<.main+10340 @066f60>: 0a 04 00 00                load.sp(+4)
	<.main+10344 @066f64>: 1a                         load.z64
	<.main+10345 @066f65>: 11 02                      dup.x64 sp(2)
	<.main+10347 @066f67>: 1f 18 1d 06 00             load.ref <@061d18> ;Math.sum(data: float64[]): float64
	<.main+10352 @066f6c>: 02                         call
	<.main+10353 @066f6d>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10356 @066f70>: 09 f0 ff ff                inc.sp(-16)
	<.main+10360 @066f74>: 23 a8 45 06                store.m64 <@0645a8> ;testMathSum_0
	cmplStd/test/std/test.math.ci:44: (38 bytes: <.main+10364 @066f78> - <.main+10402 @066f9e>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10364 @066f78>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10373 @066f81>: 1c 01 00 00 00             load.c32 1
	<.main+10378 @066f86>: 0a 04 00 00                load.sp(+4)
	<.main+10382 @066f8a>: 1a                         load.z64
	<.main+10383 @066f8b>: 11 02                      dup.x64 sp(2)
	<.main+10385 @066f8d>: 1f 18 1d 06 00             load.ref <@061d18> ;Math.sum(data: float64[]): float64
	<.main+10390 @066f92>: 02                         call
	<.main+10391 @066f93>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10394 @066f96>: 09 e8 ff ff                inc.sp(-24)
	<.main+10398 @066f9a>: 23 b0 45 06                store.m64 <@0645b0> ;testMathSum_1
	cmplStd/test/std/test.math.ci:45: (47 bytes: <.main+10402 @066f9e> - <.main+10449 @066fcd>): static testMathSum_3: float64 := Math.sum(1, 2)
	<.main+10402 @066f9e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10411 @066fa7>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10420 @066fb0>: 1c 02 00 00 00             load.c32 2
	<.main+10425 @066fb5>: 0a 04 00 00                load.sp(+4)
	<.main+10429 @066fb9>: 1a                         load.z64
	<.main+10430 @066fba>: 11 02                      dup.x64 sp(2)
	<.main+10432 @066fbc>: 1f 18 1d 06 00             load.ref <@061d18> ;Math.sum(data: float64[]): float64
	<.main+10437 @066fc1>: 02                         call
	<.main+10438 @066fc2>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10441 @066fc5>: 09 e0 ff ff                inc.sp(-32)
	<.main+10445 @066fc9>: 23 b8 45 06                store.m64 <@0645b8> ;testMathSum_3
	cmplStd/test/std/test.math.ci:46: (119 bytes: <.main+10449 @066fcd> - <.main+10568 @067044>): static testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+10449 @066fcd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10458 @066fd6>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10467 @066fdf>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10476 @066fe8>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10485 @066ff1>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10494 @066ffa>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10503 @067003>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10512 @06700c>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10521 @067015>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10530 @06701e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10539 @067027>: 1c 0a 00 00 00             load.c32 10
	<.main+10544 @06702c>: 0a 04 00 00                load.sp(+4)
	<.main+10548 @067030>: 1a                         load.z64
	<.main+10549 @067031>: 11 02                      dup.x64 sp(2)
	<.main+10551 @067033>: 1f 18 1d 06 00             load.ref <@061d18> ;Math.sum(data: float64[]): float64
	<.main+10556 @067038>: 02                         call
	<.main+10557 @067039>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10560 @06703c>: 09 a0 ff ff                inc.sp(-96)
	<.main+10564 @067040>: 23 c0 45 06                store.m64 <@0645c0> ;testMathSum_55
	cmplStd/test/std/test.math.ci:48: (13 bytes: <.main+10568 @067044> - <.main+10581 @067051>): static testMathEval_x: float64 := 10
	<.main+10568 @067044>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10577 @06704d>: 23 c8 45 06                store.m64 <@0645c8> ;testMathEval_x
	cmplStd/test/std/test.math.ci:49: (29 bytes: <.main+10581 @067051> - <.main+10610 @06706e>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10581 @067051>: 19                         load.z32
	<.main+10582 @067052>: 0a 04 00 00                load.sp(+4)
	<.main+10586 @067056>: 1a                         load.z64
	<.main+10587 @067057>: 21 c8 45 06                load.m64 <@0645c8> ;testMathEval_x
	<.main+10591 @06705b>: 11 04                      dup.x64 sp(4)
	<.main+10593 @06705d>: 1f 58 1d 06 00             load.ref <@061d58> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10598 @067062>: 02                         call
	<.main+10599 @067063>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10602 @067066>: 09 e8 ff ff                inc.sp(-24)
	<.main+10606 @06706a>: 23 d0 45 06                store.m64 <@0645d0> ;testMathEval_0
	cmplStd/test/std/test.math.ci:50: (13 bytes: <.main+10610 @06706e> - <.main+10623 @06707b>): static testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+10610 @06706e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10619 @067077>: 23 d8 45 06                store.m64 <@0645d8> ;testMathEval_1
	cmplStd/test/std/test.math.ci:51: (28 bytes: <.main+10623 @06707b> - <.main+10651 @067097>): static testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+10623 @06707b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10632 @067084>: 21 c8 45 06                load.m64 <@0645c8> ;testMathEval_x
	<.main+10636 @067088>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10645 @067091>: 83                         mul.f64
	<.main+10646 @067092>: 81                         add.f64
	<.main+10647 @067093>: 23 e0 45 06                store.m64 <@0645e0> ;testMathEval_2
	cmplStd/test/std/test.math.ci:52: (45 bytes: <.main+10651 @067097> - <.main+10696 @0670c4>): static testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+10651 @067097>: 21 c8 45 06                load.m64 <@0645c8> ;testMathEval_x
	<.main+10655 @06709b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10664 @0670a4>: 11 02                      dup.x64 sp(2)
	<.main+10666 @0670a6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10675 @0670af>: 11 06                      dup.x64 sp(6)
	<.main+10677 @0670b1>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10686 @0670ba>: 83                         mul.f64
	<.main+10687 @0670bb>: 81                         add.f64
	<.main+10688 @0670bc>: 83                         mul.f64
	<.main+10689 @0670bd>: 81                         add.f64
	<.main+10690 @0670be>: 14 02                      set.x64 sp(2)
	<.main+10692 @0670c0>: 23 e8 45 06                store.m64 <@0645e8> ;testMathEval_3
	cmplStd/test/std/test.math.ci:53: (62 bytes: <.main+10696 @0670c4> - <.main+10758 @067102>): static testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10696 @0670c4>: 21 c8 45 06                load.m64 <@0645c8> ;testMathEval_x
	<.main+10700 @0670c8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10709 @0670d1>: 11 02                      dup.x64 sp(2)
	<.main+10711 @0670d3>: 11 04                      dup.x64 sp(4)
	<.main+10713 @0670d5>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10722 @0670de>: 11 02                      dup.x64 sp(2)
	<.main+10724 @0670e0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10733 @0670e9>: 11 06                      dup.x64 sp(6)
	<.main+10735 @0670eb>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10744 @0670f4>: 83                         mul.f64
	<.main+10745 @0670f5>: 81                         add.f64
	<.main+10746 @0670f6>: 83                         mul.f64
	<.main+10747 @0670f7>: 81                         add.f64
	<.main+10748 @0670f8>: 14 02                      set.x64 sp(2)
	<.main+10750 @0670fa>: 83                         mul.f64
	<.main+10751 @0670fb>: 81                         add.f64
	<.main+10752 @0670fc>: 14 02                      set.x64 sp(2)
	<.main+10754 @0670fe>: 23 f0 45 06                store.m64 <@0645f0> ;testMathEval_4
	cmplStd/test/std/test.math.ci:54: (78 bytes: <.main+10758 @067102> - <.main+10836 @067150>): static testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10758 @067102>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10767 @06710b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10776 @067114>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10785 @06711d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10794 @067126>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10803 @06712f>: 1c 05 00 00 00             load.c32 5
	<.main+10808 @067134>: 0a 04 00 00                load.sp(+4)
	<.main+10812 @067138>: 1a                         load.z64
	<.main+10813 @067139>: 21 c8 45 06                load.m64 <@0645c8> ;testMathEval_x
	<.main+10817 @06713d>: 11 04                      dup.x64 sp(4)
	<.main+10819 @06713f>: 1f 58 1d 06 00             load.ref <@061d58> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10824 @067144>: 02                         call
	<.main+10825 @067145>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10828 @067148>: 09 c0 ff ff                inc.sp(-64)
	<.main+10832 @06714c>: 23 f8 45 06                store.m64 <@0645f8> ;testMathEval_5
	cmplStd/test/std/test.math.ci:55: (87 bytes: <.main+10836 @067150> - <.main+10923 @0671a7>): static testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10836 @067150>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10845 @067159>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10854 @067162>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10863 @06716b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10872 @067174>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10881 @06717d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10890 @067186>: 1c 06 00 00 00             load.c32 6
	<.main+10895 @06718b>: 0a 04 00 00                load.sp(+4)
	<.main+10899 @06718f>: 1a                         load.z64
	<.main+10900 @067190>: 21 c8 45 06                load.m64 <@0645c8> ;testMathEval_x
	<.main+10904 @067194>: 11 04                      dup.x64 sp(4)
	<.main+10906 @067196>: 1f 58 1d 06 00             load.ref <@061d58> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10911 @06719b>: 02                         call
	<.main+10912 @06719c>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10915 @06719f>: 09 b8 ff ff                inc.sp(-72)
	<.main+10919 @0671a3>: 23 00 46 06                store.m64 <@064600> ;testMathEval_6
	cmplStd/test/std/test.math.ci:57: (35 bytes: <.main+10923 @0671a7> - <.main+10958 @0671ca>): static testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+10923 @0671a7>: 1a                         load.z64
	<.main+10924 @0671a8>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10933 @0671b1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10942 @0671ba>: 84                         div.f64
	<.main+10943 @0671bb>: 19                         load.z32
	<.main+10944 @0671bc>: 1f 08 1e 06 00             load.ref <@061e08> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10949 @0671c1>: 02                         call
	<.main+10950 @0671c2>: 09 f4 ff ff                inc.sp(-12)
	<.main+10954 @0671c6>: 23 08 46 06                store.m64 <@064608> ;testMathSin_f64
	cmplStd/test/std/test.math.ci:58: (58 bytes: <.main+10958 @0671ca> - <.main+11016 @067204>): static testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+10958 @0671ca>: 1a                         load.z64
	<.main+10959 @0671cb>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10968 @0671d4>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10977 @0671dd>: 84                         div.f64
	<.main+10978 @0671de>: 11 00                      dup.x64 sp(0)
	<.main+10980 @0671e0>: 1a                         load.z64
	<.main+10981 @0671e1>: 88                         clt.f64
	<.main+10982 @0671e2>: 06 0b 00 00                jz <.main+10993 @0671ed>
	<.main+10986 @0671e6>: 11 00                      dup.x64 sp(0)
	<.main+10988 @0671e8>: 80                         neg.f64
	<.main+10989 @0671e9>: 04 06 00 00                jmp <.main+10995 @0671ef>
	<.main+10993 @0671ed>: 11 00                      dup.x64 sp(0)
	<.main+10995 @0671ef>: 14 02                      set.x64 sp(2)
	<.main+10997 @0671f1>: 1c 01 00 00 00             load.c32 1
	<.main+11002 @0671f6>: 1f 08 1e 06 00             load.ref <@061e08> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+11007 @0671fb>: 02                         call
	<.main+11008 @0671fc>: 09 f4 ff ff                inc.sp(-12)
	<.main+11012 @067200>: 23 10 46 06                store.m64 <@064610> ;testMathCos_f64
	cmplStd/test/std/test.math.ci:59: (34 bytes: <.main+11016 @067204> - <.main+11050 @067226>): static testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+11016 @067204>: 1a                         load.z64
	<.main+11017 @067205>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11026 @06720e>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+11035 @067217>: 84                         div.f64
	<.main+11036 @067218>: 1f 58 1f 06 00             load.ref <@061f58> ;Math.tan(arg: float64): float64
	<.main+11041 @06721d>: 02                         call
	<.main+11042 @06721e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11046 @067222>: 23 18 46 06                store.m64 <@064618> ;testMathTan_f64
	cmplStd/test/std/test.math.ci:60: (34 bytes: <.main+11050 @067226> - <.main+11084 @067248>): static testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+11050 @067226>: 1a                         load.z64
	<.main+11051 @067227>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11060 @067230>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11069 @067239>: 84                         div.f64
	<.main+11070 @06723a>: 1f d8 20 06 00             load.ref <@0620d8> ;Math.sinh(x: float64): float64
	<.main+11075 @06723f>: 02                         call
	<.main+11076 @067240>: 09 f8 ff ff                inc.sp(-8)
	<.main+11080 @067244>: 23 20 46 06                store.m64 <@064620> ;testMathSinh_f64
	cmplStd/test/std/test.math.ci:61: (34 bytes: <.main+11084 @067248> - <.main+11118 @06726a>): static testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+11084 @067248>: 1a                         load.z64
	<.main+11085 @067249>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11094 @067252>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11103 @06725b>: 84                         div.f64
	<.main+11104 @06725c>: 1f d0 21 06 00             load.ref <@0621d0> ;Math.cosh(x: float64): float64
	<.main+11109 @067261>: 02                         call
	<.main+11110 @067262>: 09 f8 ff ff                inc.sp(-8)
	<.main+11114 @067266>: 23 28 46 06                store.m64 <@064628> ;testMathCosh_f64
	cmplStd/test/std/test.math.ci:63: (24 bytes: <.main+11118 @06726a> - <.main+11142 @067282>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+11118 @06726a>: 1a                         load.z64
	<.main+11119 @06726b>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11128 @067274>: 1f 20 22 06 00             load.ref <@062220> ;Math.asin(x: float64): float64
	<.main+11133 @067279>: 02                         call
	<.main+11134 @06727a>: 09 f8 ff ff                inc.sp(-8)
	<.main+11138 @06727e>: 23 30 46 06                store.m64 <@064630> ;testMathAsin_f64
	cmplStd/test/std/test.math.ci:64: (44 bytes: <.main+11142 @067282> - <.main+11186 @0672ae>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+11142 @067282>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11151 @06728b>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11160 @067294>: 84                         div.f64
	<.main+11161 @067295>: 1a                         load.z64
	<.main+11162 @067296>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11171 @06729f>: 1f 20 22 06 00             load.ref <@062220> ;Math.asin(x: float64): float64
	<.main+11176 @0672a4>: 02                         call
	<.main+11177 @0672a5>: 09 f8 ff ff                inc.sp(-8)
	<.main+11181 @0672a9>: 82                         sub.f64
	<.main+11182 @0672aa>: 23 38 46 06                store.m64 <@064638> ;testMathAcos_f64
	cmplStd/test/std/test.math.ci:67: (34 bytes: <.main+11186 @0672ae> - <.main+11220 @0672d0>): static testMathCmp_f32: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11186 @0672ae>: 19                         load.z32
	<.main+11187 @0672af>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11192 @0672b4>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+11197 @0672b9>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11202 @0672be>: 1f 88 1d 06 00             load.ref <@061d88> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+11207 @0672c3>: 02                         call
	<.main+11208 @0672c4>: 09 f4 ff ff                inc.sp(-12)
	<.main+11212 @0672c8>: 19                         load.z32
	<.main+11213 @0672c9>: 57                         ceq.i32
	<.main+11214 @0672ca>: 1f 40 46 06 00             load.ref <@064640> ;testMathCmp_f32
	<.main+11219 @0672cf>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:68: (46 bytes: <.main+11220 @0672d0> - <.main+11266 @0672fe>): static testMathCmp_f64: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11220 @0672d0>: 19                         load.z32
	<.main+11221 @0672d1>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11230 @0672da>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+11239 @0672e3>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11248 @0672ec>: 1f c8 1d 06 00             load.ref <@061dc8> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+11253 @0672f1>: 02                         call
	<.main+11254 @0672f2>: 09 e8 ff ff                inc.sp(-24)
	<.main+11258 @0672f6>: 19                         load.z32
	<.main+11259 @0672f7>: 57                         ceq.i32
	<.main+11260 @0672f8>: 1f 48 46 06 00             load.ref <@064648> ;testMathCmp_f64
	<.main+11265 @0672fd>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:70: (33 bytes: <.main+11266 @0672fe> - <.main+11299 @06731f>): static testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+11266 @0672fe>: 1a                         load.z64
	<.main+11267 @0672ff>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11276 @067308>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11285 @067311>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11290 @067316>: 02                         call
	<.main+11291 @067317>: 09 f0 ff ff                inc.sp(-16)
	<.main+11295 @06731b>: 23 50 46 06                store.m64 <@064650> ;testMathAbsMod_f64_0a
	cmplStd/test/std/test.math.ci:71: (24 bytes: <.main+11299 @06731f> - <.main+11323 @067337>): static testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+11299 @06731f>: 1b                         load.z128
	<.main+11300 @067320>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11309 @067329>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11314 @06732e>: 02                         call
	<.main+11315 @06732f>: 09 f0 ff ff                inc.sp(-16)
	<.main+11319 @067333>: 23 58 46 06                store.m64 <@064658> ;testMathAbsMod_f64_0b
	cmplStd/test/std/test.math.ci:72: (33 bytes: <.main+11323 @067337> - <.main+11356 @067358>): static testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+11323 @067337>: 1a                         load.z64
	<.main+11324 @067338>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11333 @067341>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11342 @06734a>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11347 @06734f>: 02                         call
	<.main+11348 @067350>: 09 f0 ff ff                inc.sp(-16)
	<.main+11352 @067354>: 23 60 46 06                store.m64 <@064660> ;testMathAbsMod_f64_0c
	cmplStd/test/std/test.math.ci:74: (33 bytes: <.main+11356 @067358> - <.main+11389 @067379>): static testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+11356 @067358>: 1a                         load.z64
	<.main+11357 @067359>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11366 @067362>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11375 @06736b>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11380 @067370>: 02                         call
	<.main+11381 @067371>: 09 f0 ff ff                inc.sp(-16)
	<.main+11385 @067375>: 23 68 46 06                store.m64 <@064668> ;testMathAbsMod_f64_9a
	cmplStd/test/std/test.math.ci:75: (33 bytes: <.main+11389 @067379> - <.main+11422 @06739a>): static testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+11389 @067379>: 1a                         load.z64
	<.main+11390 @06737a>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11399 @067383>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11408 @06738c>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11413 @067391>: 02                         call
	<.main+11414 @067392>: 09 f0 ff ff                inc.sp(-16)
	<.main+11418 @067396>: 23 70 46 06                store.m64 <@064670> ;testMathAbsMod_f64_9b
	cmplStd/test/std/test.math.ci:76: (33 bytes: <.main+11422 @06739a> - <.main+11455 @0673bb>): static testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+11422 @06739a>: 1a                         load.z64
	<.main+11423 @06739b>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11432 @0673a4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11441 @0673ad>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11446 @0673b2>: 02                         call
	<.main+11447 @0673b3>: 09 f0 ff ff                inc.sp(-16)
	<.main+11451 @0673b7>: 23 78 46 06                store.m64 <@064678> ;testMathAbsMod_f64_9c
	cmplStd/test/std/test.math.ci:77: (33 bytes: <.main+11455 @0673bb> - <.main+11488 @0673dc>): static testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+11455 @0673bb>: 1a                         load.z64
	<.main+11456 @0673bc>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11465 @0673c5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11474 @0673ce>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11479 @0673d3>: 02                         call
	<.main+11480 @0673d4>: 09 f0 ff ff                inc.sp(-16)
	<.main+11484 @0673d8>: 23 80 46 06                store.m64 <@064680> ;testMathAbsMod_f64_9d
	cmplStd/test/std/test.math.ci:79: (33 bytes: <.main+11488 @0673dc> - <.main+11521 @0673fd>): static testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+11488 @0673dc>: 1a                         load.z64
	<.main+11489 @0673dd>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11498 @0673e6>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11507 @0673ef>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11512 @0673f4>: 02                         call
	<.main+11513 @0673f5>: 09 f0 ff ff                inc.sp(-16)
	<.main+11517 @0673f9>: 23 88 46 06                store.m64 <@064688> ;testMathAbsMod_f64_8a
	cmplStd/test/std/test.math.ci:80: (33 bytes: <.main+11521 @0673fd> - <.main+11554 @06741e>): static testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+11521 @0673fd>: 1a                         load.z64
	<.main+11522 @0673fe>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11531 @067407>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11540 @067410>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11545 @067415>: 02                         call
	<.main+11546 @067416>: 09 f0 ff ff                inc.sp(-16)
	<.main+11550 @06741a>: 23 90 46 06                store.m64 <@064690> ;testMathAbsMod_f64_8b
	cmplStd/test/std/test.math.ci:81: (33 bytes: <.main+11554 @06741e> - <.main+11587 @06743f>): static testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+11554 @06741e>: 1a                         load.z64
	<.main+11555 @06741f>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11564 @067428>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11573 @067431>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11578 @067436>: 02                         call
	<.main+11579 @067437>: 09 f0 ff ff                inc.sp(-16)
	<.main+11583 @06743b>: 23 98 46 06                store.m64 <@064698> ;testMathAbsMod_f64_8c
	cmplStd/test/std/test.math.ci:82: (33 bytes: <.main+11587 @06743f> - <.main+11620 @067460>): static testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+11587 @06743f>: 1a                         load.z64
	<.main+11588 @067440>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11597 @067449>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11606 @067452>: 1f 18 1c 06 00             load.ref <@061c18> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11611 @067457>: 02                         call
	<.main+11612 @067458>: 09 f0 ff ff                inc.sp(-16)
	<.main+11616 @06745c>: 23 a0 46 06                store.m64 <@0646a0> ;testMathAbsMod_f64_8d
	cmplStd/test/std/test.math.ci:84: (25 bytes: <.main+11620 @067460> - <.main+11645 @067479>): static testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+11620 @067460>: 19                         load.z32
	<.main+11621 @067461>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11626 @067466>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11631 @06746b>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11636 @067470>: 02                         call
	<.main+11637 @067471>: 09 f8 ff ff                inc.sp(-8)
	<.main+11641 @067475>: 24 a8 46 06                store.m32 <@0646a8> ;testMathAbsMod_f32_0a
	cmplStd/test/std/test.math.ci:85: (21 bytes: <.main+11645 @067479> - <.main+11666 @06748e>): static testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+11645 @067479>: 19                         load.z32
	<.main+11646 @06747a>: 19                         load.z32
	<.main+11647 @06747b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11652 @067480>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11657 @067485>: 02                         call
	<.main+11658 @067486>: 09 f8 ff ff                inc.sp(-8)
	<.main+11662 @06748a>: 24 b0 46 06                store.m32 <@0646b0> ;testMathAbsMod_f32_0b
	cmplStd/test/std/test.math.ci:86: (25 bytes: <.main+11666 @06748e> - <.main+11691 @0674a7>): static testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+11666 @06748e>: 19                         load.z32
	<.main+11667 @06748f>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11672 @067494>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11677 @067499>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11682 @06749e>: 02                         call
	<.main+11683 @06749f>: 09 f8 ff ff                inc.sp(-8)
	<.main+11687 @0674a3>: 24 b8 46 06                store.m32 <@0646b8> ;testMathAbsMod_f32_0c
	cmplStd/test/std/test.math.ci:88: (25 bytes: <.main+11691 @0674a7> - <.main+11716 @0674c0>): static testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+11691 @0674a7>: 19                         load.z32
	<.main+11692 @0674a8>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11697 @0674ad>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11702 @0674b2>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11707 @0674b7>: 02                         call
	<.main+11708 @0674b8>: 09 f8 ff ff                inc.sp(-8)
	<.main+11712 @0674bc>: 24 c0 46 06                store.m32 <@0646c0> ;testMathAbsMod_f32_9a
	cmplStd/test/std/test.math.ci:89: (25 bytes: <.main+11716 @0674c0> - <.main+11741 @0674d9>): static testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+11716 @0674c0>: 19                         load.z32
	<.main+11717 @0674c1>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11722 @0674c6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11727 @0674cb>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11732 @0674d0>: 02                         call
	<.main+11733 @0674d1>: 09 f8 ff ff                inc.sp(-8)
	<.main+11737 @0674d5>: 24 c8 46 06                store.m32 <@0646c8> ;testMathAbsMod_f32_9b
	cmplStd/test/std/test.math.ci:90: (25 bytes: <.main+11741 @0674d9> - <.main+11766 @0674f2>): static testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+11741 @0674d9>: 19                         load.z32
	<.main+11742 @0674da>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11747 @0674df>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11752 @0674e4>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11757 @0674e9>: 02                         call
	<.main+11758 @0674ea>: 09 f8 ff ff                inc.sp(-8)
	<.main+11762 @0674ee>: 24 d0 46 06                store.m32 <@0646d0> ;testMathAbsMod_f32_9c
	cmplStd/test/std/test.math.ci:91: (25 bytes: <.main+11766 @0674f2> - <.main+11791 @06750b>): static testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+11766 @0674f2>: 19                         load.z32
	<.main+11767 @0674f3>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11772 @0674f8>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11777 @0674fd>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11782 @067502>: 02                         call
	<.main+11783 @067503>: 09 f8 ff ff                inc.sp(-8)
	<.main+11787 @067507>: 24 d8 46 06                store.m32 <@0646d8> ;testMathAbsMod_f32_9d
	cmplStd/test/std/test.math.ci:93: (25 bytes: <.main+11791 @06750b> - <.main+11816 @067524>): static testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+11791 @06750b>: 19                         load.z32
	<.main+11792 @06750c>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11797 @067511>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11802 @067516>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11807 @06751b>: 02                         call
	<.main+11808 @06751c>: 09 f8 ff ff                inc.sp(-8)
	<.main+11812 @067520>: 24 e0 46 06                store.m32 <@0646e0> ;testMathAbsMod_f32_8a
	cmplStd/test/std/test.math.ci:94: (25 bytes: <.main+11816 @067524> - <.main+11841 @06753d>): static testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+11816 @067524>: 19                         load.z32
	<.main+11817 @067525>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11822 @06752a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11827 @06752f>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11832 @067534>: 02                         call
	<.main+11833 @067535>: 09 f8 ff ff                inc.sp(-8)
	<.main+11837 @067539>: 24 e8 46 06                store.m32 <@0646e8> ;testMathAbsMod_f32_8b
	cmplStd/test/std/test.math.ci:95: (25 bytes: <.main+11841 @06753d> - <.main+11866 @067556>): static testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+11841 @06753d>: 19                         load.z32
	<.main+11842 @06753e>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11847 @067543>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11852 @067548>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11857 @06754d>: 02                         call
	<.main+11858 @06754e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11862 @067552>: 24 f0 46 06                store.m32 <@0646f0> ;testMathAbsMod_f32_8c
	cmplStd/test/std/test.math.ci:96: (25 bytes: <.main+11866 @067556> - <.main+11891 @06756f>): static testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+11866 @067556>: 19                         load.z32
	<.main+11867 @067557>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11872 @06755c>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11877 @067561>: 1f f8 1b 06 00             load.ref <@061bf8> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11882 @067566>: 02                         call
	<.main+11883 @067567>: 09 f8 ff ff                inc.sp(-8)
	<.main+11887 @06756b>: 24 f8 46 06                store.m32 <@0646f8> ;testMathAbsMod_f32_8d
	cmplStd/test/std/memory.ci:13: (18 bytes: <.main+11891 @06756f> - <.main+11909 @067581>): pointer.fill(p1, 0, 1024);
	<.main+11891 @06756f>: 20 c0 35 06                load.m32 <@0635c0> ;p1
	<.main+11895 @067573>: 19                         load.z32
	<.main+11896 @067574>: 1c 00 04 00 00             load.c32 1024
	<.main+11901 @067579>: 01 0e 00 00                nfc(14) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+11905 @06757d>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:14: (21 bytes: <.main+11909 @067581> - <.main+11930 @067596>): pointer.copy(p1, p3, 160);
	<.main+11909 @067581>: 20 c0 35 06                load.m32 <@0635c0> ;p1
	<.main+11913 @067585>: 20 d0 35 06                load.m32 <@0635d0> ;p3
	<.main+11917 @067589>: 1c a0 00 00 00             load.c32 160
	<.main+11922 @06758e>: 01 0f 00 00                nfc(15) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11926 @067592>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:17: (13 bytes: <.main+11930 @067596> - <.main+11943 @0675a3>): free(p1);
	<.main+11930 @067596>: 20 c0 35 06                load.m32 <@0635c0> ;p1
	<.main+11934 @06759a>: 19                         load.z32
	<.main+11935 @06759b>: 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11939 @06759f>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:18: (13 bytes: <.main+11943 @0675a3> - <.main+11956 @0675b0>): free(p2);
	<.main+11943 @0675a3>: 20 c8 35 06                load.m32 <@0635c8> ;p2
	<.main+11947 @0675a7>: 19                         load.z32
	<.main+11948 @0675a8>: 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11952 @0675ac>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:19: (13 bytes: <.main+11956 @0675b0> - <.main+11969 @0675bd>): free(p3);
	<.main+11956 @0675b0>: 20 d0 35 06                load.m32 <@0635d0> ;p3
	<.main+11960 @0675b4>: 19                         load.z32
	<.main+11961 @0675b5>: 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11965 @0675b9>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:20: (13 bytes: <.main+11969 @0675bd> - <.main+11982 @0675ca>): free(p4);
	<.main+11969 @0675bd>: 20 d8 35 06                load.m32 <@0635d8> ;p4
	<.main+11973 @0675c1>: 19                         load.z32
	<.main+11974 @0675c2>: 01 0d 00 00                nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11978 @0675c6>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:26: (35 bytes: <.main+11982 @0675ca> - <.main+12017 @0675ed>): debug("val1", val1);
	<.main+11982 @0675ca>: 1f 38 59 04 00             load.ref <@045938> ;"cmplStd/test/std/memory.ci"
	<.main+11987 @0675cf>: 1c 1a 00 00 00             load.c32 26
	<.main+11992 @0675d4>: 1c 0e 00 00 00             load.c32 14
	<.main+11997 @0675d9>: 19                         load.z32
	<.main+11998 @0675da>: 1f 67 59 04 00             load.ref <@045967> ;"val1"
	<.main+12003 @0675df>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12008 @0675e4>: 1f e0 35 06 00             load.ref <@0635e0> ;val1
	<.main+12013 @0675e9>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:27: (35 bytes: <.main+12017 @0675ed> - <.main+12052 @067610>): debug("val2", val2);
	<.main+12017 @0675ed>: 1f 38 59 04 00             load.ref <@045938> ;"cmplStd/test/std/memory.ci"
	<.main+12022 @0675f2>: 1c 1b 00 00 00             load.c32 27
	<.main+12027 @0675f7>: 1c 0e 00 00 00             load.c32 14
	<.main+12032 @0675fc>: 19                         load.z32
	<.main+12033 @0675fd>: 1f 6c 59 04 00             load.ref <@04596c> ;"val2"
	<.main+12038 @067602>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12043 @067607>: 1f e8 35 06 00             load.ref <@0635e8> ;val2
	<.main+12048 @06760c>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:29: (27 bytes: <.main+12052 @067610> - <.main+12079 @06762b>): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+12052 @067610>: 1f e8 35 06 00             load.ref <@0635e8> ;val2
	<.main+12057 @067615>: 1f e0 35 06 00             load.ref <@0635e0> ;val1
	<.main+12062 @06761a>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12067 @06761f>: 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+12071 @067623>: 01 10 00 00                nfc(16) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+12075 @067627>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:30: (23 bytes: <.main+12079 @06762b> - <.main+12102 @067642>): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+12079 @06762b>: 1f e0 35 06 00             load.ref <@0635e0> ;val1
	<.main+12084 @067630>: 19                         load.z32
	<.main+12085 @067631>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12090 @067636>: 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+12094 @06763a>: 01 0e 00 00                nfc(14) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+12098 @06763e>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:32: (35 bytes: <.main+12102 @067642> - <.main+12137 @067665>): debug("val1", val1);
	<.main+12102 @067642>: 1f 38 59 04 00             load.ref <@045938> ;"cmplStd/test/std/memory.ci"
	<.main+12107 @067647>: 1c 20 00 00 00             load.c32 32
	<.main+12112 @06764c>: 1c 0e 00 00 00             load.c32 14
	<.main+12117 @067651>: 19                         load.z32
	<.main+12118 @067652>: 1f 67 59 04 00             load.ref <@045967> ;"val1"
	<.main+12123 @067657>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12128 @06765c>: 1f e0 35 06 00             load.ref <@0635e0> ;val1
	<.main+12133 @067661>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:33: (35 bytes: <.main+12137 @067665> - <.main+12172 @067688>): debug("val2", val2);
	<.main+12137 @067665>: 1f 38 59 04 00             load.ref <@045938> ;"cmplStd/test/std/memory.ci"
	<.main+12142 @06766a>: 1c 21 00 00 00             load.c32 33
	<.main+12147 @06766f>: 1c 0e 00 00 00             load.c32 14
	<.main+12152 @067674>: 19                         load.z32
	<.main+12153 @067675>: 1f 6c 59 04 00             load.ref <@04596c> ;"val2"
	<.main+12158 @06767a>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12163 @06767f>: 1f e8 35 06 00             load.ref <@0635e8> ;val2
	<.main+12168 @067684>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:78: (21 bytes: <.main+12172 @067688> - <.main+12193 @06769d>): RecordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+12172 @067688>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12176 @06768c>: 1c 01 00 00 00             load.c32 1
	<.main+12181 @067691>: 13 04                      set.x32 sp(4)
	<.main+12183 @067693>: 1f 78 3b 06 00             load.ref <@063b78> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12188 @067698>: 02                         call
	<.main+12189 @067699>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:79: (20 bytes: <.main+12193 @06769d> - <.main+12213 @0676b1>): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+12193 @06769d>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12197 @0676a1>: 1c 01 00 00 00             load.c32 1
	<.main+12202 @0676a6>: 13 04                      set.x32 sp(4)
	<.main+12204 @0676a8>: 20 28 3c 06                load.m32 <@063c28> ;recordMethodTest+8
	<.main+12208 @0676ac>: 02                         call
	<.main+12209 @0676ad>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:97: (19 bytes: <.main+12213 @0676b1> - <.main+12232 @0676c4>): staticMethod(recordMethodTest, 2);
	<.main+12213 @0676b1>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12217 @0676b5>: 1c 02 00 00 00             load.c32 2
	<.main+12222 @0676ba>: 1f 30 3c 06 00             load.ref <@063c30> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12227 @0676bf>: 02                         call
	<.main+12228 @0676c0>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:98: (19 bytes: <.main+12232 @0676c4> - <.main+12251 @0676d7>): virtualMethod(recordMethodTest, 2);
	<.main+12232 @0676c4>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12236 @0676c8>: 1c 02 00 00 00             load.c32 2
	<.main+12241 @0676cd>: 1f 78 3c 06 00             load.ref <@063c78> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12246 @0676d2>: 02                         call
	<.main+12247 @0676d3>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:101: (21 bytes: <.main+12251 @0676d7> - <.main+12272 @0676ec>): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+12251 @0676d7>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12255 @0676db>: 1c 03 00 00 00             load.c32 3
	<.main+12260 @0676e0>: 13 04                      set.x32 sp(4)
	<.main+12262 @0676e2>: 1f 78 3b 06 00             load.ref <@063b78> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12267 @0676e7>: 02                         call
	<.main+12268 @0676e8>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:102: (21 bytes: <.main+12272 @0676ec> - <.main+12293 @067701>): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12272 @0676ec>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12276 @0676f0>: 1c 03 00 00 00             load.c32 3
	<.main+12281 @0676f5>: 13 04                      set.x32 sp(4)
	<.main+12283 @0676f7>: 1f a8 3b 06 00             load.ref <@063ba8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12288 @0676fc>: 02                         call
	<.main+12289 @0676fd>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:103: (20 bytes: <.main+12293 @067701> - <.main+12313 @067715>): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12293 @067701>: 22 20 3c 06                load.m128 <@063c20> ;recordMethodTest
	<.main+12297 @067705>: 1c 03 00 00 00             load.c32 3
	<.main+12302 @06770a>: 13 04                      set.x32 sp(4)
	<.main+12304 @06770c>: 20 28 3c 06                load.m32 <@063c28> ;recordMethodTest+8
	<.main+12308 @067710>: 02                         call
	<.main+12309 @067711>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:4: (39 bytes: <.main+12313 @067715> - <.main+12352 @06773c>): raise(raise.debug, 1, "0 == 0", null);
	<.main+12313 @067715>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12318 @06771a>: 1c 04 00 00 00             load.c32 4
	<.main+12323 @06771f>: 1c 0e 00 00 00             load.c32 14
	<.main+12328 @067724>: 1c 01 00 00 00             load.c32 1
	<.main+12333 @067729>: 1f 15 e0 05 00             load.ref <@05e015> ;"0 == 0"
	<.main+12338 @06772e>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12343 @067733>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12348 @067738>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:12: (39 bytes: <.main+12352 @06773c> - <.main+12391 @067763>): raise(raise.debug, 3, "0 == 0", null);
	<.main+12352 @06773c>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12357 @067741>: 1c 0c 00 00 00             load.c32 12
	<.main+12362 @067746>: 1c 0e 00 00 00             load.c32 14
	<.main+12367 @06774b>: 1c 03 00 00 00             load.c32 3
	<.main+12372 @067750>: 1f 15 e0 05 00             load.ref <@05e015> ;"0 == 0"
	<.main+12377 @067755>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12382 @06775a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12387 @06775f>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:22: (39 bytes: <.main+12391 @067763> - <.main+12430 @06778a>): raise(raise.debug, 6, "0 == 0", null);
	<.main+12391 @067763>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12396 @067768>: 1c 16 00 00 00             load.c32 22
	<.main+12401 @06776d>: 1c 0e 00 00 00             load.c32 14
	<.main+12406 @067772>: 1c 06 00 00 00             load.c32 6
	<.main+12411 @067777>: 1f 15 e0 05 00             load.ref <@05e015> ;"0 == 0"
	<.main+12416 @06777c>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12421 @067781>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12426 @067786>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:28: (49 bytes: <.main+12430 @06778a> - <.main+12479 @0677bb>): if (t == 0)
	<.main+12430 @06778a>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12434 @06778e>: 19                         load.z32
	<.main+12435 @06778f>: 57                         ceq.i32
	<.main+12436 @067790>: 06 2b 00 00                jz <.main+12479 @0677bb>
	cmplStd/test/lang/stmt.if.ci:29: (39 bytes: <.main+12440 @067794> - <.main+12479 @0677bb>): raise(raise.debug, 7, "t == 0", t);
	<.main+12440 @067794>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12445 @067799>: 1c 1d 00 00 00             load.c32 29
	<.main+12450 @06779e>: 1c 0e 00 00 00             load.c32 14
	<.main+12455 @0677a3>: 1c 07 00 00 00             load.c32 7
	<.main+12460 @0677a8>: 1f 23 e0 05 00             load.ref <@05e023> ;"t == 0"
	<.main+12465 @0677ad>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12470 @0677b2>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12475 @0677b7>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:32: (49 bytes: <.main+12479 @0677bb> - <.main+12528 @0677ec>): if (t != 0)
	<.main+12479 @0677bb>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12483 @0677bf>: 19                         load.z32
	<.main+12484 @0677c0>: 57                         ceq.i32
	<.main+12485 @0677c1>: 05 2b 00 00                jnz <.main+12528 @0677ec>
	cmplStd/test/lang/stmt.if.ci:33: (39 bytes: <.main+12489 @0677c5> - <.main+12528 @0677ec>): raise(raise.debug, 8, "t != 0", t);
	<.main+12489 @0677c5>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12494 @0677ca>: 1c 21 00 00 00             load.c32 33
	<.main+12499 @0677cf>: 1c 0e 00 00 00             load.c32 14
	<.main+12504 @0677d4>: 1c 08 00 00 00             load.c32 8
	<.main+12509 @0677d9>: 1f 2a e0 05 00             load.ref <@05e02a> ;"t != 0"
	<.main+12514 @0677de>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12519 @0677e3>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12524 @0677e8>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:36: (92 bytes: <.main+12528 @0677ec> - <.main+12620 @067848>): if (t == 0)
	<.main+12528 @0677ec>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12532 @0677f0>: 19                         load.z32
	<.main+12533 @0677f1>: 57                         ceq.i32
	<.main+12534 @0677f2>: 06 2f 00 00                jz <.main+12581 @067821>
	cmplStd/test/lang/stmt.if.ci:37: (39 bytes: <.main+12538 @0677f6> - <.main+12577 @06781d>): raise(raise.debug, 9, "t == 0", t);
	<.main+12538 @0677f6>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12543 @0677fb>: 1c 25 00 00 00             load.c32 37
	<.main+12548 @067800>: 1c 0e 00 00 00             load.c32 14
	<.main+12553 @067805>: 1c 09 00 00 00             load.c32 9
	<.main+12558 @06780a>: 1f 23 e0 05 00             load.ref <@05e023> ;"t == 0"
	<.main+12563 @06780f>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12568 @067814>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12573 @067819>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12577 @06781d>: 04 2b 00 00                jmp <.main+12620 @067848>
	cmplStd/test/lang/stmt.if.ci:40: (39 bytes: <.main+12581 @067821> - <.main+12620 @067848>): raise(raise.debug, 10, "t != 0", t);
	<.main+12581 @067821>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12586 @067826>: 1c 28 00 00 00             load.c32 40
	<.main+12591 @06782b>: 1c 0e 00 00 00             load.c32 14
	<.main+12596 @067830>: 1c 0a 00 00 00             load.c32 10
	<.main+12601 @067835>: 1f 2a e0 05 00             load.ref <@05e02a> ;"t != 0"
	<.main+12606 @06783a>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12611 @06783f>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12616 @067844>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:43: (92 bytes: <.main+12620 @067848> - <.main+12712 @0678a4>): if (t != 0)
	<.main+12620 @067848>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12624 @06784c>: 19                         load.z32
	<.main+12625 @06784d>: 57                         ceq.i32
	<.main+12626 @06784e>: 05 2f 00 00                jnz <.main+12673 @06787d>
	cmplStd/test/lang/stmt.if.ci:44: (39 bytes: <.main+12630 @067852> - <.main+12669 @067879>): raise(raise.debug, 11, "t != 0", t);
	<.main+12630 @067852>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12635 @067857>: 1c 2c 00 00 00             load.c32 44
	<.main+12640 @06785c>: 1c 0e 00 00 00             load.c32 14
	<.main+12645 @067861>: 1c 0b 00 00 00             load.c32 11
	<.main+12650 @067866>: 1f 2a e0 05 00             load.ref <@05e02a> ;"t != 0"
	<.main+12655 @06786b>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12660 @067870>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12665 @067875>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12669 @067879>: 04 2b 00 00                jmp <.main+12712 @0678a4>
	cmplStd/test/lang/stmt.if.ci:47: (39 bytes: <.main+12673 @06787d> - <.main+12712 @0678a4>): raise(raise.debug, 12, "t == 0", t);
	<.main+12673 @06787d>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12678 @067882>: 1c 2f 00 00 00             load.c32 47
	<.main+12683 @067887>: 1c 0e 00 00 00             load.c32 14
	<.main+12688 @06788c>: 1c 0c 00 00 00             load.c32 12
	<.main+12693 @067891>: 1f 23 e0 05 00             load.ref <@05e023> ;"t == 0"
	<.main+12698 @067896>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12703 @06789b>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12708 @0678a0>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:50: (377 bytes: <.main+12712 @0678a4> - <.main+13089 @067a1d>): if (t == 0)
	<.main+12712 @0678a4>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12716 @0678a8>: 19                         load.z32
	<.main+12717 @0678a9>: 57                         ceq.i32
	<.main+12718 @0678aa>: 06 2f 00 00                jz <.main+12765 @0678d9>
	cmplStd/test/lang/stmt.if.ci:51: (39 bytes: <.main+12722 @0678ae> - <.main+12761 @0678d5>): raise(raise.debug, 9, "t == 0", t);
	<.main+12722 @0678ae>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12727 @0678b3>: 1c 33 00 00 00             load.c32 51
	<.main+12732 @0678b8>: 1c 0e 00 00 00             load.c32 14
	<.main+12737 @0678bd>: 1c 09 00 00 00             load.c32 9
	<.main+12742 @0678c2>: 1f 23 e0 05 00             load.ref <@05e023> ;"t == 0"
	<.main+12747 @0678c7>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12752 @0678cc>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12757 @0678d1>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12761 @0678d5>: 04 48 01 00                jmp <.main+13089 @067a1d>
	cmplStd/test/lang/stmt.if.ci:53: (324 bytes: <.main+12765 @0678d9> - <.main+13089 @067a1d>): if (t == 1)
	<.main+12765 @0678d9>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12769 @0678dd>: 1c 01 00 00 00             load.c32 1
	<.main+12774 @0678e2>: 57                         ceq.i32
	<.main+12775 @0678e3>: 06 2f 00 00                jz <.main+12822 @067912>
	cmplStd/test/lang/stmt.if.ci:54: (39 bytes: <.main+12779 @0678e7> - <.main+12818 @06790e>): raise(raise.debug, 10, "t == 1", t);
	<.main+12779 @0678e7>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12784 @0678ec>: 1c 36 00 00 00             load.c32 54
	<.main+12789 @0678f1>: 1c 0e 00 00 00             load.c32 14
	<.main+12794 @0678f6>: 1c 0a 00 00 00             load.c32 10
	<.main+12799 @0678fb>: 1f 31 e0 05 00             load.ref <@05e031> ;"t == 1"
	<.main+12804 @067900>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12809 @067905>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12814 @06790a>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12818 @06790e>: 04 0f 01 00                jmp <.main+13089 @067a1d>
	cmplStd/test/lang/stmt.if.ci:56: (267 bytes: <.main+12822 @067912> - <.main+13089 @067a1d>): if (t == 2)
	<.main+12822 @067912>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12826 @067916>: 1c 02 00 00 00             load.c32 2
	<.main+12831 @06791b>: 57                         ceq.i32
	<.main+12832 @06791c>: 06 2f 00 00                jz <.main+12879 @06794b>
	cmplStd/test/lang/stmt.if.ci:57: (39 bytes: <.main+12836 @067920> - <.main+12875 @067947>): raise(raise.debug, 10, "t == 2", t);
	<.main+12836 @067920>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12841 @067925>: 1c 39 00 00 00             load.c32 57
	<.main+12846 @06792a>: 1c 0e 00 00 00             load.c32 14
	<.main+12851 @06792f>: 1c 0a 00 00 00             load.c32 10
	<.main+12856 @067934>: 1f 38 e0 05 00             load.ref <@05e038> ;"t == 2"
	<.main+12861 @067939>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12866 @06793e>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12871 @067943>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12875 @067947>: 04 d6 00 00                jmp <.main+13089 @067a1d>
	cmplStd/test/lang/stmt.if.ci:59: (210 bytes: <.main+12879 @06794b> - <.main+13089 @067a1d>): if (t == 3)
	<.main+12879 @06794b>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12883 @06794f>: 1c 03 00 00 00             load.c32 3
	<.main+12888 @067954>: 57                         ceq.i32
	<.main+12889 @067955>: 06 2f 00 00                jz <.main+12936 @067984>
	cmplStd/test/lang/stmt.if.ci:60: (39 bytes: <.main+12893 @067959> - <.main+12932 @067980>): raise(raise.debug, 10, "t == 3", t);
	<.main+12893 @067959>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12898 @06795e>: 1c 3c 00 00 00             load.c32 60
	<.main+12903 @067963>: 1c 0e 00 00 00             load.c32 14
	<.main+12908 @067968>: 1c 0a 00 00 00             load.c32 10
	<.main+12913 @06796d>: 1f 3f e0 05 00             load.ref <@05e03f> ;"t == 3"
	<.main+12918 @067972>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12923 @067977>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12928 @06797c>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12932 @067980>: 04 9d 00 00                jmp <.main+13089 @067a1d>
	cmplStd/test/lang/stmt.if.ci:62: (153 bytes: <.main+12936 @067984> - <.main+13089 @067a1d>): if (t == 4)
	<.main+12936 @067984>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12940 @067988>: 1c 04 00 00 00             load.c32 4
	<.main+12945 @06798d>: 57                         ceq.i32
	<.main+12946 @06798e>: 06 2f 00 00                jz <.main+12993 @0679bd>
	cmplStd/test/lang/stmt.if.ci:63: (39 bytes: <.main+12950 @067992> - <.main+12989 @0679b9>): raise(raise.debug, 10, "t == 4", t);
	<.main+12950 @067992>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12955 @067997>: 1c 3f 00 00 00             load.c32 63
	<.main+12960 @06799c>: 1c 0e 00 00 00             load.c32 14
	<.main+12965 @0679a1>: 1c 0a 00 00 00             load.c32 10
	<.main+12970 @0679a6>: 1f 46 e0 05 00             load.ref <@05e046> ;"t == 4"
	<.main+12975 @0679ab>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12980 @0679b0>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+12985 @0679b5>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12989 @0679b9>: 04 64 00 00                jmp <.main+13089 @067a1d>
	cmplStd/test/lang/stmt.if.ci:65: (96 bytes: <.main+12993 @0679bd> - <.main+13089 @067a1d>): if (t == 5)
	<.main+12993 @0679bd>: 20 98 44 06                load.m32 <@064498> ;t
	<.main+12997 @0679c1>: 1c 05 00 00 00             load.c32 5
	<.main+13002 @0679c6>: 57                         ceq.i32
	<.main+13003 @0679c7>: 06 2f 00 00                jz <.main+13050 @0679f6>
	cmplStd/test/lang/stmt.if.ci:66: (39 bytes: <.main+13007 @0679cb> - <.main+13046 @0679f2>): raise(raise.debug, 10, "t == 5", t);
	<.main+13007 @0679cb>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13012 @0679d0>: 1c 42 00 00 00             load.c32 66
	<.main+13017 @0679d5>: 1c 0e 00 00 00             load.c32 14
	<.main+13022 @0679da>: 1c 0a 00 00 00             load.c32 10
	<.main+13027 @0679df>: 1f 4d e0 05 00             load.ref <@05e04d> ;"t == 5"
	<.main+13032 @0679e4>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13037 @0679e9>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+13042 @0679ee>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13046 @0679f2>: 04 2b 00 00                jmp <.main+13089 @067a1d>
	cmplStd/test/lang/stmt.if.ci:69: (39 bytes: <.main+13050 @0679f6> - <.main+13089 @067a1d>): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+13050 @0679f6>: 1f f8 df 05 00             load.ref <@05dff8> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13055 @0679fb>: 1c 45 00 00 00             load.c32 69
	<.main+13060 @067a00>: 1c 0e 00 00 00             load.c32 14
	<.main+13065 @067a05>: 1c 0a 00 00 00             load.c32 10
	<.main+13070 @067a0a>: 1f 54 e0 05 00             load.ref <@05e054> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+13075 @067a0f>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13080 @067a14>: 1f 98 44 06 00             load.ref <@064498> ;t
	<.main+13085 @067a19>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:3: (47 bytes: <.main+13089 @067a1d> - <.main+13136 @067a4c>): for ( ; ; )
	<.main+13089 @067a1d>: 04 2b 00 00                jmp <.main+13132 @067a48>
	cmplStd/test/lang/stmt.for.ci:4: (35 bytes: <.main+13093 @067a21> - <.main+13128 @067a44>): debug("for ( ; ; )");
	<.main+13093 @067a21>: 1f 40 e1 05 00             load.ref <@05e140> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13098 @067a26>: 1c 04 00 00 00             load.c32 4
	<.main+13103 @067a2b>: 1c 0e 00 00 00             load.c32 14
	<.main+13108 @067a30>: 19                         load.z32
	<.main+13109 @067a31>: 1f 5e e1 05 00             load.ref <@05e15e> ;"for ( ; ; )"
	<.main+13114 @067a36>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13119 @067a3b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13124 @067a40>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:5: (4 bytes: <.main+13128 @067a44> - <.main+13132 @067a48>): break;
	<.main+13128 @067a44>: 04 08 00 00                jmp <.main+13136 @067a4c>
	:: (4 bytes: <.main+13132 @067a48> - <.main+13136 @067a4c>)
	<.main+13132 @067a48>: 04 d9 ff ff                jmp <.main+13093 @067a21>
	cmplStd/test/lang/stmt.for.ci:8: (59 bytes: <.main+13136 @067a4c> - <.main+13195 @067a87>): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+13136 @067a4c>: 19                         load.z32
	<.main+13137 @067a4d>: 04 2a 00 00                jmp <.main+13179 @067a77>
	cmplStd/test/lang/stmt.for.ci:9: (34 bytes: <.main+13141 @067a51> - <.main+13175 @067a73>): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+13141 @067a51>: 1f 40 e1 05 00             load.ref <@05e140> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13146 @067a56>: 1c 09 00 00 00             load.c32 9
	<.main+13151 @067a5b>: 1c 0e 00 00 00             load.c32 14
	<.main+13156 @067a60>: 19                         load.z32
	<.main+13157 @067a61>: 1f 6a e1 05 00             load.ref <@05e16a> ;"for (int i = 0; i < 2; i += 1)"
	<.main+13162 @067a66>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13167 @067a6b>: 0a 18 00 00                load.sp(+24)
	<.main+13171 @067a6f>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:8: (4 bytes: <.main+13175 @067a73> - <.main+13179 @067a77>): i := i + 1
	<.main+13175 @067a73>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:8: (12 bytes: <.main+13179 @067a77> - <.main+13191 @067a83>): i < 2
	<.main+13179 @067a77>: 10 00                      dup.x32 sp(0)
	<.main+13181 @067a79>: 1c 02 00 00 00             load.c32 2
	<.main+13186 @067a7e>: 58                         clt.i32
	<.main+13187 @067a7f>: 05 d2 ff ff                jnz <.main+13141 @067a51>
	<.main+13191 @067a83>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:13: (70 bytes: <.main+13195 @067a87> - <.main+13265 @067acd>): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+13195 @067a87>: 19                         load.z32
	<.main+13196 @067a88>: 24 a0 44 06                store.m32 <@0644a0> ;forIdx
	<.main+13200 @067a8c>: 04 33 00 00                jmp <.main+13251 @067abf>
	cmplStd/test/lang/stmt.for.ci:14: (35 bytes: <.main+13204 @067a90> - <.main+13239 @067ab3>): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+13204 @067a90>: 1f 40 e1 05 00             load.ref <@05e140> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13209 @067a95>: 1c 0e 00 00 00             load.c32 14
	<.main+13214 @067a9a>: 1c 0e 00 00 00             load.c32 14
	<.main+13219 @067a9f>: 19                         load.z32
	<.main+13220 @067aa0>: 1f 90 e1 05 00             load.ref <@05e190> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+13225 @067aa5>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13230 @067aaa>: 1f a0 44 06 00             load.ref <@0644a0> ;forIdx
	<.main+13235 @067aaf>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:13: (12 bytes: <.main+13239 @067ab3> - <.main+13251 @067abf>): forIdx := forIdx + 1
	<.main+13239 @067ab3>: 20 a0 44 06                load.m32 <@0644a0> ;forIdx
	<.main+13243 @067ab7>: 0c 01 00 00                inc.i32(+1)
	<.main+13247 @067abb>: 24 a0 44 06                store.m32 <@0644a0> ;forIdx
	cmplStd/test/lang/stmt.for.ci:13: (14 bytes: <.main+13251 @067abf> - <.main+13265 @067acd>): forIdx < 2
	<.main+13251 @067abf>: 20 a0 44 06                load.m32 <@0644a0> ;forIdx
	<.main+13255 @067ac3>: 1c 02 00 00 00             load.c32 2
	<.main+13260 @067ac8>: 58                         clt.i32
	<.main+13261 @067ac9>: 05 c7 ff ff                jnz <.main+13204 @067a90>
	cmplStd/test/lang/stmt.for.ci:17: (75 bytes: <.main+13265 @067acd> - <.main+13340 @067b18>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+13265 @067acd>: 19                         load.z32
	<.main+13266 @067ace>: 04 3a 00 00                jmp <.main+13324 @067b08>
	cmplStd/test/lang/stmt.for.ci:18: (16 bytes: <.main+13270 @067ad2> - <.main+13286 @067ae2>): if (i < 2)
	<.main+13270 @067ad2>: 10 00                      dup.x32 sp(0)
	<.main+13272 @067ad4>: 1c 02 00 00 00             load.c32 2
	<.main+13277 @067ad9>: 58                         clt.i32
	<.main+13278 @067ada>: 06 08 00 00                jz <.main+13286 @067ae2>
	cmplStd/test/lang/stmt.for.ci:19: (4 bytes: <.main+13282 @067ade> - <.main+13286 @067ae2>): continue;
	<.main+13282 @067ade>: 04 26 00 00                jmp <.main+13320 @067b04>
	cmplStd/test/lang/stmt.for.ci:21: (34 bytes: <.main+13286 @067ae2> - <.main+13320 @067b04>): debug("for with continue", i);
	<.main+13286 @067ae2>: 1f 40 e1 05 00             load.ref <@05e140> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13291 @067ae7>: 1c 15 00 00 00             load.c32 21
	<.main+13296 @067aec>: 1c 0e 00 00 00             load.c32 14
	<.main+13301 @067af1>: 19                         load.z32
	<.main+13302 @067af2>: 1f ba e1 05 00             load.ref <@05e1ba> ;"for with continue"
	<.main+13307 @067af7>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13312 @067afc>: 0a 18 00 00                load.sp(+24)
	<.main+13316 @067b00>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:17: (4 bytes: <.main+13320 @067b04> - <.main+13324 @067b08>): i := i + 1
	<.main+13320 @067b04>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:17: (12 bytes: <.main+13324 @067b08> - <.main+13336 @067b14>): i < 7
	<.main+13324 @067b08>: 10 00                      dup.x32 sp(0)
	<.main+13326 @067b0a>: 1c 07 00 00 00             load.c32 7
	<.main+13331 @067b0f>: 58                         clt.i32
	<.main+13332 @067b10>: 05 c2 ff ff                jnz <.main+13270 @067ad2>
	<.main+13336 @067b14>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:24: (75 bytes: <.main+13340 @067b18> - <.main+13415 @067b63>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+13340 @067b18>: 19                         load.z32
	<.main+13341 @067b19>: 04 3a 00 00                jmp <.main+13399 @067b53>
	cmplStd/test/lang/stmt.for.ci:25: (16 bytes: <.main+13345 @067b1d> - <.main+13361 @067b2d>): if (i > 2)
	<.main+13345 @067b1d>: 10 00                      dup.x32 sp(0)
	<.main+13347 @067b1f>: 1c 02 00 00 00             load.c32 2
	<.main+13352 @067b24>: 59                         cgt.i32
	<.main+13353 @067b25>: 06 08 00 00                jz <.main+13361 @067b2d>
	cmplStd/test/lang/stmt.for.ci:26: (4 bytes: <.main+13357 @067b29> - <.main+13361 @067b2d>): break;
	<.main+13357 @067b29>: 04 36 00 00                jmp <.main+13411 @067b5f>
	cmplStd/test/lang/stmt.for.ci:28: (34 bytes: <.main+13361 @067b2d> - <.main+13395 @067b4f>): debug("for with break", i);
	<.main+13361 @067b2d>: 1f 40 e1 05 00             load.ref <@05e140> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13366 @067b32>: 1c 1c 00 00 00             load.c32 28
	<.main+13371 @067b37>: 1c 0e 00 00 00             load.c32 14
	<.main+13376 @067b3c>: 19                         load.z32
	<.main+13377 @067b3d>: 1f cc e1 05 00             load.ref <@05e1cc> ;"for with break"
	<.main+13382 @067b42>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13387 @067b47>: 0a 18 00 00                load.sp(+24)
	<.main+13391 @067b4b>: 01 0b 00 00                nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:24: (4 bytes: <.main+13395 @067b4f> - <.main+13399 @067b53>): i := i + 1
	<.main+13395 @067b4f>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:24: (12 bytes: <.main+13399 @067b53> - <.main+13411 @067b5f>): i < 7
	<.main+13399 @067b53>: 10 00                      dup.x32 sp(0)
	<.main+13401 @067b55>: 1c 07 00 00 00             load.c32 7
	<.main+13406 @067b5a>: 58                         clt.i32
	<.main+13407 @067b5b>: 05 c2 ff ff                jnz <.main+13345 @067b1d>
	<.main+13411 @067b5f>: 09 fc ff ff                inc.sp(-4)
	<.main+13415 @067b63>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 2620.44] > .main
[ 2620.51]  > float32.sin(x: float32): float32
[ 2620.57]  < return
[ 2620.97]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2621.03]  < return
[ 2621.07]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2621.11]  < return
[ 2621.15]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2621.20]  < return
[ 2621.24]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2621.28]  < return
[ 2621.32]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2621.37]  < return
[ 2621.41]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2621.45]  < return
[ 2621.49]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2621.54]  < return
[ 2621.58]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2621.62]  < return
[ 2621.66]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2621.71]  < return
[ 2621.75]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2621.79]  < return
[ 2621.83]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2621.88]  < return
[ 2621.91]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2621.97]  < return
[ 2622.00]  > float64.sin(x: float64): float64
[ 2622.07]  < return
[ 2622.12]  > float64.cos(x: float64): float64
[ 2622.17]  < return
[ 2622.21]  > float64.tan(x: float64): float64
[ 2622.26]  < return
[ 2622.30]  > float64.log(x: float64): float64
[ 2622.36]  < return
[ 2622.39]  > float64.exp(x: float64): float64
[ 2622.44]  < return
[ 2622.48]  > float64.pow(x: float64, y: float64): float64
[ 2622.53]  < return
[ 2622.57]  > float64.sqrt(x: float64): float64
[ 2622.62]  < return
[ 2622.66]  > float64.atan2(x: float64, y: float64): float64
[ 2622.72]  < return
[ 2622.76]  > float32.sin(x: float32): float32
[ 2622.81]  < return
[ 2622.85]  > float32.cos(x: float32): float32
[ 2622.90]  < return
[ 2622.94]  > float32.tan(x: float32): float32
[ 2622.99]  < return
[ 2623.03]  > float32.log(x: float32): float32
[ 2623.08]  < return
[ 2623.12]  > float32.exp(x: float32): float32
[ 2623.16]  < return
[ 2623.21]  > float32.pow(x: float32, y: float32): float32
[ 2623.25]  < return
[ 2623.30]  > float32.sqrt(x: float32): float32
[ 2623.34]  < return
[ 2623.38]  > float32.atan2(x: float32, y: float32): float32
[ 2623.43]  < return
[ 2623.47]  > uint32.pop(value: int32): int32
[ 2623.52]  < return
[ 2623.56]  > uint32.swap(value: int32): int32
[ 2623.61]  < return
[ 2623.65]  > uint32.bsr(value: int32): int32
[ 2623.70]  < return
[ 2623.74]  > uint32.bsf(value: int32): int32
[ 2623.78]  < return
[ 2623.82]  > uint32.hib(value: int32): int32
[ 2623.87]  < return
[ 2623.91]  > uint32.lob(value: int32): int32
[ 2623.96]  < return
[ 2624.00]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 2624.05]  < return
[ 2624.09]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 2624.13]  < return
[ 2624.18]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 2624.22]  < return
[ 2624.26]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 2624.31]  < return
[ 2624.35]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2624.41]  < return
[ 2624.45]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2624.51]  < return
[ 2624.55]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2624.60]  < return
[ 2624.64]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2624.69]  < return
[ 2624.73]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2624.77]   > noError(ptr: pointer): void
[ 2624.82]   < return
[ 2624.86]   > halt(): void
[ 2624.90]   < return
[ 2624.94]  < return
[ 2624.98]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2625.03]  < return
[ 2625.07]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2625.11]   > stackOverflow(ptr: pointer): void
[ 2625.16]    > stackOverflow(ptr: pointer): void
[ 2625.20]     > stackOverflow(ptr: pointer): void
[ 2625.25]      > stackOverflow(ptr: pointer): void
[ 2625.29]       > stackOverflow(ptr: pointer): void
[ 2625.33]        > stackOverflow(ptr: pointer): void
[ 2625.38]         > stackOverflow(ptr: pointer): void
[ 2625.42]          > stackOverflow(ptr: pointer): void
[ 2625.47]           > stackOverflow(ptr: pointer): void
[ 2625.51]            > stackOverflow(ptr: pointer): void
[ 2625.55]             > stackOverflow(ptr: pointer): void
[ 2625.59]              > stackOverflow(ptr: pointer): void
[ 2625.64]               > stackOverflow(ptr: pointer): void
[ 2625.68]                > stackOverflow(ptr: pointer): void
[ 2625.72]                 > stackOverflow(ptr: pointer): void
[ 2625.77]                  > stackOverflow(ptr: pointer): void
[ 2625.81]                   > stackOverflow(ptr: pointer): void
[ 2625.85]                    > stackOverflow(ptr: pointer): void
[ 2625.90]                     > stackOverflow(ptr: pointer): void
[ 2625.94]                      > stackOverflow(ptr: pointer): void
[ 2625.98]                       > stackOverflow(ptr: pointer): void
[ 2626.03]                        > stackOverflow(ptr: pointer): void
[ 2626.07]                         > stackOverflow(ptr: pointer): void
[ 2626.13]                          > stackOverflow(ptr: pointer): void
[ 2626.18]                           > stackOverflow(ptr: pointer): void
[ 2626.23]                            > stackOverflow(ptr: pointer): void
[ 2626.26]                             > stackOverflow(ptr: pointer): void
[ 2626.30]                              > stackOverflow(ptr: pointer): void
[ 2626.33]                               > stackOverflow(ptr: pointer): void
[ 2626.36]                                > stackOverflow(ptr: pointer): void
[ 2626.40]                                 > stackOverflow(ptr: pointer): void
[ 2626.44]                                  > stackOverflow(ptr: pointer): void
[ 2626.47]                                   > stackOverflow(ptr: pointer): void
[ 2626.51]                                    > stackOverflow(ptr: pointer): void
[ 2626.54]                                     > stackOverflow(ptr: pointer): void
[ 2626.57]                                      > stackOverflow(ptr: pointer): void
[ 2626.61]                                       > stackOverflow(ptr: pointer): void
[ 2626.64]                                        > stackOverflow(ptr: pointer): void
[ 2626.67]                                         > stackOverflow(ptr: pointer): void
[ 2626.71]                                          > stackOverflow(ptr: pointer): void
[ 2626.74]                                           > stackOverflow(ptr: pointer): void
[ 2626.77]                                            > stackOverflow(ptr: pointer): void
[ 2626.81]                                             > stackOverflow(ptr: pointer): void
[ 2626.84]                                              > stackOverflow(ptr: pointer): void
[ 2626.89]                                               > stackOverflow(ptr: pointer): void
[ 2626.95]                                                > stackOverflow(ptr: pointer): void
[ 2626.99]                                                 > stackOverflow(ptr: pointer): void
[ 2627.04]                                                  > stackOverflow(ptr: pointer): void
[ 2627.09]                                                   > stackOverflow(ptr: pointer): void
[ 2627.14]                                                    > stackOverflow(ptr: pointer): void
[ 2627.19]                                                     > stackOverflow(ptr: pointer): void
[ 2627.24]                                                      > stackOverflow(ptr: pointer): void
[ 2627.29]                                                       > stackOverflow(ptr: pointer): void
[ 2627.34]                                                        > stackOverflow(ptr: pointer): void
[ 2627.39]                                                         > stackOverflow(ptr: pointer): void
[ 2627.44]                                                          > stackOverflow(ptr: pointer): void
[ 2627.49]                                                           > stackOverflow(ptr: pointer): void
[ 2627.54]                                                            > stackOverflow(ptr: pointer): void
[ 2627.59]                                                             > stackOverflow(ptr: pointer): void
[ 2627.64]                                                              > stackOverflow(ptr: pointer): void
[ 2627.69]                                                               > stackOverflow(ptr: pointer): void
[ 2627.74]                                                                > stackOverflow(ptr: pointer): void
[ 2627.79]                                                                 > stackOverflow(ptr: pointer): void
[ 2627.84]                                                                  > stackOverflow(ptr: pointer): void
[ 2627.89]                                                                   > stackOverflow(ptr: pointer): void
[ 2627.94]                                                                    > stackOverflow(ptr: pointer): void
[ 2627.99]                                                                     > stackOverflow(ptr: pointer): void
[ 2628.05]                                                                      > stackOverflow(ptr: pointer): void
[ 2628.11]                                                                       > stackOverflow(ptr: pointer): void
[ 2628.16]                                                                        > stackOverflow(ptr: pointer): void
[ 2628.21]                                                                         > stackOverflow(ptr: pointer): void
[ 2628.26]                                                                          > stackOverflow(ptr: pointer): void
[ 2628.32]                                                                           > stackOverflow(ptr: pointer): void
[ 2628.37]                                                                            > stackOverflow(ptr: pointer): void
[ 2628.42]                                                                             > stackOverflow(ptr: pointer): void
[ 2628.47]                                                                              > stackOverflow(ptr: pointer): void
[ 2628.52]                                                                               > stackOverflow(ptr: pointer): void
[ 2628.57]                                                                                > stackOverflow(ptr: pointer): void
[ 2628.61]                                                                                 > stackOverflow(ptr: pointer): void
[ 2628.66]                                                                                  > stackOverflow(ptr: pointer): void
[ 2628.71]                                                                                   > stackOverflow(ptr: pointer): void
[ 2628.76]                                                                                    > stackOverflow(ptr: pointer): void
[ 2628.81]                                                                                     > stackOverflow(ptr: pointer): void
[ 2628.86]                                                                                      > stackOverflow(ptr: pointer): void
[ 2628.91]                                                                                       > stackOverflow(ptr: pointer): void
[ 2628.95]                                                                                        > stackOverflow(ptr: pointer): void
[ 2628.98]                                                                                         > stackOverflow(ptr: pointer): void
[ 2629.01]                                                                                          > stackOverflow(ptr: pointer): void
[ 2629.04]                                                                                           > stackOverflow(ptr: pointer): void
[ 2629.07]                                                                                            > stackOverflow(ptr: pointer): void
[ 2629.11]                                                                                             > stackOverflow(ptr: pointer): void
[ 2629.18]                                                                                              > stackOverflow(ptr: pointer): void
[ 2629.21]                                                                                               > stackOverflow(ptr: pointer): void
[ 2629.24]                                                                                                > stackOverflow(ptr: pointer): void
[ 2629.28]                                                                                                 > stackOverflow(ptr: pointer): void
[ 2629.31]                                                                                                  > stackOverflow(ptr: pointer): void
[ 2629.34]                                                                                                   > stackOverflow(ptr: pointer): void
[ 2629.37]                                                                                                    > stackOverflow(ptr: pointer): void
[ 2629.41]                                                                                                     > stackOverflow(ptr: pointer): void
[ 2629.44]                                                                                                      > stackOverflow(ptr: pointer): void
[ 2629.48]                                                                                                       > stackOverflow(ptr: pointer): void
[ 2629.51]                                                                                                        > stackOverflow(ptr: pointer): void
[ 2629.54]                                                                                                         > stackOverflow(ptr: pointer): void
[ 2629.57]                                                                                                          > stackOverflow(ptr: pointer): void
[ 2629.61]                                                                                                           > stackOverflow(ptr: pointer): void
[ 2629.66]                                                                                                            > stackOverflow(ptr: pointer): void
[ 2629.70]                                                                                                             > stackOverflow(ptr: pointer): void
[ 2629.75]                                                                                                              > stackOverflow(ptr: pointer): void
[ 2629.79]                                                                                                               > stackOverflow(ptr: pointer): void
[ 2629.84]                                                                                                                > stackOverflow(ptr: pointer): void
[ 2629.90]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 2629.94]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 2629.98]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 2630.03]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 2630.07]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 2630.13]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 2630.17]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 2630.22]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 2630.26]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 2630.30]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 2630.36]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 2630.40]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 2630.45]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 2630.49]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 2630.55]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 2630.60]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 2630.64]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 2630.68]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 2630.73]                                                                                                                                  < return
[ 2630.77]                                                                                                                                 < return
[ 2630.82]                                                                                                                                < return
[ 2630.85]                                                                                                                               < return
[ 2630.89]                                                                                                                              < return
[ 2630.94]                                                                                                                             < return
[ 2630.98]                                                                                                                            < return
[ 2631.02]                                                                                                                           < return
[ 2631.06]                                                                                                                          < return
[ 2631.10]                                                                                                                         < return
[ 2631.14]                                                                                                                        < return
[ 2631.18]                                                                                                                       < return
[ 2631.22]                                                                                                                      < return
[ 2631.26]                                                                                                                     < return
[ 2631.30]                                                                                                                    < return
[ 2631.34]                                                                                                                   < return
[ 2631.37]                                                                                                                  < return
[ 2631.41]                                                                                                                 < return
[ 2631.44]                                                                                                                < return
[ 2631.48]                                                                                                               < return
[ 2631.51]                                                                                                              < return
[ 2631.55]                                                                                                             < return
[ 2631.58]                                                                                                            < return
[ 2631.62]                                                                                                           < return
[ 2631.65]                                                                                                          < return
[ 2631.71]                                                                                                         < return
[ 2631.74]                                                                                                        < return
[ 2631.78]                                                                                                       < return
[ 2631.82]                                                                                                      < return
[ 2631.86]                                                                                                     < return
[ 2631.90]                                                                                                    < return
[ 2631.95]                                                                                                   < return
[ 2631.99]                                                                                                  < return
[ 2632.03]                                                                                                 < return
[ 2632.08]                                                                                                < return
[ 2632.12]                                                                                               < return
[ 2632.17]                                                                                              < return
[ 2632.20]                                                                                             < return
[ 2632.24]                                                                                            < return
[ 2632.28]                                                                                           < return
[ 2632.32]                                                                                          < return
[ 2632.37]                                                                                         < return
[ 2632.41]                                                                                        < return
[ 2632.45]                                                                                       < return
[ 2632.49]                                                                                      < return
[ 2632.53]                                                                                     < return
[ 2632.58]                                                                                    < return
[ 2632.62]                                                                                   < return
[ 2632.65]                                                                                  < return
[ 2632.70]                                                                                 < return
[ 2632.73]                                                                                < return
[ 2632.78]                                                                               < return
[ 2632.82]                                                                              < return
[ 2632.86]                                                                             < return
[ 2632.90]                                                                            < return
[ 2632.94]                                                                           < return
[ 2632.99]                                                                          < return
[ 2633.03]                                                                         < return
[ 2633.07]                                                                        < return
[ 2633.11]                                                                       < return
[ 2633.15]                                                                      < return
[ 2633.20]                                                                     < return
[ 2633.24]                                                                    < return
[ 2633.28]                                                                   < return
[ 2633.34]                                                                  < return
[ 2633.38]                                                                 < return
[ 2633.43]                                                                < return
[ 2633.46]                                                               < return
[ 2633.50]                                                              < return
[ 2633.54]                                                             < return
[ 2633.58]                                                            < return
[ 2633.63]                                                           < return
[ 2633.66]                                                          < return
[ 2633.70]                                                         < return
[ 2633.74]                                                        < return
[ 2633.79]                                                       < return
[ 2633.84]                                                      < return
[ 2633.88]                                                     < return
[ 2633.92]                                                    < return
[ 2633.96]                                                   < return
[ 2634.00]                                                  < return
[ 2634.05]                                                 < return
[ 2634.09]                                                < return
[ 2634.13]                                               < return
[ 2634.17]                                              < return
[ 2634.22]                                             < return
[ 2634.26]                                            < return
[ 2634.30]                                           < return
[ 2634.34]                                          < return
[ 2634.39]                                         < return
[ 2634.43]                                        < return
[ 2634.47]                                       < return
[ 2634.51]                                      < return
[ 2634.55]                                     < return
[ 2634.59]                                    < return
[ 2634.63]                                   < return
[ 2634.67]                                  < return
[ 2634.71]                                 < return
[ 2634.75]                                < return
[ 2634.79]                               < return
[ 2634.83]                              < return
[ 2634.88]                             < return
[ 2634.92]                            < return
[ 2634.96]                           < return
[ 2635.00]                          < return
[ 2635.05]                         < return
[ 2635.09]                        < return
[ 2635.13]                       < return
[ 2635.17]                      < return
[ 2635.21]                     < return
[ 2635.24]                    < return
[ 2635.29]                   < return
[ 2635.33]                  < return
[ 2635.37]                 < return
[ 2635.47]                < return
[ 2635.50]               < return
[ 2635.55]              < return
[ 2635.60]             < return
[ 2635.64]            < return
[ 2635.68]           < return
[ 2635.72]          < return
[ 2635.77]         < return
[ 2635.81]        < return
[ 2635.85]       < return
[ 2635.89]      < return
[ 2635.93]     < return
[ 2635.97]    < return
[ 2636.01]   < return
[ 2636.05]  < return
[ 2636.09]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2636.13]   > divisionByZero(args: pointer): void
[ 2636.18]   < return
[ 2636.22]  < return
[ 2636.26]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2636.31]   > invalidInstruction(args: pointer): void
[ 2636.38]   < return
[ 2636.41]  < return
[ 2636.46]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2636.50]   > invalidMemoryAccess(args: pointer): void
[ 2636.55]   < return
[ 2636.58]  < return
[ 2636.64]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 2636.68]   > abortExecution(args: pointer): void
[ 2636.75]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/tryExec.ci:35: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	cmplStd/test/std/tryExec.ci:53: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 2637.71]    < return
[ 2637.76]   < return
[ 2637.80]  < return
[ 2637.96]  > object.create(type: typename): pointer
[ 2638.02]  < return
[ 2638.07]  > object.create(type: typename): pointer
[ 2638.13]  < return
[ 2638.18]  > funAdd(x: int32, y: int32): int32
[ 2638.23]  < return
[ 2638.28]  > funAdd(x: int32, y: int32): int32
[ 2638.32]  < return
[ 2638.37]  > funMul(x: int32, y: int32): int32
[ 2638.42]  < return
[ 2638.47]  > funMul(x: int32, y: int32): int32
[ 2638.52]  < return
[ 2638.56]  > fib(n: uint32): uint32
[ 2638.61]   > fib(n: uint32): uint32
[ 2638.67]    > fib(n: uint32): uint32
[ 2638.71]     > fib(n: uint32): uint32
[ 2638.76]      > fib(n: uint32): uint32
[ 2638.81]       > fib(n: uint32): uint32
[ 2638.86]        > fib(n: uint32): uint32
[ 2638.92]         > fib(n: uint32): uint32
[ 2638.96]          > fib(n: uint32): uint32
[ 2639.02]           > fib(n: uint32): uint32
[ 2639.07]            > fib(n: uint32): uint32
[ 2639.12]             > fib(n: uint32): uint32
[ 2639.17]              > fib(n: uint32): uint32
[ 2639.21]              < return
[ 2639.26]              > fib(n: uint32): uint32
[ 2639.31]              < return
[ 2639.37]             < return
[ 2639.42]             > fib(n: uint32): uint32
[ 2639.47]             < return
[ 2639.51]            < return
[ 2639.55]            > fib(n: uint32): uint32
[ 2639.62]             > fib(n: uint32): uint32
[ 2639.66]             < return
[ 2639.70]             > fib(n: uint32): uint32
[ 2639.75]             < return
[ 2639.79]            < return
[ 2639.82]           < return
[ 2639.86]           > fib(n: uint32): uint32
[ 2639.90]            > fib(n: uint32): uint32
[ 2639.94]             > fib(n: uint32): uint32
[ 2639.99]             < return
[ 2640.02]             > fib(n: uint32): uint32
[ 2640.07]             < return
[ 2640.10]            < return
[ 2640.14]            > fib(n: uint32): uint32
[ 2640.18]            < return
[ 2640.22]           < return
[ 2640.26]          < return
[ 2640.29]          > fib(n: uint32): uint32
[ 2640.34]           > fib(n: uint32): uint32
[ 2640.38]            > fib(n: uint32): uint32
[ 2640.42]             > fib(n: uint32): uint32
[ 2640.46]             < return
[ 2640.50]             > fib(n: uint32): uint32
[ 2640.53]             < return
[ 2640.57]            < return
[ 2640.61]            > fib(n: uint32): uint32
[ 2640.65]            < return
[ 2640.69]           < return
[ 2640.73]           > fib(n: uint32): uint32
[ 2640.77]            > fib(n: uint32): uint32
[ 2640.82]            < return
[ 2640.85]            > fib(n: uint32): uint32
[ 2640.89]            < return
[ 2640.93]           < return
[ 2640.97]          < return
[ 2641.00]         < return
[ 2641.04]         > fib(n: uint32): uint32
[ 2641.09]          > fib(n: uint32): uint32
[ 2641.13]           > fib(n: uint32): uint32
[ 2641.18]            > fib(n: uint32): uint32
[ 2641.22]             > fib(n: uint32): uint32
[ 2641.26]             < return
[ 2641.30]             > fib(n: uint32): uint32
[ 2641.34]             < return
[ 2641.38]            < return
[ 2641.42]            > fib(n: uint32): uint32
[ 2641.46]            < return
[ 2641.50]           < return
[ 2641.53]           > fib(n: uint32): uint32
[ 2641.58]            > fib(n: uint32): uint32
[ 2641.62]            < return
[ 2641.66]            > fib(n: uint32): uint32
[ 2641.70]            < return
[ 2641.74]           < return
[ 2641.77]          < return
[ 2641.81]          > fib(n: uint32): uint32
[ 2641.87]           > fib(n: uint32): uint32
[ 2641.91]            > fib(n: uint32): uint32
[ 2641.96]            < return
[ 2641.99]            > fib(n: uint32): uint32
[ 2642.06]            < return
[ 2642.09]           < return
[ 2642.12]           > fib(n: uint32): uint32
[ 2642.17]           < return
[ 2642.20]          < return
[ 2642.24]         < return
[ 2642.28]        < return
[ 2642.33]        > fib(n: uint32): uint32
[ 2642.37]         > fib(n: uint32): uint32
[ 2642.42]          > fib(n: uint32): uint32
[ 2642.46]           > fib(n: uint32): uint32
[ 2642.51]            > fib(n: uint32): uint32
[ 2642.55]             > fib(n: uint32): uint32
[ 2642.60]             < return
[ 2642.64]             > fib(n: uint32): uint32
[ 2642.68]             < return
[ 2642.72]            < return
[ 2642.76]            > fib(n: uint32): uint32
[ 2642.80]            < return
[ 2642.84]           < return
[ 2642.87]           > fib(n: uint32): uint32
[ 2642.92]            > fib(n: uint32): uint32
[ 2642.96]            < return
[ 2643.00]            > fib(n: uint32): uint32
[ 2643.05]            < return
[ 2643.08]           < return
[ 2643.12]          < return
[ 2643.16]          > fib(n: uint32): uint32
[ 2643.20]           > fib(n: uint32): uint32
[ 2643.25]            > fib(n: uint32): uint32
[ 2643.29]            < return
[ 2643.33]            > fib(n: uint32): uint32
[ 2643.37]            < return
[ 2643.41]           < return
[ 2643.45]           > fib(n: uint32): uint32
[ 2643.49]           < return
[ 2643.53]          < return
[ 2643.56]         < return
[ 2643.60]         > fib(n: uint32): uint32
[ 2643.65]          > fib(n: uint32): uint32
[ 2643.69]           > fib(n: uint32): uint32
[ 2643.76]            > fib(n: uint32): uint32
[ 2643.80]            < return
[ 2643.84]            > fib(n: uint32): uint32
[ 2643.89]            < return
[ 2643.92]           < return
[ 2643.97]           > fib(n: uint32): uint32
[ 2644.02]           < return
[ 2644.06]          < return
[ 2644.10]          > fib(n: uint32): uint32
[ 2644.14]           > fib(n: uint32): uint32
[ 2644.19]           < return
[ 2644.23]           > fib(n: uint32): uint32
[ 2644.28]           < return
[ 2644.31]          < return
[ 2644.36]         < return
[ 2644.40]        < return
[ 2644.44]       < return
[ 2644.48]       > fib(n: uint32): uint32
[ 2644.53]        > fib(n: uint32): uint32
[ 2644.57]         > fib(n: uint32): uint32
[ 2644.62]          > fib(n: uint32): uint32
[ 2644.69]           > fib(n: uint32): uint32
[ 2644.73]            > fib(n: uint32): uint32
[ 2644.78]             > fib(n: uint32): uint32
[ 2644.83]             < return
[ 2644.87]             > fib(n: uint32): uint32
[ 2644.92]             < return
[ 2644.96]            < return
[ 2645.00]            > fib(n: uint32): uint32
[ 2645.04]            < return
[ 2645.08]           < return
[ 2645.12]           > fib(n: uint32): uint32
[ 2645.16]            > fib(n: uint32): uint32
[ 2645.21]            < return
[ 2645.25]            > fib(n: uint32): uint32
[ 2645.30]            < return
[ 2645.34]           < return
[ 2645.38]          < return
[ 2645.42]          > fib(n: uint32): uint32
[ 2645.46]           > fib(n: uint32): uint32
[ 2645.51]            > fib(n: uint32): uint32
[ 2645.56]            < return
[ 2645.60]            > fib(n: uint32): uint32
[ 2645.64]            < return
[ 2645.68]           < return
[ 2645.72]           > fib(n: uint32): uint32
[ 2645.77]           < return
[ 2645.80]          < return
[ 2645.84]         < return
[ 2645.88]         > fib(n: uint32): uint32
[ 2645.93]          > fib(n: uint32): uint32
[ 2645.98]           > fib(n: uint32): uint32
[ 2646.03]            > fib(n: uint32): uint32
[ 2646.07]            < return
[ 2646.11]            > fib(n: uint32): uint32
[ 2646.16]            < return
[ 2646.20]           < return
[ 2646.24]           > fib(n: uint32): uint32
[ 2646.28]           < return
[ 2646.32]          < return
[ 2646.36]          > fib(n: uint32): uint32
[ 2646.41]           > fib(n: uint32): uint32
[ 2646.48]           < return
[ 2646.52]           > fib(n: uint32): uint32
[ 2646.57]           < return
[ 2646.61]          < return
[ 2646.65]         < return
[ 2646.70]        < return
[ 2646.74]        > fib(n: uint32): uint32
[ 2646.79]         > fib(n: uint32): uint32
[ 2646.83]          > fib(n: uint32): uint32
[ 2646.88]           > fib(n: uint32): uint32
[ 2646.93]            > fib(n: uint32): uint32
[ 2646.97]            < return
[ 2647.01]            > fib(n: uint32): uint32
[ 2647.07]            < return
[ 2647.11]           < return
[ 2647.15]           > fib(n: uint32): uint32
[ 2647.20]           < return
[ 2647.23]          < return
[ 2647.27]          > fib(n: uint32): uint32
[ 2647.31]           > fib(n: uint32): uint32
[ 2647.35]           < return
[ 2647.38]           > fib(n: uint32): uint32
[ 2647.41]           < return
[ 2647.44]          < return
[ 2647.46]         < return
[ 2647.49]         > fib(n: uint32): uint32
[ 2647.53]          > fib(n: uint32): uint32
[ 2647.56]           > fib(n: uint32): uint32
[ 2647.60]           < return
[ 2647.63]           > fib(n: uint32): uint32
[ 2647.66]           < return
[ 2647.69]          < return
[ 2647.72]          > fib(n: uint32): uint32
[ 2647.75]          < return
[ 2647.78]         < return
[ 2647.80]        < return
[ 2647.83]       < return
[ 2647.86]      < return
[ 2647.92]      > fib(n: uint32): uint32
[ 2647.99]       > fib(n: uint32): uint32
[ 2648.05]        > fib(n: uint32): uint32
[ 2648.11]         > fib(n: uint32): uint32
[ 2648.16]          > fib(n: uint32): uint32
[ 2648.21]           > fib(n: uint32): uint32
[ 2648.26]            > fib(n: uint32): uint32
[ 2648.32]             > fib(n: uint32): uint32
[ 2648.37]             < return
[ 2648.41]             > fib(n: uint32): uint32
[ 2648.46]             < return
[ 2648.51]            < return
[ 2648.55]            > fib(n: uint32): uint32
[ 2648.61]            < return
[ 2648.66]           < return
[ 2648.70]           > fib(n: uint32): uint32
[ 2648.76]            > fib(n: uint32): uint32
[ 2648.81]            < return
[ 2648.85]            > fib(n: uint32): uint32
[ 2648.91]            < return
[ 2648.95]           < return
[ 2648.99]          < return
[ 2649.04]          > fib(n: uint32): uint32
[ 2649.09]           > fib(n: uint32): uint32
[ 2649.15]            > fib(n: uint32): uint32
[ 2649.20]            < return
[ 2649.24]            > fib(n: uint32): uint32
[ 2649.30]            < return
[ 2649.34]           < return
[ 2649.38]           > fib(n: uint32): uint32
[ 2649.44]           < return
[ 2649.48]          < return
[ 2649.53]         < return
[ 2649.57]         > fib(n: uint32): uint32
[ 2649.63]          > fib(n: uint32): uint32
[ 2649.69]           > fib(n: uint32): uint32
[ 2649.75]            > fib(n: uint32): uint32
[ 2649.80]            < return
[ 2649.86]            > fib(n: uint32): uint32
[ 2649.91]            < return
[ 2649.95]           < return
[ 2650.00]           > fib(n: uint32): uint32
[ 2650.05]           < return
[ 2650.09]          < return
[ 2650.14]          > fib(n: uint32): uint32
[ 2650.19]           > fib(n: uint32): uint32
[ 2650.24]           < return
[ 2650.29]           > fib(n: uint32): uint32
[ 2650.34]           < return
[ 2650.38]          < return
[ 2650.43]         < return
[ 2650.47]        < return
[ 2650.52]        > fib(n: uint32): uint32
[ 2650.57]         > fib(n: uint32): uint32
[ 2650.62]          > fib(n: uint32): uint32
[ 2650.68]           > fib(n: uint32): uint32
[ 2650.73]            > fib(n: uint32): uint32
[ 2650.78]            < return
[ 2650.82]            > fib(n: uint32): uint32
[ 2650.86]            < return
[ 2650.89]           < return
[ 2650.92]           > fib(n: uint32): uint32
[ 2650.95]           < return
[ 2650.98]          < return
[ 2651.01]          > fib(n: uint32): uint32
[ 2651.04]           > fib(n: uint32): uint32
[ 2651.07]           < return
[ 2651.10]           > fib(n: uint32): uint32
[ 2651.13]           < return
[ 2651.16]          < return
[ 2651.19]         < return
[ 2651.21]         > fib(n: uint32): uint32
[ 2651.25]          > fib(n: uint32): uint32
[ 2651.28]           > fib(n: uint32): uint32
[ 2651.32]           < return
[ 2651.34]           > fib(n: uint32): uint32
[ 2651.38]           < return
[ 2651.41]          < return
[ 2651.44]          > fib(n: uint32): uint32
[ 2651.48]          < return
[ 2651.52]         < return
[ 2651.56]        < return
[ 2651.60]       < return
[ 2651.64]       > fib(n: uint32): uint32
[ 2651.69]        > fib(n: uint32): uint32
[ 2651.74]         > fib(n: uint32): uint32
[ 2651.79]          > fib(n: uint32): uint32
[ 2651.83]           > fib(n: uint32): uint32
[ 2651.89]            > fib(n: uint32): uint32
[ 2651.93]            < return
[ 2651.97]            > fib(n: uint32): uint32
[ 2652.02]            < return
[ 2652.06]           < return
[ 2652.10]           > fib(n: uint32): uint32
[ 2652.14]           < return
[ 2652.18]          < return
[ 2652.22]          > fib(n: uint32): uint32
[ 2652.26]           > fib(n: uint32): uint32
[ 2652.32]           < return
[ 2652.36]           > fib(n: uint32): uint32
[ 2652.42]           < return
[ 2652.45]          < return
[ 2652.49]         < return
[ 2652.52]         > fib(n: uint32): uint32
[ 2652.57]          > fib(n: uint32): uint32
[ 2652.61]           > fib(n: uint32): uint32
[ 2652.65]           < return
[ 2652.69]           > fib(n: uint32): uint32
[ 2652.74]           < return
[ 2652.77]          < return
[ 2652.81]          > fib(n: uint32): uint32
[ 2652.86]          < return
[ 2652.90]         < return
[ 2652.93]        < return
[ 2652.97]        > fib(n: uint32): uint32
[ 2653.02]         > fib(n: uint32): uint32
[ 2653.07]          > fib(n: uint32): uint32
[ 2653.11]           > fib(n: uint32): uint32
[ 2653.16]           < return
[ 2653.20]           > fib(n: uint32): uint32
[ 2653.24]           < return
[ 2653.28]          < return
[ 2653.31]          > fib(n: uint32): uint32
[ 2653.36]          < return
[ 2653.40]         < return
[ 2653.43]         > fib(n: uint32): uint32
[ 2653.48]          > fib(n: uint32): uint32
[ 2653.53]          < return
[ 2653.56]          > fib(n: uint32): uint32
[ 2653.61]          < return
[ 2653.64]         < return
[ 2653.68]        < return
[ 2653.72]       < return
[ 2653.75]      < return
[ 2653.79]     < return
[ 2653.83]     > fib(n: uint32): uint32
[ 2653.87]      > fib(n: uint32): uint32
[ 2653.92]       > fib(n: uint32): uint32
[ 2653.96]        > fib(n: uint32): uint32
[ 2654.01]         > fib(n: uint32): uint32
[ 2654.05]          > fib(n: uint32): uint32
[ 2654.12]           > fib(n: uint32): uint32
[ 2654.16]            > fib(n: uint32): uint32
[ 2654.21]             > fib(n: uint32): uint32
[ 2654.25]             < return
[ 2654.29]             > fib(n: uint32): uint32
[ 2654.34]             < return
[ 2654.37]            < return
[ 2654.41]            > fib(n: uint32): uint32
[ 2654.45]            < return
[ 2654.49]           < return
[ 2654.53]           > fib(n: uint32): uint32
[ 2654.58]            > fib(n: uint32): uint32
[ 2654.63]            < return
[ 2654.67]            > fib(n: uint32): uint32
[ 2654.72]            < return
[ 2654.76]           < return
[ 2654.80]          < return
[ 2654.83]          > fib(n: uint32): uint32
[ 2654.88]           > fib(n: uint32): uint32
[ 2654.93]            > fib(n: uint32): uint32
[ 2654.99]            < return
[ 2655.03]            > fib(n: uint32): uint32
[ 2655.07]            < return
[ 2655.11]           < return
[ 2655.15]           > fib(n: uint32): uint32
[ 2655.20]           < return
[ 2655.23]          < return
[ 2655.27]         < return
[ 2655.31]         > fib(n: uint32): uint32
[ 2655.35]          > fib(n: uint32): uint32
[ 2655.40]           > fib(n: uint32): uint32
[ 2655.45]            > fib(n: uint32): uint32
[ 2655.49]            < return
[ 2655.53]            > fib(n: uint32): uint32
[ 2655.57]            < return
[ 2655.61]           < return
[ 2655.65]           > fib(n: uint32): uint32
[ 2655.69]           < return
[ 2655.73]          < return
[ 2655.77]          > fib(n: uint32): uint32
[ 2655.81]           > fib(n: uint32): uint32
[ 2655.86]           < return
[ 2655.89]           > fib(n: uint32): uint32
[ 2655.94]           < return
[ 2655.98]          < return
[ 2656.03]         < return
[ 2656.07]        < return
[ 2656.11]        > fib(n: uint32): uint32
[ 2656.15]         > fib(n: uint32): uint32
[ 2656.20]          > fib(n: uint32): uint32
[ 2656.24]           > fib(n: uint32): uint32
[ 2656.29]            > fib(n: uint32): uint32
[ 2656.35]            < return
[ 2656.41]            > fib(n: uint32): uint32
[ 2656.45]            < return
[ 2656.49]           < return
[ 2656.53]           > fib(n: uint32): uint32
[ 2656.57]           < return
[ 2656.61]          < return
[ 2656.65]          > fib(n: uint32): uint32
[ 2656.70]           > fib(n: uint32): uint32
[ 2656.74]           < return
[ 2656.79]           > fib(n: uint32): uint32
[ 2656.83]           < return
[ 2656.87]          < return
[ 2656.91]         < return
[ 2656.94]         > fib(n: uint32): uint32
[ 2656.99]          > fib(n: uint32): uint32
[ 2657.03]           > fib(n: uint32): uint32
[ 2657.08]           < return
[ 2657.12]           > fib(n: uint32): uint32
[ 2657.17]           < return
[ 2657.21]          < return
[ 2657.28]          > fib(n: uint32): uint32
[ 2657.36]          < return
[ 2657.40]         < return
[ 2657.43]        < return
[ 2657.47]       < return
[ 2657.51]       > fib(n: uint32): uint32
[ 2657.55]        > fib(n: uint32): uint32
[ 2657.60]         > fib(n: uint32): uint32
[ 2657.64]          > fib(n: uint32): uint32
[ 2657.69]           > fib(n: uint32): uint32
[ 2657.74]            > fib(n: uint32): uint32
[ 2657.78]            < return
[ 2657.82]            > fib(n: uint32): uint32
[ 2657.87]            < return
[ 2657.90]           < return
[ 2657.95]           > fib(n: uint32): uint32
[ 2657.99]           < return
[ 2658.03]          < return
[ 2658.07]          > fib(n: uint32): uint32
[ 2658.11]           > fib(n: uint32): uint32
[ 2658.16]           < return
[ 2658.20]           > fib(n: uint32): uint32
[ 2658.24]           < return
[ 2658.28]          < return
[ 2658.32]         < return
[ 2658.35]         > fib(n: uint32): uint32
[ 2658.40]          > fib(n: uint32): uint32
[ 2658.45]           > fib(n: uint32): uint32
[ 2658.49]           < return
[ 2658.53]           > fib(n: uint32): uint32
[ 2658.57]           < return
[ 2658.61]          < return
[ 2658.65]          > fib(n: uint32): uint32
[ 2658.70]          < return
[ 2658.73]         < return
[ 2658.77]        < return
[ 2658.81]        > fib(n: uint32): uint32
[ 2658.85]         > fib(n: uint32): uint32
[ 2658.90]          > fib(n: uint32): uint32
[ 2658.95]           > fib(n: uint32): uint32
[ 2658.99]           < return
[ 2659.03]           > fib(n: uint32): uint32
[ 2659.07]           < return
[ 2659.11]          < return
[ 2659.15]          > fib(n: uint32): uint32
[ 2659.20]          < return
[ 2659.24]         < return
[ 2659.28]         > fib(n: uint32): uint32
[ 2659.33]          > fib(n: uint32): uint32
[ 2659.37]          < return
[ 2659.41]          > fib(n: uint32): uint32
[ 2659.45]          < return
[ 2659.49]         < return
[ 2659.53]        < return
[ 2659.57]       < return
[ 2659.60]      < return
[ 2659.64]      > fib(n: uint32): uint32
[ 2659.69]       > fib(n: uint32): uint32
[ 2659.73]        > fib(n: uint32): uint32
[ 2659.78]         > fib(n: uint32): uint32
[ 2659.82]          > fib(n: uint32): uint32
[ 2659.87]           > fib(n: uint32): uint32
[ 2659.91]            > fib(n: uint32): uint32
[ 2659.96]            < return
[ 2660.00]            > fib(n: uint32): uint32
[ 2660.07]            < return
[ 2660.10]           < return
[ 2660.14]           > fib(n: uint32): uint32
[ 2660.18]           < return
[ 2660.22]          < return
[ 2660.26]          > fib(n: uint32): uint32
[ 2660.32]           > fib(n: uint32): uint32
[ 2660.36]           < return
[ 2660.40]           > fib(n: uint32): uint32
[ 2660.45]           < return
[ 2660.49]          < return
[ 2660.53]         < return
[ 2660.57]         > fib(n: uint32): uint32
[ 2660.61]          > fib(n: uint32): uint32
[ 2660.66]           > fib(n: uint32): uint32
[ 2660.71]           < return
[ 2660.75]           > fib(n: uint32): uint32
[ 2660.81]           < return
[ 2660.84]          < return
[ 2660.88]          > fib(n: uint32): uint32
[ 2660.92]          < return
[ 2660.96]         < return
[ 2661.00]        < return
[ 2661.03]        > fib(n: uint32): uint32
[ 2661.08]         > fib(n: uint32): uint32
[ 2661.13]          > fib(n: uint32): uint32
[ 2661.17]           > fib(n: uint32): uint32
[ 2661.22]           < return
[ 2661.25]           > fib(n: uint32): uint32
[ 2661.30]           < return
[ 2661.33]          < return
[ 2661.37]          > fib(n: uint32): uint32
[ 2661.41]          < return
[ 2661.45]         < return
[ 2661.50]         > fib(n: uint32): uint32
[ 2661.55]          > fib(n: uint32): uint32
[ 2661.59]          < return
[ 2661.63]          > fib(n: uint32): uint32
[ 2661.67]          < return
[ 2661.71]         < return
[ 2661.76]        < return
[ 2661.80]       < return
[ 2661.83]       > fib(n: uint32): uint32
[ 2661.88]        > fib(n: uint32): uint32
[ 2661.92]         > fib(n: uint32): uint32
[ 2661.96]          > fib(n: uint32): uint32
[ 2662.01]           > fib(n: uint32): uint32
[ 2662.05]           < return
[ 2662.09]           > fib(n: uint32): uint32
[ 2662.13]           < return
[ 2662.17]          < return
[ 2662.20]          > fib(n: uint32): uint32
[ 2662.25]          < return
[ 2662.29]         < return
[ 2662.32]         > fib(n: uint32): uint32
[ 2662.37]          > fib(n: uint32): uint32
[ 2662.41]          < return
[ 2662.45]          > fib(n: uint32): uint32
[ 2662.49]          < return
[ 2662.53]         < return
[ 2662.57]        < return
[ 2662.61]        > fib(n: uint32): uint32
[ 2662.66]         > fib(n: uint32): uint32
[ 2662.71]          > fib(n: uint32): uint32
[ 2662.76]          < return
[ 2662.79]          > fib(n: uint32): uint32
[ 2662.84]          < return
[ 2662.88]         < return
[ 2662.92]         > fib(n: uint32): uint32
[ 2662.96]         < return
[ 2663.00]        < return
[ 2663.04]       < return
[ 2663.07]      < return
[ 2663.11]     < return
[ 2663.15]    < return
[ 2663.19]    > fib(n: uint32): uint32
[ 2663.27]     > fib(n: uint32): uint32
[ 2663.33]      > fib(n: uint32): uint32
[ 2663.39]       > fib(n: uint32): uint32
[ 2663.47]        > fib(n: uint32): uint32
[ 2663.52]         > fib(n: uint32): uint32
[ 2663.56]          > fib(n: uint32): uint32
[ 2663.64]           > fib(n: uint32): uint32
[ 2663.71]            > fib(n: uint32): uint32
[ 2663.77]             > fib(n: uint32): uint32
[ 2663.82]             < return
[ 2663.85]             > fib(n: uint32): uint32
[ 2663.90]             < return
[ 2663.94]            < return
[ 2663.97]            > fib(n: uint32): uint32
[ 2664.02]            < return
[ 2664.06]           < return
[ 2664.10]           > fib(n: uint32): uint32
[ 2664.15]            > fib(n: uint32): uint32
[ 2664.20]            < return
[ 2664.24]            > fib(n: uint32): uint32
[ 2664.30]            < return
[ 2664.34]           < return
[ 2664.40]          < return
[ 2664.45]          > fib(n: uint32): uint32
[ 2664.50]           > fib(n: uint32): uint32
[ 2664.55]            > fib(n: uint32): uint32
[ 2664.60]            < return
[ 2664.64]            > fib(n: uint32): uint32
[ 2664.68]            < return
[ 2664.72]           < return
[ 2664.76]           > fib(n: uint32): uint32
[ 2664.81]           < return
[ 2664.84]          < return
[ 2664.88]         < return
[ 2664.92]         > fib(n: uint32): uint32
[ 2664.97]          > fib(n: uint32): uint32
[ 2665.01]           > fib(n: uint32): uint32
[ 2665.06]            > fib(n: uint32): uint32
[ 2665.11]            < return
[ 2665.15]            > fib(n: uint32): uint32
[ 2665.20]            < return
[ 2665.25]           < return
[ 2665.29]           > fib(n: uint32): uint32
[ 2665.34]           < return
[ 2665.38]          < return
[ 2665.42]          > fib(n: uint32): uint32
[ 2665.48]           > fib(n: uint32): uint32
[ 2665.54]           < return
[ 2665.58]           > fib(n: uint32): uint32
[ 2665.64]           < return
[ 2665.68]          < return
[ 2665.72]         < return
[ 2665.79]        < return
[ 2665.83]        > fib(n: uint32): uint32
[ 2665.90]         > fib(n: uint32): uint32
[ 2665.96]          > fib(n: uint32): uint32
[ 2666.01]           > fib(n: uint32): uint32
[ 2666.10]            > fib(n: uint32): uint32
[ 2666.18]            < return
[ 2666.25]            > fib(n: uint32): uint32
[ 2666.32]            < return
[ 2666.36]           < return
[ 2666.40]           > fib(n: uint32): uint32
[ 2666.44]           < return
[ 2666.48]          < return
[ 2666.52]          > fib(n: uint32): uint32
[ 2666.57]           > fib(n: uint32): uint32
[ 2666.61]           < return
[ 2666.65]           > fib(n: uint32): uint32
[ 2666.69]           < return
[ 2666.73]          < return
[ 2666.77]         < return
[ 2666.81]         > fib(n: uint32): uint32
[ 2666.85]          > fib(n: uint32): uint32
[ 2666.90]           > fib(n: uint32): uint32
[ 2666.94]           < return
[ 2666.99]           > fib(n: uint32): uint32
[ 2667.07]           < return
[ 2667.11]          < return
[ 2667.15]          > fib(n: uint32): uint32
[ 2667.20]          < return
[ 2667.24]         < return
[ 2667.27]        < return
[ 2667.31]       < return
[ 2667.35]       > fib(n: uint32): uint32
[ 2667.40]        > fib(n: uint32): uint32
[ 2667.44]         > fib(n: uint32): uint32
[ 2667.49]          > fib(n: uint32): uint32
[ 2667.54]           > fib(n: uint32): uint32
[ 2667.59]            > fib(n: uint32): uint32
[ 2667.63]            < return
[ 2667.67]            > fib(n: uint32): uint32
[ 2667.73]            < return
[ 2667.78]           < return
[ 2667.82]           > fib(n: uint32): uint32
[ 2667.87]           < return
[ 2667.92]          < return
[ 2667.97]          > fib(n: uint32): uint32
[ 2668.03]           > fib(n: uint32): uint32
[ 2668.07]           < return
[ 2668.11]           > fib(n: uint32): uint32
[ 2668.16]           < return
[ 2668.20]          < return
[ 2668.24]         < return
[ 2668.28]         > fib(n: uint32): uint32
[ 2668.32]          > fib(n: uint32): uint32
[ 2668.37]           > fib(n: uint32): uint32
[ 2668.42]           < return
[ 2668.46]           > fib(n: uint32): uint32
[ 2668.50]           < return
[ 2668.54]          < return
[ 2668.58]          > fib(n: uint32): uint32
[ 2668.63]          < return
[ 2668.66]         < return
[ 2668.70]        < return
[ 2668.74]        > fib(n: uint32): uint32
[ 2668.78]         > fib(n: uint32): uint32
[ 2668.82]          > fib(n: uint32): uint32
[ 2668.86]           > fib(n: uint32): uint32
[ 2668.90]           < return
[ 2668.93]           > fib(n: uint32): uint32
[ 2668.96]           < return
[ 2668.99]          < return
[ 2669.02]          > fib(n: uint32): uint32
[ 2669.05]          < return
[ 2669.08]         < return
[ 2669.11]         > fib(n: uint32): uint32
[ 2669.14]          > fib(n: uint32): uint32
[ 2669.18]          < return
[ 2669.21]          > fib(n: uint32): uint32
[ 2669.24]          < return
[ 2669.27]         < return
[ 2669.30]        < return
[ 2669.33]       < return
[ 2669.35]      < return
[ 2669.38]      > fib(n: uint32): uint32
[ 2669.42]       > fib(n: uint32): uint32
[ 2669.50]        > fib(n: uint32): uint32
[ 2669.55]         > fib(n: uint32): uint32
[ 2669.61]          > fib(n: uint32): uint32
[ 2669.66]           > fib(n: uint32): uint32
[ 2669.72]            > fib(n: uint32): uint32
[ 2669.77]            < return
[ 2669.82]            > fib(n: uint32): uint32
[ 2669.88]            < return
[ 2669.92]           < return
[ 2669.97]           > fib(n: uint32): uint32
[ 2670.03]           < return
[ 2670.07]          < return
[ 2670.12]          > fib(n: uint32): uint32
[ 2670.18]           > fib(n: uint32): uint32
[ 2670.23]           < return
[ 2670.28]           > fib(n: uint32): uint32
[ 2670.33]           < return
[ 2670.38]          < return
[ 2670.43]         < return
[ 2670.47]         > fib(n: uint32): uint32
[ 2670.53]          > fib(n: uint32): uint32
[ 2670.58]           > fib(n: uint32): uint32
[ 2670.64]           < return
[ 2670.68]           > fib(n: uint32): uint32
[ 2670.74]           < return
[ 2670.81]          < return
[ 2670.86]          > fib(n: uint32): uint32
[ 2670.91]          < return
[ 2670.96]         < return
[ 2671.01]        < return
[ 2671.06]        > fib(n: uint32): uint32
[ 2671.12]         > fib(n: uint32): uint32
[ 2671.17]          > fib(n: uint32): uint32
[ 2671.22]           > fib(n: uint32): uint32
[ 2671.28]           < return
[ 2671.32]           > fib(n: uint32): uint32
[ 2671.37]           < return
[ 2671.42]          < return
[ 2671.46]          > fib(n: uint32): uint32
[ 2671.51]          < return
[ 2671.55]         < return
[ 2671.60]         > fib(n: uint32): uint32
[ 2671.65]          > fib(n: uint32): uint32
[ 2671.70]          < return
[ 2671.74]          > fib(n: uint32): uint32
[ 2671.80]          < return
[ 2671.84]         < return
[ 2671.89]        < return
[ 2671.94]       < return
[ 2671.99]       > fib(n: uint32): uint32
[ 2672.04]        > fib(n: uint32): uint32
[ 2672.10]         > fib(n: uint32): uint32
[ 2672.15]          > fib(n: uint32): uint32
[ 2672.21]           > fib(n: uint32): uint32
[ 2672.27]           < return
[ 2672.32]           > fib(n: uint32): uint32
[ 2672.37]           < return
[ 2672.41]          < return
[ 2672.46]          > fib(n: uint32): uint32
[ 2672.52]          < return
[ 2672.57]         < return
[ 2672.61]         > fib(n: uint32): uint32
[ 2672.67]          > fib(n: uint32): uint32
[ 2672.72]          < return
[ 2672.76]          > fib(n: uint32): uint32
[ 2672.82]          < return
[ 2672.87]         < return
[ 2672.92]        < return
[ 2672.96]        > fib(n: uint32): uint32
[ 2673.02]         > fib(n: uint32): uint32
[ 2673.07]          > fib(n: uint32): uint32
[ 2673.12]          < return
[ 2673.17]          > fib(n: uint32): uint32
[ 2673.22]          < return
[ 2673.27]         < return
[ 2673.32]         > fib(n: uint32): uint32
[ 2673.38]         < return
[ 2673.41]        < return
[ 2673.44]       < return
[ 2673.48]      < return
[ 2673.51]     < return
[ 2673.54]     > fib(n: uint32): uint32
[ 2673.58]      > fib(n: uint32): uint32
[ 2673.62]       > fib(n: uint32): uint32
[ 2673.65]        > fib(n: uint32): uint32
[ 2673.69]         > fib(n: uint32): uint32
[ 2673.72]          > fib(n: uint32): uint32
[ 2673.76]           > fib(n: uint32): uint32
[ 2673.79]            > fib(n: uint32): uint32
[ 2673.82]            < return
[ 2673.85]            > fib(n: uint32): uint32
[ 2673.89]            < return
[ 2673.91]           < return
[ 2673.94]           > fib(n: uint32): uint32
[ 2673.97]           < return
[ 2674.00]          < return
[ 2674.03]          > fib(n: uint32): uint32
[ 2674.07]           > fib(n: uint32): uint32
[ 2674.11]           < return
[ 2674.16]           > fib(n: uint32): uint32
[ 2674.21]           < return
[ 2674.24]          < return
[ 2674.28]         < return
[ 2674.33]         > fib(n: uint32): uint32
[ 2674.38]          > fib(n: uint32): uint32
[ 2674.43]           > fib(n: uint32): uint32
[ 2674.47]           < return
[ 2674.51]           > fib(n: uint32): uint32
[ 2674.56]           < return
[ 2674.60]          < return
[ 2674.64]          > fib(n: uint32): uint32
[ 2674.69]          < return
[ 2674.73]         < return
[ 2674.77]        < return
[ 2674.80]        > fib(n: uint32): uint32
[ 2674.85]         > fib(n: uint32): uint32
[ 2674.90]          > fib(n: uint32): uint32
[ 2674.95]           > fib(n: uint32): uint32
[ 2675.00]           < return
[ 2675.05]           > fib(n: uint32): uint32
[ 2675.12]           < return
[ 2675.22]          < return
[ 2675.28]          > fib(n: uint32): uint32
[ 2675.35]          < return
[ 2675.39]         < return
[ 2675.43]         > fib(n: uint32): uint32
[ 2675.48]          > fib(n: uint32): uint32
[ 2675.53]          < return
[ 2675.57]          > fib(n: uint32): uint32
[ 2675.62]          < return
[ 2675.66]         < return
[ 2675.70]        < return
[ 2675.75]       < return
[ 2675.80]       > fib(n: uint32): uint32
[ 2675.85]        > fib(n: uint32): uint32
[ 2675.93]         > fib(n: uint32): uint32
[ 2675.98]          > fib(n: uint32): uint32
[ 2676.05]           > fib(n: uint32): uint32
[ 2676.10]           < return
[ 2676.14]           > fib(n: uint32): uint32
[ 2676.19]           < return
[ 2676.23]          < return
[ 2676.28]          > fib(n: uint32): uint32
[ 2676.33]          < return
[ 2676.37]         < return
[ 2676.41]         > fib(n: uint32): uint32
[ 2676.46]          > fib(n: uint32): uint32
[ 2676.51]          < return
[ 2676.55]          > fib(n: uint32): uint32
[ 2676.60]          < return
[ 2676.64]         < return
[ 2676.68]        < return
[ 2676.72]        > fib(n: uint32): uint32
[ 2676.77]         > fib(n: uint32): uint32
[ 2676.83]          > fib(n: uint32): uint32
[ 2676.87]          < return
[ 2676.91]          > fib(n: uint32): uint32
[ 2676.95]          < return
[ 2676.98]         < return
[ 2677.03]         > fib(n: uint32): uint32
[ 2677.08]         < return
[ 2677.11]        < return
[ 2677.15]       < return
[ 2677.19]      < return
[ 2677.22]      > fib(n: uint32): uint32
[ 2677.27]       > fib(n: uint32): uint32
[ 2677.31]        > fib(n: uint32): uint32
[ 2677.36]         > fib(n: uint32): uint32
[ 2677.40]          > fib(n: uint32): uint32
[ 2677.45]           > fib(n: uint32): uint32
[ 2677.49]           < return
[ 2677.53]           > fib(n: uint32): uint32
[ 2677.57]           < return
[ 2677.61]          < return
[ 2677.64]          > fib(n: uint32): uint32
[ 2677.72]          < return
[ 2677.77]         < return
[ 2677.82]         > fib(n: uint32): uint32
[ 2677.87]          > fib(n: uint32): uint32
[ 2677.93]          < return
[ 2677.98]          > fib(n: uint32): uint32
[ 2678.04]          < return
[ 2678.09]         < return
[ 2678.13]        < return
[ 2678.18]        > fib(n: uint32): uint32
[ 2678.24]         > fib(n: uint32): uint32
[ 2678.29]          > fib(n: uint32): uint32
[ 2678.35]          < return
[ 2678.40]          > fib(n: uint32): uint32
[ 2678.45]          < return
[ 2678.50]         < return
[ 2678.55]         > fib(n: uint32): uint32
[ 2678.60]         < return
[ 2678.65]        < return
[ 2678.69]       < return
[ 2678.72]       > fib(n: uint32): uint32
[ 2678.76]        > fib(n: uint32): uint32
[ 2678.80]         > fib(n: uint32): uint32
[ 2678.83]          > fib(n: uint32): uint32
[ 2678.87]          < return
[ 2678.90]          > fib(n: uint32): uint32
[ 2678.93]          < return
[ 2678.96]         < return
[ 2678.99]         > fib(n: uint32): uint32
[ 2679.03]         < return
[ 2679.05]        < return
[ 2679.08]        > fib(n: uint32): uint32
[ 2679.12]         > fib(n: uint32): uint32
[ 2679.16]         < return
[ 2679.19]         > fib(n: uint32): uint32
[ 2679.22]         < return
[ 2679.25]        < return
[ 2679.28]       < return
[ 2679.31]      < return
[ 2679.34]     < return
[ 2679.36]    < return
[ 2679.42]   < return
[ 2679.47]   > fib(n: uint32): uint32
[ 2679.52]    > fib(n: uint32): uint32
[ 2679.57]     > fib(n: uint32): uint32
[ 2679.62]      > fib(n: uint32): uint32
[ 2679.67]       > fib(n: uint32): uint32
[ 2679.72]        > fib(n: uint32): uint32
[ 2679.78]         > fib(n: uint32): uint32
[ 2679.83]          > fib(n: uint32): uint32
[ 2679.88]           > fib(n: uint32): uint32
[ 2679.94]            > fib(n: uint32): uint32
[ 2679.99]             > fib(n: uint32): uint32
[ 2680.04]             < return
[ 2680.09]             > fib(n: uint32): uint32
[ 2680.15]             < return
[ 2680.20]            < return
[ 2680.24]            > fib(n: uint32): uint32
[ 2680.29]            < return
[ 2680.34]           < return
[ 2680.39]           > fib(n: uint32): uint32
[ 2680.43]            > fib(n: uint32): uint32
[ 2680.47]            < return
[ 2680.50]            > fib(n: uint32): uint32
[ 2680.58]            < return
[ 2680.60]           < return
[ 2680.63]          < return
[ 2680.66]          > fib(n: uint32): uint32
[ 2680.69]           > fib(n: uint32): uint32
[ 2680.73]            > fib(n: uint32): uint32
[ 2680.76]            < return
[ 2680.79]            > fib(n: uint32): uint32
[ 2680.82]            < return
[ 2680.85]           < return
[ 2680.87]           > fib(n: uint32): uint32
[ 2680.91]           < return
[ 2680.94]          < return
[ 2680.97]         < return
[ 2680.99]         > fib(n: uint32): uint32
[ 2681.03]          > fib(n: uint32): uint32
[ 2681.06]           > fib(n: uint32): uint32
[ 2681.11]            > fib(n: uint32): uint32
[ 2681.17]            < return
[ 2681.23]            > fib(n: uint32): uint32
[ 2681.29]            < return
[ 2681.34]           < return
[ 2681.39]           > fib(n: uint32): uint32
[ 2681.45]           < return
[ 2681.50]          < return
[ 2681.55]          > fib(n: uint32): uint32
[ 2681.61]           > fib(n: uint32): uint32
[ 2681.66]           < return
[ 2681.70]           > fib(n: uint32): uint32
[ 2681.75]           < return
[ 2681.84]          < return
[ 2681.94]         < return
[ 2682.01]        < return
[ 2682.06]        > fib(n: uint32): uint32
[ 2682.11]         > fib(n: uint32): uint32
[ 2682.14]          > fib(n: uint32): uint32
[ 2682.18]           > fib(n: uint32): uint32
[ 2682.22]            > fib(n: uint32): uint32
[ 2682.25]            < return
[ 2682.28]            > fib(n: uint32): uint32
[ 2682.34]            < return
[ 2682.36]           < return
[ 2682.39]           > fib(n: uint32): uint32
[ 2682.42]           < return
[ 2682.45]          < return
[ 2682.48]          > fib(n: uint32): uint32
[ 2682.51]           > fib(n: uint32): uint32
[ 2682.55]           < return
[ 2682.57]           > fib(n: uint32): uint32
[ 2682.60]           < return
[ 2682.63]          < return
[ 2682.66]         < return
[ 2682.68]         > fib(n: uint32): uint32
[ 2682.72]          > fib(n: uint32): uint32
[ 2682.75]           > fib(n: uint32): uint32
[ 2682.79]           < return
[ 2682.83]           > fib(n: uint32): uint32
[ 2682.87]           < return
[ 2682.91]          < return
[ 2682.95]          > fib(n: uint32): uint32
[ 2683.01]          < return
[ 2683.05]         < return
[ 2683.08]        < return
[ 2683.12]       < return
[ 2683.16]       > fib(n: uint32): uint32
[ 2683.20]        > fib(n: uint32): uint32
[ 2683.25]         > fib(n: uint32): uint32
[ 2683.29]          > fib(n: uint32): uint32
[ 2683.34]           > fib(n: uint32): uint32
[ 2683.38]            > fib(n: uint32): uint32
[ 2683.43]            < return
[ 2683.46]            > fib(n: uint32): uint32
[ 2683.51]            < return
[ 2683.54]           < return
[ 2683.58]           > fib(n: uint32): uint32
[ 2683.62]           < return
[ 2683.66]          < return
[ 2683.70]          > fib(n: uint32): uint32
[ 2683.74]           > fib(n: uint32): uint32
[ 2683.81]           < return
[ 2683.84]           > fib(n: uint32): uint32
[ 2683.89]           < return
[ 2683.93]          < return
[ 2683.96]         < return
[ 2684.00]         > fib(n: uint32): uint32
[ 2684.04]          > fib(n: uint32): uint32
[ 2684.09]           > fib(n: uint32): uint32
[ 2684.13]           < return
[ 2684.17]           > fib(n: uint32): uint32
[ 2684.21]           < return
[ 2684.25]          < return
[ 2684.29]          > fib(n: uint32): uint32
[ 2684.33]          < return
[ 2684.37]         < return
[ 2684.41]        < return
[ 2684.44]        > fib(n: uint32): uint32
[ 2684.49]         > fib(n: uint32): uint32
[ 2684.53]          > fib(n: uint32): uint32
[ 2684.58]           > fib(n: uint32): uint32
[ 2684.64]           < return
[ 2684.72]           > fib(n: uint32): uint32
[ 2684.76]           < return
[ 2684.80]          < return
[ 2684.84]          > fib(n: uint32): uint32
[ 2684.89]          < return
[ 2684.92]         < return
[ 2684.96]         > fib(n: uint32): uint32
[ 2685.00]          > fib(n: uint32): uint32
[ 2685.05]          < return
[ 2685.09]          > fib(n: uint32): uint32
[ 2685.13]          < return
[ 2685.17]         < return
[ 2685.20]        < return
[ 2685.24]       < return
[ 2685.27]      < return
[ 2685.33]      > fib(n: uint32): uint32
[ 2685.38]       > fib(n: uint32): uint32
[ 2685.42]        > fib(n: uint32): uint32
[ 2685.47]         > fib(n: uint32): uint32
[ 2685.53]          > fib(n: uint32): uint32
[ 2685.57]           > fib(n: uint32): uint32
[ 2685.68]            > fib(n: uint32): uint32
[ 2685.72]            < return
[ 2685.76]            > fib(n: uint32): uint32
[ 2685.80]            < return
[ 2685.84]           < return
[ 2685.88]           > fib(n: uint32): uint32
[ 2685.92]           < return
[ 2685.96]          < return
[ 2686.00]          > fib(n: uint32): uint32
[ 2686.04]           > fib(n: uint32): uint32
[ 2686.09]           < return
[ 2686.12]           > fib(n: uint32): uint32
[ 2686.17]           < return
[ 2686.20]          < return
[ 2686.24]         < return
[ 2686.28]         > fib(n: uint32): uint32
[ 2686.32]          > fib(n: uint32): uint32
[ 2686.37]           > fib(n: uint32): uint32
[ 2686.43]           < return
[ 2686.46]           > fib(n: uint32): uint32
[ 2686.51]           < return
[ 2686.54]          < return
[ 2686.58]          > fib(n: uint32): uint32
[ 2686.62]          < return
[ 2686.66]         < return
[ 2686.70]        < return
[ 2686.74]        > fib(n: uint32): uint32
[ 2686.78]         > fib(n: uint32): uint32
[ 2686.82]          > fib(n: uint32): uint32
[ 2686.87]           > fib(n: uint32): uint32
[ 2686.91]           < return
[ 2686.95]           > fib(n: uint32): uint32
[ 2686.99]           < return
[ 2687.03]          < return
[ 2687.07]          > fib(n: uint32): uint32
[ 2687.11]          < return
[ 2687.15]         < return
[ 2687.19]         > fib(n: uint32): uint32
[ 2687.25]          > fib(n: uint32): uint32
[ 2687.30]          < return
[ 2687.34]          > fib(n: uint32): uint32
[ 2687.38]          < return
[ 2687.42]         < return
[ 2687.45]        < return
[ 2687.49]       < return
[ 2687.53]       > fib(n: uint32): uint32
[ 2687.57]        > fib(n: uint32): uint32
[ 2687.62]         > fib(n: uint32): uint32
[ 2687.66]          > fib(n: uint32): uint32
[ 2687.70]           > fib(n: uint32): uint32
[ 2687.75]           < return
[ 2687.79]           > fib(n: uint32): uint32
[ 2687.85]           < return
[ 2687.89]          < return
[ 2687.92]          > fib(n: uint32): uint32
[ 2687.97]          < return
[ 2688.00]         < return
[ 2688.04]         > fib(n: uint32): uint32
[ 2688.09]          > fib(n: uint32): uint32
[ 2688.14]          < return
[ 2688.18]          > fib(n: uint32): uint32
[ 2688.22]          < return
[ 2688.26]         < return
[ 2688.30]        < return
[ 2688.33]        > fib(n: uint32): uint32
[ 2688.38]         > fib(n: uint32): uint32
[ 2688.42]          > fib(n: uint32): uint32
[ 2688.47]          < return
[ 2688.51]          > fib(n: uint32): uint32
[ 2688.55]          < return
[ 2688.59]         < return
[ 2688.62]         > fib(n: uint32): uint32
[ 2688.67]         < return
[ 2688.70]        < return
[ 2688.74]       < return
[ 2688.78]      < return
[ 2688.81]     < return
[ 2688.85]     > fib(n: uint32): uint32
[ 2688.92]      > fib(n: uint32): uint32
[ 2688.96]       > fib(n: uint32): uint32
[ 2689.01]        > fib(n: uint32): uint32
[ 2689.05]         > fib(n: uint32): uint32
[ 2689.10]          > fib(n: uint32): uint32
[ 2689.14]           > fib(n: uint32): uint32
[ 2689.19]            > fib(n: uint32): uint32
[ 2689.23]            < return
[ 2689.27]            > fib(n: uint32): uint32
[ 2689.31]            < return
[ 2689.35]           < return
[ 2689.39]           > fib(n: uint32): uint32
[ 2689.43]           < return
[ 2689.47]          < return
[ 2689.50]          > fib(n: uint32): uint32
[ 2689.55]           > fib(n: uint32): uint32
[ 2689.59]           < return
[ 2689.63]           > fib(n: uint32): uint32
[ 2689.67]           < return
[ 2689.71]          < return
[ 2689.76]         < return
[ 2689.80]         > fib(n: uint32): uint32
[ 2689.85]          > fib(n: uint32): uint32
[ 2689.89]           > fib(n: uint32): uint32
[ 2689.94]           < return
[ 2689.98]           > fib(n: uint32): uint32
[ 2690.03]           < return
[ 2690.07]          < return
[ 2690.13]          > fib(n: uint32): uint32
[ 2690.22]          < return
[ 2690.25]         < return
[ 2690.31]        < return
[ 2690.35]        > fib(n: uint32): uint32
[ 2690.39]         > fib(n: uint32): uint32
[ 2690.44]          > fib(n: uint32): uint32
[ 2690.47]           > fib(n: uint32): uint32
[ 2690.51]           < return
[ 2690.54]           > fib(n: uint32): uint32
[ 2690.57]           < return
[ 2690.60]          < return
[ 2690.63]          > fib(n: uint32): uint32
[ 2690.66]          < return
[ 2690.69]         < return
[ 2690.72]         > fib(n: uint32): uint32
[ 2690.75]          > fib(n: uint32): uint32
[ 2690.78]          < return
[ 2690.81]          > fib(n: uint32): uint32
[ 2690.85]          < return
[ 2690.87]         < return
[ 2690.90]        < return
[ 2690.93]       < return
[ 2690.96]       > fib(n: uint32): uint32
[ 2690.99]        > fib(n: uint32): uint32
[ 2691.03]         > fib(n: uint32): uint32
[ 2691.07]          > fib(n: uint32): uint32
[ 2691.12]           > fib(n: uint32): uint32
[ 2691.17]           < return
[ 2691.21]           > fib(n: uint32): uint32
[ 2691.25]           < return
[ 2691.30]          < return
[ 2691.35]          > fib(n: uint32): uint32
[ 2691.40]          < return
[ 2691.44]         < return
[ 2691.48]         > fib(n: uint32): uint32
[ 2691.53]          > fib(n: uint32): uint32
[ 2691.59]          < return
[ 2691.64]          > fib(n: uint32): uint32
[ 2691.70]          < return
[ 2691.74]         < return
[ 2691.80]        < return
[ 2691.84]        > fib(n: uint32): uint32
[ 2691.89]         > fib(n: uint32): uint32
[ 2691.95]          > fib(n: uint32): uint32
[ 2692.00]          < return
[ 2692.05]          > fib(n: uint32): uint32
[ 2692.10]          < return
[ 2692.14]         < return
[ 2692.18]         > fib(n: uint32): uint32
[ 2692.23]         < return
[ 2692.28]        < return
[ 2692.32]       < return
[ 2692.36]      < return
[ 2692.40]      > fib(n: uint32): uint32
[ 2692.45]       > fib(n: uint32): uint32
[ 2692.51]        > fib(n: uint32): uint32
[ 2692.56]         > fib(n: uint32): uint32
[ 2692.60]          > fib(n: uint32): uint32
[ 2692.66]           > fib(n: uint32): uint32
[ 2692.70]           < return
[ 2692.74]           > fib(n: uint32): uint32
[ 2692.79]           < return
[ 2692.83]          < return
[ 2692.87]          > fib(n: uint32): uint32
[ 2692.91]          < return
[ 2692.94]         < return
[ 2692.98]         > fib(n: uint32): uint32
[ 2693.02]          > fib(n: uint32): uint32
[ 2693.07]          < return
[ 2693.10]          > fib(n: uint32): uint32
[ 2693.14]          < return
[ 2693.18]         < return
[ 2693.21]        < return
[ 2693.25]        > fib(n: uint32): uint32
[ 2693.30]         > fib(n: uint32): uint32
[ 2693.34]          > fib(n: uint32): uint32
[ 2693.38]          < return
[ 2693.42]          > fib(n: uint32): uint32
[ 2693.47]          < return
[ 2693.50]         < return
[ 2693.54]         > fib(n: uint32): uint32
[ 2693.58]         < return
[ 2693.62]        < return
[ 2693.65]       < return
[ 2693.69]       > fib(n: uint32): uint32
[ 2693.75]        > fib(n: uint32): uint32
[ 2693.82]         > fib(n: uint32): uint32
[ 2693.89]          > fib(n: uint32): uint32
[ 2693.96]          < return
[ 2694.03]          > fib(n: uint32): uint32
[ 2694.11]          < return
[ 2694.16]         < return
[ 2694.20]         > fib(n: uint32): uint32
[ 2694.25]         < return
[ 2694.29]        < return
[ 2694.33]        > fib(n: uint32): uint32
[ 2694.40]         > fib(n: uint32): uint32
[ 2694.45]         < return
[ 2694.49]         > fib(n: uint32): uint32
[ 2694.54]         < return
[ 2694.59]        < return
[ 2694.64]       < return
[ 2694.68]      < return
[ 2694.72]     < return
[ 2694.76]    < return
[ 2694.81]    > fib(n: uint32): uint32
[ 2694.87]     > fib(n: uint32): uint32
[ 2694.92]      > fib(n: uint32): uint32
[ 2694.97]       > fib(n: uint32): uint32
[ 2695.02]        > fib(n: uint32): uint32
[ 2695.08]         > fib(n: uint32): uint32
[ 2695.17]          > fib(n: uint32): uint32
[ 2695.22]           > fib(n: uint32): uint32
[ 2695.27]            > fib(n: uint32): uint32
[ 2695.32]            < return
[ 2695.36]            > fib(n: uint32): uint32
[ 2695.41]            < return
[ 2695.45]           < return
[ 2695.51]           > fib(n: uint32): uint32
[ 2695.55]           < return
[ 2695.59]          < return
[ 2695.62]          > fib(n: uint32): uint32
[ 2695.67]           > fib(n: uint32): uint32
[ 2695.71]           < return
[ 2695.75]           > fib(n: uint32): uint32
[ 2695.79]           < return
[ 2695.83]          < return
[ 2695.87]         < return
[ 2695.91]         > fib(n: uint32): uint32
[ 2695.96]          > fib(n: uint32): uint32
[ 2696.01]           > fib(n: uint32): uint32
[ 2696.05]           < return
[ 2696.09]           > fib(n: uint32): uint32
[ 2696.14]           < return
[ 2696.17]          < return
[ 2696.21]          > fib(n: uint32): uint32
[ 2696.26]          < return
[ 2696.30]         < return
[ 2696.34]        < return
[ 2696.38]        > fib(n: uint32): uint32
[ 2696.44]         > fib(n: uint32): uint32
[ 2696.49]          > fib(n: uint32): uint32
[ 2696.53]           > fib(n: uint32): uint32
[ 2696.58]           < return
[ 2696.62]           > fib(n: uint32): uint32
[ 2696.66]           < return
[ 2696.70]          < return
[ 2696.74]          > fib(n: uint32): uint32
[ 2696.79]          < return
[ 2696.82]         < return
[ 2696.87]         > fib(n: uint32): uint32
[ 2696.92]          > fib(n: uint32): uint32
[ 2696.96]          < return
[ 2697.00]          > fib(n: uint32): uint32
[ 2697.05]          < return
[ 2697.08]         < return
[ 2697.12]        < return
[ 2697.16]       < return
[ 2697.20]       > fib(n: uint32): uint32
[ 2697.24]        > fib(n: uint32): uint32
[ 2697.29]         > fib(n: uint32): uint32
[ 2697.34]          > fib(n: uint32): uint32
[ 2697.38]           > fib(n: uint32): uint32
[ 2697.43]           < return
[ 2697.46]           > fib(n: uint32): uint32
[ 2697.51]           < return
[ 2697.54]          < return
[ 2697.58]          > fib(n: uint32): uint32
[ 2697.63]          < return
[ 2697.66]         < return
[ 2697.72]         > fib(n: uint32): uint32
[ 2697.76]          > fib(n: uint32): uint32
[ 2697.81]          < return
[ 2697.85]          > fib(n: uint32): uint32
[ 2697.89]          < return
[ 2697.93]         < return
[ 2697.98]        < return
[ 2698.02]        > fib(n: uint32): uint32
[ 2698.07]         > fib(n: uint32): uint32
[ 2698.11]          > fib(n: uint32): uint32
[ 2698.14]          < return
[ 2698.17]          > fib(n: uint32): uint32
[ 2698.21]          < return
[ 2698.23]         < return
[ 2698.26]         > fib(n: uint32): uint32
[ 2698.29]         < return
[ 2698.32]        < return
[ 2698.35]       < return
[ 2698.37]      < return
[ 2698.43]      > fib(n: uint32): uint32
[ 2698.53]       > fib(n: uint32): uint32
[ 2698.59]        > fib(n: uint32): uint32
[ 2698.64]         > fib(n: uint32): uint32
[ 2698.69]          > fib(n: uint32): uint32
[ 2698.74]           > fib(n: uint32): uint32
[ 2698.80]           < return
[ 2698.84]           > fib(n: uint32): uint32
[ 2698.89]           < return
[ 2698.93]          < return
[ 2698.97]          > fib(n: uint32): uint32
[ 2699.02]          < return
[ 2699.08]         < return
[ 2699.12]         > fib(n: uint32): uint32
[ 2699.18]          > fib(n: uint32): uint32
[ 2699.22]          < return
[ 2699.30]          > fib(n: uint32): uint32
[ 2699.36]          < return
[ 2699.43]         < return
[ 2699.50]        < return
[ 2699.56]        > fib(n: uint32): uint32
[ 2699.61]         > fib(n: uint32): uint32
[ 2699.67]          > fib(n: uint32): uint32
[ 2699.72]          < return
[ 2699.77]          > fib(n: uint32): uint32
[ 2699.82]          < return
[ 2699.86]         < return
[ 2699.91]         > fib(n: uint32): uint32
[ 2699.96]         < return
[ 2700.00]        < return
[ 2700.05]       < return
[ 2700.09]       > fib(n: uint32): uint32
[ 2700.14]        > fib(n: uint32): uint32
[ 2700.20]         > fib(n: uint32): uint32
[ 2700.25]          > fib(n: uint32): uint32
[ 2700.30]          < return
[ 2700.34]          > fib(n: uint32): uint32
[ 2700.39]          < return
[ 2700.44]         < return
[ 2700.48]         > fib(n: uint32): uint32
[ 2700.53]         < return
[ 2700.60]        < return
[ 2700.65]        > fib(n: uint32): uint32
[ 2700.70]         > fib(n: uint32): uint32
[ 2700.77]         < return
[ 2700.82]         > fib(n: uint32): uint32
[ 2700.88]         < return
[ 2700.92]        < return
[ 2700.97]       < return
[ 2701.01]      < return
[ 2701.06]     < return
[ 2701.11]     > fib(n: uint32): uint32
[ 2701.16]      > fib(n: uint32): uint32
[ 2701.21]       > fib(n: uint32): uint32
[ 2701.27]        > fib(n: uint32): uint32
[ 2701.32]         > fib(n: uint32): uint32
[ 2701.37]          > fib(n: uint32): uint32
[ 2701.42]           > fib(n: uint32): uint32
[ 2701.47]           < return
[ 2701.52]           > fib(n: uint32): uint32
[ 2701.57]           < return
[ 2701.61]          < return
[ 2701.66]          > fib(n: uint32): uint32
[ 2701.72]          < return
[ 2701.76]         < return
[ 2701.81]         > fib(n: uint32): uint32
[ 2701.86]          > fib(n: uint32): uint32
[ 2701.91]          < return
[ 2701.96]          > fib(n: uint32): uint32
[ 2702.01]          < return
[ 2702.05]         < return
[ 2702.10]        < return
[ 2702.15]        > fib(n: uint32): uint32
[ 2702.21]         > fib(n: uint32): uint32
[ 2702.27]          > fib(n: uint32): uint32
[ 2702.32]          < return
[ 2702.37]          > fib(n: uint32): uint32
[ 2702.42]          < return
[ 2702.47]         < return
[ 2702.51]         > fib(n: uint32): uint32
[ 2702.57]         < return
[ 2702.61]        < return
[ 2702.66]       < return
[ 2702.70]       > fib(n: uint32): uint32
[ 2702.76]        > fib(n: uint32): uint32
[ 2702.81]         > fib(n: uint32): uint32
[ 2702.86]          > fib(n: uint32): uint32
[ 2702.91]          < return
[ 2702.96]          > fib(n: uint32): uint32
[ 2703.01]          < return
[ 2703.05]         < return
[ 2703.10]         > fib(n: uint32): uint32
[ 2703.15]         < return
[ 2703.19]        < return
[ 2703.23]        > fib(n: uint32): uint32
[ 2703.29]         > fib(n: uint32): uint32
[ 2703.34]         < return
[ 2703.38]         > fib(n: uint32): uint32
[ 2703.43]         < return
[ 2703.49]        < return
[ 2703.53]       < return
[ 2703.58]      < return
[ 2703.62]      > fib(n: uint32): uint32
[ 2703.68]       > fib(n: uint32): uint32
[ 2703.73]        > fib(n: uint32): uint32
[ 2703.78]         > fib(n: uint32): uint32
[ 2703.84]          > fib(n: uint32): uint32
[ 2703.89]          < return
[ 2703.93]          > fib(n: uint32): uint32
[ 2703.98]          < return
[ 2704.03]         < return
[ 2704.07]         > fib(n: uint32): uint32
[ 2704.12]         < return
[ 2704.17]        < return
[ 2704.21]        > fib(n: uint32): uint32
[ 2704.27]         > fib(n: uint32): uint32
[ 2704.32]         < return
[ 2704.37]         > fib(n: uint32): uint32
[ 2704.42]         < return
[ 2704.47]        < return
[ 2704.52]       < return
[ 2704.56]       > fib(n: uint32): uint32
[ 2704.61]        > fib(n: uint32): uint32
[ 2704.64]         > fib(n: uint32): uint32
[ 2704.68]         < return
[ 2704.70]         > fib(n: uint32): uint32
[ 2704.74]         < return
[ 2704.77]        < return
[ 2704.80]        > fib(n: uint32): uint32
[ 2704.83]        < return
[ 2704.86]       < return
[ 2704.88]      < return
[ 2704.91]     < return
[ 2704.94]    < return
[ 2704.96]   < return
[ 2704.99]  < return
[ 2705.02]  > typename.size(type: typename): int32
[ 2705.06]  < return
[ 2705.09]  > typename.size(type: typename): int32
[ 2705.12]  < return
[ 2705.16]  > typename.size(type: typename): int32
[ 2705.20]  < return
[ 2705.22]  > typename.size(type: typename): int32
[ 2705.27]  < return
[ 2705.34]  > typename.size(type: typename): int32
[ 2705.40]  < return
[ 2705.44]  > typename.size(type: typename): int32
[ 2705.51]  < return
[ 2705.56]  > typename.size(type: typename): int32
[ 2705.62]  < return
[ 2705.66]  > typename.size(type: typename): int32
[ 2705.71]  < return
[ 2705.76]  > typename.size(type: typename): int32
[ 2705.81]  < return
[ 2705.85]  > typename.size(type: typename): int32
[ 2705.90]  < return
[ 2705.95]  > typename.size(type: typename): int32
[ 2706.00]  < return
[ 2706.06]  > typename.size(type: typename): int32
[ 2706.12]  < return
[ 2706.17]  > typename.size(type: typename): int32
[ 2706.22]  < return
[ 2706.27]  > typename.size(type: typename): int32
[ 2706.33]  < return
[ 2706.39]  > typename.size(type: typename): int32
[ 2706.45]  < return
[ 2706.49]  > typename.size(type: typename): int32
[ 2706.55]  < return
[ 2706.59]  > typename.size(type: typename): int32
[ 2706.65]  < return
[ 2706.69]  > typename.size(type: typename): int32
[ 2706.76]  < return
[ 2706.80]  > typename.name(type: typename): .cstr
[ 2706.86]  < return
[ 2706.92]  > typename.file(type: typename): .cstr
[ 2706.98]  < return
[ 2707.03]  > typename.line(type: typename): int32
[ 2707.10]  < return
[ 2707.15]  > typename.base(type: typename): typename
[ 2707.21]  < return
[ 2707.26]  > typename.name(type: typename): .cstr
[ 2707.32]  < return
[ 2707.37]  > typename.file(type: typename): .cstr
[ 2707.44]  < return
[ 2707.49]  > typename.line(type: typename): int32
[ 2707.55]  < return
[ 2707.59]  > typename.base(type: typename): typename
[ 2707.66]  < return
[ 2707.71]  > typename.base(type: typename): typename
[ 2707.76]  < return
[ 2708.68]  > Math.floor(x: float64): float64
[ 2708.74]   > Math.modf(x: float64, intPart: float64): float64
[ 2708.79]   < return
[ 2708.83]  < return
[ 2708.88]  > Math.floor(x: float64): float64
[ 2708.94]   > Math.modf(x: float64, intPart: float64): float64
[ 2708.99]   < return
[ 2709.05]  < return
[ 2709.11]  > Math.floor(x: float64): float64
[ 2709.16]   > Math.modf(x: float64, intPart: float64): float64
[ 2709.20]   < return
[ 2709.24]  < return
[ 2709.29]  > Math.floor(x: float64): float64
[ 2709.35]   > Math.modf(x: float64, intPart: float64): float64
[ 2709.40]    > Math.modf(x: float64, intPart: float64): float64
[ 2709.46]    < return
[ 2709.52]   < return
[ 2709.56]  < return
[ 2709.60]  > Math.floor(x: float64): float64
[ 2709.67]   > Math.modf(x: float64, intPart: float64): float64
[ 2709.71]    > Math.modf(x: float64, intPart: float64): float64
[ 2709.76]    < return
[ 2709.80]   < return
[ 2709.84]  < return
[ 2709.89]  > Math.floor(x: float64): float64
[ 2709.94]   > Math.modf(x: float64, intPart: float64): float64
[ 2709.99]    > Math.modf(x: float64, intPart: float64): float64
[ 2710.03]    < return
[ 2710.08]   < return
[ 2710.12]  < return
[ 2710.32]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 2710.36]  < return
[ 2710.41]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 2710.46]  < return
[ 2710.53]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 2710.58]  < return
[ 2710.65]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 2710.69]  < return
[ 2710.75]  > Math.min(data: float64[]): float64
[ 2710.82]  < return
[ 2710.87]  > Math.min(data: float64[]): float64
[ 2710.94]  < return
[ 2710.99]  > Math.max(data: float64[]): float64
[ 2711.06]  < return
[ 2711.12]  > Math.max(data: float64[]): float64
[ 2711.19]  < return
[ 2711.24]  > Math.sum(data: float64[]): float64
[ 2711.30]  < return
[ 2711.35]  > Math.sum(data: float64[]): float64
[ 2711.42]  < return
[ 2711.47]  > Math.sum(data: float64[]): float64
[ 2711.54]  < return
[ 2711.60]  > Math.sum(data: float64[]): float64
[ 2711.67]  < return
[ 2711.73]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 2711.82]  < return
[ 2711.92]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 2711.99]  < return
[ 2712.05]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 2712.12]  < return
[ 2712.17]  > Math.sinCos(arg: float64, quad: int32): float64
[ 2712.23]  < return
[ 2712.28]  > Math.sinCos(arg: float64, quad: int32): float64
[ 2712.34]  < return
[ 2712.42]  > Math.tan(arg: float64): float64
[ 2712.47]   > Math.modf(x: float64, intPart: float64): float64
[ 2712.52]   < return
[ 2712.57]  < return
[ 2712.62]  > Math.sinh(x: float64): float64
[ 2712.67]   > float64.exp(x: float64): float64
[ 2712.72]   < return
[ 2712.77]   > float64.exp(x: float64): float64
[ 2712.82]   < return
[ 2712.87]  < return
[ 2712.92]  > Math.cosh(x: float64): float64
[ 2712.97]   > float64.exp(x: float64): float64
[ 2713.01]   < return
[ 2713.03]   > float64.exp(x: float64): float64
[ 2713.07]   < return
[ 2713.09]  < return
[ 2713.12]  > Math.asin(x: float64): float64
[ 2713.15]   > float64.sqrt(x: float64): float64
[ 2713.18]   < return
[ 2713.21]   > float64.atan2(x: float64, y: float64): float64
[ 2713.24]   < return
[ 2713.27]  < return
[ 2713.30]  > Math.asin(x: float64): float64
[ 2713.33]   > float64.sqrt(x: float64): float64
[ 2713.37]   < return
[ 2713.39]   > float64.atan2(x: float64, y: float64): float64
[ 2713.42]   < return
[ 2713.45]  < return
[ 2713.48]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 2713.51]  < return
[ 2713.54]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 2713.57]  < return
[ 2713.62]  > Math.absMod(val: float64, mod: float64): float64
[ 2713.66]  < return
[ 2713.70]  > Math.absMod(val: float64, mod: float64): float64
[ 2713.74]  < return
[ 2713.78]  > Math.absMod(val: float64, mod: float64): float64
[ 2713.82]  < return
[ 2713.86]  > Math.absMod(val: float64, mod: float64): float64
[ 2713.91]  < return
[ 2713.95]  > Math.absMod(val: float64, mod: float64): float64
[ 2713.99]  < return
[ 2714.04]  > Math.absMod(val: float64, mod: float64): float64
[ 2714.07]  < return
[ 2714.12]  > Math.absMod(val: float64, mod: float64): float64
[ 2714.16]  < return
[ 2714.20]  > Math.absMod(val: float64, mod: float64): float64
[ 2714.24]  < return
[ 2714.28]  > Math.absMod(val: float64, mod: float64): float64
[ 2714.31]  < return
[ 2714.36]  > Math.absMod(val: float64, mod: float64): float64
[ 2714.39]  < return
[ 2714.43]  > Math.absMod(val: float64, mod: float64): float64
[ 2714.47]  < return
[ 2714.51]  > Math.absMod(val: float32, mod: float32): float32
[ 2714.56]  < return
[ 2714.61]  > Math.absMod(val: float32, mod: float32): float32
[ 2714.65]  < return
[ 2714.70]  > Math.absMod(val: float32, mod: float32): float32
[ 2714.74]  < return
[ 2714.79]  > Math.absMod(val: float32, mod: float32): float32
[ 2714.83]  < return
[ 2714.88]  > Math.absMod(val: float32, mod: float32): float32
[ 2714.92]  < return
[ 2714.97]  > Math.absMod(val: float32, mod: float32): float32
[ 2715.01]  < return
[ 2715.06]  > Math.absMod(val: float32, mod: float32): float32
[ 2715.10]  < return
[ 2715.15]  > Math.absMod(val: float32, mod: float32): float32
[ 2715.19]  < return
[ 2715.24]  > Math.absMod(val: float32, mod: float32): float32
[ 2715.28]  < return
[ 2715.33]  > Math.absMod(val: float32, mod: float32): float32
[ 2715.37]  < return
[ 2715.42]  > Math.absMod(val: float32, mod: float32): float32
[ 2715.46]  < return
[ 2715.51]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 2715.57]  < return
[ 2715.61]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 2715.67]  < return
[ 2715.71]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2715.77]  < return
[ 2715.81]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2715.86]  < return
[ 2715.91]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2715.96]  < return
[ 2716.01]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 2716.06]  < return
[ 2716.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:26: debug: val1: int64(42)
[ 2716.37]  < return
[ 2716.42]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:27: debug: val2: int64(96)
[ 2716.62]  < return
[ 2716.68]  > typename.size(type: typename): int32
[ 2716.74]  < return
[ 2716.78]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 2716.84]  < return
[ 2716.89]  > typename.size(type: typename): int32
[ 2716.95]  < return
[ 2716.99]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 2717.04]  < return
[ 2717.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:32: debug: val1: int64(0)
[ 2717.33]  < return
[ 2717.41]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:33: debug: val2: int64(42)
[ 2717.61]  < return
[ 2717.66]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 2717.72]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	cmplStd/test/lang/init.method.ci:78: staticMethod(this: <?>, x: 1)
	native.code:: .main
[ 2718.13]   < return
[ 2718.18]  < return
[ 2718.22]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 2718.28]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	cmplStd/test/lang/init.method.ci:79: virtualMethod(this: <?>, x: 1)
	native.code:: .main
[ 2718.73]   < return
[ 2718.78]  < return
[ 2718.83]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 2718.89]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:85: debug: extension.staticMethod
[ 2719.03]   < return
[ 2719.08]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 2719.13]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	cmplStd/test/lang/init.method.ci:87: staticMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 2719.73]    < return
[ 2719.78]   < return
[ 2719.82]  < return
[ 2719.87]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 2719.91]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:91: debug: extension.virtualMethod
[ 2719.99]   < return
[ 2720.02]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 2720.06]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	cmplStd/test/lang/init.method.ci:93: virtualMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 2720.39]    < return
[ 2720.42]   < return
[ 2720.46]  < return
[ 2720.51]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 2720.55]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	cmplStd/test/lang/init.method.ci:101: staticMethod(this: <?>, x: 3)
	native.code:: .main
[ 2720.90]   < return
[ 2720.94]  < return
[ 2720.98]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 2721.02]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:102: virtualMethod(this: <?>, x: 3)
	native.code:: .main
[ 2721.37]   < return
[ 2721.41]  < return
[ 2721.45]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 2721.49]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:103: virtualMethod(this: <?>, x: 3)
	native.code:: .main
[ 2721.88]   < return
[ 2721.92]  < return
[ 2721.97]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
[ 2722.13]  < return
[ 2722.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
[ 2722.37]  < return
[ 2722.41]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
[ 2722.58]  < return
[ 2722.64]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 2722.83]  < return
[ 2722.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 2723.06]  < return
[ 2723.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 2723.29]  < return
[ 2723.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 2723.60]  < return
[ 2723.66]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:4: debug: for ( ; ; )
[ 2723.79]  < return
[ 2723.84]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 2724.03]  < return
[ 2724.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 2724.28]  < return
[ 2724.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 2724.56]  < return
[ 2724.61]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 2724.80]  < return
[ 2724.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
[ 2725.07]  < return
[ 2725.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
[ 2725.31]  < return
[ 2725.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
[ 2725.56]  < return
[ 2725.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
[ 2725.80]  < return
[ 2725.86]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
[ 2726.04]  < return
[ 2726.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(0)
[ 2726.28]  < return
[ 2726.34]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(1)
[ 2726.50]  < return
[ 2726.56]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(2)
[ 2726.73]  < return
[ 2726.78]  > halt(): void
[ 2726.83]  < return
[ 2726.87] < return

---------- Profile functions: 70/115, coverage: 60.87%, failures: 5
::[.005ed8, .005ed8): hits(2), time(0.084 ms): halt(): void
::[.006198, .006198): hits(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006500, .006500): hits(3), time(0.177 ms): typename.base(type: typename): typename
::[.006718, .006718): hits(2), time(0.119 ms): typename.file(type: typename): .cstr
::[.006930, .006930): hits(2), time(0.128 ms): typename.line(type: typename): int32
::[.006b48, .006b48): hits(2), time(0.120 ms): typename.name(type: typename): .cstr
::[.006d58, .006d58): hits(20), time(1.052 ms): typename.size(type: typename): int32
::[.007018, .007018): hits(2), time(0.122 ms): object.create(type: typename): pointer
::[.007238, .007238): hits(0), time(0.000 ms): object.destroy(this: object): void
::[.0074e8, .0074e8): hits(0), time(0.000 ms): object.as(this: object, type: typename): pointer
::[.0076f8, .0076f8): hits(0), time(0.000 ms): object.type(this: object): typename
::[.007db0, .007db0): hits(34), time(8.573 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.008700, .008700): hits(7), time(12.808 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.0089c0, .0089c0): hits(8), time(0.416 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.008d20, .008d20): hits(2), time(0.106 ms): pointer.fill(dst: pointer, value: uint8, size: int32): pointer
::[.009080, .009080): hits(1), time(0.052 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.0093d8, .0093d8): hits(1), time(0.056 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0096a0, .0096a0): hits(0), time(0.000 ms): System.exit(code: int32): void
::[.0098c0, .0098c0): hits(0), time(0.000 ms): System.srand(seed: int32): void
::[.009a38, .009a38): hits(0), time(0.000 ms): System.time(): int32
::[.009bb0, .009bb0): hits(0), time(0.000 ms): System.millis(): int64
::[.009dc8, .009dc8): hits(0), time(0.000 ms): System.sleep(millis: int64): void
::[.009f40, .009f40): hits(0), time(0.000 ms): System.rand(): int32
::[.00a158, .00a158): hits(0), time(0.000 ms): System.clock(): int32
::[.00a560, .00a560): hits(7), time(0.325 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.00a8b8, .00a8b8): hits(7), time(0.323 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.00aad0, .00aad0): hits(1), time(0.047 ms): uint32.pop(value: int32): int32
::[.00ace8, .00ace8): hits(1), time(0.049 ms): uint32.swap(value: int32): int32
::[.00af00, .00af00): hits(1), time(0.048 ms): uint32.bsr(value: int32): int32
::[.00b118, .00b118): hits(1), time(0.045 ms): uint32.bsf(value: int32): int32
::[.00b330, .00b330): hits(1), time(0.048 ms): uint32.hib(value: int32): int32
::[.00b548, .00b548): hits(1), time(0.046 ms): uint32.lob(value: int32): int32
::[.00b898, .00b898): hits(1), time(0.046 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00bbe8, .00bbe8): hits(1), time(0.047 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00be00, .00be00): hits(2), time(0.113 ms): float32.sin(x: float32): float32
::[.00c018, .00c018): hits(1), time(0.047 ms): float32.cos(x: float32): float32
::[.00c230, .00c230): hits(1), time(0.047 ms): float32.tan(x: float32): float32
::[.00c448, .00c448): hits(1), time(0.047 ms): float32.log(x: float32): float32
::[.00c660, .00c660): hits(1), time(0.047 ms): float32.exp(x: float32): float32
::[.00c918, .00c918): hits(1), time(0.046 ms): float32.pow(x: float32, y: float32): float32
::[.00cb30, .00cb30): hits(1), time(0.046 ms): float32.sqrt(x: float32): float32
::[.00cde8, .00cde8): hits(1), time(0.047 ms): float32.atan2(x: float32, y: float32): float32
::[.00cff8, .00cff8): hits(1), time(0.067 ms): float64.sin(x: float64): float64
::[.00d208, .00d208): hits(1), time(0.049 ms): float64.cos(x: float64): float64
::[.00d418, .00d418): hits(1), time(0.050 ms): float64.tan(x: float64): float64
::[.00d628, .00d628): hits(1), time(0.052 ms): float64.log(x: float64): float64
::[.00d838, .00d838): hits(5), time(0.224 ms): float64.exp(x: float64): float64
::[.00dae8, .00dae8): hits(1), time(0.046 ms): float64.pow(x: float64, y: float64): float64
::[.00dcf8, .00dcf8): hits(3), time(0.113 ms): float64.sqrt(x: float64): float64
::[.00dfa8, .00dfa8): hits(3), time(0.128 ms): float64.atan2(x: float64, y: float64): float64
cmplStd/lib/debug.ci:61:[.061b20, .061b87): hits(0), time(0.000 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
cmplStd/lib/math.ci:22:[.061b88, .061bde): hits(10), time(0.630 ms): Math.modf(x: float64, intPart: float64): float64
cmplStd/lib/math.ci:47:[.061be0, .061bf8): hits(6), time(1.180-0.578 ms): Math.floor(x: float64): float64
cmplStd/lib/math.ci:82:[.061bf8, .061c13): hits(11), time(0.479 ms): Math.absMod(val: float32, mod: float32): float32
cmplStd/lib/math.ci:90:[.061c18, .061c33): hits(11), time(0.431 ms): Math.absMod(val: float64, mod: float64): float64
cmplStd/lib/math.ci:164:[.061c38, .061c56): hits(2), time(0.099 ms): Math.clamp(t: float32, a: float32, b: float32): float32
cmplStd/lib/math.ci:175:[.061c58, .061c76): hits(2), time(0.088 ms): Math.clamp(t: float64, a: float64, b: float64): float64
cmplStd/lib/math.ci:206:[.061c78, .061cc7): hits(2), time(0.132 ms): Math.min(data: float64[]): float64
cmplStd/lib/math.ci:220:[.061cc8, .061d17): hits(2), time(0.134 ms): Math.max(data: float64[]): float64
cmplStd/lib/math.ci:234:[.061d18, .061d40): hits(4), time(0.278 ms): Math.sum(data: float64[]): float64
cmplStd/lib/math.ci:243:[.061d40, .061d54): hits(0), time(0.000 ms): Math.mean(data: float64[]): float64
cmplStd/lib/math.ci:260:[.061d58, .061d87): hits(3), time(0.224 ms): Math.eval(x: float64, polynomial: float64[]): float64
cmplStd/lib/math.ci:269:[.061d88, .061dc1): hits(1), time(0.028 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
cmplStd/lib/math.ci:284:[.061dc8, .061e01): hits(1), time(0.030 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
cmplStd/lib/math.ci:299:[.061e08, .061f57): hits(2), time(0.116 ms): Math.sinCos(arg: float64, quad: int32): float64
cmplStd/lib/math.ci:356:[.061f58, .0620d2): hits(1), time(0.156-0.052 ms): Math.tan(arg: float64): float64
cmplStd/lib/math.ci:413:[.0620d8, .0621c9): hits(1), time(0.245-0.108 ms): Math.sinh(x: float64): float64
cmplStd/lib/math.ci:452:[.0621d0, .06221b): hits(1), time(0.172-0.070 ms): Math.cosh(x: float64): float64
cmplStd/lib/math.ci:467:[.062220, .0622cd): hits(2), time(0.296-0.139 ms): Math.asin(x: float64): float64
cmplStd/lib/math/Complex.ci:24:[.0622d0, .0622d7): hits(0), time(0.000 ms): Complex(re: float64): Complex
cmplStd/lib/math/Complex.ci:31:[.0622d8, .0622df): hits(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
cmplStd/lib/math/Complex.ci:86:[.0622e0, .06236b): hits(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
cmplStd/lib/math/Complex.ci:117:[.062370, .06238f): hits(0), time(0.000 ms): inv(a: Complex): Complex
cmplStd/lib/math/Complex.ci:135:[.062390, .0623f4): hits(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
cmplStd/lib/math/Matrix4f.ci:62:[.0623f8, .062429): hits(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:75:[.062430, .062445): hits(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
cmplStd/lib/math/Matrix4f.ci:87:[.062448, .062479): hits(0), time(0.000 ms): transpose(mat: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:97:[.062480, .062575): hits(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:111:[.062578, .06273e): hits(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:160:[.062740, .062820): hits(0), time(0.000 ms): rotation(direction: vec4f, angle: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:193:[.062820, .062878): hits(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:203:[.062878, .062951): hits(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Vector2d.ci:14:[.062958, .06295f): hits(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
cmplStd/lib/text/string.ci:4:[.062960, .062986): hits(0), time(0.000 ms): length(str: char[*]): int32
cmplStd/lib/text/string.ci:15:[.062988, .0629ba): hits(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
cmplStd/lib/text/string.ci:25:[.0629c0, .0629f2): hits(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
cmplStd/lib/text/string.ci:36:[.0629f8, .062a41): hits(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/text/string.ci:46:[.062a48, .062ac6): hits(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/text/string.ci:61:[.062ac8, .062b07): hits(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
cmplStd/lib/text/string.ci:74:[.062b08, .062b4f): hits(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
cmplStd/lib/text/string.ci:73:[.062b50, .062b74): hits(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
cmplStd/lib/text/string.ci:88:[.062b78, .062b86): hits(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
cmplStd/lib/text/string.ci:134:[.062b88, .062bff): hits(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
cmplStd/lib/text/string.ci:154:[.062c10, .062e9d): hits(0), time(0.000 ms): append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
cmplStd/lib/text/string.ci:229:[.062ea0, .062f06): hits(0), time(0.000 ms): append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
cmplStd/lib/text/string.ci:255:[.062f20, .0630b2): hits(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
cmplStd/lib/text/string.ci:294:[.0630c8, .0630e7): hits(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
cmplStd/lib/text/string.ci:300:[.0630e8, .06323f): hits(0), time(0.000 ms): float64(value: char[]): float64
cmplStd/test/std/tryExec.ci:11:[.0635f0, .0635f1): hits(1), time(0.046 ms): noError(ptr: pointer): void
cmplStd/test/std/tryExec.ci:14:[.0635f8, .063610): hits(128-128), time(10.892 ms): stackOverflow(ptr: pointer): void
cmplStd/test/std/tryExec.ci:20:[.063610, .06361c): hits(1-1), time(0.046 ms): divisionByZero(args: pointer): void
cmplStd/test/std/tryExec.ci:24:[.063620, .063664): hits(1-1), time(1.077-0.958 ms): abortExecution(args: pointer): void
cmplStd/test/std/tryExec.ci:38:[.063668, .063675): hits(1-1), time(0.046 ms): invalidMemoryAccess(args: pointer): void
cmplStd/test/std/tryExec.ci:43:[.063678, .06367a): hits(1-1), time(0.070 ms): invalidInstruction(args: pointer): void
cmplStd/test/lang/function.ci:4:[.063978, .063979): hits(0), time(0.000 ms): empty(): void
cmplStd/test/lang/function.ci:7:[.063980, .063988): hits(2), time(0.093 ms): funAdd(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:33:[.0639c0, .0639c8): hits(2), time(0.105 ms): funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:38:[.0639c8, .0639fe): hits(753), time(66.429 ms): fib(n: uint32): uint32
cmplStd/test/lang/init.method.ci:10:[.063b78, .063b9f): hits(3), time(1.636-1.354 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:40:[.063ba8, .063bcf): hits(4), time(1.857-1.508 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47:[.063bd0, .063bf7): hits(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:57:[.063bf8, .063c1f): hits(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:84:[.063c30, .063c72): hits(1), time(0.995-0.842 ms): staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:90:[.063c78, .063cb7): hits(1), time(0.592-0.481 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.0646fc, .067b67): hits(1), time(106.430-96.341 ms): .main

---------- Profile statements: 826/1237, coverage: 66.77%, failures: 5
cmplStd/lib/debug.ci:63:[.061b29, .061b2a) hits(0), instructions(0): <assertEq+9>
cmplStd/lib/debug.ci:62:[.061b20, .061b2a) hits(0), instructions(0): <assertEq+0>
cmplStd/lib/debug.ci:65:[.061b2e, .061b37) hits(0), instructions(0): <assertEq+14>
cmplStd/lib/debug.ci:65:[.061b2a, .061b37) hits(0), instructions(0): <assertEq+10>
cmplStd/lib/debug.ci:67:[.061b3b, .061b46) hits(0), instructions(0): <assertEq+27>
cmplStd/lib/debug.ci:68:[.061b46, .061b51) hits(0), instructions(0): <assertEq+38>
cmplStd/lib/debug.ci:69:[.061b51, .061b5c) hits(0), instructions(0): <assertEq+49>
cmplStd/lib/debug.ci:66:[.061b37, .061b5c) hits(0), instructions(0): <assertEq+23>
cmplStd/lib/debug.ci:71:[.061b5c, .061b82) hits(0), instructions(0): <assertEq+60>
cmplStd/lib/math.ci:25:[.061ba0, .061bb1) hits(3), instructions(24): <modf+24>
cmplStd/lib/math.ci:26:[.061bb1, .061bb8) hits(3), instructions(15): <modf+41>
cmplStd/lib/math.ci:27:[.061bb8, .061bbb) hits(3), instructions(6): <modf+48>
cmplStd/lib/math.ci:24:[.061b98, .061bbf) hits(3), instructions(12): <modf+16>
cmplStd/lib/math.ci:29:[.061bbf, .061bc3) hits(0), instructions(0): <modf+55>
cmplStd/lib/math.ci:30:[.061bc3, .061bc7) hits(0), instructions(0): <modf+59>
cmplStd/lib/math.ci:23:[.061b88, .061bc7) hits(10), instructions(40): <modf+0>
cmplStd/lib/math.ci:32:[.061bc7, .061bd3) hits(7), instructions(21): <modf+63>
cmplStd/lib/math.ci:33:[.061bd3, .061bdb) hits(7), instructions(35): <modf+75>
cmplStd/lib/math.ci:34:[.061bdb, .061bde) hits(7), instructions(14): <modf+83>
cmplStd/lib/math.ci:48:[.061be0, .061be1) hits(6), instructions(6): <floor+0>
cmplStd/lib/math.ci:49:[.061be1, .061bf5) hits(6), instructions(36): <floor+1>
cmplStd/lib/math.ci:50:[.061bf5, .061bf8) hits(6), instructions(12): <floor+21>
cmplStd/lib/math.ci:84:[.061c07, .061c0f) hits(4), instructions(20): <absMod+15>
cmplStd/lib/math.ci:83:[.061bf8, .061c0f) hits(11), instructions(88): <absMod+0>
cmplStd/lib/math.ci:86:[.061c0f, .061c13) hits(7), instructions(14): <absMod+23>
cmplStd/lib/math.ci:92:[.061c27, .061c2f) hits(4), instructions(20): <absMod+15>
cmplStd/lib/math.ci:91:[.061c18, .061c2f) hits(11), instructions(88): <absMod+0>
cmplStd/lib/math.ci:94:[.061c2f, .061c33) hits(7), instructions(14): <absMod+23>
cmplStd/lib/math.ci:166:[.061c41, .061c45) hits(0), instructions(0): <clamp+9>
cmplStd/lib/math.ci:165:[.061c38, .061c45) hits(2), instructions(8): <clamp+0>
cmplStd/lib/math.ci:169:[.061c4e, .061c52) hits(1), instructions(2): <clamp+22>
cmplStd/lib/math.ci:168:[.061c45, .061c52) hits(2), instructions(8): <clamp+13>
cmplStd/lib/math.ci:171:[.061c52, .061c56) hits(1), instructions(2): <clamp+26>
cmplStd/lib/math.ci:177:[.061c61, .061c65) hits(0), instructions(0): <clamp+9>
cmplStd/lib/math.ci:176:[.061c58, .061c65) hits(2), instructions(8): <clamp+0>
cmplStd/lib/math.ci:180:[.061c6e, .061c72) hits(1), instructions(2): <clamp+22>
cmplStd/lib/math.ci:179:[.061c65, .061c72) hits(2), instructions(8): <clamp+13>
cmplStd/lib/math.ci:182:[.061c72, .061c76) hits(1), instructions(2): <clamp+26>
cmplStd/lib/math.ci:208:[.061c80, .061c8c) hits(1), instructions(3): <min+8>
cmplStd/lib/math.ci:207:[.061c78, .061c8c) hits(2), instructions(8): <min+0>
cmplStd/lib/math.ci:210:[.061c8c, .061c8f) hits(1), instructions(2): <min+20>
cmplStd/lib/math.ci:213:[.061ca8, .061cb3) hits(2), instructions(10): <min+48>
cmplStd/lib/math.ci:212:[.061c98, .061cb3) hits(8), instructions(56): <min+32>
cmplStd/lib/math.ci:211:[.061cb3, .061cb7) hits(8), instructions(8): <min+59>
cmplStd/lib/math.ci:211:[.061cb7, .061cc0) hits(9), instructions(36): <min+63>
cmplStd/lib/math.ci:211:[.061c8f, .061cc4) hits(1), instructions(3): <min+23>
cmplStd/lib/math.ci:216:[.061cc4, .061cc7) hits(1), instructions(2): <min+76>
cmplStd/lib/math.ci:222:[.061cd0, .061cdc) hits(1), instructions(3): <max+8>
cmplStd/lib/math.ci:221:[.061cc8, .061cdc) hits(2), instructions(8): <max+0>
cmplStd/lib/math.ci:224:[.061cdc, .061cdf) hits(1), instructions(2): <max+20>
cmplStd/lib/math.ci:227:[.061cf8, .061d03) hits(2), instructions(10): <max+48>
cmplStd/lib/math.ci:226:[.061ce8, .061d03) hits(8), instructions(56): <max+32>
cmplStd/lib/math.ci:225:[.061d03, .061d07) hits(8), instructions(8): <max+59>
cmplStd/lib/math.ci:225:[.061d07, .061d10) hits(9), instructions(36): <max+63>
cmplStd/lib/math.ci:225:[.061cdf, .061d14) hits(1), instructions(3): <max+23>
cmplStd/lib/math.ci:230:[.061d14, .061d17) hits(1), instructions(2): <max+76>
cmplStd/lib/math.ci:235:[.061d18, .061d19) hits(4), instructions(4): <sum+0>
cmplStd/lib/math.ci:237:[.061d1e, .061d2c) hits(13), instructions(91): <sum+6>
cmplStd/lib/math.ci:236:[.061d2c, .061d30) hits(13), instructions(13): <sum+20>
cmplStd/lib/math.ci:236:[.061d30, .061d39) hits(17), instructions(68): <sum+24>
cmplStd/lib/math.ci:236:[.061d19, .061d3d) hits(4), instructions(12): <sum+1>
cmplStd/lib/math.ci:239:[.061d3d, .061d40) hits(4), instructions(8): <sum+37>
cmplStd/lib/math.ci:244:[.061d40, .061d54) hits(0), instructions(0): <mean+0>
cmplStd/lib/math.ci:261:[.061d58, .061d59) hits(3), instructions(3): <eval+0>
cmplStd/lib/math.ci:263:[.061d63, .061d74) hits(11), instructions(99): <eval+11>
cmplStd/lib/math.ci:262:[.061d74, .061d78) hits(11), instructions(11): <eval+28>
cmplStd/lib/math.ci:262:[.061d78, .061d80) hits(14), instructions(56): <eval+32>
cmplStd/lib/math.ci:262:[.061d59, .061d84) hits(3), instructions(12): <eval+1>
cmplStd/lib/math.ci:265:[.061d84, .061d87) hits(3), instructions(6): <eval+44>
cmplStd/lib/math.ci:272:[.061d9d, .061da5) hits(0), instructions(0): <cmp+21>
cmplStd/lib/math.ci:271:[.061d91, .061da5) hits(1), instructions(6): <cmp+9>
cmplStd/lib/math.ci:277:[.061db5, .061dbd) hits(0), instructions(0): <cmp+45>
cmplStd/lib/math.ci:276:[.061da9, .061dbd) hits(0), instructions(0): <cmp+33>
cmplStd/lib/math.ci:270:[.061d88, .061dbd) hits(1), instructions(5): <cmp+0>
cmplStd/lib/math.ci:280:[.061dbd, .061dc1) hits(1), instructions(3): <cmp+53>
cmplStd/lib/math.ci:287:[.061ddd, .061de5) hits(0), instructions(0): <cmp+21>
cmplStd/lib/math.ci:286:[.061dd1, .061de5) hits(1), instructions(6): <cmp+9>
cmplStd/lib/math.ci:292:[.061df5, .061dfd) hits(0), instructions(0): <cmp+45>
cmplStd/lib/math.ci:291:[.061de9, .061dfd) hits(0), instructions(0): <cmp+33>
cmplStd/lib/math.ci:285:[.061dc8, .061dfd) hits(1), instructions(5): <cmp+0>
cmplStd/lib/math.ci:295:[.061dfd, .061e01) hits(1), instructions(3): <cmp+53>
cmplStd/lib/math.ci:313:[.061e08, .061e0a) hits(2), instructions(2): <sinCos+0>
cmplStd/lib/math.ci:315:[.061e12, .061e13) hits(0), instructions(0): <sinCos+10>
cmplStd/lib/math.ci:316:[.061e13, .061e1b) hits(0), instructions(0): <sinCos+11>
cmplStd/lib/math.ci:314:[.061e0a, .061e1b) hits(2), instructions(8): <sinCos+2>
cmplStd/lib/math.ci:319:[.061e1b, .061e1c) hits(2), instructions(2): <sinCos+19>
cmplStd/lib/math.ci:320:[.061e1c, .061e34) hits(2), instructions(12): <sinCos+20>
cmplStd/lib/math.ci:322:[.061e44, .061e45) hits(0), instructions(0): <sinCos+60>
cmplStd/lib/math.ci:323:[.061e45, .061e57) hits(0), instructions(0): <sinCos+61>
cmplStd/lib/math.ci:324:[.061e57, .061e5b) hits(0), instructions(0): <sinCos+79>
cmplStd/lib/math.ci:326:[.061e5b, .061e5c) hits(0), instructions(0): <sinCos+83>
cmplStd/lib/math.ci:327:[.061e5c, .061e7a) hits(0), instructions(0): <sinCos+84>
cmplStd/lib/math.ci:328:[.061e7a, .061e8c) hits(0), instructions(0): <sinCos+114>
cmplStd/lib/math.ci:331:[.061e94, .061e97) hits(2), instructions(4): <sinCos+140>
cmplStd/lib/math.ci:332:[.061e97, .061e9f) hits(2), instructions(10): <sinCos+143>
cmplStd/lib/math.ci:333:[.061e9f, .061ea6) hits(2), instructions(8): <sinCos+151>
cmplStd/lib/math.ci:334:[.061ea6, .061eac) hits(2), instructions(6): <sinCos+158>
cmplStd/lib/math.ci:321:[.061e34, .061eb0) hits(2), instructions(10): <sinCos+44>
cmplStd/lib/math.ci:337:[.061eb8, .061ec6) hits(1), instructions(4): <sinCos+176>
cmplStd/lib/math.ci:336:[.061eb0, .061ec6) hits(2), instructions(6): <sinCos+168>
cmplStd/lib/math.ci:340:[.061ed2, .061ed3) hits(1), instructions(1): <sinCos+202>
cmplStd/lib/math.ci:339:[.061ec6, .061ed3) hits(2), instructions(8): <sinCos+190>
cmplStd/lib/math.ci:343:[.061ed3, .061ed8) hits(2), instructions(6): <sinCos+203>
cmplStd/lib/math.ci:344:[.061ed8, .061f18) hits(2), instructions(38): <sinCos+208>
cmplStd/lib/math.ci:345:[.061f18, .061f4b) hits(2), instructions(30): <sinCos+272>
cmplStd/lib/math.ci:346:[.061f4b, .061f57) hits(2), instructions(12): <sinCos+323>
cmplStd/lib/math.ci:369:[.061f58, .061f59) hits(1), instructions(1): <tan+0>
cmplStd/lib/math.ci:370:[.061f59, .061f5a) hits(1), instructions(1): <tan+1>
cmplStd/lib/math.ci:373:[.061f62, .061f67) hits(0), instructions(0): <tan+10>
cmplStd/lib/math.ci:374:[.061f67, .061f71) hits(0), instructions(0): <tan+15>
cmplStd/lib/math.ci:372:[.061f5a, .061f71) hits(1), instructions(4): <tan+2>
cmplStd/lib/math.ci:376:[.061f71, .061f89) hits(1), instructions(6): <tan+25>
cmplStd/lib/math.ci:378:[.061f89, .061f8a) hits(1), instructions(1): <tan+49>
cmplStd/lib/math.ci:379:[.061f8a, .061f9a) hits(1), instructions(5): <tan+50>
cmplStd/lib/math.ci:380:[.061f9a, .061fa3) hits(1), instructions(4): <tan+66>
cmplStd/lib/math.ci:384:[.061fb7, .061fc5) hits(1), instructions(4): <tan+95>
cmplStd/lib/math.ci:385:[.061fc5, .061fcf) hits(1), instructions(3): <tan+109>
cmplStd/lib/math.ci:388:[.061fdf, .061fea) hits(0), instructions(0): <tan+135>
cmplStd/lib/math.ci:389:[.061fea, .061ff4) hits(0), instructions(0): <tan+146>
cmplStd/lib/math.ci:392:[.062004, .062012) hits(0), instructions(0): <tan+172>
cmplStd/lib/math.ci:393:[.062012, .06201d) hits(0), instructions(0): <tan+186>
cmplStd/lib/math.ci:391:[.061ff8, .06201d) hits(0), instructions(0): <tan+160>
cmplStd/lib/math.ci:387:[.061fd3, .06201d) hits(0), instructions(0): <tan+123>
cmplStd/lib/math.ci:383:[.061fab, .06201d) hits(1), instructions(5): <tan+83>
cmplStd/lib/math.ci:382:[.061fa3, .06201d) hits(1), instructions(4): <tan+75>
cmplStd/lib/math.ci:396:[.06201d, .062022) hits(1), instructions(3): <tan+197>
cmplStd/lib/math.ci:397:[.062022, .062062) hits(1), instructions(19): <tan+202>
cmplStd/lib/math.ci:398:[.062062, .062089) hits(1), instructions(12): <tan+266>
cmplStd/lib/math.ci:402:[.06209a, .0620aa) hits(0), instructions(0): <tan+322>
cmplStd/lib/math.ci:401:[.062092, .0620aa) hits(1), instructions(4): <tan+314>
cmplStd/lib/math.ci:404:[.0620aa, .0620b8) hits(1), instructions(4): <tan+338>
cmplStd/lib/math.ci:400:[.062089, .0620b8) hits(1), instructions(3): <tan+305>
cmplStd/lib/math.ci:407:[.0620c1, .0620cb) hits(0), instructions(0): <tan+361>
cmplStd/lib/math.ci:406:[.0620b8, .0620cb) hits(1), instructions(3): <tan+352>
cmplStd/lib/math.ci:409:[.0620cb, .0620d2) hits(1), instructions(3): <tan+371>
cmplStd/lib/math.ci:425:[.0620d8, .0620d9) hits(1), instructions(1): <sinh+0>
cmplStd/lib/math.ci:427:[.0620e1, .0620e6) hits(0), instructions(0): <sinh+9>
cmplStd/lib/math.ci:428:[.0620e6, .0620f0) hits(0), instructions(0): <sinh+14>
cmplStd/lib/math.ci:426:[.0620d9, .0620f0) hits(1), instructions(4): <sinh+1>
cmplStd/lib/math.ci:432:[.062100, .062117) hits(0), instructions(0): <sinh+40>
cmplStd/lib/math.ci:431:[.0620f0, .062117) hits(1), instructions(4): <sinh+24>
cmplStd/lib/math.ci:435:[.062117, .062118) hits(1), instructions(1): <sinh+63>
cmplStd/lib/math.ci:437:[.062128, .062142) hits(1), instructions(9): <sinh+80>
cmplStd/lib/math.ci:440:[.062146, .06214b) hits(0), instructions(0): <sinh+110>
cmplStd/lib/math.ci:441:[.06214b, .062180) hits(0), instructions(0): <sinh+115>
cmplStd/lib/math.ci:442:[.062180, .0621ab) hits(0), instructions(0): <sinh+168>
cmplStd/lib/math.ci:436:[.062118, .0621af) hits(1), instructions(5): <sinh+64>
cmplStd/lib/math.ci:446:[.0621b8, .0621c2) hits(0), instructions(0): <sinh+224>
cmplStd/lib/math.ci:445:[.0621af, .0621c2) hits(1), instructions(3): <sinh+215>
cmplStd/lib/math.ci:448:[.0621c2, .0621c9) hits(1), instructions(3): <sinh+234>
cmplStd/lib/math.ci:454:[.0621d8, .0621dd) hits(0), instructions(0): <cosh+8>
cmplStd/lib/math.ci:453:[.0621d0, .0621dd) hits(1), instructions(4): <cosh+0>
cmplStd/lib/math.ci:457:[.0621ed, .062200) hits(0), instructions(0): <cosh+29>
cmplStd/lib/math.ci:456:[.0621dd, .062200) hits(1), instructions(4): <cosh+13>
cmplStd/lib/math.ci:459:[.062200, .06221b) hits(1), instructions(10): <cosh+48>
cmplStd/lib/math.ci:470:[.062228, .06222c) hits(0), instructions(0): <asin+8>
cmplStd/lib/math.ci:468:[.062220, .06222c) hits(2), instructions(8): <asin+0>
cmplStd/lib/math.ci:473:[.06222c, .06222d) hits(2), instructions(2): <asin+12>
cmplStd/lib/math.ci:475:[.062235, .06223f) hits(0), instructions(0): <asin+21>
cmplStd/lib/math.ci:476:[.06223f, .062244) hits(0), instructions(0): <asin+31>
cmplStd/lib/math.ci:474:[.06222d, .062244) hits(2), instructions(8): <asin+13>
cmplStd/lib/math.ci:481:[.062254, .062264) hits(0), instructions(0): <asin+52>
cmplStd/lib/math.ci:479:[.062244, .062264) hits(2), instructions(8): <asin+36>
cmplStd/lib/math.ci:484:[.062264, .062277) hits(2), instructions(12): <asin+68>
cmplStd/lib/math.ci:486:[.062287, .0622a5) hits(0), instructions(0): <asin+103>
cmplStd/lib/math.ci:489:[.0622a9, .0622b3) hits(2), instructions(8): <asin+137>
cmplStd/lib/math.ci:485:[.062277, .0622b3) hits(2), instructions(8): <asin+87>
cmplStd/lib/math.ci:493:[.0622bc, .0622c6) hits(0), instructions(0): <asin+156>
cmplStd/lib/math.ci:492:[.0622b3, .0622c6) hits(2), instructions(6): <asin+147>
cmplStd/lib/math.ci:495:[.0622c6, .0622cd) hits(2), instructions(6): <asin+166>
cmplStd/lib/math/Complex.ci:26:[.0622d0, .0622d3) hits(0), instructions(0): <Complex+0>
::[.0622d3, .0622d6) hits(0), instructions(0): <Complex+3>
cmplStd/lib/math/Complex.ci:25:[.0622d0, .0622d7) hits(0), instructions(0): <Complex+0>
cmplStd/lib/math/Complex.ci:33:[.0622d8, .0622db) hits(0), instructions(0): <Complex+0>
cmplStd/lib/math/Complex.ci:34:[.0622db, .0622de) hits(0), instructions(0): <Complex+3>
cmplStd/lib/math/Complex.ci:32:[.0622d8, .0622df) hits(0), instructions(0): <Complex+0>
cmplStd/lib/math/Complex.ci:91:[.06230f, .062314) hits(0), instructions(0): <div+47>
cmplStd/lib/math/Complex.ci:92:[.062314, .06231c) hits(0), instructions(0): <div+52>
cmplStd/lib/math/Complex.ci:94:[.06231c, .062329) hits(0), instructions(0): <div+60>
cmplStd/lib/math/Complex.ci:95:[.062329, .062336) hits(0), instructions(0): <div+73>
cmplStd/lib/math/Complex.ci:93:[.06231c, .06233b) hits(0), instructions(0): <div+60>
cmplStd/lib/math/Complex.ci:90:[.0622e0, .06233f) hits(0), instructions(0): <div+0>
cmplStd/lib/math/Complex.ci:98:[.06233f, .062344) hits(0), instructions(0): <div+95>
cmplStd/lib/math/Complex.ci:99:[.062344, .06234c) hits(0), instructions(0): <div+100>
cmplStd/lib/math/Complex.ci:101:[.06234c, .062359) hits(0), instructions(0): <div+108>
cmplStd/lib/math/Complex.ci:102:[.062359, .062366) hits(0), instructions(0): <div+121>
cmplStd/lib/math/Complex.ci:100:[.06234c, .06236b) hits(0), instructions(0): <div+108>
cmplStd/lib/math/Complex.ci:118:[.062370, .06237b) hits(0), instructions(0): <inv+0>
cmplStd/lib/math/Complex.ci:120:[.06237b, .062382) hits(0), instructions(0): <inv+11>
cmplStd/lib/math/Complex.ci:121:[.062382, .06238a) hits(0), instructions(0): <inv+18>
cmplStd/lib/math/Complex.ci:119:[.06237b, .06238f) hits(0), instructions(0): <inv+11>
cmplStd/lib/math/Complex.ci:136:[.062390, .0623a7) hits(0), instructions(0): <pow+0>
cmplStd/lib/math/Complex.ci:137:[.0623a7, .0623b7) hits(0), instructions(0): <pow+23>
cmplStd/lib/math/Complex.ci:138:[.0623b7, .0623c6) hits(0), instructions(0): <pow+39>
cmplStd/lib/math/Complex.ci:139:[.0623c6, .0623d9) hits(0), instructions(0): <pow+54>
cmplStd/lib/math/Complex.ci:141:[.0623d9, .0623e4) hits(0), instructions(0): <pow+73>
cmplStd/lib/math/Complex.ci:142:[.0623e4, .0623ef) hits(0), instructions(0): <pow+84>
cmplStd/lib/math/Complex.ci:140:[.0623d9, .0623f4) hits(0), instructions(0): <pow+73>
cmplStd/lib/math/Matrix4f.ci:67:[.0623f8, .0623fb) hits(0), instructions(0): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:67:[.0623fb, .0623fe) hits(0), instructions(0): <mat4f+3>
cmplStd/lib/math/Matrix4f.ci:67:[.0623fe, .062401) hits(0), instructions(0): <mat4f+6>
cmplStd/lib/math/Matrix4f.ci:67:[.062401, .062404) hits(0), instructions(0): <mat4f+9>
cmplStd/lib/math/Matrix4f.ci:68:[.062404, .062407) hits(0), instructions(0): <mat4f+12>
cmplStd/lib/math/Matrix4f.ci:68:[.062407, .06240a) hits(0), instructions(0): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:68:[.06240a, .06240d) hits(0), instructions(0): <mat4f+18>
cmplStd/lib/math/Matrix4f.ci:68:[.06240d, .062410) hits(0), instructions(0): <mat4f+21>
cmplStd/lib/math/Matrix4f.ci:69:[.062410, .062413) hits(0), instructions(0): <mat4f+24>
cmplStd/lib/math/Matrix4f.ci:69:[.062413, .062416) hits(0), instructions(0): <mat4f+27>
cmplStd/lib/math/Matrix4f.ci:69:[.062416, .062419) hits(0), instructions(0): <mat4f+30>
cmplStd/lib/math/Matrix4f.ci:69:[.062419, .06241c) hits(0), instructions(0): <mat4f+33>
cmplStd/lib/math/Matrix4f.ci:70:[.06241c, .06241f) hits(0), instructions(0): <mat4f+36>
cmplStd/lib/math/Matrix4f.ci:70:[.06241f, .062422) hits(0), instructions(0): <mat4f+39>
cmplStd/lib/math/Matrix4f.ci:70:[.062422, .062425) hits(0), instructions(0): <mat4f+42>
cmplStd/lib/math/Matrix4f.ci:70:[.062425, .062428) hits(0), instructions(0): <mat4f+45>
cmplStd/lib/math/Matrix4f.ci:66:[.0623f8, .062429) hits(0), instructions(0): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.062430, .062435) hits(0), instructions(0): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.062435, .06243a) hits(0), instructions(0): <mat4f+5>
cmplStd/lib/math/Matrix4f.ci:76:[.06243a, .06243f) hits(0), instructions(0): <mat4f+10>
cmplStd/lib/math/Matrix4f.ci:76:[.06243f, .062444) hits(0), instructions(0): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:76:[.062430, .062445) hits(0), instructions(0): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:89:[.062448, .06244b) hits(0), instructions(0): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:89:[.06244b, .06244e) hits(0), instructions(0): <transpose+3>
cmplStd/lib/math/Matrix4f.ci:89:[.06244e, .062451) hits(0), instructions(0): <transpose+6>
cmplStd/lib/math/Matrix4f.ci:89:[.062451, .062454) hits(0), instructions(0): <transpose+9>
cmplStd/lib/math/Matrix4f.ci:90:[.062454, .062457) hits(0), instructions(0): <transpose+12>
cmplStd/lib/math/Matrix4f.ci:90:[.062457, .06245a) hits(0), instructions(0): <transpose+15>
cmplStd/lib/math/Matrix4f.ci:90:[.06245a, .06245d) hits(0), instructions(0): <transpose+18>
cmplStd/lib/math/Matrix4f.ci:90:[.06245d, .062460) hits(0), instructions(0): <transpose+21>
cmplStd/lib/math/Matrix4f.ci:91:[.062460, .062463) hits(0), instructions(0): <transpose+24>
cmplStd/lib/math/Matrix4f.ci:91:[.062463, .062466) hits(0), instructions(0): <transpose+27>
cmplStd/lib/math/Matrix4f.ci:91:[.062466, .062469) hits(0), instructions(0): <transpose+30>
cmplStd/lib/math/Matrix4f.ci:91:[.062469, .06246c) hits(0), instructions(0): <transpose+33>
cmplStd/lib/math/Matrix4f.ci:92:[.06246c, .06246f) hits(0), instructions(0): <transpose+36>
cmplStd/lib/math/Matrix4f.ci:92:[.06246f, .062472) hits(0), instructions(0): <transpose+39>
cmplStd/lib/math/Matrix4f.ci:92:[.062472, .062475) hits(0), instructions(0): <transpose+42>
cmplStd/lib/math/Matrix4f.ci:92:[.062475, .062478) hits(0), instructions(0): <transpose+45>
cmplStd/lib/math/Matrix4f.ci:88:[.062448, .062479) hits(0), instructions(0): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:98:[.062480, .06249c) hits(0), instructions(0): <mul+0>
cmplStd/lib/math/Matrix4f.ci:100:[.06249c, .0624ce) hits(0), instructions(0): <mul+28>
cmplStd/lib/math/Matrix4f.ci:101:[.0624ce, .062504) hits(0), instructions(0): <mul+78>
cmplStd/lib/math/Matrix4f.ci:102:[.062504, .06253a) hits(0), instructions(0): <mul+132>
cmplStd/lib/math/Matrix4f.ci:103:[.06253a, .062570) hits(0), instructions(0): <mul+186>
cmplStd/lib/math/Matrix4f.ci:99:[.06249c, .062575) hits(0), instructions(0): <mul+28>
cmplStd/lib/math/Matrix4f.ci:112:[.062578, .06258a) hits(0), instructions(0): <rotation+0>
cmplStd/lib/math/Matrix4f.ci:114:[.06259b, .0625bf) hits(0), instructions(0): <rotation+35>
cmplStd/lib/math/Matrix4f.ci:116:[.0625bf, .0625c5) hits(0), instructions(0): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:117:[.0625c5, .0625cb) hits(0), instructions(0): <rotation+77>
cmplStd/lib/math/Matrix4f.ci:118:[.0625cb, .0625d1) hits(0), instructions(0): <rotation+83>
cmplStd/lib/math/Matrix4f.ci:119:[.0625d1, .0625d7) hits(0), instructions(0): <rotation+89>
cmplStd/lib/math/Matrix4f.ci:115:[.0625bf, .0625dc) hits(0), instructions(0): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:113:[.06258a, .0625dc) hits(0), instructions(0): <rotation+18>
cmplStd/lib/math/Matrix4f.ci:122:[.0625dc, .0625e2) hits(0), instructions(0): <rotation+100>
cmplStd/lib/math/Matrix4f.ci:123:[.0625e2, .0625ec) hits(0), instructions(0): <rotation+106>
cmplStd/lib/math/Matrix4f.ci:124:[.0625ec, .0625f6) hits(0), instructions(0): <rotation+116>
cmplStd/lib/math/Matrix4f.ci:125:[.0625f6, .0625f9) hits(0), instructions(0): <rotation+126>
cmplStd/lib/math/Matrix4f.ci:126:[.0625f9, .062600) hits(0), instructions(0): <rotation+129>
cmplStd/lib/math/Matrix4f.ci:127:[.062600, .062607) hits(0), instructions(0): <rotation+136>
cmplStd/lib/math/Matrix4f.ci:128:[.062607, .06260c) hits(0), instructions(0): <rotation+143>
cmplStd/lib/math/Matrix4f.ci:129:[.06260c, .062611) hits(0), instructions(0): <rotation+148>
cmplStd/lib/math/Matrix4f.ci:130:[.062611, .062616) hits(0), instructions(0): <rotation+153>
cmplStd/lib/math/Matrix4f.ci:131:[.062616, .06261b) hits(0), instructions(0): <rotation+158>
cmplStd/lib/math/Matrix4f.ci:132:[.06261b, .062620) hits(0), instructions(0): <rotation+163>
cmplStd/lib/math/Matrix4f.ci:133:[.062620, .062625) hits(0), instructions(0): <rotation+168>
cmplStd/lib/math/Matrix4f.ci:135:[.062625, .06262b) hits(0), instructions(0): <rotation+173>
cmplStd/lib/math/Matrix4f.ci:136:[.06262b, .062631) hits(0), instructions(0): <rotation+179>
cmplStd/lib/math/Matrix4f.ci:137:[.062631, .062639) hits(0), instructions(0): <rotation+185>
cmplStd/lib/math/Matrix4f.ci:140:[.062639, .062646) hits(0), instructions(0): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:141:[.062646, .062653) hits(0), instructions(0): <rotation+206>
cmplStd/lib/math/Matrix4f.ci:142:[.062653, .062660) hits(0), instructions(0): <rotation+219>
cmplStd/lib/math/Matrix4f.ci:143:[.062660, .06268b) hits(0), instructions(0): <rotation+232>
cmplStd/lib/math/Matrix4f.ci:145:[.06268b, .062698) hits(0), instructions(0): <rotation+275>
cmplStd/lib/math/Matrix4f.ci:146:[.062698, .0626a5) hits(0), instructions(0): <rotation+288>
cmplStd/lib/math/Matrix4f.ci:147:[.0626a5, .0626b2) hits(0), instructions(0): <rotation+301>
cmplStd/lib/math/Matrix4f.ci:148:[.0626b2, .0626dd) hits(0), instructions(0): <rotation+314>
cmplStd/lib/math/Matrix4f.ci:150:[.0626dd, .0626ea) hits(0), instructions(0): <rotation+357>
cmplStd/lib/math/Matrix4f.ci:151:[.0626ea, .0626f7) hits(0), instructions(0): <rotation+370>
cmplStd/lib/math/Matrix4f.ci:152:[.0626f7, .062704) hits(0), instructions(0): <rotation+383>
cmplStd/lib/math/Matrix4f.ci:153:[.062704, .06272f) hits(0), instructions(0): <rotation+396>
cmplStd/lib/math/Matrix4f.ci:155:[.06272f, .062739) hits(0), instructions(0): <rotation+439>
cmplStd/lib/math/Matrix4f.ci:139:[.062639, .06273e) hits(0), instructions(0): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:161:[.062740, .062747) hits(0), instructions(0): <rotation+0>
cmplStd/lib/math/Matrix4f.ci:162:[.062747, .062756) hits(0), instructions(0): <rotation+7>
cmplStd/lib/math/Matrix4f.ci:163:[.062756, .062765) hits(0), instructions(0): <rotation+22>
cmplStd/lib/math/Matrix4f.ci:164:[.062765, .062770) hits(0), instructions(0): <rotation+37>
cmplStd/lib/math/Matrix4f.ci:165:[.062770, .06277b) hits(0), instructions(0): <rotation+48>
cmplStd/lib/math/Matrix4f.ci:166:[.06277b, .06278a) hits(0), instructions(0): <rotation+59>
cmplStd/lib/math/Matrix4f.ci:167:[.06278a, .062790) hits(0), instructions(0): <rotation+74>
cmplStd/lib/math/Matrix4f.ci:168:[.062790, .062796) hits(0), instructions(0): <rotation+80>
cmplStd/lib/math/Matrix4f.ci:169:[.062796, .06279e) hits(0), instructions(0): <rotation+86>
cmplStd/lib/math/Matrix4f.ci:170:[.06279e, .0627ae) hits(0), instructions(0): <rotation+94>
cmplStd/lib/math/Matrix4f.ci:173:[.0627ae, .0627b8) hits(0), instructions(0): <rotation+110>
cmplStd/lib/math/Matrix4f.ci:174:[.0627b8, .0627c2) hits(0), instructions(0): <rotation+120>
cmplStd/lib/math/Matrix4f.ci:175:[.0627c2, .0627cc) hits(0), instructions(0): <rotation+130>
cmplStd/lib/math/Matrix4f.ci:176:[.0627cc, .0627cf) hits(0), instructions(0): <rotation+140>
cmplStd/lib/math/Matrix4f.ci:178:[.0627cf, .0627d9) hits(0), instructions(0): <rotation+143>
cmplStd/lib/math/Matrix4f.ci:179:[.0627d9, .0627e3) hits(0), instructions(0): <rotation+153>
cmplStd/lib/math/Matrix4f.ci:180:[.0627e3, .0627ed) hits(0), instructions(0): <rotation+163>
cmplStd/lib/math/Matrix4f.ci:181:[.0627ed, .0627f0) hits(0), instructions(0): <rotation+173>
cmplStd/lib/math/Matrix4f.ci:183:[.0627f0, .0627fa) hits(0), instructions(0): <rotation+176>
cmplStd/lib/math/Matrix4f.ci:184:[.0627fa, .062804) hits(0), instructions(0): <rotation+186>
cmplStd/lib/math/Matrix4f.ci:185:[.062804, .06280e) hits(0), instructions(0): <rotation+196>
cmplStd/lib/math/Matrix4f.ci:186:[.06280e, .062811) hits(0), instructions(0): <rotation+206>
cmplStd/lib/math/Matrix4f.ci:188:[.062811, .06281b) hits(0), instructions(0): <rotation+209>
cmplStd/lib/math/Matrix4f.ci:172:[.0627ae, .062820) hits(0), instructions(0): <rotation+110>
cmplStd/lib/math/Matrix4f.ci:195:[.062820, .062827) hits(0), instructions(0): <translation+0>
cmplStd/lib/math/Matrix4f.ci:195:[.062827, .06282a) hits(0), instructions(0): <translation+7>
cmplStd/lib/math/Matrix4f.ci:195:[.06282a, .06282d) hits(0), instructions(0): <translation+10>
cmplStd/lib/math/Matrix4f.ci:195:[.06282d, .062835) hits(0), instructions(0): <translation+13>
cmplStd/lib/math/Matrix4f.ci:196:[.062835, .062838) hits(0), instructions(0): <translation+21>
cmplStd/lib/math/Matrix4f.ci:196:[.062838, .06283f) hits(0), instructions(0): <translation+24>
cmplStd/lib/math/Matrix4f.ci:196:[.06283f, .062842) hits(0), instructions(0): <translation+31>
cmplStd/lib/math/Matrix4f.ci:196:[.062842, .06284e) hits(0), instructions(0): <translation+34>
cmplStd/lib/math/Matrix4f.ci:197:[.06284e, .062851) hits(0), instructions(0): <translation+46>
cmplStd/lib/math/Matrix4f.ci:197:[.062851, .062854) hits(0), instructions(0): <translation+49>
cmplStd/lib/math/Matrix4f.ci:197:[.062854, .06285b) hits(0), instructions(0): <translation+52>
cmplStd/lib/math/Matrix4f.ci:197:[.06285b, .062867) hits(0), instructions(0): <translation+59>
cmplStd/lib/math/Matrix4f.ci:198:[.062867, .06286a) hits(0), instructions(0): <translation+71>
cmplStd/lib/math/Matrix4f.ci:198:[.06286a, .06286d) hits(0), instructions(0): <translation+74>
cmplStd/lib/math/Matrix4f.ci:198:[.06286d, .062870) hits(0), instructions(0): <translation+77>
cmplStd/lib/math/Matrix4f.ci:198:[.062870, .062877) hits(0), instructions(0): <translation+80>
cmplStd/lib/math/Matrix4f.ci:194:[.062820, .062878) hits(0), instructions(0): <translation+0>
cmplStd/lib/math/Matrix4f.ci:206:[.062878, .0628af) hits(0), instructions(0): <scale+0>
cmplStd/lib/math/Matrix4f.ci:206:[.0628af, .0628b2) hits(0), instructions(0): <scale+55>
cmplStd/lib/math/Matrix4f.ci:206:[.0628b2, .0628b5) hits(0), instructions(0): <scale+58>
cmplStd/lib/math/Matrix4f.ci:206:[.0628b5, .0628b8) hits(0), instructions(0): <scale+61>
cmplStd/lib/math/Matrix4f.ci:207:[.0628b8, .0628bb) hits(0), instructions(0): <scale+64>
cmplStd/lib/math/Matrix4f.ci:207:[.0628bb, .0628f6) hits(0), instructions(0): <scale+67>
cmplStd/lib/math/Matrix4f.ci:207:[.0628f6, .0628f9) hits(0), instructions(0): <scale+126>
cmplStd/lib/math/Matrix4f.ci:207:[.0628f9, .0628fc) hits(0), instructions(0): <scale+129>
cmplStd/lib/math/Matrix4f.ci:208:[.0628fc, .0628ff) hits(0), instructions(0): <scale+132>
cmplStd/lib/math/Matrix4f.ci:208:[.0628ff, .062902) hits(0), instructions(0): <scale+135>
cmplStd/lib/math/Matrix4f.ci:208:[.062902, .06293d) hits(0), instructions(0): <scale+138>
cmplStd/lib/math/Matrix4f.ci:208:[.06293d, .062940) hits(0), instructions(0): <scale+197>
cmplStd/lib/math/Matrix4f.ci:209:[.062940, .062943) hits(0), instructions(0): <scale+200>
cmplStd/lib/math/Matrix4f.ci:209:[.062943, .062946) hits(0), instructions(0): <scale+203>
cmplStd/lib/math/Matrix4f.ci:209:[.062946, .062949) hits(0), instructions(0): <scale+206>
cmplStd/lib/math/Matrix4f.ci:209:[.062949, .062950) hits(0), instructions(0): <scale+209>
cmplStd/lib/math/Matrix4f.ci:205:[.062878, .062951) hits(0), instructions(0): <scale+0>
cmplStd/lib/math/Vector2d.ci:16:[.062958, .06295b) hits(0), instructions(0): <vec2d+0>
cmplStd/lib/math/Vector2d.ci:17:[.06295b, .06295e) hits(0), instructions(0): <vec2d+3>
cmplStd/lib/math/Vector2d.ci:15:[.062958, .06295f) hits(0), instructions(0): <vec2d+0>
cmplStd/lib/text/string.ci:6:[.06296c, .062970) hits(0), instructions(0): <length+12>
cmplStd/lib/text/string.ci:5:[.062960, .062970) hits(0), instructions(0): <length+0>
cmplStd/lib/text/string.ci:8:[.062970, .062971) hits(0), instructions(0): <length+16>
cmplStd/lib/text/string.ci:9:[.062975, .062979) hits(0), instructions(0): <length+21>
cmplStd/lib/text/string.ci:9:[.062979, .062983) hits(0), instructions(0): <length+25>
cmplStd/lib/text/string.ci:9:[.062971, .062983) hits(0), instructions(0): <length+17>
cmplStd/lib/text/string.ci:11:[.062983, .062986) hits(0), instructions(0): <length+35>
cmplStd/lib/text/string.ci:18:[.06299d, .0629a0) hits(0), instructions(0): <indexOf+21>
cmplStd/lib/text/string.ci:17:[.06298d, .0629a0) hits(0), instructions(0): <indexOf+5>
cmplStd/lib/text/string.ci:16:[.0629a0, .0629a4) hits(0), instructions(0): <indexOf+24>
cmplStd/lib/text/string.ci:16:[.0629a4, .0629ae) hits(0), instructions(0): <indexOf+28>
cmplStd/lib/text/string.ci:16:[.062988, .0629b2) hits(0), instructions(0): <indexOf+0>
cmplStd/lib/text/string.ci:21:[.0629b2, .0629ba) hits(0), instructions(0): <indexOf+42>
cmplStd/lib/text/string.ci:26:[.0629c0, .0629c5) hits(0), instructions(0): <lastIndexOf+0>
cmplStd/lib/text/string.ci:29:[.0629da, .0629dd) hits(0), instructions(0): <lastIndexOf+26>
cmplStd/lib/text/string.ci:28:[.0629ca, .0629dd) hits(0), instructions(0): <lastIndexOf+10>
cmplStd/lib/text/string.ci:27:[.0629dd, .0629e1) hits(0), instructions(0): <lastIndexOf+29>
cmplStd/lib/text/string.ci:27:[.0629e1, .0629eb) hits(0), instructions(0): <lastIndexOf+33>
cmplStd/lib/text/string.ci:27:[.0629c5, .0629ef) hits(0), instructions(0): <lastIndexOf+5>
cmplStd/lib/text/string.ci:32:[.0629ef, .0629f2) hits(0), instructions(0): <lastIndexOf+47>
cmplStd/lib/text/string.ci:39:[.062a17, .062a22) hits(0), instructions(0): <startsWith+31>
cmplStd/lib/text/string.ci:38:[.0629fd, .062a22) hits(0), instructions(0): <startsWith+5>
cmplStd/lib/text/string.ci:37:[.062a22, .062a26) hits(0), instructions(0): <startsWith+42>
cmplStd/lib/text/string.ci:37:[.062a26, .062a32) hits(0), instructions(0): <startsWith+46>
cmplStd/lib/text/string.ci:37:[.0629f8, .062a36) hits(0), instructions(0): <startsWith+0>
cmplStd/lib/text/string.ci:42:[.062a36, .062a41) hits(0), instructions(0): <startsWith+62>
cmplStd/lib/text/string.ci:47:[.062a48, .062a55) hits(0), instructions(0): <endsWith+0>
cmplStd/lib/text/string.ci:48:[.062a55, .062a62) hits(0), instructions(0): <endsWith+13>
cmplStd/lib/text/string.ci:50:[.062a6b, .062a76) hits(0), instructions(0): <endsWith+35>
cmplStd/lib/text/string.ci:49:[.062a62, .062a76) hits(0), instructions(0): <endsWith+26>
cmplStd/lib/text/string.ci:54:[.062a9b, .062aa6) hits(0), instructions(0): <endsWith+83>
cmplStd/lib/text/string.ci:53:[.062a7b, .062aa6) hits(0), instructions(0): <endsWith+51>
cmplStd/lib/text/string.ci:52:[.062aa6, .062aaa) hits(0), instructions(0): <endsWith+94>
cmplStd/lib/text/string.ci:52:[.062aaa, .062ab3) hits(0), instructions(0): <endsWith+98>
cmplStd/lib/text/string.ci:52:[.062a76, .062ab7) hits(0), instructions(0): <endsWith+46>
cmplStd/lib/text/string.ci:57:[.062ab7, .062ac6) hits(0), instructions(0): <endsWith+111>
cmplStd/lib/text/string.ci:62:[.062ac8, .062ac9) hits(0), instructions(0): <compare+0>
cmplStd/lib/text/string.ci:64:[.062ace, .062ae4) hits(0), instructions(0): <compare+6>
cmplStd/lib/text/string.ci:66:[.062af0, .062af4) hits(0), instructions(0): <compare+40>
cmplStd/lib/text/string.ci:65:[.062ae4, .062af4) hits(0), instructions(0): <compare+28>
cmplStd/lib/text/string.ci:63:[.062af4, .062af8) hits(0), instructions(0): <compare+44>
cmplStd/lib/text/string.ci:63:[.062af8, .062b00) hits(0), instructions(0): <compare+48>
cmplStd/lib/text/string.ci:63:[.062ac9, .062b04) hits(0), instructions(0): <compare+1>
cmplStd/lib/text/string.ci:69:[.062b04, .062b07) hits(0), instructions(0): <compare+60>
cmplStd/lib/text/string.ci:76:[.062b17, .062b22) hits(0), instructions(0): <ignCase+15>
cmplStd/lib/text/string.ci:75:[.062b08, .062b22) hits(0), instructions(0): <ignCase+0>
cmplStd/lib/text/string.ci:79:[.062b31, .062b3c) hits(0), instructions(0): <ignCase+41>
cmplStd/lib/text/string.ci:78:[.062b22, .062b3c) hits(0), instructions(0): <ignCase+26>
cmplStd/lib/text/string.ci:81:[.062b3c, .062b4f) hits(0), instructions(0): <ignCase+52>
cmplStd/lib/text/string.ci:84:[.062b50, .062b74) hits(0), instructions(0): <ignCaseCmp+0>
cmplStd/lib/text/string.ci:89:[.062b78, .062b86) hits(0), instructions(0): <caseCmp+0>
cmplStd/lib/text/string.ci:136:[.062b94, .062bab) hits(0), instructions(0): <append+12>
cmplStd/lib/text/string.ci:135:[.062b88, .062bab) hits(0), instructions(0): <append+0>
cmplStd/lib/text/string.ci:140:[.062bb9, .062bbd) hits(0), instructions(0): <append+49>
cmplStd/lib/text/string.ci:139:[.062bb0, .062bbd) hits(0), instructions(0): <append+40>
cmplStd/lib/text/string.ci:142:[.062bbd, .062bc9) hits(0), instructions(0): <append+53>
cmplStd/lib/text/string.ci:143:[.062bc9, .062bd1) hits(0), instructions(0): <append+65>
cmplStd/lib/text/string.ci:138:[.062bd1, .062bd5) hits(0), instructions(0): <append+73>
cmplStd/lib/text/string.ci:138:[.062bd5, .062bdf) hits(0), instructions(0): <append+77>
cmplStd/lib/text/string.ci:138:[.062bab, .062be3) hits(0), instructions(0): <append+35>
cmplStd/lib/text/string.ci:147:[.062bec, .062bf4) hits(0), instructions(0): <append+100>
cmplStd/lib/text/string.ci:146:[.062be3, .062bf4) hits(0), instructions(0): <append+91>
cmplStd/lib/text/string.ci:149:[.062bf4, .062bfb) hits(0), instructions(0): <append+108>
cmplStd/lib/text/string.ci:150:[.062bfb, .062bff) hits(0), instructions(0): <append+115>
cmplStd/lib/text/string.ci:158:[.062c10, .062c11) hits(0), instructions(0): <append+0>
cmplStd/lib/text/string.ci:159:[.062c11, .062c15) hits(0), instructions(0): <append+1>
cmplStd/lib/text/string.ci:161:[.062c15, .062c4b) hits(0), instructions(0): <append+5>
cmplStd/lib/text/string.ci:162:[.062c4b, .062c80) hits(0), instructions(0): <append+59>
cmplStd/lib/text/string.ci:166:[.062c84, .062ca1) hits(0), instructions(0): <append+116>
cmplStd/lib/text/string.ci:165:[.062ca1, .062ca9) hits(0), instructions(0): <append+145>
cmplStd/lib/text/string.ci:165:[.062ca9, .062cb1) hits(0), instructions(0): <append+153>
cmplStd/lib/text/string.ci:165:[.062c80, .062cb1) hits(0), instructions(0): <append+112>
cmplStd/lib/text/string.ci:169:[.062cb9, .062cce) hits(0), instructions(0): <append+169>
cmplStd/lib/text/string.ci:168:[.062cb1, .062cce) hits(0), instructions(0): <append+161>
cmplStd/lib/text/string.ci:172:[.062cce, .062cd8) hits(0), instructions(0): <append+190>
cmplStd/lib/text/string.ci:174:[.062cd8, .062cdf) hits(0), instructions(0): <append+200>
cmplStd/lib/text/string.ci:176:[.062cea, .062cf4) hits(0), instructions(0): <append+218>
cmplStd/lib/text/string.ci:175:[.062cdf, .062cf4) hits(0), instructions(0): <append+207>
cmplStd/lib/text/string.ci:181:[.062cfd, .062d05) hits(0), instructions(0): <append+237>
cmplStd/lib/text/string.ci:185:[.062d23, .062d57) hits(0), instructions(0): <append+275>
cmplStd/lib/text/string.ci:186:[.062d57, .062d62) hits(0), instructions(0): <append+327>
cmplStd/lib/text/string.ci:187:[.062d62, .062d6a) hits(0), instructions(0): <append+338>
cmplStd/lib/text/string.ci:184:[.062d6a, .062d72) hits(0), instructions(0): <append+346>
cmplStd/lib/text/string.ci:184:[.062d72, .062d7a) hits(0), instructions(0): <append+354>
cmplStd/lib/text/string.ci:184:[.062d1f, .062d7a) hits(0), instructions(0): <append+271>
cmplStd/lib/text/string.ci:182:[.062d05, .062d7a) hits(0), instructions(0): <append+245>
cmplStd/lib/text/string.ci:190:[.062d7a, .062dae) hits(0), instructions(0): <append+362>
cmplStd/lib/text/string.ci:191:[.062dae, .062db7) hits(0), instructions(0): <append+414>
cmplStd/lib/text/string.ci:192:[.062db7, .062dbf) hits(0), instructions(0): <append+423>
cmplStd/lib/text/string.ci:180:[.062cf4, .062dbf) hits(0), instructions(0): <append+228>
cmplStd/lib/text/string.ci:197:[.062dc3, .062df7) hits(0), instructions(0): <append+435>
cmplStd/lib/text/string.ci:198:[.062df7, .062e02) hits(0), instructions(0): <append+487>
cmplStd/lib/text/string.ci:199:[.062e02, .062e0a) hits(0), instructions(0): <append+498>
cmplStd/lib/text/string.ci:196:[.062e0a, .062e12) hits(0), instructions(0): <append+506>
cmplStd/lib/text/string.ci:196:[.062e12, .062e1a) hits(0), instructions(0): <append+514>
cmplStd/lib/text/string.ci:196:[.062dbf, .062e1a) hits(0), instructions(0): <append+431>
cmplStd/lib/text/string.ci:204:[.062e1f, .062e53) hits(0), instructions(0): <append+527>
cmplStd/lib/text/string.ci:205:[.062e53, .062e64) hits(0), instructions(0): <append+579>
cmplStd/lib/text/string.ci:206:[.062e64, .062e6c) hits(0), instructions(0): <append+596>
cmplStd/lib/text/string.ci:203:[.062e6c, .062e70) hits(0), instructions(0): <append+604>
cmplStd/lib/text/string.ci:203:[.062e70, .062e79) hits(0), instructions(0): <append+608>
cmplStd/lib/text/string.ci:203:[.062e1a, .062e7d) hits(0), instructions(0): <append+522>
cmplStd/lib/text/string.ci:210:[.062e86, .062e8e) hits(0), instructions(0): <append+630>
cmplStd/lib/text/string.ci:209:[.062e7d, .062e8e) hits(0), instructions(0): <append+621>
cmplStd/lib/text/string.ci:212:[.062e8e, .062e95) hits(0), instructions(0): <append+638>
cmplStd/lib/text/string.ci:213:[.062e95, .062e9d) hits(0), instructions(0): <append+645>
cmplStd/lib/text/string.ci:231:[.062ea4, .062ebd) hits(0), instructions(0): <append+4>
cmplStd/lib/text/string.ci:232:[.062ebd, .062ec6) hits(0), instructions(0): <append+29>
cmplStd/lib/text/string.ci:233:[.062ec6, .062ecf) hits(0), instructions(0): <append+38>
cmplStd/lib/text/string.ci:234:[.062ecf, .062edb) hits(0), instructions(0): <append+47>
cmplStd/lib/text/string.ci:230:[.062ea0, .062edb) hits(0), instructions(0): <append+0>
cmplStd/lib/text/string.ci:237:[.062ee3, .062ee8) hits(0), instructions(0): <append+67>
cmplStd/lib/text/string.ci:236:[.062edb, .062ee8) hits(0), instructions(0): <append+59>
cmplStd/lib/text/string.ci:239:[.062ee8, .062f06) hits(0), instructions(0): <append+72>
cmplStd/lib/text/string.ci:259:[.062f24, .062f3d) hits(0), instructions(0): <append+4>
cmplStd/lib/text/string.ci:260:[.062f3d, .062f44) hits(0), instructions(0): <append+29>
cmplStd/lib/text/string.ci:261:[.062f44, .062f50) hits(0), instructions(0): <append+36>
cmplStd/lib/text/string.ci:262:[.062f50, .062f65) hits(0), instructions(0): <append+48>
cmplStd/lib/text/string.ci:258:[.062f20, .062f65) hits(0), instructions(0): <append+0>
cmplStd/lib/text/string.ci:265:[.062f65, .062f8c) hits(0), instructions(0): <append+69>
cmplStd/lib/text/string.ci:267:[.062f8c, .062fb0) hits(0), instructions(0): <append+108>
cmplStd/lib/text/string.ci:268:[.062fb0, .062fcd) hits(0), instructions(0): <append+144>
cmplStd/lib/text/string.ci:272:[.062fe8, .062ff0) hits(0), instructions(0): <append+200>
cmplStd/lib/text/string.ci:271:[.062fcd, .062ff0) hits(0), instructions(0): <append+173>
cmplStd/lib/text/string.ci:276:[.062ff0, .063006) hits(0), instructions(0): <append+208>
cmplStd/lib/text/string.ci:277:[.063006, .06302d) hits(0), instructions(0): <append+230>
cmplStd/lib/text/string.ci:281:[.06303a, .063042) hits(0), instructions(0): <append+282>
cmplStd/lib/text/string.ci:279:[.06302d, .063042) hits(0), instructions(0): <append+269>
cmplStd/lib/text/string.ci:284:[.063046, .063063) hits(0), instructions(0): <append+294>
cmplStd/lib/text/string.ci:285:[.063063, .063081) hits(0), instructions(0): <append+323>
cmplStd/lib/text/string.ci:283:[.063081, .0630aa) hits(0), instructions(0): <append+353>
cmplStd/lib/text/string.ci:283:[.063042, .0630aa) hits(0), instructions(0): <append+290>
cmplStd/lib/text/string.ci:287:[.0630aa, .0630b2) hits(0), instructions(0): <append+394>
cmplStd/lib/text/string.ci:296:[.0630c8, .0630e7) hits(0), instructions(0): <append+0>
cmplStd/lib/text/string.ci:301:[.0630e8, .0630f1) hits(0), instructions(0): <float64+0>
cmplStd/lib/text/string.ci:302:[.0630f1, .0630f2) hits(0), instructions(0): <float64+9>
cmplStd/lib/text/string.ci:307:[.0630f7, .0630fd) hits(0), instructions(0): <float64+15>
cmplStd/lib/text/string.ci:309:[.063123, .06313c) hits(0), instructions(0): <float64+59>
cmplStd/lib/text/string.ci:310:[.06313c, .06314a) hits(0), instructions(0): <float64+84>
cmplStd/lib/text/string.ci:315:[.063165, .063175) hits(0), instructions(0): <float64+125>
cmplStd/lib/text/string.ci:313:[.06315d, .063175) hits(0), instructions(0): <float64+117>
cmplStd/lib/text/string.ci:317:[.063175, .063180) hits(0), instructions(0): <float64+141>
cmplStd/lib/text/string.ci:320:[.0631a1, .0631ac) hits(0), instructions(0): <float64+185>
cmplStd/lib/text/string.ci:323:[.0631cd, .0631d8) hits(0), instructions(0): <float64+229>
cmplStd/lib/text/string.ci:327:[.0631dc, .0631ec) hits(0), instructions(0): <float64+244>
cmplStd/lib/text/string.ci:322:[.0631b0, .0631ec) hits(0), instructions(0): <float64+200>
cmplStd/lib/text/string.ci:319:[.063184, .0631ec) hits(0), instructions(0): <float64+156>
cmplStd/lib/text/string.ci:312:[.06314e, .0631ec) hits(0), instructions(0): <float64+102>
cmplStd/lib/text/string.ci:308:[.0630fd, .0631ec) hits(0), instructions(0): <float64+21>
cmplStd/lib/text/string.ci:306:[.0631f0, .0631f4) hits(0), instructions(0): <float64+264>
cmplStd/lib/text/string.ci:306:[.0631f4, .063210) hits(0), instructions(0): <float64+268>
cmplStd/lib/text/string.ci:306:[.0630f2, .063214) hits(0), instructions(0): <float64+10>
cmplStd/lib/text/string.ci:333:[.063224, .063230) hits(0), instructions(0): <float64+316>
cmplStd/lib/text/string.ci:332:[.06321c, .063230) hits(0), instructions(0): <float64+308>
cmplStd/lib/text/string.ci:331:[.063214, .063230) hits(0), instructions(0): <float64+300>
cmplStd/lib/text/string.ci:336:[.063230, .06323f) hits(0), instructions(0): <float64+328>
cmplStd/test/std/tryExec.ci:16:[.0635f8, .0635fc) hits(128), instructions(128-1): <stackOverflow+0>
cmplStd/test/std/tryExec.ci:17:[.0635fc, .06360b) hits(127), instructions(508): <stackOverflow+4>
cmplStd/test/std/tryExec.ci:21:[.063610, .063617) hits(1), instructions(3-1): <divisionByZero+0>
cmplStd/test/std/tryExec.ci:31:[.063624, .06362b) hits(1), instructions(2): <abortExecution+4>
cmplStd/test/std/tryExec.ci:32:[.06362b, .063632) hits(1), instructions(2): <abortExecution+11>
cmplStd/test/std/tryExec.ci:33:[.063632, .063639) hits(1), instructions(2): <abortExecution+18>
cmplStd/test/std/tryExec.ci:30:[.063620, .063639) hits(1), instructions(1): <abortExecution+0>
cmplStd/test/std/tryExec.ci:35:[.063639, .06365f) hits(1), instructions(8-1): <abortExecution+25>
cmplStd/test/std/tryExec.ci:39:[.063668, .06366d) hits(1), instructions(1): <invalidMemoryAccess+0>
cmplStd/test/std/tryExec.ci:40:[.06366d, .063670) hits(1), instructions(2-1): <invalidMemoryAccess+5>
cmplStd/test/std/tryExec.ci:44:[.063678, .06367a) hits(1), instructions(2-1): <invalidInstruction+0>
cmplStd/test/lang/function.ci:8:[.063980, .063988) hits(2), instructions(10): <funAdd+0>
cmplStd/test/lang/function.ci:34:[.0639c0, .0639c8) hits(2), instructions(10): <funMul+0>
cmplStd/test/lang/function.ci:40:[.0639d4, .0639d8) hits(377), instructions(754): <fib+12>
cmplStd/test/lang/function.ci:39:[.0639c8, .0639d8) hits(753), instructions(3012): <fib+0>
cmplStd/test/lang/function.ci:42:[.0639d8, .0639fe) hits(376), instructions(5640): <fib+16>
cmplStd/test/lang/init.method.ci:11:[.063b78, .063b9e) hits(3), instructions(24): <staticMethod+0>
cmplStd/test/lang/init.method.ci:41:[.063ba8, .063bce) hits(4), instructions(32): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:48:[.063bd0, .063bf6) hits(0), instructions(0): <forwardMethod+0>
cmplStd/test/lang/init.method.ci:58:[.063bf8, .063c1e) hits(0), instructions(0): <globalFunction+0>
cmplStd/test/lang/init.method.ci:85:[.063c30, .063c53) hits(1), instructions(8): <staticMethod+0>
cmplStd/test/lang/init.method.ci:87:[.063c61, .063c71) hits(1), instructions(6): <staticMethod+49>
cmplStd/test/lang/init.method.ci:86:[.063c53, .063c71) hits(1), instructions(4): <staticMethod+35>
cmplStd/test/lang/init.method.ci:91:[.063c78, .063c9b) hits(1), instructions(8): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:93:[.063ca9, .063cb6) hits(1), instructions(6): <virtualMethod+49>
cmplStd/test/lang/init.method.ci:92:[.063c9b, .063cb6) hits(1), instructions(4): <virtualMethod+35>
cmplStd/lib/text/string.ci:155:[.0646fc, .06470a) hits(1), instructions(3): <.main+0>
cmplStd/lib/text/string.ci:156:[.06470a, .064718) hits(1), instructions(3): <.main+14>
::[.064718, .06471f) hits(1), instructions(3): <.main+28>
::[.06471f, .064724) hits(1), instructions(2): <.main+35>
::[.064724, .06472b) hits(1), instructions(3): <.main+40>
::[.06472b, .064730) hits(1), instructions(2): <.main+47>
cmplStd/lib/text/string.ci:257:[.064718, .064730) hits(0), instructions(0): <.main+28>
cmplStd/lib/text/string.ci:270:[.064730, .06473d) hits(1), instructions(2): <.main+52>
::[.06473d, .064744) hits(1), instructions(3): <.main+65>
::[.064744, .064749) hits(1), instructions(2): <.main+72>
::[.064749, .064750) hits(1), instructions(3): <.main+77>
::[.064750, .064755) hits(1), instructions(2): <.main+84>
cmplStd/lib/text/string.ci:295:[.06473d, .064755) hits(0), instructions(0): <.main+65>
cmplStd/test/lang/emit.ci:3:[.064755, .06475a) hits(1), instructions(2): <.main+89>
cmplStd/test/lang/emit.ci:4:[.06475a, .06475f) hits(1), instructions(2): <.main+94>
cmplStd/test/lang/emit.ci:6:[.06475f, .064768) hits(1), instructions(2): <.main+99>
cmplStd/test/lang/emit.ci:7:[.064768, .064771) hits(1), instructions(2): <.main+108>
cmplStd/test/lang/emit.ci:10:[.064771, .06477e) hits(1), instructions(4): <.main+117>
cmplStd/test/lang/emit.ci:13:[.06477e, .06478d) hits(1), instructions(4): <.main+130>
cmplStd/test/lang/emit.ci:16:[.06478d, .0647a0) hits(1), instructions(5): <.main+145>
cmplStd/test/lang/emit.ci:23:[.0647a0, .0647a9) hits(1), instructions(2): <.main+164>
cmplStd/test/lang/emit.ci:24:[.0647a9, .0647b3) hits(1), instructions(3): <.main+173>
cmplStd/test/lang/emit.ci:25:[.0647b3, .0647c1) hits(1), instructions(3): <.main+183>
cmplStd/test/lang/emit.ci:26:[.0647c1, .0647ce) hits(1), instructions(2): <.main+197>
cmplStd/test/lang/emit.ci:29:[.0647ce, .0647dc) hits(1), instructions(3): <.main+210>
cmplStd/test/lang/inlineMacros.ci:10:[.0647dc, .0647e5) hits(1), instructions(2): <.main+224>
cmplStd/test/lang/inlineMacros.ci:11:[.0647e5, .0647ee) hits(1), instructions(2): <.main+233>
cmplStd/test/lang/inlineMacros.ci:12:[.0647ee, .0647f7) hits(1), instructions(2): <.main+242>
cmplStd/test/lang/inlineMacros.ci:13:[.0647f7, .064800) hits(1), instructions(2): <.main+251>
cmplStd/test/lang/inlineMacros.ci:15:[.064800, .064805) hits(1), instructions(2): <.main+260>
cmplStd/test/lang/inlineMacros.ci:16:[.064805, .06480a) hits(1), instructions(2): <.main+265>
cmplStd/test/lang/inlineMacros.ci:17:[.06480a, .06480f) hits(1), instructions(2): <.main+270>
cmplStd/test/lang/inlineMacros.ci:19:[.06480f, .064818) hits(1), instructions(2): <.main+275>
cmplStd/test/lang/inlineMacros.ci:20:[.064818, .064820) hits(1), instructions(2): <.main+284>
cmplStd/test/lang/inlineMacros.ci:21:[.064820, .064830) hits(1), instructions(4): <.main+292>
cmplStd/test/lang/inlineMacros.ci:23:[.064830, .06483d) hits(1), instructions(3): <.main+308>
cmplStd/test/lang/inlineMacros.ci:24:[.06483d, .06484a) hits(1), instructions(4): <.main+321>
cmplStd/test/lang/inlineMacros.ci:25:[.06484a, .064863) hits(1), instructions(7): <.main+334>
cmplStd/test/lang/inlineMacros.ci:27:[.064863, .06487f) hits(1), instructions(7): <.main+359>
cmplStd/test/lang/inlineMacros.ci:28:[.06487f, .064899) hits(1), instructions(7): <.main+387>
cmplStd/test/lang/inlineMacros.ci:29:[.064899, .0648bf) hits(1), instructions(9): <.main+413>
cmplStd/test/lang/inlineMacros.ci:31:[.0648bf, .0648e4) hits(1), instructions(11): <.main+451>
cmplStd/test/lang/inlineMacros.ci:32:[.0648e4, .064907) hits(1), instructions(11): <.main+488>
cmplStd/test/lang/inlineMacros.ci:33:[.064907, .064936) hits(1), instructions(14): <.main+523>
cmplStd/test/lang/inlineMacros.ci:35:[.064936, .06495b) hits(1), instructions(10): <.main+570>
cmplStd/test/lang/inlineMacros.ci:36:[.06495b, .06497e) hits(1), instructions(10): <.main+607>
cmplStd/test/lang/inlineMacros.ci:37:[.06497e, .0649ad) hits(1), instructions(13): <.main+642>
cmplStd/test/lang/inlineMacros.ci:41:[.0649ad, .0649c6) hits(1), instructions(7): <.main+689>
cmplStd/test/lang/inlineMacros.ci:42:[.0649c6, .0649db) hits(1), instructions(5): <.main+714>
cmplStd/test/lang/inlineMacros.ci:43:[.0649db, .0649f2) hits(1), instructions(8): <.main+735>
cmplStd/test/lang/inlineMacros.ci:44:[.0649f2, .064a09) hits(1), instructions(8): <.main+758>
cmplStd/test/lang/inlineMacros.ci:45:[.064a09, .064a34) hits(1), instructions(13): <.main+781>
cmplStd/test/lang/inlineMacros.ci:46:[.064a34, .064a5f) hits(1), instructions(13): <.main+824>
cmplStd/test/lang/inlineMacros.ci:50:[.064a5f, .064aa1) hits(1), instructions(7): <.main+867>
cmplStd/test/lang/inlineMacros.ci:51:[.064aa1, .064ae3) hits(1), instructions(17): <.main+933>
cmplStd/test/lang/inlineMacros.ci:52:[.064ae3, .064b21) hits(1), instructions(7): <.main+999>
cmplStd/test/lang/inlineMacros.ci:53:[.064b21, .064b5f) hits(1), instructions(17): <.main+1061>
cmplStd/test/lang/inlineMacros.ci:54:[.064b5f, .064bb1) hits(1), instructions(9): <.main+1123>
cmplStd/test/lang/inlineMacros.ci:55:[.064bb1, .064c03) hits(1), instructions(19): <.main+1205>
cmplStd/test/lang/inlineMacros.ci:59:[.064c03, .064c60) hits(1), instructions(27): <.main+1287>
cmplStd/test/lang/inlineMacros.ci:60:[.064c60, .064cbd) hits(1), instructions(28): <.main+1380>
cmplStd/test/lang/inlineMacros.ci:61:[.064cbd, .064d16) hits(1), instructions(27): <.main+1473>
cmplStd/test/lang/inlineMacros.ci:62:[.064d16, .064d6f) hits(1), instructions(28): <.main+1562>
cmplStd/test/lang/inlineMacros.ci:63:[.064d6f, .064ddc) hits(1), instructions(32): <.main+1651>
cmplStd/test/lang/inlineMacros.ci:64:[.064ddc, .064e49) hits(1), instructions(33): <.main+1760>
cmplStd/test/lang/inlineMacros.ci:68:[.064e49, .064ea6) hits(1), instructions(26): <.main+1869>
cmplStd/test/lang/inlineMacros.ci:69:[.064ea6, .064f03) hits(1), instructions(27): <.main+1962>
cmplStd/test/lang/inlineMacros.ci:70:[.064f03, .064f5c) hits(1), instructions(26): <.main+2055>
cmplStd/test/lang/inlineMacros.ci:71:[.064f5c, .064fb5) hits(1), instructions(27): <.main+2144>
cmplStd/test/lang/inlineMacros.ci:72:[.064fb5, .065022) hits(1), instructions(31): <.main+2233>
cmplStd/test/lang/inlineMacros.ci:73:[.065022, .06508f) hits(1), instructions(32): <.main+2342>
cmplStd/test/lang/overload.inline.ci:9:[.06508f, .065098) hits(1), instructions(2): <.main+2451>
cmplStd/test/lang/overload.inline.ci:10:[.065098, .0650a1) hits(1), instructions(2): <.main+2460>
cmplStd/test/lang/overload.inline.ci:11:[.0650a1, .0650aa) hits(1), instructions(2): <.main+2469>
cmplStd/test/lang/overload.inline.ci:12:[.0650aa, .0650b3) hits(1), instructions(2): <.main+2478>
cmplStd/test/lang/overload.inline.ci:13:[.0650b3, .0650bc) hits(1), instructions(2): <.main+2487>
cmplStd/test/lang/overload.inline.ci:28:[.0650bc, .0650c9) hits(1), instructions(2): <.main+2496>
cmplStd/test/lang/overload.inline.ci:29:[.0650c9, .0650e5) hits(1), instructions(6): <.main+2509>
cmplStd/test/std/number.ci:3:[.0650e5, .0650f2) hits(1), instructions(2): <.main+2537>
cmplStd/test/std/number.ci:4:[.0650f2, .0650ff) hits(1), instructions(2): <.main+2550>
cmplStd/test/std/number.ci:6:[.0650ff, .065108) hits(1), instructions(3): <.main+2563>
cmplStd/test/std/number.ci:7:[.065108, .065111) hits(1), instructions(3): <.main+2572>
cmplStd/test/std/number.ci:14:[.065111, .06511c) hits(1), instructions(3): <.main+2581>
cmplStd/test/std/number.ci:15:[.06511c, .065127) hits(1), instructions(3): <.main+2592>
cmplStd/test/std/number.ci:16:[.065127, .065132) hits(1), instructions(3): <.main+2603>
cmplStd/test/std/number.ci:18:[.065132, .065158) hits(1), instructions(14): <.main+2614>
cmplStd/test/std/number.ci:19:[.065158, .06517c) hits(1), instructions(13): <.main+2652>
cmplStd/test/std/number.ci:21:[.06517c, .065192) hits(1), instructions(5): <.main+2688>
cmplStd/test/std/number.ci:22:[.065192, .0651a8) hits(1), instructions(5): <.main+2710>
cmplStd/test/std/number.ci:23:[.0651a8, .0651ba) hits(1), instructions(5): <.main+2732>
cmplStd/test/std/number.ci:25:[.0651ba, .0651d0) hits(1), instructions(5): <.main+2750>
cmplStd/test/std/number.ci:26:[.0651d0, .0651e6) hits(1), instructions(5): <.main+2772>
cmplStd/test/std/number.ci:27:[.0651e6, .0651f8) hits(1), instructions(5): <.main+2794>
cmplStd/test/std/number.ci:29:[.0651f8, .06520e) hits(1), instructions(5): <.main+2812>
cmplStd/test/std/number.ci:30:[.06520e, .065224) hits(1), instructions(5): <.main+2834>
cmplStd/test/std/number.ci:31:[.065224, .065236) hits(1), instructions(5): <.main+2856>
cmplStd/test/std/number.ci:33:[.065236, .06524c) hits(1), instructions(5): <.main+2874>
cmplStd/test/std/number.ci:34:[.06524c, .065262) hits(1), instructions(5): <.main+2896>
cmplStd/test/std/number.ci:35:[.065262, .065274) hits(1), instructions(5): <.main+2918>
cmplStd/test/std/number.ci:37:[.065274, .06528a) hits(1), instructions(5): <.main+2936>
cmplStd/test/std/number.ci:38:[.06528a, .0652a0) hits(1), instructions(5): <.main+2958>
cmplStd/test/std/number.ci:39:[.0652a0, .0652b6) hits(1), instructions(5): <.main+2980>
cmplStd/test/std/number.ci:40:[.0652b6, .0652cc) hits(1), instructions(7): <.main+3002>
cmplStd/test/std/number.ci:41:[.0652cc, .0652dd) hits(1), instructions(3): <.main+3024>
cmplStd/test/std/number.ci:42:[.0652dd, .0652f7) hits(1), instructions(6): <.main+3041>
cmplStd/test/std/number.ci:43:[.0652f7, .065308) hits(1), instructions(5): <.main+3067>
cmplStd/test/std/number.ci:44:[.065308, .06531d) hits(1), instructions(4): <.main+3084>
cmplStd/test/std/number.ci:46:[.06531d, .06532f) hits(1), instructions(5): <.main+3105>
cmplStd/test/std/number.ci:47:[.06532f, .065341) hits(1), instructions(5): <.main+3123>
cmplStd/test/std/number.ci:48:[.065341, .065353) hits(1), instructions(5): <.main+3141>
cmplStd/test/std/number.ci:49:[.065353, .065369) hits(1), instructions(7): <.main+3159>
cmplStd/test/std/number.ci:50:[.065369, .065376) hits(1), instructions(3): <.main+3181>
cmplStd/test/std/number.ci:51:[.065376, .06538c) hits(1), instructions(6): <.main+3194>
cmplStd/test/std/number.ci:52:[.06538c, .06539d) hits(1), instructions(5): <.main+3216>
cmplStd/test/std/number.ci:53:[.06539d, .0653ae) hits(1), instructions(4): <.main+3233>
cmplStd/test/std/number.ci:55:[.0653ae, .0653ba) hits(1), instructions(3): <.main+3250>
cmplStd/test/std/number.ci:56:[.0653ba, .0653c6) hits(1), instructions(3): <.main+3262>
cmplStd/test/std/number.ci:57:[.0653c6, .0653d2) hits(1), instructions(3): <.main+3274>
cmplStd/test/std/number.ci:58:[.0653d2, .0653de) hits(1), instructions(3): <.main+3286>
cmplStd/test/std/number.ci:59:[.0653de, .0653ea) hits(1), instructions(3): <.main+3298>
cmplStd/test/std/number.ci:60:[.0653ea, .0653f6) hits(1), instructions(3): <.main+3310>
cmplStd/test/std/number.ci:62:[.0653f6, .065408) hits(1), instructions(5): <.main+3322>
cmplStd/test/std/number.ci:63:[.065408, .06541a) hits(1), instructions(5): <.main+3340>
cmplStd/test/std/number.ci:65:[.06541a, .06542e) hits(1), instructions(7): <.main+3358>
cmplStd/test/std/number.ci:66:[.06542e, .065442) hits(1), instructions(7): <.main+3378>
cmplStd/test/std/memory.ci:7:[.065442, .065454) hits(1), instructions(4): <.main+3398>
cmplStd/test/std/memory.ci:8:[.065454, .065466) hits(1), instructions(4): <.main+3416>
cmplStd/test/std/memory.ci:9:[.065466, .065478) hits(1), instructions(4): <.main+3434>
cmplStd/test/std/memory.ci:10:[.065478, .06548a) hits(1), instructions(4): <.main+3452>
cmplStd/test/std/memory.ci:23:[.06548a, .065497) hits(1), instructions(2): <.main+3470>
cmplStd/test/std/memory.ci:24:[.065497, .0654a4) hits(1), instructions(2): <.main+3483>
cmplStd/test/std/tryExec.ci:47:[.0654a4, .0654b6) hits(1), instructions(4): <.main+3496>
cmplStd/test/std/tryExec.ci:48:[.0654b6, .0654c8) hits(1), instructions(4): <.main+3514>
cmplStd/test/std/tryExec.ci:49:[.0654c8, .0654da) hits(1), instructions(4): <.main+3532>
cmplStd/test/std/tryExec.ci:50:[.0654da, .0654ec) hits(1), instructions(4): <.main+3550>
cmplStd/test/std/tryExec.ci:51:[.0654ec, .0654fe) hits(1), instructions(4): <.main+3568>
cmplStd/test/std/tryExec.ci:52:[.0654fe, .065510) hits(1), instructions(4): <.main+3586>
cmplStd/test/std/tryExec.ci:53:[.065510, .065522) hits(1), instructions(4): <.main+3604>
cmplStd/test/lang/init.reference.ci:7:[.065522, .06552f) hits(1), instructions(2): <.main+3622>
cmplStd/test/lang/init.reference.ci:8:[.06552f, .065538) hits(1), instructions(2): <.main+3635>
cmplStd/test/lang/init.reference.ci:9:[.065538, .065541) hits(1), instructions(2): <.main+3644>
cmplStd/test/lang/init.reference.ci:10:[.065541, .06554f) hits(1), instructions(3): <.main+3653>
cmplStd/test/lang/init.reference.ci:12:[.06554f, .065558) hits(1), instructions(3): <.main+3667>
cmplStd/test/lang/init.reference.ci:13:[.065558, .065560) hits(1), instructions(2): <.main+3676>
cmplStd/test/lang/init.reference.ci:14:[.065560, .065568) hits(1), instructions(2): <.main+3684>
cmplStd/test/lang/init.reference.ci:16:[.065568, .065571) hits(1), instructions(2): <.main+3692>
cmplStd/test/lang/init.reference.ci:17:[.065571, .06557a) hits(1), instructions(2): <.main+3701>
cmplStd/test/lang/init.reference.ci:18:[.06557a, .065588) hits(1), instructions(3): <.main+3710>
cmplStd/test/lang/init.reference.ci:19:[.065588, .065591) hits(1), instructions(2): <.main+3724>
cmplStd/test/lang/init.reference.ci:20:[.065591, .06559a) hits(1), instructions(2): <.main+3733>
cmplStd/test/lang/init.reference.ci:21:[.06559a, .0655a3) hits(1), instructions(2): <.main+3742>
cmplStd/test/lang/init.reference.ci:23:[.0655a3, .0655ac) hits(1), instructions(2): <.main+3751>
cmplStd/test/lang/init.reference.ci:24:[.0655ac, .0655ba) hits(1), instructions(3): <.main+3760>
cmplStd/test/lang/init.reference.ci:25:[.0655ba, .0655c3) hits(1), instructions(2): <.main+3774>
cmplStd/test/lang/init.reference.ci:27:[.0655c3, .0655cb) hits(1), instructions(2): <.main+3783>
cmplStd/test/lang/init.reference.ci:28:[.0655cb, .0655d3) hits(1), instructions(2): <.main+3791>
cmplStd/test/lang/init.reference.ci:29:[.0655d3, .0655db) hits(1), instructions(2): <.main+3799>
cmplStd/test/lang/init.reference.ci:30:[.0655db, .0655e3) hits(1), instructions(2): <.main+3807>
cmplStd/test/lang/init.reference.ci:31:[.0655e3, .0655eb) hits(1), instructions(2): <.main+3815>
cmplStd/test/lang/init.reference.ci:32:[.0655eb, .0655f3) hits(1), instructions(2): <.main+3823>
cmplStd/test/lang/init.reference.ci:35:[.0655f3, .0655fc) hits(1), instructions(2): <.main+3831>
cmplStd/test/lang/init.reference.ci:36:[.0655fc, .065605) hits(1), instructions(2): <.main+3840>
cmplStd/test/lang/init.reference.ci:37:[.065605, .06560e) hits(1), instructions(2): <.main+3849>
cmplStd/test/lang/init.reference.ci:38:[.06560e, .065617) hits(1), instructions(2): <.main+3858>
cmplStd/test/lang/init.reference.ci:39:[.065617, .065620) hits(1), instructions(2): <.main+3867>
cmplStd/test/lang/init.reference.ci:40:[.065620, .065629) hits(1), instructions(2): <.main+3876>
cmplStd/test/lang/init.reference.ci:41:[.065629, .065632) hits(1), instructions(2): <.main+3885>
cmplStd/test/lang/init.reference.ci:42:[.065632, .06563b) hits(1), instructions(2): <.main+3894>
cmplStd/test/lang/init.reference.ci:43:[.06563b, .065644) hits(1), instructions(2): <.main+3903>
cmplStd/test/lang/init.reference.ci:44:[.065644, .06564d) hits(1), instructions(2): <.main+3912>
cmplStd/test/lang/init.reference.ci:45:[.06564d, .065656) hits(1), instructions(2): <.main+3921>
cmplStd/test/lang/init.reference.ci:46:[.065656, .06565f) hits(1), instructions(2): <.main+3930>
cmplStd/test/lang/init.reference.ci:47:[.06565f, .065668) hits(1), instructions(2): <.main+3939>
cmplStd/test/lang/init.reference.ci:48:[.065668, .065671) hits(1), instructions(2): <.main+3948>
cmplStd/test/lang/init.reference.ci:49:[.065671, .06567a) hits(1), instructions(2): <.main+3957>
cmplStd/test/lang/init.reference.ci:50:[.06567a, .065683) hits(1), instructions(2): <.main+3966>
cmplStd/test/lang/init.reference.ci:51:[.065683, .06568c) hits(1), instructions(2): <.main+3975>
cmplStd/test/lang/init.reference.ci:52:[.06568c, .065695) hits(1), instructions(2): <.main+3984>
cmplStd/test/lang/init.reference.ci:55:[.065695, .0656a3) hits(1), instructions(3): <.main+3993>
cmplStd/test/lang/init.reference.ci:56:[.0656a3, .0656b1) hits(1), instructions(3): <.main+4007>
cmplStd/test/lang/init.reference.ci:57:[.0656b1, .0656bf) hits(1), instructions(3): <.main+4021>
cmplStd/test/lang/init.reference.ci:58:[.0656bf, .0656cd) hits(1), instructions(3): <.main+4035>
cmplStd/test/lang/init.reference.ci:59:[.0656cd, .0656db) hits(1), instructions(3): <.main+4049>
cmplStd/test/lang/init.reference.ci:60:[.0656db, .0656e9) hits(1), instructions(3): <.main+4063>
cmplStd/test/lang/init.reference.ci:61:[.0656e9, .0656f7) hits(1), instructions(3): <.main+4077>
cmplStd/test/lang/init.reference.ci:62:[.0656f7, .065705) hits(1), instructions(3): <.main+4091>
cmplStd/test/lang/init.reference.ci:63:[.065705, .065713) hits(1), instructions(3): <.main+4105>
cmplStd/test/lang/init.reference.ci:64:[.065713, .065721) hits(1), instructions(3): <.main+4119>
cmplStd/test/lang/init.reference.ci:65:[.065721, .06572f) hits(1), instructions(3): <.main+4133>
cmplStd/test/lang/init.reference.ci:66:[.06572f, .06573d) hits(1), instructions(3): <.main+4147>
cmplStd/test/lang/init.reference.ci:67:[.06573d, .06574b) hits(1), instructions(3): <.main+4161>
cmplStd/test/lang/init.reference.ci:68:[.06574b, .065759) hits(1), instructions(3): <.main+4175>
cmplStd/test/lang/init.reference.ci:69:[.065759, .065767) hits(1), instructions(3): <.main+4189>
cmplStd/test/lang/init.reference.ci:70:[.065767, .065775) hits(1), instructions(3): <.main+4203>
cmplStd/test/lang/init.reference.ci:71:[.065775, .065783) hits(1), instructions(3): <.main+4217>
cmplStd/test/lang/init.reference.ci:72:[.065783, .065791) hits(1), instructions(3): <.main+4231>
cmplStd/test/lang/init.reference.ci:75:[.065791, .06579a) hits(1), instructions(2): <.main+4245>
cmplStd/test/lang/init.reference.ci:76:[.06579a, .0657a3) hits(1), instructions(2): <.main+4254>
cmplStd/test/lang/init.reference.ci:77:[.0657a3, .0657ac) hits(1), instructions(2): <.main+4263>
cmplStd/test/lang/init.reference.ci:78:[.0657ac, .0657b5) hits(1), instructions(2): <.main+4272>
cmplStd/test/lang/init.reference.ci:79:[.0657b5, .0657be) hits(1), instructions(2): <.main+4281>
cmplStd/test/lang/init.reference.ci:80:[.0657be, .0657c7) hits(1), instructions(2): <.main+4290>
cmplStd/test/lang/init.reference.ci:81:[.0657c7, .0657d0) hits(1), instructions(2): <.main+4299>
cmplStd/test/lang/init.reference.ci:82:[.0657d0, .0657d9) hits(1), instructions(2): <.main+4308>
cmplStd/test/lang/init.reference.ci:83:[.0657d9, .0657e2) hits(1), instructions(2): <.main+4317>
cmplStd/test/lang/init.reference.ci:84:[.0657e2, .0657eb) hits(1), instructions(2): <.main+4326>
cmplStd/test/lang/init.reference.ci:85:[.0657eb, .0657f4) hits(1), instructions(2): <.main+4335>
cmplStd/test/lang/init.reference.ci:86:[.0657f4, .0657fd) hits(1), instructions(2): <.main+4344>
cmplStd/test/lang/init.reference.ci:87:[.0657fd, .065806) hits(1), instructions(2): <.main+4353>
cmplStd/test/lang/init.reference.ci:88:[.065806, .06580f) hits(1), instructions(2): <.main+4362>
cmplStd/test/lang/init.reference.ci:89:[.06580f, .065818) hits(1), instructions(2): <.main+4371>
cmplStd/test/lang/init.reference.ci:90:[.065818, .065821) hits(1), instructions(2): <.main+4380>
cmplStd/test/lang/init.reference.ci:91:[.065821, .06582a) hits(1), instructions(2): <.main+4389>
cmplStd/test/lang/init.reference.ci:92:[.06582a, .065833) hits(1), instructions(2): <.main+4398>
cmplStd/test/lang/init.reference.ci:95:[.065833, .06583c) hits(1), instructions(2): <.main+4407>
cmplStd/test/lang/init.reference.ci:96:[.06583c, .06584a) hits(1), instructions(3): <.main+4416>
cmplStd/test/lang/init.reference.ci:97:[.06584a, .065853) hits(1), instructions(2): <.main+4430>
cmplStd/test/lang/init.reference.ci:99:[.065853, .06585c) hits(1), instructions(2): <.main+4439>
cmplStd/test/lang/init.reference.ci:105:[.06585c, .065869) hits(1), instructions(3): <.main+4448>
cmplStd/test/lang/init.reference.ci:108:[.065869, .065871) hits(1), instructions(2): <.main+4461>
cmplStd/test/lang/init.variable.ci:3:[.065871, .065876) hits(1), instructions(2): <.main+4469>
cmplStd/test/lang/init.variable.ci:7:[.065876, .06587f) hits(1), instructions(2): <.main+4474>
cmplStd/test/lang/init.variable.ci:24:[.06587f, .06588c) hits(1), instructions(2): <.main+4483>
::[.06588c, .065891) hits(1), instructions(2): <.main+4496>
cmplStd/test/lang/init.variable.ci:24:[.06587f, .065891) hits(0), instructions(0): <.main+4483>
cmplStd/test/lang/init.variable.ci:33:[.065891, .06589e) hits(1), instructions(3): <.main+4501>
cmplStd/test/lang/init.variable.ci:33:[.06589e, .0658b0) hits(1), instructions(4): <.main+4514>
::[.0658b0, .0658ba) hits(1), instructions(4): <.main+4532>
cmplStd/test/lang/init.variable.ci:33:[.065891, .0658ba) hits(0), instructions(0): <.main+4501>
cmplStd/test/lang/init.variable.ci:41:[.0658ba, .0658c7) hits(1), instructions(3): <.main+4542>
cmplStd/test/lang/init.variable.ci:41:[.0658c7, .0658d9) hits(1), instructions(4): <.main+4555>
::[.0658d9, .0658e3) hits(1), instructions(4): <.main+4573>
cmplStd/test/lang/init.variable.ci:41:[.0658ba, .0658e3) hits(0), instructions(0): <.main+4542>
cmplStd/test/lang/function.ci:12:[.0658e3, .0658fc) hits(1), instructions(7): <.main+4583>
cmplStd/test/lang/function.ci:15:[.0658fc, .065905) hits(1), instructions(2): <.main+4608>
cmplStd/test/lang/function.ci:18:[.065905, .06591d) hits(1), instructions(7): <.main+4617>
cmplStd/test/lang/function.ci:21:[.06591d, .065926) hits(1), instructions(2): <.main+4641>
cmplStd/test/lang/function.ci:24:[.065926, .06593e) hits(1), instructions(7): <.main+4650>
cmplStd/test/lang/function.ci:27:[.06593e, .065946) hits(1), instructions(2): <.main+4674>
cmplStd/test/lang/function.ci:30:[.065946, .06595e) hits(1), instructions(7): <.main+4682>
cmplStd/test/lang/function.ci:46:[.06595e, .065972) hits(1), instructions(6): <.main+4706>
cmplStd/test/lang/reflect.ci:3:[.065972, .06597f) hits(1), instructions(3): <.main+4726>
cmplStd/test/lang/reflect.ci:4:[.06597f, .06598c) hits(1), instructions(3): <.main+4739>
cmplStd/test/lang/reflect.ci:5:[.06598c, .065999) hits(1), instructions(3): <.main+4752>
cmplStd/test/lang/reflect.ci:6:[.065999, .0659a6) hits(1), instructions(3): <.main+4765>
cmplStd/test/lang/reflect.ci:7:[.0659a6, .0659b3) hits(1), instructions(3): <.main+4778>
cmplStd/test/lang/reflect.ci:8:[.0659b3, .0659c0) hits(1), instructions(3): <.main+4791>
cmplStd/test/lang/reflect.ci:9:[.0659c0, .0659cd) hits(1), instructions(3): <.main+4804>
cmplStd/test/lang/reflect.ci:10:[.0659cd, .0659da) hits(1), instructions(3): <.main+4817>
cmplStd/test/lang/reflect.ci:11:[.0659da, .0659e7) hits(1), instructions(3): <.main+4830>
cmplStd/test/lang/reflect.ci:12:[.0659e7, .0659f4) hits(1), instructions(3): <.main+4843>
cmplStd/test/lang/reflect.ci:13:[.0659f4, .065a01) hits(1), instructions(3): <.main+4856>
cmplStd/test/lang/reflect.ci:14:[.065a01, .065a0e) hits(1), instructions(3): <.main+4869>
cmplStd/test/lang/reflect.ci:15:[.065a0e, .065a1b) hits(1), instructions(3): <.main+4882>
cmplStd/test/lang/reflect.ci:16:[.065a1b, .065a28) hits(1), instructions(3): <.main+4895>
cmplStd/test/lang/reflect.ci:17:[.065a28, .065a35) hits(1), instructions(3): <.main+4908>
cmplStd/test/lang/reflect.ci:18:[.065a35, .065a42) hits(1), instructions(3): <.main+4921>
cmplStd/test/lang/reflect.ci:19:[.065a42, .065a4f) hits(1), instructions(3): <.main+4934>
cmplStd/test/lang/reflect.ci:20:[.065a4f, .065a5c) hits(1), instructions(3): <.main+4947>
cmplStd/test/lang/reflect.ci:30:[.065a5c, .065a65) hits(1), instructions(2): <.main+4960>
cmplStd/test/lang/reflect.ci:31:[.065a65, .065a71) hits(1), instructions(3): <.main+4969>
cmplStd/test/lang/reflect.ci:32:[.065a71, .065a7e) hits(1), instructions(4): <.main+4981>
cmplStd/test/lang/reflect.ci:33:[.065a7e, .065a8b) hits(1), instructions(4): <.main+4994>
cmplStd/test/lang/reflect.ci:34:[.065a8b, .065a97) hits(1), instructions(3): <.main+5007>
cmplStd/test/lang/reflect.ci:35:[.065a97, .065aa3) hits(1), instructions(3): <.main+5019>
cmplStd/test/lang/reflect.ci:37:[.065aa3, .065aaf) hits(1), instructions(3): <.main+5031>
cmplStd/test/lang/reflect.ci:38:[.065aaf, .065abb) hits(1), instructions(3): <.main+5043>
cmplStd/test/lang/reflect.ci:39:[.065abb, .065ac8) hits(1), instructions(4): <.main+5055>
cmplStd/test/lang/reflect.ci:40:[.065ac8, .065ad5) hits(1), instructions(4): <.main+5068>
cmplStd/test/lang/reflect.ci:41:[.065ad5, .065ae1) hits(1), instructions(3): <.main+5081>
cmplStd/test/lang/reflect.ci:42:[.065ae1, .065aed) hits(1), instructions(3): <.main+5093>
cmplStd/test/lang/reflect.ci:44:[.065aed, .065af9) hits(1), instructions(3): <.main+5105>
cmplStd/test/lang/reflect.ci:45:[.065af9, .065b06) hits(1), instructions(4): <.main+5117>
cmplStd/test/lang/reflect.ci:46:[.065b06, .065b13) hits(1), instructions(4): <.main+5130>
cmplStd/test/lang/reflect.ci:48:[.065b13, .065b1f) hits(1), instructions(3): <.main+5143>
cmplStd/test/lang/reflect.ci:49:[.065b1f, .065b2c) hits(1), instructions(4): <.main+5155>
cmplStd/test/lang/reflect.ci:50:[.065b2c, .065b39) hits(1), instructions(4): <.main+5168>
cmplStd/test/lang/init.member.ci:34:[.065b39, .065b3e) hits(1), instructions(2): <.main+5181>
cmplStd/test/lang/init.member.ci:37:[.065b3e, .065b47) hits(1), instructions(2): <.main+5186>
cmplStd/test/lang/init.member.ci:40:[.065b47, .065b50) hits(1), instructions(2): <.main+5195>
cmplStd/test/lang/init.member.ci:43:[.065b50, .065b59) hits(1), instructions(2): <.main+5204>
::[.065b59, .065b5e) hits(1), instructions(2): <.main+5213>
cmplStd/test/lang/init.member.ci:43:[.065b50, .065b5e) hits(0), instructions(0): <.main+5204>
cmplStd/test/lang/init.member.ci:46:[.065b5e, .065b67) hits(1), instructions(2): <.main+5218>
cmplStd/test/lang/init.member.ci:46:[.065b67, .065b70) hits(1), instructions(2): <.main+5227>
cmplStd/test/lang/init.member.ci:46:[.065b5e, .065b70) hits(0), instructions(0): <.main+5218>
cmplStd/test/lang/init.member.ci:49:[.065b70, .065b79) hits(1), instructions(2): <.main+5236>
cmplStd/test/lang/init.member.ci:49:[.065b79, .065b82) hits(1), instructions(2): <.main+5245>
cmplStd/test/lang/init.member.ci:49:[.065b70, .065b82) hits(0), instructions(0): <.main+5236>
cmplStd/test/lang/init.member.ci:53:[.065b82, .065b8b) hits(1), instructions(2): <.main+5254>
cmplStd/test/lang/init.member.ci:54:[.065b8b, .065b94) hits(1), instructions(2): <.main+5263>
cmplStd/test/lang/init.member.ci:55:[.065b94, .065b9d) hits(1), instructions(2): <.main+5272>
cmplStd/test/lang/init.member.ci:56:[.065b9d, .065ba6) hits(1), instructions(2): <.main+5281>
cmplStd/test/lang/init.member.ci:59:[.065ba6, .065baf) hits(1), instructions(2): <.main+5290>
cmplStd/test/lang/init.member.ci:60:[.065baf, .065bb8) hits(1), instructions(2): <.main+5299>
cmplStd/test/lang/init.member.ci:64:[.065bb8, .065bc1) hits(1), instructions(2): <.main+5308>
cmplStd/test/lang/init.member.ci:65:[.065bc1, .065bca) hits(1), instructions(2): <.main+5317>
cmplStd/test/lang/init.member.ci:52:[.065b82, .065bca) hits(0), instructions(0): <.main+5254>
cmplStd/test/lang/init.method.ci:18:[.065bca, .065bd3) hits(1), instructions(2): <.main+5326>
cmplStd/test/lang/init.method.ci:64:[.065bd3, .065bdc) hits(1), instructions(2): <.main+5335>
::[.065bdc, .065be4) hits(1), instructions(2): <.main+5344>
::[.065be4, .065bed) hits(1), instructions(2): <.main+5352>
cmplStd/test/lang/init.method.ci:62:[.065bd3, .065bed) hits(0), instructions(0): <.main+5335>
cmplStd/test/lang/recUnion.ci:26:[.065bed, .065bf4) hits(1), instructions(3): <.main+5361>
cmplStd/test/lang/recUnion.ci:26:[.065bf4, .065bfb) hits(1), instructions(3): <.main+5368>
cmplStd/test/lang/recUnion.ci:26:[.065bfb, .065c02) hits(1), instructions(3): <.main+5375>
cmplStd/test/lang/recUnion.ci:26:[.065bed, .065c02) hits(0), instructions(0): <.main+5361>
cmplStd/test/lang/recUnion.ci:27:[.065c02, .065c09) hits(1), instructions(3): <.main+5382>
cmplStd/test/lang/recUnion.ci:27:[.065c09, .065c14) hits(1), instructions(3): <.main+5389>
cmplStd/test/lang/recUnion.ci:27:[.065c14, .065c1b) hits(1), instructions(3): <.main+5400>
cmplStd/test/lang/recUnion.ci:27:[.065c02, .065c1b) hits(0), instructions(0): <.main+5382>
cmplStd/test/lang/recUnion.ci:28:[.065c1b, .065c26) hits(1), instructions(3): <.main+5407>
cmplStd/test/lang/recUnion.ci:28:[.065c26, .065c31) hits(1), instructions(3): <.main+5418>
cmplStd/test/lang/recUnion.ci:28:[.065c31, .065c3c) hits(1), instructions(3): <.main+5429>
cmplStd/test/lang/recUnion.ci:28:[.065c1b, .065c3c) hits(0), instructions(0): <.main+5407>
cmplStd/test/lang/recUnion.ci:30:[.065c3c, .065c45) hits(1), instructions(2): <.main+5440>
cmplStd/test/lang/recUnion.ci:30:[.065c3c, .065c45) hits(0), instructions(0): <.main+5440>
cmplStd/test/lang/recUnion.ci:31:[.065c45, .065c4c) hits(1), instructions(3): <.main+5449>
cmplStd/test/lang/recUnion.ci:31:[.065c4c, .065c53) hits(1), instructions(3): <.main+5456>
cmplStd/test/lang/recUnion.ci:31:[.065c53, .065c5e) hits(1), instructions(3): <.main+5463>
cmplStd/test/lang/recUnion.ci:31:[.065c45, .065c5e) hits(0), instructions(0): <.main+5449>
cmplStd/test/lang/useOperator.ci:5:[.065c5e, .065c67) hits(1), instructions(2): <.main+5474>
cmplStd/test/lang/useOperator.ci:7:[.065c67, .065c72) hits(1), instructions(3): <.main+5483>
cmplStd/test/lang/useOperator.ci:8:[.065c72, .065c7d) hits(1), instructions(3): <.main+5494>
cmplStd/test/lang/useOperator.ci:17:[.065c7d, .065c90) hits(1), instructions(7): <.main+5505>
cmplStd/test/lang/useOperator.ci:18:[.065c90, .065ca3) hits(1), instructions(7): <.main+5524>
cmplStd/test/lang/useOperator.ci:19:[.065ca3, .065cb6) hits(1), instructions(7): <.main+5543>
cmplStd/test/lang/useOperator.ci:22:[.065cb6, .065cc3) hits(1), instructions(5): <.main+5562>
cmplStd/test/lang/useOperator.ci:23:[.065cc3, .065cd6) hits(1), instructions(7): <.main+5575>
cmplStd/test/lang/useOperator.ci:24:[.065cd6, .065cea) hits(1), instructions(8): <.main+5594>
cmplStd/test/lang/useOperator.ci:25:[.065cea, .065cfd) hits(1), instructions(7): <.main+5614>
cmplStd/test/lang/useOperator.ci:26:[.065cfd, .065d11) hits(1), instructions(8): <.main+5633>
cmplStd/test/lang/useOperator.ci:27:[.065d11, .065d24) hits(1), instructions(7): <.main+5653>
cmplStd/test/lang/useOperator.ci:28:[.065d24, .065d38) hits(1), instructions(8): <.main+5672>
cmplStd/test/lang/useOperator.ci:30:[.065d38, .065d43) hits(1), instructions(3): <.main+5692>
cmplStd/test/lang/useOperator.ci:31:[.065d43, .065d4e) hits(1), instructions(3): <.main+5703>
cmplStd/test/lang/useOperator.ci:32:[.065d4e, .065d5a) hits(1), instructions(4): <.main+5714>
cmplStd/test/lang/useOperator.ci:33:[.065d5a, .065d67) hits(1), instructions(5): <.main+5726>
cmplStd/test/lang/useOperator.ci:34:[.065d67, .065d74) hits(1), instructions(5): <.main+5739>
cmplStd/test/lang/useOperator.ci:35:[.065d74, .065d87) hits(1), instructions(7): <.main+5752>
cmplStd/test/lang/useOperator.ci:36:[.065d87, .065d9a) hits(1), instructions(7): <.main+5771>
cmplStd/test/lang/useOperator.ci:37:[.065d9a, .065dad) hits(1), instructions(7): <.main+5790>
cmplStd/test/lang/useOperator.ci:38:[.065dad, .065dc0) hits(1), instructions(7): <.main+5809>
cmplStd/test/lang/useOperator.ci:39:[.065dc0, .065dd3) hits(1), instructions(7): <.main+5828>
cmplStd/test/lang/useOperator.ci:40:[.065dd3, .065de6) hits(1), instructions(7): <.main+5847>
cmplStd/test/lang/useOperator.ci:41:[.065de6, .065df9) hits(1), instructions(7): <.main+5866>
cmplStd/test/lang/useOperator.ci:42:[.065df9, .065e0c) hits(1), instructions(7): <.main+5885>
cmplStd/test/lang/useOperator.ci:43:[.065e0c, .065e1d) hits(1), instructions(6): <.main+5904>
cmplStd/test/lang/useOperator.ci:44:[.065e1d, .065e2e) hits(1), instructions(6): <.main+5921>
cmplStd/test/lang/useOperator.ci:45:[.065e2e, .065e3c) hits(1), instructions(6): <.main+5938>
cmplStd/test/lang/useOperator.ci:46:[.065e3c, .065e4f) hits(1), instructions(7): <.main+5952>
cmplStd/test/lang/useOperator.ci:47:[.065e4f, .065e63) hits(1), instructions(8): <.main+5971>
cmplStd/test/lang/useOperator.ci:48:[.065e63, .065e76) hits(1), instructions(7): <.main+5991>
cmplStd/test/lang/useOperator.ci:49:[.065e76, .065e8a) hits(1), instructions(8): <.main+6010>
cmplStd/test/lang/useOperator.ci:50:[.065e8a, .065e9d) hits(1), instructions(7): <.main+6030>
cmplStd/test/lang/useOperator.ci:51:[.065e9d, .065eb1) hits(1), instructions(8): <.main+6049>
cmplStd/test/lang/useOperator.ci:53:[.065eb1, .065ebc) hits(1), instructions(3): <.main+6069>
cmplStd/test/lang/useOperator.ci:54:[.065ebc, .065ec7) hits(1), instructions(3): <.main+6080>
cmplStd/test/lang/useOperator.ci:55:[.065ec7, .065ed3) hits(1), instructions(4): <.main+6091>
cmplStd/test/lang/useOperator.ci:56:[.065ed3, .065ee0) hits(1), instructions(5): <.main+6103>
cmplStd/test/lang/useOperator.ci:57:[.065ee0, .065eed) hits(1), instructions(5): <.main+6116>
cmplStd/test/lang/useOperator.ci:58:[.065eed, .065f00) hits(1), instructions(7): <.main+6129>
cmplStd/test/lang/useOperator.ci:59:[.065f00, .065f13) hits(1), instructions(7): <.main+6148>
cmplStd/test/lang/useOperator.ci:60:[.065f13, .065f26) hits(1), instructions(7): <.main+6167>
cmplStd/test/lang/useOperator.ci:61:[.065f26, .065f39) hits(1), instructions(7): <.main+6186>
cmplStd/test/lang/useOperator.ci:62:[.065f39, .065f4c) hits(1), instructions(7): <.main+6205>
cmplStd/test/lang/useOperator.ci:63:[.065f4c, .065f5f) hits(1), instructions(7): <.main+6224>
cmplStd/test/lang/useOperator.ci:64:[.065f5f, .065f72) hits(1), instructions(7): <.main+6243>
cmplStd/test/lang/useOperator.ci:65:[.065f72, .065f85) hits(1), instructions(7): <.main+6262>
cmplStd/test/lang/useOperator.ci:66:[.065f85, .065f96) hits(1), instructions(6): <.main+6281>
cmplStd/test/lang/useOperator.ci:67:[.065f96, .065fa7) hits(1), instructions(6): <.main+6298>
cmplStd/test/lang/useOperator.ci:68:[.065fa7, .065fb5) hits(1), instructions(6): <.main+6315>
cmplStd/test/lang/useOperator.ci:69:[.065fb5, .065fc8) hits(1), instructions(7): <.main+6329>
cmplStd/test/lang/useOperator.ci:70:[.065fc8, .065fdc) hits(1), instructions(8): <.main+6348>
cmplStd/test/lang/useOperator.ci:71:[.065fdc, .065fef) hits(1), instructions(7): <.main+6368>
cmplStd/test/lang/useOperator.ci:72:[.065fef, .066003) hits(1), instructions(8): <.main+6387>
cmplStd/test/lang/useOperator.ci:73:[.066003, .066016) hits(1), instructions(7): <.main+6407>
cmplStd/test/lang/useOperator.ci:74:[.066016, .06602a) hits(1), instructions(8): <.main+6426>
cmplStd/test/lang/useOperator.ci:76:[.06602a, .066035) hits(1), instructions(3): <.main+6446>
cmplStd/test/lang/useOperator.ci:77:[.066035, .066040) hits(1), instructions(3): <.main+6457>
cmplStd/test/lang/useOperator.ci:78:[.066040, .06604c) hits(1), instructions(4): <.main+6468>
cmplStd/test/lang/useOperator.ci:79:[.06604c, .066059) hits(1), instructions(5): <.main+6480>
cmplStd/test/lang/useOperator.ci:80:[.066059, .066066) hits(1), instructions(5): <.main+6493>
cmplStd/test/lang/useOperator.ci:81:[.066066, .066079) hits(1), instructions(7): <.main+6506>
cmplStd/test/lang/useOperator.ci:82:[.066079, .06608c) hits(1), instructions(7): <.main+6525>
cmplStd/test/lang/useOperator.ci:83:[.06608c, .06609f) hits(1), instructions(7): <.main+6544>
cmplStd/test/lang/useOperator.ci:84:[.06609f, .0660b2) hits(1), instructions(7): <.main+6563>
cmplStd/test/lang/useOperator.ci:85:[.0660b2, .0660c5) hits(1), instructions(7): <.main+6582>
cmplStd/test/lang/useOperator.ci:86:[.0660c5, .0660d8) hits(1), instructions(7): <.main+6601>
cmplStd/test/lang/useOperator.ci:87:[.0660d8, .0660eb) hits(1), instructions(7): <.main+6620>
cmplStd/test/lang/useOperator.ci:88:[.0660eb, .0660fe) hits(1), instructions(7): <.main+6639>
cmplStd/test/lang/useOperator.ci:89:[.0660fe, .06610f) hits(1), instructions(6): <.main+6658>
cmplStd/test/lang/useOperator.ci:90:[.06610f, .066120) hits(1), instructions(6): <.main+6675>
cmplStd/test/lang/useOperator.ci:91:[.066120, .06612e) hits(1), instructions(6): <.main+6692>
cmplStd/test/lang/useOperator.ci:92:[.06612e, .066141) hits(1), instructions(7): <.main+6706>
cmplStd/test/lang/useOperator.ci:93:[.066141, .066155) hits(1), instructions(8): <.main+6725>
cmplStd/test/lang/useOperator.ci:94:[.066155, .066168) hits(1), instructions(7): <.main+6745>
cmplStd/test/lang/useOperator.ci:95:[.066168, .06617c) hits(1), instructions(8): <.main+6764>
cmplStd/test/lang/useOperator.ci:96:[.06617c, .06618f) hits(1), instructions(7): <.main+6784>
cmplStd/test/lang/useOperator.ci:97:[.06618f, .0661a3) hits(1), instructions(8): <.main+6803>
cmplStd/test/lang/useOperator.ci:99:[.0661a3, .0661ae) hits(1), instructions(3): <.main+6823>
cmplStd/test/lang/useOperator.ci:100:[.0661ae, .0661b9) hits(1), instructions(3): <.main+6834>
cmplStd/test/lang/useOperator.ci:101:[.0661b9, .0661c5) hits(1), instructions(4): <.main+6845>
cmplStd/test/lang/useOperator.ci:102:[.0661c5, .0661d2) hits(1), instructions(5): <.main+6857>
cmplStd/test/lang/useOperator.ci:103:[.0661d2, .0661df) hits(1), instructions(5): <.main+6870>
cmplStd/test/lang/useOperator.ci:104:[.0661df, .0661f2) hits(1), instructions(7): <.main+6883>
cmplStd/test/lang/useOperator.ci:105:[.0661f2, .066205) hits(1), instructions(7): <.main+6902>
cmplStd/test/lang/useOperator.ci:106:[.066205, .066218) hits(1), instructions(7): <.main+6921>
cmplStd/test/lang/useOperator.ci:107:[.066218, .06622b) hits(1), instructions(7): <.main+6940>
cmplStd/test/lang/useOperator.ci:108:[.06622b, .06623e) hits(1), instructions(7): <.main+6959>
cmplStd/test/lang/useOperator.ci:109:[.06623e, .066251) hits(1), instructions(7): <.main+6978>
cmplStd/test/lang/useOperator.ci:110:[.066251, .066264) hits(1), instructions(7): <.main+6997>
cmplStd/test/lang/useOperator.ci:111:[.066264, .066277) hits(1), instructions(7): <.main+7016>
cmplStd/test/lang/useOperator.ci:112:[.066277, .066288) hits(1), instructions(6): <.main+7035>
cmplStd/test/lang/useOperator.ci:113:[.066288, .066299) hits(1), instructions(6): <.main+7052>
cmplStd/test/lang/useOperator.ci:114:[.066299, .0662a7) hits(1), instructions(6): <.main+7069>
cmplStd/test/lang/useOperator.ci:115:[.0662a7, .0662ba) hits(1), instructions(7): <.main+7083>
cmplStd/test/lang/useOperator.ci:116:[.0662ba, .0662ce) hits(1), instructions(8): <.main+7102>
cmplStd/test/lang/useOperator.ci:117:[.0662ce, .0662e1) hits(1), instructions(7): <.main+7122>
cmplStd/test/lang/useOperator.ci:118:[.0662e1, .0662f5) hits(1), instructions(8): <.main+7141>
cmplStd/test/lang/useOperator.ci:119:[.0662f5, .066308) hits(1), instructions(7): <.main+7161>
cmplStd/test/lang/useOperator.ci:120:[.066308, .06631c) hits(1), instructions(8): <.main+7180>
cmplStd/test/lang/useOperator.ci:122:[.06631c, .066327) hits(1), instructions(3): <.main+7200>
cmplStd/test/lang/useOperator.ci:123:[.066327, .066332) hits(1), instructions(3): <.main+7211>
cmplStd/test/lang/useOperator.ci:124:[.066332, .06633e) hits(1), instructions(4): <.main+7222>
cmplStd/test/lang/useOperator.ci:125:[.06633e, .06634b) hits(1), instructions(5): <.main+7234>
cmplStd/test/lang/useOperator.ci:126:[.06634b, .066358) hits(1), instructions(5): <.main+7247>
cmplStd/test/lang/useOperator.ci:127:[.066358, .06636b) hits(1), instructions(7): <.main+7260>
cmplStd/test/lang/useOperator.ci:128:[.06636b, .06637e) hits(1), instructions(7): <.main+7279>
cmplStd/test/lang/useOperator.ci:129:[.06637e, .066391) hits(1), instructions(7): <.main+7298>
cmplStd/test/lang/useOperator.ci:130:[.066391, .0663a4) hits(1), instructions(7): <.main+7317>
cmplStd/test/lang/useOperator.ci:131:[.0663a4, .0663b7) hits(1), instructions(7): <.main+7336>
cmplStd/test/lang/useOperator.ci:132:[.0663b7, .0663ca) hits(1), instructions(7): <.main+7355>
cmplStd/test/lang/useOperator.ci:133:[.0663ca, .0663dd) hits(1), instructions(7): <.main+7374>
cmplStd/test/lang/useOperator.ci:134:[.0663dd, .0663f0) hits(1), instructions(7): <.main+7393>
cmplStd/test/lang/useOperator.ci:135:[.0663f0, .066401) hits(1), instructions(6): <.main+7412>
cmplStd/test/lang/useOperator.ci:136:[.066401, .066412) hits(1), instructions(6): <.main+7429>
cmplStd/test/lang/useOperator.ci:137:[.066412, .066420) hits(1), instructions(6): <.main+7446>
cmplStd/test/lang/useOperator.ci:138:[.066420, .066433) hits(1), instructions(7): <.main+7460>
cmplStd/test/lang/useOperator.ci:139:[.066433, .066447) hits(1), instructions(8): <.main+7479>
cmplStd/test/lang/useOperator.ci:140:[.066447, .06645a) hits(1), instructions(7): <.main+7499>
cmplStd/test/lang/useOperator.ci:141:[.06645a, .06646e) hits(1), instructions(8): <.main+7518>
cmplStd/test/lang/useOperator.ci:142:[.06646e, .066481) hits(1), instructions(7): <.main+7538>
cmplStd/test/lang/useOperator.ci:143:[.066481, .066495) hits(1), instructions(8): <.main+7557>
cmplStd/test/lang/useOperator.ci:145:[.066495, .06649e) hits(1), instructions(2): <.main+7577>
cmplStd/test/lang/useOperator.ci:146:[.06649e, .0664a7) hits(1), instructions(2): <.main+7586>
cmplStd/test/lang/useOperator.ci:147:[.0664a7, .0664af) hits(1), instructions(2): <.main+7595>
cmplStd/test/lang/useOperator.ci:148:[.0664af, .0664b8) hits(1), instructions(3): <.main+7603>
cmplStd/test/lang/useOperator.ci:149:[.0664b8, .0664c1) hits(1), instructions(3): <.main+7612>
cmplStd/test/lang/useOperator.ci:150:[.0664c1, .0664ce) hits(1), instructions(4): <.main+7621>
cmplStd/test/lang/useOperator.ci:151:[.0664ce, .0664db) hits(1), instructions(4): <.main+7634>
cmplStd/test/lang/useOperator.ci:152:[.0664db, .0664e8) hits(1), instructions(4): <.main+7647>
cmplStd/test/lang/useOperator.ci:153:[.0664e8, .0664f5) hits(1), instructions(4): <.main+7660>
cmplStd/test/lang/useOperator.ci:154:[.0664f5, .066502) hits(1), instructions(4): <.main+7673>
cmplStd/test/lang/useOperator.ci:155:[.066502, .06650f) hits(1), instructions(4): <.main+7686>
cmplStd/test/lang/useOperator.ci:156:[.06650f, .06651c) hits(1), instructions(4): <.main+7699>
cmplStd/test/lang/useOperator.ci:157:[.06651c, .066529) hits(1), instructions(4): <.main+7712>
cmplStd/test/lang/useOperator.ci:158:[.066529, .066536) hits(1), instructions(4): <.main+7725>
cmplStd/test/lang/useOperator.ci:159:[.066536, .066543) hits(1), instructions(4): <.main+7738>
cmplStd/test/lang/useOperator.ci:160:[.066543, .06654f) hits(1), instructions(5): <.main+7751>
cmplStd/test/lang/useOperator.ci:161:[.06654f, .06655e) hits(1), instructions(5): <.main+7763>
cmplStd/test/lang/useOperator.ci:162:[.06655e, .06656e) hits(1), instructions(6): <.main+7778>
cmplStd/test/lang/useOperator.ci:163:[.06656e, .06657d) hits(1), instructions(5): <.main+7794>
cmplStd/test/lang/useOperator.ci:164:[.06657d, .06658d) hits(1), instructions(6): <.main+7809>
cmplStd/test/lang/useOperator.ci:165:[.06658d, .06659c) hits(1), instructions(5): <.main+7825>
cmplStd/test/lang/useOperator.ci:166:[.06659c, .0665ac) hits(1), instructions(6): <.main+7840>
cmplStd/test/lang/useOperator.ci:168:[.0665ac, .0665b5) hits(1), instructions(2): <.main+7856>
cmplStd/test/lang/useOperator.ci:169:[.0665b5, .0665be) hits(1), instructions(2): <.main+7865>
cmplStd/test/lang/useOperator.ci:170:[.0665be, .0665c6) hits(1), instructions(2): <.main+7874>
cmplStd/test/lang/useOperator.ci:171:[.0665c6, .0665cf) hits(1), instructions(3): <.main+7882>
cmplStd/test/lang/useOperator.ci:172:[.0665cf, .0665d8) hits(1), instructions(3): <.main+7891>
cmplStd/test/lang/useOperator.ci:173:[.0665d8, .0665e5) hits(1), instructions(4): <.main+7900>
cmplStd/test/lang/useOperator.ci:174:[.0665e5, .0665f2) hits(1), instructions(4): <.main+7913>
cmplStd/test/lang/useOperator.ci:175:[.0665f2, .0665ff) hits(1), instructions(4): <.main+7926>
cmplStd/test/lang/useOperator.ci:176:[.0665ff, .06660c) hits(1), instructions(4): <.main+7939>
cmplStd/test/lang/useOperator.ci:177:[.06660c, .066619) hits(1), instructions(4): <.main+7952>
cmplStd/test/lang/useOperator.ci:178:[.066619, .066626) hits(1), instructions(4): <.main+7965>
cmplStd/test/lang/useOperator.ci:179:[.066626, .066633) hits(1), instructions(4): <.main+7978>
cmplStd/test/lang/useOperator.ci:180:[.066633, .066640) hits(1), instructions(4): <.main+7991>
cmplStd/test/lang/useOperator.ci:181:[.066640, .06664d) hits(1), instructions(4): <.main+8004>
cmplStd/test/lang/useOperator.ci:182:[.06664d, .06665a) hits(1), instructions(4): <.main+8017>
cmplStd/test/lang/useOperator.ci:183:[.06665a, .066666) hits(1), instructions(5): <.main+8030>
cmplStd/test/lang/useOperator.ci:184:[.066666, .066675) hits(1), instructions(5): <.main+8042>
cmplStd/test/lang/useOperator.ci:185:[.066675, .066685) hits(1), instructions(6): <.main+8057>
cmplStd/test/lang/useOperator.ci:186:[.066685, .066694) hits(1), instructions(5): <.main+8073>
cmplStd/test/lang/useOperator.ci:187:[.066694, .0666a4) hits(1), instructions(6): <.main+8088>
cmplStd/test/lang/useOperator.ci:188:[.0666a4, .0666b3) hits(1), instructions(5): <.main+8104>
cmplStd/test/lang/useOperator.ci:189:[.0666b3, .0666c3) hits(1), instructions(6): <.main+8119>
cmplStd/test/lang/useOperator.ci:191:[.0666c3, .0666d0) hits(1), instructions(2): <.main+8135>
cmplStd/test/lang/useOperator.ci:192:[.0666d0, .0666dd) hits(1), instructions(2): <.main+8148>
cmplStd/test/lang/useOperator.ci:193:[.0666dd, .0666e5) hits(1), instructions(2): <.main+8161>
cmplStd/test/lang/useOperator.ci:194:[.0666e5, .0666ee) hits(1), instructions(3): <.main+8169>
cmplStd/test/lang/useOperator.ci:195:[.0666ee, .0666f7) hits(1), instructions(3): <.main+8178>
cmplStd/test/lang/useOperator.ci:196:[.0666f7, .066704) hits(1), instructions(4): <.main+8187>
cmplStd/test/lang/useOperator.ci:197:[.066704, .066711) hits(1), instructions(4): <.main+8200>
cmplStd/test/lang/useOperator.ci:198:[.066711, .06671e) hits(1), instructions(4): <.main+8213>
cmplStd/test/lang/useOperator.ci:199:[.06671e, .06672b) hits(1), instructions(4): <.main+8226>
cmplStd/test/lang/useOperator.ci:200:[.06672b, .066738) hits(1), instructions(4): <.main+8239>
cmplStd/test/lang/useOperator.ci:201:[.066738, .066745) hits(1), instructions(4): <.main+8252>
cmplStd/test/lang/useOperator.ci:202:[.066745, .066752) hits(1), instructions(4): <.main+8265>
cmplStd/test/lang/useOperator.ci:203:[.066752, .06675f) hits(1), instructions(4): <.main+8278>
cmplStd/test/lang/useOperator.ci:204:[.06675f, .06676c) hits(1), instructions(4): <.main+8291>
cmplStd/test/lang/useOperator.ci:205:[.06676c, .066779) hits(1), instructions(4): <.main+8304>
cmplStd/test/lang/useOperator.ci:206:[.066779, .066785) hits(1), instructions(5): <.main+8317>
cmplStd/test/lang/useOperator.ci:207:[.066785, .066794) hits(1), instructions(5): <.main+8329>
cmplStd/test/lang/useOperator.ci:208:[.066794, .0667a4) hits(1), instructions(6): <.main+8344>
cmplStd/test/lang/useOperator.ci:209:[.0667a4, .0667b3) hits(1), instructions(5): <.main+8360>
cmplStd/test/lang/useOperator.ci:210:[.0667b3, .0667c3) hits(1), instructions(6): <.main+8375>
cmplStd/test/lang/useOperator.ci:211:[.0667c3, .0667d2) hits(1), instructions(5): <.main+8391>
cmplStd/test/lang/useOperator.ci:212:[.0667d2, .0667e2) hits(1), instructions(6): <.main+8406>
cmplStd/test/lang/useOperator.ci:214:[.0667e2, .0667ef) hits(1), instructions(2): <.main+8422>
cmplStd/test/lang/useOperator.ci:215:[.0667ef, .0667fc) hits(1), instructions(2): <.main+8435>
cmplStd/test/lang/useOperator.ci:216:[.0667fc, .066804) hits(1), instructions(2): <.main+8448>
cmplStd/test/lang/useOperator.ci:217:[.066804, .06680d) hits(1), instructions(3): <.main+8456>
cmplStd/test/lang/useOperator.ci:218:[.06680d, .066816) hits(1), instructions(3): <.main+8465>
cmplStd/test/lang/useOperator.ci:219:[.066816, .066823) hits(1), instructions(4): <.main+8474>
cmplStd/test/lang/useOperator.ci:220:[.066823, .066830) hits(1), instructions(4): <.main+8487>
cmplStd/test/lang/useOperator.ci:221:[.066830, .06683d) hits(1), instructions(4): <.main+8500>
cmplStd/test/lang/useOperator.ci:222:[.06683d, .06684a) hits(1), instructions(4): <.main+8513>
cmplStd/test/lang/useOperator.ci:223:[.06684a, .066857) hits(1), instructions(4): <.main+8526>
cmplStd/test/lang/useOperator.ci:224:[.066857, .066864) hits(1), instructions(4): <.main+8539>
cmplStd/test/lang/useOperator.ci:225:[.066864, .066871) hits(1), instructions(4): <.main+8552>
cmplStd/test/lang/useOperator.ci:226:[.066871, .06687e) hits(1), instructions(4): <.main+8565>
cmplStd/test/lang/useOperator.ci:227:[.06687e, .06688b) hits(1), instructions(4): <.main+8578>
cmplStd/test/lang/useOperator.ci:228:[.06688b, .066898) hits(1), instructions(4): <.main+8591>
cmplStd/test/lang/useOperator.ci:229:[.066898, .0668a4) hits(1), instructions(5): <.main+8604>
cmplStd/test/lang/useOperator.ci:230:[.0668a4, .0668b3) hits(1), instructions(5): <.main+8616>
cmplStd/test/lang/useOperator.ci:231:[.0668b3, .0668c3) hits(1), instructions(6): <.main+8631>
cmplStd/test/lang/useOperator.ci:232:[.0668c3, .0668d2) hits(1), instructions(5): <.main+8647>
cmplStd/test/lang/useOperator.ci:233:[.0668d2, .0668e2) hits(1), instructions(6): <.main+8662>
cmplStd/test/lang/useOperator.ci:234:[.0668e2, .0668f1) hits(1), instructions(5): <.main+8678>
cmplStd/test/lang/useOperator.ci:235:[.0668f1, .066901) hits(1), instructions(6): <.main+8693>
cmplStd/test/lang/useOperator.ci:237:[.066901, .06690a) hits(1), instructions(2): <.main+8709>
cmplStd/test/lang/useOperator.ci:238:[.06690a, .066913) hits(1), instructions(2): <.main+8718>
cmplStd/test/lang/useOperator.ci:239:[.066913, .06691b) hits(1), instructions(2): <.main+8727>
cmplStd/test/lang/useOperator.ci:240:[.06691b, .066924) hits(1), instructions(3): <.main+8735>
cmplStd/test/lang/useOperator.ci:242:[.066924, .066931) hits(1), instructions(4): <.main+8744>
cmplStd/test/lang/useOperator.ci:243:[.066931, .06693e) hits(1), instructions(4): <.main+8757>
cmplStd/test/lang/useOperator.ci:244:[.06693e, .06694b) hits(1), instructions(4): <.main+8770>
cmplStd/test/lang/useOperator.ci:245:[.06694b, .066958) hits(1), instructions(4): <.main+8783>
cmplStd/test/lang/useOperator.ci:246:[.066958, .066965) hits(1), instructions(4): <.main+8796>
cmplStd/test/lang/useOperator.ci:252:[.066965, .066971) hits(1), instructions(5): <.main+8809>
cmplStd/test/lang/useOperator.ci:253:[.066971, .066980) hits(1), instructions(5): <.main+8821>
cmplStd/test/lang/useOperator.ci:254:[.066980, .066990) hits(1), instructions(6): <.main+8836>
cmplStd/test/lang/useOperator.ci:255:[.066990, .06699f) hits(1), instructions(5): <.main+8852>
cmplStd/test/lang/useOperator.ci:256:[.06699f, .0669af) hits(1), instructions(6): <.main+8867>
cmplStd/test/lang/useOperator.ci:257:[.0669af, .0669be) hits(1), instructions(5): <.main+8883>
cmplStd/test/lang/useOperator.ci:258:[.0669be, .0669ce) hits(1), instructions(6): <.main+8898>
cmplStd/test/lang/useOperator.ci:260:[.0669ce, .0669db) hits(1), instructions(2): <.main+8914>
cmplStd/test/lang/useOperator.ci:261:[.0669db, .0669e8) hits(1), instructions(2): <.main+8927>
cmplStd/test/lang/useOperator.ci:262:[.0669e8, .0669f0) hits(1), instructions(2): <.main+8940>
cmplStd/test/lang/useOperator.ci:263:[.0669f0, .0669f9) hits(1), instructions(3): <.main+8948>
cmplStd/test/lang/useOperator.ci:265:[.0669f9, .066a06) hits(1), instructions(4): <.main+8957>
cmplStd/test/lang/useOperator.ci:266:[.066a06, .066a13) hits(1), instructions(4): <.main+8970>
cmplStd/test/lang/useOperator.ci:267:[.066a13, .066a20) hits(1), instructions(4): <.main+8983>
cmplStd/test/lang/useOperator.ci:268:[.066a20, .066a2d) hits(1), instructions(4): <.main+8996>
cmplStd/test/lang/useOperator.ci:269:[.066a2d, .066a3a) hits(1), instructions(4): <.main+9009>
cmplStd/test/lang/useOperator.ci:275:[.066a3a, .066a46) hits(1), instructions(5): <.main+9022>
cmplStd/test/lang/useOperator.ci:276:[.066a46, .066a55) hits(1), instructions(5): <.main+9034>
cmplStd/test/lang/useOperator.ci:277:[.066a55, .066a65) hits(1), instructions(6): <.main+9049>
cmplStd/test/lang/useOperator.ci:278:[.066a65, .066a74) hits(1), instructions(5): <.main+9065>
cmplStd/test/lang/useOperator.ci:279:[.066a74, .066a84) hits(1), instructions(6): <.main+9080>
cmplStd/test/lang/useOperator.ci:280:[.066a84, .066a93) hits(1), instructions(5): <.main+9096>
cmplStd/test/lang/useOperator.ci:281:[.066a93, .066aa3) hits(1), instructions(6): <.main+9111>
cmplStd/test/lang/useOperator.ci:283:[.066aa3, .066aac) hits(1), instructions(2): <.main+9127>
cmplStd/test/lang/useOperator.ci:284:[.066aac, .066ab5) hits(1), instructions(2): <.main+9136>
cmplStd/test/lang/useOperator.ci:299:[.066ab5, .066ac4) hits(1), instructions(5): <.main+9145>
cmplStd/test/lang/useOperator.ci:300:[.066ac4, .066ad4) hits(1), instructions(6): <.main+9160>
cmplStd/test/lang/stmt.if.ci:26:[.066ad4, .066ad9) hits(1), instructions(2): <.main+9176>
cmplStd/test/lang/stmt.for.ci:12:[.066ad9, .066ade) hits(1), instructions(2): <.main+9181>
cmplStd/test/std/test.math.ci:3:[.066ade, .066af6) hits(1), instructions(6): <.main+9186>
cmplStd/test/std/test.math.ci:4:[.066af6, .066b0e) hits(1), instructions(6): <.main+9210>
cmplStd/test/std/test.math.ci:5:[.066b0e, .066b26) hits(1), instructions(6): <.main+9234>
cmplStd/test/std/test.math.ci:6:[.066b26, .066b3e) hits(1), instructions(6): <.main+9258>
cmplStd/test/std/test.math.ci:7:[.066b3e, .066b56) hits(1), instructions(6): <.main+9282>
cmplStd/test/std/test.math.ci:8:[.066b56, .066b6e) hits(1), instructions(6): <.main+9306>
cmplStd/test/std/test.math.ci:10:[.066b6e, .066b8b) hits(1), instructions(12): <.main+9330>
cmplStd/test/std/test.math.ci:11:[.066b8b, .066ba0) hits(1), instructions(12): <.main+9359>
cmplStd/test/std/test.math.ci:12:[.066ba0, .066bbd) hits(1), instructions(12): <.main+9380>
cmplStd/test/std/test.math.ci:13:[.066bbd, .066bd2) hits(1), instructions(11): <.main+9409>
cmplStd/test/std/test.math.ci:14:[.066bd2, .066be3) hits(1), instructions(11): <.main+9430>
cmplStd/test/std/test.math.ci:15:[.066be3, .066bf8) hits(1), instructions(11): <.main+9447>
cmplStd/test/std/test.math.ci:17:[.066bf8, .066c18) hits(1), instructions(8): <.main+9468>
cmplStd/test/std/test.math.ci:18:[.066c18, .066c30) hits(1), instructions(8): <.main+9500>
cmplStd/test/std/test.math.ci:19:[.066c30, .066c50) hits(1), instructions(10): <.main+9524>
cmplStd/test/std/test.math.ci:20:[.066c50, .066c6d) hits(1), instructions(9): <.main+9556>
cmplStd/test/std/test.math.ci:21:[.066c6d, .066c86) hits(1), instructions(9): <.main+9585>
cmplStd/test/std/test.math.ci:22:[.066c86, .066ca3) hits(1), instructions(11): <.main+9610>
cmplStd/test/std/test.math.ci:24:[.066ca3, .066cc9) hits(1), instructions(12): <.main+9639>
cmplStd/test/std/test.math.ci:25:[.066cc9, .066cef) hits(1), instructions(11): <.main+9677>
cmplStd/test/std/test.math.ci:26:[.066cef, .066d1c) hits(1), instructions(11): <.main+9715>
cmplStd/test/std/test.math.ci:27:[.066d1c, .066d49) hits(1), instructions(10): <.main+9760>
cmplStd/test/std/test.math.ci:29:[.066d49, .066d64) hits(1), instructions(9): <.main+9805>
cmplStd/test/std/test.math.ci:30:[.066d64, .066d86) hits(1), instructions(8): <.main+9832>
cmplStd/test/std/test.math.ci:32:[.066d86, .066d9f) hits(1), instructions(11): <.main+9866>
cmplStd/test/std/test.math.ci:33:[.066d9f, .066dbf) hits(1), instructions(10): <.main+9891>
cmplStd/test/std/test.math.ci:35:[.066dbf, .066dff) hits(1), instructions(27): <.main+9923>
cmplStd/test/std/test.math.ci:36:[.066dff, .066e51) hits(1), instructions(25): <.main+9987>
cmplStd/test/std/test.math.ci:38:[.066e51, .066e6a) hits(1), instructions(9): <.main+10069>
cmplStd/test/std/test.math.ci:39:[.066e6a, .066ed8) hits(1), instructions(18): <.main+10094>
cmplStd/test/std/test.math.ci:40:[.066ed8, .066ef1) hits(1), instructions(9): <.main+10204>
cmplStd/test/std/test.math.ci:41:[.066ef1, .066f5f) hits(1), instructions(18): <.main+10229>
cmplStd/test/std/test.math.ci:43:[.066f5f, .066f78) hits(1), instructions(9): <.main+10339>
cmplStd/test/std/test.math.ci:44:[.066f78, .066f9e) hits(1), instructions(10): <.main+10364>
cmplStd/test/std/test.math.ci:45:[.066f9e, .066fcd) hits(1), instructions(11): <.main+10402>
cmplStd/test/std/test.math.ci:46:[.066fcd, .067044) hits(1), instructions(19): <.main+10449>
cmplStd/test/std/test.math.ci:48:[.067044, .067051) hits(1), instructions(2): <.main+10568>
cmplStd/test/std/test.math.ci:49:[.067051, .06706e) hits(1), instructions(10): <.main+10581>
cmplStd/test/std/test.math.ci:50:[.06706e, .06707b) hits(1), instructions(2): <.main+10610>
cmplStd/test/std/test.math.ci:51:[.06707b, .067097) hits(1), instructions(6): <.main+10623>
cmplStd/test/std/test.math.ci:52:[.067097, .0670c4) hits(1), instructions(12): <.main+10651>
cmplStd/test/std/test.math.ci:53:[.0670c4, .067102) hits(1), instructions(18): <.main+10696>
cmplStd/test/std/test.math.ci:54:[.067102, .067150) hits(1), instructions(15): <.main+10758>
cmplStd/test/std/test.math.ci:55:[.067150, .0671a7) hits(1), instructions(16): <.main+10836>
cmplStd/test/std/test.math.ci:57:[.0671a7, .0671ca) hits(1), instructions(9): <.main+10923>
cmplStd/test/std/test.math.ci:58:[.0671ca, .067204) hits(1), instructions(15): <.main+10958>
cmplStd/test/std/test.math.ci:59:[.067204, .067226) hits(1), instructions(8): <.main+11016>
cmplStd/test/std/test.math.ci:60:[.067226, .067248) hits(1), instructions(8): <.main+11050>
cmplStd/test/std/test.math.ci:61:[.067248, .06726a) hits(1), instructions(8): <.main+11084>
cmplStd/test/std/test.math.ci:63:[.06726a, .067282) hits(1), instructions(6): <.main+11118>
cmplStd/test/std/test.math.ci:64:[.067282, .0672ae) hits(1), instructions(10): <.main+11142>
cmplStd/test/std/test.math.ci:67:[.0672ae, .0672d0) hits(1), instructions(11): <.main+11186>
cmplStd/test/std/test.math.ci:68:[.0672d0, .0672fe) hits(1), instructions(11): <.main+11220>
cmplStd/test/std/test.math.ci:70:[.0672fe, .06731f) hits(1), instructions(7): <.main+11266>
cmplStd/test/std/test.math.ci:71:[.06731f, .067337) hits(1), instructions(6): <.main+11299>
cmplStd/test/std/test.math.ci:72:[.067337, .067358) hits(1), instructions(7): <.main+11323>
cmplStd/test/std/test.math.ci:74:[.067358, .067379) hits(1), instructions(7): <.main+11356>
cmplStd/test/std/test.math.ci:75:[.067379, .06739a) hits(1), instructions(7): <.main+11389>
cmplStd/test/std/test.math.ci:76:[.06739a, .0673bb) hits(1), instructions(7): <.main+11422>
cmplStd/test/std/test.math.ci:77:[.0673bb, .0673dc) hits(1), instructions(7): <.main+11455>
cmplStd/test/std/test.math.ci:79:[.0673dc, .0673fd) hits(1), instructions(7): <.main+11488>
cmplStd/test/std/test.math.ci:80:[.0673fd, .06741e) hits(1), instructions(7): <.main+11521>
cmplStd/test/std/test.math.ci:81:[.06741e, .06743f) hits(1), instructions(7): <.main+11554>
cmplStd/test/std/test.math.ci:82:[.06743f, .067460) hits(1), instructions(7): <.main+11587>
cmplStd/test/std/test.math.ci:84:[.067460, .067479) hits(1), instructions(7): <.main+11620>
cmplStd/test/std/test.math.ci:85:[.067479, .06748e) hits(1), instructions(7): <.main+11645>
cmplStd/test/std/test.math.ci:86:[.06748e, .0674a7) hits(1), instructions(7): <.main+11666>
cmplStd/test/std/test.math.ci:88:[.0674a7, .0674c0) hits(1), instructions(7): <.main+11691>
cmplStd/test/std/test.math.ci:89:[.0674c0, .0674d9) hits(1), instructions(7): <.main+11716>
cmplStd/test/std/test.math.ci:90:[.0674d9, .0674f2) hits(1), instructions(7): <.main+11741>
cmplStd/test/std/test.math.ci:91:[.0674f2, .06750b) hits(1), instructions(7): <.main+11766>
cmplStd/test/std/test.math.ci:93:[.06750b, .067524) hits(1), instructions(7): <.main+11791>
cmplStd/test/std/test.math.ci:94:[.067524, .06753d) hits(1), instructions(7): <.main+11816>
cmplStd/test/std/test.math.ci:95:[.06753d, .067556) hits(1), instructions(7): <.main+11841>
cmplStd/test/std/test.math.ci:96:[.067556, .06756f) hits(1), instructions(7): <.main+11866>
cmplStd/test/std/memory.ci:13:[.06756f, .067581) hits(1), instructions(5): <.main+11891>
cmplStd/test/std/memory.ci:14:[.067581, .067596) hits(1), instructions(5): <.main+11909>
cmplStd/test/std/memory.ci:17:[.067596, .0675a3) hits(1), instructions(4): <.main+11930>
cmplStd/test/std/memory.ci:18:[.0675a3, .0675b0) hits(1), instructions(4): <.main+11943>
cmplStd/test/std/memory.ci:19:[.0675b0, .0675bd) hits(1), instructions(4): <.main+11956>
cmplStd/test/std/memory.ci:20:[.0675bd, .0675ca) hits(1), instructions(4): <.main+11969>
cmplStd/test/std/memory.ci:26:[.0675ca, .0675ed) hits(1), instructions(8): <.main+11982>
cmplStd/test/std/memory.ci:27:[.0675ed, .067610) hits(1), instructions(8): <.main+12017>
cmplStd/test/std/memory.ci:29:[.067610, .06762b) hits(1), instructions(6): <.main+12052>
cmplStd/test/std/memory.ci:30:[.06762b, .067642) hits(1), instructions(6): <.main+12079>
cmplStd/test/std/memory.ci:32:[.067642, .067665) hits(1), instructions(8): <.main+12102>
cmplStd/test/std/memory.ci:33:[.067665, .067688) hits(1), instructions(8): <.main+12137>
cmplStd/test/lang/init.method.ci:78:[.067688, .06769d) hits(1), instructions(6): <.main+12172>
cmplStd/test/lang/init.method.ci:79:[.06769d, .0676b1) hits(1), instructions(6): <.main+12193>
cmplStd/test/lang/init.method.ci:97:[.0676b1, .0676c4) hits(1), instructions(5): <.main+12213>
cmplStd/test/lang/init.method.ci:98:[.0676c4, .0676d7) hits(1), instructions(5): <.main+12232>
cmplStd/test/lang/init.method.ci:101:[.0676d7, .0676ec) hits(1), instructions(6): <.main+12251>
cmplStd/test/lang/init.method.ci:102:[.0676ec, .067701) hits(1), instructions(6): <.main+12272>
cmplStd/test/lang/init.method.ci:103:[.067701, .067715) hits(1), instructions(6): <.main+12293>
cmplStd/test/lang/stmt.if.ci:4:[.067715, .06773c) hits(1), instructions(8): <.main+12313>
cmplStd/test/lang/stmt.if.ci:12:[.06773c, .067763) hits(1), instructions(8): <.main+12352>
cmplStd/test/lang/stmt.if.ci:22:[.067763, .06778a) hits(1), instructions(8): <.main+12391>
cmplStd/test/lang/stmt.if.ci:29:[.067794, .0677bb) hits(1), instructions(8): <.main+12440>
cmplStd/test/lang/stmt.if.ci:28:[.06778a, .0677bb) hits(1), instructions(4): <.main+12430>
cmplStd/test/lang/stmt.if.ci:33:[.0677c5, .0677ec) hits(0), instructions(0): <.main+12489>
cmplStd/test/lang/stmt.if.ci:32:[.0677bb, .0677ec) hits(1), instructions(4): <.main+12479>
cmplStd/test/lang/stmt.if.ci:37:[.0677f6, .06781d) hits(1), instructions(8): <.main+12538>
cmplStd/test/lang/stmt.if.ci:40:[.067821, .067848) hits(0), instructions(0): <.main+12581>
cmplStd/test/lang/stmt.if.ci:36:[.0677ec, .067848) hits(1), instructions(5): <.main+12528>
cmplStd/test/lang/stmt.if.ci:44:[.067852, .067879) hits(0), instructions(0): <.main+12630>
cmplStd/test/lang/stmt.if.ci:47:[.06787d, .0678a4) hits(1), instructions(8): <.main+12673>
cmplStd/test/lang/stmt.if.ci:43:[.067848, .0678a4) hits(1), instructions(4): <.main+12620>
cmplStd/test/lang/stmt.if.ci:51:[.0678ae, .0678d5) hits(1), instructions(8): <.main+12722>
cmplStd/test/lang/stmt.if.ci:54:[.0678e7, .06790e) hits(0), instructions(0): <.main+12779>
cmplStd/test/lang/stmt.if.ci:57:[.067920, .067947) hits(0), instructions(0): <.main+12836>
cmplStd/test/lang/stmt.if.ci:60:[.067959, .067980) hits(0), instructions(0): <.main+12893>
cmplStd/test/lang/stmt.if.ci:63:[.067992, .0679b9) hits(0), instructions(0): <.main+12950>
cmplStd/test/lang/stmt.if.ci:66:[.0679cb, .0679f2) hits(0), instructions(0): <.main+13007>
cmplStd/test/lang/stmt.if.ci:69:[.0679f6, .067a1d) hits(0), instructions(0): <.main+13050>
cmplStd/test/lang/stmt.if.ci:65:[.0679bd, .067a1d) hits(0), instructions(0): <.main+12993>
cmplStd/test/lang/stmt.if.ci:62:[.067984, .067a1d) hits(0), instructions(0): <.main+12936>
cmplStd/test/lang/stmt.if.ci:59:[.06794b, .067a1d) hits(0), instructions(0): <.main+12879>
cmplStd/test/lang/stmt.if.ci:56:[.067912, .067a1d) hits(0), instructions(0): <.main+12822>
cmplStd/test/lang/stmt.if.ci:53:[.0678d9, .067a1d) hits(0), instructions(0): <.main+12765>
cmplStd/test/lang/stmt.if.ci:50:[.0678a4, .067a1d) hits(1), instructions(5): <.main+12712>
cmplStd/test/lang/stmt.for.ci:4:[.067a21, .067a44) hits(1), instructions(8): <.main+13093>
cmplStd/test/lang/stmt.for.ci:5:[.067a44, .067a48) hits(1), instructions(1): <.main+13128>
::[.067a48, .067a4c) hits(1), instructions(1): <.main+13132>
cmplStd/test/lang/stmt.for.ci:3:[.067a1d, .067a4c) hits(1), instructions(1): <.main+13089>
cmplStd/test/lang/stmt.for.ci:9:[.067a51, .067a73) hits(2), instructions(16): <.main+13141>
cmplStd/test/lang/stmt.for.ci:8:[.067a73, .067a77) hits(2), instructions(2): <.main+13175>
cmplStd/test/lang/stmt.for.ci:8:[.067a77, .067a83) hits(3), instructions(12): <.main+13179>
cmplStd/test/lang/stmt.for.ci:8:[.067a4c, .067a87) hits(1), instructions(3): <.main+13136>
cmplStd/test/lang/stmt.for.ci:14:[.067a90, .067ab3) hits(2), instructions(16): <.main+13204>
cmplStd/test/lang/stmt.for.ci:13:[.067ab3, .067abf) hits(2), instructions(6): <.main+13239>
cmplStd/test/lang/stmt.for.ci:13:[.067abf, .067acd) hits(3), instructions(12): <.main+13251>
cmplStd/test/lang/stmt.for.ci:13:[.067a87, .067acd) hits(1), instructions(3): <.main+13195>
cmplStd/test/lang/stmt.for.ci:19:[.067ade, .067ae2) hits(2), instructions(2): <.main+13282>
cmplStd/test/lang/stmt.for.ci:18:[.067ad2, .067ae2) hits(7), instructions(28): <.main+13270>
cmplStd/test/lang/stmt.for.ci:21:[.067ae2, .067b04) hits(5), instructions(40): <.main+13286>
cmplStd/test/lang/stmt.for.ci:17:[.067b04, .067b08) hits(7), instructions(7): <.main+13320>
cmplStd/test/lang/stmt.for.ci:17:[.067b08, .067b14) hits(8), instructions(32): <.main+13324>
cmplStd/test/lang/stmt.for.ci:17:[.067acd, .067b18) hits(1), instructions(3): <.main+13265>
cmplStd/test/lang/stmt.for.ci:26:[.067b29, .067b2d) hits(1), instructions(1): <.main+13357>
cmplStd/test/lang/stmt.for.ci:25:[.067b1d, .067b2d) hits(4), instructions(16): <.main+13345>
cmplStd/test/lang/stmt.for.ci:28:[.067b2d, .067b4f) hits(3), instructions(24): <.main+13361>
cmplStd/test/lang/stmt.for.ci:24:[.067b4f, .067b53) hits(3), instructions(3): <.main+13395>
cmplStd/test/lang/stmt.for.ci:24:[.067b53, .067b5f) hits(4), instructions(16): <.main+13399>
cmplStd/test/lang/stmt.for.ci:24:[.067b18, .067b63) hits(1), instructions(3): <.main+13340>

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
cmplStd/lib/debug.ci:48: NotEquals: typename(<NotEquals>)
cmplStd/lib/debug.ci:61: assertEq: function(<assertEq>)
cmplStd/lib/math.ci:22: Math.modf: function(<Math.modf>)
cmplStd/lib/math.ci:47: Math.floor: function(<Math.floor>)
cmplStd/lib/math.ci:82: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:90: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:164: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:175: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:206: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:220: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:234: Math.sum: function(<Math.sum>)
cmplStd/lib/math.ci:243: Math.mean: function(<Math.mean>)
cmplStd/lib/math.ci:260: Math.eval: function(<Math.eval>)
cmplStd/lib/math.ci:269: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:284: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:299: Math.sinCos: function(<Math.sinCos>)
cmplStd/lib/math.ci:356: Math.tan: function(<Math.tan>)
cmplStd/lib/math.ci:413: Math.sinh: function(<Math.sinh>)
cmplStd/lib/math.ci:452: Math.cosh: function(<Math.cosh>)
cmplStd/lib/math.ci:467: Math.asin: function(<Math.asin>)
cmplStd/lib/math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:24: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:31: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:86: div: function(<div>)
cmplStd/lib/math/Complex.ci:117: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:135: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:111: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:160: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:193: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:203: scale: function(<scale>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/text/string.ci:4: length: function(<length>)
cmplStd/lib/text/string.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/text/string.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/text/string.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/text/string.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/text/string.ci:61: compare: function(<compare>)
cmplStd/lib/text/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/text/string.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/text/string.ci:119: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/text/string.ci:134: append: function(<append>)
cmplStd/lib/text/string.ci:154: append: function(<append>)
cmplStd/lib/text/string.ci:229: append: function(<append>)
cmplStd/lib/text/string.ci:255: append: function(<append>)
cmplStd/lib/text/string.ci:294: append: function(<append>)
cmplStd/lib/text/string.ci:300: float64: function(<float64>)
cmplStd/test/lang/emit.ci:3: emitldz32: int32(0)
cmplStd/test/lang/emit.ci:4: emitldz64: int64(0)
cmplStd/test/lang/emit.ci:6: emitA: int32(42)
cmplStd/test/lang/emit.ci:7: emitB: int32(96)
cmplStd/test/lang/emit.ci:10: emitAddI32: int32(138)
cmplStd/test/lang/emit.ci:13: emitDivI32: int32(2)
cmplStd/test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
cmplStd/test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
cmplStd/test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
cmplStd/test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
cmplStd/test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
cmplStd/test/lang/emit.ci:29: emitSlice: char[]([3] {'s', 't', 'r'})
cmplStd/test/lang/inlineMacros.ci:10: i3: int32(3)
cmplStd/test/lang/inlineMacros.ci:11: i6: int32(6)
cmplStd/test/lang/inlineMacros.ci:12: i2: int32(2)
cmplStd/test/lang/inlineMacros.ci:13: i8: int32(8)
cmplStd/test/lang/inlineMacros.ci:15: zeroVal: int32(0)
cmplStd/test/lang/inlineMacros.ci:16: zeroVar: int32(0)
cmplStd/test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
cmplStd/test/lang/inlineMacros.ci:19: lastVal: int32(6)
cmplStd/test/lang/inlineMacros.ci:20: lastVar: int32(6)
cmplStd/test/lang/inlineMacros.ci:21: lastXpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:23: sum2Val: int32(9)
cmplStd/test/lang/inlineMacros.ci:24: sum2Var: int32(9)
cmplStd/test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
cmplStd/test/lang/inlineMacros.ci:27: any2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:28: any2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:31: min2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:32: min2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:35: max2Val: int32(6)
cmplStd/test/lang/inlineMacros.ci:36: max2Var: int32(6)
cmplStd/test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:59: minRlVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:60: minLrVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:61: minRlVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:62: minLrVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
cmplStd/test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
cmplStd/test/lang/overload.inline.ci:9: overload1: float32(1.000000)
cmplStd/test/lang/overload.inline.ci:10: overload2: float32(2.000000)
cmplStd/test/lang/overload.inline.ci:11: overload3: float32(3.000000)
cmplStd/test/lang/overload.inline.ci:12: overload4: float32(4.000000)
cmplStd/test/lang/overload.inline.ci:13: overload5: float32(5.000000)
cmplStd/test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
cmplStd/test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
cmplStd/test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
cmplStd/test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
cmplStd/test/std/number.ci:3: pi64: float64(3.141593)
cmplStd/test/std/number.ci:4: e64: float64(2.718282)
cmplStd/test/std/number.ci:6: pi32: float32(3.141593)
cmplStd/test/std/number.ci:7: e32: float32(2.718282)
cmplStd/test/std/number.ci:14: r_comp: int32(112)
cmplStd/test/std/number.ci:15: g_comp: int32(252)
cmplStd/test/std/number.ci:16: b_comp: int32(248)
cmplStd/test/std/number.ci:18: r5g6b5: int32(30719)
cmplStd/test/std/number.ci:19: r8g8b8: int32(7404792)
cmplStd/test/std/number.ci:21: zxtR5: int32(14)
cmplStd/test/std/number.ci:22: zxtG6: int32(63)
cmplStd/test/std/number.ci:23: zxtB5: int32(31)
cmplStd/test/std/number.ci:25: sxtR5: int32(14)
cmplStd/test/std/number.ci:26: sxtG6: int32(-1)
cmplStd/test/std/number.ci:27: sxtB5: int32(-1)
cmplStd/test/std/number.ci:29: zxtR8: int32(112)
cmplStd/test/std/number.ci:30: zxtG8: int32(252)
cmplStd/test/std/number.ci:31: zxtB8: int32(248)
cmplStd/test/std/number.ci:33: sxtR8: int32(112)
cmplStd/test/std/number.ci:34: sxtG8: int32(-4)
cmplStd/test/std/number.ci:35: sxtB8: int32(-8)
cmplStd/test/std/number.ci:37: testSin_f64: float64(1.000000)
cmplStd/test/std/number.ci:38: testCos_f64: float64(0.000000)
cmplStd/test/std/number.ci:39: testTan_f64: float64(1.000000)
cmplStd/test/std/number.ci:40: testLog_f64: float64(3.000000)
cmplStd/test/std/number.ci:41: testExp_f64: float64(2.718282)
cmplStd/test/std/number.ci:42: testPow_f64: float64(3.141593)
cmplStd/test/std/number.ci:43: testSqrt_f64: float64(3.141593)
cmplStd/test/std/number.ci:44: testAtan_f64: float64(1.262627)
cmplStd/test/std/number.ci:46: testSin_f32: float32(1.000000)
cmplStd/test/std/number.ci:47: testCos_f32: float32(-0.000000)
cmplStd/test/std/number.ci:48: testTan_f32: float32(1.000000)
cmplStd/test/std/number.ci:49: testLog_f32: float32(3.000000)
cmplStd/test/std/number.ci:50: testExp_f32: float32(2.718282)
cmplStd/test/std/number.ci:51: testPow_f32: float32(3.141593)
cmplStd/test/std/number.ci:52: testSqrt_f32: float32(3.141593)
cmplStd/test/std/number.ci:53: testAtan_f32: float32(1.262627)
cmplStd/test/std/number.ci:55: testPopulation_u32: int32(14)
cmplStd/test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
cmplStd/test/std/number.ci:57: testBitScanReverse_u32: int32(14)
cmplStd/test/std/number.ci:58: testBitScanForward_u32: int32(0)
cmplStd/test/std/number.ci:59: testHighBit_u32: int32(16384)
cmplStd/test/std/number.ci:60: testLowBit_u32: int32(1)
cmplStd/test/std/number.ci:62: testZeroExtend_u32: int32(31)
cmplStd/test/std/number.ci:63: testSignExtend_u32: int32(-1)
cmplStd/test/std/number.ci:65: testZeroExtend_u64: int32(31)
cmplStd/test/std/number.ci:66: testSignExtend_u64: int32(-1)
cmplStd/test/std/memory.ci:7: p1: pointer(<?>)
cmplStd/test/std/memory.ci:8: p2: pointer(<?>)
cmplStd/test/std/memory.ci:9: p3: pointer(<?>)
cmplStd/test/std/memory.ci:10: p4: pointer(<?>)
cmplStd/test/std/memory.ci:23: val1: int64(0)
cmplStd/test/std/memory.ci:24: val2: int64(42)
cmplStd/test/std/tryExec.ci:11: noError: function(<noError>)
cmplStd/test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
cmplStd/test/std/tryExec.ci:20: divisionByZero: function(<divisionByZero>)
cmplStd/test/std/tryExec.ci:24: abortExecution: function(<abortExecution>)
cmplStd/test/std/tryExec.ci:38: invalidMemoryAccess: function(<invalidMemoryAccess>)
cmplStd/test/std/tryExec.ci:43: invalidInstruction: function(<invalidInstruction>)
cmplStd/test/std/tryExec.ci:47: tryExecErr0: int32(0)
cmplStd/test/std/tryExec.ci:48: tryExecErr1: int32(1)
cmplStd/test/std/tryExec.ci:49: tryExecErr2: int32(2)
cmplStd/test/std/tryExec.ci:50: tryExecErr3: int32(3)
cmplStd/test/std/tryExec.ci:51: tryExecErr4: int32(4)
cmplStd/test/std/tryExec.ci:52: tryExecErr5: int32(5)
cmplStd/test/std/tryExec.ci:53: tryExecErr6: int32(6)
cmplStd/test/lang/init.reference.ci:7: value: int64(42)
cmplStd/test/lang/init.reference.ci:8: valueRef: int64(42)
cmplStd/test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:12: fromRef: int64(42)
cmplStd/test/lang/init.reference.ci:13: fromPtr: int64(42)
cmplStd/test/lang/init.reference.ci:14: fromVar: int64(42)
cmplStd/test/lang/init.reference.ci:16: nullRef: int64(null)
cmplStd/test/lang/init.reference.ci:17: nullPtr: pointer(null)
cmplStd/test/lang/init.reference.ci:18: nullVar: variant(null)
cmplStd/test/lang/init.reference.ci:19: nullTyp: typename(null)
cmplStd/test/lang/init.reference.ci:20: nullFun: function(null)
cmplStd/test/lang/init.reference.ci:21: nullObj: object(null)
cmplStd/test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:27: local: int64(42)
cmplStd/test/lang/init.reference.ci:28: copyVal: int64(42)
cmplStd/test/lang/init.reference.ci:29: copyRef: int64(42)
cmplStd/test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
cmplStd/test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
cmplStd/test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
cmplStd/test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
cmplStd/test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
cmplStd/test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
cmplStd/test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
cmplStd/test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
cmplStd/test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
cmplStd/test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
cmplStd/test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
cmplStd/test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
cmplStd/test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
cmplStd/test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
cmplStd/test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
cmplStd/test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
cmplStd/test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
cmplStd/test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
cmplStd/test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
cmplStd/test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
cmplStd/test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
cmplStd/test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
cmplStd/test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
cmplStd/test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
cmplStd/test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
cmplStd/test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
cmplStd/test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
cmplStd/test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
cmplStd/test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
cmplStd/test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
cmplStd/test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
cmplStd/test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
cmplStd/test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
cmplStd/test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
cmplStd/test/lang/init.reference.ci:75: typVoid: typename(<void>)
cmplStd/test/lang/init.reference.ci:76: typBool: typename(<bool>)
cmplStd/test/lang/init.reference.ci:77: typChar: typename(<char>)
cmplStd/test/lang/init.reference.ci:78: typInt8: typename(<int8>)
cmplStd/test/lang/init.reference.ci:79: typInt16: typename(<int16>)
cmplStd/test/lang/init.reference.ci:80: typInt32: typename(<int32>)
cmplStd/test/lang/init.reference.ci:81: typInt64: typename(<int64>)
cmplStd/test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
cmplStd/test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
cmplStd/test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
cmplStd/test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
cmplStd/test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
cmplStd/test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
cmplStd/test/lang/init.reference.ci:88: typTypename: typename(<typename>)
cmplStd/test/lang/init.reference.ci:89: typFunction: typename(<function>)
cmplStd/test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
cmplStd/test/lang/init.reference.ci:91: typVariant: typename(<variant>)
cmplStd/test/lang/init.reference.ci:92: typObject: typename(<object>)
cmplStd/test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
cmplStd/test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
cmplStd/test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
cmplStd/test/lang/init.variable.ci:3: variable: int32(0)
cmplStd/test/lang/init.variable.ci:7: constant: int32(42)
cmplStd/test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
cmplStd/test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
cmplStd/test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
cmplStd/test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/function.ci:4: empty: function(<empty>)
cmplStd/test/lang/function.ci:7: funAdd: function(<funAdd>)
cmplStd/test/lang/function.ci:12: funAddResult: int32(9)
cmplStd/test/lang/function.ci:15: funAddRef: function(<funAdd>)
cmplStd/test/lang/function.ci:18: funAddRefResult: int32(10)
cmplStd/test/lang/function.ci:21: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:24: funMulResult: int32(12)
cmplStd/test/lang/function.ci:27: funMulRef: function(<funMul>)
cmplStd/test/lang/function.ci:30: funMulRefResult: int32(14)
cmplStd/test/lang/function.ci:33: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:38: fib: function(<fib>)
cmplStd/test/lang/function.ci:46: fibonacci_13: uint32(233)
cmplStd/test/lang/reflect.ci:3: sizeofVoid: int32(0)
cmplStd/test/lang/reflect.ci:4: sizeofBool: int32(1)
cmplStd/test/lang/reflect.ci:5: sizeofChar: int32(1)
cmplStd/test/lang/reflect.ci:6: sizeofInt8: int32(1)
cmplStd/test/lang/reflect.ci:7: sizeofInt16: int32(2)
cmplStd/test/lang/reflect.ci:8: sizeofInt32: int32(4)
cmplStd/test/lang/reflect.ci:9: sizeofInt64: int32(8)
cmplStd/test/lang/reflect.ci:10: sizeofUint8: int32(1)
cmplStd/test/lang/reflect.ci:11: sizeofUint16: int32(2)
cmplStd/test/lang/reflect.ci:12: sizeofUint32: int32(4)
cmplStd/test/lang/reflect.ci:13: sizeofUint64: int32(8)
cmplStd/test/lang/reflect.ci:14: sizeofFloat32: int32(4)
cmplStd/test/lang/reflect.ci:15: sizeofFloat64: int32(8)
cmplStd/test/lang/reflect.ci:16: sizeofPointer: int32(4)
cmplStd/test/lang/reflect.ci:17: sizeofVariant: int32(8)
cmplStd/test/lang/reflect.ci:18: sizeofTypename: int32(4)
cmplStd/test/lang/reflect.ci:19: sizeofFunction: int32(4)
cmplStd/test/lang/reflect.ci:20: sizeofObject: int32(4)
cmplStd/test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
cmplStd/test/lang/reflect.ci:32: offsetOfRecord: int32(319472)
cmplStd/test/lang/reflect.ci:33: sizeOfRecord: int32(16)
cmplStd/test/lang/reflect.ci:34: fileOfRecord: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:35: lineOfRecord: int32(26)
cmplStd/test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
cmplStd/test/lang/reflect.ci:39: offsetOfBase: int32(319152)
cmplStd/test/lang/reflect.ci:40: sizeOfBase: int32(12)
cmplStd/test/lang/reflect.ci:41: fileOfBase: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:42: lineOfBase: int32(22)
cmplStd/test/lang/reflect.ci:44: typeofBase1: typename(<object>)
cmplStd/test/lang/reflect.ci:45: offsetOfBase1: int32(2880)
cmplStd/test/lang/reflect.ci:46: sizeOfBase1: int32(4)
cmplStd/test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
cmplStd/test/lang/reflect.ci:49: offsetOfBase2: int32(8)
cmplStd/test/lang/reflect.ci:50: sizeOfBase2: int32(160)
cmplStd/test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
cmplStd/test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
cmplStd/test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
cmplStd/test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
cmplStd/test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
cmplStd/test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
cmplStd/test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
cmplStd/test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
cmplStd/test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
cmplStd/test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
cmplStd/test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
cmplStd/test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
cmplStd/test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
cmplStd/test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
cmplStd/test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
cmplStd/test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
cmplStd/test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
cmplStd/test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
cmplStd/test/lang/recUnion.ci:16: color: typename(<color>)
cmplStd/test/lang/recUnion.ci:22: Color: typename(<Color>)
cmplStd/test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
cmplStd/test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535)
})
cmplStd/test/lang/recUnion.ci:31: blue: color({
	col: uint32(255)
})
cmplStd/test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
cmplStd/test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
cmplStd/test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
cmplStd/test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
cmplStd/test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
cmplStd/test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
cmplStd/test/lang/useOperator.ci:5: shift: int32(2)
cmplStd/test/lang/useOperator.ci:7: boolA: bool(1)
cmplStd/test/lang/useOperator.ci:8: boolB: bool(1)
cmplStd/test/lang/useOperator.ci:17: boolAnd: bool(1)
cmplStd/test/lang/useOperator.ci:18: boolIor: bool(1)
cmplStd/test/lang/useOperator.ci:19: boolXor: bool(0)
cmplStd/test/lang/useOperator.ci:22: boolNot: bool(0)
cmplStd/test/lang/useOperator.ci:23: boolCeq: bool(1)
cmplStd/test/lang/useOperator.ci:24: boolCne: bool(0)
cmplStd/test/lang/useOperator.ci:25: boolClt: bool(0)
cmplStd/test/lang/useOperator.ci:26: boolCle: bool(1)
cmplStd/test/lang/useOperator.ci:27: boolCgt: bool(0)
cmplStd/test/lang/useOperator.ci:28: boolCge: bool(1)
cmplStd/test/lang/useOperator.ci:30: chrA: char('a')
cmplStd/test/lang/useOperator.ci:31: chrB: char('b')
cmplStd/test/lang/useOperator.ci:32: chrPls: char('b')
cmplStd/test/lang/useOperator.ci:33: chrNeg: char('')
cmplStd/test/lang/useOperator.ci:34: chrCmt: char('')
cmplStd/test/lang/useOperator.ci:35: chrAdd: char('')
cmplStd/test/lang/useOperator.ci:36: chrSub: char('')
cmplStd/test/lang/useOperator.ci:37: chrMul: char('\"')
cmplStd/test/lang/useOperator.ci:38: chrDiv: char('')
cmplStd/test/lang/useOperator.ci:39: chrMod: char('a')
cmplStd/test/lang/useOperator.ci:40: chrAnd: char('`')
cmplStd/test/lang/useOperator.ci:41: chrIor: char('c')
cmplStd/test/lang/useOperator.ci:42: chrXor: char('')
cmplStd/test/lang/useOperator.ci:43: chrShl: char('')
cmplStd/test/lang/useOperator.ci:44: chrShr: char('')
cmplStd/test/lang/useOperator.ci:45: chrNot: bool(0)
cmplStd/test/lang/useOperator.ci:46: chrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:47: chrCne: bool(1)
cmplStd/test/lang/useOperator.ci:48: chrClt: bool(1)
cmplStd/test/lang/useOperator.ci:49: chrCle: bool(1)
cmplStd/test/lang/useOperator.ci:50: chrCgt: bool(0)
cmplStd/test/lang/useOperator.ci:51: chrCge: bool(0)
cmplStd/test/lang/useOperator.ci:53: i8A: int8(96)
cmplStd/test/lang/useOperator.ci:54: i8B: int8(42)
cmplStd/test/lang/useOperator.ci:55: i8Pls: int8(42)
cmplStd/test/lang/useOperator.ci:56: i8Neg: int8(-42)
cmplStd/test/lang/useOperator.ci:57: i8Cmt: int8(-43)
cmplStd/test/lang/useOperator.ci:58: i8Add: int8(-118)
cmplStd/test/lang/useOperator.ci:59: i8Sub: int8(54)
cmplStd/test/lang/useOperator.ci:60: i8Mul: int8(-64)
cmplStd/test/lang/useOperator.ci:61: i8Div: int8(2)
cmplStd/test/lang/useOperator.ci:62: i8Mod: int8(12)
cmplStd/test/lang/useOperator.ci:63: i8And: int8(32)
cmplStd/test/lang/useOperator.ci:64: i8Ior: int8(106)
cmplStd/test/lang/useOperator.ci:65: i8Xor: int8(74)
cmplStd/test/lang/useOperator.ci:66: i8Shl: int8(-128)
cmplStd/test/lang/useOperator.ci:67: i8Shr: int8(24)
cmplStd/test/lang/useOperator.ci:68: i8Not: bool(0)
cmplStd/test/lang/useOperator.ci:69: i8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:70: i8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:71: i8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:72: i8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:73: i8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:74: i8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:76: u8A: uint8(96)
cmplStd/test/lang/useOperator.ci:77: u8B: uint8(42)
cmplStd/test/lang/useOperator.ci:78: u8Pls: uint8(42)
cmplStd/test/lang/useOperator.ci:79: u8Neg: uint8(214)
cmplStd/test/lang/useOperator.ci:80: u8Cmt: uint8(213)
cmplStd/test/lang/useOperator.ci:81: u8Add: uint8(138)
cmplStd/test/lang/useOperator.ci:82: u8Sub: uint8(54)
cmplStd/test/lang/useOperator.ci:83: u8Mul: uint8(192)
cmplStd/test/lang/useOperator.ci:84: u8Div: uint8(2)
cmplStd/test/lang/useOperator.ci:85: u8Mod: uint8(12)
cmplStd/test/lang/useOperator.ci:86: u8And: uint8(32)
cmplStd/test/lang/useOperator.ci:87: u8Ior: uint8(106)
cmplStd/test/lang/useOperator.ci:88: u8Xor: uint8(74)
cmplStd/test/lang/useOperator.ci:89: u8Shl: uint8(128)
cmplStd/test/lang/useOperator.ci:90: u8Shr: uint8(24)
cmplStd/test/lang/useOperator.ci:91: u8Not: bool(0)
cmplStd/test/lang/useOperator.ci:92: u8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:93: u8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:94: u8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:95: u8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:96: u8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:97: u8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:99: i16A: int16(96)
cmplStd/test/lang/useOperator.ci:100: i16B: int16(42)
cmplStd/test/lang/useOperator.ci:101: i16Pls: int16(42)
cmplStd/test/lang/useOperator.ci:102: i16Neg: int16(-42)
cmplStd/test/lang/useOperator.ci:103: i16Cmt: int16(-43)
cmplStd/test/lang/useOperator.ci:104: i16Add: int16(138)
cmplStd/test/lang/useOperator.ci:105: i16Sub: int16(54)
cmplStd/test/lang/useOperator.ci:106: i16Mul: int16(4032)
cmplStd/test/lang/useOperator.ci:107: i16Div: int16(2)
cmplStd/test/lang/useOperator.ci:108: i16Mod: int16(12)
cmplStd/test/lang/useOperator.ci:109: i16And: int16(32)
cmplStd/test/lang/useOperator.ci:110: i16Ior: int16(106)
cmplStd/test/lang/useOperator.ci:111: i16Xor: int16(74)
cmplStd/test/lang/useOperator.ci:112: i16Shl: int16(384)
cmplStd/test/lang/useOperator.ci:113: i16Shr: int16(24)
cmplStd/test/lang/useOperator.ci:114: i16Not: bool(0)
cmplStd/test/lang/useOperator.ci:115: i16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:116: i16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:117: i16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:118: i16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:119: i16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:120: i16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:122: u16A: uint16(96)
cmplStd/test/lang/useOperator.ci:123: u16B: uint16(42)
cmplStd/test/lang/useOperator.ci:124: u16Pls: uint16(42)
cmplStd/test/lang/useOperator.ci:125: u16Neg: uint16(65494)
cmplStd/test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
cmplStd/test/lang/useOperator.ci:127: u16Add: uint16(138)
cmplStd/test/lang/useOperator.ci:128: u16Sub: uint16(54)
cmplStd/test/lang/useOperator.ci:129: u16Mul: uint16(4032)
cmplStd/test/lang/useOperator.ci:130: u16Div: uint16(2)
cmplStd/test/lang/useOperator.ci:131: u16Mod: uint16(12)
cmplStd/test/lang/useOperator.ci:132: u16And: uint16(32)
cmplStd/test/lang/useOperator.ci:133: u16Ior: uint16(106)
cmplStd/test/lang/useOperator.ci:134: u16Xor: uint16(74)
cmplStd/test/lang/useOperator.ci:135: u16Shl: uint16(384)
cmplStd/test/lang/useOperator.ci:136: u16Shr: uint16(24)
cmplStd/test/lang/useOperator.ci:137: u16Not: bool(0)
cmplStd/test/lang/useOperator.ci:138: u16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:139: u16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:140: u16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:141: u16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:142: u16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:143: u16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:145: i32A: int32(96)
cmplStd/test/lang/useOperator.ci:146: i32B: int32(42)
cmplStd/test/lang/useOperator.ci:147: i32Pls: int32(42)
cmplStd/test/lang/useOperator.ci:148: i32Neg: int32(-42)
cmplStd/test/lang/useOperator.ci:149: i32Cmt: int32(-43)
cmplStd/test/lang/useOperator.ci:150: i32Add: int32(138)
cmplStd/test/lang/useOperator.ci:151: i32Sub: int32(54)
cmplStd/test/lang/useOperator.ci:152: i32Mul: int32(4032)
cmplStd/test/lang/useOperator.ci:153: i32Div: int32(2)
cmplStd/test/lang/useOperator.ci:154: i32Mod: int32(12)
cmplStd/test/lang/useOperator.ci:155: i32And: int32(32)
cmplStd/test/lang/useOperator.ci:156: i32Ior: int32(106)
cmplStd/test/lang/useOperator.ci:157: i32Xor: int32(74)
cmplStd/test/lang/useOperator.ci:158: i32Shl: int32(384)
cmplStd/test/lang/useOperator.ci:159: i32Shr: int32(24)
cmplStd/test/lang/useOperator.ci:160: i32Not: bool(0)
cmplStd/test/lang/useOperator.ci:161: i32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:162: i32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:163: i32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:164: i32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:165: i32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:166: i32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:168: u32A: uint32(96)
cmplStd/test/lang/useOperator.ci:169: u32B: uint32(42)
cmplStd/test/lang/useOperator.ci:170: u32Pls: uint32(42)
cmplStd/test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
cmplStd/test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
cmplStd/test/lang/useOperator.ci:173: u32Add: uint32(138)
cmplStd/test/lang/useOperator.ci:174: u32Sub: uint32(54)
cmplStd/test/lang/useOperator.ci:175: u32Mul: uint32(4032)
cmplStd/test/lang/useOperator.ci:176: u32Div: uint32(2)
cmplStd/test/lang/useOperator.ci:177: u32Mod: uint32(12)
cmplStd/test/lang/useOperator.ci:178: u32And: uint32(32)
cmplStd/test/lang/useOperator.ci:179: u32Ior: uint32(106)
cmplStd/test/lang/useOperator.ci:180: u32Xor: uint32(74)
cmplStd/test/lang/useOperator.ci:181: u32Shl: uint32(384)
cmplStd/test/lang/useOperator.ci:182: u32Shr: uint32(24)
cmplStd/test/lang/useOperator.ci:183: u32Not: bool(0)
cmplStd/test/lang/useOperator.ci:184: u32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:185: u32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:186: u32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:187: u32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:188: u32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:189: u32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:191: i64A: int64(96)
cmplStd/test/lang/useOperator.ci:192: i64B: int64(42)
cmplStd/test/lang/useOperator.ci:193: i64Pls: int64(42)
cmplStd/test/lang/useOperator.ci:194: i64Neg: int64(-42)
cmplStd/test/lang/useOperator.ci:195: i64Cmt: int64(-43)
cmplStd/test/lang/useOperator.ci:196: i64Add: int64(138)
cmplStd/test/lang/useOperator.ci:197: i64Sub: int64(54)
cmplStd/test/lang/useOperator.ci:198: i64Mul: int64(4032)
cmplStd/test/lang/useOperator.ci:199: i64Div: int64(2)
cmplStd/test/lang/useOperator.ci:200: i64Mod: int64(12)
cmplStd/test/lang/useOperator.ci:201: i64And: int64(32)
cmplStd/test/lang/useOperator.ci:202: i64Ior: int64(106)
cmplStd/test/lang/useOperator.ci:203: i64Xor: int64(74)
cmplStd/test/lang/useOperator.ci:204: i64Shl: int64(384)
cmplStd/test/lang/useOperator.ci:205: i64Shr: int64(24)
cmplStd/test/lang/useOperator.ci:206: i64Not: bool(0)
cmplStd/test/lang/useOperator.ci:207: i64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:208: i64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:209: i64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:210: i64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:211: i64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:212: i64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:214: u64A: uint64(96)
cmplStd/test/lang/useOperator.ci:215: u64B: uint64(42)
cmplStd/test/lang/useOperator.ci:216: u64Pls: uint64(42)
cmplStd/test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
cmplStd/test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
cmplStd/test/lang/useOperator.ci:219: u64Add: uint64(138)
cmplStd/test/lang/useOperator.ci:220: u64Sub: uint64(54)
cmplStd/test/lang/useOperator.ci:221: u64Mul: uint64(4032)
cmplStd/test/lang/useOperator.ci:222: u64Div: uint64(2)
cmplStd/test/lang/useOperator.ci:223: u64Mod: uint64(12)
cmplStd/test/lang/useOperator.ci:224: u64And: uint64(32)
cmplStd/test/lang/useOperator.ci:225: u64Ior: uint64(106)
cmplStd/test/lang/useOperator.ci:226: u64Xor: uint64(74)
cmplStd/test/lang/useOperator.ci:227: u64Shl: uint64(384)
cmplStd/test/lang/useOperator.ci:228: u64Shr: uint64(24)
cmplStd/test/lang/useOperator.ci:229: u64Not: bool(0)
cmplStd/test/lang/useOperator.ci:230: u64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:231: u64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:232: u64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:233: u64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:234: u64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:235: u64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:237: f32A: float32(96.300003)
cmplStd/test/lang/useOperator.ci:238: f32B: float32(42.139999)
cmplStd/test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
cmplStd/test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
cmplStd/test/lang/useOperator.ci:242: f32Add: float32(138.440002)
cmplStd/test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
cmplStd/test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
cmplStd/test/lang/useOperator.ci:245: f32Div: float32(2.285240)
cmplStd/test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
cmplStd/test/lang/useOperator.ci:252: f32Not: bool(0)
cmplStd/test/lang/useOperator.ci:253: f32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:254: f32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:255: f32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:256: f32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:257: f32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:258: f32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:260: f64A: float64(96.300000)
cmplStd/test/lang/useOperator.ci:261: f64B: float64(42.140000)
cmplStd/test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
cmplStd/test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
cmplStd/test/lang/useOperator.ci:265: f64Add: float64(138.440000)
cmplStd/test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
cmplStd/test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
cmplStd/test/lang/useOperator.ci:268: f64Div: float64(2.285240)
cmplStd/test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
cmplStd/test/lang/useOperator.ci:275: f64Not: bool(0)
cmplStd/test/lang/useOperator.ci:276: f64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:277: f64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:278: f64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:279: f64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:280: f64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:281: f64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:283: ptrA: pointer(null)
cmplStd/test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
cmplStd/test/lang/useOperator.ci:299: ptrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:300: ptrCne: bool(1)
cmplStd/test/lang/stmt.if.ci:26: t: int32(0)
cmplStd/test/lang/stmt.for.ci:12: forIdx: int32(2)
cmplStd/test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
cmplStd/test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
cmplStd/test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
cmplStd/test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
cmplStd/test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
cmplStd/test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
cmplStd/test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
cmplStd/test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
cmplStd/test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
cmplStd/test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
cmplStd/test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
cmplStd/test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
cmplStd/test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
cmplStd/test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
cmplStd/test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
cmplStd/test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
cmplStd/test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
cmplStd/test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
cmplStd/test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
cmplStd/test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
cmplStd/test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
cmplStd/test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
cmplStd/test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
cmplStd/test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
cmplStd/test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
cmplStd/test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
cmplStd/test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
cmplStd/test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
cmplStd/test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
cmplStd/test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
cmplStd/test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
cmplStd/test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
cmplStd/test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
cmplStd/test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
cmplStd/test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
cmplStd/test/std/test.math.ci:67: testMathCmp_f32: bool(1)
cmplStd/test/std/test.math.ci:68: testMathCmp_f64: bool(1)
cmplStd/test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
cmplStd/test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
cmplStd/test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
cmplStd/test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
cmplStd/test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
cmplStd/test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
cmplStd/test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
cmplStd/test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
cmplStd/test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
cmplStd/test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
cmplStd/test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
cmplStd/test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
cmplStd/test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
cmplStd/test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
cmplStd/test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
cmplStd/test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
cmplStd/test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
cmplStd/test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
cmplStd/test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
cmplStd/test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
cmplStd/test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
cmplStd/test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194016(4.0 Mb)
memory[used] @000000; size: 424807(414.9 Kb)
memory[heap] @067b67; size: 2720657(2.6 Mb)
memory[stack] @1fff40; size: 1048504(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 400160(390.8 Kb)
memory[code] @000000; size: 19612(19.2 Kb)
memory[data] @000000; size: 2607(2.5 Kb)

---------- heap memory:
memory[free] @067b80; size: 2144(2.1 Kb)
memory[used] @0683f0; size: 32(32.0 bytes)
memory[used] @068420; size: 32(32.0 bytes)
memory[free] @068450; size: 2718352(2.6 Mb)

---------- Exitcode: 0, time: 106.472 ms
