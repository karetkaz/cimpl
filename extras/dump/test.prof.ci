
---------- Compile: `cmplStd/stdlib.ci`
warn: variable `args` hides previous declaration
cmplStd/stdlib.ci:40: debug: inline file: `cmplStd/lib/debug.ci`
cmplStd/lib/debug.ci:65: warn: adding implicit cast variant(message: char[*])
cmplStd/lib/debug.ci:67: warn: adding implicit cast variant(expected: int32)
cmplStd/lib/debug.ci:68: warn: adding implicit cast variant(returned: int32)
cmplStd/lib/debug.ci:69: warn: adding implicit cast variant[](extras: variant[1])
cmplStd/stdlib.ci:43: debug: inline file: `cmplStd/lib/math.ci`
cmplStd/lib/math.ci:17: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:18: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:23: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:24: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:29: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:32: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:64: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:64: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:65: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:66: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math.ci:71: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:71: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:74: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:74: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:78: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:86: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:96: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math.ci:105: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:108: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:179: warn: adding implicit cast float32(2: int32)
cmplStd/lib/math.ci:179: warn: adding implicit cast float32(3: int32)
cmplStd/lib/math.ci:180: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:180: warn: adding implicit cast float64(3: int32)
cmplStd/lib/math.ci:190: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:194: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:204: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:208: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:219: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:227: warn: adding implicit cast float64(signed(data.length): int32)
cmplStd/lib/math.ci:245: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math.ci:297: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:303: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:304: warn: adding implicit cast float64(32764: int32)
cmplStd/lib/math.ci:307: warn: adding implicit cast float64(quad: int32)
cmplStd/lib/math.ci:311: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math.ci:311: warn: adding implicit cast int32(e - (4) * f: float64)
cmplStd/lib/math.ci:315: warn: adding implicit cast float64(k: int32)
cmplStd/lib/math.ci:320: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:355: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:359: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:367: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:375: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:384: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:387: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:409: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:414: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:415: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:420: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:436: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:439: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:440: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:442: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:451: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:457: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:462: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:467: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:469: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:485: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:509: warn: adding implicit cast float64(180: int32)
cmplStd/lib/math.ci:512: warn: adding implicit cast float64(180: int32)
cmplStd/stdlib.ci:46: debug: inline file: `cmplStd/lib/math/Complex.ci`
cmplStd/lib/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
cmplStd/lib/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
cmplStd/stdlib.ci:47: debug: inline file: `cmplStd/lib/math/Vector4f.ci`
cmplStd/stdlib.ci:48: debug: inline file: `cmplStd/lib/math/Matrix4f.ci`
cmplStd/lib/math/Matrix4f.ci:113: warn: adding implicit cast float64(len: float32)
cmplStd/lib/math/Matrix4f.ci:137: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(1: int32)
cmplStd/stdlib.ci:49: debug: inline file: `cmplStd/lib/math/Vector2d.ci`
cmplStd/stdlib.ci:54: debug: inline file: `cmplStd/lib/string.ci`
cmplStd/lib/string.ci:5: warn: adding implicit cast pointer(str: char[*])
cmplStd/lib/string.ci:37: warn: adding implicit cast int32(with[i]: char)
cmplStd/lib/string.ci:65: warn: adding implicit cast int32(str[i]: char)
cmplStd/lib/string.ci:121: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
cmplStd/lib/string.ci:127: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
cmplStd/lib/string.ci:133: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:140: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:141: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/string.ci:141: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/string.ci:143: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:156: warn: adding implicit cast int32(sign: char)
cmplStd/lib/string.ci:166: warn: adding implicit cast int32(radixDigits.length: uint32)
cmplStd/lib/string.ci:169: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/string.ci:169: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/string.ci:170: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/string.ci:184: warn: adding implicit cast int32(sign: char)
cmplStd/lib/string.ci:189: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:201: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:208: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:213: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:214: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/string.ci:214: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/string.ci:216: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:229: warn: adding implicit cast int64(0: int32)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:229: warn: adding implicit cast int64(0: int32)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:233: warn: adding implicit cast int32(value: int16)
cmplStd/lib/string.ci:233: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:233: warn: adding implicit cast int32(value: int16)
cmplStd/lib/string.ci:235: warn: adding implicit cast int32(value: int8)
cmplStd/lib/string.ci:235: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:235: warn: adding implicit cast int32(value: int8)
cmplStd/lib/string.ci:252: warn: adding implicit cast float64(0: int32)
cmplStd/lib/string.ci:252: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:267: debug: using default field initializer: FormatFlags.showSign := false
cmplStd/lib/string.ci:267: debug: using default field initializer: FormatFlags.precision := 0
cmplStd/lib/string.ci:267: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/string.ci:124: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:267: debug: using default field initializer: FormatFlags.padLen := 0

---------- Compile: `cmplStd/test/test.ci`
cmplStd/test/test.ci:9: debug: inline file: `cmplStd/test/lang/emit.ci`
cmplStd/test/test.ci:10: debug: inline file: `cmplStd/test/lang/inlineMacros.ci`
cmplStd/test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
cmplStd/test/test.ci:11: debug: inline file: `cmplStd/test/lang/overload.inline.ci`
cmplStd/test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
cmplStd/test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
cmplStd/test/test.ci:14: debug: inline file: `cmplStd/test/std/number.ci`
cmplStd/test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
cmplStd/test/test.ci:15: debug: inline file: `cmplStd/test/std/memory.ci`
cmplStd/test/test.ci:16: debug: inline file: `cmplStd/test/std/tryExec.ci`
cmplStd/test/std/tryExec.ci:25: warn: variable `abortExecution.NotEquals` hides previous declaration
cmplStd/lib/debug.ci:48: warn: previously defined as `NotEquals`
cmplStd/test/std/tryExec.ci:25: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
cmplStd/test/std/tryExec.ci:31: warn: adding implicit cast char[*]("assertion failed": .cstr)
cmplStd/test/test.ci:20: debug: inline file: `cmplStd/test/lang/init.reference.ci`
cmplStd/test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:21: debug: inline file: `cmplStd/test/lang/init.variable.ci`
cmplStd/test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
cmplStd/test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:41: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/test.ci:24: debug: inline file: `cmplStd/test/lang/function.ci`
cmplStd/test/lang/function.ci:33: warn: Overwriting forward function: funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
cmplStd/test/test.ci:25: debug: inline file: `cmplStd/test/lang/reflect.ci`
cmplStd/test/test.ci:29: debug: inline file: `cmplStd/test/lang/init.member.ci`
cmplStd/test/lang/init.member.ci:81: warn: ignoring nested comment
cmplStd/test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
cmplStd/test/test.ci:30: debug: inline file: `cmplStd/test/lang/init.method.ci`
cmplStd/test/lang/init.method.ci:40: warn: Creating virtual method for: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47: warn: Overwriting forward function: RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
cmplStd/test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/test.ci:33: debug: inline file: `cmplStd/test/lang/recUnion.ci`
cmplStd/test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
cmplStd/test/test.ci:34: debug: inline file: `cmplStd/test/lang/recPacking.ci`
cmplStd/test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
cmplStd/test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
cmplStd/test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
cmplStd/test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
cmplStd/test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
cmplStd/test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
cmplStd/test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
cmplStd/test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
cmplStd/test/test.ci:41: debug: inline file: `cmplStd/test/lang/useOperator.ci`
cmplStd/test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
cmplStd/test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
cmplStd/test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
cmplStd/test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
cmplStd/test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
cmplStd/test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
cmplStd/test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
cmplStd/test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
cmplStd/test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
cmplStd/test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
cmplStd/test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
cmplStd/test/test.ci:45: debug: inline file: `cmplStd/test/lang/stmt.if.ci`
cmplStd/test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:46: debug: inline file: `cmplStd/test/lang/stmt.for.ci`
cmplStd/test/test.ci:49: debug: inline file: `cmplStd/test/std/test.math.ci`
cmplStd/test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
cmplStd/lib/math.ci:48: warn: using default type initializer: Math.floor.result := 0
cmplStd/lib/math.ci:302: warn: using default type initializer: Math.sinCos.y := 0
cmplStd/lib/math.ci:305: warn: using default type initializer: e := 0
cmplStd/lib/math.ci:309: warn: using default type initializer: f := 0
cmplStd/lib/math.ci:361: warn: using default type initializer: Math.tan.e := 0
cmplStd/lib/math.ci:418: warn: using default type initializer: Math.sinh.result := 0
cmplStd/lib/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
cmplStd/test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0
cmplStd/test/lang/init.method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006500>, cast: static const inline)
.field file: function (size: 0, offs: <@006718>, cast: static const inline)
.field line: function (size: 0, offs: <@006930>, cast: static const inline)
.field name: function (size: 0, offs: <@006b48>, cast: static const inline)
.field size: function (size: 0, offs: <@006d58>, cast: static const inline)
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:42: referenced as `typename`
	cmplStd/test/lang/reflect.ci:41: referenced as `typename`
	cmplStd/test/lang/reflect.ci:38: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:35: referenced as `typename`
	cmplStd/test/lang/reflect.ci:34: referenced as `typename`
	cmplStd/test/lang/reflect.ci:31: referenced as `typename`
	cmplStd/test/lang/reflect.ci:30: referenced as `typename`
	cmplStd/test/lang/reflect.ci:18: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:92: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:91: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:90: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:89: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:87: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:86: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:85: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:84: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:83: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:82: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:81: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:80: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:79: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:78: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:77: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:76: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:75: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:68: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:48: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:32: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:25: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:19: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:3: referenced as `typename`
	cmplStd/stdlib.ci:39: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	internal usages: 11
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `size`
	cmplStd/test/lang/reflect.ci:46: referenced as `size`
	cmplStd/test/lang/reflect.ci:40: referenced as `size`
	cmplStd/test/lang/reflect.ci:33: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:49: referenced as `offset`
	cmplStd/test/lang/reflect.ci:45: referenced as `offset`
	cmplStd/test/lang/reflect.ci:39: referenced as `offset`
	cmplStd/test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006500>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `base`
	cmplStd/test/lang/reflect.ci:44: referenced as `base`
	cmplStd/test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006718>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	cmplStd/test/lang/reflect.ci:41: referenced as `file`
	cmplStd/test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006930>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	cmplStd/test/lang/reflect.ci:42: referenced as `line`
	cmplStd/test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b48>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	cmplStd/test/lang/reflect.ci:38: referenced as `name`
	cmplStd/test/lang/reflect.ci:31: referenced as `name`
}
typename.size(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006d58>
.name: 'size'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
	cmplStd/stdlib.ci:37: referenced as `size`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b8>
.name: 'void'
.usages:
	cmplStd/test/lang/init.method.ci:90: referenced as `void`
	cmplStd/test/lang/init.method.ci:84: referenced as `void`
	cmplStd/test/lang/init.method.ci:57: referenced as `void`
	cmplStd/test/lang/init.method.ci:47: referenced as `void`
	cmplStd/test/lang/init.method.ci:40: referenced as `void`
	cmplStd/test/lang/init.method.ci:32: referenced as `void`
	cmplStd/test/lang/init.method.ci:25: referenced as `void`
	cmplStd/test/lang/init.method.ci:18: referenced as `void`
	cmplStd/test/lang/init.method.ci:10: referenced as `void`
	cmplStd/test/lang/reflect.ci:3: referenced as `void`
	cmplStd/test/lang/function.ci:4: referenced as `void`
	cmplStd/test/lang/init.reference.ci:75: referenced as `void`
	cmplStd/test/lang/init.reference.ci:55: referenced as `void`
	cmplStd/test/lang/init.reference.ci:35: referenced as `void`
	cmplStd/test/std/tryExec.ci:43: referenced as `void`
	cmplStd/test/std/tryExec.ci:38: referenced as `void`
	cmplStd/test/std/tryExec.ci:24: referenced as `void`
	cmplStd/test/std/tryExec.ci:20: referenced as `void`
	cmplStd/test/std/tryExec.ci:14: referenced as `void`
	cmplStd/test/std/tryExec.ci:11: referenced as `void`
	cmplStd/lib/debug.ci:61: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	internal usages: 7
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000160>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `bool`
	cmplStd/test/std/test.math.ci:67: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:300: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:299: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:281: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:280: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:279: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:278: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:277: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:276: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:275: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:258: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:257: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:256: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:255: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:254: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:253: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:252: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:235: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:234: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:233: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:232: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:231: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:230: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:229: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:212: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:211: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:210: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:209: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:208: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:207: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:206: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:189: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:188: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:187: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:186: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:185: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:184: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:183: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:166: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:165: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:164: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:163: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:162: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:161: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:160: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:143: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:142: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:141: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:140: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:139: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:138: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:137: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:120: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:119: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:118: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:117: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:116: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:115: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:114: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:97: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:96: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:95: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:94: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:93: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:92: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:91: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:74: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:73: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:72: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:71: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:70: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:69: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:68: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:51: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:50: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:49: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:48: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:47: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:46: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:45: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:28: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:27: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:26: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:25: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:24: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:23: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:22: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:19: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:18: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:17: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:8: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:7: referenced as `bool`
	cmplStd/test/lang/reflect.ci:4: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:76: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:56: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:36: referenced as `bool`
	cmplStd/lib/string.ci:118: referenced as `bool`
	cmplStd/lib/string.ci:46: referenced as `bool`
	cmplStd/lib/string.ci:36: referenced as `bool`
	cmplStd/lib/math.ci:456: referenced as `bool`
	cmplStd/lib/math.ci:408: referenced as `bool`
	cmplStd/lib/math.ci:353: referenced as `bool`
	cmplStd/lib/math.ci:352: referenced as `bool`
	cmplStd/lib/debug.ci:45: referenced as `bool`
	cmplStd/lib/debug.ci:43: referenced as `bool`
	cmplStd/lib/debug.ci:41: referenced as `bool`
	cmplStd/stdlib.ci:3: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000208>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:44: referenced as `char`
	cmplStd/test/lang/useOperator.ci:43: referenced as `char`
	cmplStd/test/lang/useOperator.ci:42: referenced as `char`
	cmplStd/test/lang/useOperator.ci:41: referenced as `char`
	cmplStd/test/lang/useOperator.ci:40: referenced as `char`
	cmplStd/test/lang/useOperator.ci:39: referenced as `char`
	cmplStd/test/lang/useOperator.ci:38: referenced as `char`
	cmplStd/test/lang/useOperator.ci:37: referenced as `char`
	cmplStd/test/lang/useOperator.ci:36: referenced as `char`
	cmplStd/test/lang/useOperator.ci:35: referenced as `char`
	cmplStd/test/lang/useOperator.ci:34: referenced as `char`
	cmplStd/test/lang/useOperator.ci:33: referenced as `char`
	cmplStd/test/lang/useOperator.ci:32: referenced as `char`
	cmplStd/test/lang/useOperator.ci:31: referenced as `char`
	cmplStd/test/lang/useOperator.ci:30: referenced as `char`
	cmplStd/test/lang/reflect.ci:41: referenced as `char`
	cmplStd/test/lang/reflect.ci:38: referenced as `char`
	cmplStd/test/lang/reflect.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:31: referenced as `char`
	cmplStd/test/lang/reflect.ci:5: referenced as `char`
	cmplStd/test/lang/init.reference.ci:77: referenced as `char`
	cmplStd/test/lang/init.reference.ci:57: referenced as `char`
	cmplStd/test/lang/init.reference.ci:37: referenced as `char`
	cmplStd/test/std/tryExec.ci:26: referenced as `char`
	cmplStd/test/lang/emit.ci:29: referenced as `char`
	cmplStd/lib/string.ci:266: referenced as `char`
	cmplStd/lib/string.ci:263: referenced as `char`
	cmplStd/lib/string.ci:252: referenced as `char`
	cmplStd/lib/string.ci:238: referenced as `char`
	cmplStd/lib/string.ci:235: referenced as `char`
	cmplStd/lib/string.ci:233: referenced as `char`
	cmplStd/lib/string.ci:231: referenced as `char`
	cmplStd/lib/string.ci:229: referenced as `char`
	cmplStd/lib/string.ci:227: referenced as `char`
	cmplStd/lib/string.ci:225: referenced as `char`
	cmplStd/lib/string.ci:223: referenced as `char`
	cmplStd/lib/string.ci:221: referenced as `char`
	cmplStd/lib/string.ci:178: referenced as `char`
	cmplStd/lib/string.ci:153: referenced as `char`
	cmplStd/lib/string.ci:150: referenced as `char`
	cmplStd/lib/string.ci:149: referenced as `char`
	cmplStd/lib/string.ci:148: referenced as `char`
	cmplStd/lib/string.ci:148: referenced as `char`
	cmplStd/lib/string.ci:131: referenced as `char`
	cmplStd/lib/string.ci:131: referenced as `char`
	cmplStd/lib/string.ci:124: referenced as `char`
	cmplStd/lib/string.ci:102: referenced as `char`
	cmplStd/lib/string.ci:102: referenced as `char`
	cmplStd/lib/string.ci:99: referenced as `char`
	cmplStd/lib/string.ci:99: referenced as `char`
	cmplStd/lib/string.ci:97: referenced as `char`
	cmplStd/lib/string.ci:97: referenced as `char`
	cmplStd/lib/string.ci:95: referenced as `char`
	cmplStd/lib/string.ci:95: referenced as `char`
	cmplStd/lib/string.ci:93: referenced as `char`
	cmplStd/lib/string.ci:93: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:4: referenced as `char`
	cmplStd/lib/debug.ci:61: referenced as `char`
	cmplStd/lib/debug.ci:43: referenced as `char`
	cmplStd/lib/debug.ci:41: referenced as `char`
	cmplStd/lib/debug.ci:36: referenced as `char`
	cmplStd/lib/debug.ci:34: referenced as `char`
	cmplStd/lib/debug.ci:31: referenced as `char`
	cmplStd/lib/debug.ci:29: referenced as `char`
	cmplStd/lib/debug.ci:26: referenced as `char`
	cmplStd/lib/debug.ci:24: referenced as `char`
	cmplStd/lib/debug.ci:21: referenced as `char`
	cmplStd/lib/debug.ci:19: referenced as `char`
	cmplStd/lib/debug.ci:16: referenced as `char`
	cmplStd/lib/debug.ci:14: referenced as `char`
	cmplStd/lib/debug.ci:11: referenced as `char`
	cmplStd/lib/debug.ci:9: referenced as `char`
	cmplStd/lib/debug.ci:6: referenced as `char`
	cmplStd/lib/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0002b0>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:67: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:66: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:65: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:64: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:63: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:62: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:61: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:60: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:59: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:58: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:57: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:56: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:55: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:54: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:53: referenced as `int8`
	cmplStd/test/lang/reflect.ci:6: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:78: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:58: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:38: referenced as `int8`
	cmplStd/lib/string.ci:235: referenced as `int8`
	cmplStd/stdlib.ci:25: referenced as `int8`
	cmplStd/stdlib.ci:13: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000358>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:113: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:112: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:111: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:110: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:109: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:108: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:107: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:106: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:105: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:104: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:103: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:102: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:101: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:100: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:99: referenced as `int16`
	cmplStd/test/lang/reflect.ci:7: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:79: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:59: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:39: referenced as `int16`
	cmplStd/lib/string.ci:233: referenced as `int16`
	cmplStd/stdlib.ci:28: referenced as `int16`
	cmplStd/stdlib.ci:16: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000400>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/stmt.for.ci:24: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:17: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:12: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:8: referenced as `int`
	cmplStd/test/lang/stmt.if.ci:26: referenced as `int`
	cmplStd/test/lang/useOperator.ci:159: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:158: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:157: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:156: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:155: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:154: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:153: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:152: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:151: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:150: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:149: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:148: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:147: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:146: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:145: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:5: referenced as `int32`
	cmplStd/test/lang/init.method.ci:90: referenced as `int`
	cmplStd/test/lang/init.method.ci:84: referenced as `int`
	cmplStd/test/lang/init.method.ci:57: referenced as `int`
	cmplStd/test/lang/init.method.ci:47: referenced as `int`
	cmplStd/test/lang/init.method.ci:40: referenced as `int`
	cmplStd/test/lang/init.method.ci:32: referenced as `int`
	cmplStd/test/lang/init.method.ci:25: referenced as `int`
	cmplStd/test/lang/init.method.ci:18: referenced as `int`
	cmplStd/test/lang/init.method.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:40: referenced as `int`
	cmplStd/test/lang/init.member.ci:37: referenced as `int`
	cmplStd/test/lang/init.member.ci:34: referenced as `int`
	cmplStd/test/lang/init.member.ci:19: referenced as `int`
	cmplStd/test/lang/init.member.ci:16: referenced as `int`
	cmplStd/test/lang/init.member.ci:13: referenced as `int`
	cmplStd/test/lang/init.member.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:6: referenced as `int`
	cmplStd/test/lang/init.member.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:50: referenced as `int`
	cmplStd/test/lang/reflect.ci:49: referenced as `int`
	cmplStd/test/lang/reflect.ci:46: referenced as `int`
	cmplStd/test/lang/reflect.ci:45: referenced as `int`
	cmplStd/test/lang/reflect.ci:42: referenced as `int`
	cmplStd/test/lang/reflect.ci:40: referenced as `int`
	cmplStd/test/lang/reflect.ci:39: referenced as `int`
	cmplStd/test/lang/reflect.ci:35: referenced as `int`
	cmplStd/test/lang/reflect.ci:33: referenced as `int`
	cmplStd/test/lang/reflect.ci:32: referenced as `int`
	cmplStd/test/lang/reflect.ci:27: referenced as `int32`
	cmplStd/test/lang/reflect.ci:20: referenced as `int`
	cmplStd/test/lang/reflect.ci:19: referenced as `int`
	cmplStd/test/lang/reflect.ci:18: referenced as `int`
	cmplStd/test/lang/reflect.ci:17: referenced as `int`
	cmplStd/test/lang/reflect.ci:16: referenced as `int`
	cmplStd/test/lang/reflect.ci:15: referenced as `int`
	cmplStd/test/lang/reflect.ci:14: referenced as `int`
	cmplStd/test/lang/reflect.ci:13: referenced as `int`
	cmplStd/test/lang/reflect.ci:12: referenced as `int`
	cmplStd/test/lang/reflect.ci:11: referenced as `int`
	cmplStd/test/lang/reflect.ci:10: referenced as `int`
	cmplStd/test/lang/reflect.ci:9: referenced as `int`
	cmplStd/test/lang/reflect.ci:8: referenced as `int32`
	cmplStd/test/lang/reflect.ci:8: referenced as `int`
	cmplStd/test/lang/reflect.ci:7: referenced as `int`
	cmplStd/test/lang/reflect.ci:6: referenced as `int`
	cmplStd/test/lang/reflect.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:4: referenced as `int`
	cmplStd/test/lang/reflect.ci:3: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:30: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:24: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:18: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:12: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:3: referenced as `int`
	cmplStd/test/lang/init.reference.ci:80: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:60: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:40: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:4: referenced as `int32`
	cmplStd/test/std/tryExec.ci:53: referenced as `int`
	cmplStd/test/std/tryExec.ci:52: referenced as `int`
	cmplStd/test/std/tryExec.ci:51: referenced as `int`
	cmplStd/test/std/tryExec.ci:50: referenced as `int`
	cmplStd/test/std/tryExec.ci:49: referenced as `int`
	cmplStd/test/std/tryExec.ci:48: referenced as `int`
	cmplStd/test/std/tryExec.ci:47: referenced as `int`
	cmplStd/test/std/tryExec.ci:40: referenced as `int`
	cmplStd/test/std/tryExec.ci:39: referenced as `int32`
	cmplStd/test/std/tryExec.ci:28: referenced as `int`
	cmplStd/test/std/tryExec.ci:27: referenced as `int`
	cmplStd/test/std/tryExec.ci:21: referenced as `int`
	cmplStd/test/std/memory.ci:4: referenced as `int`
	cmplStd/test/std/memory.ci:3: referenced as `int`
	cmplStd/test/std/number.ci:66: referenced as `int32`
	cmplStd/test/std/number.ci:65: referenced as `int32`
	cmplStd/test/std/number.ci:63: referenced as `int32`
	cmplStd/test/std/number.ci:62: referenced as `int32`
	cmplStd/test/std/number.ci:60: referenced as `int32`
	cmplStd/test/std/number.ci:59: referenced as `int32`
	cmplStd/test/std/number.ci:58: referenced as `int32`
	cmplStd/test/std/number.ci:57: referenced as `int32`
	cmplStd/test/std/number.ci:55: referenced as `int32`
	cmplStd/test/std/number.ci:35: referenced as `int32`
	cmplStd/test/std/number.ci:34: referenced as `int32`
	cmplStd/test/std/number.ci:33: referenced as `int32`
	cmplStd/test/std/number.ci:31: referenced as `int32`
	cmplStd/test/std/number.ci:30: referenced as `int32`
	cmplStd/test/std/number.ci:29: referenced as `int32`
	cmplStd/test/std/number.ci:27: referenced as `int32`
	cmplStd/test/std/number.ci:26: referenced as `int32`
	cmplStd/test/std/number.ci:25: referenced as `int32`
	cmplStd/test/std/number.ci:23: referenced as `int32`
	cmplStd/test/std/number.ci:22: referenced as `int32`
	cmplStd/test/std/number.ci:21: referenced as `int32`
	cmplStd/test/std/number.ci:19: referenced as `int32`
	cmplStd/test/std/number.ci:18: referenced as `int32`
	cmplStd/test/std/number.ci:16: referenced as `int`
	cmplStd/test/std/number.ci:15: referenced as `int`
	cmplStd/test/std/number.ci:14: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:5: referenced as `int32`
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:13: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:12: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:11: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:10: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/emit.ci:29: referenced as `int`
	cmplStd/test/lang/emit.ci:25: referenced as `int32`
	cmplStd/test/lang/emit.ci:23: referenced as `int32`
	cmplStd/test/lang/emit.ci:19: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:7: referenced as `int32`
	cmplStd/test/lang/emit.ci:6: referenced as `int32`
	cmplStd/test/lang/emit.ci:3: referenced as `int32`
	cmplStd/lib/string.ci:266: referenced as `int`
	cmplStd/lib/string.ci:266: referenced as `int`
	cmplStd/lib/string.ci:266: referenced as `int`
	cmplStd/lib/string.ci:263: referenced as `int`
	cmplStd/lib/string.ci:238: referenced as `int`
	cmplStd/lib/string.ci:238: referenced as `int`
	cmplStd/lib/string.ci:235: referenced as `int`
	cmplStd/lib/string.ci:233: referenced as `int`
	cmplStd/lib/string.ci:231: referenced as `int32`
	cmplStd/lib/string.ci:231: referenced as `int`
	cmplStd/lib/string.ci:229: referenced as `int`
	cmplStd/lib/string.ci:227: referenced as `int`
	cmplStd/lib/string.ci:225: referenced as `int`
	cmplStd/lib/string.ci:223: referenced as `int`
	cmplStd/lib/string.ci:221: referenced as `int`
	cmplStd/lib/string.ci:207: referenced as `int`
	cmplStd/lib/string.ci:176: referenced as `int`
	cmplStd/lib/string.ci:161: referenced as `int`
	cmplStd/lib/string.ci:152: referenced as `int`
	cmplStd/lib/string.ci:148: referenced as `int`
	cmplStd/lib/string.ci:148: referenced as `int`
	cmplStd/lib/string.ci:132: referenced as `int`
	cmplStd/lib/string.ci:131: referenced as `int`
	cmplStd/lib/string.ci:131: referenced as `int`
	cmplStd/lib/string.ci:127: referenced as `int`
	cmplStd/lib/string.ci:121: referenced as `int`
	cmplStd/lib/string.ci:88: referenced as `int`
	cmplStd/lib/string.ci:73: referenced as `int`
	cmplStd/lib/string.ci:63: referenced as `int`
	cmplStd/lib/string.ci:62: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:52: referenced as `int`
	cmplStd/lib/string.ci:48: referenced as `int`
	cmplStd/lib/string.ci:47: referenced as `int`
	cmplStd/lib/string.ci:46: referenced as `int`
	cmplStd/lib/string.ci:37: referenced as `int`
	cmplStd/lib/string.ci:36: referenced as `int`
	cmplStd/lib/string.ci:27: referenced as `int`
	cmplStd/lib/string.ci:26: referenced as `int`
	cmplStd/lib/string.ci:25: referenced as `int`
	cmplStd/lib/string.ci:16: referenced as `int`
	cmplStd/lib/string.ci:15: referenced as `int`
	cmplStd/lib/string.ci:8: referenced as `int`
	cmplStd/lib/string.ci:4: referenced as `int`
	cmplStd/lib/math.ci:363: referenced as `int`
	cmplStd/lib/math.ci:363: referenced as `int`
	cmplStd/lib/math.ci:314: referenced as `int`
	cmplStd/lib/math.ci:282: referenced as `int`
	cmplStd/lib/math.ci:267: referenced as `int`
	cmplStd/lib/math.ci:252: referenced as `int`
	cmplStd/lib/math.ci:245: referenced as `int`
	cmplStd/lib/math.ci:219: referenced as `int`
	cmplStd/lib/math.ci:208: referenced as `int`
	cmplStd/lib/math.ci:194: referenced as `int`
	cmplStd/lib/math.ci:129: referenced as `int32`
	cmplStd/lib/math.ci:129: referenced as `int32`
	cmplStd/lib/math.ci:111: referenced as `int32`
	cmplStd/lib/math.ci:111: referenced as `int32`
	cmplStd/lib/math.ci:93: referenced as `int32`
	cmplStd/lib/math.ci:74: referenced as `int`
	cmplStd/lib/math.ci:74: referenced as `int`
	cmplStd/lib/math.ci:71: referenced as `int`
	cmplStd/lib/math.ci:71: referenced as `int`
	cmplStd/lib/math.ci:63: referenced as `int32`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/stdlib.ci:31: referenced as `int32`
	cmplStd/stdlib.ci:19: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@0004a8>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `integer`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `integer`
	cmplStd/test/lang/useOperator.ci:205: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:204: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:203: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:202: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:201: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:200: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:199: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:198: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:197: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:196: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:195: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:194: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:193: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:192: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:191: referenced as `int64`
	cmplStd/test/lang/reflect.ci:23: referenced as `int64`
	cmplStd/test/lang/reflect.ci:9: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:81: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:61: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:41: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:29: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:28: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:27: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:25: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:24: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:16: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:14: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:13: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:12: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:8: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:7: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:3: referenced as `integer`
	cmplStd/test/std/memory.ci:30: referenced as `int64`
	cmplStd/test/std/memory.ci:29: referenced as `int64`
	cmplStd/test/std/memory.ci:24: referenced as `int64`
	cmplStd/test/std/memory.ci:23: referenced as `int64`
	cmplStd/test/lang/emit.ci:26: referenced as `int64`
	cmplStd/test/lang/emit.ci:24: referenced as `int64`
	cmplStd/test/lang/emit.ci:21: referenced as `int64`
	cmplStd/test/lang/emit.ci:4: referenced as `int64`
	cmplStd/test/test.ci:5: referenced as `int64`
	cmplStd/lib/string.ci:258: referenced as `int64`
	cmplStd/lib/string.ci:254: referenced as `int64`
	cmplStd/lib/string.ci:229: referenced as `int64`
	cmplStd/lib/math.ci:132: referenced as `int64`
	cmplStd/lib/math.ci:132: referenced as `int64`
	cmplStd/lib/math.ci:114: referenced as `int64`
	cmplStd/lib/math.ci:114: referenced as `int64`
	cmplStd/lib/math.ci:96: referenced as `int64`
	cmplStd/lib/math.ci:64: referenced as `int64`
	cmplStd/stdlib.ci:34: referenced as `int64`
	cmplStd/stdlib.ci:22: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000550>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:90: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:89: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:88: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:87: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:86: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:85: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:84: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:83: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:82: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:81: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:80: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:79: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:78: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:77: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:76: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:57: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:55: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:53: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:47: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:45: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:43: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:37: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:35: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:33: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:27: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:25: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:23: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:17: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:15: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:13: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:7: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:5: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:3: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:12: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:11: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:10: referenced as `uint8`
	cmplStd/test/lang/reflect.ci:10: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:82: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:62: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:42: referenced as `uint8`
	cmplStd/test/std/tryExec.ci:16: referenced as `byte`
	cmplStd/lib/string.ci:227: referenced as `uint8`
	cmplStd/stdlib.ci:25: referenced as `uint8`
	cmplStd/stdlib.ci:13: referenced as `uint8`
	cmplStd/stdlib.ci:8: referenced as `uint8`
	internal usages: 1
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005f8>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:136: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:135: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:134: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:133: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:132: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:131: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:130: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:129: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:128: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:127: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:126: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:125: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:124: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:123: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:122: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:58: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:48: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:38: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:28: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:18: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:8: referenced as `uint16`
	cmplStd/test/lang/reflect.ci:11: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:83: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:63: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:43: referenced as `uint16`
	cmplStd/lib/string.ci:225: referenced as `uint16`
	cmplStd/stdlib.ci:28: referenced as `uint16`
	cmplStd/stdlib.ci:16: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0006a0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@00a370>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a6c8>, cast: static const inline)
.field pop: function (size: 0, offs: <@00a8e0>, cast: static const inline)
.field swap: function (size: 0, offs: <@00aaf8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00ad10>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00af28>, cast: static const inline)
.field hib: function (size: 0, offs: <@00b140>, cast: static const inline)
.field lob: function (size: 0, offs: <@00b358>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:182: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:181: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:180: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:179: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:178: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:177: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:176: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:175: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:174: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:173: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:172: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:171: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:170: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:169: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:168: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:56: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:46: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:36: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:26: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:16: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:6: referenced as `uint32`
	cmplStd/test/lang/recUnion.ci:17: referenced as `uint32`
	cmplStd/test/lang/reflect.ci:12: referenced as `uint32`
	cmplStd/test/lang/function.ci:46: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:84: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:64: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:44: referenced as `uint32`
	cmplStd/test/std/number.ci:63: referenced as `uint32`
	cmplStd/test/std/number.ci:62: referenced as `uint32`
	cmplStd/test/std/number.ci:60: referenced as `uint32`
	cmplStd/test/std/number.ci:59: referenced as `uint32`
	cmplStd/test/std/number.ci:58: referenced as `uint32`
	cmplStd/test/std/number.ci:57: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:55: referenced as `uint32`
	cmplStd/test/std/number.ci:35: referenced as `uint32`
	cmplStd/test/std/number.ci:34: referenced as `uint32`
	cmplStd/test/std/number.ci:33: referenced as `uint32`
	cmplStd/test/std/number.ci:31: referenced as `uint32`
	cmplStd/test/std/number.ci:30: referenced as `uint32`
	cmplStd/test/std/number.ci:29: referenced as `uint32`
	cmplStd/test/std/number.ci:27: referenced as `uint32`
	cmplStd/test/std/number.ci:26: referenced as `uint32`
	cmplStd/test/std/number.ci:25: referenced as `uint32`
	cmplStd/test/std/number.ci:23: referenced as `uint32`
	cmplStd/test/std/number.ci:22: referenced as `uint32`
	cmplStd/test/std/number.ci:21: referenced as `uint32`
	cmplStd/lib/string.ci:223: referenced as `uint32`
	cmplStd/lib/math.ci:135: referenced as `uint32`
	cmplStd/lib/math.ci:135: referenced as `uint32`
	cmplStd/lib/math.ci:117: referenced as `uint32`
	cmplStd/lib/math.ci:117: referenced as `uint32`
	cmplStd/lib/math.ci:99: referenced as `uint32`
	cmplStd/lib/math.ci:65: referenced as `uint32`
	cmplStd/stdlib.ci:31: referenced as `uint32`
	cmplStd/stdlib.ci:19: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a370>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(23)
.usages:
	cmplStd/test/std/number.ci:62: referenced as `zxt`
	cmplStd/test/std/number.ci:31: referenced as `zxt`
	cmplStd/test/std/number.ci:30: referenced as `zxt`
	cmplStd/test/std/number.ci:29: referenced as `zxt`
	cmplStd/test/std/number.ci:23: referenced as `zxt`
	cmplStd/test/std/number.ci:22: referenced as `zxt`
	cmplStd/test/std/number.ci:21: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a6c8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(24)
.usages:
	cmplStd/test/std/number.ci:63: referenced as `sxt`
	cmplStd/test/std/number.ci:35: referenced as `sxt`
	cmplStd/test/std/number.ci:34: referenced as `sxt`
	cmplStd/test/std/number.ci:33: referenced as `sxt`
	cmplStd/test/std/number.ci:27: referenced as `sxt`
	cmplStd/test/std/number.ci:26: referenced as `sxt`
	cmplStd/test/std/number.ci:25: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a8e0>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	cmplStd/test/std/number.ci:55: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00aaf8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	cmplStd/test/std/number.ci:56: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad10>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	cmplStd/test/std/number.ci:57: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af28>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	cmplStd/test/std/number.ci:58: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b140>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(29)
.usages:
	cmplStd/test/std/number.ci:59: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b358>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(30)
.usages:
	cmplStd/test/std/number.ci:60: referenced as `lob`
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000748>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00b6a8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00b9f8>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:228: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:227: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:226: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:225: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:224: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:223: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:222: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:221: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:220: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:219: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:218: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:217: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:216: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:215: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:214: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:54: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:44: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:34: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:24: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:14: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:4: referenced as `uint64`
	cmplStd/test/lang/reflect.ci:13: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:85: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:65: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:45: referenced as `uint64`
	cmplStd/test/std/number.ci:66: referenced as `uint64`
	cmplStd/test/std/number.ci:65: referenced as `uint64`
	cmplStd/lib/string.ci:258: referenced as `uint64`
	cmplStd/lib/string.ci:254: referenced as `uint64`
	cmplStd/lib/string.ci:235: referenced as `uint64`
	cmplStd/lib/string.ci:233: referenced as `uint64`
	cmplStd/lib/string.ci:231: referenced as `uint64`
	cmplStd/lib/string.ci:229: referenced as `uint64`
	cmplStd/lib/string.ci:227: referenced as `uint64`
	cmplStd/lib/string.ci:225: referenced as `uint64`
	cmplStd/lib/string.ci:223: referenced as `uint64`
	cmplStd/lib/string.ci:221: referenced as `uint64`
	cmplStd/lib/string.ci:221: referenced as `uint64`
	cmplStd/lib/string.ci:148: referenced as `uint64`
	cmplStd/lib/math.ci:138: referenced as `uint64`
	cmplStd/lib/math.ci:138: referenced as `uint64`
	cmplStd/lib/math.ci:120: referenced as `uint64`
	cmplStd/lib/math.ci:120: referenced as `uint64`
	cmplStd/lib/math.ci:102: referenced as `uint64`
	cmplStd/lib/math.ci:66: referenced as `uint64`
	cmplStd/stdlib.ci:34: referenced as `uint64`
	cmplStd/stdlib.ci:22: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b6a8>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(31)
.usages:
	cmplStd/test/std/number.ci:65: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b9f8>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(32)
.usages:
	cmplStd/test/std/number.ci:66: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00bc10>, cast: static const inline)
.field cos: function (size: 0, offs: <@00be28>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c040>, cast: static const inline)
.field log: function (size: 0, offs: <@00c258>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c470>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c728>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c940>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00cbf8>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `float32`
	cmplStd/test/std/test.math.ci:95: referenced as `float32`
	cmplStd/test/std/test.math.ci:94: referenced as `float32`
	cmplStd/test/std/test.math.ci:93: referenced as `float32`
	cmplStd/test/std/test.math.ci:91: referenced as `float32`
	cmplStd/test/std/test.math.ci:90: referenced as `float32`
	cmplStd/test/std/test.math.ci:89: referenced as `float32`
	cmplStd/test/std/test.math.ci:88: referenced as `float32`
	cmplStd/test/std/test.math.ci:86: referenced as `float32`
	cmplStd/test/std/test.math.ci:85: referenced as `float32`
	cmplStd/test/std/test.math.ci:84: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:246: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:245: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:244: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:243: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:242: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:240: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:239: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:238: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:237: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:5: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:4: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:3: referenced as `float32`
	cmplStd/test/lang/reflect.ci:14: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:86: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:66: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:7: referenced as `float32`
	cmplStd/test/std/number.ci:6: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:13: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:12: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:11: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:10: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:9: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:6: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/lib/string.ci:263: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:137: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:132: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:252: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:183: referenced as `float32`
	cmplStd/lib/math.ci:179: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:174: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:147: referenced as `float32`
	cmplStd/lib/math.ci:141: referenced as `float32`
	cmplStd/lib/math.ci:141: referenced as `float32`
	cmplStd/lib/math.ci:123: referenced as `float32`
	cmplStd/lib/math.ci:123: referenced as `float32`
	cmplStd/lib/math.ci:105: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:71: referenced as `float32`
	cmplStd/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc10>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	cmplStd/test/std/number.ci:46: referenced as `sin`
	cmplStd/test/lang/emit.ci:16: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be28>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	cmplStd/test/std/number.ci:47: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c040>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	cmplStd/test/std/number.ci:48: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c258>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(36)
.usages:
	cmplStd/test/std/number.ci:49: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c470>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(37)
.usages:
	cmplStd/test/std/number.ci:50: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c728>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(38)
.usages:
	cmplStd/test/std/number.ci:51: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c940>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(39)
.usages:
	cmplStd/test/std/number.ci:52: referenced as `sqrt`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cbf8>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(40)
.usages:
	cmplStd/test/std/number.ci:53: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000898>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00ce08>, cast: static const inline)
.field cos: function (size: 0, offs: <@00d018>, cast: static const inline)
.field tan: function (size: 0, offs: <@00d228>, cast: static const inline)
.field log: function (size: 0, offs: <@00d438>, cast: static const inline)
.field exp: function (size: 0, offs: <@00d648>, cast: static const inline)
.field pow: function (size: 0, offs: <@00d8f8>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00db08>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00ddb8>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `float64`
	cmplStd/test/std/test.math.ci:81: referenced as `float64`
	cmplStd/test/std/test.math.ci:80: referenced as `float64`
	cmplStd/test/std/test.math.ci:79: referenced as `float64`
	cmplStd/test/std/test.math.ci:77: referenced as `float64`
	cmplStd/test/std/test.math.ci:76: referenced as `float64`
	cmplStd/test/std/test.math.ci:75: referenced as `float64`
	cmplStd/test/std/test.math.ci:74: referenced as `float64`
	cmplStd/test/std/test.math.ci:72: referenced as `float64`
	cmplStd/test/std/test.math.ci:71: referenced as `float64`
	cmplStd/test/std/test.math.ci:70: referenced as `float64`
	cmplStd/test/std/test.math.ci:64: referenced as `float64`
	cmplStd/test/std/test.math.ci:63: referenced as `float64`
	cmplStd/test/std/test.math.ci:61: referenced as `float64`
	cmplStd/test/std/test.math.ci:60: referenced as `float64`
	cmplStd/test/std/test.math.ci:59: referenced as `float64`
	cmplStd/test/std/test.math.ci:58: referenced as `float64`
	cmplStd/test/std/test.math.ci:57: referenced as `float64`
	cmplStd/test/std/test.math.ci:55: referenced as `float64`
	cmplStd/test/std/test.math.ci:54: referenced as `float64`
	cmplStd/test/std/test.math.ci:53: referenced as `float64`
	cmplStd/test/std/test.math.ci:52: referenced as `float64`
	cmplStd/test/std/test.math.ci:51: referenced as `float64`
	cmplStd/test/std/test.math.ci:50: referenced as `float64`
	cmplStd/test/std/test.math.ci:49: referenced as `float64`
	cmplStd/test/std/test.math.ci:48: referenced as `float64`
	cmplStd/test/std/test.math.ci:46: referenced as `float64`
	cmplStd/test/std/test.math.ci:45: referenced as `float64`
	cmplStd/test/std/test.math.ci:44: referenced as `float64`
	cmplStd/test/std/test.math.ci:43: referenced as `float64`
	cmplStd/test/std/test.math.ci:41: referenced as `float64`
	cmplStd/test/std/test.math.ci:40: referenced as `float64`
	cmplStd/test/std/test.math.ci:39: referenced as `float64`
	cmplStd/test/std/test.math.ci:38: referenced as `float64`
	cmplStd/test/std/test.math.ci:36: referenced as `float64`
	cmplStd/test/std/test.math.ci:35: referenced as `float64`
	cmplStd/test/std/test.math.ci:33: referenced as `float64`
	cmplStd/test/std/test.math.ci:32: referenced as `float64`
	cmplStd/test/std/test.math.ci:30: referenced as `float64`
	cmplStd/test/std/test.math.ci:29: referenced as `float64`
	cmplStd/test/std/test.math.ci:27: referenced as `float64`
	cmplStd/test/std/test.math.ci:26: referenced as `float64`
	cmplStd/test/std/test.math.ci:25: referenced as `float64`
	cmplStd/test/std/test.math.ci:24: referenced as `float64`
	cmplStd/test/std/test.math.ci:22: referenced as `float64`
	cmplStd/test/std/test.math.ci:21: referenced as `float64`
	cmplStd/test/std/test.math.ci:20: referenced as `float64`
	cmplStd/test/std/test.math.ci:19: referenced as `float64`
	cmplStd/test/std/test.math.ci:18: referenced as `float64`
	cmplStd/test/std/test.math.ci:17: referenced as `float64`
	cmplStd/test/std/test.math.ci:15: referenced as `float64`
	cmplStd/test/std/test.math.ci:14: referenced as `float64`
	cmplStd/test/std/test.math.ci:13: referenced as `float64`
	cmplStd/test/std/test.math.ci:12: referenced as `float64`
	cmplStd/test/std/test.math.ci:11: referenced as `float64`
	cmplStd/test/std/test.math.ci:10: referenced as `float64`
	cmplStd/test/std/test.math.ci:8: referenced as `float64`
	cmplStd/test/std/test.math.ci:7: referenced as `float64`
	cmplStd/test/std/test.math.ci:6: referenced as `float64`
	cmplStd/test/std/test.math.ci:5: referenced as `float64`
	cmplStd/test/std/test.math.ci:4: referenced as `float64`
	cmplStd/test/std/test.math.ci:3: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:269: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:268: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:267: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:266: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:265: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:263: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:262: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:261: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:260: referenced as `float64`
	cmplStd/test/lang/reflect.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:14: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:11: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:10: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:87: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:67: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:47: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:4: referenced as `float64`
	cmplStd/test/std/number.ci:3: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:16: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:15: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/lib/string.ci:263: referenced as `float64`
	cmplStd/lib/string.ci:257: referenced as `float64`
	cmplStd/lib/string.ci:253: referenced as `float64`
	cmplStd/lib/string.ci:238: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:146: referenced as `float64`
	cmplStd/lib/math/Complex.ci:142: referenced as `float64`
	cmplStd/lib/math/Complex.ci:141: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:137: referenced as `float64`
	cmplStd/lib/math/Complex.ci:136: referenced as `float64`
	cmplStd/lib/math/Complex.ci:132: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:118: referenced as `float64`
	cmplStd/lib/math/Complex.ci:114: referenced as `float64`
	cmplStd/lib/math/Complex.ci:112: referenced as `float64`
	cmplStd/lib/math/Complex.ci:109: referenced as `float64`
	cmplStd/lib/math/Complex.ci:107: referenced as `float64`
	cmplStd/lib/math/Complex.ci:99: referenced as `float64`
	cmplStd/lib/math/Complex.ci:98: referenced as `float64`
	cmplStd/lib/math/Complex.ci:92: referenced as `float64`
	cmplStd/lib/math/Complex.ci:91: referenced as `float64`
	cmplStd/lib/math/Complex.ci:83: referenced as `float64`
	cmplStd/lib/math/Complex.ci:81: referenced as `float64`
	cmplStd/lib/math/Complex.ci:73: referenced as `float64`
	cmplStd/lib/math/Complex.ci:71: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:64: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:24: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math.ci:512: referenced as `float64`
	cmplStd/lib/math.ci:512: referenced as `float64`
	cmplStd/lib/math.ci:509: referenced as `float64`
	cmplStd/lib/math.ci:509: referenced as `float64`
	cmplStd/lib/math.ci:485: referenced as `float64`
	cmplStd/lib/math.ci:472: referenced as `float64`
	cmplStd/lib/math.ci:469: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:467: referenced as `float64`
	cmplStd/lib/math.ci:450: referenced as `float64`
	cmplStd/lib/math.ci:450: referenced as `float64`
	cmplStd/lib/math.ci:442: referenced as `float64`
	cmplStd/lib/math.ci:442: referenced as `float64`
	cmplStd/lib/math.ci:440: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:423: referenced as `float64`
	cmplStd/lib/math.ci:420: referenced as `float64`
	cmplStd/lib/math.ci:420: referenced as `float64`
	cmplStd/lib/math.ci:418: referenced as `float64`
	cmplStd/lib/math.ci:415: referenced as `float64`
	cmplStd/lib/math.ci:398: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:396: referenced as `float64`
	cmplStd/lib/math.ci:380: referenced as `float64`
	cmplStd/lib/math.ci:379: referenced as `float64`
	cmplStd/lib/math.ci:362: referenced as `float64`
	cmplStd/lib/math.ci:361: referenced as `float64`
	cmplStd/lib/math.ci:340: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:336: referenced as `float64`
	cmplStd/lib/math.ci:333: referenced as `float64`
	cmplStd/lib/math.ci:328: referenced as `float64`
	cmplStd/lib/math.ci:327: referenced as `float64`
	cmplStd/lib/math.ci:326: referenced as `float64`
	cmplStd/lib/math.ci:309: referenced as `float64`
	cmplStd/lib/math.ci:305: referenced as `float64`
	cmplStd/lib/math.ci:302: referenced as `float64`
	cmplStd/lib/math.ci:296: referenced as `float64`
	cmplStd/lib/math.ci:283: referenced as `float64`
	cmplStd/lib/math.ci:282: referenced as `float64`
	cmplStd/lib/math.ci:282: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:267: referenced as `float64`
	cmplStd/lib/math.ci:244: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:240: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:237: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:234: referenced as `float64`
	cmplStd/lib/math.ci:231: referenced as `float64`
	cmplStd/lib/math.ci:231: referenced as `float64`
	cmplStd/lib/math.ci:226: referenced as `float64`
	cmplStd/lib/math.ci:226: referenced as `float64`
	cmplStd/lib/math.ci:218: referenced as `float64`
	cmplStd/lib/math.ci:217: referenced as `float64`
	cmplStd/lib/math.ci:217: referenced as `float64`
	cmplStd/lib/math.ci:207: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:203: referenced as `float64`
	cmplStd/lib/math.ci:193: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:186: referenced as `float64`
	cmplStd/lib/math.ci:180: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:177: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:158: referenced as `float64`
	cmplStd/lib/math.ci:144: referenced as `float64`
	cmplStd/lib/math.ci:144: referenced as `float64`
	cmplStd/lib/math.ci:126: referenced as `float64`
	cmplStd/lib/math.ci:126: referenced as `float64`
	cmplStd/lib/math.ci:108: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:74: referenced as `float64`
	cmplStd/lib/math.ci:57: referenced as `float64`
	cmplStd/lib/math.ci:54: referenced as `float64`
	cmplStd/lib/math.ci:48: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:32: referenced as `float64`
	cmplStd/lib/math.ci:25: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:5: referenced as `float64`
	cmplStd/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ce08>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	cmplStd/test/std/number.ci:37: referenced as `sin`
	cmplStd/lib/math/Complex.ci:187: referenced as `sin`
	cmplStd/lib/math/Complex.ci:151: referenced as `sin`
	cmplStd/lib/math/Complex.ci:149: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:129: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d018>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	cmplStd/test/std/number.ci:38: referenced as `cos`
	cmplStd/lib/math/Complex.ci:187: referenced as `cos`
	cmplStd/lib/math/Complex.ci:151: referenced as `cos`
	cmplStd/lib/math/Complex.ci:149: referenced as `cos`
	cmplStd/lib/math/Complex.ci:141: referenced as `cos`
	cmplStd/lib/math/Complex.ci:129: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d228>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	cmplStd/test/std/number.ci:39: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d438>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(44)
.usages:
	cmplStd/test/std/number.ci:40: referenced as `log`
	cmplStd/lib/math/Complex.ci:138: referenced as `log`
	cmplStd/lib/math/Complex.ci:132: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d648>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(45)
.usages:
	cmplStd/test/std/number.ci:41: referenced as `exp`
	cmplStd/lib/math/Complex.ci:139: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math.ci:442: referenced as `exp`
	cmplStd/lib/math.ci:442: referenced as `exp`
	cmplStd/lib/math.ci:440: referenced as `exp`
	cmplStd/lib/math.ci:420: referenced as `exp`
	cmplStd/lib/math.ci:420: referenced as `exp`
	cmplStd/lib/math.ci:415: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d8f8>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(46)
.usages:
	cmplStd/test/std/number.ci:42: referenced as `pow`
	cmplStd/lib/string.ci:257: referenced as `pow`
	cmplStd/lib/math/Complex.ci:139: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00db08>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(47)
.usages:
	cmplStd/test/std/number.ci:43: referenced as `sqrt`
	cmplStd/lib/math/Complex.ci:112: referenced as `sqrt`
	cmplStd/lib/math.ci:467: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ddb8>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(48)
.usages:
	cmplStd/test/std/number.ci:44: referenced as `atan2`
	cmplStd/lib/math/Complex.ci:114: referenced as `atan2`
	cmplStd/lib/math.ci:472: referenced as `atan2`
	cmplStd/lib/math.ci:469: referenced as `atan2`
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000940>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@008918>, cast: static const inline)
.field fill: function (size: 0, offs: <@008c78>, cast: static const inline)
.field copy: function (size: 0, offs: <@008fd8>, cast: static const inline)
.field move: function (size: 0, offs: <@009330>, cast: static const inline)
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:283: referenced as `pointer`
	cmplStd/test/lang/reflect.ci:16: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:108: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:90: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:70: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:52: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:51: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:49: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:48: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:47: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:46: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:45: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:44: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:43: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:42: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:41: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:40: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:39: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:38: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:37: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:36: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:35: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:30: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:17: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:9: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:43: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:38: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:24: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:20: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:14: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:11: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:14: referenced as `pointer`
	cmplStd/test/std/memory.ci:13: referenced as `pointer`
	cmplStd/test/std/memory.ci:10: referenced as `pointer`
	cmplStd/test/std/memory.ci:9: referenced as `pointer`
	cmplStd/test/std/memory.ci:8: referenced as `pointer`
	cmplStd/test/std/memory.ci:7: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:4: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/emit.ci:29: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008918>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(12)
.usages:
	cmplStd/test/std/memory.ci:5: referenced as `alloc`
	cmplStd/test/std/memory.ci:4: referenced as `alloc`
	cmplStd/test/std/memory.ci:3: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008c78>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: uint8 (size: 4, offs: <+8>, cast: variable(u32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(13)
.usages:
	cmplStd/test/std/memory.ci:30: referenced as `fill`
	cmplStd/test/std/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008fd8>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(14)
.usages:
	cmplStd/test/std/memory.ci:14: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009330>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(15)
.usages:
	cmplStd/test/std/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@0009e8>
.name: 'variant'
.field as: function (size: 0, offs: <@006198>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:17: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:105: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:91: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:72: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:70: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:69: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:68: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:67: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:66: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:65: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:64: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:63: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:62: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:61: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:60: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:59: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:58: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:57: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:56: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:55: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:51: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:31: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:24: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:18: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:10: referenced as `variant`
	cmplStd/lib/debug.ci:65: referenced as `variant`
	cmplStd/lib/debug.ci:56: referenced as `variant`
	cmplStd/lib/debug.ci:53: referenced as `variant`
	cmplStd/lib/debug.ci:50: referenced as `variant`
	cmplStd/lib/debug.ci:41: referenced as `variant`
	cmplStd/lib/debug.ci:34: referenced as `variant`
	cmplStd/lib/debug.ci:29: referenced as `variant`
	cmplStd/lib/debug.ci:24: referenced as `variant`
	cmplStd/lib/debug.ci:19: referenced as `variant`
	cmplStd/lib/debug.ci:14: referenced as `variant`
	cmplStd/lib/debug.ci:9: referenced as `variant`
	cmplStd/lib/debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006198>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a90>
.name: 'function'
.usages:
	cmplStd/test/lang/reflect.ci:19: referenced as `function`
	cmplStd/test/lang/init.reference.ci:89: referenced as `function`
	cmplStd/test/lang/init.reference.ci:69: referenced as `function`
	cmplStd/test/lang/init.reference.ci:49: referenced as `function`
	cmplStd/test/lang/init.reference.ci:20: referenced as `function`
	cmplStd/stdlib.ci:39: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000b40>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.usages:
	cmplStd/test/lang/recUnion.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:20: referenced as `object`
	cmplStd/test/lang/init.variable.ci:41: referenced as `object`
	cmplStd/test/lang/init.variable.ci:13: referenced as `object`
	cmplStd/test/lang/init.reference.ci:92: referenced as `object`
	cmplStd/test/lang/init.reference.ci:72: referenced as `object`
	cmplStd/test/lang/init.reference.ci:52: referenced as `object`
	cmplStd/test/lang/init.reference.ci:21: referenced as `object`
	internal usages: 2
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	cmplStd/test/lang/stmt.if.ci:73: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `null`
	cmplStd/test/lang/useOperator.ci:283: referenced as `null`
	cmplStd/test/lang/init.method.ci:92: referenced as `null`
	cmplStd/test/lang/init.method.ci:86: referenced as `null`
	cmplStd/test/lang/init.reference.ci:21: referenced as `null`
	cmplStd/test/lang/init.reference.ci:20: referenced as `null`
	cmplStd/test/lang/init.reference.ci:19: referenced as `null`
	cmplStd/test/lang/init.reference.ci:18: referenced as `null`
	cmplStd/test/lang/init.reference.ci:17: referenced as `null`
	cmplStd/test/lang/init.reference.ci:16: referenced as `null`
	cmplStd/test/lang/init.reference.ci:3: referenced as `null`
	cmplStd/test/std/tryExec.ci:53: referenced as `null`
	cmplStd/test/std/tryExec.ci:52: referenced as `null`
	cmplStd/test/std/tryExec.ci:51: referenced as `null`
	cmplStd/test/std/tryExec.ci:50: referenced as `null`
	cmplStd/test/std/tryExec.ci:49: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:47: referenced as `null`
	cmplStd/test/std/tryExec.ci:39: referenced as `null`
	cmplStd/test/std/memory.ci:4: referenced as `null`
	cmplStd/lib/string.ci:5: referenced as `null`
	cmplStd/lib/debug.ci:74: referenced as `null`
	cmplStd/lib/debug.ci:56: referenced as `null`
	cmplStd/lib/debug.ci:38: referenced as `null`
	cmplStd/lib/debug.ci:36: referenced as `null`
	cmplStd/lib/debug.ci:31: referenced as `null`
	cmplStd/lib/debug.ci:26: referenced as `null`
	cmplStd/lib/debug.ci:21: referenced as `null`
	cmplStd/lib/debug.ci:16: referenced as `null`
	cmplStd/lib/debug.ci:11: referenced as `null`
	cmplStd/lib/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000de0>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000e88>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001278>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001320>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0015c0>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001ba8>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001f70>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@002168>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@002350>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002538>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002720>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002908>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002c30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@0030b8>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003520>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@003988>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f30>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044d8>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004940>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004da8>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005210>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005678>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005860>, cast: static const typename(void))
.field swz: typename (size: 0, offs: <@005a48>, cast: static const typename(void))
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:29: referenced as `emit`
	cmplStd/test/lang/emit.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:19: referenced as `emit`
	cmplStd/test/lang/emit.ci:16: referenced as `emit`
	cmplStd/test/lang/emit.ci:13: referenced as `emit`
	cmplStd/test/lang/emit.ci:10: referenced as `emit`
	cmplStd/test/lang/emit.ci:4: referenced as `emit`
	cmplStd/test/lang/emit.ci:3: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:76: referenced as `emit`
	cmplStd/lib/math/Complex.ci:69: referenced as `emit`
	cmplStd/lib/math/Complex.ci:62: referenced as `emit`
	cmplStd/lib/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001278>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:112: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:116: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001320>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0015c0>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `load`
	cmplStd/test/lang/emit.ci:4: referenced as `load`
	cmplStd/test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `z32`
	cmplStd/test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	cmplStd/test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001ba8>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f70>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002168>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002350>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002538>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002720>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002908>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002c30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0030b8>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `add`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:77: referenced as `add`
	cmplStd/lib/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003520>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:78: referenced as `sub`
	cmplStd/lib/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003988>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:78: referenced as `mul`
	cmplStd/lib/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:78: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f30>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `div`
	cmplStd/test/lang/emit.ci:13: referenced as `div`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	cmplStd/test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044d8>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004940>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004da8>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005210>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005678>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005860>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005a48>
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `swz`
	cmplStd/lib/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `x2`
	cmplStd/lib/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ed8>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007d08>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(10)
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/stdlib.ci:39: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	cmplStd/lib/debug.ci:71: referenced as `abort`
	cmplStd/lib/debug.ci:38: referenced as `abort`
	cmplStd/lib/debug.ci:36: referenced as `abort`
	cmplStd/lib/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	cmplStd/lib/debug.ci:31: referenced as `error`
	cmplStd/lib/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	cmplStd/lib/debug.ci:26: referenced as `warn`
	cmplStd/lib/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	cmplStd/lib/debug.ci:21: referenced as `info`
	cmplStd/lib/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `debug`
	cmplStd/lib/debug.ci:16: referenced as `debug`
	cmplStd/lib/debug.ci:14: referenced as `debug`
	cmplStd/lib/debug.ci:11: referenced as `debug`
	cmplStd/lib/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	cmplStd/lib/debug.ci:6: referenced as `verbose`
	cmplStd/lib/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	cmplStd/lib/debug.ci:26: referenced as `noTrace`
	cmplStd/lib/debug.ci:24: referenced as `noTrace`
	cmplStd/lib/debug.ci:21: referenced as `noTrace`
	cmplStd/lib/debug.ci:19: referenced as `noTrace`
	cmplStd/lib/debug.ci:11: referenced as `noTrace`
	cmplStd/lib/debug.ci:9: referenced as `noTrace`
	cmplStd/lib/debug.ci:6: referenced as `noTrace`
	cmplStd/lib/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	cmplStd/lib/debug.ci:71: referenced as `defTrace`
	cmplStd/lib/debug.ci:38: referenced as `defTrace`
	cmplStd/lib/debug.ci:36: referenced as `defTrace`
	cmplStd/lib/debug.ci:34: referenced as `defTrace`
	cmplStd/lib/debug.ci:31: referenced as `defTrace`
	cmplStd/lib/debug.ci:29: referenced as `defTrace`
	cmplStd/lib/debug.ci:16: referenced as `defTrace`
	cmplStd/lib/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008658>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(11)
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:52: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:51: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:50: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:49: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:48: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:47: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@009360>
.name: 'System'
.field exit: function (size: 0, offs: <@0095f8>, cast: static const inline)
.field srand: function (size: 0, offs: <@009818>, cast: static const inline)
.field rand: function (size: 0, offs: <@009990>, cast: static const inline)
.field time: function (size: 0, offs: <@009b08>, cast: static const inline)
.field clock: function (size: 0, offs: <@009c80>, cast: static const inline)
.field millis: function (size: 0, offs: <@009df8>, cast: static const inline)
.field sleep: function (size: 0, offs: <@00a010>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0095f8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(16)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009818>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(17)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009990>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(18)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009b08>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(19)
.usages:
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009c80>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(20)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009df8>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(21)
.usages:
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a010>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(22)
.usages:
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.file: 'cmplStd/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	cmplStd/test/lang/useOperator.ci:7: referenced as `true`
	cmplStd/lib/string.ci:57: referenced as `true`
	cmplStd/lib/string.ci:42: referenced as `true`
	cmplStd/lib/math.ci:458: referenced as `true`
	cmplStd/lib/math.ci:411: referenced as `true`
	cmplStd/lib/math.ci:372: referenced as `true`
	cmplStd/lib/math.ci:368: referenced as `true`
	cmplStd/lib/math.ci:357: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.file: 'cmplStd/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:8: referenced as `false`
	cmplStd/lib/string.ci:246: referenced as `false`
	cmplStd/lib/string.ci:118: referenced as `false`
	cmplStd/lib/string.ci:54: referenced as `false`
	cmplStd/lib/string.ci:50: referenced as `false`
	cmplStd/lib/string.ci:39: referenced as `false`
	cmplStd/lib/math.ci:456: referenced as `false`
	cmplStd/lib/math.ci:408: referenced as `false`
	cmplStd/lib/math.ci:353: referenced as `false`
	cmplStd/lib/math.ci:352: referenced as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'cmplStd/stdlib.ci:8'
.value: uint8
.usages:
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'cmplStd/stdlib.ci:9'
.value: float32
.usages:
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'cmplStd/stdlib.ci:10'
.value: float64
.usages:
}
signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:13'
.param .result: int8 (size: 1, offs: <+0>, cast: i32)
.param value: uint8 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:16'
.param .result: int16 (size: 2, offs: <+0>, cast: i32)
.param value: uint16 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math.ci:227: referenced as `signed`
}
signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:22'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:25'
.param .result: uint8 (size: 1, offs: <+0>, cast: u32)
.param value: int8 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:28'
.param .result: uint16 (size: 2, offs: <+0>, cast: u32)
.param value: int16 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:31'
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param value: int32 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:34'
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param value: int64 (size: 8, offs: <+8>, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'cmplStd/stdlib.ci:37'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: typename.size(type)
.usages:
	cmplStd/test/lang/reflect.ci:20: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:19: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:18: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:17: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:16: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:15: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:14: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:13: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:12: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:11: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:10: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:9: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:8: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:7: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:6: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:5: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:4: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:3: referenced as `sizeof`
	cmplStd/test/std/memory.ci:30: referenced as `sizeof`
	cmplStd/test/std/memory.ci:29: referenced as `sizeof`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	cmplStd/test/lang/stmt.for.ci:28: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:21: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:14: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:9: referenced as `debug`
	cmplStd/test/std/memory.ci:33: referenced as `debug`
	cmplStd/test/std/memory.ci:32: referenced as `debug`
	cmplStd/test/std/memory.ci:27: referenced as `debug`
	cmplStd/test/std/memory.ci:26: referenced as `debug`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.for.ci:4: referenced as `debug`
	cmplStd/test/lang/init.method.ci:91: referenced as `debug`
	cmplStd/test/lang/init.method.ci:85: referenced as `debug`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/lang/init.method.ci:58: referenced as `trace`
	cmplStd/test/lang/init.method.ci:48: referenced as `trace`
	cmplStd/test/lang/init.method.ci:41: referenced as `trace`
	cmplStd/test/lang/init.method.ci:11: referenced as `trace`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `trace`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.if.ci:78: referenced as `error`
	cmplStd/test/lang/stmt.if.ci:74: referenced as `error`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/std/tryExec.ci:35: referenced as `abort`
	cmplStd/lib/debug.ci:41: referenced as `abort`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	cmplStd/lib/debug.ci:45: referenced as `abort`
	cmplStd/lib/debug.ci:43: referenced as `abort`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	cmplStd/lib/string.ci:166: referenced as `assert`
	cmplStd/lib/string.ci:165: referenced as `assert`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	cmplStd/lib/string.ci:208: referenced as `assert`
	cmplStd/lib/string.ci:201: referenced as `assert`
	cmplStd/lib/string.ci:194: referenced as `assert`
	cmplStd/lib/string.ci:189: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@012770>
.name: 'NotEquals'
.file: 'cmplStd/lib/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field extras: variant[] (size: 8, offs: <+16>, cast: const variable(arr))
.doc: '@public'
.usages:
	cmplStd/lib/debug.ci:66: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'cmplStd/lib/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/debug.ci:67: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'cmplStd/lib/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/debug.ci:68: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.offset: <+16>
.name: 'extras'
.file: 'cmplStd/lib/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	cmplStd/lib/debug.ci:69: referenced as `extras`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 103
.offset: <@05f780>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:61'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	extras: variant[1] := {
		void(extras[0] := (message));
	};
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.extras := (extras));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (103 bytes: <assertEq @05f780> - <assertEq+103 @05f7e7>)
	cmplStd/lib/debug.ci:62: (10 bytes: <assertEq @05f780> - <assertEq+10 @05f78a>): if (returned == expected)
	<assertEq @05f780>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @05f782>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @05f784>    : 57                         ceq.i32
	<assertEq+5 @05f785>    : 06 05 00 00                jz <assertEq+10 @05f78a>
	cmplStd/lib/debug.ci:63: (1 byte: <assertEq+9 @05f789> - <assertEq+10 @05f78a>): return;
	<assertEq+9 @05f789>    : 03                         ret
	cmplStd/lib/debug.ci:65: (13 bytes: <assertEq+10 @05f78a> - <assertEq+23 @05f797>): extras: variant[1] := {...}
	<assertEq+10 @05f78a>   : 09 08 00 00                inc.sp(+8)
	cmplStd/lib/debug.ci:65: (9 bytes: <assertEq+14 @05f78e> - <assertEq+23 @05f797>): extras[0] := (message);
	<assertEq+14 @05f78e>   : 1f 70 2c 01 00             load.ref <@012c70>
	<assertEq+19 @05f793>   : 10 04                      dup.x32 sp(4)
	<assertEq+21 @05f795>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:66: (37 bytes: <assertEq+23 @05f797> - <assertEq+60 @05f7bc>): details: NotEquals := {...}
	<assertEq+23 @05f797>   : 09 18 00 00                inc.sp(+24)
	cmplStd/lib/debug.ci:67: (11 bytes: <assertEq+27 @05f79b> - <assertEq+38 @05f7a6>): details.expected := (expected);
	<assertEq+27 @05f79b>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+32 @05f7a0>   : 0a 30 00 00                load.sp(+48)
	<assertEq+36 @05f7a4>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:68: (11 bytes: <assertEq+38 @05f7a6> - <assertEq+49 @05f7b1>): details.returned := (returned);
	<assertEq+38 @05f7a6>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+43 @05f7ab>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+47 @05f7af>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/debug.ci:69: (11 bytes: <assertEq+49 @05f7b1> - <assertEq+60 @05f7bc>): details.extras := (extras);
	<assertEq+49 @05f7b1>   : 1c 01 00 00 00             load.c32 1
	<assertEq+54 @05f7b6>   : 0a 1c 00 00                load.sp(+28)
	<assertEq+58 @05f7ba>   : 14 06                      set.x64 sp(6)
	cmplStd/lib/debug.ci:71: (38 bytes: <assertEq+60 @05f7bc> - <assertEq+98 @05f7e2>): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+60 @05f7bc>   : 1f 18 f3 00 00             load.ref <@00f318> ;"cmplStd/lib/debug.ci"
	<assertEq+65 @05f7c1>   : 1c 47 00 00 00             load.c32 71
	<assertEq+70 @05f7c6>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+75 @05f7cb>   : 1c 80 00 00 00             load.c32 128
	<assertEq+80 @05f7d0>   : 1f f8 f5 00 00             load.ref <@00f5f8> ;"assertion failed"
	<assertEq+85 @05f7d5>   : 1f 70 27 01 00             load.ref <@012770> ;NotEquals
	<assertEq+90 @05f7da>   : 0a 18 00 00                load.sp(+24)
	<assertEq+94 @05f7de>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+98 @05f7e2>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+102 @05f7e6>  : 03                         ret
.usages:
	cmplStd/lib/debug.ci:74: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:74'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@013a08>
.name: 'Math'
.file: 'cmplStd/lib/math.ci:2'
.field pi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field e: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 0, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 0, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@05f7e8>, cast: static function)
.field floor: function (size: 24, offs: <@05f840>, cast: static function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field absMod: function (size: 27, offs: <@05f858>, cast: static function)
.field absMod: function (size: 27, offs: <@05f878>, cast: static function)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 30, offs: <@05f898>, cast: static function)
.field clamp: function (size: 30, offs: <@05f8b8>, cast: static function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@05f8d8>, cast: static function)
.field max: function (size: 79, offs: <@05f928>, cast: static function)
.field sum: function (size: 40, offs: <@05f978>, cast: static function)
.field mean: function (size: 20, offs: <@05f9a0>, cast: static function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@05f9b8>, cast: static function)
.field cmp: function (size: 57, offs: <@05f9e8>, cast: static function)
.field cmp: function (size: 57, offs: <@05fa28>, cast: static function)
.field sinCos: function (size: 335, offs: <@05fa68>, cast: static function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@05fbb8>, cast: static function)
.field sinh: function (size: 241, offs: <@05fd38>, cast: static function)
.field cosh: function (size: 75, offs: <@05fe30>, cast: static function)
.field asin: function (size: 173, offs: <@05fe80>, cast: static function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `Math`
	cmplStd/test/std/test.math.ci:95: referenced as `Math`
	cmplStd/test/std/test.math.ci:94: referenced as `Math`
	cmplStd/test/std/test.math.ci:93: referenced as `Math`
	cmplStd/test/std/test.math.ci:91: referenced as `Math`
	cmplStd/test/std/test.math.ci:90: referenced as `Math`
	cmplStd/test/std/test.math.ci:89: referenced as `Math`
	cmplStd/test/std/test.math.ci:88: referenced as `Math`
	cmplStd/test/std/test.math.ci:86: referenced as `Math`
	cmplStd/test/std/test.math.ci:85: referenced as `Math`
	cmplStd/test/std/test.math.ci:84: referenced as `Math`
	cmplStd/test/std/test.math.ci:82: referenced as `Math`
	cmplStd/test/std/test.math.ci:81: referenced as `Math`
	cmplStd/test/std/test.math.ci:80: referenced as `Math`
	cmplStd/test/std/test.math.ci:79: referenced as `Math`
	cmplStd/test/std/test.math.ci:77: referenced as `Math`
	cmplStd/test/std/test.math.ci:76: referenced as `Math`
	cmplStd/test/std/test.math.ci:75: referenced as `Math`
	cmplStd/test/std/test.math.ci:74: referenced as `Math`
	cmplStd/test/std/test.math.ci:72: referenced as `Math`
	cmplStd/test/std/test.math.ci:71: referenced as `Math`
	cmplStd/test/std/test.math.ci:70: referenced as `Math`
	cmplStd/test/std/test.math.ci:68: referenced as `Math`
	cmplStd/test/std/test.math.ci:67: referenced as `Math`
	cmplStd/test/std/test.math.ci:64: referenced as `Math`
	cmplStd/test/std/test.math.ci:63: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:55: referenced as `Math`
	cmplStd/test/std/test.math.ci:54: referenced as `Math`
	cmplStd/test/std/test.math.ci:53: referenced as `Math`
	cmplStd/test/std/test.math.ci:52: referenced as `Math`
	cmplStd/test/std/test.math.ci:51: referenced as `Math`
	cmplStd/test/std/test.math.ci:50: referenced as `Math`
	cmplStd/test/std/test.math.ci:49: referenced as `Math`
	cmplStd/test/std/test.math.ci:46: referenced as `Math`
	cmplStd/test/std/test.math.ci:45: referenced as `Math`
	cmplStd/test/std/test.math.ci:44: referenced as `Math`
	cmplStd/test/std/test.math.ci:43: referenced as `Math`
	cmplStd/test/std/test.math.ci:41: referenced as `Math`
	cmplStd/test/std/test.math.ci:40: referenced as `Math`
	cmplStd/test/std/test.math.ci:39: referenced as `Math`
	cmplStd/test/std/test.math.ci:38: referenced as `Math`
	cmplStd/test/std/test.math.ci:36: referenced as `Math`
	cmplStd/test/std/test.math.ci:35: referenced as `Math`
	cmplStd/test/std/test.math.ci:33: referenced as `Math`
	cmplStd/test/std/test.math.ci:32: referenced as `Math`
	cmplStd/test/std/test.math.ci:30: referenced as `Math`
	cmplStd/test/std/test.math.ci:29: referenced as `Math`
	cmplStd/test/std/test.math.ci:27: referenced as `Math`
	cmplStd/test/std/test.math.ci:26: referenced as `Math`
	cmplStd/test/std/test.math.ci:25: referenced as `Math`
	cmplStd/test/std/test.math.ci:24: referenced as `Math`
	cmplStd/test/std/test.math.ci:22: referenced as `Math`
	cmplStd/test/std/test.math.ci:21: referenced as `Math`
	cmplStd/test/std/test.math.ci:20: referenced as `Math`
	cmplStd/test/std/test.math.ci:19: referenced as `Math`
	cmplStd/test/std/test.math.ci:18: referenced as `Math`
	cmplStd/test/std/test.math.ci:17: referenced as `Math`
	cmplStd/test/std/test.math.ci:15: referenced as `Math`
	cmplStd/test/std/test.math.ci:14: referenced as `Math`
	cmplStd/test/std/test.math.ci:13: referenced as `Math`
	cmplStd/test/std/test.math.ci:12: referenced as `Math`
	cmplStd/test/std/test.math.ci:11: referenced as `Math`
	cmplStd/test/std/test.math.ci:10: referenced as `Math`
	cmplStd/test/std/test.math.ci:8: referenced as `Math`
	cmplStd/test/std/test.math.ci:7: referenced as `Math`
	cmplStd/test/std/test.math.ci:6: referenced as `Math`
	cmplStd/test/std/test.math.ci:5: referenced as `Math`
	cmplStd/test/std/test.math.ci:4: referenced as `Math`
	cmplStd/test/std/test.math.ci:3: referenced as `Math`
	cmplStd/lib/string.ci:253: referenced as `Math`
	cmplStd/lib/string.ci:253: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'pi'
.file: 'cmplStd/lib/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `pi`
	cmplStd/test/std/test.math.ci:60: referenced as `pi`
	cmplStd/test/std/test.math.ci:59: referenced as `pi`
	cmplStd/test/std/test.math.ci:58: referenced as `pi`
	cmplStd/test/std/test.math.ci:57: referenced as `pi`
	cmplStd/lib/math.ci:512: referenced as `pi`
	cmplStd/lib/math.ci:509: referenced as `pi`
	cmplStd/lib/math.ci:485: referenced as `pi`
	cmplStd/lib/math.ci:469: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'e'
.file: 'cmplStd/lib/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln2'
.file: 'cmplStd/lib/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log2E'
.file: 'cmplStd/lib/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln10'
.file: 'cmplStd/lib/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log10E'
.file: 'cmplStd/lib/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'phi'
.file: 'cmplStd/lib/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrt2'
.file: 'cmplStd/lib/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtE'
.file: 'cmplStd/lib/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPi'
.file: 'cmplStd/lib/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'nan'
.file: 'cmplStd/lib/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/math.ci:464: referenced as `nan`
	cmplStd/lib/math.ci:385: referenced as `nan`
	cmplStd/lib/math.ci:205: referenced as `nan`
	cmplStd/lib/math.ci:191: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'inf'
.file: 'cmplStd/lib/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 86
.offset: <@05f7e8>
.name: 'modf'
.file: 'cmplStd/lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <modf @05f7e8> - <modf+86 @05f83e>)
	cmplStd/lib/math.ci:23: (63 bytes: <modf @05f7e8> - <modf+63 @05f827>): if (x < (1))
	<modf @05f7e8>      : 11 02                      dup.x64 sp(2)
	<modf+2 @05f7ea>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @05f7f3>   : 88                         clt.f64
	<modf+12 @05f7f4>   : 06 33 00 00                jz <modf+63 @05f827>
	cmplStd/lib/math.ci:24: (39 bytes: <modf+16 @05f7f8> - <modf+55 @05f81f>): if (x < (0))
	<modf+16 @05f7f8>   : 11 02                      dup.x64 sp(2)
	<modf+18 @05f7fa>   : 1a                         load.z64
	<modf+19 @05f7fb>   : 88                         clt.f64
	<modf+20 @05f7fc>   : 06 23 00 00                jz <modf+55 @05f81f>
	cmplStd/lib/math.ci:25: (17 bytes: <modf+24 @05f800> - <modf+41 @05f811>): result: float64 := -modf(-x, &intPart)
	<modf+24 @05f800>   : 1a                         load.z64
	<modf+25 @05f801>   : 11 04                      dup.x64 sp(4)
	<modf+27 @05f803>   : 80                         neg.f64
	<modf+28 @05f804>   : 10 05                      dup.x32 sp(5)
	<modf+30 @05f806>   : 1f e8 f7 05 00             load.ref <@05f7e8> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @05f80b>   : 02                         call
	<modf+36 @05f80c>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @05f810>   : 80                         neg.f64
	cmplStd/lib/math.ci:26: (7 bytes: <modf+41 @05f811> - <modf+48 @05f818>): intPart := -intPart;
	<modf+41 @05f811>   : 10 03                      dup.x32 sp(3)
	<modf+43 @05f813>   : 29                         load.i64
	<modf+44 @05f814>   : 80                         neg.f64
	<modf+45 @05f815>   : 10 05                      dup.x32 sp(5)
	<modf+47 @05f817>   : 2e                         store.i64
	cmplStd/lib/math.ci:27: (3 bytes: <modf+48 @05f818> - <modf+51 @05f81b>): return .result := result;
	<modf+48 @05f818>   : 14 06                      set.x64 sp(6)
	<modf+50 @05f81a>   : 03                         ret
	<modf+51 @05f81b>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:29: (4 bytes: <modf+55 @05f81f> - <modf+59 @05f823>): intPart := (0);
	<modf+55 @05f81f>   : 1a                         load.z64
	<modf+56 @05f820>   : 10 03                      dup.x32 sp(3)
	<modf+58 @05f822>   : 2e                         store.i64
	cmplStd/lib/math.ci:30: (4 bytes: <modf+59 @05f823> - <modf+63 @05f827>): return .result := x;
	<modf+59 @05f823>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @05f826>   : 03                         ret
	cmplStd/lib/math.ci:32: (12 bytes: <modf+63 @05f827> - <modf+75 @05f833>): result: float64 := x % (1)
	<modf+63 @05f827>   : 11 02                      dup.x64 sp(2)
	<modf+65 @05f829>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @05f832>   : 85                         mod.f64
	cmplStd/lib/math.ci:33: (8 bytes: <modf+75 @05f833> - <modf+83 @05f83b>): intPart := x - result;
	<modf+75 @05f833>   : 11 04                      dup.x64 sp(4)
	<modf+77 @05f835>   : 11 02                      dup.x64 sp(2)
	<modf+79 @05f837>   : 82                         sub.f64
	<modf+80 @05f838>   : 10 05                      dup.x32 sp(5)
	<modf+82 @05f83a>   : 2e                         store.i64
	cmplStd/lib/math.ci:34: (3 bytes: <modf+83 @05f83b> - <modf+86 @05f83e>): return .result := result;
	<modf+83 @05f83b>   : 14 06                      set.x64 sp(6)
	<modf+85 @05f83d>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:253: referenced as `modf`
	cmplStd/lib/math.ci:362: referenced as `modf`
	cmplStd/lib/math.ci:310: referenced as `modf`
	cmplStd/lib/math.ci:306: referenced as `modf`
	cmplStd/lib/math.ci:49: referenced as `modf`
	cmplStd/lib/math.ci:25: referenced as `modf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@05f840>
.name: 'floor'
.file: 'cmplStd/lib/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <floor @05f840> - <floor+24 @05f858>)
	cmplStd/lib/math.ci:48: (1 byte: <floor @05f840> - <floor+1 @05f841>): result: float64
	<floor @05f840>      : 1b                         load.z128
	cmplStd/lib/math.ci:49: (20 bytes: <floor+1 @05f841> - <floor+21 @05f855>): modf(x, &result);
	<floor+1 @05f841>    : 11 05                      dup.x64 sp(5)
	<floor+3 @05f843>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @05f847>    : 1f e8 f7 05 00             load.ref <@05f7e8> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @05f84c>   : 02                         call
	<floor+13 @05f84d>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @05f851>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:50: (3 bytes: <floor+21 @05f855> - <floor+24 @05f858>): return .result := result;
	<floor+21 @05f855>   : 14 05                      set.x64 sp(5)
	<floor+23 @05f857>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:8: referenced as `floor`
	cmplStd/test/std/test.math.ci:7: referenced as `floor`
	cmplStd/test/std/test.math.ci:6: referenced as `floor`
	cmplStd/test/std/test.math.ci:5: referenced as `floor`
	cmplStd/test/std/test.math.ci:4: referenced as `floor`
	cmplStd/test/std/test.math.ci:3: referenced as `floor`
	cmplStd/lib/math.ci:57: referenced as `floor`
	cmplStd/lib/math.ci:54: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'cmplStd/lib/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'cmplStd/lib/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
}
Math.sign(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:63'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: bool(x != 0) ? bool(x < 0) ? int32(-1) : 1 : 0
.usages:
}
Math.sign(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: bool(x != (0)) ? bool(x < (0)) ? int32(-1) : 1 : 0
.usages:
}
Math.sign(x: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:65'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: uint32 (size: 4, offs: <+4>, cast: u32)
.value: bool(x > (0)) ? 1 : 0
.usages:
}
Math.sign(x: uint64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:66'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: uint64 (size: 8, offs: <+8>, cast: u64)
.value: bool(x > (0)) ? 1 : 0
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:71'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:15: referenced as `sign`
	cmplStd/test/std/test.math.ci:14: referenced as `sign`
	cmplStd/test/std/test.math.ci:13: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:74'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:12: referenced as `sign`
	cmplStd/test/std/test.math.ci:11: referenced as `sign`
	cmplStd/test/std/test.math.ci:10: referenced as `sign`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@05f858>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <absMod @05f858> - <absMod+27 @05f873>)
	cmplStd/lib/math.ci:78: (23 bytes: <absMod @05f858> - <absMod+23 @05f86f>): if ((val := val % mod) < (0))
	<absMod @05f858>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @05f85a>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @05f85c>    : 75                         mod.f32
	<absMod+5 @05f85d>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @05f85f>    : 13 04                      set.x32 sp(4)
	<absMod+9 @05f861>    : 19                         load.z32
	<absMod+10 @05f862>   : 78                         clt.f32
	<absMod+11 @05f863>   : 06 0c 00 00                jz <absMod+23 @05f86f>
	cmplStd/lib/math.ci:79: (8 bytes: <absMod+15 @05f867> - <absMod+23 @05f86f>): return .result := val + mod;
	<absMod+15 @05f867>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @05f869>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @05f86b>   : 71                         add.f32
	<absMod+20 @05f86c>   : 13 04                      set.x32 sp(4)
	<absMod+22 @05f86e>   : 03                         ret
	cmplStd/lib/math.ci:81: (4 bytes: <absMod+23 @05f86f> - <absMod+27 @05f873>): return .result := val;
	<absMod+23 @05f86f>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @05f872>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `absMod`
	cmplStd/test/std/test.math.ci:95: referenced as `absMod`
	cmplStd/test/std/test.math.ci:94: referenced as `absMod`
	cmplStd/test/std/test.math.ci:93: referenced as `absMod`
	cmplStd/test/std/test.math.ci:91: referenced as `absMod`
	cmplStd/test/std/test.math.ci:90: referenced as `absMod`
	cmplStd/test/std/test.math.ci:89: referenced as `absMod`
	cmplStd/test/std/test.math.ci:88: referenced as `absMod`
	cmplStd/test/std/test.math.ci:86: referenced as `absMod`
	cmplStd/test/std/test.math.ci:85: referenced as `absMod`
	cmplStd/test/std/test.math.ci:84: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@05f878>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <absMod @05f878> - <absMod+27 @05f893>)
	cmplStd/lib/math.ci:86: (23 bytes: <absMod @05f878> - <absMod+23 @05f88f>): if ((val := val % mod) < (0))
	<absMod @05f878>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @05f87a>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @05f87c>    : 85                         mod.f64
	<absMod+5 @05f87d>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @05f87f>    : 14 07                      set.x64 sp(7)
	<absMod+9 @05f881>    : 1a                         load.z64
	<absMod+10 @05f882>   : 88                         clt.f64
	<absMod+11 @05f883>   : 06 0c 00 00                jz <absMod+23 @05f88f>
	cmplStd/lib/math.ci:87: (8 bytes: <absMod+15 @05f887> - <absMod+23 @05f88f>): return .result := val + mod;
	<absMod+15 @05f887>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @05f889>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @05f88b>   : 81                         add.f64
	<absMod+20 @05f88c>   : 14 07                      set.x64 sp(7)
	<absMod+22 @05f88e>   : 03                         ret
	cmplStd/lib/math.ci:89: (4 bytes: <absMod+23 @05f88f> - <absMod+27 @05f893>): return .result := val;
	<absMod+23 @05f88f>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @05f892>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `absMod`
	cmplStd/test/std/test.math.ci:81: referenced as `absMod`
	cmplStd/test/std/test.math.ci:80: referenced as `absMod`
	cmplStd/test/std/test.math.ci:79: referenced as `absMod`
	cmplStd/test/std/test.math.ci:77: referenced as `absMod`
	cmplStd/test/std/test.math.ci:76: referenced as `absMod`
	cmplStd/test/std/test.math.ci:75: referenced as `absMod`
	cmplStd/test/std/test.math.ci:74: referenced as `absMod`
	cmplStd/test/std/test.math.ci:72: referenced as `absMod`
	cmplStd/test/std/test.math.ci:71: referenced as `absMod`
	cmplStd/test/std/test.math.ci:70: referenced as `absMod`
}
Math.abs(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:93'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'Returns the absolute value of the input'
.value: bool(x < 0) ? int32(-x) : x
.usages:
}
Math.abs(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:96'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param x: int64 (size: 8, offs: <+8>, cast: variable(i64))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? int64(-x) : x
.usages:
}
Math.abs(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:99'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param x: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:102'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param x: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:105'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? float32(-x) : x
.usages:
	cmplStd/test/std/test.math.ci:22: referenced as `abs`
	cmplStd/test/std/test.math.ci:21: referenced as `abs`
	cmplStd/test/std/test.math.ci:20: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:108'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: bool(x < (0)) ? float64(-x) : x
.usages:
	cmplStd/test/std/test.math.ci:19: referenced as `abs`
	cmplStd/test/std/test.math.ci:18: referenced as `abs`
	cmplStd/test/std/test.math.ci:17: referenced as `abs`
	cmplStd/lib/string.ci:253: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math.ci:336: referenced as `abs`
}
Math.min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:111'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:114'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param a: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+16>, cast: variable(i64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:117'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param a: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:120'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
}
Math.min(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:123'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:24: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math.ci:126'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:26: referenced as `min`
}
Math.max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:129'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:132'
.owner: Math
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param a: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param b: int64 (size: 8, offs: <+16>, cast: variable(i64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:135'
.owner: Math
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param a: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param b: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:138'
.owner: Math
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.param b: uint64 (size: 8, offs: <+16>, cast: variable(u64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
}
Math.max(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:141'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:25: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math.ci:144'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/std/test.math.ci:27: referenced as `max`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@05f898>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:147'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <clamp @05f898> - <clamp+30 @05f8b6>)
	cmplStd/lib/math.ci:148: (13 bytes: <clamp @05f898> - <clamp+13 @05f8a5>): if (t < a)
	<clamp @05f898>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @05f89a>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @05f89c>    : 78                         clt.f32
	<clamp+5 @05f89d>    : 06 08 00 00                jz <clamp+13 @05f8a5>
	cmplStd/lib/math.ci:149: (4 bytes: <clamp+9 @05f8a1> - <clamp+13 @05f8a5>): return .result := a;
	<clamp+9 @05f8a1>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @05f8a4>   : 03                         ret
	cmplStd/lib/math.ci:151: (13 bytes: <clamp+13 @05f8a5> - <clamp+26 @05f8b2>): if (t > b)
	<clamp+13 @05f8a5>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @05f8a7>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @05f8a9>   : 79                         cgt.f32
	<clamp+18 @05f8aa>   : 06 08 00 00                jz <clamp+26 @05f8b2>
	cmplStd/lib/math.ci:152: (4 bytes: <clamp+22 @05f8ae> - <clamp+26 @05f8b2>): return .result := b;
	<clamp+22 @05f8ae>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @05f8b1>   : 03                         ret
	cmplStd/lib/math.ci:154: (4 bytes: <clamp+26 @05f8b2> - <clamp+30 @05f8b6>): return .result := t;
	<clamp+26 @05f8b2>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @05f8b5>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:29: referenced as `clamp`
	cmplStd/lib/math.ci:183: referenced as `clamp`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@05f8b8>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:158'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <clamp @05f8b8> - <clamp+30 @05f8d6>)
	cmplStd/lib/math.ci:159: (13 bytes: <clamp @05f8b8> - <clamp+13 @05f8c5>): if (t < a)
	<clamp @05f8b8>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @05f8ba>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @05f8bc>    : 88                         clt.f64
	<clamp+5 @05f8bd>    : 06 08 00 00                jz <clamp+13 @05f8c5>
	cmplStd/lib/math.ci:160: (4 bytes: <clamp+9 @05f8c1> - <clamp+13 @05f8c5>): return .result := a;
	<clamp+9 @05f8c1>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @05f8c4>   : 03                         ret
	cmplStd/lib/math.ci:162: (13 bytes: <clamp+13 @05f8c5> - <clamp+26 @05f8d2>): if (t > b)
	<clamp+13 @05f8c5>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @05f8c7>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @05f8c9>   : 89                         cgt.f64
	<clamp+18 @05f8ca>   : 06 08 00 00                jz <clamp+26 @05f8d2>
	cmplStd/lib/math.ci:163: (4 bytes: <clamp+22 @05f8ce> - <clamp+26 @05f8d2>): return .result := b;
	<clamp+22 @05f8ce>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @05f8d1>   : 03                         ret
	cmplStd/lib/math.ci:165: (4 bytes: <clamp+26 @05f8d2> - <clamp+30 @05f8d6>): return .result := t;
	<clamp+26 @05f8d2>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @05f8d5>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:30: referenced as `clamp`
	cmplStd/lib/math.ci:186: referenced as `clamp`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:174'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:32: referenced as `lerp`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:177'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:33: referenced as `lerp`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:179'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	cmplStd/lib/math.ci:183: referenced as `smooth`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:180'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	cmplStd/lib/math.ci:186: referenced as `smooth`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:183'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	cmplStd/test/std/test.math.ci:35: referenced as `smooth`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:186'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	cmplStd/test/std/test.math.ci:36: referenced as `smooth`
}
Math.min(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@05f8d8>
.name: 'min'
.file: 'cmplStd/lib/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <min @05f8d8> - <min+79 @05f927>)
	cmplStd/lib/math.ci:190: (20 bytes: <min @05f8d8> - <min+20 @05f8ec>): if (data.length == (0))
	<min @05f8d8>      : 10 02                      dup.x32 sp(2)
	<min+2 @05f8da>    : 19                         load.z32
	<min+3 @05f8db>    : 57                         ceq.i32
	<min+4 @05f8dc>    : 06 10 00 00                jz <min+20 @05f8ec>
	cmplStd/lib/math.ci:191: (12 bytes: <min+8 @05f8e0> - <min+20 @05f8ec>): return .result := nan;
	<min+8 @05f8e0>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @05f8e9>   : 14 05                      set.x64 sp(5)
	<min+19 @05f8eb>   : 03                         ret
	cmplStd/lib/math.ci:193: (3 bytes: <min+20 @05f8ec> - <min+23 @05f8ef>): result: float64 := data[0]
	<min+20 @05f8ec>   : 10 01                      dup.x32 sp(1)
	<min+22 @05f8ee>   : 29                         load.i64
	cmplStd/lib/math.ci:194: (53 bytes: <min+23 @05f8ef> - <min+76 @05f924>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+23 @05f8ef>   : 1c 01 00 00 00             load.c32 1
	<min+28 @05f8f4>   : 04 23 00 00                jmp <min+63 @05f917>
	cmplStd/lib/math.ci:195: (27 bytes: <min+32 @05f8f8> - <min+59 @05f913>): if (result > data[i])
	<min+32 @05f8f8>   : 11 01                      dup.x64 sp(1)
	<min+34 @05f8fa>   : 10 06                      dup.x32 sp(6)
	<min+36 @05f8fc>   : 10 03                      dup.x32 sp(3)
	<min+38 @05f8fe>   : 0d 08 00 00                mad.u32 8
	<min+42 @05f902>   : 29                         load.i64
	<min+43 @05f903>   : 89                         cgt.f64
	<min+44 @05f904>   : 06 0f 00 00                jz <min+59 @05f913>
	cmplStd/lib/math.ci:196: (11 bytes: <min+48 @05f908> - <min+59 @05f913>): result := data[i];
	<min+48 @05f908>   : 10 04                      dup.x32 sp(4)
	<min+50 @05f90a>   : 10 01                      dup.x32 sp(1)
	<min+52 @05f90c>   : 0d 08 00 00                mad.u32 8
	<min+56 @05f910>   : 29                         load.i64
	<min+57 @05f911>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:194: (4 bytes: <min+59 @05f913> - <min+63 @05f917>): i := i + 1
	<min+59 @05f913>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:194: (9 bytes: <min+63 @05f917> - <min+72 @05f920>): i < (data.length)
	<min+63 @05f917>   : 10 00                      dup.x32 sp(0)
	<min+65 @05f919>   : 10 06                      dup.x32 sp(6)
	<min+67 @05f91b>   : 58                         clt.i32
	<min+68 @05f91c>   : 05 dc ff ff                jnz <min+32 @05f8f8>
	<min+72 @05f920>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:199: (3 bytes: <min+76 @05f924> - <min+79 @05f927>): return .result := result;
	<min+76 @05f924>   : 14 05                      set.x64 sp(5)
	<min+78 @05f926>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:39: referenced as `min`
	cmplStd/test/std/test.math.ci:38: referenced as `min`
}
Math.max(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@05f928>
.name: 'max'
.file: 'cmplStd/lib/math.ci:203'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <max @05f928> - <max+79 @05f977>)
	cmplStd/lib/math.ci:204: (20 bytes: <max @05f928> - <max+20 @05f93c>): if (data.length == (0))
	<max @05f928>      : 10 02                      dup.x32 sp(2)
	<max+2 @05f92a>    : 19                         load.z32
	<max+3 @05f92b>    : 57                         ceq.i32
	<max+4 @05f92c>    : 06 10 00 00                jz <max+20 @05f93c>
	cmplStd/lib/math.ci:205: (12 bytes: <max+8 @05f930> - <max+20 @05f93c>): return .result := nan;
	<max+8 @05f930>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @05f939>   : 14 05                      set.x64 sp(5)
	<max+19 @05f93b>   : 03                         ret
	cmplStd/lib/math.ci:207: (3 bytes: <max+20 @05f93c> - <max+23 @05f93f>): result: float64 := data[0]
	<max+20 @05f93c>   : 10 01                      dup.x32 sp(1)
	<max+22 @05f93e>   : 29                         load.i64
	cmplStd/lib/math.ci:208: (53 bytes: <max+23 @05f93f> - <max+76 @05f974>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+23 @05f93f>   : 1c 01 00 00 00             load.c32 1
	<max+28 @05f944>   : 04 23 00 00                jmp <max+63 @05f967>
	cmplStd/lib/math.ci:209: (27 bytes: <max+32 @05f948> - <max+59 @05f963>): if (result < data[i])
	<max+32 @05f948>   : 11 01                      dup.x64 sp(1)
	<max+34 @05f94a>   : 10 06                      dup.x32 sp(6)
	<max+36 @05f94c>   : 10 03                      dup.x32 sp(3)
	<max+38 @05f94e>   : 0d 08 00 00                mad.u32 8
	<max+42 @05f952>   : 29                         load.i64
	<max+43 @05f953>   : 88                         clt.f64
	<max+44 @05f954>   : 06 0f 00 00                jz <max+59 @05f963>
	cmplStd/lib/math.ci:210: (11 bytes: <max+48 @05f958> - <max+59 @05f963>): result := data[i];
	<max+48 @05f958>   : 10 04                      dup.x32 sp(4)
	<max+50 @05f95a>   : 10 01                      dup.x32 sp(1)
	<max+52 @05f95c>   : 0d 08 00 00                mad.u32 8
	<max+56 @05f960>   : 29                         load.i64
	<max+57 @05f961>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:208: (4 bytes: <max+59 @05f963> - <max+63 @05f967>): i := i + 1
	<max+59 @05f963>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:208: (9 bytes: <max+63 @05f967> - <max+72 @05f970>): i < (data.length)
	<max+63 @05f967>   : 10 00                      dup.x32 sp(0)
	<max+65 @05f969>   : 10 06                      dup.x32 sp(6)
	<max+67 @05f96b>   : 58                         clt.i32
	<max+68 @05f96c>   : 05 dc ff ff                jnz <max+32 @05f948>
	<max+72 @05f970>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:213: (3 bytes: <max+76 @05f974> - <max+79 @05f977>): return .result := result;
	<max+76 @05f974>   : 14 05                      set.x64 sp(5)
	<max+78 @05f976>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:41: referenced as `max`
	cmplStd/test/std/test.math.ci:40: referenced as `max`
}
Math.sum(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.offset: <@05f978>
.name: 'sum'
.file: 'cmplStd/lib/math.ci:217'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <sum @05f978> - <sum+40 @05f9a0>)
	cmplStd/lib/math.ci:218: (1 byte: <sum @05f978> - <sum+1 @05f979>): result: float64 := 0
	<sum @05f978>      : 1b                         load.z128
	cmplStd/lib/math.ci:219: (36 bytes: <sum+1 @05f979> - <sum+37 @05f99d>): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+1 @05f979>    : 6a                         i64.2i32
	<sum+2 @05f97a>    : 04 16 00 00                jmp <sum+24 @05f990>
	cmplStd/lib/math.ci:220: (14 bytes: <sum+6 @05f97e> - <sum+20 @05f98c>): result := result + data[i];
	<sum+6 @05f97e>    : 11 01                      dup.x64 sp(1)
	<sum+8 @05f980>    : 10 06                      dup.x32 sp(6)
	<sum+10 @05f982>   : 10 03                      dup.x32 sp(3)
	<sum+12 @05f984>   : 0d 08 00 00                mad.u32 8
	<sum+16 @05f988>   : 29                         load.i64
	<sum+17 @05f989>   : 81                         add.f64
	<sum+18 @05f98a>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:219: (4 bytes: <sum+20 @05f98c> - <sum+24 @05f990>): i := i + 1
	<sum+20 @05f98c>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:219: (9 bytes: <sum+24 @05f990> - <sum+33 @05f999>): i < (data.length)
	<sum+24 @05f990>   : 10 00                      dup.x32 sp(0)
	<sum+26 @05f992>   : 10 06                      dup.x32 sp(6)
	<sum+28 @05f994>   : 58                         clt.i32
	<sum+29 @05f995>   : 05 e9 ff ff                jnz <sum+6 @05f97e>
	<sum+33 @05f999>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:222: (3 bytes: <sum+37 @05f99d> - <sum+40 @05f9a0>): return .result := result;
	<sum+37 @05f99d>   : 14 05                      set.x64 sp(5)
	<sum+39 @05f99f>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:46: referenced as `sum`
	cmplStd/test/std/test.math.ci:45: referenced as `sum`
	cmplStd/test/std/test.math.ci:44: referenced as `sum`
	cmplStd/test/std/test.math.ci:43: referenced as `sum`
	cmplStd/lib/math.ci:227: referenced as `sum`
}
Math.mean(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.offset: <@05f9a0>
.name: 'mean'
.file: 'cmplStd/lib/math.ci:226'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
}
.instructions: (20 bytes: <mean @05f9a0> - <mean+20 @05f9b4>)
	cmplStd/lib/math.ci:227: (20 bytes: <mean @05f9a0> - <mean+20 @05f9b4>): return .result := sum(...data) / (signed(data.length));
	<mean @05f9a0>      : 1a                         load.z64
	<mean+1 @05f9a1>    : 11 03                      dup.x64 sp(3)
	<mean+3 @05f9a3>    : 1f 78 f9 05 00             load.ref <@05f978> ;Math.sum(data: float64[]): float64
	<mean+8 @05f9a8>    : 02                         call
	<mean+9 @05f9a9>    : 09 f8 ff ff                inc.sp(-8)
	<mean+13 @05f9ad>   : 10 04                      dup.x32 sp(4)
	<mean+15 @05f9af>   : 5d                         i32.2f64
	<mean+16 @05f9b0>   : 84                         div.f64
	<mean+17 @05f9b1>   : 14 05                      set.x64 sp(5)
	<mean+19 @05f9b3>   : 03                         ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:231'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	cmplStd/test/std/test.math.ci:50: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:234'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	cmplStd/test/std/test.math.ci:51: referenced as `eval`
	cmplStd/lib/math.ci:237: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:237'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	cmplStd/test/std/test.math.ci:52: referenced as `eval`
	cmplStd/lib/math.ci:240: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:240'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	cmplStd/test/std/test.math.ci:53: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.offset: <@05f9b8>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <eval @05f9b8> - <eval+47 @05f9e7>)
	cmplStd/lib/math.ci:244: (1 byte: <eval @05f9b8> - <eval+1 @05f9b9>): result: float64 := 0
	<eval @05f9b8>      : 1a                         load.z64
	cmplStd/lib/math.ci:245: (43 bytes: <eval+1 @05f9b9> - <eval+44 @05f9e4>): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+1 @05f9b9>    : 10 04                      dup.x32 sp(4)
	<eval+3 @05f9bb>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @05f9bf>    : 04 19 00 00                jmp <eval+32 @05f9d8>
	cmplStd/lib/math.ci:246: (17 bytes: <eval+11 @05f9c3> - <eval+28 @05f9d4>): result := result * x + polynomial[i];
	<eval+11 @05f9c3>   : 11 01                      dup.x64 sp(1)
	<eval+13 @05f9c5>   : 11 08                      dup.x64 sp(8)
	<eval+15 @05f9c7>   : 83                         mul.f64
	<eval+16 @05f9c8>   : 10 06                      dup.x32 sp(6)
	<eval+18 @05f9ca>   : 10 03                      dup.x32 sp(3)
	<eval+20 @05f9cc>   : 0d 08 00 00                mad.u32 8
	<eval+24 @05f9d0>   : 29                         load.i64
	<eval+25 @05f9d1>   : 81                         add.f64
	<eval+26 @05f9d2>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:245: (4 bytes: <eval+28 @05f9d4> - <eval+32 @05f9d8>): i := i - 1
	<eval+28 @05f9d4>   : 0c ff ff ff                inc.i32(-1)
	cmplStd/lib/math.ci:245: (8 bytes: <eval+32 @05f9d8> - <eval+40 @05f9e0>): i >= 0
	<eval+32 @05f9d8>   : 10 00                      dup.x32 sp(0)
	<eval+34 @05f9da>   : 19                         load.z32
	<eval+35 @05f9db>   : 58                         clt.i32
	<eval+36 @05f9dc>   : 06 e7 ff ff                jz <eval+11 @05f9c3>
	<eval+40 @05f9e0>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:248: (3 bytes: <eval+44 @05f9e4> - <eval+47 @05f9e7>): return .result := result;
	<eval+44 @05f9e4>   : 14 07                      set.x64 sp(7)
	<eval+46 @05f9e6>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `eval`
	cmplStd/test/std/test.math.ci:54: referenced as `eval`
	cmplStd/test/std/test.math.ci:49: referenced as `eval`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@05f9e8>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:252'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float32(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @05f9e8> - <cmp+57 @05fa21>)
	cmplStd/lib/math.ci:253: (53 bytes: <cmp @05f9e8> - <cmp+53 @05fa1d>): if (a < b)
	<cmp @05f9e8>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @05f9ea>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @05f9ec>    : 78                         clt.f32
	<cmp+5 @05f9ed>    : 06 1c 00 00                jz <cmp+33 @05fa09>
	cmplStd/lib/math.ci:254: (20 bytes: <cmp+9 @05f9f1> - <cmp+29 @05fa05>): if (eps < (b - a))
	<cmp+9 @05f9f1>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @05f9f3>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @05f9f5>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @05f9f7>   : 72                         sub.f32
	<cmp+16 @05f9f8>   : 78                         clt.f32
	<cmp+17 @05f9f9>   : 06 0c 00 00                jz <cmp+29 @05fa05>
	cmplStd/lib/math.ci:255: (8 bytes: <cmp+21 @05f9fd> - <cmp+29 @05fa05>): return .result := -1;
	<cmp+21 @05f9fd>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05fa02>   : 13 05                      set.x32 sp(5)
	<cmp+28 @05fa04>   : 03                         ret
	<cmp+29 @05fa05>   : 04 18 00 00                jmp <cmp+53 @05fa1d>
	cmplStd/lib/math.ci:259: (20 bytes: <cmp+33 @05fa09> - <cmp+53 @05fa1d>): if (eps < (a - b))
	<cmp+33 @05fa09>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @05fa0b>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @05fa0d>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @05fa0f>   : 72                         sub.f32
	<cmp+40 @05fa10>   : 78                         clt.f32
	<cmp+41 @05fa11>   : 06 0c 00 00                jz <cmp+53 @05fa1d>
	cmplStd/lib/math.ci:260: (8 bytes: <cmp+45 @05fa15> - <cmp+53 @05fa1d>): return .result := +1;
	<cmp+45 @05fa15>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05fa1a>   : 13 05                      set.x32 sp(5)
	<cmp+52 @05fa1c>   : 03                         ret
	cmplStd/lib/math.ci:263: (4 bytes: <cmp+53 @05fa1d> - <cmp+57 @05fa21>): return .result := 0;
	<cmp+53 @05fa1d>   : 19                         load.z32
	<cmp+54 @05fa1e>   : 13 05                      set.x32 sp(5)
	<cmp+56 @05fa20>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:67: referenced as `cmp`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@05fa28>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:267'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float64(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @05fa28> - <cmp+57 @05fa61>)
	cmplStd/lib/math.ci:268: (53 bytes: <cmp @05fa28> - <cmp+53 @05fa5d>): if (a < b)
	<cmp @05fa28>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @05fa2a>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @05fa2c>    : 88                         clt.f64
	<cmp+5 @05fa2d>    : 06 1c 00 00                jz <cmp+33 @05fa49>
	cmplStd/lib/math.ci:269: (20 bytes: <cmp+9 @05fa31> - <cmp+29 @05fa45>): if (eps < (b - a))
	<cmp+9 @05fa31>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @05fa33>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @05fa35>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @05fa37>   : 82                         sub.f64
	<cmp+16 @05fa38>   : 88                         clt.f64
	<cmp+17 @05fa39>   : 06 0c 00 00                jz <cmp+29 @05fa45>
	cmplStd/lib/math.ci:270: (8 bytes: <cmp+21 @05fa3d> - <cmp+29 @05fa45>): return .result := -1;
	<cmp+21 @05fa3d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05fa42>   : 13 08                      set.x32 sp(8)
	<cmp+28 @05fa44>   : 03                         ret
	<cmp+29 @05fa45>   : 04 18 00 00                jmp <cmp+53 @05fa5d>
	cmplStd/lib/math.ci:274: (20 bytes: <cmp+33 @05fa49> - <cmp+53 @05fa5d>): if (eps < (a - b))
	<cmp+33 @05fa49>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @05fa4b>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @05fa4d>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @05fa4f>   : 82                         sub.f64
	<cmp+40 @05fa50>   : 88                         clt.f64
	<cmp+41 @05fa51>   : 06 0c 00 00                jz <cmp+53 @05fa5d>
	cmplStd/lib/math.ci:275: (8 bytes: <cmp+45 @05fa55> - <cmp+53 @05fa5d>): return .result := +1;
	<cmp+45 @05fa55>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05fa5a>   : 13 08                      set.x32 sp(8)
	<cmp+52 @05fa5c>   : 03                         ret
	cmplStd/lib/math.ci:278: (4 bytes: <cmp+53 @05fa5d> - <cmp+57 @05fa61>): return .result := 0;
	<cmp+53 @05fa5d>   : 19                         load.z32
	<cmp+54 @05fa5e>   : 13 08                      set.x32 sp(8)
	<cmp+56 @05fa60>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `cmp`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 335
.offset: <@05fa68>
.name: 'sinCos'
.file: 'cmplStd/lib/math.ci:282'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <sinCos @05fa68> - <sinCos+335 @05fbb7>)
	cmplStd/lib/math.ci:296: (2 bytes: <sinCos @05fa68> - <sinCos+2 @05fa6a>): x: float64 := arg
	<sinCos @05fa68>      : 11 02                      dup.x64 sp(2)
	cmplStd/lib/math.ci:297: (17 bytes: <sinCos+2 @05fa6a> - <sinCos+19 @05fa7b>): if (x < (0))
	<sinCos+2 @05fa6a>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @05fa6c>    : 1a                         load.z64
	<sinCos+5 @05fa6d>    : 88                         clt.f64
	<sinCos+6 @05fa6e>    : 06 0d 00 00                jz <sinCos+19 @05fa7b>
	cmplStd/lib/math.ci:298: (1 byte: <sinCos+10 @05fa72> - <sinCos+11 @05fa73>): x := -x;
	<sinCos+10 @05fa72>   : 80                         neg.f64
	cmplStd/lib/math.ci:299: (8 bytes: <sinCos+11 @05fa73> - <sinCos+19 @05fa7b>): quad := quad + 2;
	<sinCos+11 @05fa73>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @05fa75>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @05fa79>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math.ci:302: (1 byte: <sinCos+19 @05fa7b> - <sinCos+20 @05fa7c>): y: float64
	<sinCos+19 @05fa7b>   : 1a                         load.z64
	cmplStd/lib/math.ci:303: (24 bytes: <sinCos+20 @05fa7c> - <sinCos+44 @05fa94>): x := x * (1) / PIO2;
	<sinCos+20 @05fa7c>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @05fa7e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @05fa87>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @05fa90>   : 84                         div.f64
	<sinCos+41 @05fa91>   : 83                         mul.f64
	<sinCos+42 @05fa92>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:304: (124 bytes: <sinCos+44 @05fa94> - <sinCos+168 @05fb10>): if (x > (32764))
	<sinCos+44 @05fa94>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @05fa96>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05fa9f>   : 89                         cgt.f64
	<sinCos+56 @05faa0>   : 06 54 00 00                jz <sinCos+140 @05faf4>
	cmplStd/lib/math.ci:305: (1 byte: <sinCos+60 @05faa4> - <sinCos+61 @05faa5>): e: float64
	<sinCos+60 @05faa4>   : 1b                         load.z128
	cmplStd/lib/math.ci:306: (18 bytes: <sinCos+61 @05faa5> - <sinCos+79 @05fab7>): y := modf(x, &e);
	<sinCos+61 @05faa5>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @05faa7>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05faab>   : 1f e8 f7 05 00             load.ref <@05f7e8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @05fab0>   : 02                         call
	<sinCos+73 @05fab1>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @05fab5>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:307: (4 bytes: <sinCos+79 @05fab7> - <sinCos+83 @05fabb>): e := e + (quad);
	<sinCos+79 @05fab7>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @05fab9>   : 5d                         i32.2f64
	<sinCos+82 @05faba>   : 81                         add.f64
	cmplStd/lib/math.ci:309: (1 byte: <sinCos+83 @05fabb> - <sinCos+84 @05fabc>): f: float64
	<sinCos+83 @05fabb>   : 1b                         load.z128
	cmplStd/lib/math.ci:310: (30 bytes: <sinCos+84 @05fabc> - <sinCos+114 @05fada>): modf(0.250000 * e, &f);
	<sinCos+84 @05fabc>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @05fac5>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @05fac7>   : 83                         mul.f64
	<sinCos+96 @05fac8>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @05facc>  : 1f e8 f7 05 00             load.ref <@05f7e8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @05fad1>  : 02                         call
	<sinCos+106 @05fad2>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @05fad6>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:311: (18 bytes: <sinCos+114 @05fada> - <sinCos+132 @05faec>): quad := (e - (4) * f);
	<sinCos+114 @05fada>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @05fadc>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @05fae5>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @05fae7>  : 83                         mul.f64
	<sinCos+128 @05fae8>  : 82                         sub.f64
	<sinCos+129 @05fae9>  : 8a                         f64.2i32
	<sinCos+130 @05faea>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @05faec>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @05faf0>  : 04 20 00 00                jmp <sinCos+168 @05fb10>
	cmplStd/lib/math.ci:314: (3 bytes: <sinCos+140 @05faf4> - <sinCos+143 @05faf7>): k: int32 := x
	<sinCos+140 @05faf4>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @05faf6>  : 8a                         f64.2i32
	cmplStd/lib/math.ci:315: (8 bytes: <sinCos+143 @05faf7> - <sinCos+151 @05faff>): y := x - (k);
	<sinCos+143 @05faf7>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @05faf9>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @05fafb>  : 5d                         i32.2f64
	<sinCos+148 @05fafc>  : 82                         sub.f64
	<sinCos+149 @05fafd>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:316: (7 bytes: <sinCos+151 @05faff> - <sinCos+158 @05fb06>): quad := quad + k;
	<sinCos+151 @05faff>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @05fb01>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @05fb03>  : 51                         add.i32
	<sinCos+156 @05fb04>  : 13 07                      set.x32 sp(7)
	cmplStd/lib/math.ci:317: (6 bytes: <sinCos+158 @05fb06> - <sinCos+164 @05fb0c>): quad := quad & 3;
	<sinCos+158 @05fb06>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @05fb08>  : 3f 02                      b32.and 0x03
	<sinCos+162 @05fb0a>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @05fb0c>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:319: (22 bytes: <sinCos+168 @05fb10> - <sinCos+190 @05fb26>): if (quad & 1)
	<sinCos+168 @05fb10>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @05fb12>  : 3f 01                      b32.and 0x01
	<sinCos+172 @05fb14>  : 06 12 00 00                jz <sinCos+190 @05fb26>
	cmplStd/lib/math.ci:320: (14 bytes: <sinCos+176 @05fb18> - <sinCos+190 @05fb26>): y := (1) - y;
	<sinCos+176 @05fb18>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @05fb21>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @05fb23>  : 82                         sub.f64
	<sinCos+188 @05fb24>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:322: (13 bytes: <sinCos+190 @05fb26> - <sinCos+203 @05fb33>): if (quad > 1)
	<sinCos+190 @05fb26>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @05fb28>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @05fb2d>  : 59                         cgt.i32
	<sinCos+198 @05fb2e>  : 06 05 00 00                jz <sinCos+203 @05fb33>
	cmplStd/lib/math.ci:323: (1 byte: <sinCos+202 @05fb32> - <sinCos+203 @05fb33>): y := -y;
	<sinCos+202 @05fb32>  : 80                         neg.f64
	cmplStd/lib/math.ci:326: (5 bytes: <sinCos+203 @05fb33> - <sinCos+208 @05fb38>): ysq: float64 := y * y
	<sinCos+203 @05fb33>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @05fb35>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @05fb37>  : 83                         mul.f64
	cmplStd/lib/math.ci:327: (64 bytes: <sinCos+208 @05fb38> - <sinCos+272 @05fb78>): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+208 @05fb38>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @05fb41>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @05fb43>  : 83                         mul.f64
	<sinCos+220 @05fb44>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @05fb4d>  : 81                         add.f64
	<sinCos+230 @05fb4e>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @05fb50>  : 83                         mul.f64
	<sinCos+233 @05fb51>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @05fb5a>  : 81                         add.f64
	<sinCos+243 @05fb5b>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @05fb5d>  : 83                         mul.f64
	<sinCos+246 @05fb5e>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @05fb67>  : 81                         add.f64
	<sinCos+256 @05fb68>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @05fb6a>  : 83                         mul.f64
	<sinCos+259 @05fb6b>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @05fb74>  : 81                         add.f64
	<sinCos+269 @05fb75>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @05fb77>  : 83                         mul.f64
	cmplStd/lib/math.ci:328: (51 bytes: <sinCos+272 @05fb78> - <sinCos+323 @05fbab>): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+272 @05fb78>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @05fb7a>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @05fb83>  : 81                         add.f64
	<sinCos+284 @05fb84>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @05fb86>  : 83                         mul.f64
	<sinCos+287 @05fb87>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @05fb90>  : 81                         add.f64
	<sinCos+297 @05fb91>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @05fb93>  : 83                         mul.f64
	<sinCos+300 @05fb94>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05fb9d>  : 81                         add.f64
	<sinCos+310 @05fb9e>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @05fba0>  : 83                         mul.f64
	<sinCos+313 @05fba1>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05fbaa>  : 81                         add.f64
	cmplStd/lib/math.ci:329: (12 bytes: <sinCos+323 @05fbab> - <sinCos+335 @05fbb7>): return .result := temp1 / temp2;
	<sinCos+323 @05fbab>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @05fbad>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @05fbaf>  : 84                         div.f64
	<sinCos+328 @05fbb0>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @05fbb2>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @05fbb6>  : 03                         ret
.usages:
	cmplStd/lib/math.ci:336: referenced as `sinCos`
	cmplStd/lib/math.ci:333: referenced as `sinCos`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math.ci:333'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	cmplStd/test/std/test.math.ci:57: referenced as `sin`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math.ci:336'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	cmplStd/test/std/test.math.ci:58: referenced as `cos`
}
Math.tan(arg: float64): float64: function {
.kind: static function
.base: `function`
.size: 378
.offset: <@05fbb8>
.name: 'tan'
.file: 'cmplStd/lib/math.ci:339'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else if (bool(i == 1)) {
		float64(x := float64((1) - x));
		bool(complement := true);
	}
	else if (bool(i == 2)) {
		bool(negate := bool(!negate));
		bool(complement := true);
	}
	else if (bool(i == 3)) {
		float64(x := float64((1) - x));
		bool(negate := bool(!negate));
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <tan @05fbb8> - <tan+378 @05fd32>)
	cmplStd/lib/math.ci:352: (1 byte: <tan @05fbb8> - <tan+1 @05fbb9>): complement: bool := false
	<tan @05fbb8>      : 19                         load.z32
	cmplStd/lib/math.ci:353: (1 byte: <tan+1 @05fbb9> - <tan+2 @05fbba>): negate: bool := false
	<tan+1 @05fbb9>    : 19                         load.z32
	cmplStd/lib/math.ci:355: (23 bytes: <tan+2 @05fbba> - <tan+25 @05fbd1>): if (arg < (0))
	<tan+2 @05fbba>    : 11 03                      dup.x64 sp(3)
	<tan+4 @05fbbc>    : 1a                         load.z64
	<tan+5 @05fbbd>    : 88                         clt.f64
	<tan+6 @05fbbe>    : 06 13 00 00                jz <tan+25 @05fbd1>
	cmplStd/lib/math.ci:356: (5 bytes: <tan+10 @05fbc2> - <tan+15 @05fbc7>): arg := -arg;
	<tan+10 @05fbc2>   : 11 03                      dup.x64 sp(3)
	<tan+12 @05fbc4>   : 80                         neg.f64
	<tan+13 @05fbc5>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:357: (10 bytes: <tan+15 @05fbc7> - <tan+25 @05fbd1>): negate := true;
	<tan+15 @05fbc7>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @05fbcc>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @05fbd0>   : 2b                         store.i8
	cmplStd/lib/math.ci:359: (24 bytes: <tan+25 @05fbd1> - <tan+49 @05fbe9>): arg := (2) * arg / PIO2;
	<tan+25 @05fbd1>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @05fbda>   : 11 05                      dup.x64 sp(5)
	<tan+36 @05fbdc>   : 83                         mul.f64
	<tan+37 @05fbdd>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @05fbe6>   : 84                         div.f64
	<tan+47 @05fbe7>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:361: (1 byte: <tan+49 @05fbe9> - <tan+50 @05fbea>): e: float64
	<tan+49 @05fbe9>   : 1b                         load.z128
	cmplStd/lib/math.ci:362: (16 bytes: <tan+50 @05fbea> - <tan+66 @05fbfa>): x: float64 := modf(arg, &e)
	<tan+50 @05fbea>   : 11 07                      dup.x64 sp(7)
	<tan+52 @05fbec>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @05fbf0>   : 1f e8 f7 05 00             load.ref <@05f7e8> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @05fbf5>   : 02                         call
	<tan+62 @05fbf6>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math.ci:363: (9 bytes: <tan+66 @05fbfa> - <tan+75 @05fc03>): i: int32 := int32(e) % 4
	<tan+66 @05fbfa>   : 11 02                      dup.x64 sp(2)
	<tan+68 @05fbfc>   : 8a                         f64.2i32
	<tan+69 @05fbfd>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @05fc02>   : 55                         mod.i32
	cmplStd/lib/math.ci:365: (122 bytes: <tan+75 @05fc03> - <tan+197 @05fc7d>): if (i == 0)
	<tan+75 @05fc03>   : 10 00                      dup.x32 sp(0)
	<tan+77 @05fc05>   : 19                         load.z32
	<tan+78 @05fc06>   : 57                         ceq.i32
	<tan+79 @05fc07>   : 05 76 00 00                jnz <tan+197 @05fc7d>
	cmplStd/lib/math.ci:366: (114 bytes: <tan+83 @05fc0b> - <tan+197 @05fc7d>): if (i == 1)
	<tan+83 @05fc0b>   : 10 00                      dup.x32 sp(0)
	<tan+85 @05fc0d>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @05fc12>   : 57                         ceq.i32
	<tan+91 @05fc13>   : 06 20 00 00                jz <tan+123 @05fc33>
	cmplStd/lib/math.ci:367: (14 bytes: <tan+95 @05fc17> - <tan+109 @05fc25>): x := (1) - x;
	<tan+95 @05fc17>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @05fc20>  : 11 03                      dup.x64 sp(3)
	<tan+106 @05fc22>  : 82                         sub.f64
	<tan+107 @05fc23>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:368: (10 bytes: <tan+109 @05fc25> - <tan+119 @05fc2f>): complement := true;
	<tan+109 @05fc25>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @05fc2a>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @05fc2e>  : 2b                         store.i8
	<tan+119 @05fc2f>  : 04 4e 00 00                jmp <tan+197 @05fc7d>
	cmplStd/lib/math.ci:370: (74 bytes: <tan+123 @05fc33> - <tan+197 @05fc7d>): if (i == 2)
	<tan+123 @05fc33>  : 10 00                      dup.x32 sp(0)
	<tan+125 @05fc35>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @05fc3a>  : 57                         ceq.i32
	<tan+131 @05fc3b>  : 06 1d 00 00                jz <tan+160 @05fc58>
	cmplStd/lib/math.ci:371: (11 bytes: <tan+135 @05fc3f> - <tan+146 @05fc4a>): negate := !negate;
	<tan+135 @05fc3f>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @05fc43>  : 26                         load.i8
	<tan+140 @05fc44>  : 0b                         not.b32
	<tan+141 @05fc45>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @05fc49>  : 2b                         store.i8
	cmplStd/lib/math.ci:372: (10 bytes: <tan+146 @05fc4a> - <tan+156 @05fc54>): complement := true;
	<tan+146 @05fc4a>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @05fc4f>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @05fc53>  : 2b                         store.i8
	<tan+156 @05fc54>  : 04 29 00 00                jmp <tan+197 @05fc7d>
	cmplStd/lib/math.ci:374: (37 bytes: <tan+160 @05fc58> - <tan+197 @05fc7d>): if (i == 3)
	<tan+160 @05fc58>  : 10 00                      dup.x32 sp(0)
	<tan+162 @05fc5a>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @05fc5f>  : 57                         ceq.i32
	<tan+168 @05fc60>  : 06 1d 00 00                jz <tan+197 @05fc7d>
	cmplStd/lib/math.ci:375: (14 bytes: <tan+172 @05fc64> - <tan+186 @05fc72>): x := (1) - x;
	<tan+172 @05fc64>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @05fc6d>  : 11 03                      dup.x64 sp(3)
	<tan+183 @05fc6f>  : 82                         sub.f64
	<tan+184 @05fc70>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:376: (11 bytes: <tan+186 @05fc72> - <tan+197 @05fc7d>): negate := !negate;
	<tan+186 @05fc72>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @05fc76>  : 26                         load.i8
	<tan+191 @05fc77>  : 0b                         not.b32
	<tan+192 @05fc78>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @05fc7c>  : 2b                         store.i8
	cmplStd/lib/math.ci:379: (5 bytes: <tan+197 @05fc7d> - <tan+202 @05fc82>): xsq: float64 := x * x
	<tan+197 @05fc7d>  : 11 01                      dup.x64 sp(1)
	<tan+199 @05fc7f>  : 11 03                      dup.x64 sp(3)
	<tan+201 @05fc81>  : 83                         mul.f64
	cmplStd/lib/math.ci:380: (64 bytes: <tan+202 @05fc82> - <tan+266 @05fcc2>): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+202 @05fc82>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @05fc8b>  : 11 02                      dup.x64 sp(2)
	<tan+213 @05fc8d>  : 83                         mul.f64
	<tan+214 @05fc8e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @05fc97>  : 81                         add.f64
	<tan+224 @05fc98>  : 11 02                      dup.x64 sp(2)
	<tan+226 @05fc9a>  : 83                         mul.f64
	<tan+227 @05fc9b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @05fca4>  : 81                         add.f64
	<tan+237 @05fca5>  : 11 02                      dup.x64 sp(2)
	<tan+239 @05fca7>  : 83                         mul.f64
	<tan+240 @05fca8>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @05fcb1>  : 81                         add.f64
	<tan+250 @05fcb2>  : 11 02                      dup.x64 sp(2)
	<tan+252 @05fcb4>  : 83                         mul.f64
	<tan+253 @05fcb5>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @05fcbe>  : 81                         add.f64
	<tan+263 @05fcbf>  : 11 05                      dup.x64 sp(5)
	<tan+265 @05fcc1>  : 83                         mul.f64
	cmplStd/lib/math.ci:381: (39 bytes: <tan+266 @05fcc2> - <tan+305 @05fce9>): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+266 @05fcc2>  : 11 02                      dup.x64 sp(2)
	<tan+268 @05fcc4>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @05fccd>  : 81                         add.f64
	<tan+278 @05fcce>  : 11 04                      dup.x64 sp(4)
	<tan+280 @05fcd0>  : 83                         mul.f64
	<tan+281 @05fcd1>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @05fcda>  : 81                         add.f64
	<tan+291 @05fcdb>  : 11 04                      dup.x64 sp(4)
	<tan+293 @05fcdd>  : 83                         mul.f64
	<tan+294 @05fcde>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @05fce7>  : 81                         add.f64
	<tan+304 @05fce8>  : 84                         div.f64
	cmplStd/lib/math.ci:383: (47 bytes: <tan+305 @05fce9> - <tan+352 @05fd18>): if (complement)
	<tan+305 @05fce9>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @05fced>  : 26                         load.i8
	<tan+310 @05fcee>  : 06 2a 00 00                jz <tan+352 @05fd18>
	cmplStd/lib/math.ci:384: (24 bytes: <tan+314 @05fcf2> - <tan+338 @05fd0a>): if (result == (0))
	<tan+314 @05fcf2>  : 11 00                      dup.x64 sp(0)
	<tan+316 @05fcf4>  : 1a                         load.z64
	<tan+317 @05fcf5>  : 87                         ceq.f64
	<tan+318 @05fcf6>  : 06 14 00 00                jz <tan+338 @05fd0a>
	cmplStd/lib/math.ci:385: (16 bytes: <tan+322 @05fcfa> - <tan+338 @05fd0a>): return .result := nan;
	<tan+322 @05fcfa>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @05fd03>  : 14 10                      set.x64 sp(16)
	<tan+333 @05fd05>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @05fd09>  : 03                         ret
	cmplStd/lib/math.ci:387: (14 bytes: <tan+338 @05fd0a> - <tan+352 @05fd18>): result := (1) / result;
	<tan+338 @05fd0a>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @05fd13>  : 11 02                      dup.x64 sp(2)
	<tan+349 @05fd15>  : 84                         div.f64
	<tan+350 @05fd16>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:389: (19 bytes: <tan+352 @05fd18> - <tan+371 @05fd2b>): if (negate)
	<tan+352 @05fd18>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @05fd1c>  : 26                         load.i8
	<tan+357 @05fd1d>  : 06 0e 00 00                jz <tan+371 @05fd2b>
	cmplStd/lib/math.ci:390: (10 bytes: <tan+361 @05fd21> - <tan+371 @05fd2b>): return .result := -result;
	<tan+361 @05fd21>  : 11 00                      dup.x64 sp(0)
	<tan+363 @05fd23>  : 80                         neg.f64
	<tan+364 @05fd24>  : 14 10                      set.x64 sp(16)
	<tan+366 @05fd26>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @05fd2a>  : 03                         ret
	cmplStd/lib/math.ci:392: (7 bytes: <tan+371 @05fd2b> - <tan+378 @05fd32>): return .result := result;
	<tan+371 @05fd2b>  : 14 0e                      set.x64 sp(14)
	<tan+373 @05fd2d>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @05fd31>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:59: referenced as `tan`
}
Math.sinh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 241
.offset: <@05fd38>
.name: 'sinh'
.file: 'cmplStd/lib/math.ci:396'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <sinh @05fd38> - <sinh+241 @05fe29>)
	cmplStd/lib/math.ci:408: (1 byte: <sinh @05fd38> - <sinh+1 @05fd39>): negate: bool := false
	<sinh @05fd38>      : 19                         load.z32
	cmplStd/lib/math.ci:409: (23 bytes: <sinh+1 @05fd39> - <sinh+24 @05fd50>): if (x < (0))
	<sinh+1 @05fd39>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @05fd3b>    : 1a                         load.z64
	<sinh+4 @05fd3c>    : 88                         clt.f64
	<sinh+5 @05fd3d>    : 06 13 00 00                jz <sinh+24 @05fd50>
	cmplStd/lib/math.ci:410: (5 bytes: <sinh+9 @05fd41> - <sinh+14 @05fd46>): x := -x;
	<sinh+9 @05fd41>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @05fd43>   : 80                         neg.f64
	<sinh+12 @05fd44>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:411: (10 bytes: <sinh+14 @05fd46> - <sinh+24 @05fd50>): negate := true;
	<sinh+14 @05fd46>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @05fd4b>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @05fd4f>   : 2b                         store.i8
	cmplStd/lib/math.ci:414: (39 bytes: <sinh+24 @05fd50> - <sinh+63 @05fd77>): if (x > (21))
	<sinh+24 @05fd50>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @05fd52>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @05fd5b>   : 89                         cgt.f64
	<sinh+36 @05fd5c>   : 06 1b 00 00                jz <sinh+63 @05fd77>
	cmplStd/lib/math.ci:415: (23 bytes: <sinh+40 @05fd60> - <sinh+63 @05fd77>): return .result := float64.exp(x) / (2);
	<sinh+40 @05fd60>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @05fd62>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<sinh+46 @05fd66>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @05fd6f>   : 84                         div.f64
	<sinh+56 @05fd70>   : 14 06                      set.x64 sp(6)
	<sinh+58 @05fd72>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @05fd76>   : 03                         ret
	cmplStd/lib/math.ci:418: (1 byte: <sinh+63 @05fd77> - <sinh+64 @05fd78>): result: float64
	<sinh+63 @05fd77>   : 1a                         load.z64
	cmplStd/lib/math.ci:419: (151 bytes: <sinh+64 @05fd78> - <sinh+215 @05fe0f>): if (x > 0.500000)
	<sinh+64 @05fd78>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @05fd7a>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @05fd83>   : 89                         cgt.f64
	<sinh+76 @05fd84>   : 06 22 00 00                jz <sinh+110 @05fda6>
	cmplStd/lib/math.ci:420: (26 bytes: <sinh+80 @05fd88> - <sinh+106 @05fda2>): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+80 @05fd88>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @05fd8a>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<sinh+86 @05fd8e>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @05fd90>   : 80                         neg.f64
	<sinh+89 @05fd91>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<sinh+93 @05fd95>   : 82                         sub.f64
	<sinh+94 @05fd96>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @05fd9f>  : 84                         div.f64
	<sinh+104 @05fda0>  : 14 02                      set.x64 sp(2)
	<sinh+106 @05fda2>  : 04 6d 00 00                jmp <sinh+215 @05fe0f>
	cmplStd/lib/math.ci:423: (5 bytes: <sinh+110 @05fda6> - <sinh+115 @05fdab>): sq: float64 := x * x
	<sinh+110 @05fda6>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @05fda8>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @05fdaa>  : 83                         mul.f64
	cmplStd/lib/math.ci:424: (53 bytes: <sinh+115 @05fdab> - <sinh+168 @05fde0>): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+115 @05fdab>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @05fdb4>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @05fdb6>  : 83                         mul.f64
	<sinh+127 @05fdb7>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @05fdc0>  : 81                         add.f64
	<sinh+137 @05fdc1>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @05fdc3>  : 83                         mul.f64
	<sinh+140 @05fdc4>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @05fdcd>  : 81                         add.f64
	<sinh+150 @05fdce>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @05fdd0>  : 83                         mul.f64
	<sinh+153 @05fdd1>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @05fdda>  : 81                         add.f64
	<sinh+163 @05fddb>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @05fddd>  : 83                         mul.f64
	<sinh+166 @05fdde>  : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:425: (43 bytes: <sinh+168 @05fde0> - <sinh+211 @05fe0b>): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+168 @05fde0>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @05fde2>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @05fde4>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @05fded>  : 81                         add.f64
	<sinh+182 @05fdee>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @05fdf0>  : 83                         mul.f64
	<sinh+185 @05fdf1>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @05fdfa>  : 81                         add.f64
	<sinh+195 @05fdfb>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @05fdfd>  : 83                         mul.f64
	<sinh+198 @05fdfe>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @05fe07>  : 81                         add.f64
	<sinh+208 @05fe08>  : 84                         div.f64
	<sinh+209 @05fe09>  : 14 04                      set.x64 sp(4)
	<sinh+211 @05fe0b>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:428: (19 bytes: <sinh+215 @05fe0f> - <sinh+234 @05fe22>): if (negate)
	<sinh+215 @05fe0f>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @05fe13>  : 26                         load.i8
	<sinh+220 @05fe14>  : 06 0e 00 00                jz <sinh+234 @05fe22>
	cmplStd/lib/math.ci:429: (10 bytes: <sinh+224 @05fe18> - <sinh+234 @05fe22>): return .result := -result;
	<sinh+224 @05fe18>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @05fe1a>  : 80                         neg.f64
	<sinh+227 @05fe1b>  : 14 08                      set.x64 sp(8)
	<sinh+229 @05fe1d>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @05fe21>  : 03                         ret
	cmplStd/lib/math.ci:431: (7 bytes: <sinh+234 @05fe22> - <sinh+241 @05fe29>): return .result := result;
	<sinh+234 @05fe22>  : 14 06                      set.x64 sp(6)
	<sinh+236 @05fe24>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @05fe28>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:60: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:151: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:149: referenced as `sinh`
}
Math.cosh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 75
.offset: <@05fe30>
.name: 'cosh'
.file: 'cmplStd/lib/math.ci:435'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <cosh @05fe30> - <cosh+75 @05fe7b>)
	cmplStd/lib/math.ci:436: (13 bytes: <cosh @05fe30> - <cosh+13 @05fe3d>): if (x < (0))
	<cosh @05fe30>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @05fe32>    : 1a                         load.z64
	<cosh+3 @05fe33>    : 88                         clt.f64
	<cosh+4 @05fe34>    : 06 09 00 00                jz <cosh+13 @05fe3d>
	cmplStd/lib/math.ci:437: (5 bytes: <cosh+8 @05fe38> - <cosh+13 @05fe3d>): x := -x;
	<cosh+8 @05fe38>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @05fe3a>   : 80                         neg.f64
	<cosh+11 @05fe3b>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:439: (35 bytes: <cosh+13 @05fe3d> - <cosh+48 @05fe60>): if (x > (21))
	<cosh+13 @05fe3d>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @05fe3f>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @05fe48>   : 89                         cgt.f64
	<cosh+25 @05fe49>   : 06 17 00 00                jz <cosh+48 @05fe60>
	cmplStd/lib/math.ci:440: (19 bytes: <cosh+29 @05fe4d> - <cosh+48 @05fe60>): return .result := float64.exp(x) / (2);
	<cosh+29 @05fe4d>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @05fe4f>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<cosh+35 @05fe53>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @05fe5c>   : 84                         div.f64
	<cosh+45 @05fe5d>   : 14 05                      set.x64 sp(5)
	<cosh+47 @05fe5f>   : 03                         ret
	cmplStd/lib/math.ci:442: (27 bytes: <cosh+48 @05fe60> - <cosh+75 @05fe7b>): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+48 @05fe60>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @05fe62>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<cosh+54 @05fe66>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @05fe68>   : 80                         neg.f64
	<cosh+57 @05fe69>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<cosh+61 @05fe6d>   : 81                         add.f64
	<cosh+62 @05fe6e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @05fe77>   : 84                         div.f64
	<cosh+72 @05fe78>   : 14 05                      set.x64 sp(5)
	<cosh+74 @05fe7a>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:151: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:149: referenced as `cosh`
}
Math.asin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 173
.offset: <@05fe80>
.name: 'asin'
.file: 'cmplStd/lib/math.ci:450'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <asin @05fe80> - <asin+173 @05ff2d>)
	cmplStd/lib/math.ci:451: (12 bytes: <asin @05fe80> - <asin+12 @05fe8c>): if (x == (0))
	<asin @05fe80>      : 11 01                      dup.x64 sp(1)
	<asin+2 @05fe82>    : 1a                         load.z64
	<asin+3 @05fe83>    : 87                         ceq.f64
	<asin+4 @05fe84>    : 06 08 00 00                jz <asin+12 @05fe8c>
	cmplStd/lib/math.ci:453: (4 bytes: <asin+8 @05fe88> - <asin+12 @05fe8c>): return .result := x;
	<asin+8 @05fe88>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @05fe8b>   : 03                         ret
	cmplStd/lib/math.ci:456: (1 byte: <asin+12 @05fe8c> - <asin+13 @05fe8d>): negate: bool := false
	<asin+12 @05fe8c>   : 19                         load.z32
	cmplStd/lib/math.ci:457: (23 bytes: <asin+13 @05fe8d> - <asin+36 @05fea4>): if (x < (0))
	<asin+13 @05fe8d>   : 11 02                      dup.x64 sp(2)
	<asin+15 @05fe8f>   : 1a                         load.z64
	<asin+16 @05fe90>   : 88                         clt.f64
	<asin+17 @05fe91>   : 06 13 00 00                jz <asin+36 @05fea4>
	cmplStd/lib/math.ci:458: (10 bytes: <asin+21 @05fe95> - <asin+31 @05fe9f>): negate := true;
	<asin+21 @05fe95>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @05fe9a>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @05fe9e>   : 2b                         store.i8
	cmplStd/lib/math.ci:459: (5 bytes: <asin+31 @05fe9f> - <asin+36 @05fea4>): x := -x;
	<asin+31 @05fe9f>   : 11 02                      dup.x64 sp(2)
	<asin+33 @05fea1>   : 80                         neg.f64
	<asin+34 @05fea2>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:462: (32 bytes: <asin+36 @05fea4> - <asin+68 @05fec4>): if (x > (1))
	<asin+36 @05fea4>   : 11 02                      dup.x64 sp(2)
	<asin+38 @05fea6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @05feaf>   : 89                         cgt.f64
	<asin+48 @05feb0>   : 06 14 00 00                jz <asin+68 @05fec4>
	cmplStd/lib/math.ci:464: (16 bytes: <asin+52 @05feb4> - <asin+68 @05fec4>): return .result := nan;
	<asin+52 @05feb4>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @05febd>   : 14 06                      set.x64 sp(6)
	<asin+63 @05febf>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @05fec3>   : 03                         ret
	cmplStd/lib/math.ci:467: (19 bytes: <asin+68 @05fec4> - <asin+87 @05fed7>): result: float64 := float64.sqrt((1) - x * x)
	<asin+68 @05fec4>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @05fecd>   : 11 04                      dup.x64 sp(4)
	<asin+79 @05fecf>   : 11 06                      dup.x64 sp(6)
	<asin+81 @05fed1>   : 83                         mul.f64
	<asin+82 @05fed2>   : 82                         sub.f64
	<asin+83 @05fed3>   : 01 2f 00 00                nfc(47) ;float64.sqrt(x: float64): float64
	cmplStd/lib/math.ci:468: (60 bytes: <asin+87 @05fed7> - <asin+147 @05ff13>): if (x > 0.700000)
	<asin+87 @05fed7>   : 11 04                      dup.x64 sp(4)
	<asin+89 @05fed9>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @05fee2>   : 89                         cgt.f64
	<asin+99 @05fee3>   : 06 26 00 00                jz <asin+137 @05ff09>
	cmplStd/lib/math.ci:469: (30 bytes: <asin+103 @05fee7> - <asin+133 @05ff05>): result := pi / (2) - float64.atan2(result, x);
	<asin+103 @05fee7>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @05fef0>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @05fef9>  : 84                         div.f64
	<asin+122 @05fefa>  : 11 02                      dup.x64 sp(2)
	<asin+124 @05fefc>  : 11 08                      dup.x64 sp(8)
	<asin+126 @05fefe>  : 01 30 00 00                nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @05ff02>  : 82                         sub.f64
	<asin+131 @05ff03>  : 14 02                      set.x64 sp(2)
	<asin+133 @05ff05>  : 04 0e 00 00                jmp <asin+147 @05ff13>
	cmplStd/lib/math.ci:472: (10 bytes: <asin+137 @05ff09> - <asin+147 @05ff13>): result := float64.atan2(x, result);
	<asin+137 @05ff09>  : 11 04                      dup.x64 sp(4)
	<asin+139 @05ff0b>  : 11 02                      dup.x64 sp(2)
	<asin+141 @05ff0d>  : 01 30 00 00                nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @05ff11>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:475: (19 bytes: <asin+147 @05ff13> - <asin+166 @05ff26>): if (negate)
	<asin+147 @05ff13>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @05ff17>  : 26                         load.i8
	<asin+152 @05ff18>  : 06 0e 00 00                jz <asin+166 @05ff26>
	cmplStd/lib/math.ci:476: (10 bytes: <asin+156 @05ff1c> - <asin+166 @05ff26>): return .result := -result;
	<asin+156 @05ff1c>  : 11 00                      dup.x64 sp(0)
	<asin+158 @05ff1e>  : 80                         neg.f64
	<asin+159 @05ff1f>  : 14 08                      set.x64 sp(8)
	<asin+161 @05ff21>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @05ff25>  : 03                         ret
	cmplStd/lib/math.ci:478: (7 bytes: <asin+166 @05ff26> - <asin+173 @05ff2d>): return .result := result;
	<asin+166 @05ff26>  : 14 06                      set.x64 sp(6)
	<asin+168 @05ff28>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @05ff2c>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:63: referenced as `asin`
	cmplStd/lib/math.ci:485: referenced as `asin`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'cmplStd/lib/math.ci:485'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	cmplStd/test/std/test.math.ci:64: referenced as `acos`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'cmplStd/lib/math.ci:509'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'cmplStd/lib/math.ci:512'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01f4c8>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:184: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:182: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:180: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:178: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:175: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:173: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:171: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:169: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:166: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:164: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:114: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:112: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:31: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:24: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:141: referenced as `re`
	cmplStd/lib/math/Complex.ci:139: referenced as `re`
	cmplStd/lib/math/Complex.ci:138: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:126: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:114: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:102: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:99: referenced as `re`
	cmplStd/lib/math/Complex.ci:98: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:95: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:92: referenced as `re`
	cmplStd/lib/math/Complex.ci:91: referenced as `re`
	cmplStd/lib/math/Complex.ci:90: referenced as `re`
	cmplStd/lib/math/Complex.ci:83: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:73: referenced as `re`
	cmplStd/lib/math/Complex.ci:71: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:64: referenced as `re`
	cmplStd/lib/math/Complex.ci:33: referenced as `re`
	cmplStd/lib/math/Complex.ci:26: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:139: referenced as `im`
	cmplStd/lib/math/Complex.ci:138: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:126: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:114: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:101: referenced as `im`
	cmplStd/lib/math/Complex.ci:99: referenced as `im`
	cmplStd/lib/math/Complex.ci:98: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:94: referenced as `im`
	cmplStd/lib/math/Complex.ci:92: referenced as `im`
	cmplStd/lib/math/Complex.ci:91: referenced as `im`
	cmplStd/lib/math/Complex.ci:90: referenced as `im`
	cmplStd/lib/math/Complex.ci:83: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:73: referenced as `im`
	cmplStd/lib/math/Complex.ci:71: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:64: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	internal usages: 1
}
Complex(re: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@05ff30>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <Complex @05ff30> - <Complex+7 @05ff37>)
	cmplStd/lib/math/Complex.ci:25: (7 bytes: <Complex @05ff30> - <Complex+7 @05ff37>): return .result := {...};
	cmplStd/lib/math/Complex.ci:26: (3 bytes: <Complex @05ff30> - <Complex+3 @05ff33>): .result.re := re;
	<Complex @05ff30>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <Complex+3 @05ff33> - <Complex+6 @05ff36>): .result.im := (0);
	<Complex+3 @05ff33>    : 1a                         load.z64
	<Complex+4 @05ff34>    : 14 07                      set.x64 sp(7)
	<Complex+6 @05ff36>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@05ff38>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <Complex @05ff38> - <Complex+7 @05ff3f>)
	cmplStd/lib/math/Complex.ci:32: (7 bytes: <Complex @05ff38> - <Complex+7 @05ff3f>): return .result := {...};
	cmplStd/lib/math/Complex.ci:33: (3 bytes: <Complex @05ff38> - <Complex+3 @05ff3b>): .result.re := re;
	<Complex @05ff38>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:34: (3 bytes: <Complex+3 @05ff3b> - <Complex+6 @05ff3e>): .result.im := im;
	<Complex+3 @05ff3b>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @05ff3e>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(void(struct(a), neg.p2d)))
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:171: referenced as `neg`
	cmplStd/lib/math/Complex.ci:169: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `add`
	cmplStd/lib/math/Complex.ci:173: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:169: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `sub`
	cmplStd/lib/math/Complex.ci:173: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)))
.usages:
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 139
.offset: <@05ff40>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:86'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (139 bytes: <div @05ff40> - <div+139 @05ffcb>)
	cmplStd/lib/math/Complex.ci:90: (95 bytes: <div @05ff40> - <div+95 @05ff9f>): if (Math.abs(b.re) >= Math.abs(b.im))
	<div @05ff40>      : 11 01                      dup.x64 sp(1)
	<div+2 @05ff42>    : 11 00                      dup.x64 sp(0)
	<div+4 @05ff44>    : 1a                         load.z64
	<div+5 @05ff45>    : 88                         clt.f64
	<div+6 @05ff46>    : 06 0b 00 00                jz <div+17 @05ff51>
	<div+10 @05ff4a>   : 11 00                      dup.x64 sp(0)
	<div+12 @05ff4c>   : 80                         neg.f64
	<div+13 @05ff4d>   : 04 06 00 00                jmp <div+19 @05ff53>
	<div+17 @05ff51>   : 11 00                      dup.x64 sp(0)
	<div+19 @05ff53>   : 14 02                      set.x64 sp(2)
	<div+21 @05ff55>   : 11 05                      dup.x64 sp(5)
	<div+23 @05ff57>   : 11 00                      dup.x64 sp(0)
	<div+25 @05ff59>   : 1a                         load.z64
	<div+26 @05ff5a>   : 88                         clt.f64
	<div+27 @05ff5b>   : 06 0b 00 00                jz <div+38 @05ff66>
	<div+31 @05ff5f>   : 11 00                      dup.x64 sp(0)
	<div+33 @05ff61>   : 80                         neg.f64
	<div+34 @05ff62>   : 04 06 00 00                jmp <div+40 @05ff68>
	<div+38 @05ff66>   : 11 00                      dup.x64 sp(0)
	<div+40 @05ff68>   : 14 02                      set.x64 sp(2)
	<div+42 @05ff6a>   : 88                         clt.f64
	<div+43 @05ff6b>   : 05 34 00 00                jnz <div+95 @05ff9f>
	cmplStd/lib/math/Complex.ci:91: (5 bytes: <div+47 @05ff6f> - <div+52 @05ff74>): r: float64 := b.im / b.re
	<div+47 @05ff6f>   : 11 03                      dup.x64 sp(3)
	<div+49 @05ff71>   : 11 03                      dup.x64 sp(3)
	<div+51 @05ff73>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:92: (8 bytes: <div+52 @05ff74> - <div+60 @05ff7c>): den: float64 := b.re + r * b.im
	<div+52 @05ff74>   : 11 03                      dup.x64 sp(3)
	<div+54 @05ff76>   : 11 02                      dup.x64 sp(2)
	<div+56 @05ff78>   : 11 09                      dup.x64 sp(9)
	<div+58 @05ff7a>   : 83                         mul.f64
	<div+59 @05ff7b>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:93: (31 bytes: <div+60 @05ff7c> - <div+91 @05ff9b>): return .result := {...};
	cmplStd/lib/math/Complex.ci:94: (13 bytes: <div+60 @05ff7c> - <div+73 @05ff89>): .result.re := (a.re + r * a.im) / den;
	<div+60 @05ff7c>   : 11 09                      dup.x64 sp(9)
	<div+62 @05ff7e>   : 11 04                      dup.x64 sp(4)
	<div+64 @05ff80>   : 11 0f                      dup.x64 sp(15)
	<div+66 @05ff82>   : 83                         mul.f64
	<div+67 @05ff83>   : 81                         add.f64
	<div+68 @05ff84>   : 11 02                      dup.x64 sp(2)
	<div+70 @05ff86>   : 84                         div.f64
	<div+71 @05ff87>   : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:95: (13 bytes: <div+73 @05ff89> - <div+86 @05ff96>): .result.im := (a.im - r * a.re) / den;
	<div+73 @05ff89>   : 11 0b                      dup.x64 sp(11)
	<div+75 @05ff8b>   : 11 04                      dup.x64 sp(4)
	<div+77 @05ff8d>   : 11 0d                      dup.x64 sp(13)
	<div+79 @05ff8f>   : 83                         mul.f64
	<div+80 @05ff90>   : 82                         sub.f64
	<div+81 @05ff91>   : 11 02                      dup.x64 sp(2)
	<div+83 @05ff93>   : 84                         div.f64
	<div+84 @05ff94>   : 14 11                      set.x64 sp(17)
	<div+86 @05ff96>   : 09 f0 ff ff                inc.sp(-16)
	<div+90 @05ff9a>   : 03                         ret
	<div+91 @05ff9b>   : 09 f0 ff ff                inc.sp(-16)
	cmplStd/lib/math/Complex.ci:98: (5 bytes: <div+95 @05ff9f> - <div+100 @05ffa4>): r: float64 := b.re / b.im
	<div+95 @05ff9f>   : 11 01                      dup.x64 sp(1)
	<div+97 @05ffa1>   : 11 05                      dup.x64 sp(5)
	<div+99 @05ffa3>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:99: (8 bytes: <div+100 @05ffa4> - <div+108 @05ffac>): den: float64 := b.im + r * b.re
	<div+100 @05ffa4>  : 11 05                      dup.x64 sp(5)
	<div+102 @05ffa6>  : 11 02                      dup.x64 sp(2)
	<div+104 @05ffa8>  : 11 07                      dup.x64 sp(7)
	<div+106 @05ffaa>  : 83                         mul.f64
	<div+107 @05ffab>  : 81                         add.f64
	cmplStd/lib/math/Complex.ci:100: (31 bytes: <div+108 @05ffac> - <div+139 @05ffcb>): return .result := {...};
	cmplStd/lib/math/Complex.ci:101: (13 bytes: <div+108 @05ffac> - <div+121 @05ffb9>): .result.re := (a.re * r + a.im) / den;
	<div+108 @05ffac>  : 11 09                      dup.x64 sp(9)
	<div+110 @05ffae>  : 11 04                      dup.x64 sp(4)
	<div+112 @05ffb0>  : 83                         mul.f64
	<div+113 @05ffb1>  : 11 0d                      dup.x64 sp(13)
	<div+115 @05ffb3>  : 81                         add.f64
	<div+116 @05ffb4>  : 11 02                      dup.x64 sp(2)
	<div+118 @05ffb6>  : 84                         div.f64
	<div+119 @05ffb7>  : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:102: (13 bytes: <div+121 @05ffb9> - <div+134 @05ffc6>): .result.im := (a.im * r - a.re) / den;
	<div+121 @05ffb9>  : 11 0b                      dup.x64 sp(11)
	<div+123 @05ffbb>  : 11 04                      dup.x64 sp(4)
	<div+125 @05ffbd>  : 83                         mul.f64
	<div+126 @05ffbe>  : 11 0b                      dup.x64 sp(11)
	<div+128 @05ffc0>  : 82                         sub.f64
	<div+129 @05ffc1>  : 11 02                      dup.x64 sp(2)
	<div+131 @05ffc3>  : 84                         div.f64
	<div+132 @05ffc4>  : 14 11                      set.x64 sp(17)
	<div+134 @05ffc6>  : 09 f0 ff ff                inc.sp(-16)
	<div+138 @05ffca>  : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `div`
	cmplStd/lib/math/Complex.ci:173: referenced as `div`
	cmplStd/lib/math/Complex.ci:166: referenced as `div`
	cmplStd/lib/math/Complex.ci:164: referenced as `div`
	cmplStd/lib/math/Complex.ci:109: referenced as `div`
	cmplStd/lib/math/Complex.ci:107: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:107'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `div`
	cmplStd/lib/math/Complex.ci:169: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:109'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:112'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `abs`
	cmplStd/lib/math/Complex.ci:136: referenced as `abs`
	cmplStd/lib/math/Complex.ci:132: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:114'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `arg`
	cmplStd/lib/math/Complex.ci:137: referenced as `arg`
	cmplStd/lib/math/Complex.ci:132: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.offset: <@05ffd0>
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:117'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <inv @05ffd0> - <inv+31 @05ffef>)
	cmplStd/lib/math/Complex.ci:118: (11 bytes: <inv @05ffd0> - <inv+11 @05ffdb>): d: float64 := a.re * a.re + a.im * a.im
	<inv @05ffd0>      : 11 01                      dup.x64 sp(1)
	<inv+2 @05ffd2>    : 11 03                      dup.x64 sp(3)
	<inv+4 @05ffd4>    : 83                         mul.f64
	<inv+5 @05ffd5>    : 11 05                      dup.x64 sp(5)
	<inv+7 @05ffd7>    : 11 07                      dup.x64 sp(7)
	<inv+9 @05ffd9>    : 83                         mul.f64
	<inv+10 @05ffda>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:119: (20 bytes: <inv+11 @05ffdb> - <inv+31 @05ffef>): return .result := {...};
	cmplStd/lib/math/Complex.ci:120: (7 bytes: <inv+11 @05ffdb> - <inv+18 @05ffe2>): .result.re := +a.re / d;
	<inv+11 @05ffdb>   : 11 03                      dup.x64 sp(3)
	<inv+13 @05ffdd>   : 11 02                      dup.x64 sp(2)
	<inv+15 @05ffdf>   : 84                         div.f64
	<inv+16 @05ffe0>   : 14 09                      set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:121: (8 bytes: <inv+18 @05ffe2> - <inv+26 @05ffea>): .result.im := -a.im / d;
	<inv+18 @05ffe2>   : 11 05                      dup.x64 sp(5)
	<inv+20 @05ffe4>   : 80                         neg.f64
	<inv+21 @05ffe5>   : 11 02                      dup.x64 sp(2)
	<inv+23 @05ffe7>   : 84                         div.f64
	<inv+24 @05ffe8>   : 14 0b                      set.x64 sp(11)
	<inv+26 @05ffea>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @05ffee>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `inv`
	cmplStd/lib/math/Complex.ci:182: referenced as `inv`
	cmplStd/lib/math/Complex.ci:180: referenced as `inv`
	cmplStd/lib/math/Complex.ci:178: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 100
.offset: <@05fff0>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <pow @05fff0> - <pow+100 @060054>)
	cmplStd/lib/math/Complex.ci:136: (23 bytes: <pow @05fff0> - <pow+23 @060007>): r: float64 := abs(a)
	<pow @05fff0>      : 12 05                      dup.x128 sp(5)
	<pow+2 @05fff2>    : 11 00                      dup.x64 sp(0)
	<pow+4 @05fff4>    : 11 02                      dup.x64 sp(2)
	<pow+6 @05fff6>    : 83                         mul.f64
	<pow+7 @05fff7>    : 11 04                      dup.x64 sp(4)
	<pow+9 @05fff9>    : 11 06                      dup.x64 sp(6)
	<pow+11 @05fffb>   : 83                         mul.f64
	<pow+12 @05fffc>   : 81                         add.f64
	<pow+13 @05fffd>   : 01 2f 00 00                nfc(47) ;float64.sqrt(x: float64): float64
	<pow+17 @060001>   : 14 04                      set.x64 sp(4)
	<pow+19 @060003>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:137: (16 bytes: <pow+23 @060007> - <pow+39 @060017>): t: float64 := arg(a)
	<pow+23 @060007>   : 12 07                      dup.x128 sp(7)
	<pow+25 @060009>   : 11 00                      dup.x64 sp(0)
	<pow+27 @06000b>   : 11 04                      dup.x64 sp(4)
	<pow+29 @06000d>   : 01 30 00 00                nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @060011>   : 14 04                      set.x64 sp(4)
	<pow+35 @060013>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:138: (15 bytes: <pow+39 @060017> - <pow+54 @060026>): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+39 @060017>   : 11 05                      dup.x64 sp(5)
	<pow+41 @060019>   : 11 02                      dup.x64 sp(2)
	<pow+43 @06001b>   : 83                         mul.f64
	<pow+44 @06001c>   : 11 09                      dup.x64 sp(9)
	<pow+46 @06001e>   : 11 06                      dup.x64 sp(6)
	<pow+48 @060020>   : 01 2c 00 00                nfc(44) ;float64.log(x: float64): float64
	<pow+52 @060024>   : 83                         mul.f64
	<pow+53 @060025>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:139: (19 bytes: <pow+54 @060026> - <pow+73 @060039>): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+54 @060026>   : 11 04                      dup.x64 sp(4)
	<pow+56 @060028>   : 11 09                      dup.x64 sp(9)
	<pow+58 @06002a>   : 01 2e 00 00                nfc(46) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @06002e>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @060030>   : 80                         neg.f64
	<pow+65 @060031>   : 11 06                      dup.x64 sp(6)
	<pow+67 @060033>   : 83                         mul.f64
	<pow+68 @060034>   : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<pow+72 @060038>   : 83                         mul.f64
	cmplStd/lib/math/Complex.ci:140: (27 bytes: <pow+73 @060039> - <pow+100 @060054>): return .result := {...};
	cmplStd/lib/math/Complex.ci:141: (11 bytes: <pow+73 @060039> - <pow+84 @060044>): .result.re := v * float64.cos(u);
	<pow+73 @060039>   : 11 00                      dup.x64 sp(0)
	<pow+75 @06003b>   : 11 04                      dup.x64 sp(4)
	<pow+77 @06003d>   : 01 2a 00 00                nfc(42) ;float64.cos(x: float64): float64
	<pow+81 @060041>   : 83                         mul.f64
	<pow+82 @060042>   : 14 13                      set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:142: (11 bytes: <pow+84 @060044> - <pow+95 @06004f>): .result.im := v * float64.sin(u);
	<pow+84 @060044>   : 11 00                      dup.x64 sp(0)
	<pow+86 @060046>   : 11 04                      dup.x64 sp(4)
	<pow+88 @060048>   : 01 29 00 00                nfc(41) ;float64.sin(x: float64): float64
	<pow+92 @06004c>   : 83                         mul.f64
	<pow+93 @06004d>   : 14 15                      set.x64 sp(21)
	<pow+95 @06004f>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @060053>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:149'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:180: referenced as `sin`
	cmplStd/lib/math/Complex.ci:166: referenced as `sin`
	cmplStd/lib/math/Complex.ci:164: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:151'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:178: referenced as `cos`
	cmplStd/lib/math/Complex.ci:166: referenced as `cos`
	cmplStd/lib/math/Complex.ci:164: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:164'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:169'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:171'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:182: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:173'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:178'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:180'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:182'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:187'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:189'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@025010>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:141'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.param w: float32 (size: 4, offs: <+16>, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:128: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(void(vec4f(a), b))
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(void(a, vec4f(b)))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(vec4f(a), b))
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(a, vec4f(b)))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(vec4f(a), b))
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(a, vec4f(b)))
.usages:
}
div(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(vec4f(a), b))
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(a, vec4f(b)))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:102'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: vec4f (size: 16, offs: <+32>, cast: val)
.param max: vec4f (size: 16, offs: <+48>, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(void(max(void(vec, min)), max))
.usages:
	cmplStd/lib/math/Vector4f.ci:108: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: float32 (size: 4, offs: <+20>, cast: f32)
.param max: float32 (size: 4, offs: <+24>, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(void(void(vec, vec4f(min)), vec4f(max)))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:112'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:116'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:120'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:126'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:128'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@02a4a8>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:142: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:147: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:152: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@060058>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
}
.instructions: (49 bytes: <mat4f @060058> - <mat4f+49 @060089>)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes: <mat4f @060058> - <mat4f+49 @060089>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f @060058> - <mat4f+3 @06005b>): .result.xx := xx;
	<mat4f @060058>      : 16 11 10                   mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+3 @06005b> - <mat4f+6 @06005e>): .result.xy := xy;
	<mat4f+3 @06005b>    : 16 12 0f                   mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+6 @06005e> - <mat4f+9 @060061>): .result.xz := xz;
	<mat4f+6 @06005e>    : 16 13 0e                   mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+9 @060061> - <mat4f+12 @060064>): .result.xw := xw;
	<mat4f+9 @060061>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+12 @060064> - <mat4f+15 @060067>): .result.yx := yx;
	<mat4f+12 @060064>   : 16 15 0c                   mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+15 @060067> - <mat4f+18 @06006a>): .result.yy := yy;
	<mat4f+15 @060067>   : 16 16 0b                   mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+18 @06006a> - <mat4f+21 @06006d>): .result.yz := yz;
	<mat4f+18 @06006a>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+21 @06006d> - <mat4f+24 @060070>): .result.yw := yw;
	<mat4f+21 @06006d>   : 16 18 09                   mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+24 @060070> - <mat4f+27 @060073>): .result.zx := zx;
	<mat4f+24 @060070>   : 16 19 08                   mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+27 @060073> - <mat4f+30 @060076>): .result.zy := zy;
	<mat4f+27 @060073>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+30 @060076> - <mat4f+33 @060079>): .result.zz := zz;
	<mat4f+30 @060076>   : 16 1b 06                   mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+33 @060079> - <mat4f+36 @06007c>): .result.zw := zw;
	<mat4f+33 @060079>   : 16 1c 05                   mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+36 @06007c> - <mat4f+39 @06007f>): .result.wx := wx;
	<mat4f+36 @06007c>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+39 @06007f> - <mat4f+42 @060082>): .result.wy := wy;
	<mat4f+39 @06007f>   : 16 1e 03                   mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+42 @060082> - <mat4f+45 @060085>): .result.wz := wz;
	<mat4f+42 @060082>   : 16 1f 02                   mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+45 @060085> - <mat4f+48 @060088>): .result.ww := ww;
	<mat4f+45 @060085>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @060088>   : 03                         ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.offset: <@060090>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <mat4f @060090> - <mat4f+21 @0600a5>)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes: <mat4f @060090> - <mat4f+21 @0600a5>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f @060090> - <mat4f+5 @060095>): .result.x := x;
	<mat4f @060090>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @060092>    : 2a                         load.i128
	<mat4f+3 @060093>    : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+5 @060095> - <mat4f+10 @06009a>): .result.y := y;
	<mat4f+5 @060095>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @060097>    : 2a                         load.i128
	<mat4f+8 @060098>    : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+10 @06009a> - <mat4f+15 @06009f>): .result.z := z;
	<mat4f+10 @06009a>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @06009c>   : 2a                         load.i128
	<mat4f+13 @06009d>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+15 @06009f> - <mat4f+20 @0600a4>): .result.w := w;
	<mat4f+15 @06009f>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @0600a1>   : 2a                         load.i128
	<mat4f+18 @0600a2>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @0600a4>   : 03                         ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@0600a8>
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param mat: mat4f (size: 64, offs: <+128>, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
}
.instructions: (49 bytes: <transpose @0600a8> - <transpose+49 @0600d9>)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes: <transpose @0600a8> - <transpose+49 @0600d9>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose @0600a8> - <transpose+3 @0600ab>): .result.xx := mat.xx;
	<transpose @0600a8>      : 16 11 01                   mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+3 @0600ab> - <transpose+6 @0600ae>): .result.xy := mat.yx;
	<transpose+3 @0600ab>    : 16 12 05                   mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+6 @0600ae> - <transpose+9 @0600b1>): .result.xz := mat.zx;
	<transpose+6 @0600ae>    : 16 13 09                   mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+9 @0600b1> - <transpose+12 @0600b4>): .result.xw := mat.wx;
	<transpose+9 @0600b1>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+12 @0600b4> - <transpose+15 @0600b7>): .result.yx := mat.xy;
	<transpose+12 @0600b4>   : 16 15 02                   mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+15 @0600b7> - <transpose+18 @0600ba>): .result.yy := mat.yy;
	<transpose+15 @0600b7>   : 16 16 06                   mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+18 @0600ba> - <transpose+21 @0600bd>): .result.yz := mat.zy;
	<transpose+18 @0600ba>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+21 @0600bd> - <transpose+24 @0600c0>): .result.yw := mat.wy;
	<transpose+21 @0600bd>   : 16 18 0e                   mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+24 @0600c0> - <transpose+27 @0600c3>): .result.zx := mat.xz;
	<transpose+24 @0600c0>   : 16 19 03                   mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+27 @0600c3> - <transpose+30 @0600c6>): .result.zy := mat.yz;
	<transpose+27 @0600c3>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+30 @0600c6> - <transpose+33 @0600c9>): .result.zz := mat.zz;
	<transpose+30 @0600c6>   : 16 1b 0b                   mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+33 @0600c9> - <transpose+36 @0600cc>): .result.zw := mat.wz;
	<transpose+33 @0600c9>   : 16 1c 0f                   mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+36 @0600cc> - <transpose+39 @0600cf>): .result.wx := mat.xw;
	<transpose+36 @0600cc>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+39 @0600cf> - <transpose+42 @0600d2>): .result.wy := mat.yw;
	<transpose+39 @0600cf>   : 16 1e 08                   mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+42 @0600d2> - <transpose+45 @0600d5>): .result.wz := mat.zw;
	<transpose+42 @0600d2>   : 16 1f 0c                   mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+45 @0600d5> - <transpose+48 @0600d8>): .result.ww := mat.ww;
	<transpose+45 @0600d5>   : 16 20 10                   mov.x32 sp(32, 16)
	<transpose+48 @0600d8>   : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 245
.offset: <@0600e0>
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (245 bytes: <mul @0600e0> - <mul+245 @0601d5>)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes: <mul @0600e0> - <mul+28 @0600fc>): transposed: mat4f := transpose(rhs)
	<mul @0600e0>      : 09 40 00 00                inc.sp(+64)
	<mul+4 @0600e4>    : 10 11                      dup.x32 sp(17)
	<mul+6 @0600e6>    : 0a c4 ff ff                load.sp(-60)
	<mul+10 @0600ea>   : 1e c0 ff ff                copy.mem -64
	<mul+14 @0600ee>   : 09 40 00 00                inc.sp(+64)
	<mul+18 @0600f2>   : 1f a8 00 06 00             load.ref <@0600a8> ;transpose(mat: mat4f): mat4f
	<mul+23 @0600f7>   : 02                         call
	<mul+24 @0600f8>   : 09 c0 ff ff                inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (217 bytes: <mul+28 @0600fc> - <mul+245 @0601d5>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (50 bytes: <mul+28 @0600fc> - <mul+78 @06012e>): .result.x := dp4(transposed, lhs.x);
	<mul+28 @0600fc>   : 0a 00 00 00                load.sp(+0)
	<mul+32 @060100>   : 10 13                      dup.x32 sp(19)
	<mul+34 @060102>   : 10 01                      dup.x32 sp(1)
	<mul+36 @060104>   : 0c 30 00 00                inc.i32(+48)
	<mul+40 @060108>   : 2a                         load.i128
	<mul+41 @060109>   : 10 04                      dup.x32 sp(4)
	<mul+43 @06010b>   : 2a                         load.i128
	<mul+44 @06010c>   : 9b                         dp4.v4f
	<mul+45 @06010d>   : 10 02                      dup.x32 sp(2)
	<mul+47 @06010f>   : 0c 20 00 00                inc.i32(+32)
	<mul+51 @060113>   : 2a                         load.i128
	<mul+52 @060114>   : 10 05                      dup.x32 sp(5)
	<mul+54 @060116>   : 2a                         load.i128
	<mul+55 @060117>   : 9b                         dp4.v4f
	<mul+56 @060118>   : 10 03                      dup.x32 sp(3)
	<mul+58 @06011a>   : 0c 10 00 00                inc.i32(+16)
	<mul+62 @06011e>   : 2a                         load.i128
	<mul+63 @06011f>   : 10 06                      dup.x32 sp(6)
	<mul+65 @060121>   : 2a                         load.i128
	<mul+66 @060122>   : 9b                         dp4.v4f
	<mul+67 @060123>   : 10 04                      dup.x32 sp(4)
	<mul+69 @060125>   : 2a                         load.i128
	<mul+70 @060126>   : 10 07                      dup.x32 sp(7)
	<mul+72 @060128>   : 2a                         load.i128
	<mul+73 @060129>   : 9b                         dp4.v4f
	<mul+74 @06012a>   : 15 02                      set.x128 sp(2)
	<mul+76 @06012c>   : 15 17                      set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (54 bytes: <mul+78 @06012e> - <mul+132 @060164>): .result.y := dp4(transposed, lhs.y);
	<mul+78 @06012e>   : 0a 00 00 00                load.sp(+0)
	<mul+82 @060132>   : 10 13                      dup.x32 sp(19)
	<mul+84 @060134>   : 0c 10 00 00                inc.i32(+16)
	<mul+88 @060138>   : 10 01                      dup.x32 sp(1)
	<mul+90 @06013a>   : 0c 30 00 00                inc.i32(+48)
	<mul+94 @06013e>   : 2a                         load.i128
	<mul+95 @06013f>   : 10 04                      dup.x32 sp(4)
	<mul+97 @060141>   : 2a                         load.i128
	<mul+98 @060142>   : 9b                         dp4.v4f
	<mul+99 @060143>   : 10 02                      dup.x32 sp(2)
	<mul+101 @060145>  : 0c 20 00 00                inc.i32(+32)
	<mul+105 @060149>  : 2a                         load.i128
	<mul+106 @06014a>  : 10 05                      dup.x32 sp(5)
	<mul+108 @06014c>  : 2a                         load.i128
	<mul+109 @06014d>  : 9b                         dp4.v4f
	<mul+110 @06014e>  : 10 03                      dup.x32 sp(3)
	<mul+112 @060150>  : 0c 10 00 00                inc.i32(+16)
	<mul+116 @060154>  : 2a                         load.i128
	<mul+117 @060155>  : 10 06                      dup.x32 sp(6)
	<mul+119 @060157>  : 2a                         load.i128
	<mul+120 @060158>  : 9b                         dp4.v4f
	<mul+121 @060159>  : 10 04                      dup.x32 sp(4)
	<mul+123 @06015b>  : 2a                         load.i128
	<mul+124 @06015c>  : 10 07                      dup.x32 sp(7)
	<mul+126 @06015e>  : 2a                         load.i128
	<mul+127 @06015f>  : 9b                         dp4.v4f
	<mul+128 @060160>  : 15 02                      set.x128 sp(2)
	<mul+130 @060162>  : 15 1b                      set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (54 bytes: <mul+132 @060164> - <mul+186 @06019a>): .result.z := dp4(transposed, lhs.z);
	<mul+132 @060164>  : 0a 00 00 00                load.sp(+0)
	<mul+136 @060168>  : 10 13                      dup.x32 sp(19)
	<mul+138 @06016a>  : 0c 20 00 00                inc.i32(+32)
	<mul+142 @06016e>  : 10 01                      dup.x32 sp(1)
	<mul+144 @060170>  : 0c 30 00 00                inc.i32(+48)
	<mul+148 @060174>  : 2a                         load.i128
	<mul+149 @060175>  : 10 04                      dup.x32 sp(4)
	<mul+151 @060177>  : 2a                         load.i128
	<mul+152 @060178>  : 9b                         dp4.v4f
	<mul+153 @060179>  : 10 02                      dup.x32 sp(2)
	<mul+155 @06017b>  : 0c 20 00 00                inc.i32(+32)
	<mul+159 @06017f>  : 2a                         load.i128
	<mul+160 @060180>  : 10 05                      dup.x32 sp(5)
	<mul+162 @060182>  : 2a                         load.i128
	<mul+163 @060183>  : 9b                         dp4.v4f
	<mul+164 @060184>  : 10 03                      dup.x32 sp(3)
	<mul+166 @060186>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @06018a>  : 2a                         load.i128
	<mul+171 @06018b>  : 10 06                      dup.x32 sp(6)
	<mul+173 @06018d>  : 2a                         load.i128
	<mul+174 @06018e>  : 9b                         dp4.v4f
	<mul+175 @06018f>  : 10 04                      dup.x32 sp(4)
	<mul+177 @060191>  : 2a                         load.i128
	<mul+178 @060192>  : 10 07                      dup.x32 sp(7)
	<mul+180 @060194>  : 2a                         load.i128
	<mul+181 @060195>  : 9b                         dp4.v4f
	<mul+182 @060196>  : 15 02                      set.x128 sp(2)
	<mul+184 @060198>  : 15 1f                      set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (54 bytes: <mul+186 @06019a> - <mul+240 @0601d0>): .result.w := dp4(transposed, lhs.w);
	<mul+186 @06019a>  : 0a 00 00 00                load.sp(+0)
	<mul+190 @06019e>  : 10 13                      dup.x32 sp(19)
	<mul+192 @0601a0>  : 0c 30 00 00                inc.i32(+48)
	<mul+196 @0601a4>  : 10 01                      dup.x32 sp(1)
	<mul+198 @0601a6>  : 0c 30 00 00                inc.i32(+48)
	<mul+202 @0601aa>  : 2a                         load.i128
	<mul+203 @0601ab>  : 10 04                      dup.x32 sp(4)
	<mul+205 @0601ad>  : 2a                         load.i128
	<mul+206 @0601ae>  : 9b                         dp4.v4f
	<mul+207 @0601af>  : 10 02                      dup.x32 sp(2)
	<mul+209 @0601b1>  : 0c 20 00 00                inc.i32(+32)
	<mul+213 @0601b5>  : 2a                         load.i128
	<mul+214 @0601b6>  : 10 05                      dup.x32 sp(5)
	<mul+216 @0601b8>  : 2a                         load.i128
	<mul+217 @0601b9>  : 9b                         dp4.v4f
	<mul+218 @0601ba>  : 10 03                      dup.x32 sp(3)
	<mul+220 @0601bc>  : 0c 10 00 00                inc.i32(+16)
	<mul+224 @0601c0>  : 2a                         load.i128
	<mul+225 @0601c1>  : 10 06                      dup.x32 sp(6)
	<mul+227 @0601c3>  : 2a                         load.i128
	<mul+228 @0601c4>  : 9b                         dp4.v4f
	<mul+229 @0601c5>  : 10 04                      dup.x32 sp(4)
	<mul+231 @0601c7>  : 2a                         load.i128
	<mul+232 @0601c8>  : 10 07                      dup.x32 sp(7)
	<mul+234 @0601ca>  : 2a                         load.i128
	<mul+235 @0601cb>  : 9b                         dp4.v4f
	<mul+236 @0601cc>  : 15 02                      set.x128 sp(2)
	<mul+238 @0601ce>  : 15 23                      set.x128 sp(35)
	<mul+240 @0601d0>  : 09 c0 ff ff                inc.sp(-64)
	<mul+244 @0601d4>  : 03                         ret
.usages:
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 454
.offset: <@0601d8>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (454 bytes: <rotation @0601d8> - <rotation+454 @06039e>)
	cmplStd/lib/math/Matrix4f.ci:112: (18 bytes: <rotation @0601d8> - <rotation+18 @0601ea>): len: float32 := length(direction)
	<rotation @0601d8>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @0601da>    : 2a                         load.i128
	<rotation+3 @0601db>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @0601dd>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @0601df>    : 9a                         dp3.v4f
	<rotation+8 @0601e0>    : 01 27 00 00                nfc(39) ;float32.sqrt(x: float32): float32
	<rotation+12 @0601e4>   : 13 04                      set.x32 sp(4)
	<rotation+14 @0601e6>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math/Matrix4f.ci:113: (82 bytes: <rotation+18 @0601ea> - <rotation+100 @06023c>): if ((len) < 0.000000)
	<rotation+18 @0601ea>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @0601ec>   : 7d                         f32.2f64
	<rotation+21 @0601ed>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @0601f6>   : 88                         clt.f64
	<rotation+31 @0601f7>   : 06 45 00 00                jz <rotation+100 @06023c>
	cmplStd/lib/math/Matrix4f.ci:114: (36 bytes: <rotation+35 @0601fb> - <rotation+71 @06021f>): trace("invalid direction of rotation", direction);
	<rotation+35 @0601fb>   : 1f 58 a1 02 00             load.ref <@02a158> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+40 @060200>   : 1c 72 00 00 00             load.c32 114
	<rotation+45 @060205>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @06020a>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @06020f>   : 1f 15 a4 02 00             load.ref <@02a415> ;"invalid direction of rotation"
	<rotation+60 @060214>   : 1f 10 50 02 00             load.ref <@025010> ;vec4f
	<rotation+65 @060219>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @06021b>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/math/Matrix4f.ci:115: (29 bytes: <rotation+71 @06021f> - <rotation+100 @06023c>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes: <rotation+71 @06021f> - <rotation+77 @060225>): .result.x := vec4f(0, 0, 0, 0);
	<rotation+71 @06021f>   : 19                         load.z32
	<rotation+72 @060220>   : 19                         load.z32
	<rotation+73 @060221>   : 19                         load.z32
	<rotation+74 @060222>   : 19                         load.z32
	<rotation+75 @060223>   : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes: <rotation+77 @060225> - <rotation+83 @06022b>): .result.y := vec4f(0, 0, 0, 0);
	<rotation+77 @060225>   : 19                         load.z32
	<rotation+78 @060226>   : 19                         load.z32
	<rotation+79 @060227>   : 19                         load.z32
	<rotation+80 @060228>   : 19                         load.z32
	<rotation+81 @060229>   : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:118: (6 bytes: <rotation+83 @06022b> - <rotation+89 @060231>): .result.z := vec4f(0, 0, 0, 0);
	<rotation+83 @06022b>   : 19                         load.z32
	<rotation+84 @06022c>   : 19                         load.z32
	<rotation+85 @06022d>   : 19                         load.z32
	<rotation+86 @06022e>   : 19                         load.z32
	<rotation+87 @06022f>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:119: (6 bytes: <rotation+89 @060231> - <rotation+95 @060237>): .result.w := vec4f(0, 0, 0, 0);
	<rotation+89 @060231>   : 19                         load.z32
	<rotation+90 @060232>   : 19                         load.z32
	<rotation+91 @060233>   : 19                         load.z32
	<rotation+92 @060234>   : 19                         load.z32
	<rotation+93 @060235>   : 15 15                      set.x128 sp(21)
	<rotation+95 @060237>   : 09 fc ff ff                inc.sp(-4)
	<rotation+99 @06023b>   : 03                         ret
	cmplStd/lib/math/Matrix4f.ci:122: (6 bytes: <rotation+100 @06023c> - <rotation+106 @060242>): x: float32 := direction.x / len
	<rotation+100 @06023c>  : 10 03                      dup.x32 sp(3)
	<rotation+102 @06023e>  : 28                         load.i32
	<rotation+103 @06023f>  : 10 01                      dup.x32 sp(1)
	<rotation+105 @060241>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (10 bytes: <rotation+106 @060242> - <rotation+116 @06024c>): y: float32 := direction.y / len
	<rotation+106 @060242>  : 10 04                      dup.x32 sp(4)
	<rotation+108 @060244>  : 0c 04 00 00                inc.i32(+4)
	<rotation+112 @060248>  : 28                         load.i32
	<rotation+113 @060249>  : 10 02                      dup.x32 sp(2)
	<rotation+115 @06024b>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:124: (10 bytes: <rotation+116 @06024c> - <rotation+126 @060256>): z: float32 := direction.z / len
	<rotation+116 @06024c>  : 10 05                      dup.x32 sp(5)
	<rotation+118 @06024e>  : 0c 08 00 00                inc.i32(+8)
	<rotation+122 @060252>  : 28                         load.i32
	<rotation+123 @060253>  : 10 03                      dup.x32 sp(3)
	<rotation+125 @060255>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:125: (3 bytes: <rotation+126 @060256> - <rotation+129 @060259>): cx: float32 := center.x
	<rotation+126 @060256>  : 10 07                      dup.x32 sp(7)
	<rotation+128 @060258>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (7 bytes: <rotation+129 @060259> - <rotation+136 @060260>): cy: float32 := center.y
	<rotation+129 @060259>  : 10 08                      dup.x32 sp(8)
	<rotation+131 @06025b>  : 0c 04 00 00                inc.i32(+4)
	<rotation+135 @06025f>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:127: (7 bytes: <rotation+136 @060260> - <rotation+143 @060267>): cz: float32 := center.z
	<rotation+136 @060260>  : 10 09                      dup.x32 sp(9)
	<rotation+138 @060262>  : 0c 08 00 00                inc.i32(+8)
	<rotation+142 @060266>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes: <rotation+143 @060267> - <rotation+148 @06026c>): xx: float32 := x * x
	<rotation+143 @060267>  : 10 05                      dup.x32 sp(5)
	<rotation+145 @060269>  : 10 06                      dup.x32 sp(6)
	<rotation+147 @06026b>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes: <rotation+148 @06026c> - <rotation+153 @060271>): xy: float32 := x * y
	<rotation+148 @06026c>  : 10 06                      dup.x32 sp(6)
	<rotation+150 @06026e>  : 10 06                      dup.x32 sp(6)
	<rotation+152 @060270>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes: <rotation+153 @060271> - <rotation+158 @060276>): xz: float32 := x * z
	<rotation+153 @060271>  : 10 07                      dup.x32 sp(7)
	<rotation+155 @060273>  : 10 06                      dup.x32 sp(6)
	<rotation+157 @060275>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes: <rotation+158 @060276> - <rotation+163 @06027b>): yy: float32 := y * y
	<rotation+158 @060276>  : 10 07                      dup.x32 sp(7)
	<rotation+160 @060278>  : 10 08                      dup.x32 sp(8)
	<rotation+162 @06027a>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:132: (5 bytes: <rotation+163 @06027b> - <rotation+168 @060280>): yz: float32 := y * z
	<rotation+163 @06027b>  : 10 08                      dup.x32 sp(8)
	<rotation+165 @06027d>  : 10 08                      dup.x32 sp(8)
	<rotation+167 @06027f>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (5 bytes: <rotation+168 @060280> - <rotation+173 @060285>): zz: float32 := z * z
	<rotation+168 @060280>  : 10 08                      dup.x32 sp(8)
	<rotation+170 @060282>  : 10 09                      dup.x32 sp(9)
	<rotation+172 @060284>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:135: (6 bytes: <rotation+173 @060285> - <rotation+179 @06028b>): s: float32 := float32.sin(angle)
	<rotation+173 @060285>  : 10 0e                      dup.x32 sp(14)
	<rotation+175 @060287>  : 01 21 00 00                nfc(33) ;float32.sin(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:136: (6 bytes: <rotation+179 @06028b> - <rotation+185 @060291>): c: float32 := float32.cos(angle)
	<rotation+179 @06028b>  : 10 0f                      dup.x32 sp(15)
	<rotation+181 @06028d>  : 01 22 00 00                nfc(34) ;float32.cos(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:137: (8 bytes: <rotation+185 @060291> - <rotation+193 @060299>): k: float32 := (1) - c
	<rotation+185 @060291>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+190 @060296>  : 10 01                      dup.x32 sp(1)
	<rotation+192 @060298>  : 72                         sub.f32
	cmplStd/lib/math/Matrix4f.ci:139: (261 bytes: <rotation+193 @060299> - <rotation+454 @06039e>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes: <rotation+193 @060299> - <rotation+206 @0602a6>): .result.xx := xx + (yy + zz) * c;
	<rotation+193 @060299>  : 10 08                      dup.x32 sp(8)
	<rotation+195 @06029b>  : 10 06                      dup.x32 sp(6)
	<rotation+197 @06029d>  : 10 05                      dup.x32 sp(5)
	<rotation+199 @06029f>  : 71                         add.f32
	<rotation+200 @0602a0>  : 10 03                      dup.x32 sp(3)
	<rotation+202 @0602a2>  : 73                         mul.f32
	<rotation+203 @0602a3>  : 71                         add.f32
	<rotation+204 @0602a4>  : 13 15                      set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:141: (13 bytes: <rotation+206 @0602a6> - <rotation+219 @0602b3>): .result.xy := xy * k - z * s;
	<rotation+206 @0602a6>  : 10 07                      dup.x32 sp(7)
	<rotation+208 @0602a8>  : 10 01                      dup.x32 sp(1)
	<rotation+210 @0602aa>  : 73                         mul.f32
	<rotation+211 @0602ab>  : 10 0d                      dup.x32 sp(13)
	<rotation+213 @0602ad>  : 10 04                      dup.x32 sp(4)
	<rotation+215 @0602af>  : 73                         mul.f32
	<rotation+216 @0602b0>  : 72                         sub.f32
	<rotation+217 @0602b1>  : 13 16                      set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:142: (13 bytes: <rotation+219 @0602b3> - <rotation+232 @0602c0>): .result.xz := xz * k + y * s;
	<rotation+219 @0602b3>  : 10 06                      dup.x32 sp(6)
	<rotation+221 @0602b5>  : 10 01                      dup.x32 sp(1)
	<rotation+223 @0602b7>  : 73                         mul.f32
	<rotation+224 @0602b8>  : 10 0e                      dup.x32 sp(14)
	<rotation+226 @0602ba>  : 10 04                      dup.x32 sp(4)
	<rotation+228 @0602bc>  : 73                         mul.f32
	<rotation+229 @0602bd>  : 71                         add.f32
	<rotation+230 @0602be>  : 13 17                      set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:143: (43 bytes: <rotation+232 @0602c0> - <rotation+275 @0602eb>): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+232 @0602c0>  : 10 0b                      dup.x32 sp(11)
	<rotation+234 @0602c2>  : 10 06                      dup.x32 sp(6)
	<rotation+236 @0602c4>  : 10 05                      dup.x32 sp(5)
	<rotation+238 @0602c6>  : 71                         add.f32
	<rotation+239 @0602c7>  : 73                         mul.f32
	<rotation+240 @0602c8>  : 10 0f                      dup.x32 sp(15)
	<rotation+242 @0602ca>  : 10 0c                      dup.x32 sp(12)
	<rotation+244 @0602cc>  : 10 10                      dup.x32 sp(16)
	<rotation+246 @0602ce>  : 73                         mul.f32
	<rotation+247 @0602cf>  : 10 0c                      dup.x32 sp(12)
	<rotation+249 @0602d1>  : 10 10                      dup.x32 sp(16)
	<rotation+251 @0602d3>  : 73                         mul.f32
	<rotation+252 @0602d4>  : 71                         add.f32
	<rotation+253 @0602d5>  : 73                         mul.f32
	<rotation+254 @0602d6>  : 72                         sub.f32
	<rotation+255 @0602d7>  : 10 01                      dup.x32 sp(1)
	<rotation+257 @0602d9>  : 73                         mul.f32
	<rotation+258 @0602da>  : 10 0b                      dup.x32 sp(11)
	<rotation+260 @0602dc>  : 10 0e                      dup.x32 sp(14)
	<rotation+262 @0602de>  : 73                         mul.f32
	<rotation+263 @0602df>  : 10 0b                      dup.x32 sp(11)
	<rotation+265 @0602e1>  : 10 10                      dup.x32 sp(16)
	<rotation+267 @0602e3>  : 73                         mul.f32
	<rotation+268 @0602e4>  : 72                         sub.f32
	<rotation+269 @0602e5>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @0602e7>  : 73                         mul.f32
	<rotation+272 @0602e8>  : 71                         add.f32
	<rotation+273 @0602e9>  : 13 18                      set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes: <rotation+275 @0602eb> - <rotation+288 @0602f8>): .result.yx := xy * k + z * s;
	<rotation+275 @0602eb>  : 10 07                      dup.x32 sp(7)
	<rotation+277 @0602ed>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @0602ef>  : 73                         mul.f32
	<rotation+280 @0602f0>  : 10 0d                      dup.x32 sp(13)
	<rotation+282 @0602f2>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @0602f4>  : 73                         mul.f32
	<rotation+285 @0602f5>  : 71                         add.f32
	<rotation+286 @0602f6>  : 13 19                      set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:146: (13 bytes: <rotation+288 @0602f8> - <rotation+301 @060305>): .result.yy := yy + (xx + zz) * c;
	<rotation+288 @0602f8>  : 10 05                      dup.x32 sp(5)
	<rotation+290 @0602fa>  : 10 09                      dup.x32 sp(9)
	<rotation+292 @0602fc>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @0602fe>  : 71                         add.f32
	<rotation+295 @0602ff>  : 10 03                      dup.x32 sp(3)
	<rotation+297 @060301>  : 73                         mul.f32
	<rotation+298 @060302>  : 71                         add.f32
	<rotation+299 @060303>  : 13 1a                      set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:147: (13 bytes: <rotation+301 @060305> - <rotation+314 @060312>): .result.yz := yz * k - x * s;
	<rotation+301 @060305>  : 10 04                      dup.x32 sp(4)
	<rotation+303 @060307>  : 10 01                      dup.x32 sp(1)
	<rotation+305 @060309>  : 73                         mul.f32
	<rotation+306 @06030a>  : 10 0f                      dup.x32 sp(15)
	<rotation+308 @06030c>  : 10 04                      dup.x32 sp(4)
	<rotation+310 @06030e>  : 73                         mul.f32
	<rotation+311 @06030f>  : 72                         sub.f32
	<rotation+312 @060310>  : 13 1b                      set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:148: (43 bytes: <rotation+314 @060312> - <rotation+357 @06033d>): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+314 @060312>  : 10 0a                      dup.x32 sp(10)
	<rotation+316 @060314>  : 10 09                      dup.x32 sp(9)
	<rotation+318 @060316>  : 10 05                      dup.x32 sp(5)
	<rotation+320 @060318>  : 71                         add.f32
	<rotation+321 @060319>  : 73                         mul.f32
	<rotation+322 @06031a>  : 10 0e                      dup.x32 sp(14)
	<rotation+324 @06031c>  : 10 0d                      dup.x32 sp(13)
	<rotation+326 @06031e>  : 10 11                      dup.x32 sp(17)
	<rotation+328 @060320>  : 73                         mul.f32
	<rotation+329 @060321>  : 10 0c                      dup.x32 sp(12)
	<rotation+331 @060323>  : 10 10                      dup.x32 sp(16)
	<rotation+333 @060325>  : 73                         mul.f32
	<rotation+334 @060326>  : 71                         add.f32
	<rotation+335 @060327>  : 73                         mul.f32
	<rotation+336 @060328>  : 72                         sub.f32
	<rotation+337 @060329>  : 10 01                      dup.x32 sp(1)
	<rotation+339 @06032b>  : 73                         mul.f32
	<rotation+340 @06032c>  : 10 0a                      dup.x32 sp(10)
	<rotation+342 @06032e>  : 10 10                      dup.x32 sp(16)
	<rotation+344 @060330>  : 73                         mul.f32
	<rotation+345 @060331>  : 10 0d                      dup.x32 sp(13)
	<rotation+347 @060333>  : 10 0f                      dup.x32 sp(15)
	<rotation+349 @060335>  : 73                         mul.f32
	<rotation+350 @060336>  : 72                         sub.f32
	<rotation+351 @060337>  : 10 04                      dup.x32 sp(4)
	<rotation+353 @060339>  : 73                         mul.f32
	<rotation+354 @06033a>  : 71                         add.f32
	<rotation+355 @06033b>  : 13 1c                      set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes: <rotation+357 @06033d> - <rotation+370 @06034a>): .result.zx := xz * k - y * s;
	<rotation+357 @06033d>  : 10 06                      dup.x32 sp(6)
	<rotation+359 @06033f>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @060341>  : 73                         mul.f32
	<rotation+362 @060342>  : 10 0e                      dup.x32 sp(14)
	<rotation+364 @060344>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @060346>  : 73                         mul.f32
	<rotation+367 @060347>  : 72                         sub.f32
	<rotation+368 @060348>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:151: (13 bytes: <rotation+370 @06034a> - <rotation+383 @060357>): .result.zy := yz * k + x * s;
	<rotation+370 @06034a>  : 10 04                      dup.x32 sp(4)
	<rotation+372 @06034c>  : 10 01                      dup.x32 sp(1)
	<rotation+374 @06034e>  : 73                         mul.f32
	<rotation+375 @06034f>  : 10 0f                      dup.x32 sp(15)
	<rotation+377 @060351>  : 10 04                      dup.x32 sp(4)
	<rotation+379 @060353>  : 73                         mul.f32
	<rotation+380 @060354>  : 71                         add.f32
	<rotation+381 @060355>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:152: (13 bytes: <rotation+383 @060357> - <rotation+396 @060364>): .result.zz := zz + (xx + yy) * c;
	<rotation+383 @060357>  : 10 03                      dup.x32 sp(3)
	<rotation+385 @060359>  : 10 09                      dup.x32 sp(9)
	<rotation+387 @06035b>  : 10 07                      dup.x32 sp(7)
	<rotation+389 @06035d>  : 71                         add.f32
	<rotation+390 @06035e>  : 10 03                      dup.x32 sp(3)
	<rotation+392 @060360>  : 73                         mul.f32
	<rotation+393 @060361>  : 71                         add.f32
	<rotation+394 @060362>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:153: (43 bytes: <rotation+396 @060364> - <rotation+439 @06038f>): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+396 @060364>  : 10 09                      dup.x32 sp(9)
	<rotation+398 @060366>  : 10 09                      dup.x32 sp(9)
	<rotation+400 @060368>  : 10 07                      dup.x32 sp(7)
	<rotation+402 @06036a>  : 71                         add.f32
	<rotation+403 @06036b>  : 73                         mul.f32
	<rotation+404 @06036c>  : 10 0d                      dup.x32 sp(13)
	<rotation+406 @06036e>  : 10 0d                      dup.x32 sp(13)
	<rotation+408 @060370>  : 10 11                      dup.x32 sp(17)
	<rotation+410 @060372>  : 73                         mul.f32
	<rotation+411 @060373>  : 10 0d                      dup.x32 sp(13)
	<rotation+413 @060375>  : 10 11                      dup.x32 sp(17)
	<rotation+415 @060377>  : 73                         mul.f32
	<rotation+416 @060378>  : 71                         add.f32
	<rotation+417 @060379>  : 73                         mul.f32
	<rotation+418 @06037a>  : 72                         sub.f32
	<rotation+419 @06037b>  : 10 01                      dup.x32 sp(1)
	<rotation+421 @06037d>  : 73                         mul.f32
	<rotation+422 @06037e>  : 10 0c                      dup.x32 sp(12)
	<rotation+424 @060380>  : 10 0f                      dup.x32 sp(15)
	<rotation+426 @060382>  : 73                         mul.f32
	<rotation+427 @060383>  : 10 0c                      dup.x32 sp(12)
	<rotation+429 @060385>  : 10 11                      dup.x32 sp(17)
	<rotation+431 @060387>  : 73                         mul.f32
	<rotation+432 @060388>  : 72                         sub.f32
	<rotation+433 @060389>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @06038b>  : 73                         mul.f32
	<rotation+436 @06038c>  : 71                         add.f32
	<rotation+437 @06038d>  : 13 20                      set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:155: (10 bytes: <rotation+439 @06038f> - <rotation+449 @060399>): .result.w := vec4f(0, 0, 0, 1);
	<rotation+439 @06038f>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+444 @060394>  : 19                         load.z32
	<rotation+445 @060395>  : 19                         load.z32
	<rotation+446 @060396>  : 19                         load.z32
	<rotation+447 @060397>  : 15 24                      set.x128 sp(36)
	<rotation+449 @060399>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+453 @06039d>  : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `rotation`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.offset: <@0603a0>
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:163'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (88 bytes: <translation @0603a0> - <translation+88 @0603f8>)
	cmplStd/lib/math/Matrix4f.ci:164: (88 bytes: <translation @0603a0> - <translation+88 @0603f8>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:165: (7 bytes: <translation @0603a0> - <translation+7 @0603a7>): .result.xx := (1);
	<translation @0603a0>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @0603a5>    : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes: <translation+7 @0603a7> - <translation+10 @0603aa>): .result.xy := (0);
	<translation+7 @0603a7>    : 19                         load.z32
	<translation+8 @0603a8>    : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes: <translation+10 @0603aa> - <translation+13 @0603ad>): .result.xz := (0);
	<translation+10 @0603aa>   : 19                         load.z32
	<translation+11 @0603ab>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:165: (8 bytes: <translation+13 @0603ad> - <translation+21 @0603b5>): .result.xw := direction.x * amount;
	<translation+13 @0603ad>   : 10 02                      dup.x32 sp(2)
	<translation+15 @0603af>   : 28                         load.i32
	<translation+16 @0603b0>   : 10 02                      dup.x32 sp(2)
	<translation+18 @0603b2>   : 73                         mul.f32
	<translation+19 @0603b3>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes: <translation+21 @0603b5> - <translation+24 @0603b8>): .result.yx := (0);
	<translation+21 @0603b5>   : 19                         load.z32
	<translation+22 @0603b6>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:166: (7 bytes: <translation+24 @0603b8> - <translation+31 @0603bf>): .result.yy := (1);
	<translation+24 @0603b8>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @0603bd>   : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes: <translation+31 @0603bf> - <translation+34 @0603c2>): .result.yz := (0);
	<translation+31 @0603bf>   : 19                         load.z32
	<translation+32 @0603c0>   : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:166: (12 bytes: <translation+34 @0603c2> - <translation+46 @0603ce>): .result.yw := direction.y * amount;
	<translation+34 @0603c2>   : 10 02                      dup.x32 sp(2)
	<translation+36 @0603c4>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @0603c8>   : 28                         load.i32
	<translation+41 @0603c9>   : 10 02                      dup.x32 sp(2)
	<translation+43 @0603cb>   : 73                         mul.f32
	<translation+44 @0603cc>   : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes: <translation+46 @0603ce> - <translation+49 @0603d1>): .result.zx := (0);
	<translation+46 @0603ce>   : 19                         load.z32
	<translation+47 @0603cf>   : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes: <translation+49 @0603d1> - <translation+52 @0603d4>): .result.zy := (0);
	<translation+49 @0603d1>   : 19                         load.z32
	<translation+50 @0603d2>   : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:167: (7 bytes: <translation+52 @0603d4> - <translation+59 @0603db>): .result.zz := (1);
	<translation+52 @0603d4>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @0603d9>   : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:167: (12 bytes: <translation+59 @0603db> - <translation+71 @0603e7>): .result.zw := direction.z * amount;
	<translation+59 @0603db>   : 10 02                      dup.x32 sp(2)
	<translation+61 @0603dd>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @0603e1>   : 28                         load.i32
	<translation+66 @0603e2>   : 10 02                      dup.x32 sp(2)
	<translation+68 @0603e4>   : 73                         mul.f32
	<translation+69 @0603e5>   : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+71 @0603e7> - <translation+74 @0603ea>): .result.wx := (0);
	<translation+71 @0603e7>   : 19                         load.z32
	<translation+72 @0603e8>   : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+74 @0603ea> - <translation+77 @0603ed>): .result.wy := (0);
	<translation+74 @0603ea>   : 19                         load.z32
	<translation+75 @0603eb>   : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+77 @0603ed> - <translation+80 @0603f0>): .result.wz := (0);
	<translation+77 @0603ed>   : 19                         load.z32
	<translation+78 @0603ee>   : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:168: (7 bytes: <translation+80 @0603f0> - <translation+87 @0603f7>): .result.ww := (1);
	<translation+80 @0603f0>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @0603f5>   : 13 13                      set.x32 sp(19)
	<translation+87 @0603f7>   : 03                         ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.offset: <@0603f8>
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:173'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (217 bytes: <scale @0603f8> - <scale+217 @0604d1>)
	cmplStd/lib/math/Matrix4f.ci:175: (217 bytes: <scale @0603f8> - <scale+217 @0604d1>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:176: (55 bytes: <scale @0603f8> - <scale+55 @06042f>): .result.xx := rcp(direction.x * amount);
	<scale @0603f8>      : 10 02                      dup.x32 sp(2)
	<scale+2 @0603fa>    : 28                         load.i32
	<scale+3 @0603fb>    : 10 02                      dup.x32 sp(2)
	<scale+5 @0603fd>    : 73                         mul.f32
	<scale+6 @0603fe>    : 10 00                      dup.x32 sp(0)
	<scale+8 @060400>    : 19                         load.z32
	<scale+9 @060401>    : 78                         clt.f32
	<scale+10 @060402>   : 06 0b 00 00                jz <scale+21 @06040d>
	<scale+14 @060406>   : 10 00                      dup.x32 sp(0)
	<scale+16 @060408>   : 70                         neg.f32
	<scale+17 @060409>   : 04 06 00 00                jmp <scale+23 @06040f>
	<scale+21 @06040d>   : 10 00                      dup.x32 sp(0)
	<scale+23 @06040f>   : 7d                         f32.2f64
	<scale+24 @060410>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @060419>   : 88                         clt.f64
	<scale+34 @06041a>   : 06 09 00 00                jz <scale+43 @060423>
	<scale+38 @06041e>   : 19                         load.z32
	<scale+39 @06041f>   : 04 0c 00 00                jmp <scale+51 @06042b>
	<scale+43 @060423>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @060428>   : 10 01                      dup.x32 sp(1)
	<scale+50 @06042a>   : 74                         div.f32
	<scale+51 @06042b>   : 13 01                      set.x32 sp(1)
	<scale+53 @06042d>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+55 @06042f> - <scale+58 @060432>): .result.xy := (0);
	<scale+55 @06042f>   : 19                         load.z32
	<scale+56 @060430>   : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+58 @060432> - <scale+61 @060435>): .result.xz := (0);
	<scale+58 @060432>   : 19                         load.z32
	<scale+59 @060433>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+61 @060435> - <scale+64 @060438>): .result.xw := (0);
	<scale+61 @060435>   : 19                         load.z32
	<scale+62 @060436>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+64 @060438> - <scale+67 @06043b>): .result.yx := (0);
	<scale+64 @060438>   : 19                         load.z32
	<scale+65 @060439>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:177: (59 bytes: <scale+67 @06043b> - <scale+126 @060476>): .result.yy := rcp(direction.y * amount);
	<scale+67 @06043b>   : 10 02                      dup.x32 sp(2)
	<scale+69 @06043d>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @060441>   : 28                         load.i32
	<scale+74 @060442>   : 10 02                      dup.x32 sp(2)
	<scale+76 @060444>   : 73                         mul.f32
	<scale+77 @060445>   : 10 00                      dup.x32 sp(0)
	<scale+79 @060447>   : 19                         load.z32
	<scale+80 @060448>   : 78                         clt.f32
	<scale+81 @060449>   : 06 0b 00 00                jz <scale+92 @060454>
	<scale+85 @06044d>   : 10 00                      dup.x32 sp(0)
	<scale+87 @06044f>   : 70                         neg.f32
	<scale+88 @060450>   : 04 06 00 00                jmp <scale+94 @060456>
	<scale+92 @060454>   : 10 00                      dup.x32 sp(0)
	<scale+94 @060456>   : 7d                         f32.2f64
	<scale+95 @060457>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @060460>  : 88                         clt.f64
	<scale+105 @060461>  : 06 09 00 00                jz <scale+114 @06046a>
	<scale+109 @060465>  : 19                         load.z32
	<scale+110 @060466>  : 04 0c 00 00                jmp <scale+122 @060472>
	<scale+114 @06046a>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @06046f>  : 10 01                      dup.x32 sp(1)
	<scale+121 @060471>  : 74                         div.f32
	<scale+122 @060472>  : 13 01                      set.x32 sp(1)
	<scale+124 @060474>  : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+126 @060476> - <scale+129 @060479>): .result.yz := (0);
	<scale+126 @060476>  : 19                         load.z32
	<scale+127 @060477>  : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+129 @060479> - <scale+132 @06047c>): .result.yw := (0);
	<scale+129 @060479>  : 19                         load.z32
	<scale+130 @06047a>  : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+132 @06047c> - <scale+135 @06047f>): .result.zx := (0);
	<scale+132 @06047c>  : 19                         load.z32
	<scale+133 @06047d>  : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+135 @06047f> - <scale+138 @060482>): .result.zy := (0);
	<scale+135 @06047f>  : 19                         load.z32
	<scale+136 @060480>  : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:178: (59 bytes: <scale+138 @060482> - <scale+197 @0604bd>): .result.zz := rcp(direction.z * amount);
	<scale+138 @060482>  : 10 02                      dup.x32 sp(2)
	<scale+140 @060484>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @060488>  : 28                         load.i32
	<scale+145 @060489>  : 10 02                      dup.x32 sp(2)
	<scale+147 @06048b>  : 73                         mul.f32
	<scale+148 @06048c>  : 10 00                      dup.x32 sp(0)
	<scale+150 @06048e>  : 19                         load.z32
	<scale+151 @06048f>  : 78                         clt.f32
	<scale+152 @060490>  : 06 0b 00 00                jz <scale+163 @06049b>
	<scale+156 @060494>  : 10 00                      dup.x32 sp(0)
	<scale+158 @060496>  : 70                         neg.f32
	<scale+159 @060497>  : 04 06 00 00                jmp <scale+165 @06049d>
	<scale+163 @06049b>  : 10 00                      dup.x32 sp(0)
	<scale+165 @06049d>  : 7d                         f32.2f64
	<scale+166 @06049e>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @0604a7>  : 88                         clt.f64
	<scale+176 @0604a8>  : 06 09 00 00                jz <scale+185 @0604b1>
	<scale+180 @0604ac>  : 19                         load.z32
	<scale+181 @0604ad>  : 04 0c 00 00                jmp <scale+193 @0604b9>
	<scale+185 @0604b1>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @0604b6>  : 10 01                      dup.x32 sp(1)
	<scale+192 @0604b8>  : 74                         div.f32
	<scale+193 @0604b9>  : 13 01                      set.x32 sp(1)
	<scale+195 @0604bb>  : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+197 @0604bd> - <scale+200 @0604c0>): .result.zw := (0);
	<scale+197 @0604bd>  : 19                         load.z32
	<scale+198 @0604be>  : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+200 @0604c0> - <scale+203 @0604c3>): .result.wx := (0);
	<scale+200 @0604c0>  : 19                         load.z32
	<scale+201 @0604c1>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+203 @0604c3> - <scale+206 @0604c6>): .result.wy := (0);
	<scale+203 @0604c3>  : 19                         load.z32
	<scale+204 @0604c4>  : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+206 @0604c6> - <scale+209 @0604c9>): .result.wz := (0);
	<scale+206 @0604c6>  : 19                         load.z32
	<scale+207 @0604c7>  : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:179: (7 bytes: <scale+209 @0604c9> - <scale+216 @0604d0>): .result.ww := (1);
	<scale+209 @0604c9>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @0604ce>  : 13 13                      set.x32 sp(19)
	<scale+216 @0604d0>  : 03                         ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02f988>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@0604d8>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <vec2d @0604d8> - <vec2d+7 @0604df>)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes: <vec2d @0604d8> - <vec2d+7 @0604df>): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes: <vec2d @0604d8> - <vec2d+3 @0604db>): .result.x := x;
	<vec2d @0604d8>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes: <vec2d+3 @0604db> - <vec2d+6 @0604de>): .result.y := y;
	<vec2d+3 @0604db>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @0604de>    : 03                         ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), div.p2d)))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), min.p2d)))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), max.p2d)))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.offset: <@0604e0>
.name: 'length'
.file: 'cmplStd/lib/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <length @0604e0> - <length+38 @060506>)
	cmplStd/lib/string.ci:5: (16 bytes: <length @0604e0> - <length+16 @0604f0>): if ((str) == null)
	<length @0604e0>      : 10 01                      dup.x32 sp(1)
	<length+2 @0604e2>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @0604e7>    : 57                         ceq.i32
	<length+8 @0604e8>    : 06 08 00 00                jz <length+16 @0604f0>
	cmplStd/lib/string.ci:6: (4 bytes: <length+12 @0604ec> - <length+16 @0604f0>): return .result := 0;
	<length+12 @0604ec>   : 19                         load.z32
	<length+13 @0604ed>   : 13 03                      set.x32 sp(3)
	<length+15 @0604ef>   : 03                         ret
	cmplStd/lib/string.ci:8: (1 byte: <length+16 @0604f0> - <length+17 @0604f1>): result: int32 := 0
	<length+16 @0604f0>   : 19                         load.z32
	cmplStd/lib/string.ci:9: (18 bytes: <length+17 @0604f1> - <length+35 @060503>): for ( ; str[result]; result := result + 1)
	<length+17 @0604f1>   : 04 08 00 00                jmp <length+25 @0604f9>
	cmplStd/lib/string.ci:9: (4 bytes: <length+21 @0604f5> - <length+25 @0604f9>): result := result + 1
	<length+21 @0604f5>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:9: (10 bytes: <length+25 @0604f9> - <length+35 @060503>): str[result]
	<length+25 @0604f9>   : 10 02                      dup.x32 sp(2)
	<length+27 @0604fb>   : 10 01                      dup.x32 sp(1)
	<length+29 @0604fd>   : 51                         add.i32
	<length+30 @0604fe>   : 26                         load.i8
	<length+31 @0604ff>   : 05 f6 ff ff                jnz <length+21 @0604f5>
	cmplStd/lib/string.ci:11: (3 bytes: <length+35 @060503> - <length+38 @060506>): return .result := result;
	<length+35 @060503>   : 13 03                      set.x32 sp(3)
	<length+37 @060505>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:48: referenced as `length`
	cmplStd/lib/string.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@060508>
.name: 'indexOf'
.file: 'cmplStd/lib/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <indexOf @060508> - <indexOf+50 @06053a>)
	cmplStd/lib/string.ci:16: (42 bytes: <indexOf @060508> - <indexOf+42 @060532>): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf @060508>      : 19                         load.z32
	<indexOf+1 @060509>    : 04 1b 00 00                jmp <indexOf+28 @060524>
	cmplStd/lib/string.ci:17: (19 bytes: <indexOf+5 @06050d> - <indexOf+24 @060520>): if (str[i] == chr)
	<indexOf+5 @06050d>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @06050f>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @060511>    : 51                         add.i32
	<indexOf+10 @060512>   : 26                         load.i8
	<indexOf+11 @060513>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @060517>   : 26                         load.i8
	<indexOf+16 @060518>   : 57                         ceq.i32
	<indexOf+17 @060519>   : 06 07 00 00                jz <indexOf+24 @060520>
	cmplStd/lib/string.ci:18: (3 bytes: <indexOf+21 @06051d> - <indexOf+24 @060520>): return .result := i;
	<indexOf+21 @06051d>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @06051f>   : 03                         ret
	cmplStd/lib/string.ci:16: (4 bytes: <indexOf+24 @060520> - <indexOf+28 @060524>): i := i + 1
	<indexOf+24 @060520>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:16: (10 bytes: <indexOf+28 @060524> - <indexOf+38 @06052e>): str[i]
	<indexOf+28 @060524>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @060526>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @060528>   : 51                         add.i32
	<indexOf+33 @060529>   : 26                         load.i8
	<indexOf+34 @06052a>   : 05 e3 ff ff                jnz <indexOf+5 @06050d>
	<indexOf+38 @06052e>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:21: (8 bytes: <indexOf+42 @060532> - <indexOf+50 @06053a>): return .result := -1;
	<indexOf+42 @060532>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @060537>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @060539>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:102: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@060540>
.name: 'lastIndexOf'
.file: 'cmplStd/lib/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <lastIndexOf @060540> - <lastIndexOf+50 @060572>)
	cmplStd/lib/string.ci:26: (5 bytes: <lastIndexOf @060540> - <lastIndexOf+5 @060545>): result: int32 := -1
	<lastIndexOf @060540>      : 1c ff ff ff ff             load.c32 -1
	cmplStd/lib/string.ci:27: (42 bytes: <lastIndexOf+5 @060545> - <lastIndexOf+47 @06056f>): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+5 @060545>    : 19                         load.z32
	<lastIndexOf+6 @060546>    : 04 1b 00 00                jmp <lastIndexOf+33 @060561>
	cmplStd/lib/string.ci:28: (19 bytes: <lastIndexOf+10 @06054a> - <lastIndexOf+29 @06055d>): if (str[i] == chr)
	<lastIndexOf+10 @06054a>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @06054c>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @06054e>   : 51                         add.i32
	<lastIndexOf+15 @06054f>   : 26                         load.i8
	<lastIndexOf+16 @060550>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @060554>   : 26                         load.i8
	<lastIndexOf+21 @060555>   : 57                         ceq.i32
	<lastIndexOf+22 @060556>   : 06 07 00 00                jz <lastIndexOf+29 @06055d>
	cmplStd/lib/string.ci:29: (3 bytes: <lastIndexOf+26 @06055a> - <lastIndexOf+29 @06055d>): result := i;
	<lastIndexOf+26 @06055a>   : 16 01 00                   mov.x32 sp(1, 0)
	cmplStd/lib/string.ci:27: (4 bytes: <lastIndexOf+29 @06055d> - <lastIndexOf+33 @060561>): i := i + 1
	<lastIndexOf+29 @06055d>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:27: (10 bytes: <lastIndexOf+33 @060561> - <lastIndexOf+43 @06056b>): str[i]
	<lastIndexOf+33 @060561>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @060563>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @060565>   : 51                         add.i32
	<lastIndexOf+38 @060566>   : 26                         load.i8
	<lastIndexOf+39 @060567>   : 05 e3 ff ff                jnz <lastIndexOf+10 @06054a>
	<lastIndexOf+43 @06056b>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:32: (3 bytes: <lastIndexOf+47 @06056f> - <lastIndexOf+50 @060572>): return .result := result;
	<lastIndexOf+47 @06056f>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @060571>   : 03                         ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.offset: <@060578>
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <startsWith @060578> - <startsWith+73 @0605c1>)
	cmplStd/lib/string.ci:37: (62 bytes: <startsWith @060578> - <startsWith+62 @0605b6>): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith @060578>      : 19                         load.z32
	<startsWith+1 @060579>    : 04 2d 00 00                jmp <startsWith+46 @0605a6>
	cmplStd/lib/string.ci:38: (37 bytes: <startsWith+5 @06057d> - <startsWith+42 @0605a2>): if (cmp(str[i], with[i]) != 0)
	<startsWith+5 @06057d>    : 19                         load.z32
	<startsWith+6 @06057e>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @060580>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @060582>   : 51                         add.i32
	<startsWith+11 @060583>   : 26                         load.i8
	<startsWith+12 @060584>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @060586>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @060588>   : 51                         add.i32
	<startsWith+17 @060589>   : 26                         load.i8
	<startsWith+18 @06058a>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @06058c>   : 02                         call
	<startsWith+21 @06058d>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @060591>   : 19                         load.z32
	<startsWith+26 @060592>   : 57                         ceq.i32
	<startsWith+27 @060593>   : 05 0f 00 00                jnz <startsWith+42 @0605a2>
	cmplStd/lib/string.ci:39: (11 bytes: <startsWith+31 @060597> - <startsWith+42 @0605a2>): return .result := false;
	<startsWith+31 @060597>   : 19                         load.z32
	<startsWith+32 @060598>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @06059c>   : 2b                         store.i8
	<startsWith+37 @06059d>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @0605a1>   : 03                         ret
	cmplStd/lib/string.ci:37: (4 bytes: <startsWith+42 @0605a2> - <startsWith+46 @0605a6>): i := i + 1
	<startsWith+42 @0605a2>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:37: (12 bytes: <startsWith+46 @0605a6> - <startsWith+58 @0605b2>): (with[i]) != 0
	<startsWith+46 @0605a6>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @0605a8>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @0605aa>   : 51                         add.i32
	<startsWith+51 @0605ab>   : 26                         load.i8
	<startsWith+52 @0605ac>   : 19                         load.z32
	<startsWith+53 @0605ad>   : 57                         ceq.i32
	<startsWith+54 @0605ae>   : 06 cf ff ff                jz <startsWith+5 @06057d>
	<startsWith+58 @0605b2>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:42: (11 bytes: <startsWith+62 @0605b6> - <startsWith+73 @0605c1>): return .result := true;
	<startsWith+62 @0605b6>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @0605bb>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @0605bf>   : 2b                         store.i8
	<startsWith+72 @0605c0>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:93: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.offset: <@0605c8>
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <endsWith @0605c8> - <endsWith+126 @060646>)
	cmplStd/lib/string.ci:47: (13 bytes: <endsWith @0605c8> - <endsWith+13 @0605d5>): withLen: int32 := length(with)
	<endsWith @0605c8>      : 19                         load.z32
	<endsWith+1 @0605c9>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @0605cb>    : 1f e0 04 06 00             load.ref <@0604e0> ;length(str: char[*]): int32
	<endsWith+8 @0605d0>    : 02                         call
	<endsWith+9 @0605d1>    : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:48: (13 bytes: <endsWith+13 @0605d5> - <endsWith+26 @0605e2>): strLen: int32 := length(str)
	<endsWith+13 @0605d5>   : 19                         load.z32
	<endsWith+14 @0605d6>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @0605d8>   : 1f e0 04 06 00             load.ref <@0604e0> ;length(str: char[*]): int32
	<endsWith+21 @0605dd>   : 02                         call
	<endsWith+22 @0605de>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:49: (20 bytes: <endsWith+26 @0605e2> - <endsWith+46 @0605f6>): if (strLen < withLen)
	<endsWith+26 @0605e2>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @0605e4>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @0605e6>   : 58                         clt.i32
	<endsWith+31 @0605e7>   : 06 0f 00 00                jz <endsWith+46 @0605f6>
	cmplStd/lib/string.ci:50: (11 bytes: <endsWith+35 @0605eb> - <endsWith+46 @0605f6>): return .result := false;
	<endsWith+35 @0605eb>   : 19                         load.z32
	<endsWith+36 @0605ec>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @0605f0>   : 2b                         store.i8
	<endsWith+41 @0605f1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @0605f5>   : 03                         ret
	cmplStd/lib/string.ci:52: (65 bytes: <endsWith+46 @0605f6> - <endsWith+111 @060637>): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+46 @0605f6>   : 19                         load.z32
	<endsWith+47 @0605f7>   : 04 33 00 00                jmp <endsWith+98 @06062a>
	cmplStd/lib/string.ci:53: (43 bytes: <endsWith+51 @0605fb> - <endsWith+94 @060626>): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+51 @0605fb>   : 19                         load.z32
	<endsWith+52 @0605fc>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @0605fe>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @060600>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @060602>   : 52                         sub.i32
	<endsWith+59 @060603>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @060605>   : 51                         add.i32
	<endsWith+62 @060606>   : 51                         add.i32
	<endsWith+63 @060607>   : 26                         load.i8
	<endsWith+64 @060608>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @06060a>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @06060c>   : 51                         add.i32
	<endsWith+69 @06060d>   : 26                         load.i8
	<endsWith+70 @06060e>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @060610>   : 02                         call
	<endsWith+73 @060611>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @060615>   : 19                         load.z32
	<endsWith+78 @060616>   : 57                         ceq.i32
	<endsWith+79 @060617>   : 05 0f 00 00                jnz <endsWith+94 @060626>
	cmplStd/lib/string.ci:54: (11 bytes: <endsWith+83 @06061b> - <endsWith+94 @060626>): return .result := false;
	<endsWith+83 @06061b>   : 19                         load.z32
	<endsWith+84 @06061c>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @060620>   : 2b                         store.i8
	<endsWith+89 @060621>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @060625>   : 03                         ret
	cmplStd/lib/string.ci:52: (4 bytes: <endsWith+94 @060626> - <endsWith+98 @06062a>): i := i + 1
	<endsWith+94 @060626>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:52: (9 bytes: <endsWith+98 @06062a> - <endsWith+107 @060633>): i < withLen
	<endsWith+98 @06062a>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @06062c>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @06062e>  : 58                         clt.i32
	<endsWith+103 @06062f>  : 05 cc ff ff                jnz <endsWith+51 @0605fb>
	<endsWith+107 @060633>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:57: (15 bytes: <endsWith+111 @060637> - <endsWith+126 @060646>): return .result := true;
	<endsWith+111 @060637>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @06063c>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @060640>  : 2b                         store.i8
	<endsWith+121 @060641>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @060645>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:95: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@060648>
.name: 'compare'
.file: 'cmplStd/lib/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, less or greater, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <compare @060648> - <compare+63 @060687>)
	cmplStd/lib/string.ci:62: (1 byte: <compare @060648> - <compare+1 @060649>): result: int32 := 0
	<compare @060648>      : 19                         load.z32
	cmplStd/lib/string.ci:63: (59 bytes: <compare+1 @060649> - <compare+60 @060684>): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+1 @060649>    : 19                         load.z32
	<compare+2 @06064a>    : 04 2e 00 00                jmp <compare+48 @060678>
	cmplStd/lib/string.ci:64: (22 bytes: <compare+6 @06064e> - <compare+28 @060664>): result := cmp(str[i], with[i]);
	<compare+6 @06064e>    : 19                         load.z32
	<compare+7 @06064f>    : 10 06                      dup.x32 sp(6)
	<compare+9 @060651>    : 10 02                      dup.x32 sp(2)
	<compare+11 @060653>   : 51                         add.i32
	<compare+12 @060654>   : 26                         load.i8
	<compare+13 @060655>   : 10 06                      dup.x32 sp(6)
	<compare+15 @060657>   : 10 03                      dup.x32 sp(3)
	<compare+17 @060659>   : 51                         add.i32
	<compare+18 @06065a>   : 26                         load.i8
	<compare+19 @06065b>   : 10 06                      dup.x32 sp(6)
	<compare+21 @06065d>   : 02                         call
	<compare+22 @06065e>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @060662>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:65: (16 bytes: <compare+28 @060664> - <compare+44 @060674>): if ((str[i]) == 0)
	<compare+28 @060664>   : 10 05                      dup.x32 sp(5)
	<compare+30 @060666>   : 10 01                      dup.x32 sp(1)
	<compare+32 @060668>   : 51                         add.i32
	<compare+33 @060669>   : 26                         load.i8
	<compare+34 @06066a>   : 19                         load.z32
	<compare+35 @06066b>   : 57                         ceq.i32
	<compare+36 @06066c>   : 06 08 00 00                jz <compare+44 @060674>
	cmplStd/lib/string.ci:66: (4 bytes: <compare+40 @060670> - <compare+44 @060674>): break;
	<compare+40 @060670>   : 04 10 00 00                jmp <compare+56 @060680>
	cmplStd/lib/string.ci:63: (4 bytes: <compare+44 @060674> - <compare+48 @060678>): i := i + 1
	<compare+44 @060674>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:63: (8 bytes: <compare+48 @060678> - <compare+56 @060680>): result == 0
	<compare+48 @060678>   : 10 01                      dup.x32 sp(1)
	<compare+50 @06067a>   : 19                         load.z32
	<compare+51 @06067b>   : 57                         ceq.i32
	<compare+52 @06067c>   : 05 d2 ff ff                jnz <compare+6 @06064e>
	<compare+56 @060680>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:69: (3 bytes: <compare+60 @060684> - <compare+63 @060687>): return .result := result;
	<compare+60 @060684>   : 13 05                      set.x32 sp(5)
	<compare+62 @060686>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:99: referenced as `compare`
	cmplStd/lib/string.ci:97: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.offset: <@0606d0>
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <ignCaseCmp @0606d0> - <ignCaseCmp+36 @0606f4>)
	cmplStd/lib/string.ci:84: (36 bytes: <ignCaseCmp @0606d0> - <ignCaseCmp+36 @0606f4>): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp @0606d0>      : 19                         load.z32
	<ignCaseCmp+1 @0606d1>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @0606d5>    : 26                         load.i8
	<ignCaseCmp+6 @0606d6>    : 1f 88 06 06 00             load.ref <@060688> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @0606db>   : 02                         call
	<ignCaseCmp+12 @0606dc>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @0606e0>   : 19                         load.z32
	<ignCaseCmp+17 @0606e1>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @0606e5>   : 26                         load.i8
	<ignCaseCmp+22 @0606e6>   : 1f 88 06 06 00             load.ref <@060688> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @0606eb>   : 02                         call
	<ignCaseCmp+28 @0606ec>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @0606f0>   : 52                         sub.i32
	<ignCaseCmp+33 @0606f1>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @0606f3>   : 03                         ret
.usages:
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.offset: <@0606f8>
.name: 'caseCmp'
.file: 'cmplStd/lib/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <caseCmp @0606f8> - <caseCmp+14 @060706>)
	cmplStd/lib/string.ci:89: (14 bytes: <caseCmp @0606f8> - <caseCmp+14 @060706>): return .result := chr - with;
	<caseCmp @0606f8>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @0606fc>    : 26                         load.i8
	<caseCmp+5 @0606fd>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @060701>    : 26                         load.i8
	<caseCmp+10 @060702>   : 52                         sub.i32
	<caseCmp+11 @060703>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @060705>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:99: referenced as `caseCmp`
	cmplStd/lib/string.ci:97: referenced as `caseCmp`
	cmplStd/lib/string.ci:95: referenced as `caseCmp`
	cmplStd/lib/string.ci:93: referenced as `caseCmp`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if a string begins with a specified string, using case-sensitive comparison'
.value: startsWith(void(void(str, with), caseCmp))
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:95'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if a string ends in a specified string, using case-sensitive comparison'
.value: endsWith(void(void(str, with), caseCmp))
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'cmplStd/lib/string.ci:97'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if the two strings are equal, less or greater, using case-sensitive comparison'
.value: compare(void(void(str, with), caseCmp))
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'equals'
.file: 'cmplStd/lib/string.ci:99'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'Check if the two strings are equal, using case-sensitive comparison'
.value: bool(compare(void(void(str, with), caseCmp)) == 0)
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'cmplStd/lib/string.ci:102'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	cmplStd/lib/string.ci:186: referenced as `contains`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0355d0>
.name: 'FormatFlags'
.file: 'cmplStd/lib/string.ci:116'
.field showSign: bool (size: 1, offs: <+0>, cast: const variable(bool))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	cmplStd/lib/string.ci:267: referenced as `FormatFlags`
	cmplStd/lib/string.ci:263: referenced as `FormatFlags`
	cmplStd/lib/string.ci:245: referenced as `FormatFlags`
	cmplStd/lib/string.ci:239: referenced as `FormatFlags`
	cmplStd/lib/string.ci:238: referenced as `FormatFlags`
	cmplStd/lib/string.ci:235: referenced as `FormatFlags`
	cmplStd/lib/string.ci:233: referenced as `FormatFlags`
	cmplStd/lib/string.ci:231: referenced as `FormatFlags`
	cmplStd/lib/string.ci:229: referenced as `FormatFlags`
	cmplStd/lib/string.ci:227: referenced as `FormatFlags`
	cmplStd/lib/string.ci:225: referenced as `FormatFlags`
	cmplStd/lib/string.ci:223: referenced as `FormatFlags`
	cmplStd/lib/string.ci:221: referenced as `FormatFlags`
	cmplStd/lib/string.ci:148: referenced as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.offset: <+0>
.name: 'showSign'
.file: 'cmplStd/lib/string.ci:118'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	cmplStd/lib/string.ci:246: referenced as `showSign`
	cmplStd/lib/string.ci:240: referenced as `showSign`
	cmplStd/lib/string.ci:240: referenced as `showSign`
	cmplStd/lib/string.ci:155: referenced as `showSign`
	internal usages: 1
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'cmplStd/lib/string.ci:121'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	cmplStd/lib/string.ci:257: referenced as `precision`
	cmplStd/lib/string.ci:247: referenced as `precision`
	cmplStd/lib/string.ci:249: referenced as `precision`
	cmplStd/lib/string.ci:241: referenced as `precision`
	cmplStd/lib/string.ci:243: referenced as `precision`
	cmplStd/lib/string.ci:161: referenced as `precision`
	internal usages: 1
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'cmplStd/lib/string.ci:124'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	cmplStd/lib/string.ci:248: referenced as `padChr`
	cmplStd/lib/string.ci:242: referenced as `padChr`
	cmplStd/lib/string.ci:242: referenced as `padChr`
	cmplStd/lib/string.ci:178: referenced as `padChr`
	internal usages: 1
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'cmplStd/lib/string.ci:127'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/string.ci:249: referenced as `padLen`
	cmplStd/lib/string.ci:243: referenced as `padLen`
	cmplStd/lib/string.ci:243: referenced as `padLen`
	cmplStd/lib/string.ci:176: referenced as `padLen`
	internal usages: 1
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 84
.offset: <@060708>
.name: 'append'
.file: 'cmplStd/lib/string.ci:131'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <append @060708> - <append+84 @06075c>)
	cmplStd/lib/string.ci:132: (56 bytes: <append @060708> - <append+56 @060740>): for (i: int32 := 0; value[i]; i := i + 1)
	<append @060708>      : 19                         load.z32
	<append+1 @060709>    : 04 29 00 00                jmp <append+42 @060732>
	cmplStd/lib/string.ci:133: (13 bytes: <append+5 @06070d> - <append+18 @06071a>): if (pos >= (output.length))
	<append+5 @06070d>    : 10 03                      dup.x32 sp(3)
	<append+7 @06070f>    : 10 06                      dup.x32 sp(6)
	<append+9 @060711>    : 58                         clt.i32
	<append+10 @060712>   : 05 08 00 00                jnz <append+18 @06071a>
	cmplStd/lib/string.ci:134: (4 bytes: <append+14 @060716> - <append+18 @06071a>): break;
	<append+14 @060716>   : 04 26 00 00                jmp <append+52 @06073c>
	cmplStd/lib/string.ci:136: (12 bytes: <append+18 @06071a> - <append+30 @060726>): output[pos] := value[i];
	<append+18 @06071a>   : 10 02                      dup.x32 sp(2)
	<append+20 @06071c>   : 10 01                      dup.x32 sp(1)
	<append+22 @06071e>   : 51                         add.i32
	<append+23 @06071f>   : 26                         load.i8
	<append+24 @060720>   : 10 05                      dup.x32 sp(5)
	<append+26 @060722>   : 10 05                      dup.x32 sp(5)
	<append+28 @060724>   : 51                         add.i32
	<append+29 @060725>   : 2b                         store.i8
	cmplStd/lib/string.ci:137: (8 bytes: <append+30 @060726> - <append+38 @06072e>): pos := pos + 1;
	<append+30 @060726>   : 10 03                      dup.x32 sp(3)
	<append+32 @060728>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @06072c>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:132: (4 bytes: <append+38 @06072e> - <append+42 @060732>): i := i + 1
	<append+38 @06072e>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:132: (10 bytes: <append+42 @060732> - <append+52 @06073c>): value[i]
	<append+42 @060732>   : 10 02                      dup.x32 sp(2)
	<append+44 @060734>   : 10 01                      dup.x32 sp(1)
	<append+46 @060736>   : 51                         add.i32
	<append+47 @060737>   : 26                         load.i8
	<append+48 @060738>   : 05 d5 ff ff                jnz <append+5 @06070d>
	<append+52 @06073c>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:140: (17 bytes: <append+56 @060740> - <append+73 @060751>): if (pos >= (output.length))
	<append+56 @060740>   : 10 02                      dup.x32 sp(2)
	<append+58 @060742>   : 10 05                      dup.x32 sp(5)
	<append+60 @060744>   : 58                         clt.i32
	<append+61 @060745>   : 05 0c 00 00                jnz <append+73 @060751>
	cmplStd/lib/string.ci:141: (8 bytes: <append+65 @060749> - <append+73 @060751>): pos := (output.length - (1));
	<append+65 @060749>   : 10 04                      dup.x32 sp(4)
	<append+67 @06074b>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @06074f>   : 13 03                      set.x32 sp(3)
	cmplStd/lib/string.ci:143: (7 bytes: <append+73 @060751> - <append+80 @060758>): output[pos] := (0);
	<append+73 @060751>   : 19                         load.z32
	<append+74 @060752>   : 10 04                      dup.x32 sp(4)
	<append+76 @060754>   : 10 04                      dup.x32 sp(4)
	<append+78 @060756>   : 51                         add.i32
	<append+79 @060757>   : 2b                         store.i8
	cmplStd/lib/string.ci:144: (4 bytes: <append+80 @060758> - <append+84 @06075c>): return .result := pos;
	<append+80 @060758>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @06075b>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:256: referenced as `append`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 707
.offset: <@060770>
.name: 'append'
.file: 'cmplStd/lib/string.ci:148'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	if (format.showSign) {
		if (bool((sign) == 0)) {
			char(sign := '+');
		}
	}
	radix: int32 := format.precision;
	if (bool(radix == 0)) {
		int32(radix := 10);
	}
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (707 bytes: <append @060770> - <append+707 @060a33>)
	cmplStd/lib/string.ci:152: (1 byte: <append @060770> - <append+1 @060771>): len: int32 := 0
	<append @060770>      : 19                         load.z32
	cmplStd/lib/string.ci:153: (4 bytes: <append+1 @060771> - <append+5 @060775>): digits: char[80] := {...}
	<append+1 @060771>    : 09 50 00 00                inc.sp(+80)
	cmplStd/lib/string.ci:155: (28 bytes: <append+5 @060775> - <append+33 @060791>): if (format.showSign)
	<append+5 @060775>    : 10 16                      dup.x32 sp(22)
	<append+7 @060777>    : 26                         load.i8
	<append+8 @060778>    : 06 19 00 00                jz <append+33 @060791>
	cmplStd/lib/string.ci:156: (21 bytes: <append+12 @06077c> - <append+33 @060791>): if ((sign) == 0)
	<append+12 @06077c>   : 0a 64 00 00                load.sp(+100)
	<append+16 @060780>   : 26                         load.i8
	<append+17 @060781>   : 19                         load.z32
	<append+18 @060782>   : 57                         ceq.i32
	<append+19 @060783>   : 06 0e 00 00                jz <append+33 @060791>
	cmplStd/lib/string.ci:157: (10 bytes: <append+23 @060787> - <append+33 @060791>): sign := '+';
	<append+23 @060787>   : 1c 2b 00 00 00             load.c32 43
	<append+28 @06078c>   : 0a 68 00 00                load.sp(+104)
	<append+32 @060790>   : 2b                         store.i8
	cmplStd/lib/string.ci:161: (7 bytes: <append+33 @060791> - <append+40 @060798>): radix: int32 := format.precision
	<append+33 @060791>   : 10 16                      dup.x32 sp(22)
	<append+35 @060793>   : 0c 04 00 00                inc.i32(+4)
	<append+39 @060797>   : 28                         load.i32
	cmplStd/lib/string.ci:162: (15 bytes: <append+40 @060798> - <append+55 @0607a7>): if (radix == 0)
	<append+40 @060798>   : 10 00                      dup.x32 sp(0)
	<append+42 @06079a>   : 19                         load.z32
	<append+43 @06079b>   : 57                         ceq.i32
	<append+44 @06079c>   : 06 0b 00 00                jz <append+55 @0607a7>
	cmplStd/lib/string.ci:163: (7 bytes: <append+48 @0607a0> - <append+55 @0607a7>): radix := 10;
	<append+48 @0607a0>   : 1c 0a 00 00 00             load.c32 10
	<append+53 @0607a5>   : 13 01                      set.x32 sp(1)
	cmplStd/lib/string.ci:165: (54 bytes: <append+55 @0607a7> - <append+109 @0607dd>): assert(radix > 1, "radix is too small", radix);
	<append+55 @0607a7>   : 10 00                      dup.x32 sp(0)
	<append+57 @0607a9>   : 1c 01 00 00 00             load.c32 1
	<append+62 @0607ae>   : 59                         cgt.i32
	<append+63 @0607af>   : 06 08 00 00                jz <append+71 @0607b7>
	<append+67 @0607b3>   : 04 2a 00 00                jmp <append+109 @0607dd>
	<append+71 @0607b7>   : 1f a8 15 03 00             load.ref <@0315a8> ;"cmplStd/lib/string.ci"
	<append+76 @0607bc>   : 1c a5 00 00 00             load.c32 165
	<append+81 @0607c1>   : 1c fe ff ff ff             load.c32 -2
	<append+86 @0607c6>   : 1c 80 00 00 00             load.c32 128
	<append+91 @0607cb>   : 1f 95 1a 03 00             load.ref <@031a95> ;"radix is too small"
	<append+96 @0607d0>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+101 @0607d5>  : 0a 18 00 00                load.sp(+24)
	<append+105 @0607d9>  : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:166: (53 bytes: <append+109 @0607dd> - <append+162 @060812>): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+109 @0607dd>  : 10 00                      dup.x32 sp(0)
	<append+111 @0607df>  : 20 6c 07 06                load.m32 <@06076c> ;append.radixDigits+4
	<append+115 @0607e3>  : 58                         clt.i32
	<append+116 @0607e4>  : 06 08 00 00                jz <append+124 @0607ec>
	<append+120 @0607e8>  : 04 2a 00 00                jmp <append+162 @060812>
	<append+124 @0607ec>  : 1f a8 15 03 00             load.ref <@0315a8> ;"cmplStd/lib/string.ci"
	<append+129 @0607f1>  : 1c a6 00 00 00             load.c32 166
	<append+134 @0607f6>  : 1c fe ff ff ff             load.c32 -2
	<append+139 @0607fb>  : 1c 80 00 00 00             load.c32 128
	<append+144 @060800>  : 1f a8 1a 03 00             load.ref <@031aa8> ;"radix is too big"
	<append+149 @060805>  : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+154 @06080a>  : 0a 18 00 00                load.sp(+24)
	<append+158 @06080e>  : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:169: (49 bytes: <append+162 @060812> - <append+211 @060843>): for ( ; value > (0); value := value / (radix))
	<append+162 @060812>  : 04 29 00 00                jmp <append+203 @06083b>
	cmplStd/lib/string.ci:170: (29 bytes: <append+166 @060816> - <append+195 @060833>): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+166 @060816>  : 20 68 07 06                load.m32 <@060768> ;append.radixDigits
	<append+170 @06081a>  : 11 19                      dup.x64 sp(25)
	<append+172 @06081c>  : 10 03                      dup.x32 sp(3)
	<append+174 @06081e>  : 5b                         i32.2i64
	<append+175 @06081f>  : 45                         mod.u64
	<append+176 @060820>  : 6a                         i64.2i32
	<append+177 @060821>  : 51                         add.i32
	<append+178 @060822>  : 26                         load.i8
	<append+179 @060823>  : 0a 08 00 00                load.sp(+8)
	<append+183 @060827>  : 10 17                      dup.x32 sp(23)
	<append+185 @060829>  : 0c 01 00 00                inc.i32(+1)
	<append+189 @06082d>  : 10 00                      dup.x32 sp(0)
	<append+191 @06082f>  : 13 19                      set.x32 sp(25)
	<append+193 @060831>  : 51                         add.i32
	<append+194 @060832>  : 2b                         store.i8
	cmplStd/lib/string.ci:169: (8 bytes: <append+195 @060833> - <append+203 @06083b>): value := value / (radix)
	<append+195 @060833>  : 11 18                      dup.x64 sp(24)
	<append+197 @060835>  : 10 02                      dup.x32 sp(2)
	<append+199 @060837>  : 5b                         i32.2i64
	<append+200 @060838>  : 44                         div.u64
	<append+201 @060839>  : 14 1a                      set.x64 sp(26)
	cmplStd/lib/string.ci:169: (8 bytes: <append+203 @06083b> - <append+211 @060843>): value > (0)
	<append+203 @06083b>  : 11 18                      dup.x64 sp(24)
	<append+205 @06083d>  : 1a                         load.z64
	<append+206 @06083e>  : 49                         cgt.u64
	<append+207 @06083f>  : 05 d7 ff ff                jnz <append+166 @060816>
	cmplStd/lib/string.ci:172: (29 bytes: <append+211 @060843> - <append+240 @060860>): if (len == 0)
	<append+211 @060843>  : 10 15                      dup.x32 sp(21)
	<append+213 @060845>  : 19                         load.z32
	<append+214 @060846>  : 57                         ceq.i32
	<append+215 @060847>  : 06 19 00 00                jz <append+240 @060860>
	cmplStd/lib/string.ci:173: (21 bytes: <append+219 @06084b> - <append+240 @060860>): digits[len := len + 1] := '0';
	<append+219 @06084b>  : 1c 30 00 00 00             load.c32 48
	<append+224 @060850>  : 0a 08 00 00                load.sp(+8)
	<append+228 @060854>  : 10 17                      dup.x32 sp(23)
	<append+230 @060856>  : 0c 01 00 00                inc.i32(+1)
	<append+234 @06085a>  : 10 00                      dup.x32 sp(0)
	<append+236 @06085c>  : 13 19                      set.x32 sp(25)
	<append+238 @06085e>  : 51                         add.i32
	<append+239 @06085f>  : 2b                         store.i8
	cmplStd/lib/string.ci:176: (10 bytes: <append+240 @060860> - <append+250 @06086a>): maxLen: int32 := format.padLen - len
	<append+240 @060860>  : 10 17                      dup.x32 sp(23)
	<append+242 @060862>  : 0c 0c 00 00                inc.i32(+12)
	<append+246 @060866>  : 28                         load.i32
	<append+247 @060867>  : 10 16                      dup.x32 sp(22)
	<append+249 @060869>  : 52                         sub.i32
	cmplStd/lib/string.ci:178: (7 bytes: <append+250 @06086a> - <append+257 @060871>): padChr: char := format.padChr
	<append+250 @06086a>  : 10 18                      dup.x32 sp(24)
	<append+252 @06086c>  : 0c 08 00 00                inc.i32(+8)
	<append+256 @060870>  : 26                         load.i8
	cmplStd/lib/string.ci:179: (21 bytes: <append+257 @060871> - <append+278 @060886>): if (padChr == '')
	<append+257 @060871>  : 0a 00 00 00                load.sp(+0)
	<append+261 @060875>  : 26                         load.i8
	<append+262 @060876>  : 19                         load.z32
	<append+263 @060877>  : 57                         ceq.i32
	<append+264 @060878>  : 06 0e 00 00                jz <append+278 @060886>
	cmplStd/lib/string.ci:180: (10 bytes: <append+268 @06087c> - <append+278 @060886>): padChr := ' ';
	<append+268 @06087c>  : 1c 20 00 00 00             load.c32 32
	<append+273 @060881>  : 0a 04 00 00                load.sp(+4)
	<append+277 @060885>  : 2b                         store.i8
	cmplStd/lib/string.ci:184: (207 bytes: <append+278 @060886> - <append+485 @060955>): if ((sign) != 0)
	<append+278 @060886>  : 0a 70 00 00                load.sp(+112)
	<append+282 @06088a>  : 26                         load.i8
	<append+283 @06088b>  : 19                         load.z32
	<append+284 @06088c>  : 57                         ceq.i32
	<append+285 @06088d>  : 05 c8 00 00                jnz <append+485 @060955>
	cmplStd/lib/string.ci:185: (8 bytes: <append+289 @060891> - <append+297 @060899>): maxLen := maxLen - 1;
	<append+289 @060891>  : 10 01                      dup.x32 sp(1)
	<append+291 @060893>  : 0c ff ff ff                inc.i32(-1)
	<append+295 @060897>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:186: (117 bytes: <append+297 @060899> - <append+414 @06090e>): if (contains(whiteSpace, padChr))
	<append+297 @060899>  : 19                         load.z32
	<append+298 @06089a>  : 20 60 07 06                load.m32 <@060760> ;append.whiteSpace
	<append+302 @06089e>  : 0a 08 00 00                load.sp(+8)
	<append+306 @0608a2>  : 26                         load.i8
	<append+307 @0608a3>  : 1f 08 05 06 00             load.ref <@060508> ;indexOf(str: char[*], chr: char): int32
	<append+312 @0608a8>  : 02                         call
	<append+313 @0608a9>  : 09 f8 ff ff                inc.sp(-8)
	<append+317 @0608ad>  : 19                         load.z32
	<append+318 @0608ae>  : 58                         clt.i32
	<append+319 @0608af>  : 05 5f 00 00                jnz <append+414 @06090e>
	cmplStd/lib/string.ci:188: (91 bytes: <append+323 @0608b3> - <append+414 @06090e>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+323 @0608b3>  : 04 53 00 00                jmp <append+406 @060906>
	cmplStd/lib/string.ci:189: (52 bytes: <append+327 @0608b7> - <append+379 @0608eb>): assert(pos < (output.length));
	<append+327 @0608b7>  : 10 1d                      dup.x32 sp(29)
	<append+329 @0608b9>  : 10 20                      dup.x32 sp(32)
	<append+331 @0608bb>  : 58                         clt.i32
	<append+332 @0608bc>  : 06 08 00 00                jz <append+340 @0608c4>
	<append+336 @0608c0>  : 04 2b 00 00                jmp <append+379 @0608eb>
	<append+340 @0608c4>  : 1f a8 15 03 00             load.ref <@0315a8> ;"cmplStd/lib/string.ci"
	<append+345 @0608c9>  : 1c bd 00 00 00             load.c32 189
	<append+350 @0608ce>  : 1c fe ff ff ff             load.c32 -2
	<append+355 @0608d3>  : 1c 80 00 00 00             load.c32 128
	<append+360 @0608d8>  : 1f 00 f5 00 00             load.ref <@00f500> ;"assertion failed!"
	<append+365 @0608dd>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+370 @0608e2>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+375 @0608e7>  : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:190: (11 bytes: <append+379 @0608eb> - <append+390 @0608f6>): output[pos] := padChr;
	<append+379 @0608eb>  : 0a 00 00 00                load.sp(+0)
	<append+383 @0608ef>  : 26                         load.i8
	<append+384 @0608f0>  : 10 1f                      dup.x32 sp(31)
	<append+386 @0608f2>  : 10 1f                      dup.x32 sp(31)
	<append+388 @0608f4>  : 51                         add.i32
	<append+389 @0608f5>  : 2b                         store.i8
	cmplStd/lib/string.ci:191: (8 bytes: <append+390 @0608f6> - <append+398 @0608fe>): pos := pos + 1;
	<append+390 @0608f6>  : 10 1d                      dup.x32 sp(29)
	<append+392 @0608f8>  : 0c 01 00 00                inc.i32(+1)
	<append+396 @0608fc>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:188: (8 bytes: <append+398 @0608fe> - <append+406 @060906>): maxLen := maxLen - 1
	<append+398 @0608fe>  : 10 01                      dup.x32 sp(1)
	<append+400 @060900>  : 0c ff ff ff                inc.i32(-1)
	<append+404 @060904>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:188: (8 bytes: <append+406 @060906> - <append+414 @06090e>): maxLen > 0
	<append+406 @060906>  : 10 01                      dup.x32 sp(1)
	<append+408 @060908>  : 19                         load.z32
	<append+409 @060909>  : 59                         cgt.i32
	<append+410 @06090a>  : 05 ad ff ff                jnz <append+327 @0608b7>
	cmplStd/lib/string.ci:194: (52 bytes: <append+414 @06090e> - <append+466 @060942>): assert(pos < (output.length));
	<append+414 @06090e>  : 10 1d                      dup.x32 sp(29)
	<append+416 @060910>  : 10 20                      dup.x32 sp(32)
	<append+418 @060912>  : 58                         clt.i32
	<append+419 @060913>  : 06 08 00 00                jz <append+427 @06091b>
	<append+423 @060917>  : 04 2b 00 00                jmp <append+466 @060942>
	<append+427 @06091b>  : 1f a8 15 03 00             load.ref <@0315a8> ;"cmplStd/lib/string.ci"
	<append+432 @060920>  : 1c c2 00 00 00             load.c32 194
	<append+437 @060925>  : 1c fe ff ff ff             load.c32 -2
	<append+442 @06092a>  : 1c 80 00 00 00             load.c32 128
	<append+447 @06092f>  : 1f 00 f5 00 00             load.ref <@00f500> ;"assertion failed!"
	<append+452 @060934>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+457 @060939>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+462 @06093e>  : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:195: (11 bytes: <append+466 @060942> - <append+477 @06094d>): output[pos] := sign;
	<append+466 @060942>  : 0a 70 00 00                load.sp(+112)
	<append+470 @060946>  : 26                         load.i8
	<append+471 @060947>  : 10 1f                      dup.x32 sp(31)
	<append+473 @060949>  : 10 1f                      dup.x32 sp(31)
	<append+475 @06094b>  : 51                         add.i32
	<append+476 @06094c>  : 2b                         store.i8
	cmplStd/lib/string.ci:196: (8 bytes: <append+477 @06094d> - <append+485 @060955>): pos := pos + 1;
	<append+477 @06094d>  : 10 1d                      dup.x32 sp(29)
	<append+479 @06094f>  : 0c 01 00 00                inc.i32(+1)
	<append+483 @060953>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:200: (91 bytes: <append+485 @060955> - <append+576 @0609b0>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+485 @060955>  : 04 53 00 00                jmp <append+568 @0609a8>
	cmplStd/lib/string.ci:201: (52 bytes: <append+489 @060959> - <append+541 @06098d>): assert(pos < (output.length));
	<append+489 @060959>  : 10 1d                      dup.x32 sp(29)
	<append+491 @06095b>  : 10 20                      dup.x32 sp(32)
	<append+493 @06095d>  : 58                         clt.i32
	<append+494 @06095e>  : 06 08 00 00                jz <append+502 @060966>
	<append+498 @060962>  : 04 2b 00 00                jmp <append+541 @06098d>
	<append+502 @060966>  : 1f a8 15 03 00             load.ref <@0315a8> ;"cmplStd/lib/string.ci"
	<append+507 @06096b>  : 1c c9 00 00 00             load.c32 201
	<append+512 @060970>  : 1c fe ff ff ff             load.c32 -2
	<append+517 @060975>  : 1c 80 00 00 00             load.c32 128
	<append+522 @06097a>  : 1f 00 f5 00 00             load.ref <@00f500> ;"assertion failed!"
	<append+527 @06097f>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+532 @060984>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+537 @060989>  : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:202: (11 bytes: <append+541 @06098d> - <append+552 @060998>): output[pos] := padChr;
	<append+541 @06098d>  : 0a 00 00 00                load.sp(+0)
	<append+545 @060991>  : 26                         load.i8
	<append+546 @060992>  : 10 1f                      dup.x32 sp(31)
	<append+548 @060994>  : 10 1f                      dup.x32 sp(31)
	<append+550 @060996>  : 51                         add.i32
	<append+551 @060997>  : 2b                         store.i8
	cmplStd/lib/string.ci:203: (8 bytes: <append+552 @060998> - <append+560 @0609a0>): pos := pos + 1;
	<append+552 @060998>  : 10 1d                      dup.x32 sp(29)
	<append+554 @06099a>  : 0c 01 00 00                inc.i32(+1)
	<append+558 @06099e>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:200: (8 bytes: <append+560 @0609a0> - <append+568 @0609a8>): maxLen := maxLen - 1
	<append+560 @0609a0>  : 10 01                      dup.x32 sp(1)
	<append+562 @0609a2>  : 0c ff ff ff                inc.i32(-1)
	<append+566 @0609a6>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:200: (8 bytes: <append+568 @0609a8> - <append+576 @0609b0>): maxLen > 0
	<append+568 @0609a8>  : 10 01                      dup.x32 sp(1)
	<append+570 @0609aa>  : 19                         load.z32
	<append+571 @0609ab>  : 59                         cgt.i32
	<append+572 @0609ac>  : 05 ad ff ff                jnz <append+489 @060959>
	cmplStd/lib/string.ci:207: (99 bytes: <append+576 @0609b0> - <append+675 @060a13>): for (i: int32 := 0; i < len; i := i + 1)
	<append+576 @0609b0>  : 19                         load.z32
	<append+577 @0609b1>  : 04 55 00 00                jmp <append+662 @060a06>
	cmplStd/lib/string.ci:208: (52 bytes: <append+581 @0609b5> - <append+633 @0609e9>): assert(i < (output.length));
	<append+581 @0609b5>  : 10 00                      dup.x32 sp(0)
	<append+583 @0609b7>  : 10 21                      dup.x32 sp(33)
	<append+585 @0609b9>  : 58                         clt.i32
	<append+586 @0609ba>  : 06 08 00 00                jz <append+594 @0609c2>
	<append+590 @0609be>  : 04 2b 00 00                jmp <append+633 @0609e9>
	<append+594 @0609c2>  : 1f a8 15 03 00             load.ref <@0315a8> ;"cmplStd/lib/string.ci"
	<append+599 @0609c7>  : 1c d0 00 00 00             load.c32 208
	<append+604 @0609cc>  : 1c fe ff ff ff             load.c32 -2
	<append+609 @0609d1>  : 1c 80 00 00 00             load.c32 128
	<append+614 @0609d6>  : 1f 00 f5 00 00             load.ref <@00f500> ;"assertion failed!"
	<append+619 @0609db>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+624 @0609e0>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+629 @0609e5>  : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:209: (17 bytes: <append+633 @0609e9> - <append+650 @0609fa>): output[pos] := digits[len - i];
	<append+633 @0609e9>  : 0a 10 00 00                load.sp(+16)
	<append+637 @0609ed>  : 10 19                      dup.x32 sp(25)
	<append+639 @0609ef>  : 10 02                      dup.x32 sp(2)
	<append+641 @0609f1>  : 52                         sub.i32
	<append+642 @0609f2>  : 51                         add.i32
	<append+643 @0609f3>  : 26                         load.i8
	<append+644 @0609f4>  : 10 20                      dup.x32 sp(32)
	<append+646 @0609f6>  : 10 20                      dup.x32 sp(32)
	<append+648 @0609f8>  : 51                         add.i32
	<append+649 @0609f9>  : 2b                         store.i8
	cmplStd/lib/string.ci:210: (8 bytes: <append+650 @0609fa> - <append+658 @060a02>): pos := pos + 1;
	<append+650 @0609fa>  : 10 1e                      dup.x32 sp(30)
	<append+652 @0609fc>  : 0c 01 00 00                inc.i32(+1)
	<append+656 @060a00>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/string.ci:207: (4 bytes: <append+658 @060a02> - <append+662 @060a06>): i := i + 1
	<append+658 @060a02>  : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:207: (9 bytes: <append+662 @060a06> - <append+671 @060a0f>): i < len
	<append+662 @060a06>  : 10 00                      dup.x32 sp(0)
	<append+664 @060a08>  : 10 19                      dup.x32 sp(25)
	<append+666 @060a0a>  : 58                         clt.i32
	<append+667 @060a0b>  : 05 aa ff ff                jnz <append+581 @0609b5>
	<append+671 @060a0f>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:213: (17 bytes: <append+675 @060a13> - <append+692 @060a24>): if (pos >= (output.length))
	<append+675 @060a13>  : 10 1d                      dup.x32 sp(29)
	<append+677 @060a15>  : 10 20                      dup.x32 sp(32)
	<append+679 @060a17>  : 58                         clt.i32
	<append+680 @060a18>  : 05 0c 00 00                jnz <append+692 @060a24>
	cmplStd/lib/string.ci:214: (8 bytes: <append+684 @060a1c> - <append+692 @060a24>): pos := (output.length - (1));
	<append+684 @060a1c>  : 10 1f                      dup.x32 sp(31)
	<append+686 @060a1e>  : 0c ff ff ff                inc.i32(-1)
	<append+690 @060a22>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:216: (7 bytes: <append+692 @060a24> - <append+699 @060a2b>): output[pos] := (0);
	<append+692 @060a24>  : 19                         load.z32
	<append+693 @060a25>  : 10 1f                      dup.x32 sp(31)
	<append+695 @060a27>  : 10 1f                      dup.x32 sp(31)
	<append+697 @060a29>  : 51                         add.i32
	<append+698 @060a2a>  : 2b                         store.i8
	cmplStd/lib/string.ci:217: (8 bytes: <append+699 @060a2b> - <append+707 @060a33>): return .result := pos;
	<append+699 @060a2b>  : 16 20 1d                   mov.x32 sp(32, 29)
	<append+702 @060a2e>  : 09 a0 ff ff                inc.sp(-96)
	<append+706 @060a32>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:258: referenced as `append`
	cmplStd/lib/string.ci:254: referenced as `append`
	cmplStd/lib/string.ci:235: referenced as `append`
	cmplStd/lib/string.ci:233: referenced as `append`
	cmplStd/lib/string.ci:231: referenced as `append`
	cmplStd/lib/string.ci:229: referenced as `append`
	cmplStd/lib/string.ci:227: referenced as `append`
	cmplStd/lib/string.ci:225: referenced as `append`
	cmplStd/lib/string.ci:223: referenced as `append`
	cmplStd/lib/string.ci:221: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:221'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:223'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:225'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:227'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:229'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:231'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format))
.usages:
	cmplStd/lib/string.ci:268: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:233'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:235'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 236
.offset: <@060a38>
.name: 'append'
.file: 'cmplStd/lib/string.ci:238'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		void(formatInt.showSign := format.showSign);
		void(formatInt.precision := 0);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(format.padLen - format.precision));
	};
	formatDec: FormatFlags := {
		void(formatDec.showSign := false);
		void(formatDec.precision := 0);
		void(formatDec.padChr := '0');
		void(formatDec.padLen := format.precision);
	};
	sign: char := bool(value < (0)) ? ('-') : 0;
	fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
	int32(pos := append(void(output, void(pos, "."))));
	float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
	return int32(.result := pos);
}
.instructions: (236 bytes: <append @060a38> - <append+236 @060b24>)
	cmplStd/lib/string.ci:239: (44 bytes: <append @060a38> - <append+44 @060a64>): formatInt: FormatFlags := {...}
	<append @060a38>      : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/string.ci:240: (8 bytes: <append+4 @060a3c> - <append+12 @060a44>): formatInt.showSign := format.showSign;
	<append+4 @060a3c>    : 10 05                      dup.x32 sp(5)
	<append+6 @060a3e>    : 26                         load.i8
	<append+7 @060a3f>    : 0a 04 00 00                load.sp(+4)
	<append+11 @060a43>   : 2b                         store.i8
	cmplStd/lib/string.ci:241: (3 bytes: <append+12 @060a44> - <append+15 @060a47>): formatInt.precision := 0;
	<append+12 @060a44>   : 19                         load.z32
	<append+13 @060a45>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:242: (12 bytes: <append+15 @060a47> - <append+27 @060a53>): formatInt.padChr := format.padChr;
	<append+15 @060a47>   : 10 05                      dup.x32 sp(5)
	<append+17 @060a49>   : 0c 08 00 00                inc.i32(+8)
	<append+21 @060a4d>   : 26                         load.i8
	<append+22 @060a4e>   : 0a 0c 00 00                load.sp(+12)
	<append+26 @060a52>   : 2b                         store.i8
	cmplStd/lib/string.ci:243: (17 bytes: <append+27 @060a53> - <append+44 @060a64>): formatInt.padLen := format.padLen - format.precision;
	<append+27 @060a53>   : 10 05                      dup.x32 sp(5)
	<append+29 @060a55>   : 0c 0c 00 00                inc.i32(+12)
	<append+33 @060a59>   : 28                         load.i32
	<append+34 @060a5a>   : 10 06                      dup.x32 sp(6)
	<append+36 @060a5c>   : 0c 04 00 00                inc.i32(+4)
	<append+40 @060a60>   : 28                         load.i32
	<append+41 @060a61>   : 52                         sub.i32
	<append+42 @060a62>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:245: (32 bytes: <append+44 @060a64> - <append+76 @060a84>): formatDec: FormatFlags := {...}
	<append+44 @060a64>   : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/string.ci:246: (6 bytes: <append+48 @060a68> - <append+54 @060a6e>): formatDec.showSign := false;
	<append+48 @060a68>   : 19                         load.z32
	<append+49 @060a69>   : 0a 04 00 00                load.sp(+4)
	<append+53 @060a6d>   : 2b                         store.i8
	cmplStd/lib/string.ci:247: (3 bytes: <append+54 @060a6e> - <append+57 @060a71>): formatDec.precision := 0;
	<append+54 @060a6e>   : 19                         load.z32
	<append+55 @060a6f>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:248: (10 bytes: <append+57 @060a71> - <append+67 @060a7b>): formatDec.padChr := '0';
	<append+57 @060a71>   : 1c 30 00 00 00             load.c32 48
	<append+62 @060a76>   : 0a 0c 00 00                load.sp(+12)
	<append+66 @060a7a>   : 2b                         store.i8
	cmplStd/lib/string.ci:249: (9 bytes: <append+67 @060a7b> - <append+76 @060a84>): formatDec.padLen := format.precision;
	<append+67 @060a7b>   : 10 09                      dup.x32 sp(9)
	<append+69 @060a7d>   : 0c 04 00 00                inc.i32(+4)
	<append+73 @060a81>   : 28                         load.i32
	<append+74 @060a82>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:252: (18 bytes: <append+76 @060a84> - <append+94 @060a96>): sign: char := value < (0) ? ('-') : 0
	<append+76 @060a84>   : 11 0a                      dup.x64 sp(10)
	<append+78 @060a86>   : 1a                         load.z64
	<append+79 @060a87>   : 88                         clt.f64
	<append+80 @060a88>   : 06 0d 00 00                jz <append+93 @060a95>
	<append+84 @060a8c>   : 1c 2d 00 00 00             load.c32 45
	<append+89 @060a91>   : 04 05 00 00                jmp <append+94 @060a96>
	<append+93 @060a95>   : 19                         load.z32
	cmplStd/lib/string.ci:253: (36 bytes: <append+94 @060a96> - <append+130 @060aba>): fract: float64 := Math.modf(Math.abs(value), &value)
	<append+94 @060a96>   : 1a                         load.z64
	<append+95 @060a97>   : 11 0d                      dup.x64 sp(13)
	<append+97 @060a99>   : 11 00                      dup.x64 sp(0)
	<append+99 @060a9b>   : 1a                         load.z64
	<append+100 @060a9c>  : 88                         clt.f64
	<append+101 @060a9d>  : 06 0b 00 00                jz <append+112 @060aa8>
	<append+105 @060aa1>  : 11 00                      dup.x64 sp(0)
	<append+107 @060aa3>  : 80                         neg.f64
	<append+108 @060aa4>  : 04 06 00 00                jmp <append+114 @060aaa>
	<append+112 @060aa8>  : 11 00                      dup.x64 sp(0)
	<append+114 @060aaa>  : 14 02                      set.x64 sp(2)
	<append+116 @060aac>  : 0a 3c 00 00                load.sp(+60)
	<append+120 @060ab0>  : 1f e8 f7 05 00             load.ref <@05f7e8> ;Math.modf(x: float64, intPart: float64): float64
	<append+125 @060ab5>  : 02                         call
	<append+126 @060ab6>  : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/string.ci:254: (29 bytes: <append+130 @060aba> - <append+159 @060ad7>): pos := append(output, pos, sign, uint64(int64(value)), formatInt);
	<append+130 @060aba>  : 19                         load.z32
	<append+131 @060abb>  : 11 11                      dup.x64 sp(17)
	<append+133 @060abd>  : 10 12                      dup.x32 sp(18)
	<append+135 @060abf>  : 0a 18 00 00                load.sp(+24)
	<append+139 @060ac3>  : 26                         load.i8
	<append+140 @060ac4>  : 11 12                      dup.x64 sp(18)
	<append+142 @060ac6>  : 8b                         f64.2i64
	<append+143 @060ac7>  : 0a 38 00 00                load.sp(+56)
	<append+147 @060acb>  : 1f 70 07 06 00             load.ref <@060770> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+152 @060ad0>  : 02                         call
	<append+153 @060ad1>  : 09 e4 ff ff                inc.sp(-28)
	<append+157 @060ad5>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:256: (22 bytes: <append+159 @060ad7> - <append+181 @060aed>): pos := append(output, pos, ".");
	<append+159 @060ad7>  : 19                         load.z32
	<append+160 @060ad8>  : 11 11                      dup.x64 sp(17)
	<append+162 @060ada>  : 10 12                      dup.x32 sp(18)
	<append+164 @060adc>  : 1f 0e 1b 03 00             load.ref <@031b0e> ;"."
	<append+169 @060ae1>  : 1f 08 07 06 00             load.ref <@060708> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+174 @060ae6>  : 02                         call
	<append+175 @060ae7>  : 09 f0 ff ff                inc.sp(-16)
	<append+179 @060aeb>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:257: (22 bytes: <append+181 @060aed> - <append+203 @060b03>): fract := fract * float64.pow(10, format.precision);
	<append+181 @060aed>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+190 @060af6>  : 10 0e                      dup.x32 sp(14)
	<append+192 @060af8>  : 0c 04 00 00                inc.i32(+4)
	<append+196 @060afc>  : 28                         load.i32
	<append+197 @060afd>  : 5d                         i32.2f64
	<append+198 @060afe>  : 01 2e 00 00                nfc(46) ;float64.pow(x: float64, y: float64): float64
	<append+202 @060b02>  : 83                         mul.f64
	cmplStd/lib/string.ci:258: (25 bytes: <append+203 @060b03> - <append+228 @060b1c>): pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
	<append+203 @060b03>  : 19                         load.z32
	<append+204 @060b04>  : 11 11                      dup.x64 sp(17)
	<append+206 @060b06>  : 10 12                      dup.x32 sp(18)
	<append+208 @060b08>  : 19                         load.z32
	<append+209 @060b09>  : 11 05                      dup.x64 sp(5)
	<append+211 @060b0b>  : 8b                         f64.2i64
	<append+212 @060b0c>  : 0a 28 00 00                load.sp(+40)
	<append+216 @060b10>  : 1f 70 07 06 00             load.ref <@060770> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+221 @060b15>  : 02                         call
	<append+222 @060b16>  : 09 e4 ff ff                inc.sp(-28)
	<append+226 @060b1a>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:259: (8 bytes: <append+228 @060b1c> - <append+236 @060b24>): return .result := pos;
	<append+228 @060b1c>  : 16 12 0f                   mov.x32 sp(18, 15)
	<append+231 @060b1f>  : 09 d4 ff ff                inc.sp(-44)
	<append+235 @060b23>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:263: referenced as `append`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:263'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@060b38>
.name: 'append'
.file: 'cmplStd/lib/string.ci:266'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.showSign := false);
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (63 bytes: <append @060b38> - <append+63 @060b77>)
	cmplStd/lib/string.ci:268: (63 bytes: <append @060b38> - <append+63 @060b77>): return .result := append(output, pos, value, format);
	<append @060b38>      : 10 01                      dup.x32 sp(1)
	<append+2 @060b3a>    : 19                         load.z32
	<append+3 @060b3b>    : 11 05                      dup.x64 sp(5)
	<append+5 @060b3d>    : 10 06                      dup.x32 sp(6)
	<append+7 @060b3f>    : 10 04                      dup.x32 sp(4)
	<append+9 @060b41>    : 19                         load.z32
	<append+10 @060b42>   : 58                         clt.i32
	<append+11 @060b43>   : 06 0d 00 00                jz <append+24 @060b50>
	<append+15 @060b47>   : 1c 2d 00 00 00             load.c32 45
	<append+20 @060b4c>   : 04 05 00 00                jmp <append+25 @060b51>
	<append+24 @060b50>   : 19                         load.z32
	<append+25 @060b51>   : 10 05                      dup.x32 sp(5)
	<append+27 @060b53>   : 19                         load.z32
	<append+28 @060b54>   : 58                         clt.i32
	<append+29 @060b55>   : 06 0b 00 00                jz <append+40 @060b60>
	<append+33 @060b59>   : 10 05                      dup.x32 sp(5)
	<append+35 @060b5b>   : 50                         neg.i32
	<append+36 @060b5c>   : 04 06 00 00                jmp <append+42 @060b62>
	<append+40 @060b60>   : 10 05                      dup.x32 sp(5)
	<append+42 @060b62>   : 5b                         i32.2i64
	<append+43 @060b63>   : 1f 28 0b 06 00             load.ref <@060b28> ;append.format
	<append+48 @060b68>   : 1f 70 07 06 00             load.ref <@060770> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+53 @060b6d>   : 02                         call
	<append+54 @060b6e>   : 09 e4 ff ff                inc.sp(-28)
	<append+58 @060b72>   : 13 01                      set.x32 sp(1)
	<append+60 @060b74>   : 13 06                      set.x32 sp(6)
	<append+62 @060b76>   : 03                         ret
.usages:
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'cmplStd/test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060b78>
.name: 'emitldz32'
.file: 'cmplStd/test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060b80>
.name: 'emitldz64'
.file: 'cmplStd/test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060b88>
.name: 'emitA'
.file: 'cmplStd/test/lang/emit.ci:6'
.value: 42
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060b90>
.name: 'emitB'
.file: 'cmplStd/test/lang/emit.ci:7'
.value: 96
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060b98>
.name: 'emitAddI32'
.file: 'cmplStd/test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ba0>
.name: 'emitDivI32'
.file: 'cmplStd/test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
}
emitNfcF32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060ba8>
.name: 'emitNfcF32'
.file: 'cmplStd/test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin))
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'cmplStd/test/lang/emit.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	cmplStd/test/lang/emit.ci:24: referenced as `floatAsInt32`
	cmplStd/test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'cmplStd/test/lang/emit.ci:21'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	cmplStd/test/lang/emit.ci:26: referenced as `floatAsInt64`
	cmplStd/test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060bb0>
.name: 'emitFloatAsInt1'
.file: 'cmplStd/test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060bb8>
.name: 'emitFloatAsInt2'
.file: 'cmplStd/test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060bc0>
.name: 'emitFloatAsInt3'
.file: 'cmplStd/test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060bc8>
.name: 'emitFloatAsInt4'
.file: 'cmplStd/test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@060bd0>
.name: 'emitSlice'
.file: 'cmplStd/test/lang/emit.ci:29'
.value: emit(void(int32(3), pointer("string")))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'cmplStd/test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'cmplStd/test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'cmplStd/test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'cmplStd/test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060bd8>
.name: 'i3'
.file: 'cmplStd/test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060be0>
.name: 'i6'
.file: 'cmplStd/test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060be8>
.name: 'i2'
.file: 'cmplStd/test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060bf0>
.name: 'i8'
.file: 'cmplStd/test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060bf8>
.name: 'zeroVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c00>
.name: 'zeroVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c08>
.name: 'zeroXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c10>
.name: 'lastVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c18>
.name: 'lastVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c20>
.name: 'lastXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c28>
.name: 'sum2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c30>
.name: 'sum2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c38>
.name: 'sum2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c40>
.name: 'any2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c48>
.name: 'any2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c50>
.name: 'any2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c58>
.name: 'min2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c60>
.name: 'min2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c68>
.name: 'min2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c70>
.name: 'max2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c78>
.name: 'max2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c80>
.name: 'max2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c88>
.name: 'sumRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c90>
.name: 'sumLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060c98>
.name: 'sumRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ca0>
.name: 'sumLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ca8>
.name: 'sumRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cb0>
.name: 'sumLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cb8>
.name: 'anyRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cc0>
.name: 'anyLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cc8>
.name: 'anyRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cd0>
.name: 'anyLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cd8>
.name: 'anyRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ce0>
.name: 'anyLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ce8>
.name: 'minRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cf0>
.name: 'minLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060cf8>
.name: 'minRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d00>
.name: 'minLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d08>
.name: 'minRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d10>
.name: 'minLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d18>
.name: 'maxRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d20>
.name: 'maxLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d28>
.name: 'maxRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d30>
.name: 'maxLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d38>
.name: 'maxRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d40>
.name: 'maxLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:3'
.value: 1
.usages:
	cmplStd/test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	cmplStd/test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	cmplStd/test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	cmplStd/test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	cmplStd/test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d48>
.name: 'overload1'
.file: 'cmplStd/test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d50>
.name: 'overload2'
.file: 'cmplStd/test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d58>
.name: 'overload3'
.file: 'cmplStd/test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d60>
.name: 'overload4'
.file: 'cmplStd/test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d68>
.name: 'overload5'
.file: 'cmplStd/test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@040410>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@040550>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	cmplStd/test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@060d70>
.name: 'boilC'
.file: 'cmplStd/test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@060d78>
.name: 'boilF'
.file: 'cmplStd/test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060d80>
.name: 'pi64'
.file: 'cmplStd/test/std/number.ci:3'
.value: 3.141593
.usages:
	cmplStd/test/std/number.ci:44: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:39: referenced as `pi64`
	cmplStd/test/std/number.ci:38: referenced as `pi64`
	cmplStd/test/std/number.ci:37: referenced as `pi64`
	cmplStd/test/std/number.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060d88>
.name: 'e64'
.file: 'cmplStd/test/std/number.ci:4'
.value: 2.718282
.usages:
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d90>
.name: 'pi32'
.file: 'cmplStd/test/std/number.ci:6'
.value: pi64
.usages:
	cmplStd/test/std/number.ci:53: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:48: referenced as `pi32`
	cmplStd/test/std/number.ci:47: referenced as `pi32`
	cmplStd/test/std/number.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060d98>
.name: 'e32'
.file: 'cmplStd/test/std/number.ci:7'
.value: e64
.usages:
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'cmplStd/test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	cmplStd/test/std/number.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'cmplStd/test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	cmplStd/test/std/number.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060da0>
.name: 'r_comp'
.file: 'cmplStd/test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `r_comp`
	cmplStd/test/std/number.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060da8>
.name: 'g_comp'
.file: 'cmplStd/test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `g_comp`
	cmplStd/test/std/number.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060db0>
.name: 'b_comp'
.file: 'cmplStd/test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `b_comp`
	cmplStd/test/std/number.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060db8>
.name: 'r5g6b5'
.file: 'cmplStd/test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:66: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:65: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:63: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:62: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:60: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:59: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:58: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:57: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:56: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:55: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:27: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:26: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:25: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:23: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:22: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060dc0>
.name: 'r8g8b8'
.file: 'cmplStd/test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:35: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:34: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:33: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:31: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:30: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060dc8>
.name: 'zxtR5'
.file: 'cmplStd/test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060dd0>
.name: 'zxtG6'
.file: 'cmplStd/test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060dd8>
.name: 'zxtB5'
.file: 'cmplStd/test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060de0>
.name: 'sxtR5'
.file: 'cmplStd/test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060de8>
.name: 'sxtG6'
.file: 'cmplStd/test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060df0>
.name: 'sxtB5'
.file: 'cmplStd/test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060df8>
.name: 'zxtR8'
.file: 'cmplStd/test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060e00>
.name: 'zxtG8'
.file: 'cmplStd/test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060e08>
.name: 'zxtB8'
.file: 'cmplStd/test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060e10>
.name: 'sxtR8'
.file: 'cmplStd/test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060e18>
.name: 'sxtG8'
.file: 'cmplStd/test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060e20>
.name: 'sxtB8'
.file: 'cmplStd/test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e28>
.name: 'testSin_f64'
.file: 'cmplStd/test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e30>
.name: 'testCos_f64'
.file: 'cmplStd/test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e38>
.name: 'testTan_f64'
.file: 'cmplStd/test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e40>
.name: 'testLog_f64'
.file: 'cmplStd/test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e48>
.name: 'testExp_f64'
.file: 'cmplStd/test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e50>
.name: 'testPow_f64'
.file: 'cmplStd/test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e58>
.name: 'testSqrt_f64'
.file: 'cmplStd/test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060e60>
.name: 'testAtan_f64'
.file: 'cmplStd/test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e68>
.name: 'testSin_f32'
.file: 'cmplStd/test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e70>
.name: 'testCos_f32'
.file: 'cmplStd/test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e78>
.name: 'testTan_f32'
.file: 'cmplStd/test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e80>
.name: 'testLog_f32'
.file: 'cmplStd/test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e88>
.name: 'testExp_f32'
.file: 'cmplStd/test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e90>
.name: 'testPow_f32'
.file: 'cmplStd/test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060e98>
.name: 'testSqrt_f32'
.file: 'cmplStd/test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060ea0>
.name: 'testAtan_f32'
.file: 'cmplStd/test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ea8>
.name: 'testPopulation_u32'
.file: 'cmplStd/test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@060eb0>
.name: 'testSwapBits_u32'
.file: 'cmplStd/test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060eb8>
.name: 'testBitScanReverse_u32'
.file: 'cmplStd/test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ec0>
.name: 'testBitScanForward_u32'
.file: 'cmplStd/test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ec8>
.name: 'testHighBit_u32'
.file: 'cmplStd/test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ed0>
.name: 'testLowBit_u32'
.file: 'cmplStd/test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ed8>
.name: 'testZeroExtend_u32'
.file: 'cmplStd/test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ee0>
.name: 'testSignExtend_u32'
.file: 'cmplStd/test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ee8>
.name: 'testZeroExtend_u64'
.file: 'cmplStd/test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ef0>
.name: 'testSignExtend_u64'
.file: 'cmplStd/test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'cmplStd/test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'cmplStd/test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	cmplStd/test/std/memory.ci:10: referenced as `malloc`
	cmplStd/test/std/memory.ci:9: referenced as `malloc`
	cmplStd/test/std/memory.ci:8: referenced as `malloc`
	cmplStd/test/std/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'cmplStd/test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `free`
	cmplStd/test/std/memory.ci:19: referenced as `free`
	cmplStd/test/std/memory.ci:18: referenced as `free`
	cmplStd/test/std/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060ef8>
.name: 'p1'
.file: 'cmplStd/test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	cmplStd/test/std/memory.ci:17: referenced as `p1`
	cmplStd/test/std/memory.ci:14: referenced as `p1`
	cmplStd/test/std/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060f00>
.name: 'p2'
.file: 'cmplStd/test/std/memory.ci:8'
.value: malloc(80)
.usages:
	cmplStd/test/std/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060f08>
.name: 'p3'
.file: 'cmplStd/test/std/memory.ci:9'
.value: malloc(160)
.usages:
	cmplStd/test/std/memory.ci:19: referenced as `p3`
	cmplStd/test/std/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060f10>
.name: 'p4'
.file: 'cmplStd/test/std/memory.ci:10'
.value: malloc(820)
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060f18>
.name: 'val1'
.file: 'cmplStd/test/std/memory.ci:23'
.value: 42
.usages:
	cmplStd/test/std/memory.ci:32: referenced as `val1`
	cmplStd/test/std/memory.ci:30: referenced as `val1`
	cmplStd/test/std/memory.ci:29: referenced as `val1`
	cmplStd/test/std/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060f20>
.name: 'val2'
.file: 'cmplStd/test/std/memory.ci:24'
.value: 96
.usages:
	cmplStd/test/std/memory.ci:33: referenced as `val2`
	cmplStd/test/std/memory.ci:29: referenced as `val2`
	cmplStd/test/std/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@060f28>
.name: 'noError'
.file: 'cmplStd/test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <noError @060f28> - <noError+1 @060f29>)
	<noError @060f28>      : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:47: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@060f30>
.name: 'stackOverflow'
.file: 'cmplStd/test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes: <stackOverflow @060f30> - <stackOverflow+24 @060f48>)
	cmplStd/test/std/tryExec.ci:16: (4 bytes: <stackOverflow @060f30> - <stackOverflow+4 @060f34>): data: uint8[8192] := {...}
	<stackOverflow @060f30>      : 09 00 20 00                inc.sp(+8192)
	cmplStd/test/std/tryExec.ci:17: (15 bytes: <stackOverflow+4 @060f34> - <stackOverflow+19 @060f43>): stackOverflow(ptr);
	<stackOverflow+4 @060f34>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @060f38>    : 28                         load.i32
	<stackOverflow+9 @060f39>    : 1f 30 0f 06 00             load.ref <@060f30> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @060f3e>   : 02                         call
	<stackOverflow+15 @060f3f>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @060f43>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @060f47>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:49: referenced as `stackOverflow`
	cmplStd/test/std/tryExec.ci:17: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@060f48>
.name: 'divisionByZero'
.file: 'cmplStd/test/std/tryExec.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <divisionByZero @060f48> - <divisionByZero+12 @060f54>)
	cmplStd/test/std/tryExec.ci:21: (7 bytes: <divisionByZero @060f48> - <divisionByZero+7 @060f4f>): value: int32 := 3 / 0
	<divisionByZero @060f48>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @060f4d>    : 19                         load.z32
	<divisionByZero+6 @060f4e>    : 54                         div.i32
	<divisionByZero+7 @060f4f>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @060f53>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:50: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 68
.offset: <@060f58>
.name: 'abortExecution'
.file: 'cmplStd/test/std/tryExec.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <abortExecution @060f58> - <abortExecution+68 @060f9c>)
	cmplStd/test/std/tryExec.ci:30: (25 bytes: <abortExecution @060f58> - <abortExecution+25 @060f71>): details: NotEquals := {...}
	<abortExecution @060f58>      : 09 10 00 00                inc.sp(+16)
	cmplStd/test/std/tryExec.ci:31: (7 bytes: <abortExecution+4 @060f5c> - <abortExecution+11 @060f63>): details.message := ("assertion failed");
	<abortExecution+4 @060f5c>    : 1f f8 f5 00 00             load.ref <@00f5f8> ;"assertion failed"
	<abortExecution+9 @060f61>    : 13 01                      set.x32 sp(1)
	cmplStd/test/std/tryExec.ci:32: (7 bytes: <abortExecution+11 @060f63> - <abortExecution+18 @060f6a>): details.expected := 97;
	<abortExecution+11 @060f63>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @060f68>   : 13 02                      set.x32 sp(2)
	cmplStd/test/std/tryExec.ci:33: (7 bytes: <abortExecution+18 @060f6a> - <abortExecution+25 @060f71>): details.returned := 77;
	<abortExecution+18 @060f6a>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @060f6f>   : 13 03                      set.x32 sp(3)
	cmplStd/test/std/tryExec.ci:35: (38 bytes: <abortExecution+25 @060f71> - <abortExecution+63 @060f97>): abort("fatal error", details);
	<abortExecution+25 @060f71>   : 1f d8 3f 04 00             load.ref <@043fd8> ;"cmplStd/test/std/tryExec.ci"
	<abortExecution+30 @060f76>   : 1c 23 00 00 00             load.c32 35
	<abortExecution+35 @060f7b>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @060f80>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @060f85>   : 1f 28 40 04 00             load.ref <@044028> ;"fatal error"
	<abortExecution+50 @060f8a>   : 1f c0 4a 04 00             load.ref <@044ac0> ;abortExecution.NotEquals
	<abortExecution+55 @060f8f>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @060f93>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @060f97>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @060f9b>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 13
.offset: <@060fa0>
.name: 'invalidMemoryAccess'
.file: 'cmplStd/test/std/tryExec.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <invalidMemoryAccess @060fa0> - <invalidMemoryAccess+13 @060fad>)
	cmplStd/test/std/tryExec.ci:39: (5 bytes: <invalidMemoryAccess @060fa0> - <invalidMemoryAccess+5 @060fa5>): i32Ref: int32 := null
	<invalidMemoryAccess @060fa0>      : 1f 00 00 00 00             load.ref <@000000> ;null
	cmplStd/test/std/tryExec.ci:40: (3 bytes: <invalidMemoryAccess+5 @060fa5> - <invalidMemoryAccess+8 @060fa8>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @060fa5>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @060fa7>    : 28                         load.i32
	<invalidMemoryAccess+8 @060fa8>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @060fac>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:52: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 2
.offset: <@060fb0>
.name: 'invalidInstruction'
.file: 'cmplStd/test/std/tryExec.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <invalidInstruction @060fb0> - <invalidInstruction+2 @060fb2>)
	cmplStd/test/std/tryExec.ci:44: (2 bytes: <invalidInstruction @060fb0> - <invalidInstruction+2 @060fb2>): emit(load.z32, ret);
	<invalidInstruction @060fb0>      : 19                         load.z32
	<invalidInstruction+1 @060fb1>    : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:51: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fb8>
.name: 'tryExecErr0'
.file: 'cmplStd/test/std/tryExec.ci:47'
.value: tryExec(void(null, noError))
.usages:
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fc0>
.name: 'tryExecErr1'
.file: 'cmplStd/test/std/tryExec.ci:48'
.value: tryExec(void(null, null))
.usages:
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fc8>
.name: 'tryExecErr2'
.file: 'cmplStd/test/std/tryExec.ci:49'
.value: tryExec(void(null, stackOverflow))
.usages:
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fd0>
.name: 'tryExecErr3'
.file: 'cmplStd/test/std/tryExec.ci:50'
.value: tryExec(void(null, divisionByZero))
.usages:
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fd8>
.name: 'tryExecErr4'
.file: 'cmplStd/test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidInstruction))
.usages:
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fe0>
.name: 'tryExecErr5'
.file: 'cmplStd/test/std/tryExec.ci:52'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060fe8>
.name: 'tryExecErr6'
.file: 'cmplStd/test/std/tryExec.ci:53'
.value: tryExec(void(null, abortExecution))
.usages:
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060ff0>
.name: 'value'
.file: 'cmplStd/test/lang/init.reference.ci:7'
.value: 42
.usages:
	cmplStd/test/lang/init.reference.ci:99: referenced as `value`
	cmplStd/test/lang/init.reference.ci:97: referenced as `value`
	cmplStd/test/lang/init.reference.ci:96: referenced as `value`
	cmplStd/test/lang/init.reference.ci:95: referenced as `value`
	cmplStd/test/lang/init.reference.ci:27: referenced as `value`
	cmplStd/test/lang/init.reference.ci:10: referenced as `value`
	cmplStd/test/lang/init.reference.ci:9: referenced as `value`
	cmplStd/test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@060ff8>
.name: 'valueRef'
.file: 'cmplStd/test/lang/init.reference.ci:8'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:29: referenced as `valueRef`
	cmplStd/test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061000>
.name: 'valuePtr'
.file: 'cmplStd/test/lang/init.reference.ci:9'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:30: referenced as `valuePtr`
	cmplStd/test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061008>
.name: 'valueVar'
.file: 'cmplStd/test/lang/init.reference.ci:10'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:31: referenced as `valueVar`
	cmplStd/test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061010>
.name: 'fromRef'
.file: 'cmplStd/test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@061018>
.name: 'fromPtr'
.file: 'cmplStd/test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@061020>
.name: 'fromVar'
.file: 'cmplStd/test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@061028>
.name: 'nullRef'
.file: 'cmplStd/test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061030>
.name: 'nullPtr'
.file: 'cmplStd/test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061038>
.name: 'nullVar'
.file: 'cmplStd/test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061040>
.name: 'nullTyp'
.file: 'cmplStd/test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@061048>
.name: 'nullFun'
.file: 'cmplStd/test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@061050>
.name: 'nullObj'
.file: 'cmplStd/test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061058>
.name: 'typePtr'
.file: 'cmplStd/test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061060>
.name: 'typeVar'
.file: 'cmplStd/test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061068>
.name: 'typeTyp'
.file: 'cmplStd/test/lang/init.reference.ci:25'
.value: int64
.usages:
	cmplStd/test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061070>
.name: 'local'
.file: 'cmplStd/test/lang/init.reference.ci:27'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061078>
.name: 'copyVal'
.file: 'cmplStd/test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@061080>
.name: 'copyRef'
.file: 'cmplStd/test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061088>
.name: 'copyPtr'
.file: 'cmplStd/test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061090>
.name: 'copyVar'
.file: 'cmplStd/test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061098>
.name: 'copyTyp'
.file: 'cmplStd/test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610a0>
.name: 'ptrVoid'
.file: 'cmplStd/test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610a8>
.name: 'ptrBool'
.file: 'cmplStd/test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610b0>
.name: 'ptrChar'
.file: 'cmplStd/test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610b8>
.name: 'ptrInt8'
.file: 'cmplStd/test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610c0>
.name: 'ptrInt16'
.file: 'cmplStd/test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610c8>
.name: 'ptrInt32'
.file: 'cmplStd/test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610d0>
.name: 'ptrInt64'
.file: 'cmplStd/test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610d8>
.name: 'ptrUint8'
.file: 'cmplStd/test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610e0>
.name: 'ptrUint16'
.file: 'cmplStd/test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610e8>
.name: 'ptrUint32'
.file: 'cmplStd/test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610f0>
.name: 'ptrUint64'
.file: 'cmplStd/test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0610f8>
.name: 'ptrFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061100>
.name: 'ptrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:47'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061108>
.name: 'ptrTypename'
.file: 'cmplStd/test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061110>
.name: 'ptrFunction'
.file: 'cmplStd/test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061118>
.name: 'ptrPointer'
.file: 'cmplStd/test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061120>
.name: 'ptrVariant'
.file: 'cmplStd/test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061128>
.name: 'ptrObject'
.file: 'cmplStd/test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061130>
.name: 'varVoid'
.file: 'cmplStd/test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061138>
.name: 'varBool'
.file: 'cmplStd/test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061140>
.name: 'varChar'
.file: 'cmplStd/test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061148>
.name: 'varInt8'
.file: 'cmplStd/test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061150>
.name: 'varInt16'
.file: 'cmplStd/test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061158>
.name: 'varInt32'
.file: 'cmplStd/test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061160>
.name: 'varInt64'
.file: 'cmplStd/test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061168>
.name: 'varUint8'
.file: 'cmplStd/test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061170>
.name: 'varUint16'
.file: 'cmplStd/test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061178>
.name: 'varUint32'
.file: 'cmplStd/test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061180>
.name: 'varUint64'
.file: 'cmplStd/test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061188>
.name: 'varFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061190>
.name: 'varFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:67'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061198>
.name: 'varTypename'
.file: 'cmplStd/test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0611a0>
.name: 'varFunction'
.file: 'cmplStd/test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0611a8>
.name: 'varPointer'
.file: 'cmplStd/test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0611b0>
.name: 'varVariant'
.file: 'cmplStd/test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0611b8>
.name: 'varObject'
.file: 'cmplStd/test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611c0>
.name: 'typVoid'
.file: 'cmplStd/test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611c8>
.name: 'typBool'
.file: 'cmplStd/test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611d0>
.name: 'typChar'
.file: 'cmplStd/test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611d8>
.name: 'typInt8'
.file: 'cmplStd/test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611e0>
.name: 'typInt16'
.file: 'cmplStd/test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611e8>
.name: 'typInt32'
.file: 'cmplStd/test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611f0>
.name: 'typInt64'
.file: 'cmplStd/test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0611f8>
.name: 'typUint8'
.file: 'cmplStd/test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061200>
.name: 'typUint16'
.file: 'cmplStd/test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061208>
.name: 'typUint32'
.file: 'cmplStd/test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061210>
.name: 'typUint64'
.file: 'cmplStd/test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061218>
.name: 'typFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061220>
.name: 'typFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061228>
.name: 'typTypename'
.file: 'cmplStd/test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061230>
.name: 'typFunction'
.file: 'cmplStd/test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061238>
.name: 'typPointer'
.file: 'cmplStd/test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061240>
.name: 'typVariant'
.file: 'cmplStd/test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061248>
.name: 'typObject'
.file: 'cmplStd/test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061250>
.name: 'valueOfPtr'
.file: 'cmplStd/test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061258>
.name: 'valueOfVar'
.file: 'cmplStd/test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061260>
.name: 'valueOfTyp'
.file: 'cmplStd/test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061268>
.name: 'typeOfValue'
.file: 'cmplStd/test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@061270>
.name: 'copyPtrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061278>
.name: 'copyVarFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061280>
.name: 'variable'
.file: 'cmplStd/test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@061288>
.name: 'constant'
.file: 'cmplStd/test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@049360>
.name: 'ComplexVal'
.file: 'cmplStd/test/lang/init.variable.ci:9'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
	internal usages: 1
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@049540>
.name: 'ComplexObj'
.file: 'cmplStd/test/lang/init.variable.ci:13'
.field re: float64 (size: 8, offs: <+4>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+12>, cast: const variable(f64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `ComplexObj`
	cmplStd/test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+4>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `re`
	cmplStd/test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+12>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
	internal usages: 2
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
valInitImplicit: ComplexVal {
.kind: static variable(val)
.base: `ComplexVal`
.size: 16
.offset: <@061290>
.name: 'valInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	void(valInitImplicit.re := (8));
	void(valInitImplicit.im := (0));
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: static variable(ref)
.base: `ComplexObj`
.size: 4
.offset: <@0612a0>
.name: 'objInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	void(objInitImplicit := create(ComplexObj));
	void(objInitImplicit.re := (8));
	void(objInitImplicit.im := (0));
}
.usages:
}
objInitExplicit: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@0612a8>
.name: 'objInitExplicit'
.file: 'cmplStd/test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	void(objInitExplicit := create(ComplexObj));
	void(objInitExplicit.re := (8));
	void(objInitExplicit.im := (0));
}
.usages:
}
empty(): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@0612b0>
.name: 'empty'
.file: 'cmplStd/test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <empty @0612b0> - <empty+1 @0612b1>)
	<empty @0612b0>      : 03                         ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@0612b8>
.name: 'funAdd'
.file: 'cmplStd/test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <funAdd @0612b8> - <funAdd+8 @0612c0>)
	cmplStd/test/lang/function.ci:8: (8 bytes: <funAdd @0612b8> - <funAdd+8 @0612c0>): return .result := x + y;
	<funAdd @0612b8>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @0612ba>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @0612bc>    : 51                         add.i32
	<funAdd+5 @0612bd>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @0612bf>    : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:15: referenced as `funAdd`
	cmplStd/test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0612c0>
.name: 'funAddResult'
.file: 'cmplStd/test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0612c8>
.name: 'funAddRef'
.file: 'cmplStd/test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	cmplStd/test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0612d0>
.name: 'funAddRefResult'
.file: 'cmplStd/test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0612d8>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:27: referenced as `funMul`
	cmplStd/test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0612e0>
.name: 'funMulResult'
.file: 'cmplStd/test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0612e8>
.name: 'funMulRef'
.file: 'cmplStd/test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0612f0>
.name: 'funMulRefResult'
.file: 'cmplStd/test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@0612f8>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <funMul @0612f8> - <funMul+8 @061300>)
	cmplStd/test/lang/function.ci:34: (8 bytes: <funMul @0612f8> - <funMul+8 @061300>): return .result := x * y;
	<funMul @0612f8>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @0612fa>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @0612fc>    : 53                         mul.i32
	<funMul+5 @0612fd>    : 13 04                      set.x32 sp(4)
	<funMul+7 @0612ff>    : 03                         ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 54
.offset: <@061300>
.name: 'fib'
.file: 'cmplStd/test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <fib @061300> - <fib+54 @061336>)
	cmplStd/test/lang/function.ci:39: (16 bytes: <fib @061300> - <fib+16 @061310>): if (n <= (1))
	<fib @061300>      : 10 01                      dup.x32 sp(1)
	<fib+2 @061302>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @061307>    : 39                         cgt.u32
	<fib+8 @061308>    : 05 08 00 00                jnz <fib+16 @061310>
	cmplStd/test/lang/function.ci:40: (4 bytes: <fib+12 @06130c> - <fib+16 @061310>): return .result := n;
	<fib+12 @06130c>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @06130f>   : 03                         ret
	cmplStd/test/lang/function.ci:42: (38 bytes: <fib+16 @061310> - <fib+54 @061336>): return .result := fib(n - (1)) + fib(n - (2));
	<fib+16 @061310>   : 19                         load.z32
	<fib+17 @061311>   : 10 02                      dup.x32 sp(2)
	<fib+19 @061313>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @061317>   : 1f 00 13 06 00             load.ref <@061300> ;fib(n: uint32): uint32
	<fib+28 @06131c>   : 02                         call
	<fib+29 @06131d>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @061321>   : 19                         load.z32
	<fib+34 @061322>   : 10 03                      dup.x32 sp(3)
	<fib+36 @061324>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @061328>   : 1f 00 13 06 00             load.ref <@061300> ;fib(n: uint32): uint32
	<fib+45 @06132d>   : 02                         call
	<fib+46 @06132e>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @061332>   : 51                         add.i32
	<fib+51 @061333>   : 13 03                      set.x32 sp(3)
	<fib+53 @061335>   : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:46: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061338>
.name: 'fibonacci_13'
.file: 'cmplStd/test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061340>
.name: 'sizeofVoid'
.file: 'cmplStd/test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061348>
.name: 'sizeofBool'
.file: 'cmplStd/test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061350>
.name: 'sizeofChar'
.file: 'cmplStd/test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061358>
.name: 'sizeofInt8'
.file: 'cmplStd/test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061360>
.name: 'sizeofInt16'
.file: 'cmplStd/test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061368>
.name: 'sizeofInt32'
.file: 'cmplStd/test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061370>
.name: 'sizeofInt64'
.file: 'cmplStd/test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061378>
.name: 'sizeofUint8'
.file: 'cmplStd/test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061380>
.name: 'sizeofUint16'
.file: 'cmplStd/test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061388>
.name: 'sizeofUint32'
.file: 'cmplStd/test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061390>
.name: 'sizeofUint64'
.file: 'cmplStd/test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061398>
.name: 'sizeofFloat32'
.file: 'cmplStd/test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613a0>
.name: 'sizeofFloat64'
.file: 'cmplStd/test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613a8>
.name: 'sizeofPointer'
.file: 'cmplStd/test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613b0>
.name: 'sizeofVariant'
.file: 'cmplStd/test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613b8>
.name: 'sizeofTypename'
.file: 'cmplStd/test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613c0>
.name: 'sizeofFunction'
.file: 'cmplStd/test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613c8>
.name: 'sizeofObject'
.file: 'cmplStd/test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@04bb10>
.name: 'RecordSizeof'
.file: 'cmplStd/test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@04bc50>
.name: 'RecordSizeofExt'
.file: 'cmplStd/test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'cmplStd/test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0613d0>
.name: 'typeofRecord'
.file: 'cmplStd/test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	cmplStd/test/lang/reflect.ci:37: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:35: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:34: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:33: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:32: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0613d8>
.name: 'nameOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613e0>
.name: 'offsetOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613e8>
.name: 'sizeOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:33'
.value: typeofRecord.size
.usages:
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0613f0>
.name: 'fileOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0613f8>
.name: 'lineOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061400>
.name: 'typeofBase'
.file: 'cmplStd/test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	cmplStd/test/lang/reflect.ci:44: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:42: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:41: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:40: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:39: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@061408>
.name: 'nameOfBase'
.file: 'cmplStd/test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061410>
.name: 'offsetOfBase'
.file: 'cmplStd/test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061418>
.name: 'sizeOfBase'
.file: 'cmplStd/test/lang/reflect.ci:40'
.value: typeofBase.size
.usages:
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@061420>
.name: 'fileOfBase'
.file: 'cmplStd/test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061428>
.name: 'lineOfBase'
.file: 'cmplStd/test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061430>
.name: 'typeofBase1'
.file: 'cmplStd/test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:46: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061438>
.name: 'offsetOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061440>
.name: 'sizeOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@061448>
.name: 'typeofBase2'
.file: 'cmplStd/test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `typeofBase2`
	cmplStd/test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061450>
.name: 'offsetOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061458>
.name: 'sizeOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@04cc50>
.name: 'RecordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:2'
.field Inner: typename (size: 8, offs: <@04ccf0>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@061460>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@061468>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@061470>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@061478>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@061480>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@061488>, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	cmplStd/test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04ccf0>
.name: 'Inner'
.file: 'cmplStd/test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	cmplStd/test/lang/init.member.ci:49: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:46: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:43: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:25: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:64: referenced as `member`
	cmplStd/test/lang/init.member.ci:59: referenced as `member`
	cmplStd/test/lang/init.member.ci:49: referenced as `member`
	cmplStd/test/lang/init.member.ci:46: referenced as `member`
	internal usages: 1
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:65: referenced as `constant`
	cmplStd/test/lang/init.member.ci:60: referenced as `constant`
	cmplStd/test/lang/init.member.ci:49: referenced as `constant`
	cmplStd/test/lang/init.member.ci:46: referenced as `constant`
	cmplStd/test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'cmplStd/test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	cmplStd/test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'cmplStd/test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	cmplStd/test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'cmplStd/test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'cmplStd/test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061460>
.name: 'global'
.file: 'cmplStd/test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061468>
.name: 'globalInit'
.file: 'cmplStd/test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@061470>
.name: 'globalConstant'
.file: 'cmplStd/test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@061478>
.name: 'globalRec'
.file: 'cmplStd/test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	void(globalRec.constant := 4);
	void(globalRec.member := (0));
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@061480>
.name: 'globalRecInit'
.file: 'cmplStd/test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@061488>
.name: 'globalConstantRec'
.file: 'cmplStd/test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@061490>
.name: 'recordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:52'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04db68>
.name: 'RecordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:4'
.field staticMethod: function (size: 39, offs: <@0614b0>, cast: static function)
.field forwardMethod: function (size: 4, offs: <@0614d8>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 39, offs: <@0614e0>, cast: static function)
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field forwardMethod: function (size: 39, offs: <@061508>, cast: static function)
.doc: 'static, virtual and abstract methods'
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@0614b0>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <staticMethod @0614b0> - <staticMethod+39 @0614d7>)
	cmplStd/test/lang/init.method.ci:11: (38 bytes: <staticMethod @0614b0> - <staticMethod+38 @0614d6>): trace("staticMethod", x);
	<staticMethod @0614b0>      : 1f f0 d6 04 00             load.ref <@04d6f0> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @0614b5>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @0614ba>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0614bf>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @0614c4>   : 1f 9a d7 04 00             load.ref <@04d79a> ;"staticMethod"
	<staticMethod+25 @0614c9>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<staticMethod+30 @0614ce>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @0614d2>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @0614d6>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:101: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:87: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0614d8>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	cmplStd/test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'cmplStd/test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'cmplStd/test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	internal usages: 1
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@0614e0>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <virtualMethod @0614e0> - <virtualMethod+39 @061507>)
	cmplStd/test/lang/init.method.ci:41: (38 bytes: <virtualMethod @0614e0> - <virtualMethod+38 @061506>): trace("virtualMethod", x);
	<virtualMethod @0614e0>      : 1f f0 d6 04 00             load.ref <@04d6f0> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @0614e5>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @0614ea>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @0614ef>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @0614f4>   : 1f 86 da 04 00             load.ref <@04da86> ;"virtualMethod"
	<virtualMethod+25 @0614f9>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<virtualMethod+30 @0614fe>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @061502>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @061506>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:93: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:79: referenced as `virtualMethod`
	internal usages: 1
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@061508>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <forwardMethod @061508> - <forwardMethod+39 @06152f>)
	cmplStd/test/lang/init.method.ci:48: (38 bytes: <forwardMethod @061508> - <forwardMethod+38 @06152e>): trace("forwardMethod", x);
	<forwardMethod @061508>      : 1f f0 d6 04 00             load.ref <@04d6f0> ;"cmplStd/test/lang/init.method.ci"
	<forwardMethod+5 @06150d>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @061512>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @061517>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @06151c>   : 1f 0d d8 04 00             load.ref <@04d80d> ;"forwardMethod"
	<forwardMethod+25 @061521>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<forwardMethod+30 @061526>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @06152a>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @06152e>   : 03                         ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@061530>
.name: 'globalFunction'
.file: 'cmplStd/test/lang/init.method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <globalFunction @061530> - <globalFunction+39 @061557>)
	cmplStd/test/lang/init.method.ci:58: (38 bytes: <globalFunction @061530> - <globalFunction+38 @061556>): trace("globalFunction", x);
	<globalFunction @061530>      : 1f f0 d6 04 00             load.ref <@04d6f0> ;"cmplStd/test/lang/init.method.ci"
	<globalFunction+5 @061535>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @06153a>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @06153f>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @061544>   : 1f b9 da 04 00             load.ref <@04dab9> ;"globalFunction"
	<globalFunction+25 @061549>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<globalFunction+30 @06154e>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @061552>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @061556>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@061558>
.name: 'recordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:102: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:98: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:97: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:79: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 66
.offset: <@061568>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <staticMethod @061568> - <staticMethod+66 @0615aa>)
	cmplStd/test/lang/init.method.ci:85: (35 bytes: <staticMethod @061568> - <staticMethod+35 @06158b>): debug("extension.staticMethod");
	<staticMethod @061568>      : 1f f0 d6 04 00             load.ref <@04d6f0> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @06156d>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @061572>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @061577>   : 19                         load.z32
	<staticMethod+16 @061578>   : 1f 35 db 04 00             load.ref <@04db35> ;"extension.staticMethod"
	<staticMethod+21 @06157d>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<staticMethod+26 @061582>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @061587>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:86: (30 bytes: <staticMethod+35 @06158b> - <staticMethod+65 @0615a9>): if ((this) != null)
	<staticMethod+35 @06158b>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @06158f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @061594>   : 57                         ceq.i32
	<staticMethod+45 @061595>   : 05 14 00 00                jnz <staticMethod+65 @0615a9>
	cmplStd/test/lang/init.method.ci:87: (16 bytes: <staticMethod+49 @061599> - <staticMethod+65 @0615a9>): RecordMethodTest.staticMethod(this, x);
	<staticMethod+49 @061599>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @06159b>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @06159d>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @06159f>   : 1f b0 14 06 00             load.ref <@0614b0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @0615a4>   : 02                         call
	<staticMethod+61 @0615a5>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @0615a9>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@0615b0>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <virtualMethod @0615b0> - <virtualMethod+63 @0615ef>)
	cmplStd/test/lang/init.method.ci:91: (35 bytes: <virtualMethod @0615b0> - <virtualMethod+35 @0615d3>): debug("extension.virtualMethod");
	<virtualMethod @0615b0>      : 1f f0 d6 04 00             load.ref <@04d6f0> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @0615b5>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @0615ba>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @0615bf>   : 19                         load.z32
	<virtualMethod+16 @0615c0>   : 1f 4c db 04 00             load.ref <@04db4c> ;"extension.virtualMethod"
	<virtualMethod+21 @0615c5>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<virtualMethod+26 @0615ca>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @0615cf>   : 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:92: (27 bytes: <virtualMethod+35 @0615d3> - <virtualMethod+62 @0615ee>): if ((this) != null)
	<virtualMethod+35 @0615d3>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @0615d7>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @0615dc>   : 57                         ceq.i32
	<virtualMethod+45 @0615dd>   : 05 11 00 00                jnz <virtualMethod+62 @0615ee>
	cmplStd/test/lang/init.method.ci:93: (13 bytes: <virtualMethod+49 @0615e1> - <virtualMethod+62 @0615ee>): this.virtualMethod(this, x);
	<virtualMethod+49 @0615e1>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @0615e3>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @0615e5>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @0615e7>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @0615e9>   : 02                         call
	<virtualMethod+58 @0615ea>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @0615ee>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:98: referenced as `virtualMethod`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04f428>
.name: 'rgbF32'
.file: 'cmplStd/test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	cmplStd/test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@04f6a8>
.name: 'rgbU8'
.file: 'cmplStd/test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	cmplStd/test/lang/recUnion.ci:28: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:27: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:26: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `b`
	cmplStd/test/lang/recUnion.ci:28: referenced as `b`
	cmplStd/test/lang/recUnion.ci:27: referenced as `b`
	cmplStd/test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `g`
	cmplStd/test/lang/recUnion.ci:28: referenced as `g`
	cmplStd/test/lang/recUnion.ci:27: referenced as `g`
	cmplStd/test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `r`
	cmplStd/test/lang/recUnion.ci:28: referenced as `r`
	cmplStd/test/lang/recUnion.ci:27: referenced as `r`
	cmplStd/test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@04f928>
.name: 'color'
.file: 'cmplStd/test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `color`
	cmplStd/test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'cmplStd/test/lang/recUnion.ci:17'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'cmplStd/test/lang/recUnion.ci:18'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@04fb08>
.name: 'Color'
.file: 'cmplStd/test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@007018>, cast: static const inline)
.field destroy: function (size: 0, offs: <@007238>, cast: static const inline)
.field as: function (size: 0, offs: <@0074e8>, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'cmplStd/test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007018>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007238>
.name: 'destroy'
.owner: object
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0074e8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@0615f0>
.name: 'black'
.file: 'cmplStd/test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@0615f8>
.name: 'green'
.file: 'cmplStd/test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@061600>
.name: 'white'
.file: 'cmplStd/test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@061608>
.name: 'cyan'
.file: 'cmplStd/test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@061610>
.name: 'blue'
.file: 'cmplStd/test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04ffe8>
.name: 'record_pack0'
.file: 'cmplStd/test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@050448>
.name: 'record_pack1'
.file: 'cmplStd/test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0508a8>
.name: 'record_pack2'
.file: 'cmplStd/test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@050d08>
.name: 'record_pack4'
.file: 'cmplStd/test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@051168>
.name: 'record_pack8'
.file: 'cmplStd/test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0515c8>
.name: 'record_packDef'
.file: 'cmplStd/test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'cmplStd/test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	cmplStd/test/lang/useOperator.ci:260: referenced as `a`
	cmplStd/test/lang/useOperator.ci:237: referenced as `a`
	cmplStd/test/lang/useOperator.ci:214: referenced as `a`
	cmplStd/test/lang/useOperator.ci:191: referenced as `a`
	cmplStd/test/lang/useOperator.ci:168: referenced as `a`
	cmplStd/test/lang/useOperator.ci:145: referenced as `a`
	cmplStd/test/lang/useOperator.ci:122: referenced as `a`
	cmplStd/test/lang/useOperator.ci:99: referenced as `a`
	cmplStd/test/lang/useOperator.ci:76: referenced as `a`
	cmplStd/test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'cmplStd/test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	cmplStd/test/lang/useOperator.ci:261: referenced as `b`
	cmplStd/test/lang/useOperator.ci:238: referenced as `b`
	cmplStd/test/lang/useOperator.ci:215: referenced as `b`
	cmplStd/test/lang/useOperator.ci:192: referenced as `b`
	cmplStd/test/lang/useOperator.ci:169: referenced as `b`
	cmplStd/test/lang/useOperator.ci:146: referenced as `b`
	cmplStd/test/lang/useOperator.ci:123: referenced as `b`
	cmplStd/test/lang/useOperator.ci:100: referenced as `b`
	cmplStd/test/lang/useOperator.ci:77: referenced as `b`
	cmplStd/test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061618>
.name: 'shift'
.file: 'cmplStd/test/lang/useOperator.ci:5'
.value: 2
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:228: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:227: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:205: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:204: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:182: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:181: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:159: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:158: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:136: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:135: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:113: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:112: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:90: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:89: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:67: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:66: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:44: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061620>
.name: 'boolA'
.file: 'cmplStd/test/lang/useOperator.ci:7'
.value: true
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061628>
.name: 'boolB'
.file: 'cmplStd/test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:22: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061630>
.name: 'boolAnd'
.file: 'cmplStd/test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061638>
.name: 'boolIor'
.file: 'cmplStd/test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061640>
.name: 'boolXor'
.file: 'cmplStd/test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061648>
.name: 'boolNot'
.file: 'cmplStd/test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061650>
.name: 'boolCeq'
.file: 'cmplStd/test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061658>
.name: 'boolCne'
.file: 'cmplStd/test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061660>
.name: 'boolClt'
.file: 'cmplStd/test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061668>
.name: 'boolCle'
.file: 'cmplStd/test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061670>
.name: 'boolCgt'
.file: 'cmplStd/test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061678>
.name: 'boolCge'
.file: 'cmplStd/test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@061680>
.name: 'chrA'
.file: 'cmplStd/test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:44: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:43: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@061688>
.name: 'chrB'
.file: 'cmplStd/test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:45: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:34: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:33: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@061690>
.name: 'chrPls'
.file: 'cmplStd/test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@061698>
.name: 'chrNeg'
.file: 'cmplStd/test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616a0>
.name: 'chrCmt'
.file: 'cmplStd/test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616a8>
.name: 'chrAdd'
.file: 'cmplStd/test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616b0>
.name: 'chrSub'
.file: 'cmplStd/test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616b8>
.name: 'chrMul'
.file: 'cmplStd/test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616c0>
.name: 'chrDiv'
.file: 'cmplStd/test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616c8>
.name: 'chrMod'
.file: 'cmplStd/test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616d0>
.name: 'chrAnd'
.file: 'cmplStd/test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616d8>
.name: 'chrIor'
.file: 'cmplStd/test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616e0>
.name: 'chrXor'
.file: 'cmplStd/test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616e8>
.name: 'chrShl'
.file: 'cmplStd/test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0616f0>
.name: 'chrShr'
.file: 'cmplStd/test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0616f8>
.name: 'chrNot'
.file: 'cmplStd/test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061700>
.name: 'chrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061708>
.name: 'chrCne'
.file: 'cmplStd/test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061710>
.name: 'chrClt'
.file: 'cmplStd/test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061718>
.name: 'chrCle'
.file: 'cmplStd/test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061720>
.name: 'chrCgt'
.file: 'cmplStd/test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061728>
.name: 'chrCge'
.file: 'cmplStd/test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061730>
.name: 'i8A'
.file: 'cmplStd/test/lang/useOperator.ci:53'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:67: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:66: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061738>
.name: 'i8B'
.file: 'cmplStd/test/lang/useOperator.ci:54'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:68: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:57: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:56: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061740>
.name: 'i8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061748>
.name: 'i8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061750>
.name: 'i8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061758>
.name: 'i8Add'
.file: 'cmplStd/test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061760>
.name: 'i8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061768>
.name: 'i8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061770>
.name: 'i8Div'
.file: 'cmplStd/test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061778>
.name: 'i8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061780>
.name: 'i8And'
.file: 'cmplStd/test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061788>
.name: 'i8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061790>
.name: 'i8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@061798>
.name: 'i8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0617a0>
.name: 'i8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617a8>
.name: 'i8Not'
.file: 'cmplStd/test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617b0>
.name: 'i8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617b8>
.name: 'i8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617c0>
.name: 'i8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617c8>
.name: 'i8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617d0>
.name: 'i8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0617d8>
.name: 'i8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0617e0>
.name: 'u8A'
.file: 'cmplStd/test/lang/useOperator.ci:76'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:90: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:89: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0617e8>
.name: 'u8B'
.file: 'cmplStd/test/lang/useOperator.ci:77'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:91: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:80: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:79: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0617f0>
.name: 'u8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0617f8>
.name: 'u8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061800>
.name: 'u8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061808>
.name: 'u8Add'
.file: 'cmplStd/test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061810>
.name: 'u8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061818>
.name: 'u8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061820>
.name: 'u8Div'
.file: 'cmplStd/test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061828>
.name: 'u8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061830>
.name: 'u8And'
.file: 'cmplStd/test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061838>
.name: 'u8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061840>
.name: 'u8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061848>
.name: 'u8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@061850>
.name: 'u8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061858>
.name: 'u8Not'
.file: 'cmplStd/test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061860>
.name: 'u8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061868>
.name: 'u8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061870>
.name: 'u8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061878>
.name: 'u8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061880>
.name: 'u8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061888>
.name: 'u8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061890>
.name: 'i16A'
.file: 'cmplStd/test/lang/useOperator.ci:99'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:113: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:112: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061898>
.name: 'i16B'
.file: 'cmplStd/test/lang/useOperator.ci:100'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:114: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:103: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:102: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618a0>
.name: 'i16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618a8>
.name: 'i16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618b0>
.name: 'i16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618b8>
.name: 'i16Add'
.file: 'cmplStd/test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618c0>
.name: 'i16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618c8>
.name: 'i16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618d0>
.name: 'i16Div'
.file: 'cmplStd/test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618d8>
.name: 'i16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618e0>
.name: 'i16And'
.file: 'cmplStd/test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618e8>
.name: 'i16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618f0>
.name: 'i16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0618f8>
.name: 'i16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061900>
.name: 'i16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061908>
.name: 'i16Not'
.file: 'cmplStd/test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061910>
.name: 'i16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061918>
.name: 'i16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061920>
.name: 'i16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061928>
.name: 'i16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061930>
.name: 'i16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061938>
.name: 'i16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061940>
.name: 'u16A'
.file: 'cmplStd/test/lang/useOperator.ci:122'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:136: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:135: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061948>
.name: 'u16B'
.file: 'cmplStd/test/lang/useOperator.ci:123'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:137: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:126: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:125: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061950>
.name: 'u16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061958>
.name: 'u16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061960>
.name: 'u16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061968>
.name: 'u16Add'
.file: 'cmplStd/test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061970>
.name: 'u16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061978>
.name: 'u16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061980>
.name: 'u16Div'
.file: 'cmplStd/test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061988>
.name: 'u16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061990>
.name: 'u16And'
.file: 'cmplStd/test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061998>
.name: 'u16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0619a0>
.name: 'u16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0619a8>
.name: 'u16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0619b0>
.name: 'u16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619b8>
.name: 'u16Not'
.file: 'cmplStd/test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619c0>
.name: 'u16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619c8>
.name: 'u16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619d0>
.name: 'u16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619d8>
.name: 'u16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619e0>
.name: 'u16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0619e8>
.name: 'u16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0619f0>
.name: 'i32A'
.file: 'cmplStd/test/lang/useOperator.ci:145'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:159: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:158: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0619f8>
.name: 'i32B'
.file: 'cmplStd/test/lang/useOperator.ci:146'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:160: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:149: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:148: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a00>
.name: 'i32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a08>
.name: 'i32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a10>
.name: 'i32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a18>
.name: 'i32Add'
.file: 'cmplStd/test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a20>
.name: 'i32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a28>
.name: 'i32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a30>
.name: 'i32Div'
.file: 'cmplStd/test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a38>
.name: 'i32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a40>
.name: 'i32And'
.file: 'cmplStd/test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a48>
.name: 'i32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a50>
.name: 'i32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a58>
.name: 'i32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061a60>
.name: 'i32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a68>
.name: 'i32Not'
.file: 'cmplStd/test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a70>
.name: 'i32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a78>
.name: 'i32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a80>
.name: 'i32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a88>
.name: 'i32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a90>
.name: 'i32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061a98>
.name: 'i32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061aa0>
.name: 'u32A'
.file: 'cmplStd/test/lang/useOperator.ci:168'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:182: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:181: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061aa8>
.name: 'u32B'
.file: 'cmplStd/test/lang/useOperator.ci:169'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:183: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:172: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:171: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ab0>
.name: 'u32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ab8>
.name: 'u32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ac0>
.name: 'u32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ac8>
.name: 'u32Add'
.file: 'cmplStd/test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ad0>
.name: 'u32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ad8>
.name: 'u32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ae0>
.name: 'u32Div'
.file: 'cmplStd/test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061ae8>
.name: 'u32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061af0>
.name: 'u32And'
.file: 'cmplStd/test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061af8>
.name: 'u32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061b00>
.name: 'u32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061b08>
.name: 'u32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061b10>
.name: 'u32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b18>
.name: 'u32Not'
.file: 'cmplStd/test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b20>
.name: 'u32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b28>
.name: 'u32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b30>
.name: 'u32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b38>
.name: 'u32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b40>
.name: 'u32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061b48>
.name: 'u32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b50>
.name: 'i64A'
.file: 'cmplStd/test/lang/useOperator.ci:191'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:205: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:204: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b58>
.name: 'i64B'
.file: 'cmplStd/test/lang/useOperator.ci:192'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:206: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:195: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:194: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b60>
.name: 'i64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b68>
.name: 'i64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b70>
.name: 'i64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b78>
.name: 'i64Add'
.file: 'cmplStd/test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b80>
.name: 'i64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b88>
.name: 'i64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b90>
.name: 'i64Div'
.file: 'cmplStd/test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061b98>
.name: 'i64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061ba0>
.name: 'i64And'
.file: 'cmplStd/test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061ba8>
.name: 'i64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061bb0>
.name: 'i64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061bb8>
.name: 'i64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061bc0>
.name: 'i64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061bc8>
.name: 'i64Not'
.file: 'cmplStd/test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061bd0>
.name: 'i64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061bd8>
.name: 'i64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061be0>
.name: 'i64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061be8>
.name: 'i64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061bf0>
.name: 'i64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061bf8>
.name: 'i64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c00>
.name: 'u64A'
.file: 'cmplStd/test/lang/useOperator.ci:214'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:228: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:227: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c08>
.name: 'u64B'
.file: 'cmplStd/test/lang/useOperator.ci:215'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:229: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:218: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:217: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c10>
.name: 'u64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c18>
.name: 'u64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c20>
.name: 'u64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c28>
.name: 'u64Add'
.file: 'cmplStd/test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c30>
.name: 'u64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c38>
.name: 'u64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c40>
.name: 'u64Div'
.file: 'cmplStd/test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c48>
.name: 'u64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c50>
.name: 'u64And'
.file: 'cmplStd/test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c58>
.name: 'u64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c60>
.name: 'u64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c68>
.name: 'u64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061c70>
.name: 'u64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061c78>
.name: 'u64Not'
.file: 'cmplStd/test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061c80>
.name: 'u64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061c88>
.name: 'u64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061c90>
.name: 'u64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061c98>
.name: 'u64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061ca0>
.name: 'u64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061ca8>
.name: 'u64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cb0>
.name: 'f32A'
.file: 'cmplStd/test/lang/useOperator.ci:237'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cb8>
.name: 'f32B'
.file: 'cmplStd/test/lang/useOperator.ci:238'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:252: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:240: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cc0>
.name: 'f32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cc8>
.name: 'f32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cd0>
.name: 'f32Add'
.file: 'cmplStd/test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cd8>
.name: 'f32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061ce0>
.name: 'f32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061ce8>
.name: 'f32Div'
.file: 'cmplStd/test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061cf0>
.name: 'f32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061cf8>
.name: 'f32Not'
.file: 'cmplStd/test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d00>
.name: 'f32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d08>
.name: 'f32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d10>
.name: 'f32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d18>
.name: 'f32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d20>
.name: 'f32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d28>
.name: 'f32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d30>
.name: 'f64A'
.file: 'cmplStd/test/lang/useOperator.ci:260'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d38>
.name: 'f64B'
.file: 'cmplStd/test/lang/useOperator.ci:261'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:275: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:263: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d40>
.name: 'f64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d48>
.name: 'f64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d50>
.name: 'f64Add'
.file: 'cmplStd/test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d58>
.name: 'f64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d60>
.name: 'f64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d68>
.name: 'f64Div'
.file: 'cmplStd/test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061d70>
.name: 'f64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d78>
.name: 'f64Not'
.file: 'cmplStd/test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d80>
.name: 'f64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d88>
.name: 'f64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d90>
.name: 'f64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061d98>
.name: 'f64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061da0>
.name: 'f64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061da8>
.name: 'f64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061db0>
.name: 'ptrA'
.file: 'cmplStd/test/lang/useOperator.ci:283'
.value: null
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrA`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@061db8>
.name: 'ptrB'
.file: 'cmplStd/test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrB`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061dc0>
.name: 'ptrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061dc8>
.name: 'ptrCne'
.file: 'cmplStd/test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061dd0>
.name: 't'
.file: 'cmplStd/test/lang/stmt.if.ci:26'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:65: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:62: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:59: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:56: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:53: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:50: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:43: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:36: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:32: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061dd8>
.name: 'forIdx'
.file: 'cmplStd/test/lang/stmt.for.ci:12'
.usages:
	cmplStd/test/lang/stmt.for.ci:14: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061de0>
.name: 'testMathFloor_1'
.file: 'cmplStd/test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061de8>
.name: 'testMathFloor_2'
.file: 'cmplStd/test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061df0>
.name: 'testMathFloor_3'
.file: 'cmplStd/test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061df8>
.name: 'testMathFloor_4'
.file: 'cmplStd/test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e00>
.name: 'testMathFloor_5'
.file: 'cmplStd/test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e08>
.name: 'testMathFloor_6'
.file: 'cmplStd/test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e10>
.name: 'testMathSign_1F'
.file: 'cmplStd/test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e18>
.name: 'testMathSign_2F'
.file: 'cmplStd/test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e20>
.name: 'testMathSign_3F'
.file: 'cmplStd/test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e28>
.name: 'testMathSign_1f'
.file: 'cmplStd/test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e30>
.name: 'testMathSign_2f'
.file: 'cmplStd/test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e38>
.name: 'testMathSign_3f'
.file: 'cmplStd/test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e40>
.name: 'testMathAbs_1F'
.file: 'cmplStd/test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e48>
.name: 'testMathAbs_2F'
.file: 'cmplStd/test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e50>
.name: 'testMathAbs_3F'
.file: 'cmplStd/test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e58>
.name: 'testMathAbs_1f'
.file: 'cmplStd/test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e60>
.name: 'testMathAbs_2f'
.file: 'cmplStd/test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e68>
.name: 'testMathAbs_3f'
.file: 'cmplStd/test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e70>
.name: 'testMathMin_1f'
.file: 'cmplStd/test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e78>
.name: 'testMathMax_2f'
.file: 'cmplStd/test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e80>
.name: 'testMathMin_1F'
.file: 'cmplStd/test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e88>
.name: 'testMathMax_2F'
.file: 'cmplStd/test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e90>
.name: 'testMathClamp_1f'
.file: 'cmplStd/test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061e98>
.name: 'testMathClamp_1F'
.file: 'cmplStd/test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ea0>
.name: 'testMathLerp_1f'
.file: 'cmplStd/test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ea8>
.name: 'testMathLerp_1F'
.file: 'cmplStd/test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061eb0>
.name: 'testMathSmooth_1f'
.file: 'cmplStd/test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061eb8>
.name: 'testMathSmooth_1F'
.file: 'cmplStd/test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ec0>
.name: 'testMathMin_nan'
.file: 'cmplStd/test/std/test.math.ci:38'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ec8>
.name: 'testMathMin_1'
.file: 'cmplStd/test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ed0>
.name: 'testMathMax_nan'
.file: 'cmplStd/test/std/test.math.ci:40'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ed8>
.name: 'testMathMax_9'
.file: 'cmplStd/test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ee0>
.name: 'testMathSum_0'
.file: 'cmplStd/test/std/test.math.ci:43'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ee8>
.name: 'testMathSum_1'
.file: 'cmplStd/test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ef0>
.name: 'testMathSum_3'
.file: 'cmplStd/test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061ef8>
.name: 'testMathSum_55'
.file: 'cmplStd/test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f00>
.name: 'testMathEval_x'
.file: 'cmplStd/test/std/test.math.ci:48'
.value: 10
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:54: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:53: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:52: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:51: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:50: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:49: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f08>
.name: 'testMathEval_0'
.file: 'cmplStd/test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f10>
.name: 'testMathEval_1'
.file: 'cmplStd/test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f18>
.name: 'testMathEval_2'
.file: 'cmplStd/test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f20>
.name: 'testMathEval_3'
.file: 'cmplStd/test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f28>
.name: 'testMathEval_4'
.file: 'cmplStd/test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f30>
.name: 'testMathEval_5'
.file: 'cmplStd/test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f38>
.name: 'testMathEval_6'
.file: 'cmplStd/test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f40>
.name: 'testMathSin_f64'
.file: 'cmplStd/test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f48>
.name: 'testMathCos_f64'
.file: 'cmplStd/test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f50>
.name: 'testMathTan_f64'
.file: 'cmplStd/test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f58>
.name: 'testMathSinh_f64'
.file: 'cmplStd/test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f60>
.name: 'testMathCosh_f64'
.file: 'cmplStd/test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f68>
.name: 'testMathAsin_f64'
.file: 'cmplStd/test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f70>
.name: 'testMathAcos_f64'
.file: 'cmplStd/test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061f78>
.name: 'testMathCmp_f32'
.file: 'cmplStd/test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061f80>
.name: 'testMathCmp_f64'
.file: 'cmplStd/test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f88>
.name: 'testMathAbsMod_f64_0a'
.file: 'cmplStd/test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f90>
.name: 'testMathAbsMod_f64_0b'
.file: 'cmplStd/test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061f98>
.name: 'testMathAbsMod_f64_0c'
.file: 'cmplStd/test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fa0>
.name: 'testMathAbsMod_f64_9a'
.file: 'cmplStd/test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fa8>
.name: 'testMathAbsMod_f64_9b'
.file: 'cmplStd/test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fb0>
.name: 'testMathAbsMod_f64_9c'
.file: 'cmplStd/test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fb8>
.name: 'testMathAbsMod_f64_9d'
.file: 'cmplStd/test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fc0>
.name: 'testMathAbsMod_f64_8a'
.file: 'cmplStd/test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fc8>
.name: 'testMathAbsMod_f64_8b'
.file: 'cmplStd/test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fd0>
.name: 'testMathAbsMod_f64_8c'
.file: 'cmplStd/test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061fd8>
.name: 'testMathAbsMod_f64_8d'
.file: 'cmplStd/test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061fe0>
.name: 'testMathAbsMod_f32_0a'
.file: 'cmplStd/test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061fe8>
.name: 'testMathAbsMod_f32_0b'
.file: 'cmplStd/test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061ff0>
.name: 'testMathAbsMod_f32_0c'
.file: 'cmplStd/test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061ff8>
.name: 'testMathAbsMod_f32_9a'
.file: 'cmplStd/test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062000>
.name: 'testMathAbsMod_f32_9b'
.file: 'cmplStd/test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062008>
.name: 'testMathAbsMod_f32_9c'
.file: 'cmplStd/test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062010>
.name: 'testMathAbsMod_f32_9d'
.file: 'cmplStd/test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062018>
.name: 'testMathAbsMod_f32_8a'
.file: 'cmplStd/test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062020>
.name: 'testMathAbsMod_f32_8b'
.file: 'cmplStd/test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062028>
.name: 'testMathAbsMod_f32_8c'
.file: 'cmplStd/test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@062030>
.name: 'testMathAbsMod_f32_8d'
.file: 'cmplStd/test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 13382
.offset: <@062034>
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b8>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000160>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@000208>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@0002b0>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000358>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000400>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@0004a8>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000550>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005f8>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0006a0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000748>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0007f0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000898>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@000940>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@0009e8>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a90>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000b40>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000de0>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000e88>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005ed8>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@007d08>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@008658>, cast: static const inline)
.field System: typename (size: 0, offs: <@009360>, cast: static const typename(void))
.field true: bool (size: 0, offs: <@000000>, cast: static const val)
.field false: bool (size: 0, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 24, offs: <@012770>, cast: static const typename(val))
.field assertEq: function (size: 103, offs: <@05f780>, cast: static function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@013a08>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01f4c8>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@05ff30>, cast: static function)
.field Complex: function (size: 7, offs: <@05ff38>, cast: static function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 139, offs: <@05ff40>, cast: static function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@05ffd0>, cast: static function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@05fff0>, cast: static function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@025010>, cast: static const typename(val))
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@02a4a8>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@060058>, cast: static function)
.field mat4f: function (size: 21, offs: <@060090>, cast: static function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field transpose: function (size: 49, offs: <@0600a8>, cast: static function)
.field mul: function (size: 245, offs: <@0600e0>, cast: static function)
.field rotation: function (size: 454, offs: <@0601d8>, cast: static function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@0603a0>, cast: static function)
.field scale: function (size: 217, offs: <@0603f8>, cast: static function)
.field vec2d: typename (size: 16, offs: <@02f988>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@0604d8>, cast: static function)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field ceq: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@0604e0>, cast: static function)
.field indexOf: function (size: 50, offs: <@060508>, cast: static function)
.field lastIndexOf: function (size: 50, offs: <@060540>, cast: static function)
.field startsWith: function (size: 73, offs: <@060578>, cast: static function)
.field endsWith: function (size: 126, offs: <@0605c8>, cast: static function)
.field compare: function (size: 63, offs: <@060648>, cast: static function)
.field ignCaseCmp: function (size: 36, offs: <@0606d0>, cast: static function)
.field caseCmp: function (size: 14, offs: <@0606f8>, cast: static function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field equals: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@0355d0>, cast: static const typename(val))
.field append: function (size: 84, offs: <@060708>, cast: static function)
.field append: function (size: 707, offs: <@060770>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 236, offs: <@060a38>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 63, offs: <@060b38>, cast: static function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@060b78>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@060b80>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@060b88>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@060b90>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@060b98>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@060ba0>, cast: static variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <@060ba8>, cast: static variable(f32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@060bb0>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@060bb8>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@060bc0>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@060bc8>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@060bd0>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@060bd8>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@060be0>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@060be8>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@060bf0>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@060bf8>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@060c00>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@060c08>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@060c10>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@060c18>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@060c20>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@060c28>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@060c30>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@060c38>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@060c40>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@060c48>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@060c50>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@060c58>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@060c60>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@060c68>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@060c70>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@060c78>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@060c80>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@060c88>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@060c90>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@060c98>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@060ca0>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@060ca8>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@060cb0>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@060cb8>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@060cc0>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@060cc8>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@060cd0>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@060cd8>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@060ce0>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@060ce8>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@060cf0>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@060cf8>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@060d00>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@060d08>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@060d10>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@060d18>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@060d20>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@060d28>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@060d30>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@060d38>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@060d40>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@060d48>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@060d50>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@060d58>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@060d60>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@060d68>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@040410>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@040550>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@060d70>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@060d78>, cast: static variable(val))
.field pi64: float64 (size: 8, offs: <@060d80>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@060d88>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@060d90>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@060d98>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@060da0>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@060da8>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@060db0>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@060db8>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@060dc0>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@060dc8>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@060dd0>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@060dd8>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@060de0>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@060de8>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@060df0>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@060df8>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@060e00>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@060e08>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@060e10>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@060e18>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@060e20>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@060e28>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@060e30>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@060e38>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@060e40>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@060e48>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@060e50>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@060e58>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@060e60>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@060e68>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@060e70>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@060e78>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@060e80>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@060e88>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@060e90>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@060e98>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@060ea0>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@060ea8>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@060eb0>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@060eb8>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@060ec0>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@060ec8>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@060ed0>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@060ed8>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@060ee0>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@060ee8>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@060ef0>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@060ef8>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@060f00>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@060f08>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@060f10>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@060f18>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@060f20>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@060f28>, cast: static function)
.field stackOverflow: function (size: 24, offs: <@060f30>, cast: static function)
.field divisionByZero: function (size: 12, offs: <@060f48>, cast: static function)
.field abortExecution: function (size: 68, offs: <@060f58>, cast: static function)
.field invalidMemoryAccess: function (size: 13, offs: <@060fa0>, cast: static function)
.field invalidInstruction: function (size: 2, offs: <@060fb0>, cast: static function)
.field tryExecErr0: int32 (size: 4, offs: <@060fb8>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@060fc0>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@060fc8>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@060fd0>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@060fd8>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@060fe0>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@060fe8>, cast: static variable(i32))
.field value: int64 (size: 8, offs: <@060ff0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@060ff8>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@061000>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@061008>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@061010>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@061018>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@061020>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@061028>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@061030>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@061038>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@061040>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@061048>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@061050>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@061058>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@061060>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@061068>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@061070>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@061078>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@061080>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@061088>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@061090>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@061098>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@0610a0>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@0610a8>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@0610b0>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@0610b8>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@0610c0>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@0610c8>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@0610d0>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@0610d8>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@0610e0>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@0610e8>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@0610f0>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@0610f8>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@061100>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@061108>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@061110>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@061118>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@061120>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@061128>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@061130>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@061138>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@061140>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@061148>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@061150>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@061158>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@061160>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@061168>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@061170>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@061178>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@061180>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@061188>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@061190>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@061198>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@0611a0>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@0611a8>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@0611b0>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@0611b8>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@0611c0>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@0611c8>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@0611d0>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@0611d8>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@0611e0>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@0611e8>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@0611f0>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@0611f8>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@061200>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@061208>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@061210>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@061218>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@061220>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@061228>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@061230>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@061238>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@061240>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@061248>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@061250>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@061258>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@061260>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@061268>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@061270>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@061278>, cast: static variable(ref))
.field variable: int32 (size: 4, offs: <@061280>, cast: static variable(i32))
.field constant: int32 (size: 4, offs: <@061288>, cast: static const variable(i32))
.field ComplexVal: typename (size: 16, offs: <@049360>, cast: static const typename(val))
.field ComplexObj: object (size: 20, offs: <@049540>, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, offs: <@061290>, cast: static variable(val))
.field objInitImplicit: ComplexObj (size: 4, offs: <@0612a0>, cast: static variable(ref))
.field objInitExplicit: object (size: 4, offs: <@0612a8>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@0612b0>, cast: static function)
.field funAdd: function (size: 8, offs: <@0612b8>, cast: static function)
.field funAddResult: int32 (size: 4, offs: <@0612c0>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@0612c8>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@0612d0>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@0612d8>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@0612e0>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@0612e8>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@0612f0>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@0612f8>, cast: static function)
.field fib: function (size: 54, offs: <@061300>, cast: static function)
.field fibonacci_13: uint32 (size: 4, offs: <@061338>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@061340>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@061348>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@061350>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@061358>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@061360>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@061368>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@061370>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@061378>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@061380>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@061388>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@061390>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@061398>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@0613a0>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@0613a8>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@0613b0>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@0613b8>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@0613c0>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@0613c8>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@04bb10>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@04bc50>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@0613d0>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@0613d8>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@0613e0>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@0613e8>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@0613f0>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@0613f8>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@061400>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@061408>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@061410>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@061418>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@061420>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@061428>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@061430>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@061438>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@061440>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@061448>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@061450>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@061458>, cast: static variable(i32))
.field RecordMemberTest: typename (size: 32, offs: <@04cc50>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@061490>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@04db68>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@061530>, cast: static function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@061558>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@061568>, cast: static function)
.field virtualMethod: function (size: 63, offs: <@0615b0>, cast: static function)
.field rgbF32: typename (size: 16, offs: <@04f428>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@04f6a8>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@04f928>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@04fb08>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@0615f0>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@0615f8>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@061600>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@061608>, cast: static variable(val))
.field blue: color (size: 4, offs: <@061610>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@04ffe8>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@050448>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0508a8>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@050d08>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@051168>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@0515c8>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@061618>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@061620>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@061628>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@061630>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@061638>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@061640>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@061648>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@061650>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@061658>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@061660>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@061668>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@061670>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@061678>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@061680>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@061688>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@061690>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@061698>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@0616a0>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@0616a8>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@0616b0>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@0616b8>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@0616c0>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@0616c8>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@0616d0>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@0616d8>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@0616e0>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@0616e8>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@0616f0>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@0616f8>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@061700>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@061708>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@061710>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@061718>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@061720>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@061728>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@061730>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@061738>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@061740>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@061748>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@061750>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@061758>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@061760>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@061768>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@061770>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@061778>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@061780>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@061788>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@061790>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@061798>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@0617a0>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@0617a8>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@0617b0>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@0617b8>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@0617c0>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@0617c8>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@0617d0>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@0617d8>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@0617e0>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@0617e8>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@0617f0>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@0617f8>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@061800>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@061808>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@061810>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@061818>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@061820>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@061828>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@061830>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@061838>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@061840>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@061848>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@061850>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@061858>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@061860>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@061868>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@061870>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@061878>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@061880>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@061888>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@061890>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@061898>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@0618a0>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@0618a8>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@0618b0>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@0618b8>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@0618c0>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@0618c8>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@0618d0>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@0618d8>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@0618e0>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@0618e8>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@0618f0>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@0618f8>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@061900>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@061908>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@061910>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@061918>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@061920>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@061928>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@061930>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@061938>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@061940>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@061948>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@061950>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@061958>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@061960>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@061968>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@061970>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@061978>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@061980>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@061988>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@061990>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@061998>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@0619a0>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@0619a8>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@0619b0>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@0619b8>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@0619c0>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@0619c8>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@0619d0>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@0619d8>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@0619e0>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@0619e8>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@0619f0>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@0619f8>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@061a00>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@061a08>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@061a10>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@061a18>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@061a20>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@061a28>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@061a30>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@061a38>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@061a40>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@061a48>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@061a50>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@061a58>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@061a60>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@061a68>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@061a70>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@061a78>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@061a80>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@061a88>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@061a90>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@061a98>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@061aa0>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@061aa8>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@061ab0>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@061ab8>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@061ac0>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@061ac8>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@061ad0>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@061ad8>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@061ae0>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@061ae8>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@061af0>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@061af8>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@061b00>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@061b08>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@061b10>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@061b18>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@061b20>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@061b28>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@061b30>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@061b38>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@061b40>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@061b48>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@061b50>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@061b58>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@061b60>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@061b68>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@061b70>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@061b78>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@061b80>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@061b88>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@061b90>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@061b98>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@061ba0>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@061ba8>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@061bb0>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@061bb8>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@061bc0>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@061bc8>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@061bd0>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@061bd8>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@061be0>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@061be8>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@061bf0>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@061bf8>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@061c00>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@061c08>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@061c10>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@061c18>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@061c20>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@061c28>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@061c30>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@061c38>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@061c40>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@061c48>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@061c50>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@061c58>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@061c60>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@061c68>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@061c70>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@061c78>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@061c80>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@061c88>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@061c90>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@061c98>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@061ca0>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@061ca8>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@061cb0>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@061cb8>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@061cc0>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@061cc8>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@061cd0>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@061cd8>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@061ce0>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@061ce8>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@061cf0>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@061cf8>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@061d00>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@061d08>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@061d10>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@061d18>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@061d20>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@061d28>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@061d30>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@061d38>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@061d40>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@061d48>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@061d50>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@061d58>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@061d60>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@061d68>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@061d70>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@061d78>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@061d80>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@061d88>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@061d90>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@061d98>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@061da0>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@061da8>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@061db0>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@061db8>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@061dc0>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@061dc8>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@061dd0>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@061dd8>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@061de0>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@061de8>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@061df0>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@061df8>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@061e00>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@061e08>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@061e10>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@061e18>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@061e20>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@061e28>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@061e30>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@061e38>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@061e40>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@061e48>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@061e50>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@061e58>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@061e60>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@061e68>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@061e70>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@061e78>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@061e80>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@061e88>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@061e90>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@061e98>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@061ea0>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@061ea8>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@061eb0>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@061eb8>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@061ec0>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@061ec8>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@061ed0>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@061ed8>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@061ee0>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@061ee8>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@061ef0>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@061ef8>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@061f00>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@061f08>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@061f10>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@061f18>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@061f20>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@061f28>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@061f30>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@061f38>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@061f40>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@061f48>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@061f50>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@061f58>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@061f60>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@061f68>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@061f70>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@061f78>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@061f80>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@061f88>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@061f90>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@061f98>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@061fa0>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@061fa8>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@061fb0>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@061fb8>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@061fc0>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@061fc8>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@061fd0>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@061fd8>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@061fe0>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@061fe8>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@061ff0>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@061ff8>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@062000>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@062008>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@062010>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@062018>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@062020>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@062028>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@062030>, cast: static variable(f32))
.field .main: function (size: 13382, offs: <@062034>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static signed(value: uint8): int8 := int8(value);
		static signed(value: uint16): int16 := int16(value);
		static signed(value: uint32): int32 := int32(value);
		static signed(value: uint64): int64 := int64(value);
		static unsigned(value: int8): uint8 := uint8(value);
		static unsigned(value: int16): uint16 := uint16(value);
		static unsigned(value: int32): uint32 := uint32(value);
		static unsigned(value: int64): uint64 := uint64(value);
		static sizeof(type: typename): int32 := typename.size(type);
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[] := null;
			};
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				extras: variant[1] := {
					void(extras[0] := (message));
				};
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.extras := (extras));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: int32): int32 := bool(x != 0) ? bool(x < 0) ? int32(-1) : 1 : 0;
			static sign(x: int64): int32 := bool(x != (0)) ? bool(x < (0)) ? int32(-1) : 1 : 0;
			static sign(x: uint32): int32 := bool(x > (0)) ? 1 : 0;
			static sign(x: uint64): int32 := bool(x > (0)) ? 1 : 0;
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static abs(x: int32): int32 := bool(x < 0) ? int32(-x) : x;
			static abs(x: int64): int64 := bool(x < (0)) ? int64(-x) : x;
			static abs(x: uint32): uint32 := x;
			static abs(x: uint64): uint64 := x;
			static abs(x: float32): float32 := bool(x < (0)) ? float32(-x) : x;
			static abs(x: float64): float64 := bool(x < (0)) ? float64(-x) : x;
			static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
			static min(a: int64, b: int64): int64 := bool(a < b) ? a : b;
			static min(a: uint32, b: uint32): uint32 := bool(a < b) ? a : b;
			static min(a: uint64, b: uint64): uint64 := bool(a < b) ? a : b;
			static min(a: float32, b: float32): float32 := bool(a < b) ? a : b;
			static min(a: float64, b: float64): float64 := bool(a < b) ? a : b;
			static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
			static max(a: int64, b: int64): int64 := bool(a > b) ? a : b;
			static max(a: uint32, b: uint32): uint32 := bool(a > b) ? a : b;
			static max(a: uint64, b: uint64): uint64 := bool(a > b) ? a : b;
			static max(a: float32, b: float32): float32 := bool(a > b) ? a : b;
			static max(a: float64, b: float64): float64 := bool(a > b) ? a : b;
			static clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static mean(data: float64[]): float64 := {
				return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float32(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float64(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else if (bool(i == 1)) {
					float64(x := float64((1) - x));
					bool(complement := true);
				}
				else if (bool(i == 2)) {
					bool(negate := bool(!negate));
					bool(complement := true);
				}
				else if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(emit(void(struct(a), neg.p2d)));
		static add(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), add.p2d)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static inv(a: Complex): Complex := {
			d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		static vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))));
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static add(a: float32, b: vec4f): vec4f := add(void(vec4f(a), b));
		static add(a: vec4f, b: float32): vec4f := add(void(a, vec4f(b)));
		static sub(a: float32, b: vec4f): vec4f := sub(void(vec4f(a), b));
		static sub(a: vec4f, b: float32): vec4f := sub(void(a, vec4f(b)));
		static mul(a: float32, b: vec4f): vec4f := mul(void(vec4f(a), b));
		static mul(a: vec4f, b: float32): vec4f := mul(void(a, vec4f(b)));
		static div(a: float32, b: vec4f): vec4f := div(void(vec4f(a), b));
		static div(a: vec4f, b: float32): vec4f := div(void(a, vec4f(b)));
		static min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(void(max(void(vec, min)), max));
		static clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(void(void(vec, vec4f(min)), vec4f(max)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static transpose(const mat: mat4f): mat4f := {
			return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static add(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), add.p2d)));
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)));
		static div(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), div.p2d)));
		static min(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), min.p2d)));
		static max(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), max.p2d)));
		static ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static equals(const str: char[*], const with: char[*]): bool := bool(compare(void(void(str, with), caseCmp)) == 0);
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			if (format.showSign) {
				if (bool((sign) == 0)) {
					char(sign := '+');
				}
			}
			radix: int32 := format.precision;
			if (bool(radix == 0)) {
				int32(radix := 10);
			}
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format));
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				void(formatInt.showSign := format.showSign);
				void(formatInt.precision := 0);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(format.padLen - format.precision));
			};
			formatDec: FormatFlags := {
				void(formatDec.showSign := false);
				void(formatDec.precision := 0);
				void(formatDec.padChr := '0');
				void(formatDec.padLen := format.precision);
			};
			sign: char := bool(value < (0)) ? ('-') : 0;
			fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
			int32(pos := append(void(output, void(pos, "."))));
			float64(fract := float64(fract * float64.pow(void(10, format.precision))));
			int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.showSign := false);
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static emitNfcF32: float32 := emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static noError(ptr: pointer): void := {
		};
		static stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static variable: int32;
		static const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
		};
		static valInitImplicit: ComplexVal := {
			void(valInitImplicit.re := (8));
			void(valInitImplicit.im := (0));
		};
		static objInitImplicit: ComplexObj := {
			void(objInitImplicit := create(ComplexObj));
			void(objInitImplicit.re := (8));
			void(objInitImplicit.im := (0));
		};
		static objInitExplicit: object := {
			void(objInitExplicit := create(ComplexObj));
			void(objInitExplicit.re := (8));
			void(objInitExplicit.im := (0));
		};
		static empty(): void := {
		};
		static funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := typeofRecord.size;
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := typeofBase.size;
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				void(globalRec.constant := 4);
				void(globalRec.member := (0));
			};
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			static virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else if (bool(t == 1)) {
				raise(void(void(void(raise.debug, 10), "t == 1"), t));
			}
			else if (bool(t == 2)) {
				raise(void(void(void(raise.debug, 10), "t == 2"), t));
			}
			else if (bool(t == 3)) {
				raise(void(void(void(raise.debug, 10), "t == 3"), t));
			}
			else if (bool(t == 4)) {
				raise(void(void(void(raise.debug, 10), "t == 4"), t));
			}
			else if (bool(t == 5)) {
				raise(void(void(void(raise.debug, 10), "t == 5"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (13382 bytes: <.main @062034> - <.main+13382 @06547a>)
	cmplStd/lib/string.ci:149: (14 bytes: <.main @062034> - <.main+14 @062042>): static const whiteSpace: char[] := " \t\n\r"
	<.main @062034>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @062039>    : 1f 52 1a 03 00             load.ref <@031a52> ;" \t\n\r"
	<.main+10 @06203e>   : 23 60 07 06                store.m64 <@060760> ;append.whiteSpace
	cmplStd/lib/string.ci:150: (14 bytes: <.main+14 @062042> - <.main+28 @062050>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @062042>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @062047>   : 1f 63 1a 03 00             load.ref <@031a63> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @06204c>   : 23 68 07 06                store.m64 <@060768> ;append.radixDigits
	cmplStd/lib/string.ci:267: (24 bytes: <.main+28 @062050> - <.main+52 @062068>): static const format: FormatFlags := {...}
	:: (7 bytes: <.main+28 @062050> - <.main+35 @062057>): format.showSign := false;
	<.main+28 @062050>   : 19                         load.z32
	<.main+29 @062051>   : 1f 28 0b 06 00             load.ref <@060b28> ;append.format
	<.main+34 @062056>   : 2b                         store.i8
	:: (5 bytes: <.main+35 @062057> - <.main+40 @06205c>): format.precision := 0;
	<.main+35 @062057>   : 19                         load.z32
	<.main+36 @062058>   : 24 2c 0b 06                store.m32 <@060b2c> ;append.format+4
	:: (7 bytes: <.main+40 @06205c> - <.main+47 @062063>): format.padChr := (0);
	<.main+40 @06205c>   : 19                         load.z32
	<.main+41 @06205d>   : 1f 30 0b 06 00             load.ref <@060b30> ;append.format+8
	<.main+46 @062062>   : 2b                         store.i8
	:: (5 bytes: <.main+47 @062063> - <.main+52 @062068>): format.padLen := 0;
	<.main+47 @062063>   : 19                         load.z32
	<.main+48 @062064>   : 24 34 0b 06                store.m32 <@060b34> ;append.format+12
	cmplStd/test/lang/emit.ci:3: (5 bytes: <.main+52 @062068> - <.main+57 @06206d>): static emitldz32: int32 := emit(load.z32)
	<.main+52 @062068>   : 19                         load.z32
	<.main+53 @062069>   : 24 78 0b 06                store.m32 <@060b78> ;emitldz32
	cmplStd/test/lang/emit.ci:4: (5 bytes: <.main+57 @06206d> - <.main+62 @062072>): static emitldz64: int64 := emit(load.z64)
	<.main+57 @06206d>   : 1a                         load.z64
	<.main+58 @06206e>   : 23 80 0b 06                store.m64 <@060b80> ;emitldz64
	cmplStd/test/lang/emit.ci:6: (9 bytes: <.main+62 @062072> - <.main+71 @06207b>): static emitA: int32 := 42
	<.main+62 @062072>   : 1c 2a 00 00 00             load.c32 42
	<.main+67 @062077>   : 24 88 0b 06                store.m32 <@060b88> ;emitA
	cmplStd/test/lang/emit.ci:7: (9 bytes: <.main+71 @06207b> - <.main+80 @062084>): static emitB: int32 := 96
	<.main+71 @06207b>   : 1c 60 00 00 00             load.c32 96
	<.main+76 @062080>   : 24 90 0b 06                store.m32 <@060b90> ;emitB
	cmplStd/test/lang/emit.ci:10: (13 bytes: <.main+80 @062084> - <.main+93 @062091>): static emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+80 @062084>   : 20 88 0b 06                load.m32 <@060b88> ;emitA
	<.main+84 @062088>   : 20 90 0b 06                load.m32 <@060b90> ;emitB
	<.main+88 @06208c>   : 51                         add.i32
	<.main+89 @06208d>   : 24 98 0b 06                store.m32 <@060b98> ;emitAddI32
	cmplStd/test/lang/emit.ci:13: (15 bytes: <.main+93 @062091> - <.main+108 @0620a0>): static emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+93 @062091>   : 1c 0a 00 00 00             load.c32 10
	<.main+98 @062096>   : 1c 05 00 00 00             load.c32 5
	<.main+103 @06209b>  : 54                         div.i32
	<.main+104 @06209c>  : 24 a0 0b 06                store.m32 <@060ba0> ;emitDivI32
	cmplStd/test/lang/emit.ci:16: (19 bytes: <.main+108 @0620a0> - <.main+127 @0620b3>): static emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+108 @0620a0>  : 7f c3 f5 48 40             load.f32 3.140000
	<.main+113 @0620a5>  : 7f 00 00 00 40             load.f32 2.000000
	<.main+118 @0620aa>  : 74                         div.f32
	<.main+119 @0620ab>  : 01 21 00 00                nfc(33) ;float32.sin(x: float32): float32
	<.main+123 @0620af>  : 24 a8 0b 06                store.m32 <@060ba8> ;emitNfcF32
	cmplStd/test/lang/emit.ci:23: (9 bytes: <.main+127 @0620b3> - <.main+136 @0620bc>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+127 @0620b3>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+132 @0620b8>  : 24 b0 0b 06                store.m32 <@060bb0> ;emitFloatAsInt1
	cmplStd/test/lang/emit.ci:24: (10 bytes: <.main+136 @0620bc> - <.main+146 @0620c6>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+136 @0620bc>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+141 @0620c1>  : 5b                         i32.2i64
	<.main+142 @0620c2>  : 23 b8 0b 06                store.m64 <@060bb8> ;emitFloatAsInt2
	cmplStd/test/lang/emit.ci:25: (14 bytes: <.main+146 @0620c6> - <.main+160 @0620d4>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+146 @0620c6>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+155 @0620cf>  : 6a                         i64.2i32
	<.main+156 @0620d0>  : 24 c0 0b 06                store.m32 <@060bc0> ;emitFloatAsInt3
	cmplStd/test/lang/emit.ci:26: (13 bytes: <.main+160 @0620d4> - <.main+173 @0620e1>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+160 @0620d4>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+169 @0620dd>  : 23 c8 0b 06                store.m64 <@060bc8> ;emitFloatAsInt4
	cmplStd/test/lang/emit.ci:29: (14 bytes: <.main+173 @0620e1> - <.main+187 @0620ef>): static emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+173 @0620e1>  : 1c 03 00 00 00             load.c32 3
	<.main+178 @0620e6>  : 1f cd a0 03 00             load.ref <@03a0cd> ;"string"
	<.main+183 @0620eb>  : 23 d0 0b 06                store.m64 <@060bd0> ;emitSlice
	cmplStd/test/lang/inlineMacros.ci:10: (9 bytes: <.main+187 @0620ef> - <.main+196 @0620f8>): static i3: int32 := 3
	<.main+187 @0620ef>  : 1c 03 00 00 00             load.c32 3
	<.main+192 @0620f4>  : 24 d8 0b 06                store.m32 <@060bd8> ;i3
	cmplStd/test/lang/inlineMacros.ci:11: (9 bytes: <.main+196 @0620f8> - <.main+205 @062101>): static i6: int32 := 6
	<.main+196 @0620f8>  : 1c 06 00 00 00             load.c32 6
	<.main+201 @0620fd>  : 24 e0 0b 06                store.m32 <@060be0> ;i6
	cmplStd/test/lang/inlineMacros.ci:12: (9 bytes: <.main+205 @062101> - <.main+214 @06210a>): static i2: int32 := 2
	<.main+205 @062101>  : 1c 02 00 00 00             load.c32 2
	<.main+210 @062106>  : 24 e8 0b 06                store.m32 <@060be8> ;i2
	cmplStd/test/lang/inlineMacros.ci:13: (9 bytes: <.main+214 @06210a> - <.main+223 @062113>): static i8: int32 := 8
	<.main+214 @06210a>  : 1c 08 00 00 00             load.c32 8
	<.main+219 @06210f>  : 24 f0 0b 06                store.m32 <@060bf0> ;i8
	cmplStd/test/lang/inlineMacros.ci:15: (5 bytes: <.main+223 @062113> - <.main+228 @062118>): static zeroVal: int32 := zero(3, 6)
	<.main+223 @062113>  : 19                         load.z32
	<.main+224 @062114>  : 24 f8 0b 06                store.m32 <@060bf8> ;zeroVal
	cmplStd/test/lang/inlineMacros.ci:16: (5 bytes: <.main+228 @062118> - <.main+233 @06211d>): static zeroVar: int32 := zero(i3, i6)
	<.main+228 @062118>  : 19                         load.z32
	<.main+229 @062119>  : 24 00 0c 06                store.m32 <@060c00> ;zeroVar
	cmplStd/test/lang/inlineMacros.ci:17: (5 bytes: <.main+233 @06211d> - <.main+238 @062122>): static zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+233 @06211d>  : 19                         load.z32
	<.main+234 @06211e>  : 24 08 0c 06                store.m32 <@060c08> ;zeroXpr
	cmplStd/test/lang/inlineMacros.ci:19: (9 bytes: <.main+238 @062122> - <.main+247 @06212b>): static lastVal: int32 := last(3, 6)
	<.main+238 @062122>  : 1c 06 00 00 00             load.c32 6
	<.main+243 @062127>  : 24 10 0c 06                store.m32 <@060c10> ;lastVal
	cmplStd/test/lang/inlineMacros.ci:20: (8 bytes: <.main+247 @06212b> - <.main+255 @062133>): static lastVar: int32 := last(i3, i6)
	<.main+247 @06212b>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+251 @06212f>  : 24 18 0c 06                store.m32 <@060c18> ;lastVar
	cmplStd/test/lang/inlineMacros.ci:21: (16 bytes: <.main+255 @062133> - <.main+271 @062143>): static lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+255 @062133>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+259 @062137>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @06213b>  : 0c ff ff ff                inc.i32(-1)
	<.main+267 @06213f>  : 24 20 0c 06                store.m32 <@060c20> ;lastXpr
	cmplStd/test/lang/inlineMacros.ci:23: (13 bytes: <.main+271 @062143> - <.main+284 @062150>): static sum2Val: int32 := sum(3, 6)
	<.main+271 @062143>  : 1c 03 00 00 00             load.c32 3
	<.main+276 @062148>  : 0c 06 00 00                inc.i32(+6)
	<.main+280 @06214c>  : 24 28 0c 06                store.m32 <@060c28> ;sum2Val
	cmplStd/test/lang/inlineMacros.ci:24: (13 bytes: <.main+284 @062150> - <.main+297 @06215d>): static sum2Var: int32 := sum(i3, i6)
	<.main+284 @062150>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+288 @062154>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+292 @062158>  : 51                         add.i32
	<.main+293 @062159>  : 24 30 0c 06                store.m32 <@060c30> ;sum2Var
	cmplStd/test/lang/inlineMacros.ci:25: (25 bytes: <.main+297 @06215d> - <.main+322 @062176>): static sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+297 @06215d>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+301 @062161>  : 0c 01 00 00                inc.i32(+1)
	<.main+305 @062165>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+309 @062169>  : 0c 01 00 00                inc.i32(+1)
	<.main+313 @06216d>  : 51                         add.i32
	<.main+314 @06216e>  : 0c fe ff ff                inc.i32(-2)
	<.main+318 @062172>  : 24 38 0c 06                store.m32 <@060c38> ;sum2Xpr
	cmplStd/test/lang/inlineMacros.ci:27: (28 bytes: <.main+322 @062176> - <.main+350 @062192>): static any2Val: int32 := any(3, 6)
	<.main+322 @062176>  : 1c 03 00 00 00             load.c32 3
	<.main+327 @06217b>  : 10 00                      dup.x32 sp(0)
	<.main+329 @06217d>  : 06 0a 00 00                jz <.main+339 @062187>
	<.main+333 @062181>  : 10 00                      dup.x32 sp(0)
	<.main+335 @062183>  : 04 09 00 00                jmp <.main+344 @06218c>
	<.main+339 @062187>  : 1c 06 00 00 00             load.c32 6
	<.main+344 @06218c>  : 13 01                      set.x32 sp(1)
	<.main+346 @06218e>  : 24 40 0c 06                store.m32 <@060c40> ;any2Val
	cmplStd/test/lang/inlineMacros.ci:28: (26 bytes: <.main+350 @062192> - <.main+376 @0621ac>): static any2Var: int32 := any(i3, i6)
	<.main+350 @062192>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+354 @062196>  : 10 00                      dup.x32 sp(0)
	<.main+356 @062198>  : 06 0a 00 00                jz <.main+366 @0621a2>
	<.main+360 @06219c>  : 10 00                      dup.x32 sp(0)
	<.main+362 @06219e>  : 04 08 00 00                jmp <.main+370 @0621a6>
	<.main+366 @0621a2>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+370 @0621a6>  : 13 01                      set.x32 sp(1)
	<.main+372 @0621a8>  : 24 48 0c 06                store.m32 <@060c48> ;any2Var
	cmplStd/test/lang/inlineMacros.ci:29: (38 bytes: <.main+376 @0621ac> - <.main+414 @0621d2>): static any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+376 @0621ac>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+380 @0621b0>  : 0c 01 00 00                inc.i32(+1)
	<.main+384 @0621b4>  : 10 00                      dup.x32 sp(0)
	<.main+386 @0621b6>  : 06 0a 00 00                jz <.main+396 @0621c0>
	<.main+390 @0621ba>  : 10 00                      dup.x32 sp(0)
	<.main+392 @0621bc>  : 04 0c 00 00                jmp <.main+404 @0621c8>
	<.main+396 @0621c0>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+400 @0621c4>  : 0c 01 00 00                inc.i32(+1)
	<.main+404 @0621c8>  : 13 01                      set.x32 sp(1)
	<.main+406 @0621ca>  : 0c ff ff ff                inc.i32(-1)
	<.main+410 @0621ce>  : 24 50 0c 06                store.m32 <@060c50> ;any2Xpr
	cmplStd/test/lang/inlineMacros.ci:31: (37 bytes: <.main+414 @0621d2> - <.main+451 @0621f7>): static min2Val: int32 := min(3, 6)
	<.main+414 @0621d2>  : 1c 03 00 00 00             load.c32 3
	<.main+419 @0621d7>  : 1c 06 00 00 00             load.c32 6
	<.main+424 @0621dc>  : 10 01                      dup.x32 sp(1)
	<.main+426 @0621de>  : 10 01                      dup.x32 sp(1)
	<.main+428 @0621e0>  : 58                         clt.i32
	<.main+429 @0621e1>  : 06 0a 00 00                jz <.main+439 @0621eb>
	<.main+433 @0621e5>  : 10 01                      dup.x32 sp(1)
	<.main+435 @0621e7>  : 04 06 00 00                jmp <.main+441 @0621ed>
	<.main+439 @0621eb>  : 10 00                      dup.x32 sp(0)
	<.main+441 @0621ed>  : 13 02                      set.x32 sp(2)
	<.main+443 @0621ef>  : 09 fc ff ff                inc.sp(-4)
	<.main+447 @0621f3>  : 24 58 0c 06                store.m32 <@060c58> ;min2Val
	cmplStd/test/lang/inlineMacros.ci:32: (35 bytes: <.main+451 @0621f7> - <.main+486 @06221a>): static min2Var: int32 := min(i3, i6)
	<.main+451 @0621f7>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+455 @0621fb>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+459 @0621ff>  : 10 01                      dup.x32 sp(1)
	<.main+461 @062201>  : 10 01                      dup.x32 sp(1)
	<.main+463 @062203>  : 58                         clt.i32
	<.main+464 @062204>  : 06 0a 00 00                jz <.main+474 @06220e>
	<.main+468 @062208>  : 10 01                      dup.x32 sp(1)
	<.main+470 @06220a>  : 04 06 00 00                jmp <.main+476 @062210>
	<.main+474 @06220e>  : 10 00                      dup.x32 sp(0)
	<.main+476 @062210>  : 13 02                      set.x32 sp(2)
	<.main+478 @062212>  : 09 fc ff ff                inc.sp(-4)
	<.main+482 @062216>  : 24 60 0c 06                store.m32 <@060c60> ;min2Var
	cmplStd/test/lang/inlineMacros.ci:33: (47 bytes: <.main+486 @06221a> - <.main+533 @062249>): static min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+486 @06221a>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+490 @06221e>  : 0c 01 00 00                inc.i32(+1)
	<.main+494 @062222>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+498 @062226>  : 0c 01 00 00                inc.i32(+1)
	<.main+502 @06222a>  : 10 01                      dup.x32 sp(1)
	<.main+504 @06222c>  : 10 01                      dup.x32 sp(1)
	<.main+506 @06222e>  : 58                         clt.i32
	<.main+507 @06222f>  : 06 0a 00 00                jz <.main+517 @062239>
	<.main+511 @062233>  : 10 01                      dup.x32 sp(1)
	<.main+513 @062235>  : 04 06 00 00                jmp <.main+519 @06223b>
	<.main+517 @062239>  : 10 00                      dup.x32 sp(0)
	<.main+519 @06223b>  : 13 02                      set.x32 sp(2)
	<.main+521 @06223d>  : 09 fc ff ff                inc.sp(-4)
	<.main+525 @062241>  : 0c ff ff ff                inc.i32(-1)
	<.main+529 @062245>  : 24 68 0c 06                store.m32 <@060c68> ;min2Xpr
	cmplStd/test/lang/inlineMacros.ci:35: (37 bytes: <.main+533 @062249> - <.main+570 @06226e>): static max2Val: int32 := max(3, 6)
	<.main+533 @062249>  : 1c 03 00 00 00             load.c32 3
	<.main+538 @06224e>  : 1c 06 00 00 00             load.c32 6
	<.main+543 @062253>  : 10 01                      dup.x32 sp(1)
	<.main+545 @062255>  : 10 01                      dup.x32 sp(1)
	<.main+547 @062257>  : 59                         cgt.i32
	<.main+548 @062258>  : 06 0a 00 00                jz <.main+558 @062262>
	<.main+552 @06225c>  : 10 01                      dup.x32 sp(1)
	<.main+554 @06225e>  : 04 06 00 00                jmp <.main+560 @062264>
	<.main+558 @062262>  : 10 00                      dup.x32 sp(0)
	<.main+560 @062264>  : 13 02                      set.x32 sp(2)
	<.main+562 @062266>  : 09 fc ff ff                inc.sp(-4)
	<.main+566 @06226a>  : 24 70 0c 06                store.m32 <@060c70> ;max2Val
	cmplStd/test/lang/inlineMacros.ci:36: (35 bytes: <.main+570 @06226e> - <.main+605 @062291>): static max2Var: int32 := max(i3, i6)
	<.main+570 @06226e>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+574 @062272>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+578 @062276>  : 10 01                      dup.x32 sp(1)
	<.main+580 @062278>  : 10 01                      dup.x32 sp(1)
	<.main+582 @06227a>  : 59                         cgt.i32
	<.main+583 @06227b>  : 06 0a 00 00                jz <.main+593 @062285>
	<.main+587 @06227f>  : 10 01                      dup.x32 sp(1)
	<.main+589 @062281>  : 04 06 00 00                jmp <.main+595 @062287>
	<.main+593 @062285>  : 10 00                      dup.x32 sp(0)
	<.main+595 @062287>  : 13 02                      set.x32 sp(2)
	<.main+597 @062289>  : 09 fc ff ff                inc.sp(-4)
	<.main+601 @06228d>  : 24 78 0c 06                store.m32 <@060c78> ;max2Var
	cmplStd/test/lang/inlineMacros.ci:37: (47 bytes: <.main+605 @062291> - <.main+652 @0622c0>): static max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+605 @062291>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+609 @062295>  : 0c 01 00 00                inc.i32(+1)
	<.main+613 @062299>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+617 @06229d>  : 0c 01 00 00                inc.i32(+1)
	<.main+621 @0622a1>  : 10 01                      dup.x32 sp(1)
	<.main+623 @0622a3>  : 10 01                      dup.x32 sp(1)
	<.main+625 @0622a5>  : 59                         cgt.i32
	<.main+626 @0622a6>  : 06 0a 00 00                jz <.main+636 @0622b0>
	<.main+630 @0622aa>  : 10 01                      dup.x32 sp(1)
	<.main+632 @0622ac>  : 04 06 00 00                jmp <.main+638 @0622b2>
	<.main+636 @0622b0>  : 10 00                      dup.x32 sp(0)
	<.main+638 @0622b2>  : 13 02                      set.x32 sp(2)
	<.main+640 @0622b4>  : 09 fc ff ff                inc.sp(-4)
	<.main+644 @0622b8>  : 0c ff ff ff                inc.i32(-1)
	<.main+648 @0622bc>  : 24 80 0c 06                store.m32 <@060c80> ;max2Xpr
	cmplStd/test/lang/inlineMacros.ci:41: (25 bytes: <.main+652 @0622c0> - <.main+677 @0622d9>): static sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+652 @0622c0>  : 1c 03 00 00 00             load.c32 3
	<.main+657 @0622c5>  : 1c 06 00 00 00             load.c32 6
	<.main+662 @0622ca>  : 1c 02 00 00 00             load.c32 2
	<.main+667 @0622cf>  : 0c 08 00 00                inc.i32(+8)
	<.main+671 @0622d3>  : 51                         add.i32
	<.main+672 @0622d4>  : 51                         add.i32
	<.main+673 @0622d5>  : 24 88 0c 06                store.m32 <@060c88> ;sumRlVal
	cmplStd/test/lang/inlineMacros.ci:42: (21 bytes: <.main+677 @0622d9> - <.main+698 @0622ee>): static sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+677 @0622d9>  : 1c 03 00 00 00             load.c32 3
	<.main+682 @0622de>  : 0c 06 00 00                inc.i32(+6)
	<.main+686 @0622e2>  : 0c 02 00 00                inc.i32(+2)
	<.main+690 @0622e6>  : 0c 08 00 00                inc.i32(+8)
	<.main+694 @0622ea>  : 24 90 0c 06                store.m32 <@060c90> ;sumLrVal
	cmplStd/test/lang/inlineMacros.ci:43: (23 bytes: <.main+698 @0622ee> - <.main+721 @062305>): static sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+698 @0622ee>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+702 @0622f2>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+706 @0622f6>  : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+710 @0622fa>  : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+714 @0622fe>  : 51                         add.i32
	<.main+715 @0622ff>  : 51                         add.i32
	<.main+716 @062300>  : 51                         add.i32
	<.main+717 @062301>  : 24 98 0c 06                store.m32 <@060c98> ;sumRlVar
	cmplStd/test/lang/inlineMacros.ci:44: (23 bytes: <.main+721 @062305> - <.main+744 @06231c>): static sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+721 @062305>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+725 @062309>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+729 @06230d>  : 51                         add.i32
	<.main+730 @06230e>  : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+734 @062312>  : 51                         add.i32
	<.main+735 @062313>  : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+739 @062317>  : 51                         add.i32
	<.main+740 @062318>  : 24 a0 0c 06                store.m32 <@060ca0> ;sumLrVar
	cmplStd/test/lang/inlineMacros.ci:45: (43 bytes: <.main+744 @06231c> - <.main+787 @062347>): static sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+744 @06231c>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+748 @062320>  : 0c 01 00 00                inc.i32(+1)
	<.main+752 @062324>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+756 @062328>  : 0c 01 00 00                inc.i32(+1)
	<.main+760 @06232c>  : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+764 @062330>  : 0c 01 00 00                inc.i32(+1)
	<.main+768 @062334>  : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+772 @062338>  : 0c 01 00 00                inc.i32(+1)
	<.main+776 @06233c>  : 51                         add.i32
	<.main+777 @06233d>  : 51                         add.i32
	<.main+778 @06233e>  : 51                         add.i32
	<.main+779 @06233f>  : 0c fc ff ff                inc.i32(-4)
	<.main+783 @062343>  : 24 a8 0c 06                store.m32 <@060ca8> ;sumRlXpr
	cmplStd/test/lang/inlineMacros.ci:46: (43 bytes: <.main+787 @062347> - <.main+830 @062372>): static sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+787 @062347>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+791 @06234b>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @06234f>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+799 @062353>  : 0c 01 00 00                inc.i32(+1)
	<.main+803 @062357>  : 51                         add.i32
	<.main+804 @062358>  : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+808 @06235c>  : 0c 01 00 00                inc.i32(+1)
	<.main+812 @062360>  : 51                         add.i32
	<.main+813 @062361>  : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+817 @062365>  : 0c 01 00 00                inc.i32(+1)
	<.main+821 @062369>  : 51                         add.i32
	<.main+822 @06236a>  : 0c fc ff ff                inc.i32(-4)
	<.main+826 @06236e>  : 24 b0 0c 06                store.m32 <@060cb0> ;sumLrXpr
	cmplStd/test/lang/inlineMacros.ci:50: (66 bytes: <.main+830 @062372> - <.main+896 @0623b4>): static anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+830 @062372>  : 1c 03 00 00 00             load.c32 3
	<.main+835 @062377>  : 10 00                      dup.x32 sp(0)
	<.main+837 @062379>  : 06 0a 00 00                jz <.main+847 @062383>
	<.main+841 @06237d>  : 10 00                      dup.x32 sp(0)
	<.main+843 @06237f>  : 04 2f 00 00                jmp <.main+890 @0623ae>
	<.main+847 @062383>  : 1c 06 00 00 00             load.c32 6
	<.main+852 @062388>  : 10 00                      dup.x32 sp(0)
	<.main+854 @06238a>  : 06 0a 00 00                jz <.main+864 @062394>
	<.main+858 @06238e>  : 10 00                      dup.x32 sp(0)
	<.main+860 @062390>  : 04 1c 00 00                jmp <.main+888 @0623ac>
	<.main+864 @062394>  : 1c 02 00 00 00             load.c32 2
	<.main+869 @062399>  : 10 00                      dup.x32 sp(0)
	<.main+871 @06239b>  : 06 0a 00 00                jz <.main+881 @0623a5>
	<.main+875 @06239f>  : 10 00                      dup.x32 sp(0)
	<.main+877 @0623a1>  : 04 09 00 00                jmp <.main+886 @0623aa>
	<.main+881 @0623a5>  : 1c 08 00 00 00             load.c32 8
	<.main+886 @0623aa>  : 13 01                      set.x32 sp(1)
	<.main+888 @0623ac>  : 13 01                      set.x32 sp(1)
	<.main+890 @0623ae>  : 13 01                      set.x32 sp(1)
	<.main+892 @0623b0>  : 24 b8 0c 06                store.m32 <@060cb8> ;anyRlVal
	cmplStd/test/lang/inlineMacros.ci:51: (66 bytes: <.main+896 @0623b4> - <.main+962 @0623f6>): static anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+896 @0623b4>  : 1c 03 00 00 00             load.c32 3
	<.main+901 @0623b9>  : 10 00                      dup.x32 sp(0)
	<.main+903 @0623bb>  : 06 0a 00 00                jz <.main+913 @0623c5>
	<.main+907 @0623bf>  : 10 00                      dup.x32 sp(0)
	<.main+909 @0623c1>  : 04 09 00 00                jmp <.main+918 @0623ca>
	<.main+913 @0623c5>  : 1c 06 00 00 00             load.c32 6
	<.main+918 @0623ca>  : 13 01                      set.x32 sp(1)
	<.main+920 @0623cc>  : 10 00                      dup.x32 sp(0)
	<.main+922 @0623ce>  : 06 0a 00 00                jz <.main+932 @0623d8>
	<.main+926 @0623d2>  : 10 00                      dup.x32 sp(0)
	<.main+928 @0623d4>  : 04 09 00 00                jmp <.main+937 @0623dd>
	<.main+932 @0623d8>  : 1c 02 00 00 00             load.c32 2
	<.main+937 @0623dd>  : 13 01                      set.x32 sp(1)
	<.main+939 @0623df>  : 10 00                      dup.x32 sp(0)
	<.main+941 @0623e1>  : 06 0a 00 00                jz <.main+951 @0623eb>
	<.main+945 @0623e5>  : 10 00                      dup.x32 sp(0)
	<.main+947 @0623e7>  : 04 09 00 00                jmp <.main+956 @0623f0>
	<.main+951 @0623eb>  : 1c 08 00 00 00             load.c32 8
	<.main+956 @0623f0>  : 13 01                      set.x32 sp(1)
	<.main+958 @0623f2>  : 24 c0 0c 06                store.m32 <@060cc0> ;anyLrVal
	cmplStd/test/lang/inlineMacros.ci:52: (62 bytes: <.main+962 @0623f6> - <.main+1024 @062434>): static anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+962 @0623f6>  : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+966 @0623fa>  : 10 00                      dup.x32 sp(0)
	<.main+968 @0623fc>  : 06 0a 00 00                jz <.main+978 @062406>
	<.main+972 @062400>  : 10 00                      dup.x32 sp(0)
	<.main+974 @062402>  : 04 2c 00 00                jmp <.main+1018 @06242e>
	<.main+978 @062406>  : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+982 @06240a>  : 10 00                      dup.x32 sp(0)
	<.main+984 @06240c>  : 06 0a 00 00                jz <.main+994 @062416>
	<.main+988 @062410>  : 10 00                      dup.x32 sp(0)
	<.main+990 @062412>  : 04 1a 00 00                jmp <.main+1016 @06242c>
	<.main+994 @062416>  : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+998 @06241a>  : 10 00                      dup.x32 sp(0)
	<.main+1000 @06241c> : 06 0a 00 00                jz <.main+1010 @062426>
	<.main+1004 @062420> : 10 00                      dup.x32 sp(0)
	<.main+1006 @062422> : 04 08 00 00                jmp <.main+1014 @06242a>
	<.main+1010 @062426> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1014 @06242a> : 13 01                      set.x32 sp(1)
	<.main+1016 @06242c> : 13 01                      set.x32 sp(1)
	<.main+1018 @06242e> : 13 01                      set.x32 sp(1)
	<.main+1020 @062430> : 24 c8 0c 06                store.m32 <@060cc8> ;anyRlVar
	cmplStd/test/lang/inlineMacros.ci:53: (62 bytes: <.main+1024 @062434> - <.main+1086 @062472>): static anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+1024 @062434> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1028 @062438> : 10 00                      dup.x32 sp(0)
	<.main+1030 @06243a> : 06 0a 00 00                jz <.main+1040 @062444>
	<.main+1034 @06243e> : 10 00                      dup.x32 sp(0)
	<.main+1036 @062440> : 04 08 00 00                jmp <.main+1044 @062448>
	<.main+1040 @062444> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1044 @062448> : 13 01                      set.x32 sp(1)
	<.main+1046 @06244a> : 10 00                      dup.x32 sp(0)
	<.main+1048 @06244c> : 06 0a 00 00                jz <.main+1058 @062456>
	<.main+1052 @062450> : 10 00                      dup.x32 sp(0)
	<.main+1054 @062452> : 04 08 00 00                jmp <.main+1062 @06245a>
	<.main+1058 @062456> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1062 @06245a> : 13 01                      set.x32 sp(1)
	<.main+1064 @06245c> : 10 00                      dup.x32 sp(0)
	<.main+1066 @06245e> : 06 0a 00 00                jz <.main+1076 @062468>
	<.main+1070 @062462> : 10 00                      dup.x32 sp(0)
	<.main+1072 @062464> : 04 08 00 00                jmp <.main+1080 @06246c>
	<.main+1076 @062468> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1080 @06246c> : 13 01                      set.x32 sp(1)
	<.main+1082 @06246e> : 24 d0 0c 06                store.m32 <@060cd0> ;anyLrVar
	cmplStd/test/lang/inlineMacros.ci:54: (82 bytes: <.main+1086 @062472> - <.main+1168 @0624c4>): static anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1086 @062472> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1090 @062476> : 0c 01 00 00                inc.i32(+1)
	<.main+1094 @06247a> : 10 00                      dup.x32 sp(0)
	<.main+1096 @06247c> : 06 0a 00 00                jz <.main+1106 @062486>
	<.main+1100 @062480> : 10 00                      dup.x32 sp(0)
	<.main+1102 @062482> : 04 38 00 00                jmp <.main+1158 @0624ba>
	<.main+1106 @062486> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1110 @06248a> : 0c 01 00 00                inc.i32(+1)
	<.main+1114 @06248e> : 10 00                      dup.x32 sp(0)
	<.main+1116 @062490> : 06 0a 00 00                jz <.main+1126 @06249a>
	<.main+1120 @062494> : 10 00                      dup.x32 sp(0)
	<.main+1122 @062496> : 04 22 00 00                jmp <.main+1156 @0624b8>
	<.main+1126 @06249a> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1130 @06249e> : 0c 01 00 00                inc.i32(+1)
	<.main+1134 @0624a2> : 10 00                      dup.x32 sp(0)
	<.main+1136 @0624a4> : 06 0a 00 00                jz <.main+1146 @0624ae>
	<.main+1140 @0624a8> : 10 00                      dup.x32 sp(0)
	<.main+1142 @0624aa> : 04 0c 00 00                jmp <.main+1154 @0624b6>
	<.main+1146 @0624ae> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1150 @0624b2> : 0c 01 00 00                inc.i32(+1)
	<.main+1154 @0624b6> : 13 01                      set.x32 sp(1)
	<.main+1156 @0624b8> : 13 01                      set.x32 sp(1)
	<.main+1158 @0624ba> : 13 01                      set.x32 sp(1)
	<.main+1160 @0624bc> : 0c ff ff ff                inc.i32(-1)
	<.main+1164 @0624c0> : 24 d8 0c 06                store.m32 <@060cd8> ;anyRlXpr
	cmplStd/test/lang/inlineMacros.ci:55: (82 bytes: <.main+1168 @0624c4> - <.main+1250 @062516>): static anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1168 @0624c4> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1172 @0624c8> : 0c 01 00 00                inc.i32(+1)
	<.main+1176 @0624cc> : 10 00                      dup.x32 sp(0)
	<.main+1178 @0624ce> : 06 0a 00 00                jz <.main+1188 @0624d8>
	<.main+1182 @0624d2> : 10 00                      dup.x32 sp(0)
	<.main+1184 @0624d4> : 04 0c 00 00                jmp <.main+1196 @0624e0>
	<.main+1188 @0624d8> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1192 @0624dc> : 0c 01 00 00                inc.i32(+1)
	<.main+1196 @0624e0> : 13 01                      set.x32 sp(1)
	<.main+1198 @0624e2> : 10 00                      dup.x32 sp(0)
	<.main+1200 @0624e4> : 06 0a 00 00                jz <.main+1210 @0624ee>
	<.main+1204 @0624e8> : 10 00                      dup.x32 sp(0)
	<.main+1206 @0624ea> : 04 0c 00 00                jmp <.main+1218 @0624f6>
	<.main+1210 @0624ee> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1214 @0624f2> : 0c 01 00 00                inc.i32(+1)
	<.main+1218 @0624f6> : 13 01                      set.x32 sp(1)
	<.main+1220 @0624f8> : 10 00                      dup.x32 sp(0)
	<.main+1222 @0624fa> : 06 0a 00 00                jz <.main+1232 @062504>
	<.main+1226 @0624fe> : 10 00                      dup.x32 sp(0)
	<.main+1228 @062500> : 04 0c 00 00                jmp <.main+1240 @06250c>
	<.main+1232 @062504> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1236 @062508> : 0c 01 00 00                inc.i32(+1)
	<.main+1240 @06250c> : 13 01                      set.x32 sp(1)
	<.main+1242 @06250e> : 0c ff ff ff                inc.i32(-1)
	<.main+1246 @062512> : 24 e0 0c 06                store.m32 <@060ce0> ;anyLrXpr
	cmplStd/test/lang/inlineMacros.ci:59: (93 bytes: <.main+1250 @062516> - <.main+1343 @062573>): static minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+1250 @062516> : 1c 03 00 00 00             load.c32 3
	<.main+1255 @06251b> : 1c 06 00 00 00             load.c32 6
	<.main+1260 @062520> : 1c 02 00 00 00             load.c32 2
	<.main+1265 @062525> : 1c 08 00 00 00             load.c32 8
	<.main+1270 @06252a> : 10 01                      dup.x32 sp(1)
	<.main+1272 @06252c> : 10 01                      dup.x32 sp(1)
	<.main+1274 @06252e> : 58                         clt.i32
	<.main+1275 @06252f> : 06 0a 00 00                jz <.main+1285 @062539>
	<.main+1279 @062533> : 10 01                      dup.x32 sp(1)
	<.main+1281 @062535> : 04 06 00 00                jmp <.main+1287 @06253b>
	<.main+1285 @062539> : 10 00                      dup.x32 sp(0)
	<.main+1287 @06253b> : 13 02                      set.x32 sp(2)
	<.main+1289 @06253d> : 09 fc ff ff                inc.sp(-4)
	<.main+1293 @062541> : 10 01                      dup.x32 sp(1)
	<.main+1295 @062543> : 10 01                      dup.x32 sp(1)
	<.main+1297 @062545> : 58                         clt.i32
	<.main+1298 @062546> : 06 0a 00 00                jz <.main+1308 @062550>
	<.main+1302 @06254a> : 10 01                      dup.x32 sp(1)
	<.main+1304 @06254c> : 04 06 00 00                jmp <.main+1310 @062552>
	<.main+1308 @062550> : 10 00                      dup.x32 sp(0)
	<.main+1310 @062552> : 13 02                      set.x32 sp(2)
	<.main+1312 @062554> : 09 fc ff ff                inc.sp(-4)
	<.main+1316 @062558> : 10 01                      dup.x32 sp(1)
	<.main+1318 @06255a> : 10 01                      dup.x32 sp(1)
	<.main+1320 @06255c> : 58                         clt.i32
	<.main+1321 @06255d> : 06 0a 00 00                jz <.main+1331 @062567>
	<.main+1325 @062561> : 10 01                      dup.x32 sp(1)
	<.main+1327 @062563> : 04 06 00 00                jmp <.main+1333 @062569>
	<.main+1331 @062567> : 10 00                      dup.x32 sp(0)
	<.main+1333 @062569> : 13 02                      set.x32 sp(2)
	<.main+1335 @06256b> : 09 fc ff ff                inc.sp(-4)
	<.main+1339 @06256f> : 24 e8 0c 06                store.m32 <@060ce8> ;minRlVal
	cmplStd/test/lang/inlineMacros.ci:60: (93 bytes: <.main+1343 @062573> - <.main+1436 @0625d0>): static minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+1343 @062573> : 1c 03 00 00 00             load.c32 3
	<.main+1348 @062578> : 1c 06 00 00 00             load.c32 6
	<.main+1353 @06257d> : 10 01                      dup.x32 sp(1)
	<.main+1355 @06257f> : 10 01                      dup.x32 sp(1)
	<.main+1357 @062581> : 58                         clt.i32
	<.main+1358 @062582> : 06 0a 00 00                jz <.main+1368 @06258c>
	<.main+1362 @062586> : 10 01                      dup.x32 sp(1)
	<.main+1364 @062588> : 04 06 00 00                jmp <.main+1370 @06258e>
	<.main+1368 @06258c> : 10 00                      dup.x32 sp(0)
	<.main+1370 @06258e> : 13 02                      set.x32 sp(2)
	<.main+1372 @062590> : 09 fc ff ff                inc.sp(-4)
	<.main+1376 @062594> : 1c 02 00 00 00             load.c32 2
	<.main+1381 @062599> : 10 01                      dup.x32 sp(1)
	<.main+1383 @06259b> : 10 01                      dup.x32 sp(1)
	<.main+1385 @06259d> : 58                         clt.i32
	<.main+1386 @06259e> : 06 0a 00 00                jz <.main+1396 @0625a8>
	<.main+1390 @0625a2> : 10 01                      dup.x32 sp(1)
	<.main+1392 @0625a4> : 04 06 00 00                jmp <.main+1398 @0625aa>
	<.main+1396 @0625a8> : 10 00                      dup.x32 sp(0)
	<.main+1398 @0625aa> : 13 02                      set.x32 sp(2)
	<.main+1400 @0625ac> : 09 fc ff ff                inc.sp(-4)
	<.main+1404 @0625b0> : 1c 08 00 00 00             load.c32 8
	<.main+1409 @0625b5> : 10 01                      dup.x32 sp(1)
	<.main+1411 @0625b7> : 10 01                      dup.x32 sp(1)
	<.main+1413 @0625b9> : 58                         clt.i32
	<.main+1414 @0625ba> : 06 0a 00 00                jz <.main+1424 @0625c4>
	<.main+1418 @0625be> : 10 01                      dup.x32 sp(1)
	<.main+1420 @0625c0> : 04 06 00 00                jmp <.main+1426 @0625c6>
	<.main+1424 @0625c4> : 10 00                      dup.x32 sp(0)
	<.main+1426 @0625c6> : 13 02                      set.x32 sp(2)
	<.main+1428 @0625c8> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @0625cc> : 24 f0 0c 06                store.m32 <@060cf0> ;minLrVal
	cmplStd/test/lang/inlineMacros.ci:61: (89 bytes: <.main+1436 @0625d0> - <.main+1525 @062629>): static minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+1436 @0625d0> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1440 @0625d4> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1444 @0625d8> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1448 @0625dc> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1452 @0625e0> : 10 01                      dup.x32 sp(1)
	<.main+1454 @0625e2> : 10 01                      dup.x32 sp(1)
	<.main+1456 @0625e4> : 58                         clt.i32
	<.main+1457 @0625e5> : 06 0a 00 00                jz <.main+1467 @0625ef>
	<.main+1461 @0625e9> : 10 01                      dup.x32 sp(1)
	<.main+1463 @0625eb> : 04 06 00 00                jmp <.main+1469 @0625f1>
	<.main+1467 @0625ef> : 10 00                      dup.x32 sp(0)
	<.main+1469 @0625f1> : 13 02                      set.x32 sp(2)
	<.main+1471 @0625f3> : 09 fc ff ff                inc.sp(-4)
	<.main+1475 @0625f7> : 10 01                      dup.x32 sp(1)
	<.main+1477 @0625f9> : 10 01                      dup.x32 sp(1)
	<.main+1479 @0625fb> : 58                         clt.i32
	<.main+1480 @0625fc> : 06 0a 00 00                jz <.main+1490 @062606>
	<.main+1484 @062600> : 10 01                      dup.x32 sp(1)
	<.main+1486 @062602> : 04 06 00 00                jmp <.main+1492 @062608>
	<.main+1490 @062606> : 10 00                      dup.x32 sp(0)
	<.main+1492 @062608> : 13 02                      set.x32 sp(2)
	<.main+1494 @06260a> : 09 fc ff ff                inc.sp(-4)
	<.main+1498 @06260e> : 10 01                      dup.x32 sp(1)
	<.main+1500 @062610> : 10 01                      dup.x32 sp(1)
	<.main+1502 @062612> : 58                         clt.i32
	<.main+1503 @062613> : 06 0a 00 00                jz <.main+1513 @06261d>
	<.main+1507 @062617> : 10 01                      dup.x32 sp(1)
	<.main+1509 @062619> : 04 06 00 00                jmp <.main+1515 @06261f>
	<.main+1513 @06261d> : 10 00                      dup.x32 sp(0)
	<.main+1515 @06261f> : 13 02                      set.x32 sp(2)
	<.main+1517 @062621> : 09 fc ff ff                inc.sp(-4)
	<.main+1521 @062625> : 24 f8 0c 06                store.m32 <@060cf8> ;minRlVar
	cmplStd/test/lang/inlineMacros.ci:62: (89 bytes: <.main+1525 @062629> - <.main+1614 @062682>): static minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+1525 @062629> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1529 @06262d> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1533 @062631> : 10 01                      dup.x32 sp(1)
	<.main+1535 @062633> : 10 01                      dup.x32 sp(1)
	<.main+1537 @062635> : 58                         clt.i32
	<.main+1538 @062636> : 06 0a 00 00                jz <.main+1548 @062640>
	<.main+1542 @06263a> : 10 01                      dup.x32 sp(1)
	<.main+1544 @06263c> : 04 06 00 00                jmp <.main+1550 @062642>
	<.main+1548 @062640> : 10 00                      dup.x32 sp(0)
	<.main+1550 @062642> : 13 02                      set.x32 sp(2)
	<.main+1552 @062644> : 09 fc ff ff                inc.sp(-4)
	<.main+1556 @062648> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1560 @06264c> : 10 01                      dup.x32 sp(1)
	<.main+1562 @06264e> : 10 01                      dup.x32 sp(1)
	<.main+1564 @062650> : 58                         clt.i32
	<.main+1565 @062651> : 06 0a 00 00                jz <.main+1575 @06265b>
	<.main+1569 @062655> : 10 01                      dup.x32 sp(1)
	<.main+1571 @062657> : 04 06 00 00                jmp <.main+1577 @06265d>
	<.main+1575 @06265b> : 10 00                      dup.x32 sp(0)
	<.main+1577 @06265d> : 13 02                      set.x32 sp(2)
	<.main+1579 @06265f> : 09 fc ff ff                inc.sp(-4)
	<.main+1583 @062663> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1587 @062667> : 10 01                      dup.x32 sp(1)
	<.main+1589 @062669> : 10 01                      dup.x32 sp(1)
	<.main+1591 @06266b> : 58                         clt.i32
	<.main+1592 @06266c> : 06 0a 00 00                jz <.main+1602 @062676>
	<.main+1596 @062670> : 10 01                      dup.x32 sp(1)
	<.main+1598 @062672> : 04 06 00 00                jmp <.main+1604 @062678>
	<.main+1602 @062676> : 10 00                      dup.x32 sp(0)
	<.main+1604 @062678> : 13 02                      set.x32 sp(2)
	<.main+1606 @06267a> : 09 fc ff ff                inc.sp(-4)
	<.main+1610 @06267e> : 24 00 0d 06                store.m32 <@060d00> ;minLrVar
	cmplStd/test/lang/inlineMacros.ci:63: (109 bytes: <.main+1614 @062682> - <.main+1723 @0626ef>): static minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1614 @062682> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1618 @062686> : 0c 01 00 00                inc.i32(+1)
	<.main+1622 @06268a> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1626 @06268e> : 0c 01 00 00                inc.i32(+1)
	<.main+1630 @062692> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1634 @062696> : 0c 01 00 00                inc.i32(+1)
	<.main+1638 @06269a> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1642 @06269e> : 0c 01 00 00                inc.i32(+1)
	<.main+1646 @0626a2> : 10 01                      dup.x32 sp(1)
	<.main+1648 @0626a4> : 10 01                      dup.x32 sp(1)
	<.main+1650 @0626a6> : 58                         clt.i32
	<.main+1651 @0626a7> : 06 0a 00 00                jz <.main+1661 @0626b1>
	<.main+1655 @0626ab> : 10 01                      dup.x32 sp(1)
	<.main+1657 @0626ad> : 04 06 00 00                jmp <.main+1663 @0626b3>
	<.main+1661 @0626b1> : 10 00                      dup.x32 sp(0)
	<.main+1663 @0626b3> : 13 02                      set.x32 sp(2)
	<.main+1665 @0626b5> : 09 fc ff ff                inc.sp(-4)
	<.main+1669 @0626b9> : 10 01                      dup.x32 sp(1)
	<.main+1671 @0626bb> : 10 01                      dup.x32 sp(1)
	<.main+1673 @0626bd> : 58                         clt.i32
	<.main+1674 @0626be> : 06 0a 00 00                jz <.main+1684 @0626c8>
	<.main+1678 @0626c2> : 10 01                      dup.x32 sp(1)
	<.main+1680 @0626c4> : 04 06 00 00                jmp <.main+1686 @0626ca>
	<.main+1684 @0626c8> : 10 00                      dup.x32 sp(0)
	<.main+1686 @0626ca> : 13 02                      set.x32 sp(2)
	<.main+1688 @0626cc> : 09 fc ff ff                inc.sp(-4)
	<.main+1692 @0626d0> : 10 01                      dup.x32 sp(1)
	<.main+1694 @0626d2> : 10 01                      dup.x32 sp(1)
	<.main+1696 @0626d4> : 58                         clt.i32
	<.main+1697 @0626d5> : 06 0a 00 00                jz <.main+1707 @0626df>
	<.main+1701 @0626d9> : 10 01                      dup.x32 sp(1)
	<.main+1703 @0626db> : 04 06 00 00                jmp <.main+1709 @0626e1>
	<.main+1707 @0626df> : 10 00                      dup.x32 sp(0)
	<.main+1709 @0626e1> : 13 02                      set.x32 sp(2)
	<.main+1711 @0626e3> : 09 fc ff ff                inc.sp(-4)
	<.main+1715 @0626e7> : 0c ff ff ff                inc.i32(-1)
	<.main+1719 @0626eb> : 24 08 0d 06                store.m32 <@060d08> ;minRlXpr
	cmplStd/test/lang/inlineMacros.ci:64: (109 bytes: <.main+1723 @0626ef> - <.main+1832 @06275c>): static minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1723 @0626ef> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+1727 @0626f3> : 0c 01 00 00                inc.i32(+1)
	<.main+1731 @0626f7> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+1735 @0626fb> : 0c 01 00 00                inc.i32(+1)
	<.main+1739 @0626ff> : 10 01                      dup.x32 sp(1)
	<.main+1741 @062701> : 10 01                      dup.x32 sp(1)
	<.main+1743 @062703> : 58                         clt.i32
	<.main+1744 @062704> : 06 0a 00 00                jz <.main+1754 @06270e>
	<.main+1748 @062708> : 10 01                      dup.x32 sp(1)
	<.main+1750 @06270a> : 04 06 00 00                jmp <.main+1756 @062710>
	<.main+1754 @06270e> : 10 00                      dup.x32 sp(0)
	<.main+1756 @062710> : 13 02                      set.x32 sp(2)
	<.main+1758 @062712> : 09 fc ff ff                inc.sp(-4)
	<.main+1762 @062716> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+1766 @06271a> : 0c 01 00 00                inc.i32(+1)
	<.main+1770 @06271e> : 10 01                      dup.x32 sp(1)
	<.main+1772 @062720> : 10 01                      dup.x32 sp(1)
	<.main+1774 @062722> : 58                         clt.i32
	<.main+1775 @062723> : 06 0a 00 00                jz <.main+1785 @06272d>
	<.main+1779 @062727> : 10 01                      dup.x32 sp(1)
	<.main+1781 @062729> : 04 06 00 00                jmp <.main+1787 @06272f>
	<.main+1785 @06272d> : 10 00                      dup.x32 sp(0)
	<.main+1787 @06272f> : 13 02                      set.x32 sp(2)
	<.main+1789 @062731> : 09 fc ff ff                inc.sp(-4)
	<.main+1793 @062735> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+1797 @062739> : 0c 01 00 00                inc.i32(+1)
	<.main+1801 @06273d> : 10 01                      dup.x32 sp(1)
	<.main+1803 @06273f> : 10 01                      dup.x32 sp(1)
	<.main+1805 @062741> : 58                         clt.i32
	<.main+1806 @062742> : 06 0a 00 00                jz <.main+1816 @06274c>
	<.main+1810 @062746> : 10 01                      dup.x32 sp(1)
	<.main+1812 @062748> : 04 06 00 00                jmp <.main+1818 @06274e>
	<.main+1816 @06274c> : 10 00                      dup.x32 sp(0)
	<.main+1818 @06274e> : 13 02                      set.x32 sp(2)
	<.main+1820 @062750> : 09 fc ff ff                inc.sp(-4)
	<.main+1824 @062754> : 0c ff ff ff                inc.i32(-1)
	<.main+1828 @062758> : 24 10 0d 06                store.m32 <@060d10> ;minLrXpr
	cmplStd/test/lang/inlineMacros.ci:68: (93 bytes: <.main+1832 @06275c> - <.main+1925 @0627b9>): static maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+1832 @06275c> : 1c 03 00 00 00             load.c32 3
	<.main+1837 @062761> : 1c 06 00 00 00             load.c32 6
	<.main+1842 @062766> : 1c 02 00 00 00             load.c32 2
	<.main+1847 @06276b> : 1c 08 00 00 00             load.c32 8
	<.main+1852 @062770> : 10 01                      dup.x32 sp(1)
	<.main+1854 @062772> : 10 01                      dup.x32 sp(1)
	<.main+1856 @062774> : 59                         cgt.i32
	<.main+1857 @062775> : 06 0a 00 00                jz <.main+1867 @06277f>
	<.main+1861 @062779> : 10 01                      dup.x32 sp(1)
	<.main+1863 @06277b> : 04 06 00 00                jmp <.main+1869 @062781>
	<.main+1867 @06277f> : 10 00                      dup.x32 sp(0)
	<.main+1869 @062781> : 13 02                      set.x32 sp(2)
	<.main+1871 @062783> : 09 fc ff ff                inc.sp(-4)
	<.main+1875 @062787> : 10 01                      dup.x32 sp(1)
	<.main+1877 @062789> : 10 01                      dup.x32 sp(1)
	<.main+1879 @06278b> : 59                         cgt.i32
	<.main+1880 @06278c> : 06 0a 00 00                jz <.main+1890 @062796>
	<.main+1884 @062790> : 10 01                      dup.x32 sp(1)
	<.main+1886 @062792> : 04 06 00 00                jmp <.main+1892 @062798>
	<.main+1890 @062796> : 10 00                      dup.x32 sp(0)
	<.main+1892 @062798> : 13 02                      set.x32 sp(2)
	<.main+1894 @06279a> : 09 fc ff ff                inc.sp(-4)
	<.main+1898 @06279e> : 10 01                      dup.x32 sp(1)
	<.main+1900 @0627a0> : 10 01                      dup.x32 sp(1)
	<.main+1902 @0627a2> : 59                         cgt.i32
	<.main+1903 @0627a3> : 06 0a 00 00                jz <.main+1913 @0627ad>
	<.main+1907 @0627a7> : 10 01                      dup.x32 sp(1)
	<.main+1909 @0627a9> : 04 06 00 00                jmp <.main+1915 @0627af>
	<.main+1913 @0627ad> : 10 00                      dup.x32 sp(0)
	<.main+1915 @0627af> : 13 02                      set.x32 sp(2)
	<.main+1917 @0627b1> : 09 fc ff ff                inc.sp(-4)
	<.main+1921 @0627b5> : 24 18 0d 06                store.m32 <@060d18> ;maxRlVal
	cmplStd/test/lang/inlineMacros.ci:69: (93 bytes: <.main+1925 @0627b9> - <.main+2018 @062816>): static maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+1925 @0627b9> : 1c 03 00 00 00             load.c32 3
	<.main+1930 @0627be> : 1c 06 00 00 00             load.c32 6
	<.main+1935 @0627c3> : 10 01                      dup.x32 sp(1)
	<.main+1937 @0627c5> : 10 01                      dup.x32 sp(1)
	<.main+1939 @0627c7> : 59                         cgt.i32
	<.main+1940 @0627c8> : 06 0a 00 00                jz <.main+1950 @0627d2>
	<.main+1944 @0627cc> : 10 01                      dup.x32 sp(1)
	<.main+1946 @0627ce> : 04 06 00 00                jmp <.main+1952 @0627d4>
	<.main+1950 @0627d2> : 10 00                      dup.x32 sp(0)
	<.main+1952 @0627d4> : 13 02                      set.x32 sp(2)
	<.main+1954 @0627d6> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @0627da> : 1c 02 00 00 00             load.c32 2
	<.main+1963 @0627df> : 10 01                      dup.x32 sp(1)
	<.main+1965 @0627e1> : 10 01                      dup.x32 sp(1)
	<.main+1967 @0627e3> : 59                         cgt.i32
	<.main+1968 @0627e4> : 06 0a 00 00                jz <.main+1978 @0627ee>
	<.main+1972 @0627e8> : 10 01                      dup.x32 sp(1)
	<.main+1974 @0627ea> : 04 06 00 00                jmp <.main+1980 @0627f0>
	<.main+1978 @0627ee> : 10 00                      dup.x32 sp(0)
	<.main+1980 @0627f0> : 13 02                      set.x32 sp(2)
	<.main+1982 @0627f2> : 09 fc ff ff                inc.sp(-4)
	<.main+1986 @0627f6> : 1c 08 00 00 00             load.c32 8
	<.main+1991 @0627fb> : 10 01                      dup.x32 sp(1)
	<.main+1993 @0627fd> : 10 01                      dup.x32 sp(1)
	<.main+1995 @0627ff> : 59                         cgt.i32
	<.main+1996 @062800> : 06 0a 00 00                jz <.main+2006 @06280a>
	<.main+2000 @062804> : 10 01                      dup.x32 sp(1)
	<.main+2002 @062806> : 04 06 00 00                jmp <.main+2008 @06280c>
	<.main+2006 @06280a> : 10 00                      dup.x32 sp(0)
	<.main+2008 @06280c> : 13 02                      set.x32 sp(2)
	<.main+2010 @06280e> : 09 fc ff ff                inc.sp(-4)
	<.main+2014 @062812> : 24 20 0d 06                store.m32 <@060d20> ;maxLrVal
	cmplStd/test/lang/inlineMacros.ci:70: (89 bytes: <.main+2018 @062816> - <.main+2107 @06286f>): static maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+2018 @062816> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+2022 @06281a> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+2026 @06281e> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+2030 @062822> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+2034 @062826> : 10 01                      dup.x32 sp(1)
	<.main+2036 @062828> : 10 01                      dup.x32 sp(1)
	<.main+2038 @06282a> : 59                         cgt.i32
	<.main+2039 @06282b> : 06 0a 00 00                jz <.main+2049 @062835>
	<.main+2043 @06282f> : 10 01                      dup.x32 sp(1)
	<.main+2045 @062831> : 04 06 00 00                jmp <.main+2051 @062837>
	<.main+2049 @062835> : 10 00                      dup.x32 sp(0)
	<.main+2051 @062837> : 13 02                      set.x32 sp(2)
	<.main+2053 @062839> : 09 fc ff ff                inc.sp(-4)
	<.main+2057 @06283d> : 10 01                      dup.x32 sp(1)
	<.main+2059 @06283f> : 10 01                      dup.x32 sp(1)
	<.main+2061 @062841> : 59                         cgt.i32
	<.main+2062 @062842> : 06 0a 00 00                jz <.main+2072 @06284c>
	<.main+2066 @062846> : 10 01                      dup.x32 sp(1)
	<.main+2068 @062848> : 04 06 00 00                jmp <.main+2074 @06284e>
	<.main+2072 @06284c> : 10 00                      dup.x32 sp(0)
	<.main+2074 @06284e> : 13 02                      set.x32 sp(2)
	<.main+2076 @062850> : 09 fc ff ff                inc.sp(-4)
	<.main+2080 @062854> : 10 01                      dup.x32 sp(1)
	<.main+2082 @062856> : 10 01                      dup.x32 sp(1)
	<.main+2084 @062858> : 59                         cgt.i32
	<.main+2085 @062859> : 06 0a 00 00                jz <.main+2095 @062863>
	<.main+2089 @06285d> : 10 01                      dup.x32 sp(1)
	<.main+2091 @06285f> : 04 06 00 00                jmp <.main+2097 @062865>
	<.main+2095 @062863> : 10 00                      dup.x32 sp(0)
	<.main+2097 @062865> : 13 02                      set.x32 sp(2)
	<.main+2099 @062867> : 09 fc ff ff                inc.sp(-4)
	<.main+2103 @06286b> : 24 28 0d 06                store.m32 <@060d28> ;maxRlVar
	cmplStd/test/lang/inlineMacros.ci:71: (89 bytes: <.main+2107 @06286f> - <.main+2196 @0628c8>): static maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+2107 @06286f> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+2111 @062873> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+2115 @062877> : 10 01                      dup.x32 sp(1)
	<.main+2117 @062879> : 10 01                      dup.x32 sp(1)
	<.main+2119 @06287b> : 59                         cgt.i32
	<.main+2120 @06287c> : 06 0a 00 00                jz <.main+2130 @062886>
	<.main+2124 @062880> : 10 01                      dup.x32 sp(1)
	<.main+2126 @062882> : 04 06 00 00                jmp <.main+2132 @062888>
	<.main+2130 @062886> : 10 00                      dup.x32 sp(0)
	<.main+2132 @062888> : 13 02                      set.x32 sp(2)
	<.main+2134 @06288a> : 09 fc ff ff                inc.sp(-4)
	<.main+2138 @06288e> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+2142 @062892> : 10 01                      dup.x32 sp(1)
	<.main+2144 @062894> : 10 01                      dup.x32 sp(1)
	<.main+2146 @062896> : 59                         cgt.i32
	<.main+2147 @062897> : 06 0a 00 00                jz <.main+2157 @0628a1>
	<.main+2151 @06289b> : 10 01                      dup.x32 sp(1)
	<.main+2153 @06289d> : 04 06 00 00                jmp <.main+2159 @0628a3>
	<.main+2157 @0628a1> : 10 00                      dup.x32 sp(0)
	<.main+2159 @0628a3> : 13 02                      set.x32 sp(2)
	<.main+2161 @0628a5> : 09 fc ff ff                inc.sp(-4)
	<.main+2165 @0628a9> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+2169 @0628ad> : 10 01                      dup.x32 sp(1)
	<.main+2171 @0628af> : 10 01                      dup.x32 sp(1)
	<.main+2173 @0628b1> : 59                         cgt.i32
	<.main+2174 @0628b2> : 06 0a 00 00                jz <.main+2184 @0628bc>
	<.main+2178 @0628b6> : 10 01                      dup.x32 sp(1)
	<.main+2180 @0628b8> : 04 06 00 00                jmp <.main+2186 @0628be>
	<.main+2184 @0628bc> : 10 00                      dup.x32 sp(0)
	<.main+2186 @0628be> : 13 02                      set.x32 sp(2)
	<.main+2188 @0628c0> : 09 fc ff ff                inc.sp(-4)
	<.main+2192 @0628c4> : 24 30 0d 06                store.m32 <@060d30> ;maxLrVar
	cmplStd/test/lang/inlineMacros.ci:72: (109 bytes: <.main+2196 @0628c8> - <.main+2305 @062935>): static maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2196 @0628c8> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+2200 @0628cc> : 0c 01 00 00                inc.i32(+1)
	<.main+2204 @0628d0> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+2208 @0628d4> : 0c 01 00 00                inc.i32(+1)
	<.main+2212 @0628d8> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+2216 @0628dc> : 0c 01 00 00                inc.i32(+1)
	<.main+2220 @0628e0> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+2224 @0628e4> : 0c 01 00 00                inc.i32(+1)
	<.main+2228 @0628e8> : 10 01                      dup.x32 sp(1)
	<.main+2230 @0628ea> : 10 01                      dup.x32 sp(1)
	<.main+2232 @0628ec> : 59                         cgt.i32
	<.main+2233 @0628ed> : 06 0a 00 00                jz <.main+2243 @0628f7>
	<.main+2237 @0628f1> : 10 01                      dup.x32 sp(1)
	<.main+2239 @0628f3> : 04 06 00 00                jmp <.main+2245 @0628f9>
	<.main+2243 @0628f7> : 10 00                      dup.x32 sp(0)
	<.main+2245 @0628f9> : 13 02                      set.x32 sp(2)
	<.main+2247 @0628fb> : 09 fc ff ff                inc.sp(-4)
	<.main+2251 @0628ff> : 10 01                      dup.x32 sp(1)
	<.main+2253 @062901> : 10 01                      dup.x32 sp(1)
	<.main+2255 @062903> : 59                         cgt.i32
	<.main+2256 @062904> : 06 0a 00 00                jz <.main+2266 @06290e>
	<.main+2260 @062908> : 10 01                      dup.x32 sp(1)
	<.main+2262 @06290a> : 04 06 00 00                jmp <.main+2268 @062910>
	<.main+2266 @06290e> : 10 00                      dup.x32 sp(0)
	<.main+2268 @062910> : 13 02                      set.x32 sp(2)
	<.main+2270 @062912> : 09 fc ff ff                inc.sp(-4)
	<.main+2274 @062916> : 10 01                      dup.x32 sp(1)
	<.main+2276 @062918> : 10 01                      dup.x32 sp(1)
	<.main+2278 @06291a> : 59                         cgt.i32
	<.main+2279 @06291b> : 06 0a 00 00                jz <.main+2289 @062925>
	<.main+2283 @06291f> : 10 01                      dup.x32 sp(1)
	<.main+2285 @062921> : 04 06 00 00                jmp <.main+2291 @062927>
	<.main+2289 @062925> : 10 00                      dup.x32 sp(0)
	<.main+2291 @062927> : 13 02                      set.x32 sp(2)
	<.main+2293 @062929> : 09 fc ff ff                inc.sp(-4)
	<.main+2297 @06292d> : 0c ff ff ff                inc.i32(-1)
	<.main+2301 @062931> : 24 38 0d 06                store.m32 <@060d38> ;maxRlXpr
	cmplStd/test/lang/inlineMacros.ci:73: (109 bytes: <.main+2305 @062935> - <.main+2414 @0629a2>): static maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2305 @062935> : 20 d8 0b 06                load.m32 <@060bd8> ;i3
	<.main+2309 @062939> : 0c 01 00 00                inc.i32(+1)
	<.main+2313 @06293d> : 20 e0 0b 06                load.m32 <@060be0> ;i6
	<.main+2317 @062941> : 0c 01 00 00                inc.i32(+1)
	<.main+2321 @062945> : 10 01                      dup.x32 sp(1)
	<.main+2323 @062947> : 10 01                      dup.x32 sp(1)
	<.main+2325 @062949> : 59                         cgt.i32
	<.main+2326 @06294a> : 06 0a 00 00                jz <.main+2336 @062954>
	<.main+2330 @06294e> : 10 01                      dup.x32 sp(1)
	<.main+2332 @062950> : 04 06 00 00                jmp <.main+2338 @062956>
	<.main+2336 @062954> : 10 00                      dup.x32 sp(0)
	<.main+2338 @062956> : 13 02                      set.x32 sp(2)
	<.main+2340 @062958> : 09 fc ff ff                inc.sp(-4)
	<.main+2344 @06295c> : 20 e8 0b 06                load.m32 <@060be8> ;i2
	<.main+2348 @062960> : 0c 01 00 00                inc.i32(+1)
	<.main+2352 @062964> : 10 01                      dup.x32 sp(1)
	<.main+2354 @062966> : 10 01                      dup.x32 sp(1)
	<.main+2356 @062968> : 59                         cgt.i32
	<.main+2357 @062969> : 06 0a 00 00                jz <.main+2367 @062973>
	<.main+2361 @06296d> : 10 01                      dup.x32 sp(1)
	<.main+2363 @06296f> : 04 06 00 00                jmp <.main+2369 @062975>
	<.main+2367 @062973> : 10 00                      dup.x32 sp(0)
	<.main+2369 @062975> : 13 02                      set.x32 sp(2)
	<.main+2371 @062977> : 09 fc ff ff                inc.sp(-4)
	<.main+2375 @06297b> : 20 f0 0b 06                load.m32 <@060bf0> ;i8
	<.main+2379 @06297f> : 0c 01 00 00                inc.i32(+1)
	<.main+2383 @062983> : 10 01                      dup.x32 sp(1)
	<.main+2385 @062985> : 10 01                      dup.x32 sp(1)
	<.main+2387 @062987> : 59                         cgt.i32
	<.main+2388 @062988> : 06 0a 00 00                jz <.main+2398 @062992>
	<.main+2392 @06298c> : 10 01                      dup.x32 sp(1)
	<.main+2394 @06298e> : 04 06 00 00                jmp <.main+2400 @062994>
	<.main+2398 @062992> : 10 00                      dup.x32 sp(0)
	<.main+2400 @062994> : 13 02                      set.x32 sp(2)
	<.main+2402 @062996> : 09 fc ff ff                inc.sp(-4)
	<.main+2406 @06299a> : 0c ff ff ff                inc.i32(-1)
	<.main+2410 @06299e> : 24 40 0d 06                store.m32 <@060d40> ;maxLrXpr
	cmplStd/test/lang/overload.inline.ci:9: (9 bytes: <.main+2414 @0629a2> - <.main+2423 @0629ab>): static overload1: float32 := overload
	<.main+2414 @0629a2> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2419 @0629a7> : 24 48 0d 06                store.m32 <@060d48> ;overload1
	cmplStd/test/lang/overload.inline.ci:10: (9 bytes: <.main+2423 @0629ab> - <.main+2432 @0629b4>): static overload2: float32 := overload()
	<.main+2423 @0629ab> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2428 @0629b0> : 24 50 0d 06                store.m32 <@060d50> ;overload2
	cmplStd/test/lang/overload.inline.ci:11: (9 bytes: <.main+2432 @0629b4> - <.main+2441 @0629bd>): static overload3: float32 := overload(0)
	<.main+2432 @0629b4> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2437 @0629b9> : 24 58 0d 06                store.m32 <@060d58> ;overload3
	cmplStd/test/lang/overload.inline.ci:12: (9 bytes: <.main+2441 @0629bd> - <.main+2450 @0629c6>): static overload4: float32 := overload(0.000000)
	<.main+2441 @0629bd> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2446 @0629c2> : 24 60 0d 06                store.m32 <@060d60> ;overload4
	cmplStd/test/lang/overload.inline.ci:13: (9 bytes: <.main+2450 @0629c6> - <.main+2459 @0629cf>): static overload5: float32 := overload(0, 0)
	<.main+2450 @0629c6> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2455 @0629cb> : 24 68 0d 06                store.m32 <@060d68> ;overload5
	cmplStd/test/lang/overload.inline.ci:28: (13 bytes: <.main+2459 @0629cf> - <.main+2472 @0629dc>): static boilC: Celsius := Celsius(100.000000)
	<.main+2459 @0629cf> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2468 @0629d8> : 23 70 0d 06                store.m64 <@060d70> ;boilC
	cmplStd/test/lang/overload.inline.ci:29: (28 bytes: <.main+2472 @0629dc> - <.main+2500 @0629f8>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2472 @0629dc> : 21 70 0d 06                load.m64 <@060d70> ;boilC
	<.main+2476 @0629e0> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2485 @0629e9> : 83                         mul.f64
	<.main+2486 @0629ea> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2495 @0629f3> : 81                         add.f64
	<.main+2496 @0629f4> : 23 78 0d 06                store.m64 <@060d78> ;boilF
	cmplStd/test/std/number.ci:3: (13 bytes: <.main+2500 @0629f8> - <.main+2513 @062a05>): static pi64: float64 := 3.141593
	<.main+2500 @0629f8> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+2509 @062a01> : 23 80 0d 06                store.m64 <@060d80> ;pi64
	cmplStd/test/std/number.ci:4: (13 bytes: <.main+2513 @062a05> - <.main+2526 @062a12>): static e64: float64 := 2.718282
	<.main+2513 @062a05> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+2522 @062a0e> : 23 88 0d 06                store.m64 <@060d88> ;e64
	cmplStd/test/std/number.ci:6: (9 bytes: <.main+2526 @062a12> - <.main+2535 @062a1b>): static pi32: float32 := pi64
	<.main+2526 @062a12> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+2530 @062a16> : 8c                         f64.2f32
	<.main+2531 @062a17> : 24 90 0d 06                store.m32 <@060d90> ;pi32
	cmplStd/test/std/number.ci:7: (9 bytes: <.main+2535 @062a1b> - <.main+2544 @062a24>): static e32: float32 := e64
	<.main+2535 @062a1b> : 21 88 0d 06                load.m64 <@060d88> ;e64
	<.main+2539 @062a1f> : 8c                         f64.2f32
	<.main+2540 @062a20> : 24 98 0d 06                store.m32 <@060d98> ;e32
	cmplStd/test/std/number.ci:14: (11 bytes: <.main+2544 @062a24> - <.main+2555 @062a2f>): static r_comp: int32 := 14 << 3
	<.main+2544 @062a24> : 1c 0e 00 00 00             load.c32 14
	<.main+2549 @062a29> : 3f 43                      b32.shl 0x03
	<.main+2551 @062a2b> : 24 a0 0d 06                store.m32 <@060da0> ;r_comp
	cmplStd/test/std/number.ci:15: (11 bytes: <.main+2555 @062a2f> - <.main+2566 @062a3a>): static g_comp: int32 := 63 << 2
	<.main+2555 @062a2f> : 1c 3f 00 00 00             load.c32 63
	<.main+2560 @062a34> : 3f 42                      b32.shl 0x02
	<.main+2562 @062a36> : 24 a8 0d 06                store.m32 <@060da8> ;g_comp
	cmplStd/test/std/number.ci:16: (11 bytes: <.main+2566 @062a3a> - <.main+2577 @062a45>): static b_comp: int32 := 31 << 3
	<.main+2566 @062a3a> : 1c 1f 00 00 00             load.c32 31
	<.main+2571 @062a3f> : 3f 43                      b32.shl 0x03
	<.main+2573 @062a41> : 24 b0 0d 06                store.m32 <@060db0> ;b_comp
	cmplStd/test/std/number.ci:18: (38 bytes: <.main+2577 @062a45> - <.main+2615 @062a6b>): static r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+2577 @062a45> : 20 a0 0d 06                load.m32 <@060da0> ;r_comp
	<.main+2581 @062a49> : 3f 48                      b32.shl 0x08
	<.main+2583 @062a4b> : 1c 00 f8 00 00             load.c32 63488
	<.main+2588 @062a50> : 31                         and.b32
	<.main+2589 @062a51> : 20 a8 0d 06                load.m32 <@060da8> ;g_comp
	<.main+2593 @062a55> : 3f 43                      b32.shl 0x03
	<.main+2595 @062a57> : 1c e0 07 00 00             load.c32 2016
	<.main+2600 @062a5c> : 31                         and.b32
	<.main+2601 @062a5d> : 32                         or.b32
	<.main+2602 @062a5e> : 20 b0 0d 06                load.m32 <@060db0> ;b_comp
	<.main+2606 @062a62> : 3f c3                      b32.sar 0x03
	<.main+2608 @062a64> : 3f 05                      b32.and 0x1f
	<.main+2610 @062a66> : 32                         or.b32
	<.main+2611 @062a67> : 24 b8 0d 06                store.m32 <@060db8> ;r5g6b5
	cmplStd/test/std/number.ci:19: (36 bytes: <.main+2615 @062a6b> - <.main+2651 @062a8f>): static r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+2615 @062a6b> : 20 a0 0d 06                load.m32 <@060da0> ;r_comp
	<.main+2619 @062a6f> : 3f 50                      b32.shl 0x10
	<.main+2621 @062a71> : 1c 00 00 ff 00             load.c32 16711680
	<.main+2626 @062a76> : 31                         and.b32
	<.main+2627 @062a77> : 20 a8 0d 06                load.m32 <@060da8> ;g_comp
	<.main+2631 @062a7b> : 3f 48                      b32.shl 0x08
	<.main+2633 @062a7d> : 1c 00 ff 00 00             load.c32 65280
	<.main+2638 @062a82> : 31                         and.b32
	<.main+2639 @062a83> : 32                         or.b32
	<.main+2640 @062a84> : 20 b0 0d 06                load.m32 <@060db0> ;b_comp
	<.main+2644 @062a88> : 3f 08                      b32.and 0xff
	<.main+2646 @062a8a> : 32                         or.b32
	<.main+2647 @062a8b> : 24 c0 0d 06                store.m32 <@060dc0> ;r8g8b8
	cmplStd/test/std/number.ci:21: (22 bytes: <.main+2651 @062a8f> - <.main+2673 @062aa5>): static zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+2651 @062a8f> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+2655 @062a93> : 1c 0b 00 00 00             load.c32 11
	<.main+2660 @062a98> : 1c 05 00 00 00             load.c32 5
	<.main+2665 @062a9d> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2669 @062aa1> : 24 c8 0d 06                store.m32 <@060dc8> ;zxtR5
	cmplStd/test/std/number.ci:22: (22 bytes: <.main+2673 @062aa5> - <.main+2695 @062abb>): static zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+2673 @062aa5> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+2677 @062aa9> : 1c 05 00 00 00             load.c32 5
	<.main+2682 @062aae> : 1c 06 00 00 00             load.c32 6
	<.main+2687 @062ab3> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2691 @062ab7> : 24 d0 0d 06                store.m32 <@060dd0> ;zxtG6
	cmplStd/test/std/number.ci:23: (18 bytes: <.main+2695 @062abb> - <.main+2713 @062acd>): static zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+2695 @062abb> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+2699 @062abf> : 19                         load.z32
	<.main+2700 @062ac0> : 1c 05 00 00 00             load.c32 5
	<.main+2705 @062ac5> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2709 @062ac9> : 24 d8 0d 06                store.m32 <@060dd8> ;zxtB5
	cmplStd/test/std/number.ci:25: (22 bytes: <.main+2713 @062acd> - <.main+2735 @062ae3>): static sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+2713 @062acd> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+2717 @062ad1> : 1c 0b 00 00 00             load.c32 11
	<.main+2722 @062ad6> : 1c 05 00 00 00             load.c32 5
	<.main+2727 @062adb> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2731 @062adf> : 24 e0 0d 06                store.m32 <@060de0> ;sxtR5
	cmplStd/test/std/number.ci:26: (22 bytes: <.main+2735 @062ae3> - <.main+2757 @062af9>): static sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+2735 @062ae3> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+2739 @062ae7> : 1c 05 00 00 00             load.c32 5
	<.main+2744 @062aec> : 1c 06 00 00 00             load.c32 6
	<.main+2749 @062af1> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2753 @062af5> : 24 e8 0d 06                store.m32 <@060de8> ;sxtG6
	cmplStd/test/std/number.ci:27: (18 bytes: <.main+2757 @062af9> - <.main+2775 @062b0b>): static sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+2757 @062af9> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+2761 @062afd> : 19                         load.z32
	<.main+2762 @062afe> : 1c 05 00 00 00             load.c32 5
	<.main+2767 @062b03> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2771 @062b07> : 24 f0 0d 06                store.m32 <@060df0> ;sxtB5
	cmplStd/test/std/number.ci:29: (22 bytes: <.main+2775 @062b0b> - <.main+2797 @062b21>): static zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+2775 @062b0b> : 20 c0 0d 06                load.m32 <@060dc0> ;r8g8b8
	<.main+2779 @062b0f> : 1c 10 00 00 00             load.c32 16
	<.main+2784 @062b14> : 1c 08 00 00 00             load.c32 8
	<.main+2789 @062b19> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2793 @062b1d> : 24 f8 0d 06                store.m32 <@060df8> ;zxtR8
	cmplStd/test/std/number.ci:30: (22 bytes: <.main+2797 @062b21> - <.main+2819 @062b37>): static zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+2797 @062b21> : 20 c0 0d 06                load.m32 <@060dc0> ;r8g8b8
	<.main+2801 @062b25> : 1c 08 00 00 00             load.c32 8
	<.main+2806 @062b2a> : 1c 08 00 00 00             load.c32 8
	<.main+2811 @062b2f> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2815 @062b33> : 24 00 0e 06                store.m32 <@060e00> ;zxtG8
	cmplStd/test/std/number.ci:31: (18 bytes: <.main+2819 @062b37> - <.main+2837 @062b49>): static zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+2819 @062b37> : 20 c0 0d 06                load.m32 <@060dc0> ;r8g8b8
	<.main+2823 @062b3b> : 19                         load.z32
	<.main+2824 @062b3c> : 1c 08 00 00 00             load.c32 8
	<.main+2829 @062b41> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2833 @062b45> : 24 08 0e 06                store.m32 <@060e08> ;zxtB8
	cmplStd/test/std/number.ci:33: (22 bytes: <.main+2837 @062b49> - <.main+2859 @062b5f>): static sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+2837 @062b49> : 20 c0 0d 06                load.m32 <@060dc0> ;r8g8b8
	<.main+2841 @062b4d> : 1c 10 00 00 00             load.c32 16
	<.main+2846 @062b52> : 1c 08 00 00 00             load.c32 8
	<.main+2851 @062b57> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2855 @062b5b> : 24 10 0e 06                store.m32 <@060e10> ;sxtR8
	cmplStd/test/std/number.ci:34: (22 bytes: <.main+2859 @062b5f> - <.main+2881 @062b75>): static sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+2859 @062b5f> : 20 c0 0d 06                load.m32 <@060dc0> ;r8g8b8
	<.main+2863 @062b63> : 1c 08 00 00 00             load.c32 8
	<.main+2868 @062b68> : 1c 08 00 00 00             load.c32 8
	<.main+2873 @062b6d> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2877 @062b71> : 24 18 0e 06                store.m32 <@060e18> ;sxtG8
	cmplStd/test/std/number.ci:35: (18 bytes: <.main+2881 @062b75> - <.main+2899 @062b87>): static sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+2881 @062b75> : 20 c0 0d 06                load.m32 <@060dc0> ;r8g8b8
	<.main+2885 @062b79> : 19                         load.z32
	<.main+2886 @062b7a> : 1c 08 00 00 00             load.c32 8
	<.main+2891 @062b7f> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2895 @062b83> : 24 20 0e 06                store.m32 <@060e20> ;sxtB8
	cmplStd/test/std/number.ci:37: (22 bytes: <.main+2899 @062b87> - <.main+2921 @062b9d>): static testSin_f64: float64 := float64.sin(pi64 / (2))
	<.main+2899 @062b87> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+2903 @062b8b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2912 @062b94> : 84                         div.f64
	<.main+2913 @062b95> : 01 29 00 00                nfc(41) ;float64.sin(x: float64): float64
	<.main+2917 @062b99> : 23 28 0e 06                store.m64 <@060e28> ;testSin_f64
	cmplStd/test/std/number.ci:38: (22 bytes: <.main+2921 @062b9d> - <.main+2943 @062bb3>): static testCos_f64: float64 := float64.cos(pi64 / (2))
	<.main+2921 @062b9d> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+2925 @062ba1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2934 @062baa> : 84                         div.f64
	<.main+2935 @062bab> : 01 2a 00 00                nfc(42) ;float64.cos(x: float64): float64
	<.main+2939 @062baf> : 23 30 0e 06                store.m64 <@060e30> ;testCos_f64
	cmplStd/test/std/number.ci:39: (22 bytes: <.main+2943 @062bb3> - <.main+2965 @062bc9>): static testTan_f64: float64 := float64.tan(pi64 / (4))
	<.main+2943 @062bb3> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+2947 @062bb7> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+2956 @062bc0> : 84                         div.f64
	<.main+2957 @062bc1> : 01 2b 00 00                nfc(43) ;float64.tan(x: float64): float64
	<.main+2961 @062bc5> : 23 38 0e 06                store.m64 <@060e38> ;testTan_f64
	cmplStd/test/std/number.ci:40: (22 bytes: <.main+2965 @062bc9> - <.main+2987 @062bdf>): static testLog_f64: float64 := float64.log(e64 * e64 * e64)
	<.main+2965 @062bc9> : 21 88 0d 06                load.m64 <@060d88> ;e64
	<.main+2969 @062bcd> : 21 88 0d 06                load.m64 <@060d88> ;e64
	<.main+2973 @062bd1> : 83                         mul.f64
	<.main+2974 @062bd2> : 21 88 0d 06                load.m64 <@060d88> ;e64
	<.main+2978 @062bd6> : 83                         mul.f64
	<.main+2979 @062bd7> : 01 2c 00 00                nfc(44) ;float64.log(x: float64): float64
	<.main+2983 @062bdb> : 23 40 0e 06                store.m64 <@060e40> ;testLog_f64
	cmplStd/test/std/number.ci:41: (17 bytes: <.main+2987 @062bdf> - <.main+3004 @062bf0>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+2987 @062bdf> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+2996 @062be8> : 01 2d 00 00                nfc(45) ;float64.exp(x: float64): float64
	<.main+3000 @062bec> : 23 48 0e 06                store.m64 <@060e48> ;testExp_f64
	cmplStd/test/std/number.ci:42: (26 bytes: <.main+3004 @062bf0> - <.main+3030 @062c0a>): static testPow_f64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+3004 @062bf0> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+3008 @062bf4> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+3012 @062bf8> : 83                         mul.f64
	<.main+3013 @062bf9> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3022 @062c02> : 01 2e 00 00                nfc(46) ;float64.pow(x: float64, y: float64): float64
	<.main+3026 @062c06> : 23 50 0e 06                store.m64 <@060e50> ;testPow_f64
	cmplStd/test/std/number.ci:43: (17 bytes: <.main+3030 @062c0a> - <.main+3047 @062c1b>): static testSqrt_f64: float64 := float64.sqrt(pi64 * pi64)
	<.main+3030 @062c0a> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+3034 @062c0e> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+3038 @062c12> : 83                         mul.f64
	<.main+3039 @062c13> : 01 2f 00 00                nfc(47) ;float64.sqrt(x: float64): float64
	<.main+3043 @062c17> : 23 58 0e 06                store.m64 <@060e58> ;testSqrt_f64
	cmplStd/test/std/number.ci:44: (21 bytes: <.main+3047 @062c1b> - <.main+3068 @062c30>): static testAtan_f64: float64 := float64.atan2(pi64, 1.000000)
	<.main+3047 @062c1b> : 21 80 0d 06                load.m64 <@060d80> ;pi64
	<.main+3051 @062c1f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3060 @062c28> : 01 30 00 00                nfc(48) ;float64.atan2(x: float64, y: float64): float64
	<.main+3064 @062c2c> : 23 60 0e 06                store.m64 <@060e60> ;testAtan_f64
	cmplStd/test/std/number.ci:46: (18 bytes: <.main+3068 @062c30> - <.main+3086 @062c42>): static testSin_f32: float32 := float32.sin(pi32 / (2))
	<.main+3068 @062c30> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3072 @062c34> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3077 @062c39> : 74                         div.f32
	<.main+3078 @062c3a> : 01 21 00 00                nfc(33) ;float32.sin(x: float32): float32
	<.main+3082 @062c3e> : 24 68 0e 06                store.m32 <@060e68> ;testSin_f32
	cmplStd/test/std/number.ci:47: (18 bytes: <.main+3086 @062c42> - <.main+3104 @062c54>): static testCos_f32: float32 := float32.cos(pi32 / (2))
	<.main+3086 @062c42> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3090 @062c46> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3095 @062c4b> : 74                         div.f32
	<.main+3096 @062c4c> : 01 22 00 00                nfc(34) ;float32.cos(x: float32): float32
	<.main+3100 @062c50> : 24 70 0e 06                store.m32 <@060e70> ;testCos_f32
	cmplStd/test/std/number.ci:48: (18 bytes: <.main+3104 @062c54> - <.main+3122 @062c66>): static testTan_f32: float32 := float32.tan(pi32 / (4))
	<.main+3104 @062c54> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3108 @062c58> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3113 @062c5d> : 74                         div.f32
	<.main+3114 @062c5e> : 01 23 00 00                nfc(35) ;float32.tan(x: float32): float32
	<.main+3118 @062c62> : 24 78 0e 06                store.m32 <@060e78> ;testTan_f32
	cmplStd/test/std/number.ci:49: (22 bytes: <.main+3122 @062c66> - <.main+3144 @062c7c>): static testLog_f32: float32 := float32.log(e32 * e32 * e32)
	<.main+3122 @062c66> : 20 98 0d 06                load.m32 <@060d98> ;e32
	<.main+3126 @062c6a> : 20 98 0d 06                load.m32 <@060d98> ;e32
	<.main+3130 @062c6e> : 73                         mul.f32
	<.main+3131 @062c6f> : 20 98 0d 06                load.m32 <@060d98> ;e32
	<.main+3135 @062c73> : 73                         mul.f32
	<.main+3136 @062c74> : 01 24 00 00                nfc(36) ;float32.log(x: float32): float32
	<.main+3140 @062c78> : 24 80 0e 06                store.m32 <@060e80> ;testLog_f32
	cmplStd/test/std/number.ci:50: (13 bytes: <.main+3144 @062c7c> - <.main+3157 @062c89>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+3144 @062c7c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3149 @062c81> : 01 25 00 00                nfc(37) ;float32.exp(x: float32): float32
	<.main+3153 @062c85> : 24 88 0e 06                store.m32 <@060e88> ;testExp_f32
	cmplStd/test/std/number.ci:51: (22 bytes: <.main+3157 @062c89> - <.main+3179 @062c9f>): static testPow_f32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+3157 @062c89> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3161 @062c8d> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3165 @062c91> : 73                         mul.f32
	<.main+3166 @062c92> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3171 @062c97> : 01 26 00 00                nfc(38) ;float32.pow(x: float32, y: float32): float32
	<.main+3175 @062c9b> : 24 90 0e 06                store.m32 <@060e90> ;testPow_f32
	cmplStd/test/std/number.ci:52: (17 bytes: <.main+3179 @062c9f> - <.main+3196 @062cb0>): static testSqrt_f32: float32 := float32.sqrt(pi32 * pi32)
	<.main+3179 @062c9f> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3183 @062ca3> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3187 @062ca7> : 73                         mul.f32
	<.main+3188 @062ca8> : 01 27 00 00                nfc(39) ;float32.sqrt(x: float32): float32
	<.main+3192 @062cac> : 24 98 0e 06                store.m32 <@060e98> ;testSqrt_f32
	cmplStd/test/std/number.ci:53: (17 bytes: <.main+3196 @062cb0> - <.main+3213 @062cc1>): static testAtan_f32: float32 := float32.atan2(pi32, 1.000000)
	<.main+3196 @062cb0> : 20 90 0d 06                load.m32 <@060d90> ;pi32
	<.main+3200 @062cb4> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3205 @062cb9> : 01 28 00 00                nfc(40) ;float32.atan2(x: float32, y: float32): float32
	<.main+3209 @062cbd> : 24 a0 0e 06                store.m32 <@060ea0> ;testAtan_f32
	cmplStd/test/std/number.ci:55: (12 bytes: <.main+3213 @062cc1> - <.main+3225 @062ccd>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3213 @062cc1> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3217 @062cc5> : 01 19 00 00                nfc(25) ;uint32.pop(value: int32): int32
	<.main+3221 @062cc9> : 24 a8 0e 06                store.m32 <@060ea8> ;testPopulation_u32
	cmplStd/test/std/number.ci:56: (12 bytes: <.main+3225 @062ccd> - <.main+3237 @062cd9>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3225 @062ccd> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3229 @062cd1> : 01 1a 00 00                nfc(26) ;uint32.swap(value: int32): int32
	<.main+3233 @062cd5> : 24 b0 0e 06                store.m32 <@060eb0> ;testSwapBits_u32
	cmplStd/test/std/number.ci:57: (12 bytes: <.main+3237 @062cd9> - <.main+3249 @062ce5>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3237 @062cd9> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3241 @062cdd> : 01 1b 00 00                nfc(27) ;uint32.bsr(value: int32): int32
	<.main+3245 @062ce1> : 24 b8 0e 06                store.m32 <@060eb8> ;testBitScanReverse_u32
	cmplStd/test/std/number.ci:58: (12 bytes: <.main+3249 @062ce5> - <.main+3261 @062cf1>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3249 @062ce5> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3253 @062ce9> : 01 1c 00 00                nfc(28) ;uint32.bsf(value: int32): int32
	<.main+3257 @062ced> : 24 c0 0e 06                store.m32 <@060ec0> ;testBitScanForward_u32
	cmplStd/test/std/number.ci:59: (12 bytes: <.main+3261 @062cf1> - <.main+3273 @062cfd>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3261 @062cf1> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3265 @062cf5> : 01 1d 00 00                nfc(29) ;uint32.hib(value: int32): int32
	<.main+3269 @062cf9> : 24 c8 0e 06                store.m32 <@060ec8> ;testHighBit_u32
	cmplStd/test/std/number.ci:60: (12 bytes: <.main+3273 @062cfd> - <.main+3285 @062d09>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3273 @062cfd> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3277 @062d01> : 01 1e 00 00                nfc(30) ;uint32.lob(value: int32): int32
	<.main+3281 @062d05> : 24 d0 0e 06                store.m32 <@060ed0> ;testLowBit_u32
	cmplStd/test/std/number.ci:62: (18 bytes: <.main+3285 @062d09> - <.main+3303 @062d1b>): static testZeroExtend_u32: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+3285 @062d09> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3289 @062d0d> : 19                         load.z32
	<.main+3290 @062d0e> : 1c 05 00 00 00             load.c32 5
	<.main+3295 @062d13> : 01 17 00 00                nfc(23) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+3299 @062d17> : 24 d8 0e 06                store.m32 <@060ed8> ;testZeroExtend_u32
	cmplStd/test/std/number.ci:63: (18 bytes: <.main+3303 @062d1b> - <.main+3321 @062d2d>): static testSignExtend_u32: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+3303 @062d1b> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3307 @062d1f> : 19                         load.z32
	<.main+3308 @062d20> : 1c 05 00 00 00             load.c32 5
	<.main+3313 @062d25> : 01 18 00 00                nfc(24) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+3317 @062d29> : 24 e0 0e 06                store.m32 <@060ee0> ;testSignExtend_u32
	cmplStd/test/std/number.ci:65: (20 bytes: <.main+3321 @062d2d> - <.main+3341 @062d41>): static testZeroExtend_u64: int32 := uint64.zxt(r5g6b5, 0, 5)
	<.main+3321 @062d2d> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3325 @062d31> : 5b                         i32.2i64
	<.main+3326 @062d32> : 19                         load.z32
	<.main+3327 @062d33> : 1c 05 00 00 00             load.c32 5
	<.main+3332 @062d38> : 01 1f 00 00                nfc(31) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3336 @062d3c> : 6a                         i64.2i32
	<.main+3337 @062d3d> : 24 e8 0e 06                store.m32 <@060ee8> ;testZeroExtend_u64
	cmplStd/test/std/number.ci:66: (20 bytes: <.main+3341 @062d41> - <.main+3361 @062d55>): static testSignExtend_u64: int32 := uint64.sxt(r5g6b5, 0, 5)
	<.main+3341 @062d41> : 20 b8 0d 06                load.m32 <@060db8> ;r5g6b5
	<.main+3345 @062d45> : 5b                         i32.2i64
	<.main+3346 @062d46> : 19                         load.z32
	<.main+3347 @062d47> : 1c 05 00 00 00             load.c32 5
	<.main+3352 @062d4c> : 01 20 00 00                nfc(32) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3356 @062d50> : 6a                         i64.2i32
	<.main+3357 @062d51> : 24 f0 0e 06                store.m32 <@060ef0> ;testSignExtend_u64
	cmplStd/test/std/memory.ci:7: (18 bytes: <.main+3361 @062d55> - <.main+3379 @062d67>): static p1: pointer := malloc(1024)
	<.main+3361 @062d55> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3366 @062d5a> : 1c 00 04 00 00             load.c32 1024
	<.main+3371 @062d5f> : 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3375 @062d63> : 24 f8 0e 06                store.m32 <@060ef8> ;p1
	cmplStd/test/std/memory.ci:8: (18 bytes: <.main+3379 @062d67> - <.main+3397 @062d79>): static p2: pointer := malloc(80)
	<.main+3379 @062d67> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3384 @062d6c> : 1c 50 00 00 00             load.c32 80
	<.main+3389 @062d71> : 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3393 @062d75> : 24 00 0f 06                store.m32 <@060f00> ;p2
	cmplStd/test/std/memory.ci:9: (18 bytes: <.main+3397 @062d79> - <.main+3415 @062d8b>): static p3: pointer := malloc(160)
	<.main+3397 @062d79> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3402 @062d7e> : 1c a0 00 00 00             load.c32 160
	<.main+3407 @062d83> : 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3411 @062d87> : 24 08 0f 06                store.m32 <@060f08> ;p3
	cmplStd/test/std/memory.ci:10: (18 bytes: <.main+3415 @062d8b> - <.main+3433 @062d9d>): static p4: pointer := malloc(820)
	<.main+3415 @062d8b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3420 @062d90> : 1c 34 03 00 00             load.c32 820
	<.main+3425 @062d95> : 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3429 @062d99> : 24 10 0f 06                store.m32 <@060f10> ;p4
	cmplStd/test/std/memory.ci:23: (13 bytes: <.main+3433 @062d9d> - <.main+3446 @062daa>): static val1: int64 := 42
	<.main+3433 @062d9d> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3442 @062da6> : 23 18 0f 06                store.m64 <@060f18> ;val1
	cmplStd/test/std/memory.ci:24: (13 bytes: <.main+3446 @062daa> - <.main+3459 @062db7>): static val2: int64 := 96
	<.main+3446 @062daa> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+3455 @062db3> : 23 20 0f 06                store.m64 <@060f20> ;val2
	cmplStd/test/std/tryExec.ci:47: (18 bytes: <.main+3459 @062db7> - <.main+3477 @062dc9>): static tryExecErr0: int32 := tryExec(null, noError)
	<.main+3459 @062db7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3464 @062dbc> : 1f 28 0f 06 00             load.ref <@060f28> ;noError(ptr: pointer): void
	<.main+3469 @062dc1> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3473 @062dc5> : 24 b8 0f 06                store.m32 <@060fb8> ;tryExecErr0
	cmplStd/test/std/tryExec.ci:48: (18 bytes: <.main+3477 @062dc9> - <.main+3495 @062ddb>): static tryExecErr1: int32 := tryExec(null, null)
	<.main+3477 @062dc9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3482 @062dce> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3487 @062dd3> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3491 @062dd7> : 24 c0 0f 06                store.m32 <@060fc0> ;tryExecErr1
	cmplStd/test/std/tryExec.ci:49: (18 bytes: <.main+3495 @062ddb> - <.main+3513 @062ded>): static tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+3495 @062ddb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3500 @062de0> : 1f 30 0f 06 00             load.ref <@060f30> ;stackOverflow(ptr: pointer): void
	<.main+3505 @062de5> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3509 @062de9> : 24 c8 0f 06                store.m32 <@060fc8> ;tryExecErr2
	cmplStd/test/std/tryExec.ci:50: (18 bytes: <.main+3513 @062ded> - <.main+3531 @062dff>): static tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+3513 @062ded> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3518 @062df2> : 1f 48 0f 06 00             load.ref <@060f48> ;divisionByZero(args: pointer): void
	<.main+3523 @062df7> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3527 @062dfb> : 24 d0 0f 06                store.m32 <@060fd0> ;tryExecErr3
	cmplStd/test/std/tryExec.ci:51: (18 bytes: <.main+3531 @062dff> - <.main+3549 @062e11>): static tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+3531 @062dff> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3536 @062e04> : 1f b0 0f 06 00             load.ref <@060fb0> ;invalidInstruction(args: pointer): void
	<.main+3541 @062e09> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3545 @062e0d> : 24 d8 0f 06                store.m32 <@060fd8> ;tryExecErr4
	cmplStd/test/std/tryExec.ci:52: (18 bytes: <.main+3549 @062e11> - <.main+3567 @062e23>): static tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+3549 @062e11> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3554 @062e16> : 1f a0 0f 06 00             load.ref <@060fa0> ;invalidMemoryAccess(args: pointer): void
	<.main+3559 @062e1b> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3563 @062e1f> : 24 e0 0f 06                store.m32 <@060fe0> ;tryExecErr5
	cmplStd/test/std/tryExec.ci:53: (18 bytes: <.main+3567 @062e23> - <.main+3585 @062e35>): static tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+3567 @062e23> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3572 @062e28> : 1f 58 0f 06 00             load.ref <@060f58> ;abortExecution(args: pointer): void
	<.main+3577 @062e2d> : 01 0b 00 00                nfc(11) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3581 @062e31> : 24 e8 0f 06                store.m32 <@060fe8> ;tryExecErr6
	cmplStd/test/lang/init.reference.ci:7: (13 bytes: <.main+3585 @062e35> - <.main+3598 @062e42>): static value: int64 := 42
	<.main+3585 @062e35> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3594 @062e3e> : 23 f0 0f 06                store.m64 <@060ff0> ;value
	cmplStd/test/lang/init.reference.ci:8: (9 bytes: <.main+3598 @062e42> - <.main+3607 @062e4b>): static valueRef: int64 := value
	<.main+3598 @062e42> : 1f f0 0f 06 00             load.ref <@060ff0> ;value
	<.main+3603 @062e47> : 24 f8 0f 06                store.m32 <@060ff8> ;valueRef
	cmplStd/test/lang/init.reference.ci:9: (9 bytes: <.main+3607 @062e4b> - <.main+3616 @062e54>): static valuePtr: pointer := value
	<.main+3607 @062e4b> : 1f f0 0f 06 00             load.ref <@060ff0> ;value
	<.main+3612 @062e50> : 24 00 10 06                store.m32 <@061000> ;valuePtr
	cmplStd/test/lang/init.reference.ci:10: (14 bytes: <.main+3616 @062e54> - <.main+3630 @062e62>): static valueVar: variant := value
	<.main+3616 @062e54> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3621 @062e59> : 1f f0 0f 06 00             load.ref <@060ff0> ;value
	<.main+3626 @062e5e> : 23 08 10 06                store.m64 <@061008> ;valueVar
	cmplStd/test/lang/init.reference.ci:12: (9 bytes: <.main+3630 @062e62> - <.main+3639 @062e6b>): static fromRef: int64 := valueRef
	<.main+3630 @062e62> : 20 f8 0f 06                load.m32 <@060ff8> ;valueRef
	<.main+3634 @062e66> : 29                         load.i64
	<.main+3635 @062e67> : 23 10 10 06                store.m64 <@061010> ;fromRef
	cmplStd/test/lang/init.reference.ci:13: (8 bytes: <.main+3639 @062e6b> - <.main+3647 @062e73>): static fromPtr: int64 := valuePtr
	<.main+3639 @062e6b> : 20 00 10 06                load.m32 <@061000> ;valuePtr
	<.main+3643 @062e6f> : 24 18 10 06                store.m32 <@061018> ;fromPtr
	cmplStd/test/lang/init.reference.ci:14: (8 bytes: <.main+3647 @062e73> - <.main+3655 @062e7b>): static fromVar: int64 := valueVar
	<.main+3647 @062e73> : 20 08 10 06                load.m32 <@061008> ;valueVar
	<.main+3651 @062e77> : 24 20 10 06                store.m32 <@061020> ;fromVar
	cmplStd/test/lang/init.reference.ci:16: (9 bytes: <.main+3655 @062e7b> - <.main+3664 @062e84>): static nullRef: int64 := null
	<.main+3655 @062e7b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3660 @062e80> : 24 28 10 06                store.m32 <@061028> ;nullRef
	cmplStd/test/lang/init.reference.ci:17: (9 bytes: <.main+3664 @062e84> - <.main+3673 @062e8d>): static nullPtr: pointer := null
	<.main+3664 @062e84> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3669 @062e89> : 24 30 10 06                store.m32 <@061030> ;nullPtr
	cmplStd/test/lang/init.reference.ci:18: (14 bytes: <.main+3673 @062e8d> - <.main+3687 @062e9b>): static nullVar: variant := null
	<.main+3673 @062e8d> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3678 @062e92> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3683 @062e97> : 23 38 10 06                store.m64 <@061038> ;nullVar
	cmplStd/test/lang/init.reference.ci:19: (9 bytes: <.main+3687 @062e9b> - <.main+3696 @062ea4>): static nullTyp: typename := null
	<.main+3687 @062e9b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3692 @062ea0> : 24 40 10 06                store.m32 <@061040> ;nullTyp
	cmplStd/test/lang/init.reference.ci:20: (9 bytes: <.main+3696 @062ea4> - <.main+3705 @062ead>): static nullFun: function := null
	<.main+3696 @062ea4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3701 @062ea9> : 24 48 10 06                store.m32 <@061048> ;nullFun
	cmplStd/test/lang/init.reference.ci:21: (9 bytes: <.main+3705 @062ead> - <.main+3714 @062eb6>): static nullObj: object := null
	<.main+3705 @062ead> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3710 @062eb2> : 24 50 10 06                store.m32 <@061050> ;nullObj
	cmplStd/test/lang/init.reference.ci:23: (9 bytes: <.main+3714 @062eb6> - <.main+3723 @062ebf>): static typePtr: pointer := int64
	<.main+3714 @062eb6> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3719 @062ebb> : 24 58 10 06                store.m32 <@061058> ;typePtr
	cmplStd/test/lang/init.reference.ci:24: (14 bytes: <.main+3723 @062ebf> - <.main+3737 @062ecd>): static typeVar: variant := int64
	<.main+3723 @062ebf> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3728 @062ec4> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3733 @062ec9> : 23 60 10 06                store.m64 <@061060> ;typeVar
	cmplStd/test/lang/init.reference.ci:25: (9 bytes: <.main+3737 @062ecd> - <.main+3746 @062ed6>): static typeTyp: typename := int64
	<.main+3737 @062ecd> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3742 @062ed2> : 24 68 10 06                store.m32 <@061068> ;typeTyp
	cmplStd/test/lang/init.reference.ci:27: (8 bytes: <.main+3746 @062ed6> - <.main+3754 @062ede>): static local: int64 := value
	<.main+3746 @062ed6> : 21 f0 0f 06                load.m64 <@060ff0> ;value
	<.main+3750 @062eda> : 23 70 10 06                store.m64 <@061070> ;local
	cmplStd/test/lang/init.reference.ci:28: (8 bytes: <.main+3754 @062ede> - <.main+3762 @062ee6>): static copyVal: int64 := local
	<.main+3754 @062ede> : 21 70 10 06                load.m64 <@061070> ;local
	<.main+3758 @062ee2> : 23 78 10 06                store.m64 <@061078> ;copyVal
	cmplStd/test/lang/init.reference.ci:29: (8 bytes: <.main+3762 @062ee6> - <.main+3770 @062eee>): static copyRef: int64 := valueRef
	<.main+3762 @062ee6> : 20 f8 0f 06                load.m32 <@060ff8> ;valueRef
	<.main+3766 @062eea> : 24 80 10 06                store.m32 <@061080> ;copyRef
	cmplStd/test/lang/init.reference.ci:30: (8 bytes: <.main+3770 @062eee> - <.main+3778 @062ef6>): static copyPtr: pointer := valuePtr
	<.main+3770 @062eee> : 20 00 10 06                load.m32 <@061000> ;valuePtr
	<.main+3774 @062ef2> : 24 88 10 06                store.m32 <@061088> ;copyPtr
	cmplStd/test/lang/init.reference.ci:31: (8 bytes: <.main+3778 @062ef6> - <.main+3786 @062efe>): static copyVar: variant := valueVar
	<.main+3778 @062ef6> : 21 08 10 06                load.m64 <@061008> ;valueVar
	<.main+3782 @062efa> : 23 90 10 06                store.m64 <@061090> ;copyVar
	cmplStd/test/lang/init.reference.ci:32: (8 bytes: <.main+3786 @062efe> - <.main+3794 @062f06>): static copyTyp: typename := typeTyp
	<.main+3786 @062efe> : 20 68 10 06                load.m32 <@061068> ;typeTyp
	<.main+3790 @062f02> : 24 98 10 06                store.m32 <@061098> ;copyTyp
	cmplStd/test/lang/init.reference.ci:35: (9 bytes: <.main+3794 @062f06> - <.main+3803 @062f0f>): static ptrVoid: pointer := void
	<.main+3794 @062f06> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3799 @062f0b> : 24 a0 10 06                store.m32 <@0610a0> ;ptrVoid
	cmplStd/test/lang/init.reference.ci:36: (9 bytes: <.main+3803 @062f0f> - <.main+3812 @062f18>): static ptrBool: pointer := bool
	<.main+3803 @062f0f> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3808 @062f14> : 24 a8 10 06                store.m32 <@0610a8> ;ptrBool
	cmplStd/test/lang/init.reference.ci:37: (9 bytes: <.main+3812 @062f18> - <.main+3821 @062f21>): static ptrChar: pointer := char
	<.main+3812 @062f18> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3817 @062f1d> : 24 b0 10 06                store.m32 <@0610b0> ;ptrChar
	cmplStd/test/lang/init.reference.ci:38: (9 bytes: <.main+3821 @062f21> - <.main+3830 @062f2a>): static ptrInt8: pointer := int8
	<.main+3821 @062f21> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+3826 @062f26> : 24 b8 10 06                store.m32 <@0610b8> ;ptrInt8
	cmplStd/test/lang/init.reference.ci:39: (9 bytes: <.main+3830 @062f2a> - <.main+3839 @062f33>): static ptrInt16: pointer := int16
	<.main+3830 @062f2a> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+3835 @062f2f> : 24 c0 10 06                store.m32 <@0610c0> ;ptrInt16
	cmplStd/test/lang/init.reference.ci:40: (9 bytes: <.main+3839 @062f33> - <.main+3848 @062f3c>): static ptrInt32: pointer := int32
	<.main+3839 @062f33> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+3844 @062f38> : 24 c8 10 06                store.m32 <@0610c8> ;ptrInt32
	cmplStd/test/lang/init.reference.ci:41: (9 bytes: <.main+3848 @062f3c> - <.main+3857 @062f45>): static ptrInt64: pointer := int64
	<.main+3848 @062f3c> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3853 @062f41> : 24 d0 10 06                store.m32 <@0610d0> ;ptrInt64
	cmplStd/test/lang/init.reference.ci:42: (9 bytes: <.main+3857 @062f45> - <.main+3866 @062f4e>): static ptrUint8: pointer := uint8
	<.main+3857 @062f45> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+3862 @062f4a> : 24 d8 10 06                store.m32 <@0610d8> ;ptrUint8
	cmplStd/test/lang/init.reference.ci:43: (9 bytes: <.main+3866 @062f4e> - <.main+3875 @062f57>): static ptrUint16: pointer := uint16
	<.main+3866 @062f4e> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+3871 @062f53> : 24 e0 10 06                store.m32 <@0610e0> ;ptrUint16
	cmplStd/test/lang/init.reference.ci:44: (9 bytes: <.main+3875 @062f57> - <.main+3884 @062f60>): static ptrUint32: pointer := uint32
	<.main+3875 @062f57> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+3880 @062f5c> : 24 e8 10 06                store.m32 <@0610e8> ;ptrUint32
	cmplStd/test/lang/init.reference.ci:45: (9 bytes: <.main+3884 @062f60> - <.main+3893 @062f69>): static ptrUint64: pointer := uint64
	<.main+3884 @062f60> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+3889 @062f65> : 24 f0 10 06                store.m32 <@0610f0> ;ptrUint64
	cmplStd/test/lang/init.reference.ci:46: (9 bytes: <.main+3893 @062f69> - <.main+3902 @062f72>): static ptrFloat32: pointer := float32
	<.main+3893 @062f69> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+3898 @062f6e> : 24 f8 10 06                store.m32 <@0610f8> ;ptrFloat32
	cmplStd/test/lang/init.reference.ci:47: (9 bytes: <.main+3902 @062f72> - <.main+3911 @062f7b>): static ptrFloat64: pointer := float64
	<.main+3902 @062f72> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+3907 @062f77> : 24 00 11 06                store.m32 <@061100> ;ptrFloat64
	cmplStd/test/lang/init.reference.ci:48: (9 bytes: <.main+3911 @062f7b> - <.main+3920 @062f84>): static ptrTypename: pointer := typename
	<.main+3911 @062f7b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3916 @062f80> : 24 08 11 06                store.m32 <@061108> ;ptrTypename
	cmplStd/test/lang/init.reference.ci:49: (9 bytes: <.main+3920 @062f84> - <.main+3929 @062f8d>): static ptrFunction: pointer := function
	<.main+3920 @062f84> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+3925 @062f89> : 24 10 11 06                store.m32 <@061110> ;ptrFunction
	cmplStd/test/lang/init.reference.ci:50: (9 bytes: <.main+3929 @062f8d> - <.main+3938 @062f96>): static ptrPointer: pointer := pointer
	<.main+3929 @062f8d> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3934 @062f92> : 24 18 11 06                store.m32 <@061118> ;ptrPointer
	cmplStd/test/lang/init.reference.ci:51: (9 bytes: <.main+3938 @062f96> - <.main+3947 @062f9f>): static ptrVariant: pointer := variant
	<.main+3938 @062f96> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+3943 @062f9b> : 24 20 11 06                store.m32 <@061120> ;ptrVariant
	cmplStd/test/lang/init.reference.ci:52: (9 bytes: <.main+3947 @062f9f> - <.main+3956 @062fa8>): static ptrObject: pointer := object
	<.main+3947 @062f9f> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+3952 @062fa4> : 24 28 11 06                store.m32 <@061128> ;ptrObject
	cmplStd/test/lang/init.reference.ci:55: (14 bytes: <.main+3956 @062fa8> - <.main+3970 @062fb6>): static varVoid: variant := void
	<.main+3956 @062fa8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3961 @062fad> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3966 @062fb2> : 23 30 11 06                store.m64 <@061130> ;varVoid
	cmplStd/test/lang/init.reference.ci:56: (14 bytes: <.main+3970 @062fb6> - <.main+3984 @062fc4>): static varBool: variant := bool
	<.main+3970 @062fb6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3975 @062fbb> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3980 @062fc0> : 23 38 11 06                store.m64 <@061138> ;varBool
	cmplStd/test/lang/init.reference.ci:57: (14 bytes: <.main+3984 @062fc4> - <.main+3998 @062fd2>): static varChar: variant := char
	<.main+3984 @062fc4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3989 @062fc9> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3994 @062fce> : 23 40 11 06                store.m64 <@061140> ;varChar
	cmplStd/test/lang/init.reference.ci:58: (14 bytes: <.main+3998 @062fd2> - <.main+4012 @062fe0>): static varInt8: variant := int8
	<.main+3998 @062fd2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4003 @062fd7> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4008 @062fdc> : 23 48 11 06                store.m64 <@061148> ;varInt8
	cmplStd/test/lang/init.reference.ci:59: (14 bytes: <.main+4012 @062fe0> - <.main+4026 @062fee>): static varInt16: variant := int16
	<.main+4012 @062fe0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4017 @062fe5> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4022 @062fea> : 23 50 11 06                store.m64 <@061150> ;varInt16
	cmplStd/test/lang/init.reference.ci:60: (14 bytes: <.main+4026 @062fee> - <.main+4040 @062ffc>): static varInt32: variant := int32
	<.main+4026 @062fee> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4031 @062ff3> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4036 @062ff8> : 23 58 11 06                store.m64 <@061158> ;varInt32
	cmplStd/test/lang/init.reference.ci:61: (14 bytes: <.main+4040 @062ffc> - <.main+4054 @06300a>): static varInt64: variant := int64
	<.main+4040 @062ffc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4045 @063001> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4050 @063006> : 23 60 11 06                store.m64 <@061160> ;varInt64
	cmplStd/test/lang/init.reference.ci:62: (14 bytes: <.main+4054 @06300a> - <.main+4068 @063018>): static varUint8: variant := uint8
	<.main+4054 @06300a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4059 @06300f> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4064 @063014> : 23 68 11 06                store.m64 <@061168> ;varUint8
	cmplStd/test/lang/init.reference.ci:63: (14 bytes: <.main+4068 @063018> - <.main+4082 @063026>): static varUint16: variant := uint16
	<.main+4068 @063018> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4073 @06301d> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4078 @063022> : 23 70 11 06                store.m64 <@061170> ;varUint16
	cmplStd/test/lang/init.reference.ci:64: (14 bytes: <.main+4082 @063026> - <.main+4096 @063034>): static varUint32: variant := uint32
	<.main+4082 @063026> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4087 @06302b> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4092 @063030> : 23 78 11 06                store.m64 <@061178> ;varUint32
	cmplStd/test/lang/init.reference.ci:65: (14 bytes: <.main+4096 @063034> - <.main+4110 @063042>): static varUint64: variant := uint64
	<.main+4096 @063034> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4101 @063039> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4106 @06303e> : 23 80 11 06                store.m64 <@061180> ;varUint64
	cmplStd/test/lang/init.reference.ci:66: (14 bytes: <.main+4110 @063042> - <.main+4124 @063050>): static varFloat32: variant := float32
	<.main+4110 @063042> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4115 @063047> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4120 @06304c> : 23 88 11 06                store.m64 <@061188> ;varFloat32
	cmplStd/test/lang/init.reference.ci:67: (14 bytes: <.main+4124 @063050> - <.main+4138 @06305e>): static varFloat64: variant := float64
	<.main+4124 @063050> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4129 @063055> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4134 @06305a> : 23 90 11 06                store.m64 <@061190> ;varFloat64
	cmplStd/test/lang/init.reference.ci:68: (14 bytes: <.main+4138 @06305e> - <.main+4152 @06306c>): static varTypename: variant := typename
	<.main+4138 @06305e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4143 @063063> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4148 @063068> : 23 98 11 06                store.m64 <@061198> ;varTypename
	cmplStd/test/lang/init.reference.ci:69: (14 bytes: <.main+4152 @06306c> - <.main+4166 @06307a>): static varFunction: variant := function
	<.main+4152 @06306c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4157 @063071> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4162 @063076> : 23 a0 11 06                store.m64 <@0611a0> ;varFunction
	cmplStd/test/lang/init.reference.ci:70: (14 bytes: <.main+4166 @06307a> - <.main+4180 @063088>): static varPointer: variant := pointer
	<.main+4166 @06307a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4171 @06307f> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4176 @063084> : 23 a8 11 06                store.m64 <@0611a8> ;varPointer
	cmplStd/test/lang/init.reference.ci:71: (14 bytes: <.main+4180 @063088> - <.main+4194 @063096>): static varVariant: variant := variant
	<.main+4180 @063088> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4185 @06308d> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4190 @063092> : 23 b0 11 06                store.m64 <@0611b0> ;varVariant
	cmplStd/test/lang/init.reference.ci:72: (14 bytes: <.main+4194 @063096> - <.main+4208 @0630a4>): static varObject: variant := object
	<.main+4194 @063096> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4199 @06309b> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4204 @0630a0> : 23 b8 11 06                store.m64 <@0611b8> ;varObject
	cmplStd/test/lang/init.reference.ci:75: (9 bytes: <.main+4208 @0630a4> - <.main+4217 @0630ad>): static typVoid: typename := void
	<.main+4208 @0630a4> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4213 @0630a9> : 24 c0 11 06                store.m32 <@0611c0> ;typVoid
	cmplStd/test/lang/init.reference.ci:76: (9 bytes: <.main+4217 @0630ad> - <.main+4226 @0630b6>): static typBool: typename := bool
	<.main+4217 @0630ad> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4222 @0630b2> : 24 c8 11 06                store.m32 <@0611c8> ;typBool
	cmplStd/test/lang/init.reference.ci:77: (9 bytes: <.main+4226 @0630b6> - <.main+4235 @0630bf>): static typChar: typename := char
	<.main+4226 @0630b6> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4231 @0630bb> : 24 d0 11 06                store.m32 <@0611d0> ;typChar
	cmplStd/test/lang/init.reference.ci:78: (9 bytes: <.main+4235 @0630bf> - <.main+4244 @0630c8>): static typInt8: typename := int8
	<.main+4235 @0630bf> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4240 @0630c4> : 24 d8 11 06                store.m32 <@0611d8> ;typInt8
	cmplStd/test/lang/init.reference.ci:79: (9 bytes: <.main+4244 @0630c8> - <.main+4253 @0630d1>): static typInt16: typename := int16
	<.main+4244 @0630c8> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4249 @0630cd> : 24 e0 11 06                store.m32 <@0611e0> ;typInt16
	cmplStd/test/lang/init.reference.ci:80: (9 bytes: <.main+4253 @0630d1> - <.main+4262 @0630da>): static typInt32: typename := int32
	<.main+4253 @0630d1> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4258 @0630d6> : 24 e8 11 06                store.m32 <@0611e8> ;typInt32
	cmplStd/test/lang/init.reference.ci:81: (9 bytes: <.main+4262 @0630da> - <.main+4271 @0630e3>): static typInt64: typename := int64
	<.main+4262 @0630da> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4267 @0630df> : 24 f0 11 06                store.m32 <@0611f0> ;typInt64
	cmplStd/test/lang/init.reference.ci:82: (9 bytes: <.main+4271 @0630e3> - <.main+4280 @0630ec>): static typUint8: typename := uint8
	<.main+4271 @0630e3> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4276 @0630e8> : 24 f8 11 06                store.m32 <@0611f8> ;typUint8
	cmplStd/test/lang/init.reference.ci:83: (9 bytes: <.main+4280 @0630ec> - <.main+4289 @0630f5>): static typUint16: typename := uint16
	<.main+4280 @0630ec> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4285 @0630f1> : 24 00 12 06                store.m32 <@061200> ;typUint16
	cmplStd/test/lang/init.reference.ci:84: (9 bytes: <.main+4289 @0630f5> - <.main+4298 @0630fe>): static typUint32: typename := uint32
	<.main+4289 @0630f5> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4294 @0630fa> : 24 08 12 06                store.m32 <@061208> ;typUint32
	cmplStd/test/lang/init.reference.ci:85: (9 bytes: <.main+4298 @0630fe> - <.main+4307 @063107>): static typUint64: typename := uint64
	<.main+4298 @0630fe> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4303 @063103> : 24 10 12 06                store.m32 <@061210> ;typUint64
	cmplStd/test/lang/init.reference.ci:86: (9 bytes: <.main+4307 @063107> - <.main+4316 @063110>): static typFloat32: typename := float32
	<.main+4307 @063107> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4312 @06310c> : 24 18 12 06                store.m32 <@061218> ;typFloat32
	cmplStd/test/lang/init.reference.ci:87: (9 bytes: <.main+4316 @063110> - <.main+4325 @063119>): static typFloat64: typename := float64
	<.main+4316 @063110> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4321 @063115> : 24 20 12 06                store.m32 <@061220> ;typFloat64
	cmplStd/test/lang/init.reference.ci:88: (9 bytes: <.main+4325 @063119> - <.main+4334 @063122>): static typTypename: typename := typename
	<.main+4325 @063119> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4330 @06311e> : 24 28 12 06                store.m32 <@061228> ;typTypename
	cmplStd/test/lang/init.reference.ci:89: (9 bytes: <.main+4334 @063122> - <.main+4343 @06312b>): static typFunction: typename := function
	<.main+4334 @063122> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4339 @063127> : 24 30 12 06                store.m32 <@061230> ;typFunction
	cmplStd/test/lang/init.reference.ci:90: (9 bytes: <.main+4343 @06312b> - <.main+4352 @063134>): static typPointer: typename := pointer
	<.main+4343 @06312b> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4348 @063130> : 24 38 12 06                store.m32 <@061238> ;typPointer
	cmplStd/test/lang/init.reference.ci:91: (9 bytes: <.main+4352 @063134> - <.main+4361 @06313d>): static typVariant: typename := variant
	<.main+4352 @063134> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4357 @063139> : 24 40 12 06                store.m32 <@061240> ;typVariant
	cmplStd/test/lang/init.reference.ci:92: (9 bytes: <.main+4361 @06313d> - <.main+4370 @063146>): static typObject: typename := object
	<.main+4361 @06313d> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4366 @063142> : 24 48 12 06                store.m32 <@061248> ;typObject
	cmplStd/test/lang/init.reference.ci:95: (9 bytes: <.main+4370 @063146> - <.main+4379 @06314f>): static valueOfPtr: pointer := pointer(value)
	<.main+4370 @063146> : 1f f0 0f 06 00             load.ref <@060ff0> ;value
	<.main+4375 @06314b> : 24 50 12 06                store.m32 <@061250> ;valueOfPtr
	cmplStd/test/lang/init.reference.ci:96: (14 bytes: <.main+4379 @06314f> - <.main+4393 @06315d>): static valueOfVar: variant := variant(value)
	<.main+4379 @06314f> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4384 @063154> : 1f f0 0f 06 00             load.ref <@060ff0> ;value
	<.main+4389 @063159> : 23 58 12 06                store.m64 <@061258> ;valueOfVar
	cmplStd/test/lang/init.reference.ci:97: (9 bytes: <.main+4393 @06315d> - <.main+4402 @063166>): static valueOfTyp: typename := typename(value)
	<.main+4393 @06315d> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4398 @063162> : 24 60 12 06                store.m32 <@061260> ;valueOfTyp
	cmplStd/test/lang/init.reference.ci:99: (9 bytes: <.main+4402 @063166> - <.main+4411 @06316f>): static typeOfValue: typename := typename(value)
	<.main+4402 @063166> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4407 @06316b> : 24 68 12 06                store.m32 <@061268> ;typeOfValue
	cmplStd/test/lang/init.reference.ci:105: (13 bytes: <.main+4411 @06316f> - <.main+4424 @06317c>): static copyPtrFloat64: variant := ptrFloat64
	<.main+4411 @06316f> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4416 @063174> : 20 00 11 06                load.m32 <@061100> ;ptrFloat64
	<.main+4420 @063178> : 23 70 12 06                store.m64 <@061270> ;copyPtrFloat64
	cmplStd/test/lang/init.reference.ci:108: (8 bytes: <.main+4424 @06317c> - <.main+4432 @063184>): static copyVarFloat64: pointer := varFloat64
	<.main+4424 @06317c> : 20 90 11 06                load.m32 <@061190> ;varFloat64
	<.main+4428 @063180> : 24 78 12 06                store.m32 <@061278> ;copyVarFloat64
	cmplStd/test/lang/init.variable.ci:3: (5 bytes: <.main+4432 @063184> - <.main+4437 @063189>): static variable: int32
	<.main+4432 @063184> : 19                         load.z32
	<.main+4433 @063185> : 24 80 12 06                store.m32 <@061280> ;variable
	cmplStd/test/lang/init.variable.ci:7: (9 bytes: <.main+4437 @063189> - <.main+4446 @063192>): static const constant: int32 := 42
	<.main+4437 @063189> : 1c 2a 00 00 00             load.c32 42
	<.main+4442 @06318e> : 24 88 12 06                store.m32 <@061288> ;constant
	cmplStd/test/lang/init.variable.ci:24: (18 bytes: <.main+4446 @063192> - <.main+4464 @0631a4>): static valInitImplicit: ComplexVal := {...}
	cmplStd/test/lang/init.variable.ci:24: (13 bytes: <.main+4446 @063192> - <.main+4459 @06319f>): valInitImplicit.re := (8);
	<.main+4446 @063192> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4455 @06319b> : 23 90 12 06                store.m64 <@061290> ;valInitImplicit
	:: (5 bytes: <.main+4459 @06319f> - <.main+4464 @0631a4>): valInitImplicit.im := (0);
	<.main+4459 @06319f> : 1a                         load.z64
	<.main+4460 @0631a0> : 23 98 12 06                store.m64 <@061298> ;valInitImplicit+8
	cmplStd/test/lang/init.variable.ci:33: (41 bytes: <.main+4464 @0631a4> - <.main+4505 @0631cd>): static objInitImplicit: ComplexObj := {...}
	cmplStd/test/lang/init.variable.ci:33: (13 bytes: <.main+4464 @0631a4> - <.main+4477 @0631b1>): objInitImplicit := create(ComplexObj);
	<.main+4464 @0631a4> : 1f 40 95 04 00             load.ref <@049540> ;ComplexObj
	<.main+4469 @0631a9> : 01 07 00 00                nfc(7) ;object.create(type: typename): pointer
	<.main+4473 @0631ad> : 24 a0 12 06                store.m32 <@0612a0> ;objInitImplicit
	cmplStd/test/lang/init.variable.ci:33: (18 bytes: <.main+4477 @0631b1> - <.main+4495 @0631c3>): objInitImplicit.re := (8);
	<.main+4477 @0631b1> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4486 @0631ba> : 20 a0 12 06                load.m32 <@0612a0> ;objInitImplicit
	<.main+4490 @0631be> : 0c 04 00 00                inc.i32(+4)
	<.main+4494 @0631c2> : 2e                         store.i64
	:: (10 bytes: <.main+4495 @0631c3> - <.main+4505 @0631cd>): objInitImplicit.im := (0);
	<.main+4495 @0631c3> : 1a                         load.z64
	<.main+4496 @0631c4> : 20 a0 12 06                load.m32 <@0612a0> ;objInitImplicit
	<.main+4500 @0631c8> : 0c 0c 00 00                inc.i32(+12)
	<.main+4504 @0631cc> : 2e                         store.i64
	cmplStd/test/lang/init.variable.ci:41: (41 bytes: <.main+4505 @0631cd> - <.main+4546 @0631f6>): static objInitExplicit: object := {...}
	cmplStd/test/lang/init.variable.ci:41: (13 bytes: <.main+4505 @0631cd> - <.main+4518 @0631da>): objInitExplicit := create(ComplexObj);
	<.main+4505 @0631cd> : 1f 40 95 04 00             load.ref <@049540> ;ComplexObj
	<.main+4510 @0631d2> : 01 07 00 00                nfc(7) ;object.create(type: typename): pointer
	<.main+4514 @0631d6> : 24 a8 12 06                store.m32 <@0612a8> ;objInitExplicit
	cmplStd/test/lang/init.variable.ci:41: (18 bytes: <.main+4518 @0631da> - <.main+4536 @0631ec>): objInitExplicit.re := (8);
	<.main+4518 @0631da> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4527 @0631e3> : 20 a8 12 06                load.m32 <@0612a8> ;objInitExplicit
	<.main+4531 @0631e7> : 0c 04 00 00                inc.i32(+4)
	<.main+4535 @0631eb> : 2e                         store.i64
	:: (10 bytes: <.main+4536 @0631ec> - <.main+4546 @0631f6>): objInitExplicit.im := (0);
	<.main+4536 @0631ec> : 1a                         load.z64
	<.main+4537 @0631ed> : 20 a8 12 06                load.m32 <@0612a8> ;objInitExplicit
	<.main+4541 @0631f1> : 0c 0c 00 00                inc.i32(+12)
	<.main+4545 @0631f5> : 2e                         store.i64
	cmplStd/test/lang/function.ci:12: (25 bytes: <.main+4546 @0631f6> - <.main+4571 @06320f>): static funAddResult: int32 := funAdd(2, 7)
	<.main+4546 @0631f6> : 19                         load.z32
	<.main+4547 @0631f7> : 1c 02 00 00 00             load.c32 2
	<.main+4552 @0631fc> : 1c 07 00 00 00             load.c32 7
	<.main+4557 @063201> : 1f b8 12 06 00             load.ref <@0612b8> ;funAdd(x: int32, y: int32): int32
	<.main+4562 @063206> : 02                         call
	<.main+4563 @063207> : 09 f8 ff ff                inc.sp(-8)
	<.main+4567 @06320b> : 24 c0 12 06                store.m32 <@0612c0> ;funAddResult
	cmplStd/test/lang/function.ci:15: (9 bytes: <.main+4571 @06320f> - <.main+4580 @063218>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+4571 @06320f> : 1f b8 12 06 00             load.ref <@0612b8> ;funAdd(x: int32, y: int32): int32
	<.main+4576 @063214> : 24 c8 12 06                store.m32 <@0612c8> ;funAddRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:18: (24 bytes: <.main+4580 @063218> - <.main+4604 @063230>): static funAddRefResult: int32 := funAddRef(2, 8)
	<.main+4580 @063218> : 19                         load.z32
	<.main+4581 @063219> : 1c 02 00 00 00             load.c32 2
	<.main+4586 @06321e> : 1c 08 00 00 00             load.c32 8
	<.main+4591 @063223> : 20 c8 12 06                load.m32 <@0612c8> ;funAddRef(x: int32, y: int32): int32
	<.main+4595 @063227> : 02                         call
	<.main+4596 @063228> : 09 f8 ff ff                inc.sp(-8)
	<.main+4600 @06322c> : 24 d0 12 06                store.m32 <@0612d0> ;funAddRefResult
	cmplStd/test/lang/function.ci:21: (9 bytes: <.main+4604 @063230> - <.main+4613 @063239>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+4604 @063230> : 1f f8 12 06 00             load.ref <@0612f8> ;funMul(x: int32, y: int32): int32
	<.main+4609 @063235> : 24 d8 12 06                store.m32 <@0612d8> ;funMul(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:24: (24 bytes: <.main+4613 @063239> - <.main+4637 @063251>): static funMulResult: int32 := funMul(2, 6)
	<.main+4613 @063239> : 19                         load.z32
	<.main+4614 @06323a> : 1c 02 00 00 00             load.c32 2
	<.main+4619 @06323f> : 1c 06 00 00 00             load.c32 6
	<.main+4624 @063244> : 20 d8 12 06                load.m32 <@0612d8> ;funMul(x: int32, y: int32): int32
	<.main+4628 @063248> : 02                         call
	<.main+4629 @063249> : 09 f8 ff ff                inc.sp(-8)
	<.main+4633 @06324d> : 24 e0 12 06                store.m32 <@0612e0> ;funMulResult
	cmplStd/test/lang/function.ci:27: (8 bytes: <.main+4637 @063251> - <.main+4645 @063259>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+4637 @063251> : 20 d8 12 06                load.m32 <@0612d8> ;funMul(x: int32, y: int32): int32
	<.main+4641 @063255> : 24 e8 12 06                store.m32 <@0612e8> ;funMulRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:30: (24 bytes: <.main+4645 @063259> - <.main+4669 @063271>): static funMulRefResult: int32 := funMulRef(2, 7)
	<.main+4645 @063259> : 19                         load.z32
	<.main+4646 @06325a> : 1c 02 00 00 00             load.c32 2
	<.main+4651 @06325f> : 1c 07 00 00 00             load.c32 7
	<.main+4656 @063264> : 20 e8 12 06                load.m32 <@0612e8> ;funMulRef(x: int32, y: int32): int32
	<.main+4660 @063268> : 02                         call
	<.main+4661 @063269> : 09 f8 ff ff                inc.sp(-8)
	<.main+4665 @06326d> : 24 f0 12 06                store.m32 <@0612f0> ;funMulRefResult
	cmplStd/test/lang/function.ci:46: (20 bytes: <.main+4669 @063271> - <.main+4689 @063285>): static fibonacci_13: uint32 := fib(13)
	<.main+4669 @063271> : 19                         load.z32
	<.main+4670 @063272> : 1c 0d 00 00 00             load.c32 13
	<.main+4675 @063277> : 1f 00 13 06 00             load.ref <@061300> ;fib(n: uint32): uint32
	<.main+4680 @06327c> : 02                         call
	<.main+4681 @06327d> : 09 fc ff ff                inc.sp(-4)
	<.main+4685 @063281> : 24 38 13 06                store.m32 <@061338> ;fibonacci_13
	cmplStd/test/lang/reflect.ci:3: (13 bytes: <.main+4689 @063285> - <.main+4702 @063292>): static sizeofVoid: int32 := sizeof(void)
	<.main+4689 @063285> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4694 @06328a> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4698 @06328e> : 24 40 13 06                store.m32 <@061340> ;sizeofVoid
	cmplStd/test/lang/reflect.ci:4: (13 bytes: <.main+4702 @063292> - <.main+4715 @06329f>): static sizeofBool: int32 := sizeof(bool)
	<.main+4702 @063292> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4707 @063297> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4711 @06329b> : 24 48 13 06                store.m32 <@061348> ;sizeofBool
	cmplStd/test/lang/reflect.ci:5: (13 bytes: <.main+4715 @06329f> - <.main+4728 @0632ac>): static sizeofChar: int32 := sizeof(char)
	<.main+4715 @06329f> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4720 @0632a4> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4724 @0632a8> : 24 50 13 06                store.m32 <@061350> ;sizeofChar
	cmplStd/test/lang/reflect.ci:6: (13 bytes: <.main+4728 @0632ac> - <.main+4741 @0632b9>): static sizeofInt8: int32 := sizeof(int8)
	<.main+4728 @0632ac> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4733 @0632b1> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4737 @0632b5> : 24 58 13 06                store.m32 <@061358> ;sizeofInt8
	cmplStd/test/lang/reflect.ci:7: (13 bytes: <.main+4741 @0632b9> - <.main+4754 @0632c6>): static sizeofInt16: int32 := sizeof(int16)
	<.main+4741 @0632b9> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4746 @0632be> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4750 @0632c2> : 24 60 13 06                store.m32 <@061360> ;sizeofInt16
	cmplStd/test/lang/reflect.ci:8: (13 bytes: <.main+4754 @0632c6> - <.main+4767 @0632d3>): static sizeofInt32: int32 := sizeof(int32)
	<.main+4754 @0632c6> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4759 @0632cb> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4763 @0632cf> : 24 68 13 06                store.m32 <@061368> ;sizeofInt32
	cmplStd/test/lang/reflect.ci:9: (13 bytes: <.main+4767 @0632d3> - <.main+4780 @0632e0>): static sizeofInt64: int32 := sizeof(int64)
	<.main+4767 @0632d3> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4772 @0632d8> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4776 @0632dc> : 24 70 13 06                store.m32 <@061370> ;sizeofInt64
	cmplStd/test/lang/reflect.ci:10: (13 bytes: <.main+4780 @0632e0> - <.main+4793 @0632ed>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+4780 @0632e0> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4785 @0632e5> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4789 @0632e9> : 24 78 13 06                store.m32 <@061378> ;sizeofUint8
	cmplStd/test/lang/reflect.ci:11: (13 bytes: <.main+4793 @0632ed> - <.main+4806 @0632fa>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+4793 @0632ed> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4798 @0632f2> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4802 @0632f6> : 24 80 13 06                store.m32 <@061380> ;sizeofUint16
	cmplStd/test/lang/reflect.ci:12: (13 bytes: <.main+4806 @0632fa> - <.main+4819 @063307>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+4806 @0632fa> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4811 @0632ff> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4815 @063303> : 24 88 13 06                store.m32 <@061388> ;sizeofUint32
	cmplStd/test/lang/reflect.ci:13: (13 bytes: <.main+4819 @063307> - <.main+4832 @063314>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+4819 @063307> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4824 @06330c> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4828 @063310> : 24 90 13 06                store.m32 <@061390> ;sizeofUint64
	cmplStd/test/lang/reflect.ci:14: (13 bytes: <.main+4832 @063314> - <.main+4845 @063321>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+4832 @063314> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4837 @063319> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4841 @06331d> : 24 98 13 06                store.m32 <@061398> ;sizeofFloat32
	cmplStd/test/lang/reflect.ci:15: (13 bytes: <.main+4845 @063321> - <.main+4858 @06332e>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+4845 @063321> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4850 @063326> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4854 @06332a> : 24 a0 13 06                store.m32 <@0613a0> ;sizeofFloat64
	cmplStd/test/lang/reflect.ci:16: (13 bytes: <.main+4858 @06332e> - <.main+4871 @06333b>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+4858 @06332e> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4863 @063333> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4867 @063337> : 24 a8 13 06                store.m32 <@0613a8> ;sizeofPointer
	cmplStd/test/lang/reflect.ci:17: (13 bytes: <.main+4871 @06333b> - <.main+4884 @063348>): static sizeofVariant: int32 := sizeof(variant)
	<.main+4871 @06333b> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4876 @063340> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4880 @063344> : 24 b0 13 06                store.m32 <@0613b0> ;sizeofVariant
	cmplStd/test/lang/reflect.ci:18: (13 bytes: <.main+4884 @063348> - <.main+4897 @063355>): static sizeofTypename: int32 := sizeof(typename)
	<.main+4884 @063348> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4889 @06334d> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4893 @063351> : 24 b8 13 06                store.m32 <@0613b8> ;sizeofTypename
	cmplStd/test/lang/reflect.ci:19: (13 bytes: <.main+4897 @063355> - <.main+4910 @063362>): static sizeofFunction: int32 := sizeof(function)
	<.main+4897 @063355> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4902 @06335a> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4906 @06335e> : 24 c0 13 06                store.m32 <@0613c0> ;sizeofFunction
	cmplStd/test/lang/reflect.ci:20: (13 bytes: <.main+4910 @063362> - <.main+4923 @06336f>): static sizeofObject: int32 := sizeof(object)
	<.main+4910 @063362> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4915 @063367> : 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+4919 @06336b> : 24 c8 13 06                store.m32 <@0613c8> ;sizeofObject
	cmplStd/test/lang/reflect.ci:30: (9 bytes: <.main+4923 @06336f> - <.main+4932 @063378>): static typeofRecord: typename := RecordSizeofExt
	<.main+4923 @06336f> : 1f 50 bc 04 00             load.ref <@04bc50> ;RecordSizeofExt
	<.main+4928 @063374> : 24 d0 13 06                store.m32 <@0613d0> ;typeofRecord
	cmplStd/test/lang/reflect.ci:31: (12 bytes: <.main+4932 @063378> - <.main+4944 @063384>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+4932 @063378> : 20 d0 13 06                load.m32 <@0613d0> ;typeofRecord
	<.main+4936 @06337c> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4940 @063380> : 24 d8 13 06                store.m32 <@0613d8> ;nameOfRecord
	cmplStd/test/lang/reflect.ci:32: (13 bytes: <.main+4944 @063384> - <.main+4957 @063391>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+4944 @063384> : 20 d0 13 06                load.m32 <@0613d0> ;typeofRecord
	<.main+4948 @063388> : 0c 28 00 00                inc.i32(+40)
	<.main+4952 @06338c> : 28                         load.i32
	<.main+4953 @06338d> : 24 e0 13 06                store.m32 <@0613e0> ;offsetOfRecord
	cmplStd/test/lang/reflect.ci:33: (13 bytes: <.main+4957 @063391> - <.main+4970 @06339e>): static sizeOfRecord: int32 := typeofRecord.size
	<.main+4957 @063391> : 20 d0 13 06                load.m32 <@0613d0> ;typeofRecord
	<.main+4961 @063395> : 0c 20 00 00                inc.i32(+32)
	<.main+4965 @063399> : 28                         load.i32
	<.main+4966 @06339a> : 24 e8 13 06                store.m32 <@0613e8> ;sizeOfRecord
	cmplStd/test/lang/reflect.ci:34: (12 bytes: <.main+4970 @06339e> - <.main+4982 @0633aa>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+4970 @06339e> : 20 d0 13 06                load.m32 <@0613d0> ;typeofRecord
	<.main+4974 @0633a2> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4978 @0633a6> : 24 f0 13 06                store.m32 <@0613f0> ;fileOfRecord
	cmplStd/test/lang/reflect.ci:35: (12 bytes: <.main+4982 @0633aa> - <.main+4994 @0633b6>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+4982 @0633aa> : 20 d0 13 06                load.m32 <@0613d0> ;typeofRecord
	<.main+4986 @0633ae> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4990 @0633b2> : 24 f8 13 06                store.m32 <@0613f8> ;lineOfRecord
	cmplStd/test/lang/reflect.ci:37: (12 bytes: <.main+4994 @0633b6> - <.main+5006 @0633c2>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+4994 @0633b6> : 20 d0 13 06                load.m32 <@0613d0> ;typeofRecord
	<.main+4998 @0633ba> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5002 @0633be> : 24 00 14 06                store.m32 <@061400> ;typeofBase
	cmplStd/test/lang/reflect.ci:38: (12 bytes: <.main+5006 @0633c2> - <.main+5018 @0633ce>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+5006 @0633c2> : 20 00 14 06                load.m32 <@061400> ;typeofBase
	<.main+5010 @0633c6> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+5014 @0633ca> : 24 08 14 06                store.m32 <@061408> ;nameOfBase
	cmplStd/test/lang/reflect.ci:39: (13 bytes: <.main+5018 @0633ce> - <.main+5031 @0633db>): static offsetOfBase: int32 := typeofBase.offset
	<.main+5018 @0633ce> : 20 00 14 06                load.m32 <@061400> ;typeofBase
	<.main+5022 @0633d2> : 0c 28 00 00                inc.i32(+40)
	<.main+5026 @0633d6> : 28                         load.i32
	<.main+5027 @0633d7> : 24 10 14 06                store.m32 <@061410> ;offsetOfBase
	cmplStd/test/lang/reflect.ci:40: (13 bytes: <.main+5031 @0633db> - <.main+5044 @0633e8>): static sizeOfBase: int32 := typeofBase.size
	<.main+5031 @0633db> : 20 00 14 06                load.m32 <@061400> ;typeofBase
	<.main+5035 @0633df> : 0c 20 00 00                inc.i32(+32)
	<.main+5039 @0633e3> : 28                         load.i32
	<.main+5040 @0633e4> : 24 18 14 06                store.m32 <@061418> ;sizeOfBase
	cmplStd/test/lang/reflect.ci:41: (12 bytes: <.main+5044 @0633e8> - <.main+5056 @0633f4>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+5044 @0633e8> : 20 00 14 06                load.m32 <@061400> ;typeofBase
	<.main+5048 @0633ec> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+5052 @0633f0> : 24 20 14 06                store.m32 <@061420> ;fileOfBase
	cmplStd/test/lang/reflect.ci:42: (12 bytes: <.main+5056 @0633f4> - <.main+5068 @063400>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+5056 @0633f4> : 20 00 14 06                load.m32 <@061400> ;typeofBase
	<.main+5060 @0633f8> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+5064 @0633fc> : 24 28 14 06                store.m32 <@061428> ;lineOfBase
	cmplStd/test/lang/reflect.ci:44: (12 bytes: <.main+5068 @063400> - <.main+5080 @06340c>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+5068 @063400> : 20 00 14 06                load.m32 <@061400> ;typeofBase
	<.main+5072 @063404> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5076 @063408> : 24 30 14 06                store.m32 <@061430> ;typeofBase1
	cmplStd/test/lang/reflect.ci:45: (13 bytes: <.main+5080 @06340c> - <.main+5093 @063419>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+5080 @06340c> : 20 30 14 06                load.m32 <@061430> ;typeofBase1
	<.main+5084 @063410> : 0c 28 00 00                inc.i32(+40)
	<.main+5088 @063414> : 28                         load.i32
	<.main+5089 @063415> : 24 38 14 06                store.m32 <@061438> ;offsetOfBase1
	cmplStd/test/lang/reflect.ci:46: (13 bytes: <.main+5093 @063419> - <.main+5106 @063426>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+5093 @063419> : 20 30 14 06                load.m32 <@061430> ;typeofBase1
	<.main+5097 @06341d> : 0c 20 00 00                inc.i32(+32)
	<.main+5101 @063421> : 28                         load.i32
	<.main+5102 @063422> : 24 40 14 06                store.m32 <@061440> ;sizeOfBase1
	cmplStd/test/lang/reflect.ci:48: (12 bytes: <.main+5106 @063426> - <.main+5118 @063432>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+5106 @063426> : 20 30 14 06                load.m32 <@061430> ;typeofBase1
	<.main+5110 @06342a> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5114 @06342e> : 24 48 14 06                store.m32 <@061448> ;typeofBase2
	cmplStd/test/lang/reflect.ci:49: (13 bytes: <.main+5118 @063432> - <.main+5131 @06343f>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+5118 @063432> : 20 48 14 06                load.m32 <@061448> ;typeofBase2
	<.main+5122 @063436> : 0c 28 00 00                inc.i32(+40)
	<.main+5126 @06343a> : 28                         load.i32
	<.main+5127 @06343b> : 24 50 14 06                store.m32 <@061450> ;offsetOfBase2
	cmplStd/test/lang/reflect.ci:50: (13 bytes: <.main+5131 @06343f> - <.main+5144 @06344c>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+5131 @06343f> : 20 48 14 06                load.m32 <@061448> ;typeofBase2
	<.main+5135 @063443> : 0c 20 00 00                inc.i32(+32)
	<.main+5139 @063447> : 28                         load.i32
	<.main+5140 @063448> : 24 58 14 06                store.m32 <@061458> ;sizeOfBase2
	cmplStd/test/lang/init.member.ci:34: (5 bytes: <.main+5144 @06344c> - <.main+5149 @063451>): static global: int32
	<.main+5144 @06344c> : 19                         load.z32
	<.main+5145 @06344d> : 24 60 14 06                store.m32 <@061460> ;RecordMemberTest.global
	cmplStd/test/lang/init.member.ci:37: (9 bytes: <.main+5149 @063451> - <.main+5158 @06345a>): static globalInit: int32 := 1
	<.main+5149 @063451> : 1c 01 00 00 00             load.c32 1
	<.main+5154 @063456> : 24 68 14 06                store.m32 <@061468> ;RecordMemberTest.globalInit
	cmplStd/test/lang/init.member.ci:40: (9 bytes: <.main+5158 @06345a> - <.main+5167 @063463>): static const globalConstant: int32 := 2
	<.main+5158 @06345a> : 1c 02 00 00 00             load.c32 2
	<.main+5163 @06345f> : 24 70 14 06                store.m32 <@061470> ;RecordMemberTest.globalConstant
	cmplStd/test/lang/init.member.ci:43: (14 bytes: <.main+5167 @063463> - <.main+5181 @063471>): static globalRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:43: (9 bytes: <.main+5167 @063463> - <.main+5176 @06346c>): globalRec.constant := 4;
	<.main+5167 @063463> : 1c 04 00 00 00             load.c32 4
	<.main+5172 @063468> : 24 7c 14 06                store.m32 <@06147c> ;RecordMemberTest.globalRec+4
	:: (5 bytes: <.main+5176 @06346c> - <.main+5181 @063471>): globalRec.member := (0);
	<.main+5176 @06346c> : 19                         load.z32
	<.main+5177 @06346d> : 24 78 14 06                store.m32 <@061478> ;RecordMemberTest.globalRec
	cmplStd/test/lang/init.member.ci:46: (18 bytes: <.main+5181 @063471> - <.main+5199 @063483>): static globalRecInit: Inner := {...}
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5181 @063471> - <.main+5190 @06347a>): globalRecInit.member := 4;
	<.main+5181 @063471> : 1c 04 00 00 00             load.c32 4
	<.main+5186 @063476> : 24 80 14 06                store.m32 <@061480> ;RecordMemberTest.globalRecInit
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5190 @06347a> - <.main+5199 @063483>): globalRecInit.constant := 5;
	<.main+5190 @06347a> : 1c 05 00 00 00             load.c32 5
	<.main+5195 @06347f> : 24 84 14 06                store.m32 <@061484> ;RecordMemberTest.globalRecInit+4
	cmplStd/test/lang/init.member.ci:49: (18 bytes: <.main+5199 @063483> - <.main+5217 @063495>): static const globalConstantRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5199 @063483> - <.main+5208 @06348c>): globalConstantRec.member := 6;
	<.main+5199 @063483> : 1c 06 00 00 00             load.c32 6
	<.main+5204 @063488> : 24 88 14 06                store.m32 <@061488> ;RecordMemberTest.globalConstantRec
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5208 @06348c> - <.main+5217 @063495>): globalConstantRec.constant := 7;
	<.main+5208 @06348c> : 1c 07 00 00 00             load.c32 7
	<.main+5213 @063491> : 24 8c 14 06                store.m32 <@06148c> ;RecordMemberTest.globalConstantRec+4
	cmplStd/test/lang/init.member.ci:52: (72 bytes: <.main+5217 @063495> - <.main+5289 @0634dd>): static recordMemberTest: RecordMemberTest := {...}
	cmplStd/test/lang/init.member.ci:53: (9 bytes: <.main+5217 @063495> - <.main+5226 @06349e>): recordMemberTest.member := 10;
	<.main+5217 @063495> : 1c 0a 00 00 00             load.c32 10
	<.main+5222 @06349a> : 24 90 14 06                store.m32 <@061490> ;recordMemberTest
	cmplStd/test/lang/init.member.ci:54: (9 bytes: <.main+5226 @06349e> - <.main+5235 @0634a7>): recordMemberTest.constant := 11;
	<.main+5226 @06349e> : 1c 0b 00 00 00             load.c32 11
	<.main+5231 @0634a3> : 24 94 14 06                store.m32 <@061494> ;recordMemberTest+4
	cmplStd/test/lang/init.member.ci:55: (9 bytes: <.main+5235 @0634a7> - <.main+5244 @0634b0>): recordMemberTest.memberInit := 12;
	<.main+5235 @0634a7> : 1c 0c 00 00 00             load.c32 12
	<.main+5240 @0634ac> : 24 98 14 06                store.m32 <@061498> ;recordMemberTest+8
	cmplStd/test/lang/init.member.ci:56: (9 bytes: <.main+5244 @0634b0> - <.main+5253 @0634b9>): recordMemberTest.constantInit := 13;
	<.main+5244 @0634b0> : 1c 0d 00 00 00             load.c32 13
	<.main+5249 @0634b5> : 24 9c 14 06                store.m32 <@06149c> ;recordMemberTest+12
	cmplStd/test/lang/init.member.ci:59: (9 bytes: <.main+5253 @0634b9> - <.main+5262 @0634c2>): recordMemberTest.memberRec.member := 14;
	<.main+5253 @0634b9> : 1c 0e 00 00 00             load.c32 14
	<.main+5258 @0634be> : 24 a0 14 06                store.m32 <@0614a0> ;recordMemberTest+16
	cmplStd/test/lang/init.member.ci:60: (9 bytes: <.main+5262 @0634c2> - <.main+5271 @0634cb>): recordMemberTest.memberRec.constant := 15;
	<.main+5262 @0634c2> : 1c 0f 00 00 00             load.c32 15
	<.main+5267 @0634c7> : 24 a4 14 06                store.m32 <@0614a4> ;recordMemberTest+20
	cmplStd/test/lang/init.member.ci:64: (9 bytes: <.main+5271 @0634cb> - <.main+5280 @0634d4>): recordMemberTest.constantRec.member := 16;
	<.main+5271 @0634cb> : 1c 10 00 00 00             load.c32 16
	<.main+5276 @0634d0> : 24 a8 14 06                store.m32 <@0614a8> ;recordMemberTest+24
	cmplStd/test/lang/init.member.ci:65: (9 bytes: <.main+5280 @0634d4> - <.main+5289 @0634dd>): recordMemberTest.constantRec.constant := 17;
	<.main+5280 @0634d4> : 1c 11 00 00 00             load.c32 17
	<.main+5285 @0634d9> : 24 ac 14 06                store.m32 <@0614ac> ;recordMemberTest+28
	cmplStd/test/lang/init.method.ci:18: (9 bytes: <.main+5289 @0634dd> - <.main+5298 @0634e6>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5289 @0634dd> : 1f 08 15 06 00             load.ref <@061508> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5294 @0634e2> : 24 d8 14 06                store.m32 <@0614d8> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	cmplStd/test/lang/init.method.ci:62: (26 bytes: <.main+5298 @0634e6> - <.main+5324 @063500>): static recordMethodTest: RecordMethodTest := {...}
	cmplStd/test/lang/init.method.ci:64: (9 bytes: <.main+5298 @0634e6> - <.main+5307 @0634ef>): recordMethodTest.abstractMethod := globalFunction;
	<.main+5298 @0634e6> : 1f 30 15 06 00             load.ref <@061530> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5303 @0634eb> : 24 58 15 06                store.m32 <@061558> ;recordMethodTest
	:: (8 bytes: <.main+5307 @0634ef> - <.main+5315 @0634f7>): recordMethodTest.delegateMethod := forwardMethod;
	<.main+5307 @0634ef> : 20 d8 14 06                load.m32 <@0614d8> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5311 @0634f3> : 24 5c 15 06                store.m32 <@06155c> ;recordMethodTest+4
	:: (9 bytes: <.main+5315 @0634f7> - <.main+5324 @063500>): recordMethodTest.virtualMethod := virtualMethod;
	<.main+5315 @0634f7> : 1f e0 14 06 00             load.ref <@0614e0> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5320 @0634fc> : 24 60 15 06                store.m32 <@061560> ;recordMethodTest+8
	cmplStd/test/lang/recUnion.ci:26: (21 bytes: <.main+5324 @063500> - <.main+5345 @063515>): static black: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5324 @063500> - <.main+5331 @063507>): black.r := (0);
	<.main+5324 @063500> : 19                         load.z32
	<.main+5325 @063501> : 1f f2 15 06 00             load.ref <@0615f2> ;black+2
	<.main+5330 @063506> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5331 @063507> - <.main+5338 @06350e>): black.g := (0);
	<.main+5331 @063507> : 19                         load.z32
	<.main+5332 @063508> : 1f f1 15 06 00             load.ref <@0615f1> ;black+1
	<.main+5337 @06350d> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5338 @06350e> - <.main+5345 @063515>): black.b := (0);
	<.main+5338 @06350e> : 19                         load.z32
	<.main+5339 @06350f> : 1f f0 15 06 00             load.ref <@0615f0> ;black
	<.main+5344 @063514> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (25 bytes: <.main+5345 @063515> - <.main+5370 @06352e>): static green: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5345 @063515> - <.main+5352 @06351c>): green.r := (0);
	<.main+5345 @063515> : 19                         load.z32
	<.main+5346 @063516> : 1f fa 15 06 00             load.ref <@0615fa> ;green+2
	<.main+5351 @06351b> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (11 bytes: <.main+5352 @06351c> - <.main+5363 @063527>): green.g := (255);
	<.main+5352 @06351c> : 1c ff 00 00 00             load.c32 255
	<.main+5357 @063521> : 1f f9 15 06 00             load.ref <@0615f9> ;green+1
	<.main+5362 @063526> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5363 @063527> - <.main+5370 @06352e>): green.b := (0);
	<.main+5363 @063527> : 19                         load.z32
	<.main+5364 @063528> : 1f f8 15 06 00             load.ref <@0615f8> ;green
	<.main+5369 @06352d> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (33 bytes: <.main+5370 @06352e> - <.main+5403 @06354f>): static white: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5370 @06352e> - <.main+5381 @063539>): white.r := (255);
	<.main+5370 @06352e> : 1c ff 00 00 00             load.c32 255
	<.main+5375 @063533> : 1f 02 16 06 00             load.ref <@061602> ;white+2
	<.main+5380 @063538> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5381 @063539> - <.main+5392 @063544>): white.g := (255);
	<.main+5381 @063539> : 1c ff 00 00 00             load.c32 255
	<.main+5386 @06353e> : 1f 01 16 06 00             load.ref <@061601> ;white+1
	<.main+5391 @063543> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5392 @063544> - <.main+5403 @06354f>): white.b := (255);
	<.main+5392 @063544> : 1c ff 00 00 00             load.c32 255
	<.main+5397 @063549> : 1f 00 16 06 00             load.ref <@061600> ;white
	<.main+5402 @06354e> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5403 @06354f> - <.main+5412 @063558>): cyan.col := (65535);
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5403 @06354f> - <.main+5412 @063558>): static cyan: color := {...}
	<.main+5403 @06354f> : 1c ff ff 00 00             load.c32 65535
	<.main+5408 @063554> : 24 08 16 06                store.m32 <@061608> ;cyan
	cmplStd/test/lang/recUnion.ci:31: (25 bytes: <.main+5412 @063558> - <.main+5437 @063571>): static blue: color := {...}
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5412 @063558> - <.main+5419 @06355f>): blue.rgb.r := (0);
	<.main+5412 @063558> : 19                         load.z32
	<.main+5413 @063559> : 1f 12 16 06 00             load.ref <@061612> ;blue+2
	<.main+5418 @06355e> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5419 @06355f> - <.main+5426 @063566>): blue.rgb.g := (0);
	<.main+5419 @06355f> : 19                         load.z32
	<.main+5420 @063560> : 1f 11 16 06 00             load.ref <@061611> ;blue+1
	<.main+5425 @063565> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (11 bytes: <.main+5426 @063566> - <.main+5437 @063571>): blue.rgb.b := (255);
	<.main+5426 @063566> : 1c ff 00 00 00             load.c32 255
	<.main+5431 @06356b> : 1f 10 16 06 00             load.ref <@061610> ;blue
	<.main+5436 @063570> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:5: (9 bytes: <.main+5437 @063571> - <.main+5446 @06357a>): static shift: int32 := 2
	<.main+5437 @063571> : 1c 02 00 00 00             load.c32 2
	<.main+5442 @063576> : 24 18 16 06                store.m32 <@061618> ;shift
	cmplStd/test/lang/useOperator.ci:7: (11 bytes: <.main+5446 @06357a> - <.main+5457 @063585>): static boolA: bool := true
	<.main+5446 @06357a> : 1c 01 00 00 00             load.c32 1
	<.main+5451 @06357f> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5456 @063584> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:8: (11 bytes: <.main+5457 @063585> - <.main+5468 @063590>): static boolB: bool := !false
	<.main+5457 @063585> : 1c 01 00 00 00             load.c32 1
	<.main+5462 @06358a> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5467 @06358f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:17: (19 bytes: <.main+5468 @063590> - <.main+5487 @0635a3>): static boolAnd: bool := boolA & boolB
	<.main+5468 @063590> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5473 @063595> : 26                         load.i8
	<.main+5474 @063596> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5479 @06359b> : 26                         load.i8
	<.main+5480 @06359c> : 31                         and.b32
	<.main+5481 @06359d> : 1f 30 16 06 00             load.ref <@061630> ;boolAnd
	<.main+5486 @0635a2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:18: (19 bytes: <.main+5487 @0635a3> - <.main+5506 @0635b6>): static boolIor: bool := boolA | boolB
	<.main+5487 @0635a3> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5492 @0635a8> : 26                         load.i8
	<.main+5493 @0635a9> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5498 @0635ae> : 26                         load.i8
	<.main+5499 @0635af> : 32                         or.b32
	<.main+5500 @0635b0> : 1f 38 16 06 00             load.ref <@061638> ;boolIor
	<.main+5505 @0635b5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:19: (19 bytes: <.main+5506 @0635b6> - <.main+5525 @0635c9>): static boolXor: bool := boolA ^ boolB
	<.main+5506 @0635b6> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5511 @0635bb> : 26                         load.i8
	<.main+5512 @0635bc> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5517 @0635c1> : 26                         load.i8
	<.main+5518 @0635c2> : 36                         xor.b32
	<.main+5519 @0635c3> : 1f 40 16 06 00             load.ref <@061640> ;boolXor
	<.main+5524 @0635c8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:22: (13 bytes: <.main+5525 @0635c9> - <.main+5538 @0635d6>): static boolNot: bool := !boolB
	<.main+5525 @0635c9> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5530 @0635ce> : 26                         load.i8
	<.main+5531 @0635cf> : 0b                         not.b32
	<.main+5532 @0635d0> : 1f 48 16 06 00             load.ref <@061648> ;boolNot
	<.main+5537 @0635d5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:23: (19 bytes: <.main+5538 @0635d6> - <.main+5557 @0635e9>): static boolCeq: bool := boolA == boolB
	<.main+5538 @0635d6> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5543 @0635db> : 26                         load.i8
	<.main+5544 @0635dc> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5549 @0635e1> : 26                         load.i8
	<.main+5550 @0635e2> : 57                         ceq.i32
	<.main+5551 @0635e3> : 1f 50 16 06 00             load.ref <@061650> ;boolCeq
	<.main+5556 @0635e8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:24: (20 bytes: <.main+5557 @0635e9> - <.main+5577 @0635fd>): static boolCne: bool := boolA != boolB
	<.main+5557 @0635e9> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5562 @0635ee> : 26                         load.i8
	<.main+5563 @0635ef> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5568 @0635f4> : 26                         load.i8
	<.main+5569 @0635f5> : 57                         ceq.i32
	<.main+5570 @0635f6> : 0b                         not.b32
	<.main+5571 @0635f7> : 1f 58 16 06 00             load.ref <@061658> ;boolCne
	<.main+5576 @0635fc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:25: (19 bytes: <.main+5577 @0635fd> - <.main+5596 @063610>): static boolClt: bool := boolA < boolB
	<.main+5577 @0635fd> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5582 @063602> : 26                         load.i8
	<.main+5583 @063603> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5588 @063608> : 26                         load.i8
	<.main+5589 @063609> : 58                         clt.i32
	<.main+5590 @06360a> : 1f 60 16 06 00             load.ref <@061660> ;boolClt
	<.main+5595 @06360f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:26: (20 bytes: <.main+5596 @063610> - <.main+5616 @063624>): static boolCle: bool := boolA <= boolB
	<.main+5596 @063610> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5601 @063615> : 26                         load.i8
	<.main+5602 @063616> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5607 @06361b> : 26                         load.i8
	<.main+5608 @06361c> : 59                         cgt.i32
	<.main+5609 @06361d> : 0b                         not.b32
	<.main+5610 @06361e> : 1f 68 16 06 00             load.ref <@061668> ;boolCle
	<.main+5615 @063623> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:27: (19 bytes: <.main+5616 @063624> - <.main+5635 @063637>): static boolCgt: bool := boolA > boolB
	<.main+5616 @063624> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5621 @063629> : 26                         load.i8
	<.main+5622 @06362a> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5627 @06362f> : 26                         load.i8
	<.main+5628 @063630> : 59                         cgt.i32
	<.main+5629 @063631> : 1f 70 16 06 00             load.ref <@061670> ;boolCgt
	<.main+5634 @063636> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:28: (20 bytes: <.main+5635 @063637> - <.main+5655 @06364b>): static boolCge: bool := boolA >= boolB
	<.main+5635 @063637> : 1f 20 16 06 00             load.ref <@061620> ;boolA
	<.main+5640 @06363c> : 26                         load.i8
	<.main+5641 @06363d> : 1f 28 16 06 00             load.ref <@061628> ;boolB
	<.main+5646 @063642> : 26                         load.i8
	<.main+5647 @063643> : 58                         clt.i32
	<.main+5648 @063644> : 0b                         not.b32
	<.main+5649 @063645> : 1f 78 16 06 00             load.ref <@061678> ;boolCge
	<.main+5654 @06364a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:30: (11 bytes: <.main+5655 @06364b> - <.main+5666 @063656>): static chrA: char := 'a'
	<.main+5655 @06364b> : 1c 61 00 00 00             load.c32 97
	<.main+5660 @063650> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5665 @063655> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:31: (11 bytes: <.main+5666 @063656> - <.main+5677 @063661>): static chrB: char := 'b'
	<.main+5666 @063656> : 1c 62 00 00 00             load.c32 98
	<.main+5671 @06365b> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5676 @063660> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:32: (12 bytes: <.main+5677 @063661> - <.main+5689 @06366d>): static chrPls: char := +chrB
	<.main+5677 @063661> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5682 @063666> : 26                         load.i8
	<.main+5683 @063667> : 1f 90 16 06 00             load.ref <@061690> ;chrPls
	<.main+5688 @06366c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:33: (13 bytes: <.main+5689 @06366d> - <.main+5702 @06367a>): static chrNeg: char := -chrB
	<.main+5689 @06366d> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5694 @063672> : 26                         load.i8
	<.main+5695 @063673> : 50                         neg.i32
	<.main+5696 @063674> : 1f 98 16 06 00             load.ref <@061698> ;chrNeg
	<.main+5701 @063679> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:34: (13 bytes: <.main+5702 @06367a> - <.main+5715 @063687>): static chrCmt: char := ~chrB
	<.main+5702 @06367a> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5707 @06367f> : 26                         load.i8
	<.main+5708 @063680> : 30                         cmt.b32
	<.main+5709 @063681> : 1f a0 16 06 00             load.ref <@0616a0> ;chrCmt
	<.main+5714 @063686> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:35: (19 bytes: <.main+5715 @063687> - <.main+5734 @06369a>): static chrAdd: char := chrA + chrB
	<.main+5715 @063687> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5720 @06368c> : 26                         load.i8
	<.main+5721 @06368d> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5726 @063692> : 26                         load.i8
	<.main+5727 @063693> : 51                         add.i32
	<.main+5728 @063694> : 1f a8 16 06 00             load.ref <@0616a8> ;chrAdd
	<.main+5733 @063699> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:36: (19 bytes: <.main+5734 @06369a> - <.main+5753 @0636ad>): static chrSub: char := chrA - chrB
	<.main+5734 @06369a> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5739 @06369f> : 26                         load.i8
	<.main+5740 @0636a0> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5745 @0636a5> : 26                         load.i8
	<.main+5746 @0636a6> : 52                         sub.i32
	<.main+5747 @0636a7> : 1f b0 16 06 00             load.ref <@0616b0> ;chrSub
	<.main+5752 @0636ac> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:37: (19 bytes: <.main+5753 @0636ad> - <.main+5772 @0636c0>): static chrMul: char := chrA * chrB
	<.main+5753 @0636ad> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5758 @0636b2> : 26                         load.i8
	<.main+5759 @0636b3> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5764 @0636b8> : 26                         load.i8
	<.main+5765 @0636b9> : 53                         mul.i32
	<.main+5766 @0636ba> : 1f b8 16 06 00             load.ref <@0616b8> ;chrMul
	<.main+5771 @0636bf> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:38: (19 bytes: <.main+5772 @0636c0> - <.main+5791 @0636d3>): static chrDiv: char := chrA / chrB
	<.main+5772 @0636c0> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5777 @0636c5> : 26                         load.i8
	<.main+5778 @0636c6> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5783 @0636cb> : 26                         load.i8
	<.main+5784 @0636cc> : 54                         div.i32
	<.main+5785 @0636cd> : 1f c0 16 06 00             load.ref <@0616c0> ;chrDiv
	<.main+5790 @0636d2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:39: (19 bytes: <.main+5791 @0636d3> - <.main+5810 @0636e6>): static chrMod: char := chrA % chrB
	<.main+5791 @0636d3> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5796 @0636d8> : 26                         load.i8
	<.main+5797 @0636d9> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5802 @0636de> : 26                         load.i8
	<.main+5803 @0636df> : 55                         mod.i32
	<.main+5804 @0636e0> : 1f c8 16 06 00             load.ref <@0616c8> ;chrMod
	<.main+5809 @0636e5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:40: (19 bytes: <.main+5810 @0636e6> - <.main+5829 @0636f9>): static chrAnd: char := chrA & chrB
	<.main+5810 @0636e6> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5815 @0636eb> : 26                         load.i8
	<.main+5816 @0636ec> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5821 @0636f1> : 26                         load.i8
	<.main+5822 @0636f2> : 31                         and.b32
	<.main+5823 @0636f3> : 1f d0 16 06 00             load.ref <@0616d0> ;chrAnd
	<.main+5828 @0636f8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:41: (19 bytes: <.main+5829 @0636f9> - <.main+5848 @06370c>): static chrIor: char := chrA | chrB
	<.main+5829 @0636f9> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5834 @0636fe> : 26                         load.i8
	<.main+5835 @0636ff> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5840 @063704> : 26                         load.i8
	<.main+5841 @063705> : 32                         or.b32
	<.main+5842 @063706> : 1f d8 16 06 00             load.ref <@0616d8> ;chrIor
	<.main+5847 @06370b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:42: (19 bytes: <.main+5848 @06370c> - <.main+5867 @06371f>): static chrXor: char := chrA ^ chrB
	<.main+5848 @06370c> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5853 @063711> : 26                         load.i8
	<.main+5854 @063712> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5859 @063717> : 26                         load.i8
	<.main+5860 @063718> : 36                         xor.b32
	<.main+5861 @063719> : 1f e0 16 06 00             load.ref <@0616e0> ;chrXor
	<.main+5866 @06371e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:43: (17 bytes: <.main+5867 @06371f> - <.main+5884 @063730>): static chrShl: char := (chrA) << shift
	<.main+5867 @06371f> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5872 @063724> : 26                         load.i8
	<.main+5873 @063725> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+5877 @063729> : 3a                         shl.b32
	<.main+5878 @06372a> : 1f e8 16 06 00             load.ref <@0616e8> ;chrShl
	<.main+5883 @06372f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:44: (17 bytes: <.main+5884 @063730> - <.main+5901 @063741>): static chrShr: char := (chrA) >> shift
	<.main+5884 @063730> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5889 @063735> : 26                         load.i8
	<.main+5890 @063736> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+5894 @06373a> : 3c                         sar.b32
	<.main+5895 @06373b> : 1f f0 16 06 00             load.ref <@0616f0> ;chrShr
	<.main+5900 @063740> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:45: (14 bytes: <.main+5901 @063741> - <.main+5915 @06374f>): static chrNot: bool := !(chrB)
	<.main+5901 @063741> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5906 @063746> : 26                         load.i8
	<.main+5907 @063747> : 5a                         i32.2bool
	<.main+5908 @063748> : 0b                         not.b32
	<.main+5909 @063749> : 1f f8 16 06 00             load.ref <@0616f8> ;chrNot
	<.main+5914 @06374e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:46: (19 bytes: <.main+5915 @06374f> - <.main+5934 @063762>): static chrCeq: bool := chrA == chrB
	<.main+5915 @06374f> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5920 @063754> : 26                         load.i8
	<.main+5921 @063755> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5926 @06375a> : 26                         load.i8
	<.main+5927 @06375b> : 57                         ceq.i32
	<.main+5928 @06375c> : 1f 00 17 06 00             load.ref <@061700> ;chrCeq
	<.main+5933 @063761> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:47: (20 bytes: <.main+5934 @063762> - <.main+5954 @063776>): static chrCne: bool := chrA != chrB
	<.main+5934 @063762> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5939 @063767> : 26                         load.i8
	<.main+5940 @063768> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5945 @06376d> : 26                         load.i8
	<.main+5946 @06376e> : 57                         ceq.i32
	<.main+5947 @06376f> : 0b                         not.b32
	<.main+5948 @063770> : 1f 08 17 06 00             load.ref <@061708> ;chrCne
	<.main+5953 @063775> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:48: (19 bytes: <.main+5954 @063776> - <.main+5973 @063789>): static chrClt: bool := chrA < chrB
	<.main+5954 @063776> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5959 @06377b> : 26                         load.i8
	<.main+5960 @06377c> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5965 @063781> : 26                         load.i8
	<.main+5966 @063782> : 58                         clt.i32
	<.main+5967 @063783> : 1f 10 17 06 00             load.ref <@061710> ;chrClt
	<.main+5972 @063788> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:49: (20 bytes: <.main+5973 @063789> - <.main+5993 @06379d>): static chrCle: bool := chrA <= chrB
	<.main+5973 @063789> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5978 @06378e> : 26                         load.i8
	<.main+5979 @06378f> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+5984 @063794> : 26                         load.i8
	<.main+5985 @063795> : 59                         cgt.i32
	<.main+5986 @063796> : 0b                         not.b32
	<.main+5987 @063797> : 1f 18 17 06 00             load.ref <@061718> ;chrCle
	<.main+5992 @06379c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:50: (19 bytes: <.main+5993 @06379d> - <.main+6012 @0637b0>): static chrCgt: bool := chrA > chrB
	<.main+5993 @06379d> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+5998 @0637a2> : 26                         load.i8
	<.main+5999 @0637a3> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+6004 @0637a8> : 26                         load.i8
	<.main+6005 @0637a9> : 59                         cgt.i32
	<.main+6006 @0637aa> : 1f 20 17 06 00             load.ref <@061720> ;chrCgt
	<.main+6011 @0637af> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:51: (20 bytes: <.main+6012 @0637b0> - <.main+6032 @0637c4>): static chrCge: bool := chrA >= chrB
	<.main+6012 @0637b0> : 1f 80 16 06 00             load.ref <@061680> ;chrA
	<.main+6017 @0637b5> : 26                         load.i8
	<.main+6018 @0637b6> : 1f 88 16 06 00             load.ref <@061688> ;chrB
	<.main+6023 @0637bb> : 26                         load.i8
	<.main+6024 @0637bc> : 58                         clt.i32
	<.main+6025 @0637bd> : 0b                         not.b32
	<.main+6026 @0637be> : 1f 28 17 06 00             load.ref <@061728> ;chrCge
	<.main+6031 @0637c3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:53: (11 bytes: <.main+6032 @0637c4> - <.main+6043 @0637cf>): static i8A: int8 := a
	<.main+6032 @0637c4> : 1c 60 00 00 00             load.c32 96
	<.main+6037 @0637c9> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6042 @0637ce> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:54: (11 bytes: <.main+6043 @0637cf> - <.main+6054 @0637da>): static i8B: int8 := b
	<.main+6043 @0637cf> : 1c 2a 00 00 00             load.c32 42
	<.main+6048 @0637d4> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6053 @0637d9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:55: (12 bytes: <.main+6054 @0637da> - <.main+6066 @0637e6>): static i8Pls: int8 := +i8B
	<.main+6054 @0637da> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6059 @0637df> : 26                         load.i8
	<.main+6060 @0637e0> : 1f 40 17 06 00             load.ref <@061740> ;i8Pls
	<.main+6065 @0637e5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:56: (13 bytes: <.main+6066 @0637e6> - <.main+6079 @0637f3>): static i8Neg: int8 := -i8B
	<.main+6066 @0637e6> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6071 @0637eb> : 26                         load.i8
	<.main+6072 @0637ec> : 50                         neg.i32
	<.main+6073 @0637ed> : 1f 48 17 06 00             load.ref <@061748> ;i8Neg
	<.main+6078 @0637f2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:57: (13 bytes: <.main+6079 @0637f3> - <.main+6092 @063800>): static i8Cmt: int8 := ~i8B
	<.main+6079 @0637f3> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6084 @0637f8> : 26                         load.i8
	<.main+6085 @0637f9> : 30                         cmt.b32
	<.main+6086 @0637fa> : 1f 50 17 06 00             load.ref <@061750> ;i8Cmt
	<.main+6091 @0637ff> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:58: (19 bytes: <.main+6092 @063800> - <.main+6111 @063813>): static i8Add: int8 := i8A + i8B
	<.main+6092 @063800> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6097 @063805> : 26                         load.i8
	<.main+6098 @063806> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6103 @06380b> : 26                         load.i8
	<.main+6104 @06380c> : 51                         add.i32
	<.main+6105 @06380d> : 1f 58 17 06 00             load.ref <@061758> ;i8Add
	<.main+6110 @063812> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:59: (19 bytes: <.main+6111 @063813> - <.main+6130 @063826>): static i8Sub: int8 := i8A - i8B
	<.main+6111 @063813> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6116 @063818> : 26                         load.i8
	<.main+6117 @063819> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6122 @06381e> : 26                         load.i8
	<.main+6123 @06381f> : 52                         sub.i32
	<.main+6124 @063820> : 1f 60 17 06 00             load.ref <@061760> ;i8Sub
	<.main+6129 @063825> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:60: (19 bytes: <.main+6130 @063826> - <.main+6149 @063839>): static i8Mul: int8 := i8A * i8B
	<.main+6130 @063826> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6135 @06382b> : 26                         load.i8
	<.main+6136 @06382c> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6141 @063831> : 26                         load.i8
	<.main+6142 @063832> : 53                         mul.i32
	<.main+6143 @063833> : 1f 68 17 06 00             load.ref <@061768> ;i8Mul
	<.main+6148 @063838> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:61: (19 bytes: <.main+6149 @063839> - <.main+6168 @06384c>): static i8Div: int8 := i8A / i8B
	<.main+6149 @063839> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6154 @06383e> : 26                         load.i8
	<.main+6155 @06383f> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6160 @063844> : 26                         load.i8
	<.main+6161 @063845> : 54                         div.i32
	<.main+6162 @063846> : 1f 70 17 06 00             load.ref <@061770> ;i8Div
	<.main+6167 @06384b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:62: (19 bytes: <.main+6168 @06384c> - <.main+6187 @06385f>): static i8Mod: int8 := i8A % i8B
	<.main+6168 @06384c> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6173 @063851> : 26                         load.i8
	<.main+6174 @063852> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6179 @063857> : 26                         load.i8
	<.main+6180 @063858> : 55                         mod.i32
	<.main+6181 @063859> : 1f 78 17 06 00             load.ref <@061778> ;i8Mod
	<.main+6186 @06385e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:63: (19 bytes: <.main+6187 @06385f> - <.main+6206 @063872>): static i8And: int8 := i8A & i8B
	<.main+6187 @06385f> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6192 @063864> : 26                         load.i8
	<.main+6193 @063865> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6198 @06386a> : 26                         load.i8
	<.main+6199 @06386b> : 31                         and.b32
	<.main+6200 @06386c> : 1f 80 17 06 00             load.ref <@061780> ;i8And
	<.main+6205 @063871> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:64: (19 bytes: <.main+6206 @063872> - <.main+6225 @063885>): static i8Ior: int8 := i8A | i8B
	<.main+6206 @063872> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6211 @063877> : 26                         load.i8
	<.main+6212 @063878> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6217 @06387d> : 26                         load.i8
	<.main+6218 @06387e> : 32                         or.b32
	<.main+6219 @06387f> : 1f 88 17 06 00             load.ref <@061788> ;i8Ior
	<.main+6224 @063884> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:65: (19 bytes: <.main+6225 @063885> - <.main+6244 @063898>): static i8Xor: int8 := i8A ^ i8B
	<.main+6225 @063885> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6230 @06388a> : 26                         load.i8
	<.main+6231 @06388b> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6236 @063890> : 26                         load.i8
	<.main+6237 @063891> : 36                         xor.b32
	<.main+6238 @063892> : 1f 90 17 06 00             load.ref <@061790> ;i8Xor
	<.main+6243 @063897> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:66: (17 bytes: <.main+6244 @063898> - <.main+6261 @0638a9>): static i8Shl: int8 := (i8A) << shift
	<.main+6244 @063898> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6249 @06389d> : 26                         load.i8
	<.main+6250 @06389e> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+6254 @0638a2> : 3a                         shl.b32
	<.main+6255 @0638a3> : 1f 98 17 06 00             load.ref <@061798> ;i8Shl
	<.main+6260 @0638a8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:67: (17 bytes: <.main+6261 @0638a9> - <.main+6278 @0638ba>): static i8Shr: int8 := (i8A) >> shift
	<.main+6261 @0638a9> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6266 @0638ae> : 26                         load.i8
	<.main+6267 @0638af> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+6271 @0638b3> : 3c                         sar.b32
	<.main+6272 @0638b4> : 1f a0 17 06 00             load.ref <@0617a0> ;i8Shr
	<.main+6277 @0638b9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:68: (14 bytes: <.main+6278 @0638ba> - <.main+6292 @0638c8>): static i8Not: bool := !(i8B)
	<.main+6278 @0638ba> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6283 @0638bf> : 26                         load.i8
	<.main+6284 @0638c0> : 5a                         i32.2bool
	<.main+6285 @0638c1> : 0b                         not.b32
	<.main+6286 @0638c2> : 1f a8 17 06 00             load.ref <@0617a8> ;i8Not
	<.main+6291 @0638c7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:69: (19 bytes: <.main+6292 @0638c8> - <.main+6311 @0638db>): static i8Ceq: bool := i8A == i8B
	<.main+6292 @0638c8> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6297 @0638cd> : 26                         load.i8
	<.main+6298 @0638ce> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6303 @0638d3> : 26                         load.i8
	<.main+6304 @0638d4> : 57                         ceq.i32
	<.main+6305 @0638d5> : 1f b0 17 06 00             load.ref <@0617b0> ;i8Ceq
	<.main+6310 @0638da> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:70: (20 bytes: <.main+6311 @0638db> - <.main+6331 @0638ef>): static i8Cne: bool := i8A != i8B
	<.main+6311 @0638db> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6316 @0638e0> : 26                         load.i8
	<.main+6317 @0638e1> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6322 @0638e6> : 26                         load.i8
	<.main+6323 @0638e7> : 57                         ceq.i32
	<.main+6324 @0638e8> : 0b                         not.b32
	<.main+6325 @0638e9> : 1f b8 17 06 00             load.ref <@0617b8> ;i8Cne
	<.main+6330 @0638ee> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:71: (19 bytes: <.main+6331 @0638ef> - <.main+6350 @063902>): static i8Clt: bool := i8A < i8B
	<.main+6331 @0638ef> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6336 @0638f4> : 26                         load.i8
	<.main+6337 @0638f5> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6342 @0638fa> : 26                         load.i8
	<.main+6343 @0638fb> : 58                         clt.i32
	<.main+6344 @0638fc> : 1f c0 17 06 00             load.ref <@0617c0> ;i8Clt
	<.main+6349 @063901> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:72: (20 bytes: <.main+6350 @063902> - <.main+6370 @063916>): static i8Cle: bool := i8A <= i8B
	<.main+6350 @063902> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6355 @063907> : 26                         load.i8
	<.main+6356 @063908> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6361 @06390d> : 26                         load.i8
	<.main+6362 @06390e> : 59                         cgt.i32
	<.main+6363 @06390f> : 0b                         not.b32
	<.main+6364 @063910> : 1f c8 17 06 00             load.ref <@0617c8> ;i8Cle
	<.main+6369 @063915> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:73: (19 bytes: <.main+6370 @063916> - <.main+6389 @063929>): static i8Cgt: bool := i8A > i8B
	<.main+6370 @063916> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6375 @06391b> : 26                         load.i8
	<.main+6376 @06391c> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6381 @063921> : 26                         load.i8
	<.main+6382 @063922> : 59                         cgt.i32
	<.main+6383 @063923> : 1f d0 17 06 00             load.ref <@0617d0> ;i8Cgt
	<.main+6388 @063928> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:74: (20 bytes: <.main+6389 @063929> - <.main+6409 @06393d>): static i8Cge: bool := i8A >= i8B
	<.main+6389 @063929> : 1f 30 17 06 00             load.ref <@061730> ;i8A
	<.main+6394 @06392e> : 26                         load.i8
	<.main+6395 @06392f> : 1f 38 17 06 00             load.ref <@061738> ;i8B
	<.main+6400 @063934> : 26                         load.i8
	<.main+6401 @063935> : 58                         clt.i32
	<.main+6402 @063936> : 0b                         not.b32
	<.main+6403 @063937> : 1f d8 17 06 00             load.ref <@0617d8> ;i8Cge
	<.main+6408 @06393c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:76: (11 bytes: <.main+6409 @06393d> - <.main+6420 @063948>): static u8A: uint8 := a
	<.main+6409 @06393d> : 1c 60 00 00 00             load.c32 96
	<.main+6414 @063942> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6419 @063947> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:77: (11 bytes: <.main+6420 @063948> - <.main+6431 @063953>): static u8B: uint8 := b
	<.main+6420 @063948> : 1c 2a 00 00 00             load.c32 42
	<.main+6425 @06394d> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6430 @063952> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:78: (12 bytes: <.main+6431 @063953> - <.main+6443 @06395f>): static u8Pls: uint8 := +u8B
	<.main+6431 @063953> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6436 @063958> : 26                         load.i8
	<.main+6437 @063959> : 1f f0 17 06 00             load.ref <@0617f0> ;u8Pls
	<.main+6442 @06395e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:79: (13 bytes: <.main+6443 @06395f> - <.main+6456 @06396c>): static u8Neg: uint8 := -u8B
	<.main+6443 @06395f> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6448 @063964> : 26                         load.i8
	<.main+6449 @063965> : 50                         neg.i32
	<.main+6450 @063966> : 1f f8 17 06 00             load.ref <@0617f8> ;u8Neg
	<.main+6455 @06396b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:80: (13 bytes: <.main+6456 @06396c> - <.main+6469 @063979>): static u8Cmt: uint8 := ~u8B
	<.main+6456 @06396c> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6461 @063971> : 26                         load.i8
	<.main+6462 @063972> : 30                         cmt.b32
	<.main+6463 @063973> : 1f 00 18 06 00             load.ref <@061800> ;u8Cmt
	<.main+6468 @063978> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:81: (19 bytes: <.main+6469 @063979> - <.main+6488 @06398c>): static u8Add: uint8 := u8A + u8B
	<.main+6469 @063979> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6474 @06397e> : 26                         load.i8
	<.main+6475 @06397f> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6480 @063984> : 26                         load.i8
	<.main+6481 @063985> : 51                         add.i32
	<.main+6482 @063986> : 1f 08 18 06 00             load.ref <@061808> ;u8Add
	<.main+6487 @06398b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:82: (19 bytes: <.main+6488 @06398c> - <.main+6507 @06399f>): static u8Sub: uint8 := u8A - u8B
	<.main+6488 @06398c> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6493 @063991> : 26                         load.i8
	<.main+6494 @063992> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6499 @063997> : 26                         load.i8
	<.main+6500 @063998> : 52                         sub.i32
	<.main+6501 @063999> : 1f 10 18 06 00             load.ref <@061810> ;u8Sub
	<.main+6506 @06399e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:83: (19 bytes: <.main+6507 @06399f> - <.main+6526 @0639b2>): static u8Mul: uint8 := u8A * u8B
	<.main+6507 @06399f> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6512 @0639a4> : 26                         load.i8
	<.main+6513 @0639a5> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6518 @0639aa> : 26                         load.i8
	<.main+6519 @0639ab> : 33                         mul.u32
	<.main+6520 @0639ac> : 1f 18 18 06 00             load.ref <@061818> ;u8Mul
	<.main+6525 @0639b1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:84: (19 bytes: <.main+6526 @0639b2> - <.main+6545 @0639c5>): static u8Div: uint8 := u8A / u8B
	<.main+6526 @0639b2> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6531 @0639b7> : 26                         load.i8
	<.main+6532 @0639b8> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6537 @0639bd> : 26                         load.i8
	<.main+6538 @0639be> : 34                         div.u32
	<.main+6539 @0639bf> : 1f 20 18 06 00             load.ref <@061820> ;u8Div
	<.main+6544 @0639c4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:85: (19 bytes: <.main+6545 @0639c5> - <.main+6564 @0639d8>): static u8Mod: uint8 := u8A % u8B
	<.main+6545 @0639c5> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6550 @0639ca> : 26                         load.i8
	<.main+6551 @0639cb> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6556 @0639d0> : 26                         load.i8
	<.main+6557 @0639d1> : 35                         mod.u32
	<.main+6558 @0639d2> : 1f 28 18 06 00             load.ref <@061828> ;u8Mod
	<.main+6563 @0639d7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:86: (19 bytes: <.main+6564 @0639d8> - <.main+6583 @0639eb>): static u8And: uint8 := u8A & u8B
	<.main+6564 @0639d8> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6569 @0639dd> : 26                         load.i8
	<.main+6570 @0639de> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6575 @0639e3> : 26                         load.i8
	<.main+6576 @0639e4> : 31                         and.b32
	<.main+6577 @0639e5> : 1f 30 18 06 00             load.ref <@061830> ;u8And
	<.main+6582 @0639ea> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:87: (19 bytes: <.main+6583 @0639eb> - <.main+6602 @0639fe>): static u8Ior: uint8 := u8A | u8B
	<.main+6583 @0639eb> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6588 @0639f0> : 26                         load.i8
	<.main+6589 @0639f1> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6594 @0639f6> : 26                         load.i8
	<.main+6595 @0639f7> : 32                         or.b32
	<.main+6596 @0639f8> : 1f 38 18 06 00             load.ref <@061838> ;u8Ior
	<.main+6601 @0639fd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:88: (19 bytes: <.main+6602 @0639fe> - <.main+6621 @063a11>): static u8Xor: uint8 := u8A ^ u8B
	<.main+6602 @0639fe> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6607 @063a03> : 26                         load.i8
	<.main+6608 @063a04> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6613 @063a09> : 26                         load.i8
	<.main+6614 @063a0a> : 36                         xor.b32
	<.main+6615 @063a0b> : 1f 40 18 06 00             load.ref <@061840> ;u8Xor
	<.main+6620 @063a10> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:89: (17 bytes: <.main+6621 @063a11> - <.main+6638 @063a22>): static u8Shl: uint8 := (u8A) << shift
	<.main+6621 @063a11> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6626 @063a16> : 26                         load.i8
	<.main+6627 @063a17> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+6631 @063a1b> : 3a                         shl.b32
	<.main+6632 @063a1c> : 1f 48 18 06 00             load.ref <@061848> ;u8Shl
	<.main+6637 @063a21> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:90: (17 bytes: <.main+6638 @063a22> - <.main+6655 @063a33>): static u8Shr: uint8 := (u8A) >> shift
	<.main+6638 @063a22> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6643 @063a27> : 26                         load.i8
	<.main+6644 @063a28> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+6648 @063a2c> : 3c                         sar.b32
	<.main+6649 @063a2d> : 1f 50 18 06 00             load.ref <@061850> ;u8Shr
	<.main+6654 @063a32> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:91: (14 bytes: <.main+6655 @063a33> - <.main+6669 @063a41>): static u8Not: bool := !(u8B)
	<.main+6655 @063a33> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6660 @063a38> : 26                         load.i8
	<.main+6661 @063a39> : 5a                         i32.2bool
	<.main+6662 @063a3a> : 0b                         not.b32
	<.main+6663 @063a3b> : 1f 58 18 06 00             load.ref <@061858> ;u8Not
	<.main+6668 @063a40> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:92: (19 bytes: <.main+6669 @063a41> - <.main+6688 @063a54>): static u8Ceq: bool := u8A == u8B
	<.main+6669 @063a41> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6674 @063a46> : 26                         load.i8
	<.main+6675 @063a47> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6680 @063a4c> : 26                         load.i8
	<.main+6681 @063a4d> : 57                         ceq.i32
	<.main+6682 @063a4e> : 1f 60 18 06 00             load.ref <@061860> ;u8Ceq
	<.main+6687 @063a53> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:93: (20 bytes: <.main+6688 @063a54> - <.main+6708 @063a68>): static u8Cne: bool := u8A != u8B
	<.main+6688 @063a54> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6693 @063a59> : 26                         load.i8
	<.main+6694 @063a5a> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6699 @063a5f> : 26                         load.i8
	<.main+6700 @063a60> : 57                         ceq.i32
	<.main+6701 @063a61> : 0b                         not.b32
	<.main+6702 @063a62> : 1f 68 18 06 00             load.ref <@061868> ;u8Cne
	<.main+6707 @063a67> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:94: (19 bytes: <.main+6708 @063a68> - <.main+6727 @063a7b>): static u8Clt: bool := u8A < u8B
	<.main+6708 @063a68> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6713 @063a6d> : 26                         load.i8
	<.main+6714 @063a6e> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6719 @063a73> : 26                         load.i8
	<.main+6720 @063a74> : 38                         clt.u32
	<.main+6721 @063a75> : 1f 70 18 06 00             load.ref <@061870> ;u8Clt
	<.main+6726 @063a7a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:95: (20 bytes: <.main+6727 @063a7b> - <.main+6747 @063a8f>): static u8Cle: bool := u8A <= u8B
	<.main+6727 @063a7b> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6732 @063a80> : 26                         load.i8
	<.main+6733 @063a81> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6738 @063a86> : 26                         load.i8
	<.main+6739 @063a87> : 39                         cgt.u32
	<.main+6740 @063a88> : 0b                         not.b32
	<.main+6741 @063a89> : 1f 78 18 06 00             load.ref <@061878> ;u8Cle
	<.main+6746 @063a8e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:96: (19 bytes: <.main+6747 @063a8f> - <.main+6766 @063aa2>): static u8Cgt: bool := u8A > u8B
	<.main+6747 @063a8f> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6752 @063a94> : 26                         load.i8
	<.main+6753 @063a95> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6758 @063a9a> : 26                         load.i8
	<.main+6759 @063a9b> : 39                         cgt.u32
	<.main+6760 @063a9c> : 1f 80 18 06 00             load.ref <@061880> ;u8Cgt
	<.main+6765 @063aa1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:97: (20 bytes: <.main+6766 @063aa2> - <.main+6786 @063ab6>): static u8Cge: bool := u8A >= u8B
	<.main+6766 @063aa2> : 1f e0 17 06 00             load.ref <@0617e0> ;u8A
	<.main+6771 @063aa7> : 26                         load.i8
	<.main+6772 @063aa8> : 1f e8 17 06 00             load.ref <@0617e8> ;u8B
	<.main+6777 @063aad> : 26                         load.i8
	<.main+6778 @063aae> : 38                         clt.u32
	<.main+6779 @063aaf> : 0b                         not.b32
	<.main+6780 @063ab0> : 1f 88 18 06 00             load.ref <@061888> ;u8Cge
	<.main+6785 @063ab5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:99: (11 bytes: <.main+6786 @063ab6> - <.main+6797 @063ac1>): static i16A: int16 := a
	<.main+6786 @063ab6> : 1c 60 00 00 00             load.c32 96
	<.main+6791 @063abb> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6796 @063ac0> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:100: (11 bytes: <.main+6797 @063ac1> - <.main+6808 @063acc>): static i16B: int16 := b
	<.main+6797 @063ac1> : 1c 2a 00 00 00             load.c32 42
	<.main+6802 @063ac6> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6807 @063acb> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:101: (12 bytes: <.main+6808 @063acc> - <.main+6820 @063ad8>): static i16Pls: int16 := +i16B
	<.main+6808 @063acc> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6813 @063ad1> : 27                         load.i16
	<.main+6814 @063ad2> : 1f a0 18 06 00             load.ref <@0618a0> ;i16Pls
	<.main+6819 @063ad7> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:102: (13 bytes: <.main+6820 @063ad8> - <.main+6833 @063ae5>): static i16Neg: int16 := -i16B
	<.main+6820 @063ad8> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6825 @063add> : 27                         load.i16
	<.main+6826 @063ade> : 50                         neg.i32
	<.main+6827 @063adf> : 1f a8 18 06 00             load.ref <@0618a8> ;i16Neg
	<.main+6832 @063ae4> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:103: (13 bytes: <.main+6833 @063ae5> - <.main+6846 @063af2>): static i16Cmt: int16 := ~i16B
	<.main+6833 @063ae5> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6838 @063aea> : 27                         load.i16
	<.main+6839 @063aeb> : 30                         cmt.b32
	<.main+6840 @063aec> : 1f b0 18 06 00             load.ref <@0618b0> ;i16Cmt
	<.main+6845 @063af1> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:104: (19 bytes: <.main+6846 @063af2> - <.main+6865 @063b05>): static i16Add: int16 := i16A + i16B
	<.main+6846 @063af2> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6851 @063af7> : 27                         load.i16
	<.main+6852 @063af8> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6857 @063afd> : 27                         load.i16
	<.main+6858 @063afe> : 51                         add.i32
	<.main+6859 @063aff> : 1f b8 18 06 00             load.ref <@0618b8> ;i16Add
	<.main+6864 @063b04> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:105: (19 bytes: <.main+6865 @063b05> - <.main+6884 @063b18>): static i16Sub: int16 := i16A - i16B
	<.main+6865 @063b05> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6870 @063b0a> : 27                         load.i16
	<.main+6871 @063b0b> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6876 @063b10> : 27                         load.i16
	<.main+6877 @063b11> : 52                         sub.i32
	<.main+6878 @063b12> : 1f c0 18 06 00             load.ref <@0618c0> ;i16Sub
	<.main+6883 @063b17> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:106: (19 bytes: <.main+6884 @063b18> - <.main+6903 @063b2b>): static i16Mul: int16 := i16A * i16B
	<.main+6884 @063b18> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6889 @063b1d> : 27                         load.i16
	<.main+6890 @063b1e> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6895 @063b23> : 27                         load.i16
	<.main+6896 @063b24> : 53                         mul.i32
	<.main+6897 @063b25> : 1f c8 18 06 00             load.ref <@0618c8> ;i16Mul
	<.main+6902 @063b2a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:107: (19 bytes: <.main+6903 @063b2b> - <.main+6922 @063b3e>): static i16Div: int16 := i16A / i16B
	<.main+6903 @063b2b> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6908 @063b30> : 27                         load.i16
	<.main+6909 @063b31> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6914 @063b36> : 27                         load.i16
	<.main+6915 @063b37> : 54                         div.i32
	<.main+6916 @063b38> : 1f d0 18 06 00             load.ref <@0618d0> ;i16Div
	<.main+6921 @063b3d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:108: (19 bytes: <.main+6922 @063b3e> - <.main+6941 @063b51>): static i16Mod: int16 := i16A % i16B
	<.main+6922 @063b3e> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6927 @063b43> : 27                         load.i16
	<.main+6928 @063b44> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6933 @063b49> : 27                         load.i16
	<.main+6934 @063b4a> : 55                         mod.i32
	<.main+6935 @063b4b> : 1f d8 18 06 00             load.ref <@0618d8> ;i16Mod
	<.main+6940 @063b50> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:109: (19 bytes: <.main+6941 @063b51> - <.main+6960 @063b64>): static i16And: int16 := i16A & i16B
	<.main+6941 @063b51> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6946 @063b56> : 27                         load.i16
	<.main+6947 @063b57> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6952 @063b5c> : 27                         load.i16
	<.main+6953 @063b5d> : 31                         and.b32
	<.main+6954 @063b5e> : 1f e0 18 06 00             load.ref <@0618e0> ;i16And
	<.main+6959 @063b63> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:110: (19 bytes: <.main+6960 @063b64> - <.main+6979 @063b77>): static i16Ior: int16 := i16A | i16B
	<.main+6960 @063b64> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6965 @063b69> : 27                         load.i16
	<.main+6966 @063b6a> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6971 @063b6f> : 27                         load.i16
	<.main+6972 @063b70> : 32                         or.b32
	<.main+6973 @063b71> : 1f e8 18 06 00             load.ref <@0618e8> ;i16Ior
	<.main+6978 @063b76> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:111: (19 bytes: <.main+6979 @063b77> - <.main+6998 @063b8a>): static i16Xor: int16 := i16A ^ i16B
	<.main+6979 @063b77> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+6984 @063b7c> : 27                         load.i16
	<.main+6985 @063b7d> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+6990 @063b82> : 27                         load.i16
	<.main+6991 @063b83> : 36                         xor.b32
	<.main+6992 @063b84> : 1f f0 18 06 00             load.ref <@0618f0> ;i16Xor
	<.main+6997 @063b89> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:112: (17 bytes: <.main+6998 @063b8a> - <.main+7015 @063b9b>): static i16Shl: int16 := (i16A) << shift
	<.main+6998 @063b8a> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7003 @063b8f> : 27                         load.i16
	<.main+7004 @063b90> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7008 @063b94> : 3a                         shl.b32
	<.main+7009 @063b95> : 1f f8 18 06 00             load.ref <@0618f8> ;i16Shl
	<.main+7014 @063b9a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:113: (17 bytes: <.main+7015 @063b9b> - <.main+7032 @063bac>): static i16Shr: int16 := (i16A) >> shift
	<.main+7015 @063b9b> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7020 @063ba0> : 27                         load.i16
	<.main+7021 @063ba1> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7025 @063ba5> : 3c                         sar.b32
	<.main+7026 @063ba6> : 1f 00 19 06 00             load.ref <@061900> ;i16Shr
	<.main+7031 @063bab> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:114: (14 bytes: <.main+7032 @063bac> - <.main+7046 @063bba>): static i16Not: bool := !(i16B)
	<.main+7032 @063bac> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7037 @063bb1> : 27                         load.i16
	<.main+7038 @063bb2> : 5a                         i32.2bool
	<.main+7039 @063bb3> : 0b                         not.b32
	<.main+7040 @063bb4> : 1f 08 19 06 00             load.ref <@061908> ;i16Not
	<.main+7045 @063bb9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:115: (19 bytes: <.main+7046 @063bba> - <.main+7065 @063bcd>): static i16Ceq: bool := i16A == i16B
	<.main+7046 @063bba> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7051 @063bbf> : 27                         load.i16
	<.main+7052 @063bc0> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7057 @063bc5> : 27                         load.i16
	<.main+7058 @063bc6> : 57                         ceq.i32
	<.main+7059 @063bc7> : 1f 10 19 06 00             load.ref <@061910> ;i16Ceq
	<.main+7064 @063bcc> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:116: (20 bytes: <.main+7065 @063bcd> - <.main+7085 @063be1>): static i16Cne: bool := i16A != i16B
	<.main+7065 @063bcd> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7070 @063bd2> : 27                         load.i16
	<.main+7071 @063bd3> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7076 @063bd8> : 27                         load.i16
	<.main+7077 @063bd9> : 57                         ceq.i32
	<.main+7078 @063bda> : 0b                         not.b32
	<.main+7079 @063bdb> : 1f 18 19 06 00             load.ref <@061918> ;i16Cne
	<.main+7084 @063be0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:117: (19 bytes: <.main+7085 @063be1> - <.main+7104 @063bf4>): static i16Clt: bool := i16A < i16B
	<.main+7085 @063be1> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7090 @063be6> : 27                         load.i16
	<.main+7091 @063be7> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7096 @063bec> : 27                         load.i16
	<.main+7097 @063bed> : 58                         clt.i32
	<.main+7098 @063bee> : 1f 20 19 06 00             load.ref <@061920> ;i16Clt
	<.main+7103 @063bf3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:118: (20 bytes: <.main+7104 @063bf4> - <.main+7124 @063c08>): static i16Cle: bool := i16A <= i16B
	<.main+7104 @063bf4> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7109 @063bf9> : 27                         load.i16
	<.main+7110 @063bfa> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7115 @063bff> : 27                         load.i16
	<.main+7116 @063c00> : 59                         cgt.i32
	<.main+7117 @063c01> : 0b                         not.b32
	<.main+7118 @063c02> : 1f 28 19 06 00             load.ref <@061928> ;i16Cle
	<.main+7123 @063c07> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:119: (19 bytes: <.main+7124 @063c08> - <.main+7143 @063c1b>): static i16Cgt: bool := i16A > i16B
	<.main+7124 @063c08> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7129 @063c0d> : 27                         load.i16
	<.main+7130 @063c0e> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7135 @063c13> : 27                         load.i16
	<.main+7136 @063c14> : 59                         cgt.i32
	<.main+7137 @063c15> : 1f 30 19 06 00             load.ref <@061930> ;i16Cgt
	<.main+7142 @063c1a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:120: (20 bytes: <.main+7143 @063c1b> - <.main+7163 @063c2f>): static i16Cge: bool := i16A >= i16B
	<.main+7143 @063c1b> : 1f 90 18 06 00             load.ref <@061890> ;i16A
	<.main+7148 @063c20> : 27                         load.i16
	<.main+7149 @063c21> : 1f 98 18 06 00             load.ref <@061898> ;i16B
	<.main+7154 @063c26> : 27                         load.i16
	<.main+7155 @063c27> : 58                         clt.i32
	<.main+7156 @063c28> : 0b                         not.b32
	<.main+7157 @063c29> : 1f 38 19 06 00             load.ref <@061938> ;i16Cge
	<.main+7162 @063c2e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:122: (11 bytes: <.main+7163 @063c2f> - <.main+7174 @063c3a>): static u16A: uint16 := a
	<.main+7163 @063c2f> : 1c 60 00 00 00             load.c32 96
	<.main+7168 @063c34> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7173 @063c39> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:123: (11 bytes: <.main+7174 @063c3a> - <.main+7185 @063c45>): static u16B: uint16 := b
	<.main+7174 @063c3a> : 1c 2a 00 00 00             load.c32 42
	<.main+7179 @063c3f> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7184 @063c44> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:124: (12 bytes: <.main+7185 @063c45> - <.main+7197 @063c51>): static u16Pls: uint16 := +u16B
	<.main+7185 @063c45> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7190 @063c4a> : 27                         load.i16
	<.main+7191 @063c4b> : 1f 50 19 06 00             load.ref <@061950> ;u16Pls
	<.main+7196 @063c50> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:125: (13 bytes: <.main+7197 @063c51> - <.main+7210 @063c5e>): static u16Neg: uint16 := -u16B
	<.main+7197 @063c51> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7202 @063c56> : 27                         load.i16
	<.main+7203 @063c57> : 50                         neg.i32
	<.main+7204 @063c58> : 1f 58 19 06 00             load.ref <@061958> ;u16Neg
	<.main+7209 @063c5d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:126: (13 bytes: <.main+7210 @063c5e> - <.main+7223 @063c6b>): static u16Cmt: uint16 := ~u16B
	<.main+7210 @063c5e> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7215 @063c63> : 27                         load.i16
	<.main+7216 @063c64> : 30                         cmt.b32
	<.main+7217 @063c65> : 1f 60 19 06 00             load.ref <@061960> ;u16Cmt
	<.main+7222 @063c6a> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:127: (19 bytes: <.main+7223 @063c6b> - <.main+7242 @063c7e>): static u16Add: uint16 := u16A + u16B
	<.main+7223 @063c6b> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7228 @063c70> : 27                         load.i16
	<.main+7229 @063c71> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7234 @063c76> : 27                         load.i16
	<.main+7235 @063c77> : 51                         add.i32
	<.main+7236 @063c78> : 1f 68 19 06 00             load.ref <@061968> ;u16Add
	<.main+7241 @063c7d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:128: (19 bytes: <.main+7242 @063c7e> - <.main+7261 @063c91>): static u16Sub: uint16 := u16A - u16B
	<.main+7242 @063c7e> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7247 @063c83> : 27                         load.i16
	<.main+7248 @063c84> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7253 @063c89> : 27                         load.i16
	<.main+7254 @063c8a> : 52                         sub.i32
	<.main+7255 @063c8b> : 1f 70 19 06 00             load.ref <@061970> ;u16Sub
	<.main+7260 @063c90> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:129: (19 bytes: <.main+7261 @063c91> - <.main+7280 @063ca4>): static u16Mul: uint16 := u16A * u16B
	<.main+7261 @063c91> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7266 @063c96> : 27                         load.i16
	<.main+7267 @063c97> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7272 @063c9c> : 27                         load.i16
	<.main+7273 @063c9d> : 33                         mul.u32
	<.main+7274 @063c9e> : 1f 78 19 06 00             load.ref <@061978> ;u16Mul
	<.main+7279 @063ca3> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:130: (19 bytes: <.main+7280 @063ca4> - <.main+7299 @063cb7>): static u16Div: uint16 := u16A / u16B
	<.main+7280 @063ca4> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7285 @063ca9> : 27                         load.i16
	<.main+7286 @063caa> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7291 @063caf> : 27                         load.i16
	<.main+7292 @063cb0> : 34                         div.u32
	<.main+7293 @063cb1> : 1f 80 19 06 00             load.ref <@061980> ;u16Div
	<.main+7298 @063cb6> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:131: (19 bytes: <.main+7299 @063cb7> - <.main+7318 @063cca>): static u16Mod: uint16 := u16A % u16B
	<.main+7299 @063cb7> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7304 @063cbc> : 27                         load.i16
	<.main+7305 @063cbd> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7310 @063cc2> : 27                         load.i16
	<.main+7311 @063cc3> : 35                         mod.u32
	<.main+7312 @063cc4> : 1f 88 19 06 00             load.ref <@061988> ;u16Mod
	<.main+7317 @063cc9> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:132: (19 bytes: <.main+7318 @063cca> - <.main+7337 @063cdd>): static u16And: uint16 := u16A & u16B
	<.main+7318 @063cca> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7323 @063ccf> : 27                         load.i16
	<.main+7324 @063cd0> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7329 @063cd5> : 27                         load.i16
	<.main+7330 @063cd6> : 31                         and.b32
	<.main+7331 @063cd7> : 1f 90 19 06 00             load.ref <@061990> ;u16And
	<.main+7336 @063cdc> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:133: (19 bytes: <.main+7337 @063cdd> - <.main+7356 @063cf0>): static u16Ior: uint16 := u16A | u16B
	<.main+7337 @063cdd> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7342 @063ce2> : 27                         load.i16
	<.main+7343 @063ce3> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7348 @063ce8> : 27                         load.i16
	<.main+7349 @063ce9> : 32                         or.b32
	<.main+7350 @063cea> : 1f 98 19 06 00             load.ref <@061998> ;u16Ior
	<.main+7355 @063cef> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:134: (19 bytes: <.main+7356 @063cf0> - <.main+7375 @063d03>): static u16Xor: uint16 := u16A ^ u16B
	<.main+7356 @063cf0> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7361 @063cf5> : 27                         load.i16
	<.main+7362 @063cf6> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7367 @063cfb> : 27                         load.i16
	<.main+7368 @063cfc> : 36                         xor.b32
	<.main+7369 @063cfd> : 1f a0 19 06 00             load.ref <@0619a0> ;u16Xor
	<.main+7374 @063d02> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:135: (17 bytes: <.main+7375 @063d03> - <.main+7392 @063d14>): static u16Shl: uint16 := (u16A) << shift
	<.main+7375 @063d03> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7380 @063d08> : 27                         load.i16
	<.main+7381 @063d09> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7385 @063d0d> : 3a                         shl.b32
	<.main+7386 @063d0e> : 1f a8 19 06 00             load.ref <@0619a8> ;u16Shl
	<.main+7391 @063d13> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:136: (17 bytes: <.main+7392 @063d14> - <.main+7409 @063d25>): static u16Shr: uint16 := (u16A) >> shift
	<.main+7392 @063d14> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7397 @063d19> : 27                         load.i16
	<.main+7398 @063d1a> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7402 @063d1e> : 3c                         sar.b32
	<.main+7403 @063d1f> : 1f b0 19 06 00             load.ref <@0619b0> ;u16Shr
	<.main+7408 @063d24> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:137: (14 bytes: <.main+7409 @063d25> - <.main+7423 @063d33>): static u16Not: bool := !(u16B)
	<.main+7409 @063d25> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7414 @063d2a> : 27                         load.i16
	<.main+7415 @063d2b> : 5a                         i32.2bool
	<.main+7416 @063d2c> : 0b                         not.b32
	<.main+7417 @063d2d> : 1f b8 19 06 00             load.ref <@0619b8> ;u16Not
	<.main+7422 @063d32> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:138: (19 bytes: <.main+7423 @063d33> - <.main+7442 @063d46>): static u16Ceq: bool := u16A == u16B
	<.main+7423 @063d33> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7428 @063d38> : 27                         load.i16
	<.main+7429 @063d39> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7434 @063d3e> : 27                         load.i16
	<.main+7435 @063d3f> : 57                         ceq.i32
	<.main+7436 @063d40> : 1f c0 19 06 00             load.ref <@0619c0> ;u16Ceq
	<.main+7441 @063d45> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:139: (20 bytes: <.main+7442 @063d46> - <.main+7462 @063d5a>): static u16Cne: bool := u16A != u16B
	<.main+7442 @063d46> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7447 @063d4b> : 27                         load.i16
	<.main+7448 @063d4c> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7453 @063d51> : 27                         load.i16
	<.main+7454 @063d52> : 57                         ceq.i32
	<.main+7455 @063d53> : 0b                         not.b32
	<.main+7456 @063d54> : 1f c8 19 06 00             load.ref <@0619c8> ;u16Cne
	<.main+7461 @063d59> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:140: (19 bytes: <.main+7462 @063d5a> - <.main+7481 @063d6d>): static u16Clt: bool := u16A < u16B
	<.main+7462 @063d5a> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7467 @063d5f> : 27                         load.i16
	<.main+7468 @063d60> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7473 @063d65> : 27                         load.i16
	<.main+7474 @063d66> : 38                         clt.u32
	<.main+7475 @063d67> : 1f d0 19 06 00             load.ref <@0619d0> ;u16Clt
	<.main+7480 @063d6c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:141: (20 bytes: <.main+7481 @063d6d> - <.main+7501 @063d81>): static u16Cle: bool := u16A <= u16B
	<.main+7481 @063d6d> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7486 @063d72> : 27                         load.i16
	<.main+7487 @063d73> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7492 @063d78> : 27                         load.i16
	<.main+7493 @063d79> : 39                         cgt.u32
	<.main+7494 @063d7a> : 0b                         not.b32
	<.main+7495 @063d7b> : 1f d8 19 06 00             load.ref <@0619d8> ;u16Cle
	<.main+7500 @063d80> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:142: (19 bytes: <.main+7501 @063d81> - <.main+7520 @063d94>): static u16Cgt: bool := u16A > u16B
	<.main+7501 @063d81> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7506 @063d86> : 27                         load.i16
	<.main+7507 @063d87> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7512 @063d8c> : 27                         load.i16
	<.main+7513 @063d8d> : 39                         cgt.u32
	<.main+7514 @063d8e> : 1f e0 19 06 00             load.ref <@0619e0> ;u16Cgt
	<.main+7519 @063d93> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:143: (20 bytes: <.main+7520 @063d94> - <.main+7540 @063da8>): static u16Cge: bool := u16A >= u16B
	<.main+7520 @063d94> : 1f 40 19 06 00             load.ref <@061940> ;u16A
	<.main+7525 @063d99> : 27                         load.i16
	<.main+7526 @063d9a> : 1f 48 19 06 00             load.ref <@061948> ;u16B
	<.main+7531 @063d9f> : 27                         load.i16
	<.main+7532 @063da0> : 38                         clt.u32
	<.main+7533 @063da1> : 0b                         not.b32
	<.main+7534 @063da2> : 1f e8 19 06 00             load.ref <@0619e8> ;u16Cge
	<.main+7539 @063da7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:145: (9 bytes: <.main+7540 @063da8> - <.main+7549 @063db1>): static i32A: int32 := a
	<.main+7540 @063da8> : 1c 60 00 00 00             load.c32 96
	<.main+7545 @063dad> : 24 f0 19 06                store.m32 <@0619f0> ;i32A
	cmplStd/test/lang/useOperator.ci:146: (9 bytes: <.main+7549 @063db1> - <.main+7558 @063dba>): static i32B: int32 := b
	<.main+7549 @063db1> : 1c 2a 00 00 00             load.c32 42
	<.main+7554 @063db6> : 24 f8 19 06                store.m32 <@0619f8> ;i32B
	cmplStd/test/lang/useOperator.ci:147: (8 bytes: <.main+7558 @063dba> - <.main+7566 @063dc2>): static i32Pls: int32 := +i32B
	<.main+7558 @063dba> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7562 @063dbe> : 24 00 1a 06                store.m32 <@061a00> ;i32Pls
	cmplStd/test/lang/useOperator.ci:148: (9 bytes: <.main+7566 @063dc2> - <.main+7575 @063dcb>): static i32Neg: int32 := -i32B
	<.main+7566 @063dc2> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7570 @063dc6> : 50                         neg.i32
	<.main+7571 @063dc7> : 24 08 1a 06                store.m32 <@061a08> ;i32Neg
	cmplStd/test/lang/useOperator.ci:149: (9 bytes: <.main+7575 @063dcb> - <.main+7584 @063dd4>): static i32Cmt: int32 := ~i32B
	<.main+7575 @063dcb> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7579 @063dcf> : 30                         cmt.b32
	<.main+7580 @063dd0> : 24 10 1a 06                store.m32 <@061a10> ;i32Cmt
	cmplStd/test/lang/useOperator.ci:150: (13 bytes: <.main+7584 @063dd4> - <.main+7597 @063de1>): static i32Add: int32 := i32A + i32B
	<.main+7584 @063dd4> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7588 @063dd8> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7592 @063ddc> : 51                         add.i32
	<.main+7593 @063ddd> : 24 18 1a 06                store.m32 <@061a18> ;i32Add
	cmplStd/test/lang/useOperator.ci:151: (13 bytes: <.main+7597 @063de1> - <.main+7610 @063dee>): static i32Sub: int32 := i32A - i32B
	<.main+7597 @063de1> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7601 @063de5> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7605 @063de9> : 52                         sub.i32
	<.main+7606 @063dea> : 24 20 1a 06                store.m32 <@061a20> ;i32Sub
	cmplStd/test/lang/useOperator.ci:152: (13 bytes: <.main+7610 @063dee> - <.main+7623 @063dfb>): static i32Mul: int32 := i32A * i32B
	<.main+7610 @063dee> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7614 @063df2> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7618 @063df6> : 53                         mul.i32
	<.main+7619 @063df7> : 24 28 1a 06                store.m32 <@061a28> ;i32Mul
	cmplStd/test/lang/useOperator.ci:153: (13 bytes: <.main+7623 @063dfb> - <.main+7636 @063e08>): static i32Div: int32 := i32A / i32B
	<.main+7623 @063dfb> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7627 @063dff> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7631 @063e03> : 54                         div.i32
	<.main+7632 @063e04> : 24 30 1a 06                store.m32 <@061a30> ;i32Div
	cmplStd/test/lang/useOperator.ci:154: (13 bytes: <.main+7636 @063e08> - <.main+7649 @063e15>): static i32Mod: int32 := i32A % i32B
	<.main+7636 @063e08> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7640 @063e0c> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7644 @063e10> : 55                         mod.i32
	<.main+7645 @063e11> : 24 38 1a 06                store.m32 <@061a38> ;i32Mod
	cmplStd/test/lang/useOperator.ci:155: (13 bytes: <.main+7649 @063e15> - <.main+7662 @063e22>): static i32And: int32 := i32A & i32B
	<.main+7649 @063e15> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7653 @063e19> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7657 @063e1d> : 31                         and.b32
	<.main+7658 @063e1e> : 24 40 1a 06                store.m32 <@061a40> ;i32And
	cmplStd/test/lang/useOperator.ci:156: (13 bytes: <.main+7662 @063e22> - <.main+7675 @063e2f>): static i32Ior: int32 := i32A | i32B
	<.main+7662 @063e22> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7666 @063e26> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7670 @063e2a> : 32                         or.b32
	<.main+7671 @063e2b> : 24 48 1a 06                store.m32 <@061a48> ;i32Ior
	cmplStd/test/lang/useOperator.ci:157: (13 bytes: <.main+7675 @063e2f> - <.main+7688 @063e3c>): static i32Xor: int32 := i32A ^ i32B
	<.main+7675 @063e2f> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7679 @063e33> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7683 @063e37> : 36                         xor.b32
	<.main+7684 @063e38> : 24 50 1a 06                store.m32 <@061a50> ;i32Xor
	cmplStd/test/lang/useOperator.ci:158: (13 bytes: <.main+7688 @063e3c> - <.main+7701 @063e49>): static i32Shl: int32 := i32A << shift
	<.main+7688 @063e3c> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7692 @063e40> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7696 @063e44> : 3a                         shl.b32
	<.main+7697 @063e45> : 24 58 1a 06                store.m32 <@061a58> ;i32Shl
	cmplStd/test/lang/useOperator.ci:159: (13 bytes: <.main+7701 @063e49> - <.main+7714 @063e56>): static i32Shr: int32 := i32A >> shift
	<.main+7701 @063e49> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7705 @063e4d> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7709 @063e51> : 3c                         sar.b32
	<.main+7710 @063e52> : 24 60 1a 06                store.m32 <@061a60> ;i32Shr
	cmplStd/test/lang/useOperator.ci:160: (12 bytes: <.main+7714 @063e56> - <.main+7726 @063e62>): static i32Not: bool := !(i32B)
	<.main+7714 @063e56> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7718 @063e5a> : 5a                         i32.2bool
	<.main+7719 @063e5b> : 0b                         not.b32
	<.main+7720 @063e5c> : 1f 68 1a 06 00             load.ref <@061a68> ;i32Not
	<.main+7725 @063e61> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:161: (15 bytes: <.main+7726 @063e62> - <.main+7741 @063e71>): static i32Ceq: bool := i32A == i32B
	<.main+7726 @063e62> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7730 @063e66> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7734 @063e6a> : 57                         ceq.i32
	<.main+7735 @063e6b> : 1f 70 1a 06 00             load.ref <@061a70> ;i32Ceq
	<.main+7740 @063e70> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:162: (16 bytes: <.main+7741 @063e71> - <.main+7757 @063e81>): static i32Cne: bool := i32A != i32B
	<.main+7741 @063e71> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7745 @063e75> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7749 @063e79> : 57                         ceq.i32
	<.main+7750 @063e7a> : 0b                         not.b32
	<.main+7751 @063e7b> : 1f 78 1a 06 00             load.ref <@061a78> ;i32Cne
	<.main+7756 @063e80> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:163: (15 bytes: <.main+7757 @063e81> - <.main+7772 @063e90>): static i32Clt: bool := i32A < i32B
	<.main+7757 @063e81> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7761 @063e85> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7765 @063e89> : 58                         clt.i32
	<.main+7766 @063e8a> : 1f 80 1a 06 00             load.ref <@061a80> ;i32Clt
	<.main+7771 @063e8f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:164: (16 bytes: <.main+7772 @063e90> - <.main+7788 @063ea0>): static i32Cle: bool := i32A <= i32B
	<.main+7772 @063e90> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7776 @063e94> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7780 @063e98> : 59                         cgt.i32
	<.main+7781 @063e99> : 0b                         not.b32
	<.main+7782 @063e9a> : 1f 88 1a 06 00             load.ref <@061a88> ;i32Cle
	<.main+7787 @063e9f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:165: (15 bytes: <.main+7788 @063ea0> - <.main+7803 @063eaf>): static i32Cgt: bool := i32A > i32B
	<.main+7788 @063ea0> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7792 @063ea4> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7796 @063ea8> : 59                         cgt.i32
	<.main+7797 @063ea9> : 1f 90 1a 06 00             load.ref <@061a90> ;i32Cgt
	<.main+7802 @063eae> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:166: (16 bytes: <.main+7803 @063eaf> - <.main+7819 @063ebf>): static i32Cge: bool := i32A >= i32B
	<.main+7803 @063eaf> : 20 f0 19 06                load.m32 <@0619f0> ;i32A
	<.main+7807 @063eb3> : 20 f8 19 06                load.m32 <@0619f8> ;i32B
	<.main+7811 @063eb7> : 58                         clt.i32
	<.main+7812 @063eb8> : 0b                         not.b32
	<.main+7813 @063eb9> : 1f 98 1a 06 00             load.ref <@061a98> ;i32Cge
	<.main+7818 @063ebe> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:168: (9 bytes: <.main+7819 @063ebf> - <.main+7828 @063ec8>): static u32A: uint32 := a
	<.main+7819 @063ebf> : 1c 60 00 00 00             load.c32 96
	<.main+7824 @063ec4> : 24 a0 1a 06                store.m32 <@061aa0> ;u32A
	cmplStd/test/lang/useOperator.ci:169: (9 bytes: <.main+7828 @063ec8> - <.main+7837 @063ed1>): static u32B: uint32 := b
	<.main+7828 @063ec8> : 1c 2a 00 00 00             load.c32 42
	<.main+7833 @063ecd> : 24 a8 1a 06                store.m32 <@061aa8> ;u32B
	cmplStd/test/lang/useOperator.ci:170: (8 bytes: <.main+7837 @063ed1> - <.main+7845 @063ed9>): static u32Pls: uint32 := +u32B
	<.main+7837 @063ed1> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7841 @063ed5> : 24 b0 1a 06                store.m32 <@061ab0> ;u32Pls
	cmplStd/test/lang/useOperator.ci:171: (9 bytes: <.main+7845 @063ed9> - <.main+7854 @063ee2>): static u32Neg: uint32 := -u32B
	<.main+7845 @063ed9> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7849 @063edd> : 50                         neg.i32
	<.main+7850 @063ede> : 24 b8 1a 06                store.m32 <@061ab8> ;u32Neg
	cmplStd/test/lang/useOperator.ci:172: (9 bytes: <.main+7854 @063ee2> - <.main+7863 @063eeb>): static u32Cmt: uint32 := ~u32B
	<.main+7854 @063ee2> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7858 @063ee6> : 30                         cmt.b32
	<.main+7859 @063ee7> : 24 c0 1a 06                store.m32 <@061ac0> ;u32Cmt
	cmplStd/test/lang/useOperator.ci:173: (13 bytes: <.main+7863 @063eeb> - <.main+7876 @063ef8>): static u32Add: uint32 := u32A + u32B
	<.main+7863 @063eeb> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7867 @063eef> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7871 @063ef3> : 51                         add.i32
	<.main+7872 @063ef4> : 24 c8 1a 06                store.m32 <@061ac8> ;u32Add
	cmplStd/test/lang/useOperator.ci:174: (13 bytes: <.main+7876 @063ef8> - <.main+7889 @063f05>): static u32Sub: uint32 := u32A - u32B
	<.main+7876 @063ef8> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7880 @063efc> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7884 @063f00> : 52                         sub.i32
	<.main+7885 @063f01> : 24 d0 1a 06                store.m32 <@061ad0> ;u32Sub
	cmplStd/test/lang/useOperator.ci:175: (13 bytes: <.main+7889 @063f05> - <.main+7902 @063f12>): static u32Mul: uint32 := u32A * u32B
	<.main+7889 @063f05> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7893 @063f09> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7897 @063f0d> : 33                         mul.u32
	<.main+7898 @063f0e> : 24 d8 1a 06                store.m32 <@061ad8> ;u32Mul
	cmplStd/test/lang/useOperator.ci:176: (13 bytes: <.main+7902 @063f12> - <.main+7915 @063f1f>): static u32Div: uint32 := u32A / u32B
	<.main+7902 @063f12> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7906 @063f16> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7910 @063f1a> : 34                         div.u32
	<.main+7911 @063f1b> : 24 e0 1a 06                store.m32 <@061ae0> ;u32Div
	cmplStd/test/lang/useOperator.ci:177: (13 bytes: <.main+7915 @063f1f> - <.main+7928 @063f2c>): static u32Mod: uint32 := u32A % u32B
	<.main+7915 @063f1f> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7919 @063f23> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7923 @063f27> : 35                         mod.u32
	<.main+7924 @063f28> : 24 e8 1a 06                store.m32 <@061ae8> ;u32Mod
	cmplStd/test/lang/useOperator.ci:178: (13 bytes: <.main+7928 @063f2c> - <.main+7941 @063f39>): static u32And: uint32 := u32A & u32B
	<.main+7928 @063f2c> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7932 @063f30> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7936 @063f34> : 31                         and.b32
	<.main+7937 @063f35> : 24 f0 1a 06                store.m32 <@061af0> ;u32And
	cmplStd/test/lang/useOperator.ci:179: (13 bytes: <.main+7941 @063f39> - <.main+7954 @063f46>): static u32Ior: uint32 := u32A | u32B
	<.main+7941 @063f39> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7945 @063f3d> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7949 @063f41> : 32                         or.b32
	<.main+7950 @063f42> : 24 f8 1a 06                store.m32 <@061af8> ;u32Ior
	cmplStd/test/lang/useOperator.ci:180: (13 bytes: <.main+7954 @063f46> - <.main+7967 @063f53>): static u32Xor: uint32 := u32A ^ u32B
	<.main+7954 @063f46> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7958 @063f4a> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7962 @063f4e> : 36                         xor.b32
	<.main+7963 @063f4f> : 24 00 1b 06                store.m32 <@061b00> ;u32Xor
	cmplStd/test/lang/useOperator.ci:181: (13 bytes: <.main+7967 @063f53> - <.main+7980 @063f60>): static u32Shl: uint32 := u32A << shift
	<.main+7967 @063f53> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7971 @063f57> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7975 @063f5b> : 3a                         shl.b32
	<.main+7976 @063f5c> : 24 08 1b 06                store.m32 <@061b08> ;u32Shl
	cmplStd/test/lang/useOperator.ci:182: (13 bytes: <.main+7980 @063f60> - <.main+7993 @063f6d>): static u32Shr: uint32 := u32A >> shift
	<.main+7980 @063f60> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+7984 @063f64> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+7988 @063f68> : 3b                         shr.b32
	<.main+7989 @063f69> : 24 10 1b 06                store.m32 <@061b10> ;u32Shr
	cmplStd/test/lang/useOperator.ci:183: (12 bytes: <.main+7993 @063f6d> - <.main+8005 @063f79>): static u32Not: bool := !(u32B)
	<.main+7993 @063f6d> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+7997 @063f71> : 5a                         i32.2bool
	<.main+7998 @063f72> : 0b                         not.b32
	<.main+7999 @063f73> : 1f 18 1b 06 00             load.ref <@061b18> ;u32Not
	<.main+8004 @063f78> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:184: (15 bytes: <.main+8005 @063f79> - <.main+8020 @063f88>): static u32Ceq: bool := u32A == u32B
	<.main+8005 @063f79> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+8009 @063f7d> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+8013 @063f81> : 57                         ceq.i32
	<.main+8014 @063f82> : 1f 20 1b 06 00             load.ref <@061b20> ;u32Ceq
	<.main+8019 @063f87> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:185: (16 bytes: <.main+8020 @063f88> - <.main+8036 @063f98>): static u32Cne: bool := u32A != u32B
	<.main+8020 @063f88> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+8024 @063f8c> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+8028 @063f90> : 57                         ceq.i32
	<.main+8029 @063f91> : 0b                         not.b32
	<.main+8030 @063f92> : 1f 28 1b 06 00             load.ref <@061b28> ;u32Cne
	<.main+8035 @063f97> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:186: (15 bytes: <.main+8036 @063f98> - <.main+8051 @063fa7>): static u32Clt: bool := u32A < u32B
	<.main+8036 @063f98> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+8040 @063f9c> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+8044 @063fa0> : 38                         clt.u32
	<.main+8045 @063fa1> : 1f 30 1b 06 00             load.ref <@061b30> ;u32Clt
	<.main+8050 @063fa6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:187: (16 bytes: <.main+8051 @063fa7> - <.main+8067 @063fb7>): static u32Cle: bool := u32A <= u32B
	<.main+8051 @063fa7> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+8055 @063fab> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+8059 @063faf> : 39                         cgt.u32
	<.main+8060 @063fb0> : 0b                         not.b32
	<.main+8061 @063fb1> : 1f 38 1b 06 00             load.ref <@061b38> ;u32Cle
	<.main+8066 @063fb6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:188: (15 bytes: <.main+8067 @063fb7> - <.main+8082 @063fc6>): static u32Cgt: bool := u32A > u32B
	<.main+8067 @063fb7> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+8071 @063fbb> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+8075 @063fbf> : 39                         cgt.u32
	<.main+8076 @063fc0> : 1f 40 1b 06 00             load.ref <@061b40> ;u32Cgt
	<.main+8081 @063fc5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:189: (16 bytes: <.main+8082 @063fc6> - <.main+8098 @063fd6>): static u32Cge: bool := u32A >= u32B
	<.main+8082 @063fc6> : 20 a0 1a 06                load.m32 <@061aa0> ;u32A
	<.main+8086 @063fca> : 20 a8 1a 06                load.m32 <@061aa8> ;u32B
	<.main+8090 @063fce> : 38                         clt.u32
	<.main+8091 @063fcf> : 0b                         not.b32
	<.main+8092 @063fd0> : 1f 48 1b 06 00             load.ref <@061b48> ;u32Cge
	<.main+8097 @063fd5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:191: (13 bytes: <.main+8098 @063fd6> - <.main+8111 @063fe3>): static i64A: int64 := a
	<.main+8098 @063fd6> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8107 @063fdf> : 23 50 1b 06                store.m64 <@061b50> ;i64A
	cmplStd/test/lang/useOperator.ci:192: (13 bytes: <.main+8111 @063fe3> - <.main+8124 @063ff0>): static i64B: int64 := b
	<.main+8111 @063fe3> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8120 @063fec> : 23 58 1b 06                store.m64 <@061b58> ;i64B
	cmplStd/test/lang/useOperator.ci:193: (8 bytes: <.main+8124 @063ff0> - <.main+8132 @063ff8>): static i64Pls: int64 := +i64B
	<.main+8124 @063ff0> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8128 @063ff4> : 23 60 1b 06                store.m64 <@061b60> ;i64Pls
	cmplStd/test/lang/useOperator.ci:194: (9 bytes: <.main+8132 @063ff8> - <.main+8141 @064001>): static i64Neg: int64 := -i64B
	<.main+8132 @063ff8> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8136 @063ffc> : 60                         neg.i64
	<.main+8137 @063ffd> : 23 68 1b 06                store.m64 <@061b68> ;i64Neg
	cmplStd/test/lang/useOperator.ci:195: (9 bytes: <.main+8141 @064001> - <.main+8150 @06400a>): static i64Cmt: int64 := ~i64B
	<.main+8141 @064001> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8145 @064005> : 40                         cmt.b64
	<.main+8146 @064006> : 23 70 1b 06                store.m64 <@061b70> ;i64Cmt
	cmplStd/test/lang/useOperator.ci:196: (13 bytes: <.main+8150 @06400a> - <.main+8163 @064017>): static i64Add: int64 := i64A + i64B
	<.main+8150 @06400a> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8154 @06400e> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8158 @064012> : 61                         add.i64
	<.main+8159 @064013> : 23 78 1b 06                store.m64 <@061b78> ;i64Add
	cmplStd/test/lang/useOperator.ci:197: (13 bytes: <.main+8163 @064017> - <.main+8176 @064024>): static i64Sub: int64 := i64A - i64B
	<.main+8163 @064017> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8167 @06401b> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8171 @06401f> : 62                         sub.i64
	<.main+8172 @064020> : 23 80 1b 06                store.m64 <@061b80> ;i64Sub
	cmplStd/test/lang/useOperator.ci:198: (13 bytes: <.main+8176 @064024> - <.main+8189 @064031>): static i64Mul: int64 := i64A * i64B
	<.main+8176 @064024> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8180 @064028> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8184 @06402c> : 63                         mul.i64
	<.main+8185 @06402d> : 23 88 1b 06                store.m64 <@061b88> ;i64Mul
	cmplStd/test/lang/useOperator.ci:199: (13 bytes: <.main+8189 @064031> - <.main+8202 @06403e>): static i64Div: int64 := i64A / i64B
	<.main+8189 @064031> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8193 @064035> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8197 @064039> : 64                         div.i64
	<.main+8198 @06403a> : 23 90 1b 06                store.m64 <@061b90> ;i64Div
	cmplStd/test/lang/useOperator.ci:200: (13 bytes: <.main+8202 @06403e> - <.main+8215 @06404b>): static i64Mod: int64 := i64A % i64B
	<.main+8202 @06403e> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8206 @064042> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8210 @064046> : 65                         mod.i64
	<.main+8211 @064047> : 23 98 1b 06                store.m64 <@061b98> ;i64Mod
	cmplStd/test/lang/useOperator.ci:201: (13 bytes: <.main+8215 @06404b> - <.main+8228 @064058>): static i64And: int64 := i64A & i64B
	<.main+8215 @06404b> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8219 @06404f> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8223 @064053> : 41                         and.b64
	<.main+8224 @064054> : 23 a0 1b 06                store.m64 <@061ba0> ;i64And
	cmplStd/test/lang/useOperator.ci:202: (13 bytes: <.main+8228 @064058> - <.main+8241 @064065>): static i64Ior: int64 := i64A | i64B
	<.main+8228 @064058> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8232 @06405c> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8236 @064060> : 42                         or.b64
	<.main+8237 @064061> : 23 a8 1b 06                store.m64 <@061ba8> ;i64Ior
	cmplStd/test/lang/useOperator.ci:203: (13 bytes: <.main+8241 @064065> - <.main+8254 @064072>): static i64Xor: int64 := i64A ^ i64B
	<.main+8241 @064065> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8245 @064069> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8249 @06406d> : 46                         xor.b64
	<.main+8250 @06406e> : 23 b0 1b 06                store.m64 <@061bb0> ;i64Xor
	cmplStd/test/lang/useOperator.ci:204: (13 bytes: <.main+8254 @064072> - <.main+8267 @06407f>): static i64Shl: int64 := i64A << shift
	<.main+8254 @064072> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8258 @064076> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+8262 @06407a> : 4a                         shl.b64
	<.main+8263 @06407b> : 23 b8 1b 06                store.m64 <@061bb8> ;i64Shl
	cmplStd/test/lang/useOperator.ci:205: (13 bytes: <.main+8267 @06407f> - <.main+8280 @06408c>): static i64Shr: int64 := i64A >> shift
	<.main+8267 @06407f> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8271 @064083> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+8275 @064087> : 4c                         sar.b64
	<.main+8276 @064088> : 23 c0 1b 06                store.m64 <@061bc0> ;i64Shr
	cmplStd/test/lang/useOperator.ci:206: (12 bytes: <.main+8280 @06408c> - <.main+8292 @064098>): static i64Not: bool := !(i64B)
	<.main+8280 @06408c> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8284 @064090> : 6b                         i64.2bool
	<.main+8285 @064091> : 0b                         not.b32
	<.main+8286 @064092> : 1f c8 1b 06 00             load.ref <@061bc8> ;i64Not
	<.main+8291 @064097> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:207: (15 bytes: <.main+8292 @064098> - <.main+8307 @0640a7>): static i64Ceq: bool := i64A == i64B
	<.main+8292 @064098> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8296 @06409c> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8300 @0640a0> : 67                         ceq.i64
	<.main+8301 @0640a1> : 1f d0 1b 06 00             load.ref <@061bd0> ;i64Ceq
	<.main+8306 @0640a6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:208: (16 bytes: <.main+8307 @0640a7> - <.main+8323 @0640b7>): static i64Cne: bool := i64A != i64B
	<.main+8307 @0640a7> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8311 @0640ab> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8315 @0640af> : 67                         ceq.i64
	<.main+8316 @0640b0> : 0b                         not.b32
	<.main+8317 @0640b1> : 1f d8 1b 06 00             load.ref <@061bd8> ;i64Cne
	<.main+8322 @0640b6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:209: (15 bytes: <.main+8323 @0640b7> - <.main+8338 @0640c6>): static i64Clt: bool := i64A < i64B
	<.main+8323 @0640b7> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8327 @0640bb> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8331 @0640bf> : 68                         clt.i64
	<.main+8332 @0640c0> : 1f e0 1b 06 00             load.ref <@061be0> ;i64Clt
	<.main+8337 @0640c5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:210: (16 bytes: <.main+8338 @0640c6> - <.main+8354 @0640d6>): static i64Cle: bool := i64A <= i64B
	<.main+8338 @0640c6> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8342 @0640ca> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8346 @0640ce> : 69                         cgt.i64
	<.main+8347 @0640cf> : 0b                         not.b32
	<.main+8348 @0640d0> : 1f e8 1b 06 00             load.ref <@061be8> ;i64Cle
	<.main+8353 @0640d5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:211: (15 bytes: <.main+8354 @0640d6> - <.main+8369 @0640e5>): static i64Cgt: bool := i64A > i64B
	<.main+8354 @0640d6> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8358 @0640da> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8362 @0640de> : 69                         cgt.i64
	<.main+8363 @0640df> : 1f f0 1b 06 00             load.ref <@061bf0> ;i64Cgt
	<.main+8368 @0640e4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:212: (16 bytes: <.main+8369 @0640e5> - <.main+8385 @0640f5>): static i64Cge: bool := i64A >= i64B
	<.main+8369 @0640e5> : 21 50 1b 06                load.m64 <@061b50> ;i64A
	<.main+8373 @0640e9> : 21 58 1b 06                load.m64 <@061b58> ;i64B
	<.main+8377 @0640ed> : 68                         clt.i64
	<.main+8378 @0640ee> : 0b                         not.b32
	<.main+8379 @0640ef> : 1f f8 1b 06 00             load.ref <@061bf8> ;i64Cge
	<.main+8384 @0640f4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:214: (13 bytes: <.main+8385 @0640f5> - <.main+8398 @064102>): static u64A: uint64 := a
	<.main+8385 @0640f5> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8394 @0640fe> : 23 00 1c 06                store.m64 <@061c00> ;u64A
	cmplStd/test/lang/useOperator.ci:215: (13 bytes: <.main+8398 @064102> - <.main+8411 @06410f>): static u64B: uint64 := b
	<.main+8398 @064102> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8407 @06410b> : 23 08 1c 06                store.m64 <@061c08> ;u64B
	cmplStd/test/lang/useOperator.ci:216: (8 bytes: <.main+8411 @06410f> - <.main+8419 @064117>): static u64Pls: uint64 := +u64B
	<.main+8411 @06410f> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8415 @064113> : 23 10 1c 06                store.m64 <@061c10> ;u64Pls
	cmplStd/test/lang/useOperator.ci:217: (9 bytes: <.main+8419 @064117> - <.main+8428 @064120>): static u64Neg: uint64 := -u64B
	<.main+8419 @064117> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8423 @06411b> : 60                         neg.i64
	<.main+8424 @06411c> : 23 18 1c 06                store.m64 <@061c18> ;u64Neg
	cmplStd/test/lang/useOperator.ci:218: (9 bytes: <.main+8428 @064120> - <.main+8437 @064129>): static u64Cmt: uint64 := ~u64B
	<.main+8428 @064120> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8432 @064124> : 40                         cmt.b64
	<.main+8433 @064125> : 23 20 1c 06                store.m64 <@061c20> ;u64Cmt
	cmplStd/test/lang/useOperator.ci:219: (13 bytes: <.main+8437 @064129> - <.main+8450 @064136>): static u64Add: uint64 := u64A + u64B
	<.main+8437 @064129> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8441 @06412d> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8445 @064131> : 61                         add.i64
	<.main+8446 @064132> : 23 28 1c 06                store.m64 <@061c28> ;u64Add
	cmplStd/test/lang/useOperator.ci:220: (13 bytes: <.main+8450 @064136> - <.main+8463 @064143>): static u64Sub: uint64 := u64A - u64B
	<.main+8450 @064136> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8454 @06413a> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8458 @06413e> : 62                         sub.i64
	<.main+8459 @06413f> : 23 30 1c 06                store.m64 <@061c30> ;u64Sub
	cmplStd/test/lang/useOperator.ci:221: (13 bytes: <.main+8463 @064143> - <.main+8476 @064150>): static u64Mul: uint64 := u64A * u64B
	<.main+8463 @064143> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8467 @064147> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8471 @06414b> : 43                         mul.u64
	<.main+8472 @06414c> : 23 38 1c 06                store.m64 <@061c38> ;u64Mul
	cmplStd/test/lang/useOperator.ci:222: (13 bytes: <.main+8476 @064150> - <.main+8489 @06415d>): static u64Div: uint64 := u64A / u64B
	<.main+8476 @064150> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8480 @064154> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8484 @064158> : 44                         div.u64
	<.main+8485 @064159> : 23 40 1c 06                store.m64 <@061c40> ;u64Div
	cmplStd/test/lang/useOperator.ci:223: (13 bytes: <.main+8489 @06415d> - <.main+8502 @06416a>): static u64Mod: uint64 := u64A % u64B
	<.main+8489 @06415d> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8493 @064161> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8497 @064165> : 45                         mod.u64
	<.main+8498 @064166> : 23 48 1c 06                store.m64 <@061c48> ;u64Mod
	cmplStd/test/lang/useOperator.ci:224: (13 bytes: <.main+8502 @06416a> - <.main+8515 @064177>): static u64And: uint64 := u64A & u64B
	<.main+8502 @06416a> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8506 @06416e> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8510 @064172> : 41                         and.b64
	<.main+8511 @064173> : 23 50 1c 06                store.m64 <@061c50> ;u64And
	cmplStd/test/lang/useOperator.ci:225: (13 bytes: <.main+8515 @064177> - <.main+8528 @064184>): static u64Ior: uint64 := u64A | u64B
	<.main+8515 @064177> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8519 @06417b> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8523 @06417f> : 42                         or.b64
	<.main+8524 @064180> : 23 58 1c 06                store.m64 <@061c58> ;u64Ior
	cmplStd/test/lang/useOperator.ci:226: (13 bytes: <.main+8528 @064184> - <.main+8541 @064191>): static u64Xor: uint64 := u64A ^ u64B
	<.main+8528 @064184> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8532 @064188> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8536 @06418c> : 46                         xor.b64
	<.main+8537 @06418d> : 23 60 1c 06                store.m64 <@061c60> ;u64Xor
	cmplStd/test/lang/useOperator.ci:227: (13 bytes: <.main+8541 @064191> - <.main+8554 @06419e>): static u64Shl: uint64 := u64A << shift
	<.main+8541 @064191> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8545 @064195> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+8549 @064199> : 4a                         shl.b64
	<.main+8550 @06419a> : 23 68 1c 06                store.m64 <@061c68> ;u64Shl
	cmplStd/test/lang/useOperator.ci:228: (13 bytes: <.main+8554 @06419e> - <.main+8567 @0641ab>): static u64Shr: uint64 := u64A >> shift
	<.main+8554 @06419e> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8558 @0641a2> : 20 18 16 06                load.m32 <@061618> ;shift
	<.main+8562 @0641a6> : 4b                         shr.b64
	<.main+8563 @0641a7> : 23 70 1c 06                store.m64 <@061c70> ;u64Shr
	cmplStd/test/lang/useOperator.ci:229: (12 bytes: <.main+8567 @0641ab> - <.main+8579 @0641b7>): static u64Not: bool := !(u64B)
	<.main+8567 @0641ab> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8571 @0641af> : 6b                         i64.2bool
	<.main+8572 @0641b0> : 0b                         not.b32
	<.main+8573 @0641b1> : 1f 78 1c 06 00             load.ref <@061c78> ;u64Not
	<.main+8578 @0641b6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:230: (15 bytes: <.main+8579 @0641b7> - <.main+8594 @0641c6>): static u64Ceq: bool := u64A == u64B
	<.main+8579 @0641b7> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8583 @0641bb> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8587 @0641bf> : 67                         ceq.i64
	<.main+8588 @0641c0> : 1f 80 1c 06 00             load.ref <@061c80> ;u64Ceq
	<.main+8593 @0641c5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:231: (16 bytes: <.main+8594 @0641c6> - <.main+8610 @0641d6>): static u64Cne: bool := u64A != u64B
	<.main+8594 @0641c6> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8598 @0641ca> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8602 @0641ce> : 67                         ceq.i64
	<.main+8603 @0641cf> : 0b                         not.b32
	<.main+8604 @0641d0> : 1f 88 1c 06 00             load.ref <@061c88> ;u64Cne
	<.main+8609 @0641d5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:232: (15 bytes: <.main+8610 @0641d6> - <.main+8625 @0641e5>): static u64Clt: bool := u64A < u64B
	<.main+8610 @0641d6> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8614 @0641da> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8618 @0641de> : 48                         clt.u64
	<.main+8619 @0641df> : 1f 90 1c 06 00             load.ref <@061c90> ;u64Clt
	<.main+8624 @0641e4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:233: (16 bytes: <.main+8625 @0641e5> - <.main+8641 @0641f5>): static u64Cle: bool := u64A <= u64B
	<.main+8625 @0641e5> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8629 @0641e9> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8633 @0641ed> : 49                         cgt.u64
	<.main+8634 @0641ee> : 0b                         not.b32
	<.main+8635 @0641ef> : 1f 98 1c 06 00             load.ref <@061c98> ;u64Cle
	<.main+8640 @0641f4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:234: (15 bytes: <.main+8641 @0641f5> - <.main+8656 @064204>): static u64Cgt: bool := u64A > u64B
	<.main+8641 @0641f5> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8645 @0641f9> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8649 @0641fd> : 49                         cgt.u64
	<.main+8650 @0641fe> : 1f a0 1c 06 00             load.ref <@061ca0> ;u64Cgt
	<.main+8655 @064203> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:235: (16 bytes: <.main+8656 @064204> - <.main+8672 @064214>): static u64Cge: bool := u64A >= u64B
	<.main+8656 @064204> : 21 00 1c 06                load.m64 <@061c00> ;u64A
	<.main+8660 @064208> : 21 08 1c 06                load.m64 <@061c08> ;u64B
	<.main+8664 @06420c> : 48                         clt.u64
	<.main+8665 @06420d> : 0b                         not.b32
	<.main+8666 @06420e> : 1f a8 1c 06 00             load.ref <@061ca8> ;u64Cge
	<.main+8671 @064213> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:237: (9 bytes: <.main+8672 @064214> - <.main+8681 @06421d>): static f32A: float32 := a
	<.main+8672 @064214> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8677 @064219> : 24 b0 1c 06                store.m32 <@061cb0> ;f32A
	cmplStd/test/lang/useOperator.ci:238: (9 bytes: <.main+8681 @06421d> - <.main+8690 @064226>): static f32B: float32 := b
	<.main+8681 @06421d> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8686 @064222> : 24 b8 1c 06                store.m32 <@061cb8> ;f32B
	cmplStd/test/lang/useOperator.ci:239: (8 bytes: <.main+8690 @064226> - <.main+8698 @06422e>): static f32Pls: float32 := +f32B
	<.main+8690 @064226> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8694 @06422a> : 24 c0 1c 06                store.m32 <@061cc0> ;f32Pls
	cmplStd/test/lang/useOperator.ci:240: (9 bytes: <.main+8698 @06422e> - <.main+8707 @064237>): static f32Neg: float32 := -f32B
	<.main+8698 @06422e> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8702 @064232> : 70                         neg.f32
	<.main+8703 @064233> : 24 c8 1c 06                store.m32 <@061cc8> ;f32Neg
	cmplStd/test/lang/useOperator.ci:242: (13 bytes: <.main+8707 @064237> - <.main+8720 @064244>): static f32Add: float32 := f32A + f32B
	<.main+8707 @064237> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8711 @06423b> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8715 @06423f> : 71                         add.f32
	<.main+8716 @064240> : 24 d0 1c 06                store.m32 <@061cd0> ;f32Add
	cmplStd/test/lang/useOperator.ci:243: (13 bytes: <.main+8720 @064244> - <.main+8733 @064251>): static f32Sub: float32 := f32A - f32B
	<.main+8720 @064244> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8724 @064248> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8728 @06424c> : 72                         sub.f32
	<.main+8729 @06424d> : 24 d8 1c 06                store.m32 <@061cd8> ;f32Sub
	cmplStd/test/lang/useOperator.ci:244: (13 bytes: <.main+8733 @064251> - <.main+8746 @06425e>): static f32Mul: float32 := f32A * f32B
	<.main+8733 @064251> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8737 @064255> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8741 @064259> : 73                         mul.f32
	<.main+8742 @06425a> : 24 e0 1c 06                store.m32 <@061ce0> ;f32Mul
	cmplStd/test/lang/useOperator.ci:245: (13 bytes: <.main+8746 @06425e> - <.main+8759 @06426b>): static f32Div: float32 := f32A / f32B
	<.main+8746 @06425e> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8750 @064262> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8754 @064266> : 74                         div.f32
	<.main+8755 @064267> : 24 e8 1c 06                store.m32 <@061ce8> ;f32Div
	cmplStd/test/lang/useOperator.ci:246: (13 bytes: <.main+8759 @06426b> - <.main+8772 @064278>): static f32Mod: float32 := f32A % f32B
	<.main+8759 @06426b> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8763 @06426f> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8767 @064273> : 75                         mod.f32
	<.main+8768 @064274> : 24 f0 1c 06                store.m32 <@061cf0> ;f32Mod
	cmplStd/test/lang/useOperator.ci:252: (12 bytes: <.main+8772 @064278> - <.main+8784 @064284>): static f32Not: bool := !(f32B)
	<.main+8772 @064278> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8776 @06427c> : 7c                         f32.2bool
	<.main+8777 @06427d> : 0b                         not.b32
	<.main+8778 @06427e> : 1f f8 1c 06 00             load.ref <@061cf8> ;f32Not
	<.main+8783 @064283> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:253: (15 bytes: <.main+8784 @064284> - <.main+8799 @064293>): static f32Ceq: bool := f32A == f32B
	<.main+8784 @064284> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8788 @064288> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8792 @06428c> : 77                         ceq.f32
	<.main+8793 @06428d> : 1f 00 1d 06 00             load.ref <@061d00> ;f32Ceq
	<.main+8798 @064292> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:254: (16 bytes: <.main+8799 @064293> - <.main+8815 @0642a3>): static f32Cne: bool := f32A != f32B
	<.main+8799 @064293> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8803 @064297> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8807 @06429b> : 77                         ceq.f32
	<.main+8808 @06429c> : 0b                         not.b32
	<.main+8809 @06429d> : 1f 08 1d 06 00             load.ref <@061d08> ;f32Cne
	<.main+8814 @0642a2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:255: (15 bytes: <.main+8815 @0642a3> - <.main+8830 @0642b2>): static f32Clt: bool := f32A < f32B
	<.main+8815 @0642a3> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8819 @0642a7> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8823 @0642ab> : 78                         clt.f32
	<.main+8824 @0642ac> : 1f 10 1d 06 00             load.ref <@061d10> ;f32Clt
	<.main+8829 @0642b1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:256: (16 bytes: <.main+8830 @0642b2> - <.main+8846 @0642c2>): static f32Cle: bool := f32A <= f32B
	<.main+8830 @0642b2> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8834 @0642b6> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8838 @0642ba> : 79                         cgt.f32
	<.main+8839 @0642bb> : 0b                         not.b32
	<.main+8840 @0642bc> : 1f 18 1d 06 00             load.ref <@061d18> ;f32Cle
	<.main+8845 @0642c1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:257: (15 bytes: <.main+8846 @0642c2> - <.main+8861 @0642d1>): static f32Cgt: bool := f32A > f32B
	<.main+8846 @0642c2> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8850 @0642c6> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8854 @0642ca> : 79                         cgt.f32
	<.main+8855 @0642cb> : 1f 20 1d 06 00             load.ref <@061d20> ;f32Cgt
	<.main+8860 @0642d0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:258: (16 bytes: <.main+8861 @0642d1> - <.main+8877 @0642e1>): static f32Cge: bool := f32A >= f32B
	<.main+8861 @0642d1> : 20 b0 1c 06                load.m32 <@061cb0> ;f32A
	<.main+8865 @0642d5> : 20 b8 1c 06                load.m32 <@061cb8> ;f32B
	<.main+8869 @0642d9> : 78                         clt.f32
	<.main+8870 @0642da> : 0b                         not.b32
	<.main+8871 @0642db> : 1f 28 1d 06 00             load.ref <@061d28> ;f32Cge
	<.main+8876 @0642e0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:260: (13 bytes: <.main+8877 @0642e1> - <.main+8890 @0642ee>): static f64A: float64 := a
	<.main+8877 @0642e1> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8886 @0642ea> : 23 30 1d 06                store.m64 <@061d30> ;f64A
	cmplStd/test/lang/useOperator.ci:261: (13 bytes: <.main+8890 @0642ee> - <.main+8903 @0642fb>): static f64B: float64 := b
	<.main+8890 @0642ee> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8899 @0642f7> : 23 38 1d 06                store.m64 <@061d38> ;f64B
	cmplStd/test/lang/useOperator.ci:262: (8 bytes: <.main+8903 @0642fb> - <.main+8911 @064303>): static f64Pls: float64 := +f64B
	<.main+8903 @0642fb> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8907 @0642ff> : 23 40 1d 06                store.m64 <@061d40> ;f64Pls
	cmplStd/test/lang/useOperator.ci:263: (9 bytes: <.main+8911 @064303> - <.main+8920 @06430c>): static f64Neg: float64 := -f64B
	<.main+8911 @064303> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8915 @064307> : 80                         neg.f64
	<.main+8916 @064308> : 23 48 1d 06                store.m64 <@061d48> ;f64Neg
	cmplStd/test/lang/useOperator.ci:265: (13 bytes: <.main+8920 @06430c> - <.main+8933 @064319>): static f64Add: float64 := f64A + f64B
	<.main+8920 @06430c> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+8924 @064310> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8928 @064314> : 81                         add.f64
	<.main+8929 @064315> : 23 50 1d 06                store.m64 <@061d50> ;f64Add
	cmplStd/test/lang/useOperator.ci:266: (13 bytes: <.main+8933 @064319> - <.main+8946 @064326>): static f64Sub: float64 := f64A - f64B
	<.main+8933 @064319> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+8937 @06431d> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8941 @064321> : 82                         sub.f64
	<.main+8942 @064322> : 23 58 1d 06                store.m64 <@061d58> ;f64Sub
	cmplStd/test/lang/useOperator.ci:267: (13 bytes: <.main+8946 @064326> - <.main+8959 @064333>): static f64Mul: float64 := f64A * f64B
	<.main+8946 @064326> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+8950 @06432a> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8954 @06432e> : 83                         mul.f64
	<.main+8955 @06432f> : 23 60 1d 06                store.m64 <@061d60> ;f64Mul
	cmplStd/test/lang/useOperator.ci:268: (13 bytes: <.main+8959 @064333> - <.main+8972 @064340>): static f64Div: float64 := f64A / f64B
	<.main+8959 @064333> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+8963 @064337> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8967 @06433b> : 84                         div.f64
	<.main+8968 @06433c> : 23 68 1d 06                store.m64 <@061d68> ;f64Div
	cmplStd/test/lang/useOperator.ci:269: (13 bytes: <.main+8972 @064340> - <.main+8985 @06434d>): static f64Mod: float64 := f64A % f64B
	<.main+8972 @064340> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+8976 @064344> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8980 @064348> : 85                         mod.f64
	<.main+8981 @064349> : 23 70 1d 06                store.m64 <@061d70> ;f64Mod
	cmplStd/test/lang/useOperator.ci:275: (12 bytes: <.main+8985 @06434d> - <.main+8997 @064359>): static f64Not: bool := !(f64B)
	<.main+8985 @06434d> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+8989 @064351> : 8d                         f64.2bool
	<.main+8990 @064352> : 0b                         not.b32
	<.main+8991 @064353> : 1f 78 1d 06 00             load.ref <@061d78> ;f64Not
	<.main+8996 @064358> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:276: (15 bytes: <.main+8997 @064359> - <.main+9012 @064368>): static f64Ceq: bool := f64A == f64B
	<.main+8997 @064359> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+9001 @06435d> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+9005 @064361> : 87                         ceq.f64
	<.main+9006 @064362> : 1f 80 1d 06 00             load.ref <@061d80> ;f64Ceq
	<.main+9011 @064367> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:277: (16 bytes: <.main+9012 @064368> - <.main+9028 @064378>): static f64Cne: bool := f64A != f64B
	<.main+9012 @064368> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+9016 @06436c> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+9020 @064370> : 87                         ceq.f64
	<.main+9021 @064371> : 0b                         not.b32
	<.main+9022 @064372> : 1f 88 1d 06 00             load.ref <@061d88> ;f64Cne
	<.main+9027 @064377> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:278: (15 bytes: <.main+9028 @064378> - <.main+9043 @064387>): static f64Clt: bool := f64A < f64B
	<.main+9028 @064378> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+9032 @06437c> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+9036 @064380> : 88                         clt.f64
	<.main+9037 @064381> : 1f 90 1d 06 00             load.ref <@061d90> ;f64Clt
	<.main+9042 @064386> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:279: (16 bytes: <.main+9043 @064387> - <.main+9059 @064397>): static f64Cle: bool := f64A <= f64B
	<.main+9043 @064387> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+9047 @06438b> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+9051 @06438f> : 89                         cgt.f64
	<.main+9052 @064390> : 0b                         not.b32
	<.main+9053 @064391> : 1f 98 1d 06 00             load.ref <@061d98> ;f64Cle
	<.main+9058 @064396> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:280: (15 bytes: <.main+9059 @064397> - <.main+9074 @0643a6>): static f64Cgt: bool := f64A > f64B
	<.main+9059 @064397> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+9063 @06439b> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+9067 @06439f> : 89                         cgt.f64
	<.main+9068 @0643a0> : 1f a0 1d 06 00             load.ref <@061da0> ;f64Cgt
	<.main+9073 @0643a5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:281: (16 bytes: <.main+9074 @0643a6> - <.main+9090 @0643b6>): static f64Cge: bool := f64A >= f64B
	<.main+9074 @0643a6> : 21 30 1d 06                load.m64 <@061d30> ;f64A
	<.main+9078 @0643aa> : 21 38 1d 06                load.m64 <@061d38> ;f64B
	<.main+9082 @0643ae> : 88                         clt.f64
	<.main+9083 @0643af> : 0b                         not.b32
	<.main+9084 @0643b0> : 1f a8 1d 06 00             load.ref <@061da8> ;f64Cge
	<.main+9089 @0643b5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:283: (9 bytes: <.main+9090 @0643b6> - <.main+9099 @0643bf>): static ptrA: pointer := null
	<.main+9090 @0643b6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+9095 @0643bb> : 24 b0 1d 06                store.m32 <@061db0> ;ptrA
	cmplStd/test/lang/useOperator.ci:284: (9 bytes: <.main+9099 @0643bf> - <.main+9108 @0643c8>): static ptrB: pointer := pointer(shift)
	<.main+9099 @0643bf> : 1f 18 16 06 00             load.ref <@061618> ;shift
	<.main+9104 @0643c4> : 24 b8 1d 06                store.m32 <@061db8> ;ptrB
	cmplStd/test/lang/useOperator.ci:299: (15 bytes: <.main+9108 @0643c8> - <.main+9123 @0643d7>): static ptrCeq: bool := ptrA == ptrB
	<.main+9108 @0643c8> : 20 b0 1d 06                load.m32 <@061db0> ;ptrA
	<.main+9112 @0643cc> : 20 b8 1d 06                load.m32 <@061db8> ;ptrB
	<.main+9116 @0643d0> : 57                         ceq.i32
	<.main+9117 @0643d1> : 1f c0 1d 06 00             load.ref <@061dc0> ;ptrCeq
	<.main+9122 @0643d6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:300: (16 bytes: <.main+9123 @0643d7> - <.main+9139 @0643e7>): static ptrCne: bool := ptrA != ptrB
	<.main+9123 @0643d7> : 20 b0 1d 06                load.m32 <@061db0> ;ptrA
	<.main+9127 @0643db> : 20 b8 1d 06                load.m32 <@061db8> ;ptrB
	<.main+9131 @0643df> : 57                         ceq.i32
	<.main+9132 @0643e0> : 0b                         not.b32
	<.main+9133 @0643e1> : 1f c8 1d 06 00             load.ref <@061dc8> ;ptrCne
	<.main+9138 @0643e6> : 2b                         store.i8
	cmplStd/test/lang/stmt.if.ci:26: (5 bytes: <.main+9139 @0643e7> - <.main+9144 @0643ec>): static t: int32 := 0
	<.main+9139 @0643e7> : 19                         load.z32
	<.main+9140 @0643e8> : 24 d0 1d 06                store.m32 <@061dd0> ;t
	cmplStd/test/lang/stmt.for.ci:12: (5 bytes: <.main+9144 @0643ec> - <.main+9149 @0643f1>): static forIdx: int32
	<.main+9144 @0643ec> : 19                         load.z32
	<.main+9145 @0643ed> : 24 d8 1d 06                store.m32 <@061dd8> ;forIdx
	cmplStd/test/std/test.math.ci:3: (24 bytes: <.main+9149 @0643f1> - <.main+9173 @064409>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9149 @0643f1> : 1a                         load.z64
	<.main+9150 @0643f2> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9159 @0643fb> : 1f 40 f8 05 00             load.ref <@05f840> ;Math.floor(x: float64): float64
	<.main+9164 @064400> : 02                         call
	<.main+9165 @064401> : 09 f8 ff ff                inc.sp(-8)
	<.main+9169 @064405> : 23 e0 1d 06                store.m64 <@061de0> ;testMathFloor_1
	cmplStd/test/std/test.math.ci:4: (24 bytes: <.main+9173 @064409> - <.main+9197 @064421>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9173 @064409> : 1a                         load.z64
	<.main+9174 @06440a> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9183 @064413> : 1f 40 f8 05 00             load.ref <@05f840> ;Math.floor(x: float64): float64
	<.main+9188 @064418> : 02                         call
	<.main+9189 @064419> : 09 f8 ff ff                inc.sp(-8)
	<.main+9193 @06441d> : 23 e8 1d 06                store.m64 <@061de8> ;testMathFloor_2
	cmplStd/test/std/test.math.ci:5: (24 bytes: <.main+9197 @064421> - <.main+9221 @064439>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9197 @064421> : 1a                         load.z64
	<.main+9198 @064422> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9207 @06442b> : 1f 40 f8 05 00             load.ref <@05f840> ;Math.floor(x: float64): float64
	<.main+9212 @064430> : 02                         call
	<.main+9213 @064431> : 09 f8 ff ff                inc.sp(-8)
	<.main+9217 @064435> : 23 f0 1d 06                store.m64 <@061df0> ;testMathFloor_3
	cmplStd/test/std/test.math.ci:6: (24 bytes: <.main+9221 @064439> - <.main+9245 @064451>): static testMathFloor_4: float64 := Math.floor(-3.200000)
	<.main+9221 @064439> : 1a                         load.z64
	<.main+9222 @06443a> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9231 @064443> : 1f 40 f8 05 00             load.ref <@05f840> ;Math.floor(x: float64): float64
	<.main+9236 @064448> : 02                         call
	<.main+9237 @064449> : 09 f8 ff ff                inc.sp(-8)
	<.main+9241 @06444d> : 23 f8 1d 06                store.m64 <@061df8> ;testMathFloor_4
	cmplStd/test/std/test.math.ci:7: (24 bytes: <.main+9245 @064451> - <.main+9269 @064469>): static testMathFloor_5: float64 := Math.floor(-3.500000)
	<.main+9245 @064451> : 1a                         load.z64
	<.main+9246 @064452> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9255 @06445b> : 1f 40 f8 05 00             load.ref <@05f840> ;Math.floor(x: float64): float64
	<.main+9260 @064460> : 02                         call
	<.main+9261 @064461> : 09 f8 ff ff                inc.sp(-8)
	<.main+9265 @064465> : 23 00 1e 06                store.m64 <@061e00> ;testMathFloor_5
	cmplStd/test/std/test.math.ci:8: (24 bytes: <.main+9269 @064469> - <.main+9293 @064481>): static testMathFloor_6: float64 := Math.floor(-3.600000)
	<.main+9269 @064469> : 1a                         load.z64
	<.main+9270 @06446a> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9279 @064473> : 1f 40 f8 05 00             load.ref <@05f840> ;Math.floor(x: float64): float64
	<.main+9284 @064478> : 02                         call
	<.main+9285 @064479> : 09 f8 ff ff                inc.sp(-8)
	<.main+9289 @06447d> : 23 08 1e 06                store.m64 <@061e08> ;testMathFloor_6
	cmplStd/test/std/test.math.ci:10: (29 bytes: <.main+9293 @064481> - <.main+9322 @06449e>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9293 @064481> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9302 @06448a> : 11 00                      dup.x64 sp(0)
	<.main+9304 @06448c> : 1a                         load.z64
	<.main+9305 @06448d> : 89                         cgt.f64
	<.main+9306 @06448e> : 11 01                      dup.x64 sp(1)
	<.main+9308 @064490> : 1a                         load.z64
	<.main+9309 @064491> : 88                         clt.f64
	<.main+9310 @064492> : 52                         sub.i32
	<.main+9311 @064493> : 13 02                      set.x32 sp(2)
	<.main+9313 @064495> : 09 fc ff ff                inc.sp(-4)
	<.main+9317 @064499> : 5d                         i32.2f64
	<.main+9318 @06449a> : 23 10 1e 06                store.m64 <@061e10> ;testMathSign_1F
	cmplStd/test/std/test.math.ci:11: (21 bytes: <.main+9322 @06449e> - <.main+9343 @0644b3>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9322 @06449e> : 1a                         load.z64
	<.main+9323 @06449f> : 11 00                      dup.x64 sp(0)
	<.main+9325 @0644a1> : 1a                         load.z64
	<.main+9326 @0644a2> : 89                         cgt.f64
	<.main+9327 @0644a3> : 11 01                      dup.x64 sp(1)
	<.main+9329 @0644a5> : 1a                         load.z64
	<.main+9330 @0644a6> : 88                         clt.f64
	<.main+9331 @0644a7> : 52                         sub.i32
	<.main+9332 @0644a8> : 13 02                      set.x32 sp(2)
	<.main+9334 @0644aa> : 09 fc ff ff                inc.sp(-4)
	<.main+9338 @0644ae> : 5d                         i32.2f64
	<.main+9339 @0644af> : 23 18 1e 06                store.m64 <@061e18> ;testMathSign_2F
	cmplStd/test/std/test.math.ci:12: (29 bytes: <.main+9343 @0644b3> - <.main+9372 @0644d0>): static testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+9343 @0644b3> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9352 @0644bc> : 11 00                      dup.x64 sp(0)
	<.main+9354 @0644be> : 1a                         load.z64
	<.main+9355 @0644bf> : 89                         cgt.f64
	<.main+9356 @0644c0> : 11 01                      dup.x64 sp(1)
	<.main+9358 @0644c2> : 1a                         load.z64
	<.main+9359 @0644c3> : 88                         clt.f64
	<.main+9360 @0644c4> : 52                         sub.i32
	<.main+9361 @0644c5> : 13 02                      set.x32 sp(2)
	<.main+9363 @0644c7> : 09 fc ff ff                inc.sp(-4)
	<.main+9367 @0644cb> : 5d                         i32.2f64
	<.main+9368 @0644cc> : 23 20 1e 06                store.m64 <@061e20> ;testMathSign_3F
	cmplStd/test/std/test.math.ci:13: (21 bytes: <.main+9372 @0644d0> - <.main+9393 @0644e5>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9372 @0644d0> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9377 @0644d5> : 10 00                      dup.x32 sp(0)
	<.main+9379 @0644d7> : 19                         load.z32
	<.main+9380 @0644d8> : 79                         cgt.f32
	<.main+9381 @0644d9> : 10 01                      dup.x32 sp(1)
	<.main+9383 @0644db> : 19                         load.z32
	<.main+9384 @0644dc> : 78                         clt.f32
	<.main+9385 @0644dd> : 52                         sub.i32
	<.main+9386 @0644de> : 13 01                      set.x32 sp(1)
	<.main+9388 @0644e0> : 5d                         i32.2f64
	<.main+9389 @0644e1> : 23 28 1e 06                store.m64 <@061e28> ;testMathSign_1f
	cmplStd/test/std/test.math.ci:14: (17 bytes: <.main+9393 @0644e5> - <.main+9410 @0644f6>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9393 @0644e5> : 19                         load.z32
	<.main+9394 @0644e6> : 10 00                      dup.x32 sp(0)
	<.main+9396 @0644e8> : 19                         load.z32
	<.main+9397 @0644e9> : 79                         cgt.f32
	<.main+9398 @0644ea> : 10 01                      dup.x32 sp(1)
	<.main+9400 @0644ec> : 19                         load.z32
	<.main+9401 @0644ed> : 78                         clt.f32
	<.main+9402 @0644ee> : 52                         sub.i32
	<.main+9403 @0644ef> : 13 01                      set.x32 sp(1)
	<.main+9405 @0644f1> : 5d                         i32.2f64
	<.main+9406 @0644f2> : 23 30 1e 06                store.m64 <@061e30> ;testMathSign_2f
	cmplStd/test/std/test.math.ci:15: (21 bytes: <.main+9410 @0644f6> - <.main+9431 @06450b>): static testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+9410 @0644f6> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9415 @0644fb> : 10 00                      dup.x32 sp(0)
	<.main+9417 @0644fd> : 19                         load.z32
	<.main+9418 @0644fe> : 79                         cgt.f32
	<.main+9419 @0644ff> : 10 01                      dup.x32 sp(1)
	<.main+9421 @064501> : 19                         load.z32
	<.main+9422 @064502> : 78                         clt.f32
	<.main+9423 @064503> : 52                         sub.i32
	<.main+9424 @064504> : 13 01                      set.x32 sp(1)
	<.main+9426 @064506> : 5d                         i32.2f64
	<.main+9427 @064507> : 23 38 1e 06                store.m64 <@061e38> ;testMathSign_3f
	cmplStd/test/std/test.math.ci:17: (32 bytes: <.main+9431 @06450b> - <.main+9463 @06452b>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9431 @06450b> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9440 @064514> : 11 00                      dup.x64 sp(0)
	<.main+9442 @064516> : 1a                         load.z64
	<.main+9443 @064517> : 88                         clt.f64
	<.main+9444 @064518> : 06 0b 00 00                jz <.main+9455 @064523>
	<.main+9448 @06451c> : 11 00                      dup.x64 sp(0)
	<.main+9450 @06451e> : 80                         neg.f64
	<.main+9451 @06451f> : 04 06 00 00                jmp <.main+9457 @064525>
	<.main+9455 @064523> : 11 00                      dup.x64 sp(0)
	<.main+9457 @064525> : 14 02                      set.x64 sp(2)
	<.main+9459 @064527> : 23 40 1e 06                store.m64 <@061e40> ;testMathAbs_1F
	cmplStd/test/std/test.math.ci:18: (24 bytes: <.main+9463 @06452b> - <.main+9487 @064543>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9463 @06452b> : 1a                         load.z64
	<.main+9464 @06452c> : 11 00                      dup.x64 sp(0)
	<.main+9466 @06452e> : 1a                         load.z64
	<.main+9467 @06452f> : 88                         clt.f64
	<.main+9468 @064530> : 06 0b 00 00                jz <.main+9479 @06453b>
	<.main+9472 @064534> : 11 00                      dup.x64 sp(0)
	<.main+9474 @064536> : 80                         neg.f64
	<.main+9475 @064537> : 04 06 00 00                jmp <.main+9481 @06453d>
	<.main+9479 @06453b> : 11 00                      dup.x64 sp(0)
	<.main+9481 @06453d> : 14 02                      set.x64 sp(2)
	<.main+9483 @06453f> : 23 48 1e 06                store.m64 <@061e48> ;testMathAbs_2F
	cmplStd/test/std/test.math.ci:19: (32 bytes: <.main+9487 @064543> - <.main+9519 @064563>): static testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+9487 @064543> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9496 @06454c> : 11 00                      dup.x64 sp(0)
	<.main+9498 @06454e> : 1a                         load.z64
	<.main+9499 @06454f> : 88                         clt.f64
	<.main+9500 @064550> : 06 0b 00 00                jz <.main+9511 @06455b>
	<.main+9504 @064554> : 11 00                      dup.x64 sp(0)
	<.main+9506 @064556> : 80                         neg.f64
	<.main+9507 @064557> : 04 06 00 00                jmp <.main+9513 @06455d>
	<.main+9511 @06455b> : 11 00                      dup.x64 sp(0)
	<.main+9513 @06455d> : 14 02                      set.x64 sp(2)
	<.main+9515 @06455f> : 23 50 1e 06                store.m64 <@061e50> ;testMathAbs_3F
	cmplStd/test/std/test.math.ci:20: (29 bytes: <.main+9519 @064563> - <.main+9548 @064580>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9519 @064563> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9524 @064568> : 10 00                      dup.x32 sp(0)
	<.main+9526 @06456a> : 19                         load.z32
	<.main+9527 @06456b> : 78                         clt.f32
	<.main+9528 @06456c> : 06 0b 00 00                jz <.main+9539 @064577>
	<.main+9532 @064570> : 10 00                      dup.x32 sp(0)
	<.main+9534 @064572> : 70                         neg.f32
	<.main+9535 @064573> : 04 06 00 00                jmp <.main+9541 @064579>
	<.main+9539 @064577> : 10 00                      dup.x32 sp(0)
	<.main+9541 @064579> : 13 01                      set.x32 sp(1)
	<.main+9543 @06457b> : 7d                         f32.2f64
	<.main+9544 @06457c> : 23 58 1e 06                store.m64 <@061e58> ;testMathAbs_1f
	cmplStd/test/std/test.math.ci:21: (25 bytes: <.main+9548 @064580> - <.main+9573 @064599>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9548 @064580> : 19                         load.z32
	<.main+9549 @064581> : 10 00                      dup.x32 sp(0)
	<.main+9551 @064583> : 19                         load.z32
	<.main+9552 @064584> : 78                         clt.f32
	<.main+9553 @064585> : 06 0b 00 00                jz <.main+9564 @064590>
	<.main+9557 @064589> : 10 00                      dup.x32 sp(0)
	<.main+9559 @06458b> : 70                         neg.f32
	<.main+9560 @06458c> : 04 06 00 00                jmp <.main+9566 @064592>
	<.main+9564 @064590> : 10 00                      dup.x32 sp(0)
	<.main+9566 @064592> : 13 01                      set.x32 sp(1)
	<.main+9568 @064594> : 7d                         f32.2f64
	<.main+9569 @064595> : 23 60 1e 06                store.m64 <@061e60> ;testMathAbs_2f
	cmplStd/test/std/test.math.ci:22: (29 bytes: <.main+9573 @064599> - <.main+9602 @0645b6>): static testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+9573 @064599> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9578 @06459e> : 10 00                      dup.x32 sp(0)
	<.main+9580 @0645a0> : 19                         load.z32
	<.main+9581 @0645a1> : 78                         clt.f32
	<.main+9582 @0645a2> : 06 0b 00 00                jz <.main+9593 @0645ad>
	<.main+9586 @0645a6> : 10 00                      dup.x32 sp(0)
	<.main+9588 @0645a8> : 70                         neg.f32
	<.main+9589 @0645a9> : 04 06 00 00                jmp <.main+9595 @0645af>
	<.main+9593 @0645ad> : 10 00                      dup.x32 sp(0)
	<.main+9595 @0645af> : 13 01                      set.x32 sp(1)
	<.main+9597 @0645b1> : 7d                         f32.2f64
	<.main+9598 @0645b2> : 23 68 1e 06                store.m64 <@061e68> ;testMathAbs_3f
	cmplStd/test/std/test.math.ci:24: (38 bytes: <.main+9602 @0645b6> - <.main+9640 @0645dc>): static testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+9602 @0645b6> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9607 @0645bb> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9612 @0645c0> : 10 01                      dup.x32 sp(1)
	<.main+9614 @0645c2> : 10 01                      dup.x32 sp(1)
	<.main+9616 @0645c4> : 78                         clt.f32
	<.main+9617 @0645c5> : 06 0a 00 00                jz <.main+9627 @0645cf>
	<.main+9621 @0645c9> : 10 01                      dup.x32 sp(1)
	<.main+9623 @0645cb> : 04 06 00 00                jmp <.main+9629 @0645d1>
	<.main+9627 @0645cf> : 10 00                      dup.x32 sp(0)
	<.main+9629 @0645d1> : 13 02                      set.x32 sp(2)
	<.main+9631 @0645d3> : 09 fc ff ff                inc.sp(-4)
	<.main+9635 @0645d7> : 7d                         f32.2f64
	<.main+9636 @0645d8> : 23 70 1e 06                store.m64 <@061e70> ;testMathMin_1f
	cmplStd/test/std/test.math.ci:25: (38 bytes: <.main+9640 @0645dc> - <.main+9678 @064602>): static testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+9640 @0645dc> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9645 @0645e1> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9650 @0645e6> : 10 01                      dup.x32 sp(1)
	<.main+9652 @0645e8> : 10 01                      dup.x32 sp(1)
	<.main+9654 @0645ea> : 79                         cgt.f32
	<.main+9655 @0645eb> : 06 0a 00 00                jz <.main+9665 @0645f5>
	<.main+9659 @0645ef> : 10 01                      dup.x32 sp(1)
	<.main+9661 @0645f1> : 04 06 00 00                jmp <.main+9667 @0645f7>
	<.main+9665 @0645f5> : 10 00                      dup.x32 sp(0)
	<.main+9667 @0645f7> : 13 02                      set.x32 sp(2)
	<.main+9669 @0645f9> : 09 fc ff ff                inc.sp(-4)
	<.main+9673 @0645fd> : 7d                         f32.2f64
	<.main+9674 @0645fe> : 23 78 1e 06                store.m64 <@061e78> ;testMathMax_2f
	cmplStd/test/std/test.math.ci:26: (45 bytes: <.main+9678 @064602> - <.main+9723 @06462f>): static testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+9678 @064602> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9687 @06460b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9696 @064614> : 11 02                      dup.x64 sp(2)
	<.main+9698 @064616> : 11 02                      dup.x64 sp(2)
	<.main+9700 @064618> : 88                         clt.f64
	<.main+9701 @064619> : 06 0a 00 00                jz <.main+9711 @064623>
	<.main+9705 @06461d> : 11 02                      dup.x64 sp(2)
	<.main+9707 @06461f> : 04 06 00 00                jmp <.main+9713 @064625>
	<.main+9711 @064623> : 11 00                      dup.x64 sp(0)
	<.main+9713 @064625> : 14 04                      set.x64 sp(4)
	<.main+9715 @064627> : 09 f8 ff ff                inc.sp(-8)
	<.main+9719 @06462b> : 23 80 1e 06                store.m64 <@061e80> ;testMathMin_1F
	cmplStd/test/std/test.math.ci:27: (45 bytes: <.main+9723 @06462f> - <.main+9768 @06465c>): static testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+9723 @06462f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9732 @064638> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9741 @064641> : 11 02                      dup.x64 sp(2)
	<.main+9743 @064643> : 11 02                      dup.x64 sp(2)
	<.main+9745 @064645> : 89                         cgt.f64
	<.main+9746 @064646> : 06 0a 00 00                jz <.main+9756 @064650>
	<.main+9750 @06464a> : 11 02                      dup.x64 sp(2)
	<.main+9752 @06464c> : 04 06 00 00                jmp <.main+9758 @064652>
	<.main+9756 @064650> : 11 00                      dup.x64 sp(0)
	<.main+9758 @064652> : 14 04                      set.x64 sp(4)
	<.main+9760 @064654> : 09 f8 ff ff                inc.sp(-8)
	<.main+9764 @064658> : 23 88 1e 06                store.m64 <@061e88> ;testMathMax_2F
	cmplStd/test/std/test.math.ci:29: (27 bytes: <.main+9768 @06465c> - <.main+9795 @064677>): static testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9768 @06465c> : 19                         load.z32
	<.main+9769 @06465d> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9774 @064662> : 19                         load.z32
	<.main+9775 @064663> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9780 @064668> : 1f 98 f8 05 00             load.ref <@05f898> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9785 @06466d> : 02                         call
	<.main+9786 @06466e> : 09 f4 ff ff                inc.sp(-12)
	<.main+9790 @064672> : 7d                         f32.2f64
	<.main+9791 @064673> : 23 90 1e 06                store.m64 <@061e90> ;testMathClamp_1f
	cmplStd/test/std/test.math.ci:30: (34 bytes: <.main+9795 @064677> - <.main+9829 @064699>): static testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9795 @064677> : 1a                         load.z64
	<.main+9796 @064678> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9805 @064681> : 1a                         load.z64
	<.main+9806 @064682> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9815 @06468b> : 1f b8 f8 05 00             load.ref <@05f8b8> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9820 @064690> : 02                         call
	<.main+9821 @064691> : 09 e8 ff ff                inc.sp(-24)
	<.main+9825 @064695> : 23 98 1e 06                store.m64 <@061e98> ;testMathClamp_1F
	cmplStd/test/std/test.math.ci:32: (25 bytes: <.main+9829 @064699> - <.main+9854 @0646b2>): static testMathLerp_1f: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9829 @064699> : 19                         load.z32
	<.main+9830 @06469a> : 10 00                      dup.x32 sp(0)
	<.main+9832 @06469c> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9837 @0646a1> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9842 @0646a6> : 10 03                      dup.x32 sp(3)
	<.main+9844 @0646a8> : 72                         sub.f32
	<.main+9845 @0646a9> : 73                         mul.f32
	<.main+9846 @0646aa> : 71                         add.f32
	<.main+9847 @0646ab> : 13 01                      set.x32 sp(1)
	<.main+9849 @0646ad> : 7d                         f32.2f64
	<.main+9850 @0646ae> : 23 a0 1e 06                store.m64 <@061ea0> ;testMathLerp_1f
	cmplStd/test/std/test.math.ci:33: (32 bytes: <.main+9854 @0646b2> - <.main+9886 @0646d2>): static testMathLerp_1F: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9854 @0646b2> : 1a                         load.z64
	<.main+9855 @0646b3> : 11 00                      dup.x64 sp(0)
	<.main+9857 @0646b5> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9866 @0646be> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9875 @0646c7> : 11 06                      dup.x64 sp(6)
	<.main+9877 @0646c9> : 82                         sub.f64
	<.main+9878 @0646ca> : 83                         mul.f64
	<.main+9879 @0646cb> : 81                         add.f64
	<.main+9880 @0646cc> : 14 02                      set.x64 sp(2)
	<.main+9882 @0646ce> : 23 a8 1e 06                store.m64 <@061ea8> ;testMathLerp_1F
	cmplStd/test/std/test.math.ci:35: (64 bytes: <.main+9886 @0646d2> - <.main+9950 @064712>): static testMathSmooth_1f: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+9886 @0646d2> : 19                         load.z32
	<.main+9887 @0646d3> : 19                         load.z32
	<.main+9888 @0646d4> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9893 @0646d9> : 10 02                      dup.x32 sp(2)
	<.main+9895 @0646db> : 72                         sub.f32
	<.main+9896 @0646dc> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9901 @0646e1> : 10 03                      dup.x32 sp(3)
	<.main+9903 @0646e3> : 72                         sub.f32
	<.main+9904 @0646e4> : 74                         div.f32
	<.main+9905 @0646e5> : 19                         load.z32
	<.main+9906 @0646e6> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9911 @0646eb> : 1f 98 f8 05 00             load.ref <@05f898> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9916 @0646f0> : 02                         call
	<.main+9917 @0646f1> : 09 f4 ff ff                inc.sp(-12)
	<.main+9921 @0646f5> : 10 00                      dup.x32 sp(0)
	<.main+9923 @0646f7> : 10 01                      dup.x32 sp(1)
	<.main+9925 @0646f9> : 73                         mul.f32
	<.main+9926 @0646fa> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9931 @0646ff> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9936 @064704> : 10 03                      dup.x32 sp(3)
	<.main+9938 @064706> : 73                         mul.f32
	<.main+9939 @064707> : 72                         sub.f32
	<.main+9940 @064708> : 73                         mul.f32
	<.main+9941 @064709> : 13 01                      set.x32 sp(1)
	<.main+9943 @06470b> : 13 01                      set.x32 sp(1)
	<.main+9945 @06470d> : 7d                         f32.2f64
	<.main+9946 @06470e> : 23 b0 1e 06                store.m64 <@061eb0> ;testMathSmooth_1f
	cmplStd/test/std/test.math.ci:36: (82 bytes: <.main+9950 @064712> - <.main+10032 @064764>): static testMathSmooth_1F: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+9950 @064712> : 1b                         load.z128
	<.main+9951 @064713> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9960 @06471c> : 11 04                      dup.x64 sp(4)
	<.main+9962 @06471e> : 82                         sub.f64
	<.main+9963 @06471f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9972 @064728> : 11 06                      dup.x64 sp(6)
	<.main+9974 @06472a> : 82                         sub.f64
	<.main+9975 @06472b> : 84                         div.f64
	<.main+9976 @06472c> : 1a                         load.z64
	<.main+9977 @06472d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9986 @064736> : 1f b8 f8 05 00             load.ref <@05f8b8> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9991 @06473b> : 02                         call
	<.main+9992 @06473c> : 09 e8 ff ff                inc.sp(-24)
	<.main+9996 @064740> : 11 00                      dup.x64 sp(0)
	<.main+9998 @064742> : 11 02                      dup.x64 sp(2)
	<.main+10000 @064744>: 83                         mul.f64
	<.main+10001 @064745>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10010 @06474e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10019 @064757>: 11 06                      dup.x64 sp(6)
	<.main+10021 @064759>: 83                         mul.f64
	<.main+10022 @06475a>: 82                         sub.f64
	<.main+10023 @06475b>: 83                         mul.f64
	<.main+10024 @06475c>: 14 02                      set.x64 sp(2)
	<.main+10026 @06475e>: 14 02                      set.x64 sp(2)
	<.main+10028 @064760>: 23 b8 1e 06                store.m64 <@061eb8> ;testMathSmooth_1F
	cmplStd/test/std/test.math.ci:38: (25 bytes: <.main+10032 @064764> - <.main+10057 @06477d>): static testMathMin_nan: float64 := Math.min()
	<.main+10032 @064764>: 19                         load.z32
	<.main+10033 @064765>: 0a 04 00 00                load.sp(+4)
	<.main+10037 @064769>: 1a                         load.z64
	<.main+10038 @06476a>: 11 02                      dup.x64 sp(2)
	<.main+10040 @06476c>: 1f d8 f8 05 00             load.ref <@05f8d8> ;Math.min(data: float64[]): float64
	<.main+10045 @064771>: 02                         call
	<.main+10046 @064772>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10049 @064775>: 09 f0 ff ff                inc.sp(-16)
	<.main+10053 @064779>: 23 c0 1e 06                store.m64 <@061ec0> ;testMathMin_nan
	cmplStd/test/std/test.math.ci:39: (110 bytes: <.main+10057 @06477d> - <.main+10167 @0647eb>): static testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10057 @06477d>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10066 @064786>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10075 @06478f>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10084 @064798>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10093 @0647a1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10102 @0647aa>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10111 @0647b3>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10120 @0647bc>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10129 @0647c5>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10138 @0647ce>: 1c 09 00 00 00             load.c32 9
	<.main+10143 @0647d3>: 0a 04 00 00                load.sp(+4)
	<.main+10147 @0647d7>: 1a                         load.z64
	<.main+10148 @0647d8>: 11 02                      dup.x64 sp(2)
	<.main+10150 @0647da>: 1f d8 f8 05 00             load.ref <@05f8d8> ;Math.min(data: float64[]): float64
	<.main+10155 @0647df>: 02                         call
	<.main+10156 @0647e0>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10159 @0647e3>: 09 a8 ff ff                inc.sp(-88)
	<.main+10163 @0647e7>: 23 c8 1e 06                store.m64 <@061ec8> ;testMathMin_1
	cmplStd/test/std/test.math.ci:40: (25 bytes: <.main+10167 @0647eb> - <.main+10192 @064804>): static testMathMax_nan: float64 := Math.max()
	<.main+10167 @0647eb>: 19                         load.z32
	<.main+10168 @0647ec>: 0a 04 00 00                load.sp(+4)
	<.main+10172 @0647f0>: 1a                         load.z64
	<.main+10173 @0647f1>: 11 02                      dup.x64 sp(2)
	<.main+10175 @0647f3>: 1f 28 f9 05 00             load.ref <@05f928> ;Math.max(data: float64[]): float64
	<.main+10180 @0647f8>: 02                         call
	<.main+10181 @0647f9>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10184 @0647fc>: 09 f0 ff ff                inc.sp(-16)
	<.main+10188 @064800>: 23 d0 1e 06                store.m64 <@061ed0> ;testMathMax_nan
	cmplStd/test/std/test.math.ci:41: (110 bytes: <.main+10192 @064804> - <.main+10302 @064872>): static testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10192 @064804>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10201 @06480d>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10210 @064816>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10219 @06481f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10228 @064828>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10237 @064831>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10246 @06483a>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10255 @064843>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10264 @06484c>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10273 @064855>: 1c 09 00 00 00             load.c32 9
	<.main+10278 @06485a>: 0a 04 00 00                load.sp(+4)
	<.main+10282 @06485e>: 1a                         load.z64
	<.main+10283 @06485f>: 11 02                      dup.x64 sp(2)
	<.main+10285 @064861>: 1f 28 f9 05 00             load.ref <@05f928> ;Math.max(data: float64[]): float64
	<.main+10290 @064866>: 02                         call
	<.main+10291 @064867>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10294 @06486a>: 09 a8 ff ff                inc.sp(-88)
	<.main+10298 @06486e>: 23 d8 1e 06                store.m64 <@061ed8> ;testMathMax_9
	cmplStd/test/std/test.math.ci:43: (25 bytes: <.main+10302 @064872> - <.main+10327 @06488b>): static testMathSum_0: float64 := Math.sum()
	<.main+10302 @064872>: 19                         load.z32
	<.main+10303 @064873>: 0a 04 00 00                load.sp(+4)
	<.main+10307 @064877>: 1a                         load.z64
	<.main+10308 @064878>: 11 02                      dup.x64 sp(2)
	<.main+10310 @06487a>: 1f 78 f9 05 00             load.ref <@05f978> ;Math.sum(data: float64[]): float64
	<.main+10315 @06487f>: 02                         call
	<.main+10316 @064880>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10319 @064883>: 09 f0 ff ff                inc.sp(-16)
	<.main+10323 @064887>: 23 e0 1e 06                store.m64 <@061ee0> ;testMathSum_0
	cmplStd/test/std/test.math.ci:44: (38 bytes: <.main+10327 @06488b> - <.main+10365 @0648b1>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10327 @06488b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10336 @064894>: 1c 01 00 00 00             load.c32 1
	<.main+10341 @064899>: 0a 04 00 00                load.sp(+4)
	<.main+10345 @06489d>: 1a                         load.z64
	<.main+10346 @06489e>: 11 02                      dup.x64 sp(2)
	<.main+10348 @0648a0>: 1f 78 f9 05 00             load.ref <@05f978> ;Math.sum(data: float64[]): float64
	<.main+10353 @0648a5>: 02                         call
	<.main+10354 @0648a6>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10357 @0648a9>: 09 e8 ff ff                inc.sp(-24)
	<.main+10361 @0648ad>: 23 e8 1e 06                store.m64 <@061ee8> ;testMathSum_1
	cmplStd/test/std/test.math.ci:45: (47 bytes: <.main+10365 @0648b1> - <.main+10412 @0648e0>): static testMathSum_3: float64 := Math.sum(1, 2)
	<.main+10365 @0648b1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10374 @0648ba>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10383 @0648c3>: 1c 02 00 00 00             load.c32 2
	<.main+10388 @0648c8>: 0a 04 00 00                load.sp(+4)
	<.main+10392 @0648cc>: 1a                         load.z64
	<.main+10393 @0648cd>: 11 02                      dup.x64 sp(2)
	<.main+10395 @0648cf>: 1f 78 f9 05 00             load.ref <@05f978> ;Math.sum(data: float64[]): float64
	<.main+10400 @0648d4>: 02                         call
	<.main+10401 @0648d5>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10404 @0648d8>: 09 e0 ff ff                inc.sp(-32)
	<.main+10408 @0648dc>: 23 f0 1e 06                store.m64 <@061ef0> ;testMathSum_3
	cmplStd/test/std/test.math.ci:46: (119 bytes: <.main+10412 @0648e0> - <.main+10531 @064957>): static testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+10412 @0648e0>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10421 @0648e9>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10430 @0648f2>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10439 @0648fb>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10448 @064904>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10457 @06490d>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10466 @064916>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10475 @06491f>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10484 @064928>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10493 @064931>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10502 @06493a>: 1c 0a 00 00 00             load.c32 10
	<.main+10507 @06493f>: 0a 04 00 00                load.sp(+4)
	<.main+10511 @064943>: 1a                         load.z64
	<.main+10512 @064944>: 11 02                      dup.x64 sp(2)
	<.main+10514 @064946>: 1f 78 f9 05 00             load.ref <@05f978> ;Math.sum(data: float64[]): float64
	<.main+10519 @06494b>: 02                         call
	<.main+10520 @06494c>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10523 @06494f>: 09 a0 ff ff                inc.sp(-96)
	<.main+10527 @064953>: 23 f8 1e 06                store.m64 <@061ef8> ;testMathSum_55
	cmplStd/test/std/test.math.ci:48: (13 bytes: <.main+10531 @064957> - <.main+10544 @064964>): static testMathEval_x: float64 := 10
	<.main+10531 @064957>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10540 @064960>: 23 00 1f 06                store.m64 <@061f00> ;testMathEval_x
	cmplStd/test/std/test.math.ci:49: (29 bytes: <.main+10544 @064964> - <.main+10573 @064981>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10544 @064964>: 19                         load.z32
	<.main+10545 @064965>: 0a 04 00 00                load.sp(+4)
	<.main+10549 @064969>: 1a                         load.z64
	<.main+10550 @06496a>: 21 00 1f 06                load.m64 <@061f00> ;testMathEval_x
	<.main+10554 @06496e>: 11 04                      dup.x64 sp(4)
	<.main+10556 @064970>: 1f b8 f9 05 00             load.ref <@05f9b8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10561 @064975>: 02                         call
	<.main+10562 @064976>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10565 @064979>: 09 e8 ff ff                inc.sp(-24)
	<.main+10569 @06497d>: 23 08 1f 06                store.m64 <@061f08> ;testMathEval_0
	cmplStd/test/std/test.math.ci:50: (13 bytes: <.main+10573 @064981> - <.main+10586 @06498e>): static testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+10573 @064981>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10582 @06498a>: 23 10 1f 06                store.m64 <@061f10> ;testMathEval_1
	cmplStd/test/std/test.math.ci:51: (28 bytes: <.main+10586 @06498e> - <.main+10614 @0649aa>): static testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+10586 @06498e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10595 @064997>: 21 00 1f 06                load.m64 <@061f00> ;testMathEval_x
	<.main+10599 @06499b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10608 @0649a4>: 83                         mul.f64
	<.main+10609 @0649a5>: 81                         add.f64
	<.main+10610 @0649a6>: 23 18 1f 06                store.m64 <@061f18> ;testMathEval_2
	cmplStd/test/std/test.math.ci:52: (45 bytes: <.main+10614 @0649aa> - <.main+10659 @0649d7>): static testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+10614 @0649aa>: 21 00 1f 06                load.m64 <@061f00> ;testMathEval_x
	<.main+10618 @0649ae>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10627 @0649b7>: 11 02                      dup.x64 sp(2)
	<.main+10629 @0649b9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10638 @0649c2>: 11 06                      dup.x64 sp(6)
	<.main+10640 @0649c4>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10649 @0649cd>: 83                         mul.f64
	<.main+10650 @0649ce>: 81                         add.f64
	<.main+10651 @0649cf>: 83                         mul.f64
	<.main+10652 @0649d0>: 81                         add.f64
	<.main+10653 @0649d1>: 14 02                      set.x64 sp(2)
	<.main+10655 @0649d3>: 23 20 1f 06                store.m64 <@061f20> ;testMathEval_3
	cmplStd/test/std/test.math.ci:53: (62 bytes: <.main+10659 @0649d7> - <.main+10721 @064a15>): static testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10659 @0649d7>: 21 00 1f 06                load.m64 <@061f00> ;testMathEval_x
	<.main+10663 @0649db>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10672 @0649e4>: 11 02                      dup.x64 sp(2)
	<.main+10674 @0649e6>: 11 04                      dup.x64 sp(4)
	<.main+10676 @0649e8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10685 @0649f1>: 11 02                      dup.x64 sp(2)
	<.main+10687 @0649f3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10696 @0649fc>: 11 06                      dup.x64 sp(6)
	<.main+10698 @0649fe>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10707 @064a07>: 83                         mul.f64
	<.main+10708 @064a08>: 81                         add.f64
	<.main+10709 @064a09>: 83                         mul.f64
	<.main+10710 @064a0a>: 81                         add.f64
	<.main+10711 @064a0b>: 14 02                      set.x64 sp(2)
	<.main+10713 @064a0d>: 83                         mul.f64
	<.main+10714 @064a0e>: 81                         add.f64
	<.main+10715 @064a0f>: 14 02                      set.x64 sp(2)
	<.main+10717 @064a11>: 23 28 1f 06                store.m64 <@061f28> ;testMathEval_4
	cmplStd/test/std/test.math.ci:54: (78 bytes: <.main+10721 @064a15> - <.main+10799 @064a63>): static testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10721 @064a15>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10730 @064a1e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10739 @064a27>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10748 @064a30>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10757 @064a39>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10766 @064a42>: 1c 05 00 00 00             load.c32 5
	<.main+10771 @064a47>: 0a 04 00 00                load.sp(+4)
	<.main+10775 @064a4b>: 1a                         load.z64
	<.main+10776 @064a4c>: 21 00 1f 06                load.m64 <@061f00> ;testMathEval_x
	<.main+10780 @064a50>: 11 04                      dup.x64 sp(4)
	<.main+10782 @064a52>: 1f b8 f9 05 00             load.ref <@05f9b8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10787 @064a57>: 02                         call
	<.main+10788 @064a58>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10791 @064a5b>: 09 c0 ff ff                inc.sp(-64)
	<.main+10795 @064a5f>: 23 30 1f 06                store.m64 <@061f30> ;testMathEval_5
	cmplStd/test/std/test.math.ci:55: (87 bytes: <.main+10799 @064a63> - <.main+10886 @064aba>): static testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10799 @064a63>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10808 @064a6c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10817 @064a75>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10826 @064a7e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10835 @064a87>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10844 @064a90>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10853 @064a99>: 1c 06 00 00 00             load.c32 6
	<.main+10858 @064a9e>: 0a 04 00 00                load.sp(+4)
	<.main+10862 @064aa2>: 1a                         load.z64
	<.main+10863 @064aa3>: 21 00 1f 06                load.m64 <@061f00> ;testMathEval_x
	<.main+10867 @064aa7>: 11 04                      dup.x64 sp(4)
	<.main+10869 @064aa9>: 1f b8 f9 05 00             load.ref <@05f9b8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10874 @064aae>: 02                         call
	<.main+10875 @064aaf>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10878 @064ab2>: 09 b8 ff ff                inc.sp(-72)
	<.main+10882 @064ab6>: 23 38 1f 06                store.m64 <@061f38> ;testMathEval_6
	cmplStd/test/std/test.math.ci:57: (35 bytes: <.main+10886 @064aba> - <.main+10921 @064add>): static testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+10886 @064aba>: 1a                         load.z64
	<.main+10887 @064abb>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10896 @064ac4>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10905 @064acd>: 84                         div.f64
	<.main+10906 @064ace>: 19                         load.z32
	<.main+10907 @064acf>: 1f 68 fa 05 00             load.ref <@05fa68> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10912 @064ad4>: 02                         call
	<.main+10913 @064ad5>: 09 f4 ff ff                inc.sp(-12)
	<.main+10917 @064ad9>: 23 40 1f 06                store.m64 <@061f40> ;testMathSin_f64
	cmplStd/test/std/test.math.ci:58: (58 bytes: <.main+10921 @064add> - <.main+10979 @064b17>): static testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+10921 @064add>: 1a                         load.z64
	<.main+10922 @064ade>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10931 @064ae7>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10940 @064af0>: 84                         div.f64
	<.main+10941 @064af1>: 11 00                      dup.x64 sp(0)
	<.main+10943 @064af3>: 1a                         load.z64
	<.main+10944 @064af4>: 88                         clt.f64
	<.main+10945 @064af5>: 06 0b 00 00                jz <.main+10956 @064b00>
	<.main+10949 @064af9>: 11 00                      dup.x64 sp(0)
	<.main+10951 @064afb>: 80                         neg.f64
	<.main+10952 @064afc>: 04 06 00 00                jmp <.main+10958 @064b02>
	<.main+10956 @064b00>: 11 00                      dup.x64 sp(0)
	<.main+10958 @064b02>: 14 02                      set.x64 sp(2)
	<.main+10960 @064b04>: 1c 01 00 00 00             load.c32 1
	<.main+10965 @064b09>: 1f 68 fa 05 00             load.ref <@05fa68> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10970 @064b0e>: 02                         call
	<.main+10971 @064b0f>: 09 f4 ff ff                inc.sp(-12)
	<.main+10975 @064b13>: 23 48 1f 06                store.m64 <@061f48> ;testMathCos_f64
	cmplStd/test/std/test.math.ci:59: (34 bytes: <.main+10979 @064b17> - <.main+11013 @064b39>): static testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+10979 @064b17>: 1a                         load.z64
	<.main+10980 @064b18>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10989 @064b21>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10998 @064b2a>: 84                         div.f64
	<.main+10999 @064b2b>: 1f b8 fb 05 00             load.ref <@05fbb8> ;Math.tan(arg: float64): float64
	<.main+11004 @064b30>: 02                         call
	<.main+11005 @064b31>: 09 f8 ff ff                inc.sp(-8)
	<.main+11009 @064b35>: 23 50 1f 06                store.m64 <@061f50> ;testMathTan_f64
	cmplStd/test/std/test.math.ci:60: (34 bytes: <.main+11013 @064b39> - <.main+11047 @064b5b>): static testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+11013 @064b39>: 1a                         load.z64
	<.main+11014 @064b3a>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11023 @064b43>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11032 @064b4c>: 84                         div.f64
	<.main+11033 @064b4d>: 1f 38 fd 05 00             load.ref <@05fd38> ;Math.sinh(x: float64): float64
	<.main+11038 @064b52>: 02                         call
	<.main+11039 @064b53>: 09 f8 ff ff                inc.sp(-8)
	<.main+11043 @064b57>: 23 58 1f 06                store.m64 <@061f58> ;testMathSinh_f64
	cmplStd/test/std/test.math.ci:61: (34 bytes: <.main+11047 @064b5b> - <.main+11081 @064b7d>): static testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+11047 @064b5b>: 1a                         load.z64
	<.main+11048 @064b5c>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11057 @064b65>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11066 @064b6e>: 84                         div.f64
	<.main+11067 @064b6f>: 1f 30 fe 05 00             load.ref <@05fe30> ;Math.cosh(x: float64): float64
	<.main+11072 @064b74>: 02                         call
	<.main+11073 @064b75>: 09 f8 ff ff                inc.sp(-8)
	<.main+11077 @064b79>: 23 60 1f 06                store.m64 <@061f60> ;testMathCosh_f64
	cmplStd/test/std/test.math.ci:63: (24 bytes: <.main+11081 @064b7d> - <.main+11105 @064b95>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+11081 @064b7d>: 1a                         load.z64
	<.main+11082 @064b7e>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11091 @064b87>: 1f 80 fe 05 00             load.ref <@05fe80> ;Math.asin(x: float64): float64
	<.main+11096 @064b8c>: 02                         call
	<.main+11097 @064b8d>: 09 f8 ff ff                inc.sp(-8)
	<.main+11101 @064b91>: 23 68 1f 06                store.m64 <@061f68> ;testMathAsin_f64
	cmplStd/test/std/test.math.ci:64: (44 bytes: <.main+11105 @064b95> - <.main+11149 @064bc1>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+11105 @064b95>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11114 @064b9e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11123 @064ba7>: 84                         div.f64
	<.main+11124 @064ba8>: 1a                         load.z64
	<.main+11125 @064ba9>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11134 @064bb2>: 1f 80 fe 05 00             load.ref <@05fe80> ;Math.asin(x: float64): float64
	<.main+11139 @064bb7>: 02                         call
	<.main+11140 @064bb8>: 09 f8 ff ff                inc.sp(-8)
	<.main+11144 @064bbc>: 82                         sub.f64
	<.main+11145 @064bbd>: 23 70 1f 06                store.m64 <@061f70> ;testMathAcos_f64
	cmplStd/test/std/test.math.ci:67: (34 bytes: <.main+11149 @064bc1> - <.main+11183 @064be3>): static testMathCmp_f32: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11149 @064bc1>: 19                         load.z32
	<.main+11150 @064bc2>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11155 @064bc7>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+11160 @064bcc>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11165 @064bd1>: 1f e8 f9 05 00             load.ref <@05f9e8> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+11170 @064bd6>: 02                         call
	<.main+11171 @064bd7>: 09 f4 ff ff                inc.sp(-12)
	<.main+11175 @064bdb>: 19                         load.z32
	<.main+11176 @064bdc>: 57                         ceq.i32
	<.main+11177 @064bdd>: 1f 78 1f 06 00             load.ref <@061f78> ;testMathCmp_f32
	<.main+11182 @064be2>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:68: (46 bytes: <.main+11183 @064be3> - <.main+11229 @064c11>): static testMathCmp_f64: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11183 @064be3>: 19                         load.z32
	<.main+11184 @064be4>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11193 @064bed>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+11202 @064bf6>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11211 @064bff>: 1f 28 fa 05 00             load.ref <@05fa28> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+11216 @064c04>: 02                         call
	<.main+11217 @064c05>: 09 e8 ff ff                inc.sp(-24)
	<.main+11221 @064c09>: 19                         load.z32
	<.main+11222 @064c0a>: 57                         ceq.i32
	<.main+11223 @064c0b>: 1f 80 1f 06 00             load.ref <@061f80> ;testMathCmp_f64
	<.main+11228 @064c10>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:70: (33 bytes: <.main+11229 @064c11> - <.main+11262 @064c32>): static testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+11229 @064c11>: 1a                         load.z64
	<.main+11230 @064c12>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11239 @064c1b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11248 @064c24>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11253 @064c29>: 02                         call
	<.main+11254 @064c2a>: 09 f0 ff ff                inc.sp(-16)
	<.main+11258 @064c2e>: 23 88 1f 06                store.m64 <@061f88> ;testMathAbsMod_f64_0a
	cmplStd/test/std/test.math.ci:71: (24 bytes: <.main+11262 @064c32> - <.main+11286 @064c4a>): static testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+11262 @064c32>: 1b                         load.z128
	<.main+11263 @064c33>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11272 @064c3c>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11277 @064c41>: 02                         call
	<.main+11278 @064c42>: 09 f0 ff ff                inc.sp(-16)
	<.main+11282 @064c46>: 23 90 1f 06                store.m64 <@061f90> ;testMathAbsMod_f64_0b
	cmplStd/test/std/test.math.ci:72: (33 bytes: <.main+11286 @064c4a> - <.main+11319 @064c6b>): static testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+11286 @064c4a>: 1a                         load.z64
	<.main+11287 @064c4b>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11296 @064c54>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11305 @064c5d>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11310 @064c62>: 02                         call
	<.main+11311 @064c63>: 09 f0 ff ff                inc.sp(-16)
	<.main+11315 @064c67>: 23 98 1f 06                store.m64 <@061f98> ;testMathAbsMod_f64_0c
	cmplStd/test/std/test.math.ci:74: (33 bytes: <.main+11319 @064c6b> - <.main+11352 @064c8c>): static testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+11319 @064c6b>: 1a                         load.z64
	<.main+11320 @064c6c>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11329 @064c75>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11338 @064c7e>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11343 @064c83>: 02                         call
	<.main+11344 @064c84>: 09 f0 ff ff                inc.sp(-16)
	<.main+11348 @064c88>: 23 a0 1f 06                store.m64 <@061fa0> ;testMathAbsMod_f64_9a
	cmplStd/test/std/test.math.ci:75: (33 bytes: <.main+11352 @064c8c> - <.main+11385 @064cad>): static testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+11352 @064c8c>: 1a                         load.z64
	<.main+11353 @064c8d>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11362 @064c96>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11371 @064c9f>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11376 @064ca4>: 02                         call
	<.main+11377 @064ca5>: 09 f0 ff ff                inc.sp(-16)
	<.main+11381 @064ca9>: 23 a8 1f 06                store.m64 <@061fa8> ;testMathAbsMod_f64_9b
	cmplStd/test/std/test.math.ci:76: (33 bytes: <.main+11385 @064cad> - <.main+11418 @064cce>): static testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+11385 @064cad>: 1a                         load.z64
	<.main+11386 @064cae>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11395 @064cb7>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11404 @064cc0>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11409 @064cc5>: 02                         call
	<.main+11410 @064cc6>: 09 f0 ff ff                inc.sp(-16)
	<.main+11414 @064cca>: 23 b0 1f 06                store.m64 <@061fb0> ;testMathAbsMod_f64_9c
	cmplStd/test/std/test.math.ci:77: (33 bytes: <.main+11418 @064cce> - <.main+11451 @064cef>): static testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+11418 @064cce>: 1a                         load.z64
	<.main+11419 @064ccf>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11428 @064cd8>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11437 @064ce1>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11442 @064ce6>: 02                         call
	<.main+11443 @064ce7>: 09 f0 ff ff                inc.sp(-16)
	<.main+11447 @064ceb>: 23 b8 1f 06                store.m64 <@061fb8> ;testMathAbsMod_f64_9d
	cmplStd/test/std/test.math.ci:79: (33 bytes: <.main+11451 @064cef> - <.main+11484 @064d10>): static testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+11451 @064cef>: 1a                         load.z64
	<.main+11452 @064cf0>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11461 @064cf9>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11470 @064d02>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11475 @064d07>: 02                         call
	<.main+11476 @064d08>: 09 f0 ff ff                inc.sp(-16)
	<.main+11480 @064d0c>: 23 c0 1f 06                store.m64 <@061fc0> ;testMathAbsMod_f64_8a
	cmplStd/test/std/test.math.ci:80: (33 bytes: <.main+11484 @064d10> - <.main+11517 @064d31>): static testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+11484 @064d10>: 1a                         load.z64
	<.main+11485 @064d11>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11494 @064d1a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11503 @064d23>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11508 @064d28>: 02                         call
	<.main+11509 @064d29>: 09 f0 ff ff                inc.sp(-16)
	<.main+11513 @064d2d>: 23 c8 1f 06                store.m64 <@061fc8> ;testMathAbsMod_f64_8b
	cmplStd/test/std/test.math.ci:81: (33 bytes: <.main+11517 @064d31> - <.main+11550 @064d52>): static testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+11517 @064d31>: 1a                         load.z64
	<.main+11518 @064d32>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11527 @064d3b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11536 @064d44>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11541 @064d49>: 02                         call
	<.main+11542 @064d4a>: 09 f0 ff ff                inc.sp(-16)
	<.main+11546 @064d4e>: 23 d0 1f 06                store.m64 <@061fd0> ;testMathAbsMod_f64_8c
	cmplStd/test/std/test.math.ci:82: (33 bytes: <.main+11550 @064d52> - <.main+11583 @064d73>): static testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+11550 @064d52>: 1a                         load.z64
	<.main+11551 @064d53>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11560 @064d5c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11569 @064d65>: 1f 78 f8 05 00             load.ref <@05f878> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11574 @064d6a>: 02                         call
	<.main+11575 @064d6b>: 09 f0 ff ff                inc.sp(-16)
	<.main+11579 @064d6f>: 23 d8 1f 06                store.m64 <@061fd8> ;testMathAbsMod_f64_8d
	cmplStd/test/std/test.math.ci:84: (25 bytes: <.main+11583 @064d73> - <.main+11608 @064d8c>): static testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+11583 @064d73>: 19                         load.z32
	<.main+11584 @064d74>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11589 @064d79>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11594 @064d7e>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11599 @064d83>: 02                         call
	<.main+11600 @064d84>: 09 f8 ff ff                inc.sp(-8)
	<.main+11604 @064d88>: 24 e0 1f 06                store.m32 <@061fe0> ;testMathAbsMod_f32_0a
	cmplStd/test/std/test.math.ci:85: (21 bytes: <.main+11608 @064d8c> - <.main+11629 @064da1>): static testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+11608 @064d8c>: 19                         load.z32
	<.main+11609 @064d8d>: 19                         load.z32
	<.main+11610 @064d8e>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11615 @064d93>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11620 @064d98>: 02                         call
	<.main+11621 @064d99>: 09 f8 ff ff                inc.sp(-8)
	<.main+11625 @064d9d>: 24 e8 1f 06                store.m32 <@061fe8> ;testMathAbsMod_f32_0b
	cmplStd/test/std/test.math.ci:86: (25 bytes: <.main+11629 @064da1> - <.main+11654 @064dba>): static testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+11629 @064da1>: 19                         load.z32
	<.main+11630 @064da2>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11635 @064da7>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11640 @064dac>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11645 @064db1>: 02                         call
	<.main+11646 @064db2>: 09 f8 ff ff                inc.sp(-8)
	<.main+11650 @064db6>: 24 f0 1f 06                store.m32 <@061ff0> ;testMathAbsMod_f32_0c
	cmplStd/test/std/test.math.ci:88: (25 bytes: <.main+11654 @064dba> - <.main+11679 @064dd3>): static testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+11654 @064dba>: 19                         load.z32
	<.main+11655 @064dbb>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11660 @064dc0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11665 @064dc5>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11670 @064dca>: 02                         call
	<.main+11671 @064dcb>: 09 f8 ff ff                inc.sp(-8)
	<.main+11675 @064dcf>: 24 f8 1f 06                store.m32 <@061ff8> ;testMathAbsMod_f32_9a
	cmplStd/test/std/test.math.ci:89: (25 bytes: <.main+11679 @064dd3> - <.main+11704 @064dec>): static testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+11679 @064dd3>: 19                         load.z32
	<.main+11680 @064dd4>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11685 @064dd9>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11690 @064dde>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11695 @064de3>: 02                         call
	<.main+11696 @064de4>: 09 f8 ff ff                inc.sp(-8)
	<.main+11700 @064de8>: 24 00 20 06                store.m32 <@062000> ;testMathAbsMod_f32_9b
	cmplStd/test/std/test.math.ci:90: (25 bytes: <.main+11704 @064dec> - <.main+11729 @064e05>): static testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+11704 @064dec>: 19                         load.z32
	<.main+11705 @064ded>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11710 @064df2>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11715 @064df7>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11720 @064dfc>: 02                         call
	<.main+11721 @064dfd>: 09 f8 ff ff                inc.sp(-8)
	<.main+11725 @064e01>: 24 08 20 06                store.m32 <@062008> ;testMathAbsMod_f32_9c
	cmplStd/test/std/test.math.ci:91: (25 bytes: <.main+11729 @064e05> - <.main+11754 @064e1e>): static testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+11729 @064e05>: 19                         load.z32
	<.main+11730 @064e06>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11735 @064e0b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11740 @064e10>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11745 @064e15>: 02                         call
	<.main+11746 @064e16>: 09 f8 ff ff                inc.sp(-8)
	<.main+11750 @064e1a>: 24 10 20 06                store.m32 <@062010> ;testMathAbsMod_f32_9d
	cmplStd/test/std/test.math.ci:93: (25 bytes: <.main+11754 @064e1e> - <.main+11779 @064e37>): static testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+11754 @064e1e>: 19                         load.z32
	<.main+11755 @064e1f>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11760 @064e24>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11765 @064e29>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11770 @064e2e>: 02                         call
	<.main+11771 @064e2f>: 09 f8 ff ff                inc.sp(-8)
	<.main+11775 @064e33>: 24 18 20 06                store.m32 <@062018> ;testMathAbsMod_f32_8a
	cmplStd/test/std/test.math.ci:94: (25 bytes: <.main+11779 @064e37> - <.main+11804 @064e50>): static testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+11779 @064e37>: 19                         load.z32
	<.main+11780 @064e38>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11785 @064e3d>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11790 @064e42>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11795 @064e47>: 02                         call
	<.main+11796 @064e48>: 09 f8 ff ff                inc.sp(-8)
	<.main+11800 @064e4c>: 24 20 20 06                store.m32 <@062020> ;testMathAbsMod_f32_8b
	cmplStd/test/std/test.math.ci:95: (25 bytes: <.main+11804 @064e50> - <.main+11829 @064e69>): static testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+11804 @064e50>: 19                         load.z32
	<.main+11805 @064e51>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11810 @064e56>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11815 @064e5b>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11820 @064e60>: 02                         call
	<.main+11821 @064e61>: 09 f8 ff ff                inc.sp(-8)
	<.main+11825 @064e65>: 24 28 20 06                store.m32 <@062028> ;testMathAbsMod_f32_8c
	cmplStd/test/std/test.math.ci:96: (25 bytes: <.main+11829 @064e69> - <.main+11854 @064e82>): static testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+11829 @064e69>: 19                         load.z32
	<.main+11830 @064e6a>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11835 @064e6f>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11840 @064e74>: 1f 58 f8 05 00             load.ref <@05f858> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11845 @064e79>: 02                         call
	<.main+11846 @064e7a>: 09 f8 ff ff                inc.sp(-8)
	<.main+11850 @064e7e>: 24 30 20 06                store.m32 <@062030> ;testMathAbsMod_f32_8d
	cmplStd/test/std/memory.ci:13: (18 bytes: <.main+11854 @064e82> - <.main+11872 @064e94>): pointer.fill(p1, 0, 1024);
	<.main+11854 @064e82>: 20 f8 0e 06                load.m32 <@060ef8> ;p1
	<.main+11858 @064e86>: 19                         load.z32
	<.main+11859 @064e87>: 1c 00 04 00 00             load.c32 1024
	<.main+11864 @064e8c>: 01 0d 00 00                nfc(13) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+11868 @064e90>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:14: (21 bytes: <.main+11872 @064e94> - <.main+11893 @064ea9>): pointer.copy(p1, p3, 160);
	<.main+11872 @064e94>: 20 f8 0e 06                load.m32 <@060ef8> ;p1
	<.main+11876 @064e98>: 20 08 0f 06                load.m32 <@060f08> ;p3
	<.main+11880 @064e9c>: 1c a0 00 00 00             load.c32 160
	<.main+11885 @064ea1>: 01 0e 00 00                nfc(14) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11889 @064ea5>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:17: (13 bytes: <.main+11893 @064ea9> - <.main+11906 @064eb6>): free(p1);
	<.main+11893 @064ea9>: 20 f8 0e 06                load.m32 <@060ef8> ;p1
	<.main+11897 @064ead>: 19                         load.z32
	<.main+11898 @064eae>: 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11902 @064eb2>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:18: (13 bytes: <.main+11906 @064eb6> - <.main+11919 @064ec3>): free(p2);
	<.main+11906 @064eb6>: 20 00 0f 06                load.m32 <@060f00> ;p2
	<.main+11910 @064eba>: 19                         load.z32
	<.main+11911 @064ebb>: 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11915 @064ebf>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:19: (13 bytes: <.main+11919 @064ec3> - <.main+11932 @064ed0>): free(p3);
	<.main+11919 @064ec3>: 20 08 0f 06                load.m32 <@060f08> ;p3
	<.main+11923 @064ec7>: 19                         load.z32
	<.main+11924 @064ec8>: 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11928 @064ecc>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:20: (13 bytes: <.main+11932 @064ed0> - <.main+11945 @064edd>): free(p4);
	<.main+11932 @064ed0>: 20 10 0f 06                load.m32 <@060f10> ;p4
	<.main+11936 @064ed4>: 19                         load.z32
	<.main+11937 @064ed5>: 01 0c 00 00                nfc(12) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11941 @064ed9>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:26: (35 bytes: <.main+11945 @064edd> - <.main+11980 @064f00>): debug("val1", val1);
	<.main+11945 @064edd>: 1f 98 35 04 00             load.ref <@043598> ;"cmplStd/test/std/memory.ci"
	<.main+11950 @064ee2>: 1c 1a 00 00 00             load.c32 26
	<.main+11955 @064ee7>: 1c 0e 00 00 00             load.c32 14
	<.main+11960 @064eec>: 19                         load.z32
	<.main+11961 @064eed>: 1f c7 35 04 00             load.ref <@0435c7> ;"val1"
	<.main+11966 @064ef2>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+11971 @064ef7>: 1f 18 0f 06 00             load.ref <@060f18> ;val1
	<.main+11976 @064efc>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:27: (35 bytes: <.main+11980 @064f00> - <.main+12015 @064f23>): debug("val2", val2);
	<.main+11980 @064f00>: 1f 98 35 04 00             load.ref <@043598> ;"cmplStd/test/std/memory.ci"
	<.main+11985 @064f05>: 1c 1b 00 00 00             load.c32 27
	<.main+11990 @064f0a>: 1c 0e 00 00 00             load.c32 14
	<.main+11995 @064f0f>: 19                         load.z32
	<.main+11996 @064f10>: 1f cc 35 04 00             load.ref <@0435cc> ;"val2"
	<.main+12001 @064f15>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12006 @064f1a>: 1f 20 0f 06 00             load.ref <@060f20> ;val2
	<.main+12011 @064f1f>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:29: (27 bytes: <.main+12015 @064f23> - <.main+12042 @064f3e>): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+12015 @064f23>: 1f 20 0f 06 00             load.ref <@060f20> ;val2
	<.main+12020 @064f28>: 1f 18 0f 06 00             load.ref <@060f18> ;val1
	<.main+12025 @064f2d>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12030 @064f32>: 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+12034 @064f36>: 01 0f 00 00                nfc(15) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+12038 @064f3a>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:30: (23 bytes: <.main+12042 @064f3e> - <.main+12065 @064f55>): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+12042 @064f3e>: 1f 18 0f 06 00             load.ref <@060f18> ;val1
	<.main+12047 @064f43>: 19                         load.z32
	<.main+12048 @064f44>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12053 @064f49>: 01 06 00 00                nfc(6) ;typename.size(type: typename): int32
	<.main+12057 @064f4d>: 01 0d 00 00                nfc(13) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+12061 @064f51>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:32: (35 bytes: <.main+12065 @064f55> - <.main+12100 @064f78>): debug("val1", val1);
	<.main+12065 @064f55>: 1f 98 35 04 00             load.ref <@043598> ;"cmplStd/test/std/memory.ci"
	<.main+12070 @064f5a>: 1c 20 00 00 00             load.c32 32
	<.main+12075 @064f5f>: 1c 0e 00 00 00             load.c32 14
	<.main+12080 @064f64>: 19                         load.z32
	<.main+12081 @064f65>: 1f c7 35 04 00             load.ref <@0435c7> ;"val1"
	<.main+12086 @064f6a>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12091 @064f6f>: 1f 18 0f 06 00             load.ref <@060f18> ;val1
	<.main+12096 @064f74>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:33: (35 bytes: <.main+12100 @064f78> - <.main+12135 @064f9b>): debug("val2", val2);
	<.main+12100 @064f78>: 1f 98 35 04 00             load.ref <@043598> ;"cmplStd/test/std/memory.ci"
	<.main+12105 @064f7d>: 1c 21 00 00 00             load.c32 33
	<.main+12110 @064f82>: 1c 0e 00 00 00             load.c32 14
	<.main+12115 @064f87>: 19                         load.z32
	<.main+12116 @064f88>: 1f cc 35 04 00             load.ref <@0435cc> ;"val2"
	<.main+12121 @064f8d>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12126 @064f92>: 1f 20 0f 06 00             load.ref <@060f20> ;val2
	<.main+12131 @064f97>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:78: (21 bytes: <.main+12135 @064f9b> - <.main+12156 @064fb0>): recordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+12135 @064f9b>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12139 @064f9f>: 1c 01 00 00 00             load.c32 1
	<.main+12144 @064fa4>: 13 04                      set.x32 sp(4)
	<.main+12146 @064fa6>: 1f b0 14 06 00             load.ref <@0614b0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12151 @064fab>: 02                         call
	<.main+12152 @064fac>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:79: (20 bytes: <.main+12156 @064fb0> - <.main+12176 @064fc4>): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+12156 @064fb0>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12160 @064fb4>: 1c 01 00 00 00             load.c32 1
	<.main+12165 @064fb9>: 13 04                      set.x32 sp(4)
	<.main+12167 @064fbb>: 20 60 15 06                load.m32 <@061560> ;recordMethodTest+8
	<.main+12171 @064fbf>: 02                         call
	<.main+12172 @064fc0>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:97: (19 bytes: <.main+12176 @064fc4> - <.main+12195 @064fd7>): staticMethod(recordMethodTest, 2);
	<.main+12176 @064fc4>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12180 @064fc8>: 1c 02 00 00 00             load.c32 2
	<.main+12185 @064fcd>: 1f 68 15 06 00             load.ref <@061568> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12190 @064fd2>: 02                         call
	<.main+12191 @064fd3>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:98: (19 bytes: <.main+12195 @064fd7> - <.main+12214 @064fea>): virtualMethod(recordMethodTest, 2);
	<.main+12195 @064fd7>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12199 @064fdb>: 1c 02 00 00 00             load.c32 2
	<.main+12204 @064fe0>: 1f b0 15 06 00             load.ref <@0615b0> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12209 @064fe5>: 02                         call
	<.main+12210 @064fe6>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:101: (21 bytes: <.main+12214 @064fea> - <.main+12235 @064fff>): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+12214 @064fea>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12218 @064fee>: 1c 03 00 00 00             load.c32 3
	<.main+12223 @064ff3>: 13 04                      set.x32 sp(4)
	<.main+12225 @064ff5>: 1f b0 14 06 00             load.ref <@0614b0> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12230 @064ffa>: 02                         call
	<.main+12231 @064ffb>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:102: (21 bytes: <.main+12235 @064fff> - <.main+12256 @065014>): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12235 @064fff>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12239 @065003>: 1c 03 00 00 00             load.c32 3
	<.main+12244 @065008>: 13 04                      set.x32 sp(4)
	<.main+12246 @06500a>: 1f e0 14 06 00             load.ref <@0614e0> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12251 @06500f>: 02                         call
	<.main+12252 @065010>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:103: (20 bytes: <.main+12256 @065014> - <.main+12276 @065028>): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12256 @065014>: 22 58 15 06                load.m128 <@061558> ;recordMethodTest
	<.main+12260 @065018>: 1c 03 00 00 00             load.c32 3
	<.main+12265 @06501d>: 13 04                      set.x32 sp(4)
	<.main+12267 @06501f>: 20 60 15 06                load.m32 <@061560> ;recordMethodTest+8
	<.main+12271 @065023>: 02                         call
	<.main+12272 @065024>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:4: (39 bytes: <.main+12276 @065028> - <.main+12315 @06504f>): raise(raise.debug, 1, "0 == 0", null);
	<.main+12276 @065028>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12281 @06502d>: 1c 04 00 00 00             load.c32 4
	<.main+12286 @065032>: 1c 0e 00 00 00             load.c32 14
	<.main+12291 @065037>: 1c 01 00 00 00             load.c32 1
	<.main+12296 @06503c>: 1f 75 bc 05 00             load.ref <@05bc75> ;"0 == 0"
	<.main+12301 @065041>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12306 @065046>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12311 @06504b>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:12: (39 bytes: <.main+12315 @06504f> - <.main+12354 @065076>): raise(raise.debug, 3, "0 == 0", null);
	<.main+12315 @06504f>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12320 @065054>: 1c 0c 00 00 00             load.c32 12
	<.main+12325 @065059>: 1c 0e 00 00 00             load.c32 14
	<.main+12330 @06505e>: 1c 03 00 00 00             load.c32 3
	<.main+12335 @065063>: 1f 75 bc 05 00             load.ref <@05bc75> ;"0 == 0"
	<.main+12340 @065068>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12345 @06506d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12350 @065072>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:22: (39 bytes: <.main+12354 @065076> - <.main+12393 @06509d>): raise(raise.debug, 6, "0 == 0", null);
	<.main+12354 @065076>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12359 @06507b>: 1c 16 00 00 00             load.c32 22
	<.main+12364 @065080>: 1c 0e 00 00 00             load.c32 14
	<.main+12369 @065085>: 1c 06 00 00 00             load.c32 6
	<.main+12374 @06508a>: 1f 75 bc 05 00             load.ref <@05bc75> ;"0 == 0"
	<.main+12379 @06508f>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12384 @065094>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12389 @065099>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:28: (49 bytes: <.main+12393 @06509d> - <.main+12442 @0650ce>): if (t == 0)
	<.main+12393 @06509d>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12397 @0650a1>: 19                         load.z32
	<.main+12398 @0650a2>: 57                         ceq.i32
	<.main+12399 @0650a3>: 06 2b 00 00                jz <.main+12442 @0650ce>
	cmplStd/test/lang/stmt.if.ci:29: (39 bytes: <.main+12403 @0650a7> - <.main+12442 @0650ce>): raise(raise.debug, 7, "t == 0", t);
	<.main+12403 @0650a7>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12408 @0650ac>: 1c 1d 00 00 00             load.c32 29
	<.main+12413 @0650b1>: 1c 0e 00 00 00             load.c32 14
	<.main+12418 @0650b6>: 1c 07 00 00 00             load.c32 7
	<.main+12423 @0650bb>: 1f 83 bc 05 00             load.ref <@05bc83> ;"t == 0"
	<.main+12428 @0650c0>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12433 @0650c5>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12438 @0650ca>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:32: (49 bytes: <.main+12442 @0650ce> - <.main+12491 @0650ff>): if (t != 0)
	<.main+12442 @0650ce>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12446 @0650d2>: 19                         load.z32
	<.main+12447 @0650d3>: 57                         ceq.i32
	<.main+12448 @0650d4>: 05 2b 00 00                jnz <.main+12491 @0650ff>
	cmplStd/test/lang/stmt.if.ci:33: (39 bytes: <.main+12452 @0650d8> - <.main+12491 @0650ff>): raise(raise.debug, 8, "t != 0", t);
	<.main+12452 @0650d8>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12457 @0650dd>: 1c 21 00 00 00             load.c32 33
	<.main+12462 @0650e2>: 1c 0e 00 00 00             load.c32 14
	<.main+12467 @0650e7>: 1c 08 00 00 00             load.c32 8
	<.main+12472 @0650ec>: 1f 8a bc 05 00             load.ref <@05bc8a> ;"t != 0"
	<.main+12477 @0650f1>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12482 @0650f6>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12487 @0650fb>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:36: (92 bytes: <.main+12491 @0650ff> - <.main+12583 @06515b>): if (t == 0)
	<.main+12491 @0650ff>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12495 @065103>: 19                         load.z32
	<.main+12496 @065104>: 57                         ceq.i32
	<.main+12497 @065105>: 06 2f 00 00                jz <.main+12544 @065134>
	cmplStd/test/lang/stmt.if.ci:37: (39 bytes: <.main+12501 @065109> - <.main+12540 @065130>): raise(raise.debug, 9, "t == 0", t);
	<.main+12501 @065109>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12506 @06510e>: 1c 25 00 00 00             load.c32 37
	<.main+12511 @065113>: 1c 0e 00 00 00             load.c32 14
	<.main+12516 @065118>: 1c 09 00 00 00             load.c32 9
	<.main+12521 @06511d>: 1f 83 bc 05 00             load.ref <@05bc83> ;"t == 0"
	<.main+12526 @065122>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12531 @065127>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12536 @06512c>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12540 @065130>: 04 2b 00 00                jmp <.main+12583 @06515b>
	cmplStd/test/lang/stmt.if.ci:40: (39 bytes: <.main+12544 @065134> - <.main+12583 @06515b>): raise(raise.debug, 10, "t != 0", t);
	<.main+12544 @065134>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12549 @065139>: 1c 28 00 00 00             load.c32 40
	<.main+12554 @06513e>: 1c 0e 00 00 00             load.c32 14
	<.main+12559 @065143>: 1c 0a 00 00 00             load.c32 10
	<.main+12564 @065148>: 1f 8a bc 05 00             load.ref <@05bc8a> ;"t != 0"
	<.main+12569 @06514d>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12574 @065152>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12579 @065157>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:43: (92 bytes: <.main+12583 @06515b> - <.main+12675 @0651b7>): if (t != 0)
	<.main+12583 @06515b>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12587 @06515f>: 19                         load.z32
	<.main+12588 @065160>: 57                         ceq.i32
	<.main+12589 @065161>: 05 2f 00 00                jnz <.main+12636 @065190>
	cmplStd/test/lang/stmt.if.ci:44: (39 bytes: <.main+12593 @065165> - <.main+12632 @06518c>): raise(raise.debug, 11, "t != 0", t);
	<.main+12593 @065165>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12598 @06516a>: 1c 2c 00 00 00             load.c32 44
	<.main+12603 @06516f>: 1c 0e 00 00 00             load.c32 14
	<.main+12608 @065174>: 1c 0b 00 00 00             load.c32 11
	<.main+12613 @065179>: 1f 8a bc 05 00             load.ref <@05bc8a> ;"t != 0"
	<.main+12618 @06517e>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12623 @065183>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12628 @065188>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12632 @06518c>: 04 2b 00 00                jmp <.main+12675 @0651b7>
	cmplStd/test/lang/stmt.if.ci:47: (39 bytes: <.main+12636 @065190> - <.main+12675 @0651b7>): raise(raise.debug, 12, "t == 0", t);
	<.main+12636 @065190>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12641 @065195>: 1c 2f 00 00 00             load.c32 47
	<.main+12646 @06519a>: 1c 0e 00 00 00             load.c32 14
	<.main+12651 @06519f>: 1c 0c 00 00 00             load.c32 12
	<.main+12656 @0651a4>: 1f 83 bc 05 00             load.ref <@05bc83> ;"t == 0"
	<.main+12661 @0651a9>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12666 @0651ae>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12671 @0651b3>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:50: (377 bytes: <.main+12675 @0651b7> - <.main+13052 @065330>): if (t == 0)
	<.main+12675 @0651b7>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12679 @0651bb>: 19                         load.z32
	<.main+12680 @0651bc>: 57                         ceq.i32
	<.main+12681 @0651bd>: 06 2f 00 00                jz <.main+12728 @0651ec>
	cmplStd/test/lang/stmt.if.ci:51: (39 bytes: <.main+12685 @0651c1> - <.main+12724 @0651e8>): raise(raise.debug, 9, "t == 0", t);
	<.main+12685 @0651c1>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12690 @0651c6>: 1c 33 00 00 00             load.c32 51
	<.main+12695 @0651cb>: 1c 0e 00 00 00             load.c32 14
	<.main+12700 @0651d0>: 1c 09 00 00 00             load.c32 9
	<.main+12705 @0651d5>: 1f 83 bc 05 00             load.ref <@05bc83> ;"t == 0"
	<.main+12710 @0651da>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12715 @0651df>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12720 @0651e4>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12724 @0651e8>: 04 48 01 00                jmp <.main+13052 @065330>
	cmplStd/test/lang/stmt.if.ci:53: (324 bytes: <.main+12728 @0651ec> - <.main+13052 @065330>): if (t == 1)
	<.main+12728 @0651ec>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12732 @0651f0>: 1c 01 00 00 00             load.c32 1
	<.main+12737 @0651f5>: 57                         ceq.i32
	<.main+12738 @0651f6>: 06 2f 00 00                jz <.main+12785 @065225>
	cmplStd/test/lang/stmt.if.ci:54: (39 bytes: <.main+12742 @0651fa> - <.main+12781 @065221>): raise(raise.debug, 10, "t == 1", t);
	<.main+12742 @0651fa>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12747 @0651ff>: 1c 36 00 00 00             load.c32 54
	<.main+12752 @065204>: 1c 0e 00 00 00             load.c32 14
	<.main+12757 @065209>: 1c 0a 00 00 00             load.c32 10
	<.main+12762 @06520e>: 1f 91 bc 05 00             load.ref <@05bc91> ;"t == 1"
	<.main+12767 @065213>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12772 @065218>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12777 @06521d>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12781 @065221>: 04 0f 01 00                jmp <.main+13052 @065330>
	cmplStd/test/lang/stmt.if.ci:56: (267 bytes: <.main+12785 @065225> - <.main+13052 @065330>): if (t == 2)
	<.main+12785 @065225>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12789 @065229>: 1c 02 00 00 00             load.c32 2
	<.main+12794 @06522e>: 57                         ceq.i32
	<.main+12795 @06522f>: 06 2f 00 00                jz <.main+12842 @06525e>
	cmplStd/test/lang/stmt.if.ci:57: (39 bytes: <.main+12799 @065233> - <.main+12838 @06525a>): raise(raise.debug, 10, "t == 2", t);
	<.main+12799 @065233>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12804 @065238>: 1c 39 00 00 00             load.c32 57
	<.main+12809 @06523d>: 1c 0e 00 00 00             load.c32 14
	<.main+12814 @065242>: 1c 0a 00 00 00             load.c32 10
	<.main+12819 @065247>: 1f 98 bc 05 00             load.ref <@05bc98> ;"t == 2"
	<.main+12824 @06524c>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12829 @065251>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12834 @065256>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12838 @06525a>: 04 d6 00 00                jmp <.main+13052 @065330>
	cmplStd/test/lang/stmt.if.ci:59: (210 bytes: <.main+12842 @06525e> - <.main+13052 @065330>): if (t == 3)
	<.main+12842 @06525e>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12846 @065262>: 1c 03 00 00 00             load.c32 3
	<.main+12851 @065267>: 57                         ceq.i32
	<.main+12852 @065268>: 06 2f 00 00                jz <.main+12899 @065297>
	cmplStd/test/lang/stmt.if.ci:60: (39 bytes: <.main+12856 @06526c> - <.main+12895 @065293>): raise(raise.debug, 10, "t == 3", t);
	<.main+12856 @06526c>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12861 @065271>: 1c 3c 00 00 00             load.c32 60
	<.main+12866 @065276>: 1c 0e 00 00 00             load.c32 14
	<.main+12871 @06527b>: 1c 0a 00 00 00             load.c32 10
	<.main+12876 @065280>: 1f 9f bc 05 00             load.ref <@05bc9f> ;"t == 3"
	<.main+12881 @065285>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12886 @06528a>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12891 @06528f>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12895 @065293>: 04 9d 00 00                jmp <.main+13052 @065330>
	cmplStd/test/lang/stmt.if.ci:62: (153 bytes: <.main+12899 @065297> - <.main+13052 @065330>): if (t == 4)
	<.main+12899 @065297>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12903 @06529b>: 1c 04 00 00 00             load.c32 4
	<.main+12908 @0652a0>: 57                         ceq.i32
	<.main+12909 @0652a1>: 06 2f 00 00                jz <.main+12956 @0652d0>
	cmplStd/test/lang/stmt.if.ci:63: (39 bytes: <.main+12913 @0652a5> - <.main+12952 @0652cc>): raise(raise.debug, 10, "t == 4", t);
	<.main+12913 @0652a5>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12918 @0652aa>: 1c 3f 00 00 00             load.c32 63
	<.main+12923 @0652af>: 1c 0e 00 00 00             load.c32 14
	<.main+12928 @0652b4>: 1c 0a 00 00 00             load.c32 10
	<.main+12933 @0652b9>: 1f a6 bc 05 00             load.ref <@05bca6> ;"t == 4"
	<.main+12938 @0652be>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+12943 @0652c3>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+12948 @0652c8>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+12952 @0652cc>: 04 64 00 00                jmp <.main+13052 @065330>
	cmplStd/test/lang/stmt.if.ci:65: (96 bytes: <.main+12956 @0652d0> - <.main+13052 @065330>): if (t == 5)
	<.main+12956 @0652d0>: 20 d0 1d 06                load.m32 <@061dd0> ;t
	<.main+12960 @0652d4>: 1c 05 00 00 00             load.c32 5
	<.main+12965 @0652d9>: 57                         ceq.i32
	<.main+12966 @0652da>: 06 2f 00 00                jz <.main+13013 @065309>
	cmplStd/test/lang/stmt.if.ci:66: (39 bytes: <.main+12970 @0652de> - <.main+13009 @065305>): raise(raise.debug, 10, "t == 5", t);
	<.main+12970 @0652de>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+12975 @0652e3>: 1c 42 00 00 00             load.c32 66
	<.main+12980 @0652e8>: 1c 0e 00 00 00             load.c32 14
	<.main+12985 @0652ed>: 1c 0a 00 00 00             load.c32 10
	<.main+12990 @0652f2>: 1f ad bc 05 00             load.ref <@05bcad> ;"t == 5"
	<.main+12995 @0652f7>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13000 @0652fc>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+13005 @065301>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13009 @065305>: 04 2b 00 00                jmp <.main+13052 @065330>
	cmplStd/test/lang/stmt.if.ci:69: (39 bytes: <.main+13013 @065309> - <.main+13052 @065330>): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+13013 @065309>: 1f 58 bc 05 00             load.ref <@05bc58> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13018 @06530e>: 1c 45 00 00 00             load.c32 69
	<.main+13023 @065313>: 1c 0e 00 00 00             load.c32 14
	<.main+13028 @065318>: 1c 0a 00 00 00             load.c32 10
	<.main+13033 @06531d>: 1f b4 bc 05 00             load.ref <@05bcb4> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+13038 @065322>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13043 @065327>: 1f d0 1d 06 00             load.ref <@061dd0> ;t
	<.main+13048 @06532c>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:3: (47 bytes: <.main+13052 @065330> - <.main+13099 @06535f>): for ( ; ; )
	<.main+13052 @065330>: 04 2b 00 00                jmp <.main+13095 @06535b>
	cmplStd/test/lang/stmt.for.ci:4: (35 bytes: <.main+13056 @065334> - <.main+13091 @065357>): debug("for ( ; ; )");
	<.main+13056 @065334>: 1f a0 bd 05 00             load.ref <@05bda0> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13061 @065339>: 1c 04 00 00 00             load.c32 4
	<.main+13066 @06533e>: 1c 0e 00 00 00             load.c32 14
	<.main+13071 @065343>: 19                         load.z32
	<.main+13072 @065344>: 1f be bd 05 00             load.ref <@05bdbe> ;"for ( ; ; )"
	<.main+13077 @065349>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13082 @06534e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13087 @065353>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:5: (4 bytes: <.main+13091 @065357> - <.main+13095 @06535b>): break;
	<.main+13091 @065357>: 04 08 00 00                jmp <.main+13099 @06535f>
	:: (4 bytes: <.main+13095 @06535b> - <.main+13099 @06535f>)
	<.main+13095 @06535b>: 04 d9 ff ff                jmp <.main+13056 @065334>
	cmplStd/test/lang/stmt.for.ci:8: (59 bytes: <.main+13099 @06535f> - <.main+13158 @06539a>): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+13099 @06535f>: 19                         load.z32
	<.main+13100 @065360>: 04 2a 00 00                jmp <.main+13142 @06538a>
	cmplStd/test/lang/stmt.for.ci:9: (34 bytes: <.main+13104 @065364> - <.main+13138 @065386>): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+13104 @065364>: 1f a0 bd 05 00             load.ref <@05bda0> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13109 @065369>: 1c 09 00 00 00             load.c32 9
	<.main+13114 @06536e>: 1c 0e 00 00 00             load.c32 14
	<.main+13119 @065373>: 19                         load.z32
	<.main+13120 @065374>: 1f ca bd 05 00             load.ref <@05bdca> ;"for (int i = 0; i < 2; i += 1)"
	<.main+13125 @065379>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13130 @06537e>: 0a 18 00 00                load.sp(+24)
	<.main+13134 @065382>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:8: (4 bytes: <.main+13138 @065386> - <.main+13142 @06538a>): i := i + 1
	<.main+13138 @065386>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:8: (12 bytes: <.main+13142 @06538a> - <.main+13154 @065396>): i < 2
	<.main+13142 @06538a>: 10 00                      dup.x32 sp(0)
	<.main+13144 @06538c>: 1c 02 00 00 00             load.c32 2
	<.main+13149 @065391>: 58                         clt.i32
	<.main+13150 @065392>: 05 d2 ff ff                jnz <.main+13104 @065364>
	<.main+13154 @065396>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:13: (70 bytes: <.main+13158 @06539a> - <.main+13228 @0653e0>): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+13158 @06539a>: 19                         load.z32
	<.main+13159 @06539b>: 24 d8 1d 06                store.m32 <@061dd8> ;forIdx
	<.main+13163 @06539f>: 04 33 00 00                jmp <.main+13214 @0653d2>
	cmplStd/test/lang/stmt.for.ci:14: (35 bytes: <.main+13167 @0653a3> - <.main+13202 @0653c6>): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+13167 @0653a3>: 1f a0 bd 05 00             load.ref <@05bda0> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13172 @0653a8>: 1c 0e 00 00 00             load.c32 14
	<.main+13177 @0653ad>: 1c 0e 00 00 00             load.c32 14
	<.main+13182 @0653b2>: 19                         load.z32
	<.main+13183 @0653b3>: 1f f0 bd 05 00             load.ref <@05bdf0> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+13188 @0653b8>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13193 @0653bd>: 1f d8 1d 06 00             load.ref <@061dd8> ;forIdx
	<.main+13198 @0653c2>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:13: (12 bytes: <.main+13202 @0653c6> - <.main+13214 @0653d2>): forIdx := forIdx + 1
	<.main+13202 @0653c6>: 20 d8 1d 06                load.m32 <@061dd8> ;forIdx
	<.main+13206 @0653ca>: 0c 01 00 00                inc.i32(+1)
	<.main+13210 @0653ce>: 24 d8 1d 06                store.m32 <@061dd8> ;forIdx
	cmplStd/test/lang/stmt.for.ci:13: (14 bytes: <.main+13214 @0653d2> - <.main+13228 @0653e0>): forIdx < 2
	<.main+13214 @0653d2>: 20 d8 1d 06                load.m32 <@061dd8> ;forIdx
	<.main+13218 @0653d6>: 1c 02 00 00 00             load.c32 2
	<.main+13223 @0653db>: 58                         clt.i32
	<.main+13224 @0653dc>: 05 c7 ff ff                jnz <.main+13167 @0653a3>
	cmplStd/test/lang/stmt.for.ci:17: (75 bytes: <.main+13228 @0653e0> - <.main+13303 @06542b>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+13228 @0653e0>: 19                         load.z32
	<.main+13229 @0653e1>: 04 3a 00 00                jmp <.main+13287 @06541b>
	cmplStd/test/lang/stmt.for.ci:18: (16 bytes: <.main+13233 @0653e5> - <.main+13249 @0653f5>): if (i < 2)
	<.main+13233 @0653e5>: 10 00                      dup.x32 sp(0)
	<.main+13235 @0653e7>: 1c 02 00 00 00             load.c32 2
	<.main+13240 @0653ec>: 58                         clt.i32
	<.main+13241 @0653ed>: 06 08 00 00                jz <.main+13249 @0653f5>
	cmplStd/test/lang/stmt.for.ci:19: (4 bytes: <.main+13245 @0653f1> - <.main+13249 @0653f5>): continue;
	<.main+13245 @0653f1>: 04 26 00 00                jmp <.main+13283 @065417>
	cmplStd/test/lang/stmt.for.ci:21: (34 bytes: <.main+13249 @0653f5> - <.main+13283 @065417>): debug("for with continue", i);
	<.main+13249 @0653f5>: 1f a0 bd 05 00             load.ref <@05bda0> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13254 @0653fa>: 1c 15 00 00 00             load.c32 21
	<.main+13259 @0653ff>: 1c 0e 00 00 00             load.c32 14
	<.main+13264 @065404>: 19                         load.z32
	<.main+13265 @065405>: 1f 1a be 05 00             load.ref <@05be1a> ;"for with continue"
	<.main+13270 @06540a>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13275 @06540f>: 0a 18 00 00                load.sp(+24)
	<.main+13279 @065413>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:17: (4 bytes: <.main+13283 @065417> - <.main+13287 @06541b>): i := i + 1
	<.main+13283 @065417>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:17: (12 bytes: <.main+13287 @06541b> - <.main+13299 @065427>): i < 7
	<.main+13287 @06541b>: 10 00                      dup.x32 sp(0)
	<.main+13289 @06541d>: 1c 07 00 00 00             load.c32 7
	<.main+13294 @065422>: 58                         clt.i32
	<.main+13295 @065423>: 05 c2 ff ff                jnz <.main+13233 @0653e5>
	<.main+13299 @065427>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:24: (75 bytes: <.main+13303 @06542b> - <.main+13378 @065476>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+13303 @06542b>: 19                         load.z32
	<.main+13304 @06542c>: 04 3a 00 00                jmp <.main+13362 @065466>
	cmplStd/test/lang/stmt.for.ci:25: (16 bytes: <.main+13308 @065430> - <.main+13324 @065440>): if (i > 2)
	<.main+13308 @065430>: 10 00                      dup.x32 sp(0)
	<.main+13310 @065432>: 1c 02 00 00 00             load.c32 2
	<.main+13315 @065437>: 59                         cgt.i32
	<.main+13316 @065438>: 06 08 00 00                jz <.main+13324 @065440>
	cmplStd/test/lang/stmt.for.ci:26: (4 bytes: <.main+13320 @06543c> - <.main+13324 @065440>): break;
	<.main+13320 @06543c>: 04 36 00 00                jmp <.main+13374 @065472>
	cmplStd/test/lang/stmt.for.ci:28: (34 bytes: <.main+13324 @065440> - <.main+13358 @065462>): debug("for with break", i);
	<.main+13324 @065440>: 1f a0 bd 05 00             load.ref <@05bda0> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+13329 @065445>: 1c 1c 00 00 00             load.c32 28
	<.main+13334 @06544a>: 1c 0e 00 00 00             load.c32 14
	<.main+13339 @06544f>: 19                         load.z32
	<.main+13340 @065450>: 1f 2c be 05 00             load.ref <@05be2c> ;"for with break"
	<.main+13345 @065455>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13350 @06545a>: 0a 18 00 00                load.sp(+24)
	<.main+13354 @06545e>: 01 0a 00 00                nfc(10) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:24: (4 bytes: <.main+13358 @065462> - <.main+13362 @065466>): i := i + 1
	<.main+13358 @065462>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:24: (12 bytes: <.main+13362 @065466> - <.main+13374 @065472>): i < 7
	<.main+13362 @065466>: 10 00                      dup.x32 sp(0)
	<.main+13364 @065468>: 1c 07 00 00 00             load.c32 7
	<.main+13369 @06546d>: 58                         clt.i32
	<.main+13370 @06546e>: 05 c2 ff ff                jnz <.main+13308 @065430>
	<.main+13374 @065472>: 09 fc ff ff                inc.sp(-4)
	<.main+13378 @065476>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 145.39] > .main
[ 145.41]  > float32.sin(x: float32): float32
[ 145.43]  < return
[ 145.74]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 145.75]  < return
[ 145.76]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 145.77]  < return
[ 145.78]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 145.78]  < return
[ 145.79]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 145.80]  < return
[ 145.81]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 145.82]  < return
[ 145.82]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 145.83]  < return
[ 145.84]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 145.85]  < return
[ 145.85]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 145.86]  < return
[ 145.87]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 145.88]  < return
[ 145.88]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 145.90]  < return
[ 145.90]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 145.91]  < return
[ 145.92]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 145.93]  < return
[ 145.93]  > float64.sin(x: float64): float64
[ 145.95]  < return
[ 145.96]  > float64.cos(x: float64): float64
[ 145.97]  < return
[ 145.97]  > float64.tan(x: float64): float64
[ 145.98]  < return
[ 145.99]  > float64.log(x: float64): float64
[ 146.00]  < return
[ 146.00]  > float64.exp(x: float64): float64
[ 146.01]  < return
[ 146.02]  > float64.pow(x: float64, y: float64): float64
[ 146.03]  < return
[ 146.04]  > float64.sqrt(x: float64): float64
[ 146.05]  < return
[ 146.05]  > float64.atan2(x: float64, y: float64): float64
[ 146.06]  < return
[ 146.07]  > float32.sin(x: float32): float32
[ 146.08]  < return
[ 146.08]  > float32.cos(x: float32): float32
[ 146.09]  < return
[ 146.10]  > float32.tan(x: float32): float32
[ 146.11]  < return
[ 146.12]  > float32.log(x: float32): float32
[ 146.13]  < return
[ 146.13]  > float32.exp(x: float32): float32
[ 146.14]  < return
[ 146.15]  > float32.pow(x: float32, y: float32): float32
[ 146.16]  < return
[ 146.16]  > float32.sqrt(x: float32): float32
[ 146.17]  < return
[ 146.18]  > float32.atan2(x: float32, y: float32): float32
[ 146.19]  < return
[ 146.19]  > uint32.pop(value: int32): int32
[ 146.20]  < return
[ 146.21]  > uint32.swap(value: int32): int32
[ 146.22]  < return
[ 146.22]  > uint32.bsr(value: int32): int32
[ 146.23]  < return
[ 146.24]  > uint32.bsf(value: int32): int32
[ 146.25]  < return
[ 146.25]  > uint32.hib(value: int32): int32
[ 146.26]  < return
[ 146.27]  > uint32.lob(value: int32): int32
[ 146.28]  < return
[ 146.28]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 146.29]  < return
[ 146.30]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 146.31]  < return
[ 146.32]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 146.33]  < return
[ 146.33]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 146.34]  < return
[ 146.35]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 146.36]  < return
[ 146.37]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 146.38]  < return
[ 146.38]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 146.39]  < return
[ 146.40]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 146.41]  < return
[ 146.42]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 146.42]   > noError(ptr: pointer): void
[ 146.43]   < return
[ 146.44]   > halt(): void
[ 146.44]   < return
[ 146.45]  < return
[ 146.45]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 146.46]  < return
[ 146.47]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 146.47]   > stackOverflow(ptr: pointer): void
[ 146.48]    > stackOverflow(ptr: pointer): void
[ 146.49]     > stackOverflow(ptr: pointer): void
[ 146.50]      > stackOverflow(ptr: pointer): void
[ 146.51]       > stackOverflow(ptr: pointer): void
[ 146.52]        > stackOverflow(ptr: pointer): void
[ 146.52]         > stackOverflow(ptr: pointer): void
[ 146.53]          > stackOverflow(ptr: pointer): void
[ 146.54]           > stackOverflow(ptr: pointer): void
[ 146.55]            > stackOverflow(ptr: pointer): void
[ 146.56]             > stackOverflow(ptr: pointer): void
[ 146.56]              > stackOverflow(ptr: pointer): void
[ 146.57]               > stackOverflow(ptr: pointer): void
[ 146.58]                > stackOverflow(ptr: pointer): void
[ 146.59]                 > stackOverflow(ptr: pointer): void
[ 146.60]                  > stackOverflow(ptr: pointer): void
[ 146.60]                   > stackOverflow(ptr: pointer): void
[ 146.61]                    > stackOverflow(ptr: pointer): void
[ 146.62]                     > stackOverflow(ptr: pointer): void
[ 146.63]                      > stackOverflow(ptr: pointer): void
[ 146.63]                       > stackOverflow(ptr: pointer): void
[ 146.64]                        > stackOverflow(ptr: pointer): void
[ 146.65]                         > stackOverflow(ptr: pointer): void
[ 146.66]                          > stackOverflow(ptr: pointer): void
[ 146.67]                           > stackOverflow(ptr: pointer): void
[ 146.68]                            > stackOverflow(ptr: pointer): void
[ 146.68]                             > stackOverflow(ptr: pointer): void
[ 146.69]                              > stackOverflow(ptr: pointer): void
[ 146.70]                               > stackOverflow(ptr: pointer): void
[ 146.71]                                > stackOverflow(ptr: pointer): void
[ 146.72]                                 > stackOverflow(ptr: pointer): void
[ 146.72]                                  > stackOverflow(ptr: pointer): void
[ 146.73]                                   > stackOverflow(ptr: pointer): void
[ 146.74]                                    > stackOverflow(ptr: pointer): void
[ 146.75]                                     > stackOverflow(ptr: pointer): void
[ 146.75]                                      > stackOverflow(ptr: pointer): void
[ 146.76]                                       > stackOverflow(ptr: pointer): void
[ 146.77]                                        > stackOverflow(ptr: pointer): void
[ 146.78]                                         > stackOverflow(ptr: pointer): void
[ 146.79]                                          > stackOverflow(ptr: pointer): void
[ 146.79]                                           > stackOverflow(ptr: pointer): void
[ 146.80]                                            > stackOverflow(ptr: pointer): void
[ 146.81]                                             > stackOverflow(ptr: pointer): void
[ 146.82]                                              > stackOverflow(ptr: pointer): void
[ 146.83]                                               > stackOverflow(ptr: pointer): void
[ 146.84]                                                > stackOverflow(ptr: pointer): void
[ 146.84]                                                 > stackOverflow(ptr: pointer): void
[ 146.85]                                                  > stackOverflow(ptr: pointer): void
[ 146.86]                                                   > stackOverflow(ptr: pointer): void
[ 146.87]                                                    > stackOverflow(ptr: pointer): void
[ 146.88]                                                     > stackOverflow(ptr: pointer): void
[ 146.88]                                                      > stackOverflow(ptr: pointer): void
[ 146.89]                                                       > stackOverflow(ptr: pointer): void
[ 146.90]                                                        > stackOverflow(ptr: pointer): void
[ 146.91]                                                         > stackOverflow(ptr: pointer): void
[ 146.92]                                                          > stackOverflow(ptr: pointer): void
[ 146.92]                                                           > stackOverflow(ptr: pointer): void
[ 146.93]                                                            > stackOverflow(ptr: pointer): void
[ 146.94]                                                             > stackOverflow(ptr: pointer): void
[ 146.95]                                                              > stackOverflow(ptr: pointer): void
[ 146.96]                                                               > stackOverflow(ptr: pointer): void
[ 146.96]                                                                > stackOverflow(ptr: pointer): void
[ 146.97]                                                                 > stackOverflow(ptr: pointer): void
[ 146.98]                                                                  > stackOverflow(ptr: pointer): void
[ 146.99]                                                                   > stackOverflow(ptr: pointer): void
[ 147.00]                                                                    > stackOverflow(ptr: pointer): void
[ 147.00]                                                                     > stackOverflow(ptr: pointer): void
[ 147.01]                                                                      > stackOverflow(ptr: pointer): void
[ 147.02]                                                                       > stackOverflow(ptr: pointer): void
[ 147.03]                                                                        > stackOverflow(ptr: pointer): void
[ 147.04]                                                                         > stackOverflow(ptr: pointer): void
[ 147.04]                                                                          > stackOverflow(ptr: pointer): void
[ 147.05]                                                                           > stackOverflow(ptr: pointer): void
[ 147.06]                                                                            > stackOverflow(ptr: pointer): void
[ 147.07]                                                                             > stackOverflow(ptr: pointer): void
[ 147.08]                                                                              > stackOverflow(ptr: pointer): void
[ 147.09]                                                                               > stackOverflow(ptr: pointer): void
[ 147.09]                                                                                > stackOverflow(ptr: pointer): void
[ 147.10]                                                                                 > stackOverflow(ptr: pointer): void
[ 147.11]                                                                                  > stackOverflow(ptr: pointer): void
[ 147.12]                                                                                   > stackOverflow(ptr: pointer): void
[ 147.12]                                                                                    > stackOverflow(ptr: pointer): void
[ 147.13]                                                                                     > stackOverflow(ptr: pointer): void
[ 147.14]                                                                                      > stackOverflow(ptr: pointer): void
[ 147.15]                                                                                       > stackOverflow(ptr: pointer): void
[ 147.16]                                                                                        > stackOverflow(ptr: pointer): void
[ 147.17]                                                                                         > stackOverflow(ptr: pointer): void
[ 147.18]                                                                                          > stackOverflow(ptr: pointer): void
[ 147.18]                                                                                           > stackOverflow(ptr: pointer): void
[ 147.19]                                                                                            > stackOverflow(ptr: pointer): void
[ 147.20]                                                                                             > stackOverflow(ptr: pointer): void
[ 147.21]                                                                                              > stackOverflow(ptr: pointer): void
[ 147.22]                                                                                               > stackOverflow(ptr: pointer): void
[ 147.22]                                                                                                > stackOverflow(ptr: pointer): void
[ 147.23]                                                                                                 > stackOverflow(ptr: pointer): void
[ 147.24]                                                                                                  > stackOverflow(ptr: pointer): void
[ 147.25]                                                                                                   > stackOverflow(ptr: pointer): void
[ 147.26]                                                                                                    > stackOverflow(ptr: pointer): void
[ 147.26]                                                                                                     > stackOverflow(ptr: pointer): void
[ 147.27]                                                                                                      > stackOverflow(ptr: pointer): void
[ 147.28]                                                                                                       > stackOverflow(ptr: pointer): void
[ 147.29]                                                                                                        > stackOverflow(ptr: pointer): void
[ 147.30]                                                                                                         > stackOverflow(ptr: pointer): void
[ 147.30]                                                                                                          > stackOverflow(ptr: pointer): void
[ 147.31]                                                                                                           > stackOverflow(ptr: pointer): void
[ 147.32]                                                                                                            > stackOverflow(ptr: pointer): void
[ 147.33]                                                                                                             > stackOverflow(ptr: pointer): void
[ 147.34]                                                                                                              > stackOverflow(ptr: pointer): void
[ 147.34]                                                                                                               > stackOverflow(ptr: pointer): void
[ 147.35]                                                                                                                > stackOverflow(ptr: pointer): void
[ 147.37]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 147.38]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 147.39]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 147.40]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 147.41]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 147.42]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 147.43]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 147.44]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 147.44]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 147.45]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 147.46]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 147.47]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 147.48]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 147.49]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 147.49]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 147.50]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 147.51]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 147.52]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 147.53]                                                                                                                                  < return
[ 147.53]                                                                                                                                 < return
[ 147.53]                                                                                                                                < return
[ 147.54]                                                                                                                               < return
[ 147.54]                                                                                                                              < return
[ 147.55]                                                                                                                             < return
[ 147.55]                                                                                                                            < return
[ 147.55]                                                                                                                           < return
[ 147.56]                                                                                                                          < return
[ 147.56]                                                                                                                         < return
[ 147.57]                                                                                                                        < return
[ 147.57]                                                                                                                       < return
[ 147.58]                                                                                                                      < return
[ 147.58]                                                                                                                     < return
[ 147.58]                                                                                                                    < return
[ 147.59]                                                                                                                   < return
[ 147.59]                                                                                                                  < return
[ 147.60]                                                                                                                 < return
[ 147.60]                                                                                                                < return
[ 147.60]                                                                                                               < return
[ 147.61]                                                                                                              < return
[ 147.61]                                                                                                             < return
[ 147.62]                                                                                                            < return
[ 147.62]                                                                                                           < return
[ 147.62]                                                                                                          < return
[ 147.63]                                                                                                         < return
[ 147.63]                                                                                                        < return
[ 147.64]                                                                                                       < return
[ 147.64]                                                                                                      < return
[ 147.64]                                                                                                     < return
[ 147.65]                                                                                                    < return
[ 147.65]                                                                                                   < return
[ 147.66]                                                                                                  < return
[ 147.66]                                                                                                 < return
[ 147.66]                                                                                                < return
[ 147.67]                                                                                               < return
[ 147.67]                                                                                              < return
[ 147.68]                                                                                             < return
[ 147.68]                                                                                            < return
[ 147.68]                                                                                           < return
[ 147.69]                                                                                          < return
[ 147.69]                                                                                         < return
[ 147.69]                                                                                        < return
[ 147.70]                                                                                       < return
[ 147.70]                                                                                      < return
[ 147.71]                                                                                     < return
[ 147.71]                                                                                    < return
[ 147.72]                                                                                   < return
[ 147.72]                                                                                  < return
[ 147.72]                                                                                 < return
[ 147.73]                                                                                < return
[ 147.73]                                                                               < return
[ 147.74]                                                                              < return
[ 147.74]                                                                             < return
[ 147.74]                                                                            < return
[ 147.75]                                                                           < return
[ 147.75]                                                                          < return
[ 147.76]                                                                         < return
[ 147.76]                                                                        < return
[ 147.76]                                                                       < return
[ 147.77]                                                                      < return
[ 147.77]                                                                     < return
[ 147.78]                                                                    < return
[ 147.78]                                                                   < return
[ 147.78]                                                                  < return
[ 147.79]                                                                 < return
[ 147.79]                                                                < return
[ 147.79]                                                               < return
[ 147.80]                                                              < return
[ 147.80]                                                             < return
[ 147.81]                                                            < return
[ 147.81]                                                           < return
[ 147.81]                                                          < return
[ 147.82]                                                         < return
[ 147.82]                                                        < return
[ 147.83]                                                       < return
[ 147.83]                                                      < return
[ 147.83]                                                     < return
[ 147.84]                                                    < return
[ 147.84]                                                   < return
[ 147.85]                                                  < return
[ 147.85]                                                 < return
[ 147.85]                                                < return
[ 147.86]                                               < return
[ 147.86]                                              < return
[ 147.87]                                             < return
[ 147.87]                                            < return
[ 147.87]                                           < return
[ 147.88]                                          < return
[ 147.88]                                         < return
[ 147.88]                                        < return
[ 147.89]                                       < return
[ 147.89]                                      < return
[ 147.90]                                     < return
[ 147.90]                                    < return
[ 147.90]                                   < return
[ 147.91]                                  < return
[ 147.91]                                 < return
[ 147.92]                                < return
[ 147.92]                               < return
[ 147.93]                              < return
[ 147.93]                             < return
[ 147.93]                            < return
[ 147.94]                           < return
[ 147.94]                          < return
[ 147.94]                         < return
[ 147.95]                        < return
[ 147.95]                       < return
[ 147.96]                      < return
[ 147.96]                     < return
[ 147.96]                    < return
[ 147.97]                   < return
[ 147.97]                  < return
[ 147.97]                 < return
[ 147.98]                < return
[ 147.98]               < return
[ 147.99]              < return
[ 147.99]             < return
[ 147.99]            < return
[ 148.00]           < return
[ 148.00]          < return
[ 148.00]         < return
[ 148.01]        < return
[ 148.01]       < return
[ 148.02]      < return
[ 148.02]     < return
[ 148.02]    < return
[ 148.03]   < return
[ 148.03]  < return
[ 148.04]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 148.04]   > divisionByZero(args: pointer): void
[ 148.05]   < return
[ 148.06]  < return
[ 148.06]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 148.07]   > invalidInstruction(args: pointer): void
[ 148.08]   < return
[ 148.08]  < return
[ 148.09]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 148.09]   > invalidMemoryAccess(args: pointer): void
[ 148.10]   < return
[ 148.11]  < return
[ 148.11]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 148.12]   > abortExecution(args: pointer): void
[ 148.13]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/tryExec.ci:35: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	cmplStd/test/std/tryExec.ci:53: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 148.19]    < return
[ 148.20]   < return
[ 148.20]  < return
[ 148.34]  > object.create(type: typename): pointer
[ 148.35]  < return
[ 148.36]  > object.create(type: typename): pointer
[ 148.37]  < return
[ 148.39]  > funAdd(x: int32, y: int32): int32
[ 148.40]  < return
[ 148.41]  > funAdd(x: int32, y: int32): int32
[ 148.41]  < return
[ 148.42]  > funMul(x: int32, y: int32): int32
[ 148.43]  < return
[ 148.44]  > funMul(x: int32, y: int32): int32
[ 148.45]  < return
[ 148.46]  > fib(n: uint32): uint32
[ 148.47]   > fib(n: uint32): uint32
[ 148.48]    > fib(n: uint32): uint32
[ 148.49]     > fib(n: uint32): uint32
[ 148.50]      > fib(n: uint32): uint32
[ 148.51]       > fib(n: uint32): uint32
[ 148.52]        > fib(n: uint32): uint32
[ 148.53]         > fib(n: uint32): uint32
[ 148.54]          > fib(n: uint32): uint32
[ 148.55]           > fib(n: uint32): uint32
[ 148.56]            > fib(n: uint32): uint32
[ 148.57]             > fib(n: uint32): uint32
[ 148.58]              > fib(n: uint32): uint32
[ 148.59]              < return
[ 148.60]              > fib(n: uint32): uint32
[ 148.61]              < return
[ 148.61]             < return
[ 148.62]             > fib(n: uint32): uint32
[ 148.63]             < return
[ 148.63]            < return
[ 148.64]            > fib(n: uint32): uint32
[ 148.65]             > fib(n: uint32): uint32
[ 148.66]             < return
[ 148.66]             > fib(n: uint32): uint32
[ 148.67]             < return
[ 148.68]            < return
[ 148.68]           < return
[ 148.69]           > fib(n: uint32): uint32
[ 148.70]            > fib(n: uint32): uint32
[ 148.71]             > fib(n: uint32): uint32
[ 148.72]             < return
[ 148.72]             > fib(n: uint32): uint32
[ 148.73]             < return
[ 148.74]            < return
[ 148.74]            > fib(n: uint32): uint32
[ 148.75]            < return
[ 148.76]           < return
[ 148.76]          < return
[ 148.77]          > fib(n: uint32): uint32
[ 148.78]           > fib(n: uint32): uint32
[ 148.79]            > fib(n: uint32): uint32
[ 148.80]             > fib(n: uint32): uint32
[ 148.81]             < return
[ 148.81]             > fib(n: uint32): uint32
[ 148.82]             < return
[ 148.83]            < return
[ 148.83]            > fib(n: uint32): uint32
[ 148.84]            < return
[ 148.85]           < return
[ 148.85]           > fib(n: uint32): uint32
[ 148.86]            > fib(n: uint32): uint32
[ 148.87]            < return
[ 148.88]            > fib(n: uint32): uint32
[ 148.89]            < return
[ 148.89]           < return
[ 148.90]          < return
[ 148.90]         < return
[ 148.91]         > fib(n: uint32): uint32
[ 148.92]          > fib(n: uint32): uint32
[ 148.93]           > fib(n: uint32): uint32
[ 148.94]            > fib(n: uint32): uint32
[ 148.95]             > fib(n: uint32): uint32
[ 148.96]             < return
[ 148.96]             > fib(n: uint32): uint32
[ 148.97]             < return
[ 148.98]            < return
[ 148.98]            > fib(n: uint32): uint32
[ 148.99]            < return
[ 149.00]           < return
[ 149.00]           > fib(n: uint32): uint32
[ 149.01]            > fib(n: uint32): uint32
[ 149.02]            < return
[ 149.03]            > fib(n: uint32): uint32
[ 149.04]            < return
[ 149.04]           < return
[ 149.05]          < return
[ 149.05]          > fib(n: uint32): uint32
[ 149.06]           > fib(n: uint32): uint32
[ 149.07]            > fib(n: uint32): uint32
[ 149.08]            < return
[ 149.09]            > fib(n: uint32): uint32
[ 149.09]            < return
[ 149.10]           < return
[ 149.11]           > fib(n: uint32): uint32
[ 149.12]           < return
[ 149.12]          < return
[ 149.12]         < return
[ 149.13]        < return
[ 149.13]        > fib(n: uint32): uint32
[ 149.15]         > fib(n: uint32): uint32
[ 149.16]          > fib(n: uint32): uint32
[ 149.17]           > fib(n: uint32): uint32
[ 149.18]            > fib(n: uint32): uint32
[ 149.19]             > fib(n: uint32): uint32
[ 149.19]             < return
[ 149.20]             > fib(n: uint32): uint32
[ 149.21]             < return
[ 149.22]            < return
[ 149.22]            > fib(n: uint32): uint32
[ 149.23]            < return
[ 149.24]           < return
[ 149.24]           > fib(n: uint32): uint32
[ 149.25]            > fib(n: uint32): uint32
[ 149.26]            < return
[ 149.26]            > fib(n: uint32): uint32
[ 149.27]            < return
[ 149.28]           < return
[ 149.28]          < return
[ 149.29]          > fib(n: uint32): uint32
[ 149.30]           > fib(n: uint32): uint32
[ 149.31]            > fib(n: uint32): uint32
[ 149.32]            < return
[ 149.32]            > fib(n: uint32): uint32
[ 149.33]            < return
[ 149.34]           < return
[ 149.34]           > fib(n: uint32): uint32
[ 149.35]           < return
[ 149.36]          < return
[ 149.36]         < return
[ 149.37]         > fib(n: uint32): uint32
[ 149.38]          > fib(n: uint32): uint32
[ 149.39]           > fib(n: uint32): uint32
[ 149.40]            > fib(n: uint32): uint32
[ 149.41]            < return
[ 149.41]            > fib(n: uint32): uint32
[ 149.42]            < return
[ 149.43]           < return
[ 149.43]           > fib(n: uint32): uint32
[ 149.44]           < return
[ 149.45]          < return
[ 149.45]          > fib(n: uint32): uint32
[ 149.46]           > fib(n: uint32): uint32
[ 149.47]           < return
[ 149.48]           > fib(n: uint32): uint32
[ 149.49]           < return
[ 149.49]          < return
[ 149.50]         < return
[ 149.50]        < return
[ 149.51]       < return
[ 149.51]       > fib(n: uint32): uint32
[ 149.52]        > fib(n: uint32): uint32
[ 149.53]         > fib(n: uint32): uint32
[ 149.54]          > fib(n: uint32): uint32
[ 149.55]           > fib(n: uint32): uint32
[ 149.56]            > fib(n: uint32): uint32
[ 149.57]             > fib(n: uint32): uint32
[ 149.58]             < return
[ 149.59]             > fib(n: uint32): uint32
[ 149.60]             < return
[ 149.60]            < return
[ 149.61]            > fib(n: uint32): uint32
[ 149.62]            < return
[ 149.62]           < return
[ 149.63]           > fib(n: uint32): uint32
[ 149.64]            > fib(n: uint32): uint32
[ 149.65]            < return
[ 149.66]            > fib(n: uint32): uint32
[ 149.66]            < return
[ 149.67]           < return
[ 149.67]          < return
[ 149.68]          > fib(n: uint32): uint32
[ 149.69]           > fib(n: uint32): uint32
[ 149.70]            > fib(n: uint32): uint32
[ 149.71]            < return
[ 149.71]            > fib(n: uint32): uint32
[ 149.72]            < return
[ 149.73]           < return
[ 149.73]           > fib(n: uint32): uint32
[ 149.74]           < return
[ 149.75]          < return
[ 149.75]         < return
[ 149.76]         > fib(n: uint32): uint32
[ 149.77]          > fib(n: uint32): uint32
[ 149.78]           > fib(n: uint32): uint32
[ 149.79]            > fib(n: uint32): uint32
[ 149.80]            < return
[ 149.80]            > fib(n: uint32): uint32
[ 149.81]            < return
[ 149.82]           < return
[ 149.82]           > fib(n: uint32): uint32
[ 149.83]           < return
[ 149.84]          < return
[ 149.84]          > fib(n: uint32): uint32
[ 149.85]           > fib(n: uint32): uint32
[ 149.86]           < return
[ 149.87]           > fib(n: uint32): uint32
[ 149.88]           < return
[ 149.88]          < return
[ 149.89]         < return
[ 149.89]        < return
[ 149.90]        > fib(n: uint32): uint32
[ 149.91]         > fib(n: uint32): uint32
[ 149.92]          > fib(n: uint32): uint32
[ 149.93]           > fib(n: uint32): uint32
[ 149.94]            > fib(n: uint32): uint32
[ 149.95]            < return
[ 149.95]            > fib(n: uint32): uint32
[ 149.96]            < return
[ 149.97]           < return
[ 149.97]           > fib(n: uint32): uint32
[ 149.98]           < return
[ 149.99]          < return
[ 149.99]          > fib(n: uint32): uint32
[ 150.00]           > fib(n: uint32): uint32
[ 150.01]           < return
[ 150.02]           > fib(n: uint32): uint32
[ 150.03]           < return
[ 150.03]          < return
[ 150.03]         < return
[ 150.04]         > fib(n: uint32): uint32
[ 150.05]          > fib(n: uint32): uint32
[ 150.06]           > fib(n: uint32): uint32
[ 150.07]           < return
[ 150.08]           > fib(n: uint32): uint32
[ 150.09]           < return
[ 150.09]          < return
[ 150.09]          > fib(n: uint32): uint32
[ 150.10]          < return
[ 150.11]         < return
[ 150.11]        < return
[ 150.12]       < return
[ 150.12]      < return
[ 150.13]      > fib(n: uint32): uint32
[ 150.14]       > fib(n: uint32): uint32
[ 150.15]        > fib(n: uint32): uint32
[ 150.16]         > fib(n: uint32): uint32
[ 150.17]          > fib(n: uint32): uint32
[ 150.18]           > fib(n: uint32): uint32
[ 150.19]            > fib(n: uint32): uint32
[ 150.20]             > fib(n: uint32): uint32
[ 150.21]             < return
[ 150.22]             > fib(n: uint32): uint32
[ 150.22]             < return
[ 150.23]            < return
[ 150.24]            > fib(n: uint32): uint32
[ 150.24]            < return
[ 150.25]           < return
[ 150.25]           > fib(n: uint32): uint32
[ 150.26]            > fib(n: uint32): uint32
[ 150.27]            < return
[ 150.28]            > fib(n: uint32): uint32
[ 150.29]            < return
[ 150.29]           < return
[ 150.30]          < return
[ 150.30]          > fib(n: uint32): uint32
[ 150.31]           > fib(n: uint32): uint32
[ 150.32]            > fib(n: uint32): uint32
[ 150.33]            < return
[ 150.34]            > fib(n: uint32): uint32
[ 150.35]            < return
[ 150.35]           < return
[ 150.36]           > fib(n: uint32): uint32
[ 150.37]           < return
[ 150.37]          < return
[ 150.38]         < return
[ 150.38]         > fib(n: uint32): uint32
[ 150.39]          > fib(n: uint32): uint32
[ 150.40]           > fib(n: uint32): uint32
[ 150.41]            > fib(n: uint32): uint32
[ 150.42]            < return
[ 150.43]            > fib(n: uint32): uint32
[ 150.44]            < return
[ 150.44]           < return
[ 150.45]           > fib(n: uint32): uint32
[ 150.46]           < return
[ 150.46]          < return
[ 150.47]          > fib(n: uint32): uint32
[ 150.48]           > fib(n: uint32): uint32
[ 150.49]           < return
[ 150.49]           > fib(n: uint32): uint32
[ 150.50]           < return
[ 150.51]          < return
[ 150.51]         < return
[ 150.52]        < return
[ 150.52]        > fib(n: uint32): uint32
[ 150.53]         > fib(n: uint32): uint32
[ 150.54]          > fib(n: uint32): uint32
[ 150.55]           > fib(n: uint32): uint32
[ 150.56]            > fib(n: uint32): uint32
[ 150.57]            < return
[ 150.58]            > fib(n: uint32): uint32
[ 150.59]            < return
[ 150.59]           < return
[ 150.60]           > fib(n: uint32): uint32
[ 150.61]           < return
[ 150.61]          < return
[ 150.62]          > fib(n: uint32): uint32
[ 150.63]           > fib(n: uint32): uint32
[ 150.64]           < return
[ 150.64]           > fib(n: uint32): uint32
[ 150.65]           < return
[ 150.66]          < return
[ 150.66]         < return
[ 150.67]         > fib(n: uint32): uint32
[ 150.68]          > fib(n: uint32): uint32
[ 150.69]           > fib(n: uint32): uint32
[ 150.70]           < return
[ 150.70]           > fib(n: uint32): uint32
[ 150.71]           < return
[ 150.72]          < return
[ 150.72]          > fib(n: uint32): uint32
[ 150.73]          < return
[ 150.74]         < return
[ 150.74]        < return
[ 150.74]       < return
[ 150.75]       > fib(n: uint32): uint32
[ 150.76]        > fib(n: uint32): uint32
[ 150.77]         > fib(n: uint32): uint32
[ 150.78]          > fib(n: uint32): uint32
[ 150.79]           > fib(n: uint32): uint32
[ 150.80]            > fib(n: uint32): uint32
[ 150.81]            < return
[ 150.82]            > fib(n: uint32): uint32
[ 150.82]            < return
[ 150.83]           < return
[ 150.84]           > fib(n: uint32): uint32
[ 150.84]           < return
[ 150.85]          < return
[ 150.85]          > fib(n: uint32): uint32
[ 150.87]           > fib(n: uint32): uint32
[ 150.87]           < return
[ 150.88]           > fib(n: uint32): uint32
[ 150.89]           < return
[ 150.89]          < return
[ 150.90]         < return
[ 150.90]         > fib(n: uint32): uint32
[ 150.91]          > fib(n: uint32): uint32
[ 150.92]           > fib(n: uint32): uint32
[ 150.93]           < return
[ 150.94]           > fib(n: uint32): uint32
[ 150.95]           < return
[ 150.95]          < return
[ 150.96]          > fib(n: uint32): uint32
[ 150.97]          < return
[ 150.97]         < return
[ 150.98]        < return
[ 150.98]        > fib(n: uint32): uint32
[ 150.99]         > fib(n: uint32): uint32
[ 151.00]          > fib(n: uint32): uint32
[ 151.01]           > fib(n: uint32): uint32
[ 151.02]           < return
[ 151.03]           > fib(n: uint32): uint32
[ 151.04]           < return
[ 151.04]          < return
[ 151.05]          > fib(n: uint32): uint32
[ 151.06]          < return
[ 151.06]         < return
[ 151.07]         > fib(n: uint32): uint32
[ 151.08]          > fib(n: uint32): uint32
[ 151.09]          < return
[ 151.09]          > fib(n: uint32): uint32
[ 151.10]          < return
[ 151.10]         < return
[ 151.11]        < return
[ 151.11]       < return
[ 151.12]      < return
[ 151.12]     < return
[ 151.13]     > fib(n: uint32): uint32
[ 151.14]      > fib(n: uint32): uint32
[ 151.15]       > fib(n: uint32): uint32
[ 151.16]        > fib(n: uint32): uint32
[ 151.17]         > fib(n: uint32): uint32
[ 151.18]          > fib(n: uint32): uint32
[ 151.19]           > fib(n: uint32): uint32
[ 151.20]            > fib(n: uint32): uint32
[ 151.21]             > fib(n: uint32): uint32
[ 151.22]             < return
[ 151.23]             > fib(n: uint32): uint32
[ 151.24]             < return
[ 151.24]            < return
[ 151.25]            > fib(n: uint32): uint32
[ 151.25]            < return
[ 151.26]           < return
[ 151.27]           > fib(n: uint32): uint32
[ 151.28]            > fib(n: uint32): uint32
[ 151.29]            < return
[ 151.29]            > fib(n: uint32): uint32
[ 151.30]            < return
[ 151.31]           < return
[ 151.31]          < return
[ 151.32]          > fib(n: uint32): uint32
[ 151.33]           > fib(n: uint32): uint32
[ 151.34]            > fib(n: uint32): uint32
[ 151.35]            < return
[ 151.35]            > fib(n: uint32): uint32
[ 151.36]            < return
[ 151.37]           < return
[ 151.37]           > fib(n: uint32): uint32
[ 151.38]           < return
[ 151.38]          < return
[ 151.39]         < return
[ 151.40]         > fib(n: uint32): uint32
[ 151.41]          > fib(n: uint32): uint32
[ 151.42]           > fib(n: uint32): uint32
[ 151.43]            > fib(n: uint32): uint32
[ 151.44]            < return
[ 151.44]            > fib(n: uint32): uint32
[ 151.45]            < return
[ 151.46]           < return
[ 151.46]           > fib(n: uint32): uint32
[ 151.47]           < return
[ 151.47]          < return
[ 151.48]          > fib(n: uint32): uint32
[ 151.49]           > fib(n: uint32): uint32
[ 151.50]           < return
[ 151.50]           > fib(n: uint32): uint32
[ 151.51]           < return
[ 151.52]          < return
[ 151.52]         < return
[ 151.53]        < return
[ 151.53]        > fib(n: uint32): uint32
[ 151.54]         > fib(n: uint32): uint32
[ 151.55]          > fib(n: uint32): uint32
[ 151.56]           > fib(n: uint32): uint32
[ 151.57]            > fib(n: uint32): uint32
[ 151.58]            < return
[ 151.59]            > fib(n: uint32): uint32
[ 151.60]            < return
[ 151.60]           < return
[ 151.61]           > fib(n: uint32): uint32
[ 151.62]           < return
[ 151.62]          < return
[ 151.63]          > fib(n: uint32): uint32
[ 151.64]           > fib(n: uint32): uint32
[ 151.65]           < return
[ 151.65]           > fib(n: uint32): uint32
[ 151.66]           < return
[ 151.67]          < return
[ 151.67]         < return
[ 151.68]         > fib(n: uint32): uint32
[ 151.69]          > fib(n: uint32): uint32
[ 151.70]           > fib(n: uint32): uint32
[ 151.71]           < return
[ 151.71]           > fib(n: uint32): uint32
[ 151.72]           < return
[ 151.73]          < return
[ 151.73]          > fib(n: uint32): uint32
[ 151.74]          < return
[ 151.75]         < return
[ 151.75]        < return
[ 151.76]       < return
[ 151.76]       > fib(n: uint32): uint32
[ 151.77]        > fib(n: uint32): uint32
[ 151.78]         > fib(n: uint32): uint32
[ 151.79]          > fib(n: uint32): uint32
[ 151.80]           > fib(n: uint32): uint32
[ 151.81]            > fib(n: uint32): uint32
[ 151.82]            < return
[ 151.83]            > fib(n: uint32): uint32
[ 151.84]            < return
[ 151.84]           < return
[ 151.85]           > fib(n: uint32): uint32
[ 151.86]           < return
[ 151.86]          < return
[ 151.87]          > fib(n: uint32): uint32
[ 151.88]           > fib(n: uint32): uint32
[ 151.89]           < return
[ 151.89]           > fib(n: uint32): uint32
[ 151.90]           < return
[ 151.91]          < return
[ 151.91]         < return
[ 151.92]         > fib(n: uint32): uint32
[ 151.93]          > fib(n: uint32): uint32
[ 151.94]           > fib(n: uint32): uint32
[ 151.95]           < return
[ 151.95]           > fib(n: uint32): uint32
[ 151.96]           < return
[ 151.97]          < return
[ 151.97]          > fib(n: uint32): uint32
[ 151.98]          < return
[ 151.99]         < return
[ 151.99]        < return
[ 152.00]        > fib(n: uint32): uint32
[ 152.01]         > fib(n: uint32): uint32
[ 152.02]          > fib(n: uint32): uint32
[ 152.03]           > fib(n: uint32): uint32
[ 152.04]           < return
[ 152.04]           > fib(n: uint32): uint32
[ 152.05]           < return
[ 152.06]          < return
[ 152.06]          > fib(n: uint32): uint32
[ 152.07]          < return
[ 152.07]         < return
[ 152.08]         > fib(n: uint32): uint32
[ 152.09]          > fib(n: uint32): uint32
[ 152.10]          < return
[ 152.11]          > fib(n: uint32): uint32
[ 152.12]          < return
[ 152.12]         < return
[ 152.12]        < return
[ 152.13]       < return
[ 152.13]      < return
[ 152.14]      > fib(n: uint32): uint32
[ 152.15]       > fib(n: uint32): uint32
[ 152.16]        > fib(n: uint32): uint32
[ 152.17]         > fib(n: uint32): uint32
[ 152.18]          > fib(n: uint32): uint32
[ 152.19]           > fib(n: uint32): uint32
[ 152.21]            > fib(n: uint32): uint32
[ 152.21]            < return
[ 152.22]            > fib(n: uint32): uint32
[ 152.23]            < return
[ 152.23]           < return
[ 152.24]           > fib(n: uint32): uint32
[ 152.25]           < return
[ 152.25]          < return
[ 152.26]          > fib(n: uint32): uint32
[ 152.27]           > fib(n: uint32): uint32
[ 152.28]           < return
[ 152.28]           > fib(n: uint32): uint32
[ 152.29]           < return
[ 152.30]          < return
[ 152.30]         < return
[ 152.31]         > fib(n: uint32): uint32
[ 152.32]          > fib(n: uint32): uint32
[ 152.33]           > fib(n: uint32): uint32
[ 152.34]           < return
[ 152.34]           > fib(n: uint32): uint32
[ 152.35]           < return
[ 152.36]          < return
[ 152.36]          > fib(n: uint32): uint32
[ 152.37]          < return
[ 152.38]         < return
[ 152.38]        < return
[ 152.39]        > fib(n: uint32): uint32
[ 152.40]         > fib(n: uint32): uint32
[ 152.41]          > fib(n: uint32): uint32
[ 152.42]           > fib(n: uint32): uint32
[ 152.43]           < return
[ 152.43]           > fib(n: uint32): uint32
[ 152.44]           < return
[ 152.45]          < return
[ 152.45]          > fib(n: uint32): uint32
[ 152.46]          < return
[ 152.47]         < return
[ 152.47]         > fib(n: uint32): uint32
[ 152.48]          > fib(n: uint32): uint32
[ 152.49]          < return
[ 152.50]          > fib(n: uint32): uint32
[ 152.51]          < return
[ 152.51]         < return
[ 152.52]        < return
[ 152.52]       < return
[ 152.53]       > fib(n: uint32): uint32
[ 152.54]        > fib(n: uint32): uint32
[ 152.55]         > fib(n: uint32): uint32
[ 152.56]          > fib(n: uint32): uint32
[ 152.57]           > fib(n: uint32): uint32
[ 152.58]           < return
[ 152.58]           > fib(n: uint32): uint32
[ 152.59]           < return
[ 152.60]          < return
[ 152.60]          > fib(n: uint32): uint32
[ 152.61]          < return
[ 152.62]         < return
[ 152.62]         > fib(n: uint32): uint32
[ 152.63]          > fib(n: uint32): uint32
[ 152.64]          < return
[ 152.65]          > fib(n: uint32): uint32
[ 152.66]          < return
[ 152.66]         < return
[ 152.66]        < return
[ 152.67]        > fib(n: uint32): uint32
[ 152.68]         > fib(n: uint32): uint32
[ 152.69]          > fib(n: uint32): uint32
[ 152.70]          < return
[ 152.71]          > fib(n: uint32): uint32
[ 152.72]          < return
[ 152.72]         < return
[ 152.73]         > fib(n: uint32): uint32
[ 152.74]         < return
[ 152.74]        < return
[ 152.74]       < return
[ 152.75]      < return
[ 152.75]     < return
[ 152.76]    < return
[ 152.76]    > fib(n: uint32): uint32
[ 152.77]     > fib(n: uint32): uint32
[ 152.78]      > fib(n: uint32): uint32
[ 152.79]       > fib(n: uint32): uint32
[ 152.81]        > fib(n: uint32): uint32
[ 152.82]         > fib(n: uint32): uint32
[ 152.83]          > fib(n: uint32): uint32
[ 152.84]           > fib(n: uint32): uint32
[ 152.85]            > fib(n: uint32): uint32
[ 152.86]             > fib(n: uint32): uint32
[ 152.87]             < return
[ 152.87]             > fib(n: uint32): uint32
[ 152.88]             < return
[ 152.89]            < return
[ 152.89]            > fib(n: uint32): uint32
[ 152.90]            < return
[ 152.91]           < return
[ 152.91]           > fib(n: uint32): uint32
[ 152.92]            > fib(n: uint32): uint32
[ 152.93]            < return
[ 152.94]            > fib(n: uint32): uint32
[ 152.94]            < return
[ 152.95]           < return
[ 152.96]          < return
[ 152.96]          > fib(n: uint32): uint32
[ 152.97]           > fib(n: uint32): uint32
[ 152.98]            > fib(n: uint32): uint32
[ 152.99]            < return
[ 153.00]            > fib(n: uint32): uint32
[ 153.01]            < return
[ 153.01]           < return
[ 153.02]           > fib(n: uint32): uint32
[ 153.03]           < return
[ 153.03]          < return
[ 153.04]         < return
[ 153.04]         > fib(n: uint32): uint32
[ 153.05]          > fib(n: uint32): uint32
[ 153.06]           > fib(n: uint32): uint32
[ 153.07]            > fib(n: uint32): uint32
[ 153.08]            < return
[ 153.09]            > fib(n: uint32): uint32
[ 153.10]            < return
[ 153.10]           < return
[ 153.11]           > fib(n: uint32): uint32
[ 153.12]           < return
[ 153.12]          < return
[ 153.13]          > fib(n: uint32): uint32
[ 153.14]           > fib(n: uint32): uint32
[ 153.15]           < return
[ 153.15]           > fib(n: uint32): uint32
[ 153.16]           < return
[ 153.17]          < return
[ 153.17]         < return
[ 153.18]        < return
[ 153.18]        > fib(n: uint32): uint32
[ 153.19]         > fib(n: uint32): uint32
[ 153.20]          > fib(n: uint32): uint32
[ 153.21]           > fib(n: uint32): uint32
[ 153.22]            > fib(n: uint32): uint32
[ 153.23]            < return
[ 153.24]            > fib(n: uint32): uint32
[ 153.25]            < return
[ 153.25]           < return
[ 153.26]           > fib(n: uint32): uint32
[ 153.26]           < return
[ 153.27]          < return
[ 153.28]          > fib(n: uint32): uint32
[ 153.29]           > fib(n: uint32): uint32
[ 153.29]           < return
[ 153.30]           > fib(n: uint32): uint32
[ 153.31]           < return
[ 153.31]          < return
[ 153.32]         < return
[ 153.32]         > fib(n: uint32): uint32
[ 153.34]          > fib(n: uint32): uint32
[ 153.35]           > fib(n: uint32): uint32
[ 153.35]           < return
[ 153.36]           > fib(n: uint32): uint32
[ 153.37]           < return
[ 153.37]          < return
[ 153.38]          > fib(n: uint32): uint32
[ 153.39]          < return
[ 153.39]         < return
[ 153.40]        < return
[ 153.40]       < return
[ 153.41]       > fib(n: uint32): uint32
[ 153.42]        > fib(n: uint32): uint32
[ 153.43]         > fib(n: uint32): uint32
[ 153.44]          > fib(n: uint32): uint32
[ 153.45]           > fib(n: uint32): uint32
[ 153.46]            > fib(n: uint32): uint32
[ 153.47]            < return
[ 153.48]            > fib(n: uint32): uint32
[ 153.49]            < return
[ 153.49]           < return
[ 153.50]           > fib(n: uint32): uint32
[ 153.50]           < return
[ 153.51]          < return
[ 153.51]          > fib(n: uint32): uint32
[ 153.53]           > fib(n: uint32): uint32
[ 153.53]           < return
[ 153.54]           > fib(n: uint32): uint32
[ 153.55]           < return
[ 153.55]          < return
[ 153.56]         < return
[ 153.56]         > fib(n: uint32): uint32
[ 153.57]          > fib(n: uint32): uint32
[ 153.59]           > fib(n: uint32): uint32
[ 153.59]           < return
[ 153.60]           > fib(n: uint32): uint32
[ 153.61]           < return
[ 153.61]          < return
[ 153.62]          > fib(n: uint32): uint32
[ 153.63]          < return
[ 153.63]         < return
[ 153.64]        < return
[ 153.64]        > fib(n: uint32): uint32
[ 153.65]         > fib(n: uint32): uint32
[ 153.66]          > fib(n: uint32): uint32
[ 153.67]           > fib(n: uint32): uint32
[ 153.68]           < return
[ 153.69]           > fib(n: uint32): uint32
[ 153.70]           < return
[ 153.70]          < return
[ 153.71]          > fib(n: uint32): uint32
[ 153.72]          < return
[ 153.72]         < return
[ 153.73]         > fib(n: uint32): uint32
[ 153.74]          > fib(n: uint32): uint32
[ 153.75]          < return
[ 153.75]          > fib(n: uint32): uint32
[ 153.76]          < return
[ 153.77]         < return
[ 153.77]        < return
[ 153.78]       < return
[ 153.78]      < return
[ 153.79]      > fib(n: uint32): uint32
[ 153.80]       > fib(n: uint32): uint32
[ 153.81]        > fib(n: uint32): uint32
[ 153.82]         > fib(n: uint32): uint32
[ 153.83]          > fib(n: uint32): uint32
[ 153.84]           > fib(n: uint32): uint32
[ 153.85]            > fib(n: uint32): uint32
[ 153.86]            < return
[ 153.87]            > fib(n: uint32): uint32
[ 153.87]            < return
[ 153.88]           < return
[ 153.88]           > fib(n: uint32): uint32
[ 153.89]           < return
[ 153.90]          < return
[ 153.90]          > fib(n: uint32): uint32
[ 153.91]           > fib(n: uint32): uint32
[ 153.92]           < return
[ 153.93]           > fib(n: uint32): uint32
[ 153.94]           < return
[ 153.94]          < return
[ 153.95]         < return
[ 153.95]         > fib(n: uint32): uint32
[ 153.96]          > fib(n: uint32): uint32
[ 153.97]           > fib(n: uint32): uint32
[ 153.98]           < return
[ 153.99]           > fib(n: uint32): uint32
[ 154.00]           < return
[ 154.00]          < return
[ 154.01]          > fib(n: uint32): uint32
[ 154.02]          < return
[ 154.02]         < return
[ 154.03]        < return
[ 154.03]        > fib(n: uint32): uint32
[ 154.04]         > fib(n: uint32): uint32
[ 154.05]          > fib(n: uint32): uint32
[ 154.06]           > fib(n: uint32): uint32
[ 154.07]           < return
[ 154.08]           > fib(n: uint32): uint32
[ 154.09]           < return
[ 154.09]          < return
[ 154.10]          > fib(n: uint32): uint32
[ 154.11]          < return
[ 154.11]         < return
[ 154.12]         > fib(n: uint32): uint32
[ 154.13]          > fib(n: uint32): uint32
[ 154.14]          < return
[ 154.14]          > fib(n: uint32): uint32
[ 154.15]          < return
[ 154.16]         < return
[ 154.16]        < return
[ 154.17]       < return
[ 154.17]       > fib(n: uint32): uint32
[ 154.18]        > fib(n: uint32): uint32
[ 154.19]         > fib(n: uint32): uint32
[ 154.20]          > fib(n: uint32): uint32
[ 154.21]           > fib(n: uint32): uint32
[ 154.22]           < return
[ 154.23]           > fib(n: uint32): uint32
[ 154.24]           < return
[ 154.24]          < return
[ 154.25]          > fib(n: uint32): uint32
[ 154.26]          < return
[ 154.26]         < return
[ 154.27]         > fib(n: uint32): uint32
[ 154.28]          > fib(n: uint32): uint32
[ 154.29]          < return
[ 154.29]          > fib(n: uint32): uint32
[ 154.30]          < return
[ 154.31]         < return
[ 154.31]        < return
[ 154.32]        > fib(n: uint32): uint32
[ 154.33]         > fib(n: uint32): uint32
[ 154.34]          > fib(n: uint32): uint32
[ 154.34]          < return
[ 154.35]          > fib(n: uint32): uint32
[ 154.36]          < return
[ 154.37]         < return
[ 154.37]         > fib(n: uint32): uint32
[ 154.38]         < return
[ 154.38]        < return
[ 154.39]       < return
[ 154.39]      < return
[ 154.40]     < return
[ 154.40]     > fib(n: uint32): uint32
[ 154.41]      > fib(n: uint32): uint32
[ 154.43]       > fib(n: uint32): uint32
[ 154.44]        > fib(n: uint32): uint32
[ 154.45]         > fib(n: uint32): uint32
[ 154.46]          > fib(n: uint32): uint32
[ 154.47]           > fib(n: uint32): uint32
[ 154.48]            > fib(n: uint32): uint32
[ 154.49]            < return
[ 154.49]            > fib(n: uint32): uint32
[ 154.50]            < return
[ 154.50]           < return
[ 154.51]           > fib(n: uint32): uint32
[ 154.52]           < return
[ 154.53]          < return
[ 154.53]          > fib(n: uint32): uint32
[ 154.54]           > fib(n: uint32): uint32
[ 154.55]           < return
[ 154.56]           > fib(n: uint32): uint32
[ 154.56]           < return
[ 154.57]          < return
[ 154.57]         < return
[ 154.58]         > fib(n: uint32): uint32
[ 154.59]          > fib(n: uint32): uint32
[ 154.60]           > fib(n: uint32): uint32
[ 154.61]           < return
[ 154.62]           > fib(n: uint32): uint32
[ 154.62]           < return
[ 154.63]          < return
[ 154.63]          > fib(n: uint32): uint32
[ 154.64]          < return
[ 154.65]         < return
[ 154.65]        < return
[ 154.66]        > fib(n: uint32): uint32
[ 154.67]         > fib(n: uint32): uint32
[ 154.68]          > fib(n: uint32): uint32
[ 154.69]           > fib(n: uint32): uint32
[ 154.70]           < return
[ 154.71]           > fib(n: uint32): uint32
[ 154.72]           < return
[ 154.72]          < return
[ 154.73]          > fib(n: uint32): uint32
[ 154.74]          < return
[ 154.74]         < return
[ 154.75]         > fib(n: uint32): uint32
[ 154.76]          > fib(n: uint32): uint32
[ 154.77]          < return
[ 154.77]          > fib(n: uint32): uint32
[ 154.78]          < return
[ 154.78]         < return
[ 154.79]        < return
[ 154.79]       < return
[ 154.80]       > fib(n: uint32): uint32
[ 154.81]        > fib(n: uint32): uint32
[ 154.82]         > fib(n: uint32): uint32
[ 154.83]          > fib(n: uint32): uint32
[ 154.84]           > fib(n: uint32): uint32
[ 154.85]           < return
[ 154.86]           > fib(n: uint32): uint32
[ 154.87]           < return
[ 154.87]          < return
[ 154.88]          > fib(n: uint32): uint32
[ 154.88]          < return
[ 154.89]         < return
[ 154.90]         > fib(n: uint32): uint32
[ 154.91]          > fib(n: uint32): uint32
[ 154.91]          < return
[ 154.92]          > fib(n: uint32): uint32
[ 154.93]          < return
[ 154.94]         < return
[ 154.94]        < return
[ 154.94]        > fib(n: uint32): uint32
[ 154.96]         > fib(n: uint32): uint32
[ 154.97]          > fib(n: uint32): uint32
[ 154.97]          < return
[ 154.98]          > fib(n: uint32): uint32
[ 154.99]          < return
[ 154.99]         < return
[ 155.00]         > fib(n: uint32): uint32
[ 155.01]         < return
[ 155.01]        < return
[ 155.02]       < return
[ 155.02]      < return
[ 155.03]      > fib(n: uint32): uint32
[ 155.04]       > fib(n: uint32): uint32
[ 155.05]        > fib(n: uint32): uint32
[ 155.06]         > fib(n: uint32): uint32
[ 155.07]          > fib(n: uint32): uint32
[ 155.08]           > fib(n: uint32): uint32
[ 155.09]           < return
[ 155.09]           > fib(n: uint32): uint32
[ 155.10]           < return
[ 155.11]          < return
[ 155.11]          > fib(n: uint32): uint32
[ 155.12]          < return
[ 155.13]         < return
[ 155.13]         > fib(n: uint32): uint32
[ 155.14]          > fib(n: uint32): uint32
[ 155.15]          < return
[ 155.16]          > fib(n: uint32): uint32
[ 155.17]          < return
[ 155.17]         < return
[ 155.18]        < return
[ 155.18]        > fib(n: uint32): uint32
[ 155.19]         > fib(n: uint32): uint32
[ 155.20]          > fib(n: uint32): uint32
[ 155.21]          < return
[ 155.22]          > fib(n: uint32): uint32
[ 155.23]          < return
[ 155.23]         < return
[ 155.24]         > fib(n: uint32): uint32
[ 155.25]         < return
[ 155.25]        < return
[ 155.26]       < return
[ 155.26]       > fib(n: uint32): uint32
[ 155.27]        > fib(n: uint32): uint32
[ 155.28]         > fib(n: uint32): uint32
[ 155.29]          > fib(n: uint32): uint32
[ 155.30]          < return
[ 155.31]          > fib(n: uint32): uint32
[ 155.32]          < return
[ 155.32]         < return
[ 155.33]         > fib(n: uint32): uint32
[ 155.34]         < return
[ 155.34]        < return
[ 155.35]        > fib(n: uint32): uint32
[ 155.36]         > fib(n: uint32): uint32
[ 155.37]         < return
[ 155.37]         > fib(n: uint32): uint32
[ 155.38]         < return
[ 155.38]        < return
[ 155.39]       < return
[ 155.40]      < return
[ 155.40]     < return
[ 155.40]    < return
[ 155.41]   < return
[ 155.41]   > fib(n: uint32): uint32
[ 155.43]    > fib(n: uint32): uint32
[ 155.44]     > fib(n: uint32): uint32
[ 155.44]      > fib(n: uint32): uint32
[ 155.46]       > fib(n: uint32): uint32
[ 155.47]        > fib(n: uint32): uint32
[ 155.48]         > fib(n: uint32): uint32
[ 155.49]          > fib(n: uint32): uint32
[ 155.50]           > fib(n: uint32): uint32
[ 155.51]            > fib(n: uint32): uint32
[ 155.52]             > fib(n: uint32): uint32
[ 155.53]             < return
[ 155.53]             > fib(n: uint32): uint32
[ 155.54]             < return
[ 155.55]            < return
[ 155.55]            > fib(n: uint32): uint32
[ 155.56]            < return
[ 155.57]           < return
[ 155.57]           > fib(n: uint32): uint32
[ 155.58]            > fib(n: uint32): uint32
[ 155.59]            < return
[ 155.60]            > fib(n: uint32): uint32
[ 155.61]            < return
[ 155.61]           < return
[ 155.62]          < return
[ 155.62]          > fib(n: uint32): uint32
[ 155.63]           > fib(n: uint32): uint32
[ 155.64]            > fib(n: uint32): uint32
[ 155.65]            < return
[ 155.66]            > fib(n: uint32): uint32
[ 155.67]            < return
[ 155.67]           < return
[ 155.68]           > fib(n: uint32): uint32
[ 155.69]           < return
[ 155.69]          < return
[ 155.70]         < return
[ 155.70]         > fib(n: uint32): uint32
[ 155.71]          > fib(n: uint32): uint32
[ 155.72]           > fib(n: uint32): uint32
[ 155.73]            > fib(n: uint32): uint32
[ 155.74]            < return
[ 155.75]            > fib(n: uint32): uint32
[ 155.76]            < return
[ 155.76]           < return
[ 155.77]           > fib(n: uint32): uint32
[ 155.78]           < return
[ 155.78]          < return
[ 155.79]          > fib(n: uint32): uint32
[ 155.80]           > fib(n: uint32): uint32
[ 155.81]           < return
[ 155.81]           > fib(n: uint32): uint32
[ 155.82]           < return
[ 155.83]          < return
[ 155.83]         < return
[ 155.84]        < return
[ 155.84]        > fib(n: uint32): uint32
[ 155.85]         > fib(n: uint32): uint32
[ 155.86]          > fib(n: uint32): uint32
[ 155.87]           > fib(n: uint32): uint32
[ 155.88]            > fib(n: uint32): uint32
[ 155.89]            < return
[ 155.90]            > fib(n: uint32): uint32
[ 155.91]            < return
[ 155.91]           < return
[ 155.92]           > fib(n: uint32): uint32
[ 155.93]           < return
[ 155.93]          < return
[ 155.94]          > fib(n: uint32): uint32
[ 155.95]           > fib(n: uint32): uint32
[ 155.96]           < return
[ 155.96]           > fib(n: uint32): uint32
[ 155.97]           < return
[ 155.97]          < return
[ 155.98]         < return
[ 155.99]         > fib(n: uint32): uint32
[ 156.00]          > fib(n: uint32): uint32
[ 156.00]           > fib(n: uint32): uint32
[ 156.01]           < return
[ 156.02]           > fib(n: uint32): uint32
[ 156.03]           < return
[ 156.03]          < return
[ 156.04]          > fib(n: uint32): uint32
[ 156.05]          < return
[ 156.05]         < return
[ 156.06]        < return
[ 156.06]       < return
[ 156.07]       > fib(n: uint32): uint32
[ 156.08]        > fib(n: uint32): uint32
[ 156.09]         > fib(n: uint32): uint32
[ 156.10]          > fib(n: uint32): uint32
[ 156.11]           > fib(n: uint32): uint32
[ 156.12]            > fib(n: uint32): uint32
[ 156.13]            < return
[ 156.13]            > fib(n: uint32): uint32
[ 156.14]            < return
[ 156.15]           < return
[ 156.15]           > fib(n: uint32): uint32
[ 156.16]           < return
[ 156.17]          < return
[ 156.17]          > fib(n: uint32): uint32
[ 156.18]           > fib(n: uint32): uint32
[ 156.19]           < return
[ 156.20]           > fib(n: uint32): uint32
[ 156.21]           < return
[ 156.22]          < return
[ 156.22]         < return
[ 156.22]         > fib(n: uint32): uint32
[ 156.24]          > fib(n: uint32): uint32
[ 156.25]           > fib(n: uint32): uint32
[ 156.25]           < return
[ 156.26]           > fib(n: uint32): uint32
[ 156.27]           < return
[ 156.27]          < return
[ 156.28]          > fib(n: uint32): uint32
[ 156.29]          < return
[ 156.29]         < return
[ 156.30]        < return
[ 156.30]        > fib(n: uint32): uint32
[ 156.31]         > fib(n: uint32): uint32
[ 156.32]          > fib(n: uint32): uint32
[ 156.34]           > fib(n: uint32): uint32
[ 156.34]           < return
[ 156.35]           > fib(n: uint32): uint32
[ 156.36]           < return
[ 156.36]          < return
[ 156.37]          > fib(n: uint32): uint32
[ 156.38]          < return
[ 156.38]         < return
[ 156.39]         > fib(n: uint32): uint32
[ 156.40]          > fib(n: uint32): uint32
[ 156.41]          < return
[ 156.42]          > fib(n: uint32): uint32
[ 156.42]          < return
[ 156.43]         < return
[ 156.43]        < return
[ 156.44]       < return
[ 156.44]      < return
[ 156.45]      > fib(n: uint32): uint32
[ 156.46]       > fib(n: uint32): uint32
[ 156.47]        > fib(n: uint32): uint32
[ 156.48]         > fib(n: uint32): uint32
[ 156.49]          > fib(n: uint32): uint32
[ 156.50]           > fib(n: uint32): uint32
[ 156.51]            > fib(n: uint32): uint32
[ 156.52]            < return
[ 156.53]            > fib(n: uint32): uint32
[ 156.53]            < return
[ 156.54]           < return
[ 156.55]           > fib(n: uint32): uint32
[ 156.55]           < return
[ 156.56]          < return
[ 156.56]          > fib(n: uint32): uint32
[ 156.57]           > fib(n: uint32): uint32
[ 156.58]           < return
[ 156.59]           > fib(n: uint32): uint32
[ 156.60]           < return
[ 156.60]          < return
[ 156.61]         < return
[ 156.61]         > fib(n: uint32): uint32
[ 156.62]          > fib(n: uint32): uint32
[ 156.63]           > fib(n: uint32): uint32
[ 156.64]           < return
[ 156.65]           > fib(n: uint32): uint32
[ 156.66]           < return
[ 156.66]          < return
[ 156.67]          > fib(n: uint32): uint32
[ 156.68]          < return
[ 156.68]         < return
[ 156.69]        < return
[ 156.69]        > fib(n: uint32): uint32
[ 156.70]         > fib(n: uint32): uint32
[ 156.71]          > fib(n: uint32): uint32
[ 156.72]           > fib(n: uint32): uint32
[ 156.73]           < return
[ 156.74]           > fib(n: uint32): uint32
[ 156.75]           < return
[ 156.75]          < return
[ 156.76]          > fib(n: uint32): uint32
[ 156.77]          < return
[ 156.77]         < return
[ 156.78]         > fib(n: uint32): uint32
[ 156.79]          > fib(n: uint32): uint32
[ 156.80]          < return
[ 156.80]          > fib(n: uint32): uint32
[ 156.81]          < return
[ 156.82]         < return
[ 156.82]        < return
[ 156.83]       < return
[ 156.83]       > fib(n: uint32): uint32
[ 156.84]        > fib(n: uint32): uint32
[ 156.85]         > fib(n: uint32): uint32
[ 156.86]          > fib(n: uint32): uint32
[ 156.87]           > fib(n: uint32): uint32
[ 156.88]           < return
[ 156.89]           > fib(n: uint32): uint32
[ 156.90]           < return
[ 156.90]          < return
[ 156.91]          > fib(n: uint32): uint32
[ 156.92]          < return
[ 156.92]         < return
[ 156.93]         > fib(n: uint32): uint32
[ 156.94]          > fib(n: uint32): uint32
[ 156.95]          < return
[ 156.95]          > fib(n: uint32): uint32
[ 156.96]          < return
[ 156.97]         < return
[ 156.97]        < return
[ 156.98]        > fib(n: uint32): uint32
[ 156.99]         > fib(n: uint32): uint32
[ 157.00]          > fib(n: uint32): uint32
[ 157.00]          < return
[ 157.01]          > fib(n: uint32): uint32
[ 157.02]          < return
[ 157.03]         < return
[ 157.03]         > fib(n: uint32): uint32
[ 157.04]         < return
[ 157.04]        < return
[ 157.05]       < return
[ 157.05]      < return
[ 157.06]     < return
[ 157.06]     > fib(n: uint32): uint32
[ 157.07]      > fib(n: uint32): uint32
[ 157.08]       > fib(n: uint32): uint32
[ 157.09]        > fib(n: uint32): uint32
[ 157.10]         > fib(n: uint32): uint32
[ 157.12]          > fib(n: uint32): uint32
[ 157.13]           > fib(n: uint32): uint32
[ 157.14]            > fib(n: uint32): uint32
[ 157.15]            < return
[ 157.15]            > fib(n: uint32): uint32
[ 157.16]            < return
[ 157.16]           < return
[ 157.17]           > fib(n: uint32): uint32
[ 157.18]           < return
[ 157.18]          < return
[ 157.19]          > fib(n: uint32): uint32
[ 157.20]           > fib(n: uint32): uint32
[ 157.21]           < return
[ 157.22]           > fib(n: uint32): uint32
[ 157.22]           < return
[ 157.23]          < return
[ 157.24]         < return
[ 157.24]         > fib(n: uint32): uint32
[ 157.25]          > fib(n: uint32): uint32
[ 157.26]           > fib(n: uint32): uint32
[ 157.27]           < return
[ 157.28]           > fib(n: uint32): uint32
[ 157.28]           < return
[ 157.29]          < return
[ 157.30]          > fib(n: uint32): uint32
[ 157.30]          < return
[ 157.31]         < return
[ 157.31]        < return
[ 157.32]        > fib(n: uint32): uint32
[ 157.33]         > fib(n: uint32): uint32
[ 157.34]          > fib(n: uint32): uint32
[ 157.35]           > fib(n: uint32): uint32
[ 157.36]           < return
[ 157.37]           > fib(n: uint32): uint32
[ 157.37]           < return
[ 157.38]          < return
[ 157.38]          > fib(n: uint32): uint32
[ 157.39]          < return
[ 157.40]         < return
[ 157.40]         > fib(n: uint32): uint32
[ 157.41]          > fib(n: uint32): uint32
[ 157.42]          < return
[ 157.43]          > fib(n: uint32): uint32
[ 157.44]          < return
[ 157.44]         < return
[ 157.45]        < return
[ 157.45]       < return
[ 157.46]       > fib(n: uint32): uint32
[ 157.47]        > fib(n: uint32): uint32
[ 157.48]         > fib(n: uint32): uint32
[ 157.49]          > fib(n: uint32): uint32
[ 157.50]           > fib(n: uint32): uint32
[ 157.51]           < return
[ 157.51]           > fib(n: uint32): uint32
[ 157.52]           < return
[ 157.53]          < return
[ 157.53]          > fib(n: uint32): uint32
[ 157.54]          < return
[ 157.55]         < return
[ 157.55]         > fib(n: uint32): uint32
[ 157.56]          > fib(n: uint32): uint32
[ 157.57]          < return
[ 157.58]          > fib(n: uint32): uint32
[ 157.59]          < return
[ 157.59]         < return
[ 157.60]        < return
[ 157.60]        > fib(n: uint32): uint32
[ 157.61]         > fib(n: uint32): uint32
[ 157.62]          > fib(n: uint32): uint32
[ 157.63]          < return
[ 157.64]          > fib(n: uint32): uint32
[ 157.65]          < return
[ 157.65]         < return
[ 157.66]         > fib(n: uint32): uint32
[ 157.67]         < return
[ 157.67]        < return
[ 157.68]       < return
[ 157.68]      < return
[ 157.69]      > fib(n: uint32): uint32
[ 157.70]       > fib(n: uint32): uint32
[ 157.71]        > fib(n: uint32): uint32
[ 157.72]         > fib(n: uint32): uint32
[ 157.73]          > fib(n: uint32): uint32
[ 157.74]           > fib(n: uint32): uint32
[ 157.75]           < return
[ 157.75]           > fib(n: uint32): uint32
[ 157.76]           < return
[ 157.77]          < return
[ 157.77]          > fib(n: uint32): uint32
[ 157.78]          < return
[ 157.78]         < return
[ 157.79]         > fib(n: uint32): uint32
[ 157.80]          > fib(n: uint32): uint32
[ 157.81]          < return
[ 157.82]          > fib(n: uint32): uint32
[ 157.82]          < return
[ 157.83]         < return
[ 157.83]        < return
[ 157.84]        > fib(n: uint32): uint32
[ 157.85]         > fib(n: uint32): uint32
[ 157.86]          > fib(n: uint32): uint32
[ 157.87]          < return
[ 157.88]          > fib(n: uint32): uint32
[ 157.88]          < return
[ 157.89]         < return
[ 157.90]         > fib(n: uint32): uint32
[ 157.90]         < return
[ 157.91]        < return
[ 157.91]       < return
[ 157.92]       > fib(n: uint32): uint32
[ 157.93]        > fib(n: uint32): uint32
[ 157.94]         > fib(n: uint32): uint32
[ 157.95]          > fib(n: uint32): uint32
[ 157.96]          < return
[ 157.97]          > fib(n: uint32): uint32
[ 157.97]          < return
[ 157.98]         < return
[ 157.99]         > fib(n: uint32): uint32
[ 157.99]         < return
[ 158.00]        < return
[ 158.00]        > fib(n: uint32): uint32
[ 158.01]         > fib(n: uint32): uint32
[ 158.02]         < return
[ 158.03]         > fib(n: uint32): uint32
[ 158.04]         < return
[ 158.04]        < return
[ 158.05]       < return
[ 158.05]      < return
[ 158.06]     < return
[ 158.06]    < return
[ 158.07]    > fib(n: uint32): uint32
[ 158.08]     > fib(n: uint32): uint32
[ 158.09]      > fib(n: uint32): uint32
[ 158.10]       > fib(n: uint32): uint32
[ 158.11]        > fib(n: uint32): uint32
[ 158.12]         > fib(n: uint32): uint32
[ 158.13]          > fib(n: uint32): uint32
[ 158.14]           > fib(n: uint32): uint32
[ 158.15]            > fib(n: uint32): uint32
[ 158.16]            < return
[ 158.17]            > fib(n: uint32): uint32
[ 158.18]            < return
[ 158.18]           < return
[ 158.19]           > fib(n: uint32): uint32
[ 158.19]           < return
[ 158.20]          < return
[ 158.21]          > fib(n: uint32): uint32
[ 158.22]           > fib(n: uint32): uint32
[ 158.22]           < return
[ 158.23]           > fib(n: uint32): uint32
[ 158.24]           < return
[ 158.24]          < return
[ 158.25]         < return
[ 158.25]         > fib(n: uint32): uint32
[ 158.26]          > fib(n: uint32): uint32
[ 158.27]           > fib(n: uint32): uint32
[ 158.28]           < return
[ 158.29]           > fib(n: uint32): uint32
[ 158.30]           < return
[ 158.30]          < return
[ 158.31]          > fib(n: uint32): uint32
[ 158.32]          < return
[ 158.32]         < return
[ 158.33]        < return
[ 158.33]        > fib(n: uint32): uint32
[ 158.34]         > fib(n: uint32): uint32
[ 158.35]          > fib(n: uint32): uint32
[ 158.36]           > fib(n: uint32): uint32
[ 158.37]           < return
[ 158.38]           > fib(n: uint32): uint32
[ 158.39]           < return
[ 158.39]          < return
[ 158.40]          > fib(n: uint32): uint32
[ 158.41]          < return
[ 158.41]         < return
[ 158.42]         > fib(n: uint32): uint32
[ 158.43]          > fib(n: uint32): uint32
[ 158.44]          < return
[ 158.44]          > fib(n: uint32): uint32
[ 158.45]          < return
[ 158.46]         < return
[ 158.46]        < return
[ 158.47]       < return
[ 158.47]       > fib(n: uint32): uint32
[ 158.48]        > fib(n: uint32): uint32
[ 158.49]         > fib(n: uint32): uint32
[ 158.50]          > fib(n: uint32): uint32
[ 158.51]           > fib(n: uint32): uint32
[ 158.52]           < return
[ 158.53]           > fib(n: uint32): uint32
[ 158.54]           < return
[ 158.54]          < return
[ 158.55]          > fib(n: uint32): uint32
[ 158.56]          < return
[ 158.56]         < return
[ 158.56]         > fib(n: uint32): uint32
[ 158.58]          > fib(n: uint32): uint32
[ 158.59]          < return
[ 158.59]          > fib(n: uint32): uint32
[ 158.60]          < return
[ 158.60]         < return
[ 158.61]        < return
[ 158.62]        > fib(n: uint32): uint32
[ 158.62]         > fib(n: uint32): uint32
[ 158.64]          > fib(n: uint32): uint32
[ 158.65]          < return
[ 158.65]          > fib(n: uint32): uint32
[ 158.66]          < return
[ 158.66]         < return
[ 158.67]         > fib(n: uint32): uint32
[ 158.68]         < return
[ 158.68]        < return
[ 158.69]       < return
[ 158.69]      < return
[ 158.70]      > fib(n: uint32): uint32
[ 158.71]       > fib(n: uint32): uint32
[ 158.72]        > fib(n: uint32): uint32
[ 158.73]         > fib(n: uint32): uint32
[ 158.74]          > fib(n: uint32): uint32
[ 158.75]           > fib(n: uint32): uint32
[ 158.76]           < return
[ 158.76]           > fib(n: uint32): uint32
[ 158.77]           < return
[ 158.78]          < return
[ 158.78]          > fib(n: uint32): uint32
[ 158.79]          < return
[ 158.80]         < return
[ 158.80]         > fib(n: uint32): uint32
[ 158.81]          > fib(n: uint32): uint32
[ 158.82]          < return
[ 158.83]          > fib(n: uint32): uint32
[ 158.84]          < return
[ 158.84]         < return
[ 158.85]        < return
[ 158.85]        > fib(n: uint32): uint32
[ 158.86]         > fib(n: uint32): uint32
[ 158.87]          > fib(n: uint32): uint32
[ 158.88]          < return
[ 158.89]          > fib(n: uint32): uint32
[ 158.90]          < return
[ 158.90]         < return
[ 158.91]         > fib(n: uint32): uint32
[ 158.92]         < return
[ 158.92]        < return
[ 158.93]       < return
[ 158.93]       > fib(n: uint32): uint32
[ 158.94]        > fib(n: uint32): uint32
[ 158.95]         > fib(n: uint32): uint32
[ 158.96]          > fib(n: uint32): uint32
[ 158.97]          < return
[ 158.98]          > fib(n: uint32): uint32
[ 158.99]          < return
[ 158.99]         < return
[ 159.00]         > fib(n: uint32): uint32
[ 159.01]         < return
[ 159.01]        < return
[ 159.02]        > fib(n: uint32): uint32
[ 159.03]         > fib(n: uint32): uint32
[ 159.04]         < return
[ 159.04]         > fib(n: uint32): uint32
[ 159.05]         < return
[ 159.06]        < return
[ 159.06]       < return
[ 159.07]      < return
[ 159.07]     < return
[ 159.08]     > fib(n: uint32): uint32
[ 159.09]      > fib(n: uint32): uint32
[ 159.10]       > fib(n: uint32): uint32
[ 159.11]        > fib(n: uint32): uint32
[ 159.12]         > fib(n: uint32): uint32
[ 159.13]          > fib(n: uint32): uint32
[ 159.14]           > fib(n: uint32): uint32
[ 159.15]           < return
[ 159.15]           > fib(n: uint32): uint32
[ 159.16]           < return
[ 159.17]          < return
[ 159.17]          > fib(n: uint32): uint32
[ 159.18]          < return
[ 159.19]         < return
[ 159.19]         > fib(n: uint32): uint32
[ 159.20]          > fib(n: uint32): uint32
[ 159.21]          < return
[ 159.22]          > fib(n: uint32): uint32
[ 159.23]          < return
[ 159.23]         < return
[ 159.24]        < return
[ 159.24]        > fib(n: uint32): uint32
[ 159.25]         > fib(n: uint32): uint32
[ 159.26]          > fib(n: uint32): uint32
[ 159.27]          < return
[ 159.28]          > fib(n: uint32): uint32
[ 159.29]          < return
[ 159.29]         < return
[ 159.30]         > fib(n: uint32): uint32
[ 159.31]         < return
[ 159.31]        < return
[ 159.32]       < return
[ 159.32]       > fib(n: uint32): uint32
[ 159.33]        > fib(n: uint32): uint32
[ 159.34]         > fib(n: uint32): uint32
[ 159.35]          > fib(n: uint32): uint32
[ 159.36]          < return
[ 159.37]          > fib(n: uint32): uint32
[ 159.38]          < return
[ 159.38]         < return
[ 159.39]         > fib(n: uint32): uint32
[ 159.40]         < return
[ 159.40]        < return
[ 159.41]        > fib(n: uint32): uint32
[ 159.42]         > fib(n: uint32): uint32
[ 159.43]         < return
[ 159.43]         > fib(n: uint32): uint32
[ 159.44]         < return
[ 159.44]        < return
[ 159.45]       < return
[ 159.46]      < return
[ 159.46]      > fib(n: uint32): uint32
[ 159.47]       > fib(n: uint32): uint32
[ 159.48]        > fib(n: uint32): uint32
[ 159.49]         > fib(n: uint32): uint32
[ 159.50]          > fib(n: uint32): uint32
[ 159.51]          < return
[ 159.52]          > fib(n: uint32): uint32
[ 159.53]          < return
[ 159.53]         < return
[ 159.54]         > fib(n: uint32): uint32
[ 159.54]         < return
[ 159.55]        < return
[ 159.56]        > fib(n: uint32): uint32
[ 159.56]         > fib(n: uint32): uint32
[ 159.57]         < return
[ 159.58]         > fib(n: uint32): uint32
[ 159.59]         < return
[ 159.59]        < return
[ 159.60]       < return
[ 159.60]       > fib(n: uint32): uint32
[ 159.61]        > fib(n: uint32): uint32
[ 159.62]         > fib(n: uint32): uint32
[ 159.63]         < return
[ 159.64]         > fib(n: uint32): uint32
[ 159.65]         < return
[ 159.65]        < return
[ 159.66]        > fib(n: uint32): uint32
[ 159.67]        < return
[ 159.67]       < return
[ 159.68]      < return
[ 159.68]     < return
[ 159.69]    < return
[ 159.69]   < return
[ 159.70]  < return
[ 159.70]  > typename.size(type: typename): int32
[ 159.71]  < return
[ 159.72]  > typename.size(type: typename): int32
[ 159.73]  < return
[ 159.73]  > typename.size(type: typename): int32
[ 159.74]  < return
[ 159.75]  > typename.size(type: typename): int32
[ 159.76]  < return
[ 159.77]  > typename.size(type: typename): int32
[ 159.78]  < return
[ 159.78]  > typename.size(type: typename): int32
[ 159.79]  < return
[ 159.80]  > typename.size(type: typename): int32
[ 159.81]  < return
[ 159.81]  > typename.size(type: typename): int32
[ 159.82]  < return
[ 159.83]  > typename.size(type: typename): int32
[ 159.84]  < return
[ 159.84]  > typename.size(type: typename): int32
[ 159.86]  < return
[ 159.86]  > typename.size(type: typename): int32
[ 159.87]  < return
[ 159.88]  > typename.size(type: typename): int32
[ 159.89]  < return
[ 159.89]  > typename.size(type: typename): int32
[ 159.90]  < return
[ 159.91]  > typename.size(type: typename): int32
[ 159.92]  < return
[ 159.92]  > typename.size(type: typename): int32
[ 159.93]  < return
[ 159.94]  > typename.size(type: typename): int32
[ 159.95]  < return
[ 159.96]  > typename.size(type: typename): int32
[ 159.97]  < return
[ 159.97]  > typename.size(type: typename): int32
[ 159.98]  < return
[ 159.99]  > typename.name(type: typename): .cstr
[ 160.00]  < return
[ 160.01]  > typename.file(type: typename): .cstr
[ 160.03]  < return
[ 160.03]  > typename.line(type: typename): int32
[ 160.04]  < return
[ 160.05]  > typename.base(type: typename): typename
[ 160.06]  < return
[ 160.07]  > typename.name(type: typename): .cstr
[ 160.08]  < return
[ 160.09]  > typename.file(type: typename): .cstr
[ 160.11]  < return
[ 160.11]  > typename.line(type: typename): int32
[ 160.12]  < return
[ 160.13]  > typename.base(type: typename): typename
[ 160.14]  < return
[ 160.16]  > typename.base(type: typename): typename
[ 160.16]  < return
[ 161.25]  > Math.floor(x: float64): float64
[ 161.25]   > Math.modf(x: float64, intPart: float64): float64
[ 161.26]   < return
[ 161.26]  < return
[ 161.27]  > Math.floor(x: float64): float64
[ 161.27]   > Math.modf(x: float64, intPart: float64): float64
[ 161.28]   < return
[ 161.28]  < return
[ 161.29]  > Math.floor(x: float64): float64
[ 161.29]   > Math.modf(x: float64, intPart: float64): float64
[ 161.30]   < return
[ 161.30]  < return
[ 161.31]  > Math.floor(x: float64): float64
[ 161.32]   > Math.modf(x: float64, intPart: float64): float64
[ 161.32]    > Math.modf(x: float64, intPart: float64): float64
[ 161.32]    < return
[ 161.33]   < return
[ 161.33]  < return
[ 161.34]  > Math.floor(x: float64): float64
[ 161.34]   > Math.modf(x: float64, intPart: float64): float64
[ 161.35]    > Math.modf(x: float64, intPart: float64): float64
[ 161.35]    < return
[ 161.36]   < return
[ 161.36]  < return
[ 161.37]  > Math.floor(x: float64): float64
[ 161.37]   > Math.modf(x: float64, intPart: float64): float64
[ 161.38]    > Math.modf(x: float64, intPart: float64): float64
[ 161.38]    < return
[ 161.39]   < return
[ 161.39]  < return
[ 161.54]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 161.55]  < return
[ 161.56]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 161.57]  < return
[ 161.60]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 161.61]  < return
[ 161.63]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 161.64]  < return
[ 161.66]  > Math.min(data: float64[]): float64
[ 161.66]  < return
[ 161.68]  > Math.min(data: float64[]): float64
[ 161.70]  < return
[ 161.71]  > Math.max(data: float64[]): float64
[ 161.72]  < return
[ 161.74]  > Math.max(data: float64[]): float64
[ 161.76]  < return
[ 161.77]  > Math.sum(data: float64[]): float64
[ 161.78]  < return
[ 161.79]  > Math.sum(data: float64[]): float64
[ 161.80]  < return
[ 161.81]  > Math.sum(data: float64[]): float64
[ 161.82]  < return
[ 161.84]  > Math.sum(data: float64[]): float64
[ 161.86]  < return
[ 161.88]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 161.88]  < return
[ 161.93]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 161.95]  < return
[ 161.97]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 161.98]  < return
[ 162.00]  > Math.sinCos(arg: float64, quad: int32): float64
[ 162.01]  < return
[ 162.03]  > Math.sinCos(arg: float64, quad: int32): float64
[ 162.05]  < return
[ 162.06]  > Math.tan(arg: float64): float64
[ 162.07]   > Math.modf(x: float64, intPart: float64): float64
[ 162.07]   < return
[ 162.09]  < return
[ 162.10]  > Math.sinh(x: float64): float64
[ 162.10]   > float64.exp(x: float64): float64
[ 162.11]   < return
[ 162.12]   > float64.exp(x: float64): float64
[ 162.12]   < return
[ 162.13]  < return
[ 162.14]  > Math.cosh(x: float64): float64
[ 162.15]   > float64.exp(x: float64): float64
[ 162.16]   < return
[ 162.16]   > float64.exp(x: float64): float64
[ 162.17]   < return
[ 162.17]  < return
[ 162.18]  > Math.asin(x: float64): float64
[ 162.19]   > float64.sqrt(x: float64): float64
[ 162.20]   < return
[ 162.21]   > float64.atan2(x: float64, y: float64): float64
[ 162.21]   < return
[ 162.22]  < return
[ 162.23]  > Math.asin(x: float64): float64
[ 162.24]   > float64.sqrt(x: float64): float64
[ 162.25]   < return
[ 162.25]   > float64.atan2(x: float64, y: float64): float64
[ 162.26]   < return
[ 162.27]  < return
[ 162.28]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 162.28]  < return
[ 162.30]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 162.31]  < return
[ 162.32]  > Math.absMod(val: float64, mod: float64): float64
[ 162.32]  < return
[ 162.33]  > Math.absMod(val: float64, mod: float64): float64
[ 162.34]  < return
[ 162.35]  > Math.absMod(val: float64, mod: float64): float64
[ 162.35]  < return
[ 162.36]  > Math.absMod(val: float64, mod: float64): float64
[ 162.37]  < return
[ 162.38]  > Math.absMod(val: float64, mod: float64): float64
[ 162.38]  < return
[ 162.39]  > Math.absMod(val: float64, mod: float64): float64
[ 162.40]  < return
[ 162.41]  > Math.absMod(val: float64, mod: float64): float64
[ 162.41]  < return
[ 162.42]  > Math.absMod(val: float64, mod: float64): float64
[ 162.43]  < return
[ 162.44]  > Math.absMod(val: float64, mod: float64): float64
[ 162.44]  < return
[ 162.45]  > Math.absMod(val: float64, mod: float64): float64
[ 162.46]  < return
[ 162.47]  > Math.absMod(val: float64, mod: float64): float64
[ 162.47]  < return
[ 162.48]  > Math.absMod(val: float32, mod: float32): float32
[ 162.49]  < return
[ 162.50]  > Math.absMod(val: float32, mod: float32): float32
[ 162.50]  < return
[ 162.51]  > Math.absMod(val: float32, mod: float32): float32
[ 162.51]  < return
[ 162.53]  > Math.absMod(val: float32, mod: float32): float32
[ 162.53]  < return
[ 162.54]  > Math.absMod(val: float32, mod: float32): float32
[ 162.54]  < return
[ 162.55]  > Math.absMod(val: float32, mod: float32): float32
[ 162.56]  < return
[ 162.57]  > Math.absMod(val: float32, mod: float32): float32
[ 162.57]  < return
[ 162.58]  > Math.absMod(val: float32, mod: float32): float32
[ 162.59]  < return
[ 162.60]  > Math.absMod(val: float32, mod: float32): float32
[ 162.60]  < return
[ 162.61]  > Math.absMod(val: float32, mod: float32): float32
[ 162.62]  < return
[ 162.63]  > Math.absMod(val: float32, mod: float32): float32
[ 162.63]  < return
[ 162.64]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 162.65]  < return
[ 162.66]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 162.67]  < return
[ 162.68]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 162.69]  < return
[ 162.70]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 162.71]  < return
[ 162.72]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 162.73]  < return
[ 162.74]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 162.75]  < return
[ 162.76]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:26: debug: val1: int64(42)
[ 162.77]  < return
[ 162.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:27: debug: val2: int64(96)
[ 162.80]  < return
[ 162.80]  > typename.size(type: typename): int32
[ 162.81]  < return
[ 162.82]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 162.83]  < return
[ 162.84]  > typename.size(type: typename): int32
[ 162.85]  < return
[ 162.86]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 162.87]  < return
[ 162.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:32: debug: val1: int64(0)
[ 162.89]  < return
[ 162.90]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:33: debug: val2: int64(42)
[ 162.91]  < return
[ 162.92]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 162.94]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	cmplStd/test/lang/init.method.ci:78: staticMethod(this: <?>, x: 1)
	native.code:: .main
[ 162.96]   < return
[ 162.97]  < return
[ 162.98]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 162.99]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	cmplStd/test/lang/init.method.ci:79: virtualMethod(this: <?>, x: 1)
	native.code:: .main
[ 163.02]   < return
[ 163.02]  < return
[ 163.03]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 163.04]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:85: debug: extension.staticMethod
[ 163.05]   < return
[ 163.06]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 163.07]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	cmplStd/test/lang/init.method.ci:87: staticMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 163.10]    < return
[ 163.11]   < return
[ 163.12]  < return
[ 163.12]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 163.13]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:91: debug: extension.virtualMethod
[ 163.14]   < return
[ 163.15]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 163.16]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	cmplStd/test/lang/init.method.ci:93: virtualMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 163.20]    < return
[ 163.20]   < return
[ 163.21]  < return
[ 163.22]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 163.23]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	cmplStd/test/lang/init.method.ci:101: staticMethod(this: <?>, x: 3)
	native.code:: .main
[ 163.25]   < return
[ 163.26]  < return
[ 163.27]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 163.28]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:102: virtualMethod(this: <?>, x: 3)
	native.code:: .main
[ 163.31]   < return
[ 163.31]  < return
[ 163.32]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 163.33]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:103: virtualMethod(this: <?>, x: 3)
	native.code:: .main
[ 163.36]   < return
[ 163.36]  < return
[ 163.38]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
[ 163.39]  < return
[ 163.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
[ 163.41]  < return
[ 163.42]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
[ 163.44]  < return
[ 163.45]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 163.47]  < return
[ 163.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 163.50]  < return
[ 163.51]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 163.53]  < return
[ 163.54]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 163.56]  < return
[ 163.57]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:4: debug: for ( ; ; )
[ 163.58]  < return
[ 163.60]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 163.61]  < return
[ 163.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 163.64]  < return
[ 163.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 163.68]  < return
[ 163.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 163.71]  < return
[ 163.76]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
[ 163.77]  < return
[ 163.79]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
[ 163.81]  < return
[ 163.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
[ 163.84]  < return
[ 163.86]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
[ 163.87]  < return
[ 163.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
[ 163.90]  < return
[ 163.93]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(0)
[ 163.94]  < return
[ 163.97]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(1)
[ 163.98]  < return
[ 164.00]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(2)
[ 164.01]  < return
[ 164.03]  > halt(): void
[ 164.03]  < return
[ 164.03] < return

---------- Profile functions: 70/111, coverage: 63.06%
::[.005ed8, .005ed8): exec(2), time(0.010 ms): halt(): void
::[.006198, .006198): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006500, .006500): exec(3), time(0.033 ms): typename.base(type: typename): typename
::[.006718, .006718): exec(2), time(0.026 ms): typename.file(type: typename): .cstr
::[.006930, .006930): exec(2), time(0.024 ms): typename.line(type: typename): int32
::[.006b48, .006b48): exec(2), time(0.026 ms): typename.name(type: typename): .cstr
::[.006d58, .006d58): exec(20), time(0.194 ms): typename.size(type: typename): int32
::[.007018, .007018): exec(2), time(0.027 ms): object.create(type: typename): pointer
::[.007238, .007238): exec(0), time(0.000 ms): object.destroy(this: object): void
::[.0074e8, .0074e8): exec(0), time(0.000 ms): object.as(this: object, type: typename): pointer
::[.007d08, .007d08): exec(34), time(0.571 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.008658, .008658): exec(7), time(1.748 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.008918, .008918): exec(8), time(0.081 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.008c78, .008c78): exec(2), time(0.020 ms): pointer.fill(dst: pointer, value: uint8, size: int32): pointer
::[.008fd8, .008fd8): exec(1), time(0.010 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.009330, .009330): exec(1), time(0.010 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0095f8, .0095f8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.009818, .009818): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.009990, .009990): exec(0), time(0.000 ms): System.rand(): int32
::[.009b08, .009b08): exec(0), time(0.000 ms): System.time(): int32
::[.009c80, .009c80): exec(0), time(0.000 ms): System.clock(): int32
::[.009df8, .009df8): exec(0), time(0.000 ms): System.millis(): int64
::[.00a010, .00a010): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.00a370, .00a370): exec(7), time(0.065 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.00a6c8, .00a6c8): exec(7), time(0.065 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.00a8e0, .00a8e0): exec(1), time(0.009 ms): uint32.pop(value: int32): int32
::[.00aaf8, .00aaf8): exec(1), time(0.009 ms): uint32.swap(value: int32): int32
::[.00ad10, .00ad10): exec(1), time(0.009 ms): uint32.bsr(value: int32): int32
::[.00af28, .00af28): exec(1), time(0.010 ms): uint32.bsf(value: int32): int32
::[.00b140, .00b140): exec(1), time(0.010 ms): uint32.hib(value: int32): int32
::[.00b358, .00b358): exec(1), time(0.009 ms): uint32.lob(value: int32): int32
::[.00b6a8, .00b6a8): exec(1), time(0.010 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00b9f8, .00b9f8): exec(1), time(0.010 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00bc10, .00bc10): exec(2), time(0.024 ms): float32.sin(x: float32): float32
::[.00be28, .00be28): exec(1), time(0.009 ms): float32.cos(x: float32): float32
::[.00c040, .00c040): exec(1), time(0.009 ms): float32.tan(x: float32): float32
::[.00c258, .00c258): exec(1), time(0.010 ms): float32.log(x: float32): float32
::[.00c470, .00c470): exec(1), time(0.010 ms): float32.exp(x: float32): float32
::[.00c728, .00c728): exec(1), time(0.009 ms): float32.pow(x: float32, y: float32): float32
::[.00c940, .00c940): exec(1), time(0.009 ms): float32.sqrt(x: float32): float32
::[.00cbf8, .00cbf8): exec(1), time(0.010 ms): float32.atan2(x: float32, y: float32): float32
::[.00ce08, .00ce08): exec(1), time(0.015 ms): float64.sin(x: float64): float64
::[.00d018, .00d018): exec(1), time(0.010 ms): float64.cos(x: float64): float64
::[.00d228, .00d228): exec(1), time(0.011 ms): float64.tan(x: float64): float64
::[.00d438, .00d438): exec(1), time(0.010 ms): float64.log(x: float64): float64
::[.00d648, .00d648): exec(5), time(0.045 ms): float64.exp(x: float64): float64
::[.00d8f8, .00d8f8): exec(1), time(0.009 ms): float64.pow(x: float64, y: float64): float64
::[.00db08, .00db08): exec(3), time(0.027 ms): float64.sqrt(x: float64): float64
::[.00ddb8, .00ddb8): exec(3), time(0.029 ms): float64.atan2(x: float64, y: float64): float64
cmplStd/lib/debug.ci:61:[.05f780, .05f7e7): exec(0), time(0.000 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
cmplStd/lib/math.ci:22:[.05f7e8, .05f83e): exec(10), time(0.056 ms): Math.modf(x: float64, intPart: float64): float64
cmplStd/lib/math.ci:47:[.05f840, .05f858): exec(6), time(0.104-0.051 ms): Math.floor(x: float64): float64
cmplStd/lib/math.ci:77:[.05f858, .05f873): exec(11), time(0.059 ms): Math.absMod(val: float32, mod: float32): float32
cmplStd/lib/math.ci:85:[.05f878, .05f893): exec(11), time(0.057 ms): Math.absMod(val: float64, mod: float64): float64
cmplStd/lib/math.ci:147:[.05f898, .05f8b6): exec(2), time(0.012 ms): Math.clamp(t: float32, a: float32, b: float32): float32
cmplStd/lib/math.ci:158:[.05f8b8, .05f8d6): exec(2), time(0.012 ms): Math.clamp(t: float64, a: float64, b: float64): float64
cmplStd/lib/math.ci:189:[.05f8d8, .05f927): exec(2), time(0.026 ms): Math.min(data: float64[]): float64
cmplStd/lib/math.ci:203:[.05f928, .05f977): exec(2), time(0.026 ms): Math.max(data: float64[]): float64
cmplStd/lib/math.ci:217:[.05f978, .05f9a0): exec(4), time(0.048 ms): Math.sum(data: float64[]): float64
cmplStd/lib/math.ci:226:[.05f9a0, .05f9b4): exec(0), time(0.000 ms): Math.mean(data: float64[]): float64
cmplStd/lib/math.ci:243:[.05f9b8, .05f9e7): exec(3), time(0.041 ms): Math.eval(x: float64, polynomial: float64[]): float64
cmplStd/lib/math.ci:252:[.05f9e8, .05fa21): exec(1), time(0.006 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
cmplStd/lib/math.ci:267:[.05fa28, .05fa61): exec(1), time(0.006 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
cmplStd/lib/math.ci:282:[.05fa68, .05fbb7): exec(2), time(0.034 ms): Math.sinCos(arg: float64, quad: int32): float64
cmplStd/lib/math.ci:339:[.05fbb8, .05fd32): exec(1), time(0.027-0.005 ms): Math.tan(arg: float64): float64
cmplStd/lib/math.ci:396:[.05fd38, .05fe29): exec(1), time(0.035-0.017 ms): Math.sinh(x: float64): float64
cmplStd/lib/math.ci:435:[.05fe30, .05fe7b): exec(1), time(0.031-0.018 ms): Math.cosh(x: float64): float64
cmplStd/lib/math.ci:450:[.05fe80, .05ff2d): exec(2), time(0.072-0.035 ms): Math.asin(x: float64): float64
cmplStd/lib/math/Complex.ci:24:[.05ff30, .05ff37): exec(0), time(0.000 ms): Complex(re: float64): Complex
cmplStd/lib/math/Complex.ci:31:[.05ff38, .05ff3f): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
cmplStd/lib/math/Complex.ci:86:[.05ff40, .05ffcb): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
cmplStd/lib/math/Complex.ci:117:[.05ffd0, .05ffef): exec(0), time(0.000 ms): inv(a: Complex): Complex
cmplStd/lib/math/Complex.ci:135:[.05fff0, .060054): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
cmplStd/lib/math/Matrix4f.ci:62:[.060058, .060089): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:75:[.060090, .0600a5): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
cmplStd/lib/math/Matrix4f.ci:87:[.0600a8, .0600d9): exec(0), time(0.000 ms): transpose(mat: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:97:[.0600e0, .0601d5): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:111:[.0601d8, .06039e): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:163:[.0603a0, .0603f8): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:173:[.0603f8, .0604d1): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Vector2d.ci:14:[.0604d8, .0604df): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
cmplStd/lib/string.ci:4:[.0604e0, .060506): exec(0), time(0.000 ms): length(str: char[*]): int32
cmplStd/lib/string.ci:15:[.060508, .06053a): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
cmplStd/lib/string.ci:25:[.060540, .060572): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
cmplStd/lib/string.ci:36:[.060578, .0605c1): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/string.ci:46:[.0605c8, .060646): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/string.ci:61:[.060648, .060687): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
cmplStd/lib/string.ci:74:[.060688, .0606cf): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
cmplStd/lib/string.ci:73:[.0606d0, .0606f4): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
cmplStd/lib/string.ci:88:[.0606f8, .060706): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
cmplStd/lib/string.ci:131:[.060708, .06075c): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
cmplStd/lib/string.ci:148:[.060770, .060a33): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
cmplStd/lib/string.ci:238:[.060a38, .060b24): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
cmplStd/lib/string.ci:266:[.060b38, .060b77): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
cmplStd/test/std/tryExec.ci:11:[.060f28, .060f29): exec(1), time(0.009 ms): noError(ptr: pointer): void
cmplStd/test/std/tryExec.ci:14:[.060f30, .060f48): exec(128-128), time(1.553 ms): stackOverflow(ptr: pointer): void
cmplStd/test/std/tryExec.ci:20:[.060f48, .060f54): exec(1-1), time(0.008 ms): divisionByZero(args: pointer): void
cmplStd/test/std/tryExec.ci:24:[.060f58, .060f9c): exec(1-1), time(0.078-0.060 ms): abortExecution(args: pointer): void
cmplStd/test/std/tryExec.ci:38:[.060fa0, .060fad): exec(1-1), time(0.009 ms): invalidMemoryAccess(args: pointer): void
cmplStd/test/std/tryExec.ci:43:[.060fb0, .060fb2): exec(1-1), time(0.008 ms): invalidInstruction(args: pointer): void
cmplStd/test/lang/function.ci:4:[.0612b0, .0612b1): exec(0), time(0.000 ms): empty(): void
cmplStd/test/lang/function.ci:7:[.0612b8, .0612c0): exec(2), time(0.019 ms): funAdd(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:33:[.0612f8, .061300): exec(2), time(0.018 ms): funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:38:[.061300, .061336): exec(753), time(11.238 ms): fib(n: uint32): uint32
cmplStd/test/lang/init.method.ci:10:[.0614b0, .0614d7): exec(3), time(0.139-0.092 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:40:[.0614e0, .061507): exec(4), time(0.179-0.118 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47:[.061508, .06152f): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:57:[.061530, .061557): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:84:[.061568, .0615aa): exec(1), time(0.085-0.061 ms): staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:90:[.0615b0, .0615ef): exec(1), time(0.085-0.061 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.062034, .06547a): exec(1), time(18.647-15.129 ms): .main

---------- Profile statements: 821/1179, coverage: 69.64%
cmplStd/lib/debug.ci:63:[.05f789, .05f78a) exec(0), time(0.000 ms): <assertEq+9>
cmplStd/lib/debug.ci:62:[.05f780, .05f78a) exec(0), time(0.000 ms): <assertEq+0>
cmplStd/lib/debug.ci:65:[.05f78e, .05f797) exec(0), time(0.000 ms): <assertEq+14>
cmplStd/lib/debug.ci:65:[.05f78a, .05f797) exec(0), time(0.000 ms): <assertEq+10>
cmplStd/lib/debug.ci:67:[.05f79b, .05f7a6) exec(0), time(0.000 ms): <assertEq+27>
cmplStd/lib/debug.ci:68:[.05f7a6, .05f7b1) exec(0), time(0.000 ms): <assertEq+38>
cmplStd/lib/debug.ci:69:[.05f7b1, .05f7bc) exec(0), time(0.000 ms): <assertEq+49>
cmplStd/lib/debug.ci:66:[.05f797, .05f7bc) exec(0), time(0.000 ms): <assertEq+23>
cmplStd/lib/debug.ci:71:[.05f7bc, .05f7e2) exec(0), time(0.000 ms): <assertEq+60>
cmplStd/lib/math.ci:25:[.05f800, .05f811) exec(3), time(0.023-0.023 ms): <modf+24>
cmplStd/lib/math.ci:26:[.05f811, .05f818) exec(3), time(0.001-0.001 ms): <modf+41>
cmplStd/lib/math.ci:27:[.05f818, .05f81b) exec(3), time(0.009-0.009 ms): <modf+48>
cmplStd/lib/math.ci:24:[.05f7f8, .05f81f) exec(3-3), time(0.000 ms): <modf+16>
cmplStd/lib/math.ci:29:[.05f81f, .05f823) exec(0), time(0.000 ms): <modf+55>
cmplStd/lib/math.ci:30:[.05f823, .05f827) exec(0), time(0.000 ms): <modf+59>
cmplStd/lib/math.ci:23:[.05f7e8, .05f827) exec(10-3), time(0.001-0.001 ms): <modf+0>
cmplStd/lib/math.ci:32:[.05f827, .05f833) exec(7), time(0.002-0.002 ms): <modf+63>
cmplStd/lib/math.ci:33:[.05f833, .05f83b) exec(7), time(0.001-0.001 ms): <modf+75>
cmplStd/lib/math.ci:34:[.05f83b, .05f83e) exec(7), time(0.020-0.020 ms): <modf+83>
cmplStd/lib/math.ci:48:[.05f840, .05f841) exec(6), time(0.001-0.001 ms): <floor+0>
cmplStd/lib/math.ci:49:[.05f841, .05f855) exec(6), time(0.069-0.069 ms): <floor+1>
cmplStd/lib/math.ci:50:[.05f855, .05f858) exec(6), time(0.016-0.016 ms): <floor+21>
cmplStd/lib/math.ci:79:[.05f867, .05f86f) exec(4), time(0.012-0.012 ms): <absMod+15>
cmplStd/lib/math.ci:78:[.05f858, .05f86f) exec(11-4), time(0.003-0.003 ms): <absMod+0>
cmplStd/lib/math.ci:81:[.05f86f, .05f873) exec(7), time(0.020-0.020 ms): <absMod+23>
cmplStd/lib/math.ci:87:[.05f887, .05f88f) exec(4), time(0.011-0.011 ms): <absMod+15>
cmplStd/lib/math.ci:86:[.05f878, .05f88f) exec(11-4), time(0.006-0.006 ms): <absMod+0>
cmplStd/lib/math.ci:89:[.05f88f, .05f893) exec(7), time(0.020-0.020 ms): <absMod+23>
cmplStd/lib/math.ci:149:[.05f8a1, .05f8a5) exec(0), time(0.000 ms): <clamp+9>
cmplStd/lib/math.ci:148:[.05f898, .05f8a5) exec(2), time(0.000 ms): <clamp+0>
cmplStd/lib/math.ci:152:[.05f8ae, .05f8b2) exec(1), time(0.002-0.002 ms): <clamp+22>
cmplStd/lib/math.ci:151:[.05f8a5, .05f8b2) exec(2-1), time(0.001-0.001 ms): <clamp+13>
cmplStd/lib/math.ci:154:[.05f8b2, .05f8b6) exec(1), time(0.003-0.003 ms): <clamp+26>
cmplStd/lib/math.ci:160:[.05f8c1, .05f8c5) exec(0), time(0.000 ms): <clamp+9>
cmplStd/lib/math.ci:159:[.05f8b8, .05f8c5) exec(2), time(0.000 ms): <clamp+0>
cmplStd/lib/math.ci:163:[.05f8ce, .05f8d2) exec(1), time(0.003-0.003 ms): <clamp+22>
cmplStd/lib/math.ci:162:[.05f8c5, .05f8d2) exec(2-1), time(0.000 ms): <clamp+13>
cmplStd/lib/math.ci:165:[.05f8d2, .05f8d6) exec(1), time(0.003-0.003 ms): <clamp+26>
cmplStd/lib/math.ci:191:[.05f8e0, .05f8ec) exec(1), time(0.003-0.003 ms): <min+8>
cmplStd/lib/math.ci:190:[.05f8d8, .05f8ec) exec(2-1), time(0.000 ms): <min+0>
cmplStd/lib/math.ci:193:[.05f8ec, .05f8ef) exec(1), time(0.000 ms): <min+20>
cmplStd/lib/math.ci:196:[.05f908, .05f913) exec(2), time(0.002-0.002 ms): <min+48>
cmplStd/lib/math.ci:195:[.05f8f8, .05f913) exec(8-2), time(0.002-0.002 ms): <min+32>
cmplStd/lib/math.ci:194:[.05f913, .05f917) exec(8), time(0.001-0.001 ms): <min+59>
cmplStd/lib/math.ci:194:[.05f917, .05f920) exec(9), time(0.003-0.003 ms): <min+63>
cmplStd/lib/math.ci:194:[.05f8ef, .05f924) exec(1), time(0.001-0.001 ms): <min+23>
cmplStd/lib/math.ci:199:[.05f924, .05f927) exec(1), time(0.003-0.003 ms): <min+76>
cmplStd/lib/math.ci:205:[.05f930, .05f93c) exec(1), time(0.003-0.003 ms): <max+8>
cmplStd/lib/math.ci:204:[.05f928, .05f93c) exec(2-1), time(0.001-0.001 ms): <max+0>
cmplStd/lib/math.ci:207:[.05f93c, .05f93f) exec(1), time(0.000 ms): <max+20>
cmplStd/lib/math.ci:210:[.05f958, .05f963) exec(2), time(0.000 ms): <max+48>
cmplStd/lib/math.ci:209:[.05f948, .05f963) exec(8-2), time(0.004-0.004 ms): <max+32>
cmplStd/lib/math.ci:208:[.05f963, .05f967) exec(8), time(0.000 ms): <max+59>
cmplStd/lib/math.ci:208:[.05f967, .05f970) exec(9), time(0.002-0.002 ms): <max+63>
cmplStd/lib/math.ci:208:[.05f93f, .05f974) exec(1), time(0.001-0.001 ms): <max+23>
cmplStd/lib/math.ci:213:[.05f974, .05f977) exec(1), time(0.003-0.003 ms): <max+76>
cmplStd/lib/math.ci:218:[.05f978, .05f979) exec(4), time(0.000 ms): <sum+0>
cmplStd/lib/math.ci:220:[.05f97e, .05f98c) exec(13), time(0.007-0.007 ms): <sum+6>
cmplStd/lib/math.ci:219:[.05f98c, .05f990) exec(13), time(0.003-0.003 ms): <sum+20>
cmplStd/lib/math.ci:219:[.05f990, .05f999) exec(17), time(0.008-0.008 ms): <sum+24>
cmplStd/lib/math.ci:219:[.05f979, .05f99d) exec(4), time(0.003-0.003 ms): <sum+1>
cmplStd/lib/math.ci:222:[.05f99d, .05f9a0) exec(4), time(0.012-0.012 ms): <sum+37>
cmplStd/lib/math.ci:227:[.05f9a0, .05f9b4) exec(0), time(0.000 ms): <mean+0>
cmplStd/lib/math.ci:244:[.05f9b8, .05f9b9) exec(3), time(0.000 ms): <eval+0>
cmplStd/lib/math.ci:246:[.05f9c3, .05f9d4) exec(11), time(0.009-0.009 ms): <eval+11>
cmplStd/lib/math.ci:245:[.05f9d4, .05f9d8) exec(11), time(0.000 ms): <eval+28>
cmplStd/lib/math.ci:245:[.05f9d8, .05f9e0) exec(14), time(0.007-0.007 ms): <eval+32>
cmplStd/lib/math.ci:245:[.05f9b9, .05f9e4) exec(3), time(0.003-0.003 ms): <eval+1>
cmplStd/lib/math.ci:248:[.05f9e4, .05f9e7) exec(3), time(0.009-0.009 ms): <eval+44>
cmplStd/lib/math.ci:255:[.05f9fd, .05fa05) exec(0), time(0.000 ms): <cmp+21>
cmplStd/lib/math.ci:254:[.05f9f1, .05fa05) exec(1), time(0.001-0.001 ms): <cmp+9>
cmplStd/lib/math.ci:260:[.05fa15, .05fa1d) exec(0), time(0.000 ms): <cmp+45>
cmplStd/lib/math.ci:259:[.05fa09, .05fa1d) exec(0), time(0.000 ms): <cmp+33>
cmplStd/lib/math.ci:253:[.05f9e8, .05fa1d) exec(1), time(0.001-0.001 ms): <cmp+0>
cmplStd/lib/math.ci:263:[.05fa1d, .05fa21) exec(1), time(0.003-0.003 ms): <cmp+53>
cmplStd/lib/math.ci:270:[.05fa3d, .05fa45) exec(0), time(0.000 ms): <cmp+21>
cmplStd/lib/math.ci:269:[.05fa31, .05fa45) exec(1), time(0.001-0.001 ms): <cmp+9>
cmplStd/lib/math.ci:275:[.05fa55, .05fa5d) exec(0), time(0.000 ms): <cmp+45>
cmplStd/lib/math.ci:274:[.05fa49, .05fa5d) exec(0), time(0.000 ms): <cmp+33>
cmplStd/lib/math.ci:268:[.05fa28, .05fa5d) exec(1), time(0.001-0.001 ms): <cmp+0>
cmplStd/lib/math.ci:278:[.05fa5d, .05fa61) exec(1), time(0.003-0.003 ms): <cmp+53>
cmplStd/lib/math.ci:296:[.05fa68, .05fa6a) exec(2), time(0.000 ms): <sinCos+0>
cmplStd/lib/math.ci:298:[.05fa72, .05fa73) exec(0), time(0.000 ms): <sinCos+10>
cmplStd/lib/math.ci:299:[.05fa73, .05fa7b) exec(0), time(0.000 ms): <sinCos+11>
cmplStd/lib/math.ci:297:[.05fa6a, .05fa7b) exec(2), time(0.001-0.001 ms): <sinCos+2>
cmplStd/lib/math.ci:302:[.05fa7b, .05fa7c) exec(2), time(0.000 ms): <sinCos+19>
cmplStd/lib/math.ci:303:[.05fa7c, .05fa94) exec(2), time(0.001-0.001 ms): <sinCos+20>
cmplStd/lib/math.ci:305:[.05faa4, .05faa5) exec(0), time(0.000 ms): <sinCos+60>
cmplStd/lib/math.ci:306:[.05faa5, .05fab7) exec(0), time(0.000 ms): <sinCos+61>
cmplStd/lib/math.ci:307:[.05fab7, .05fabb) exec(0), time(0.000 ms): <sinCos+79>
cmplStd/lib/math.ci:309:[.05fabb, .05fabc) exec(0), time(0.000 ms): <sinCos+83>
cmplStd/lib/math.ci:310:[.05fabc, .05fada) exec(0), time(0.000 ms): <sinCos+84>
cmplStd/lib/math.ci:311:[.05fada, .05faec) exec(0), time(0.000 ms): <sinCos+114>
cmplStd/lib/math.ci:314:[.05faf4, .05faf7) exec(2), time(0.000 ms): <sinCos+140>
cmplStd/lib/math.ci:315:[.05faf7, .05faff) exec(2), time(0.002-0.002 ms): <sinCos+143>
cmplStd/lib/math.ci:316:[.05faff, .05fb06) exec(2), time(0.001-0.001 ms): <sinCos+151>
cmplStd/lib/math.ci:317:[.05fb06, .05fb0c) exec(2), time(0.001-0.001 ms): <sinCos+158>
cmplStd/lib/math.ci:304:[.05fa94, .05fb10) exec(2), time(0.001-0.001 ms): <sinCos+44>
cmplStd/lib/math.ci:320:[.05fb18, .05fb26) exec(1), time(0.000 ms): <sinCos+176>
cmplStd/lib/math.ci:319:[.05fb10, .05fb26) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
cmplStd/lib/math.ci:323:[.05fb32, .05fb33) exec(1), time(0.001-0.001 ms): <sinCos+202>
cmplStd/lib/math.ci:322:[.05fb26, .05fb33) exec(2-1), time(0.000 ms): <sinCos+190>
cmplStd/lib/math.ci:326:[.05fb33, .05fb38) exec(2), time(0.001-0.001 ms): <sinCos+203>
cmplStd/lib/math.ci:327:[.05fb38, .05fb78) exec(2), time(0.004-0.004 ms): <sinCos+208>
cmplStd/lib/math.ci:328:[.05fb78, .05fbab) exec(2), time(0.003-0.003 ms): <sinCos+272>
cmplStd/lib/math.ci:329:[.05fbab, .05fbb7) exec(2), time(0.006-0.006 ms): <sinCos+323>
cmplStd/lib/math.ci:352:[.05fbb8, .05fbb9) exec(1), time(0.000 ms): <tan+0>
cmplStd/lib/math.ci:353:[.05fbb9, .05fbba) exec(1), time(0.000 ms): <tan+1>
cmplStd/lib/math.ci:356:[.05fbc2, .05fbc7) exec(0), time(0.000 ms): <tan+10>
cmplStd/lib/math.ci:357:[.05fbc7, .05fbd1) exec(0), time(0.000 ms): <tan+15>
cmplStd/lib/math.ci:355:[.05fbba, .05fbd1) exec(1), time(0.000 ms): <tan+2>
cmplStd/lib/math.ci:359:[.05fbd1, .05fbe9) exec(1), time(0.001-0.001 ms): <tan+25>
cmplStd/lib/math.ci:361:[.05fbe9, .05fbea) exec(1), time(0.000 ms): <tan+49>
cmplStd/lib/math.ci:362:[.05fbea, .05fbfa) exec(1), time(0.008-0.008 ms): <tan+50>
cmplStd/lib/math.ci:363:[.05fbfa, .05fc03) exec(1), time(0.001-0.001 ms): <tan+66>
cmplStd/lib/math.ci:367:[.05fc17, .05fc25) exec(1), time(0.001-0.001 ms): <tan+95>
cmplStd/lib/math.ci:368:[.05fc25, .05fc2f) exec(1), time(0.000 ms): <tan+109>
cmplStd/lib/math.ci:371:[.05fc3f, .05fc4a) exec(0), time(0.000 ms): <tan+135>
cmplStd/lib/math.ci:372:[.05fc4a, .05fc54) exec(0), time(0.000 ms): <tan+146>
cmplStd/lib/math.ci:375:[.05fc64, .05fc72) exec(0), time(0.000 ms): <tan+172>
cmplStd/lib/math.ci:376:[.05fc72, .05fc7d) exec(0), time(0.000 ms): <tan+186>
cmplStd/lib/math.ci:374:[.05fc58, .05fc7d) exec(0), time(0.000 ms): <tan+160>
cmplStd/lib/math.ci:370:[.05fc33, .05fc7d) exec(0), time(0.000 ms): <tan+123>
cmplStd/lib/math.ci:366:[.05fc0b, .05fc7d) exec(1), time(0.001-0.001 ms): <tan+83>
cmplStd/lib/math.ci:365:[.05fc03, .05fc7d) exec(1-1), time(0.000 ms): <tan+75>
cmplStd/lib/math.ci:379:[.05fc7d, .05fc82) exec(1), time(0.000 ms): <tan+197>
cmplStd/lib/math.ci:380:[.05fc82, .05fcc2) exec(1), time(0.003-0.003 ms): <tan+202>
cmplStd/lib/math.ci:381:[.05fcc2, .05fce9) exec(1), time(0.001-0.001 ms): <tan+266>
cmplStd/lib/math.ci:385:[.05fcfa, .05fd0a) exec(0), time(0.000 ms): <tan+322>
cmplStd/lib/math.ci:384:[.05fcf2, .05fd0a) exec(1), time(0.000 ms): <tan+314>
cmplStd/lib/math.ci:387:[.05fd0a, .05fd18) exec(1), time(0.000 ms): <tan+338>
cmplStd/lib/math.ci:383:[.05fce9, .05fd18) exec(1-1), time(0.000 ms): <tan+305>
cmplStd/lib/math.ci:390:[.05fd21, .05fd2b) exec(0), time(0.000 ms): <tan+361>
cmplStd/lib/math.ci:389:[.05fd18, .05fd2b) exec(1), time(0.001-0.001 ms): <tan+352>
cmplStd/lib/math.ci:392:[.05fd2b, .05fd32) exec(1), time(0.003-0.003 ms): <tan+371>
cmplStd/lib/math.ci:408:[.05fd38, .05fd39) exec(1), time(0.000 ms): <sinh+0>
cmplStd/lib/math.ci:410:[.05fd41, .05fd46) exec(0), time(0.000 ms): <sinh+9>
cmplStd/lib/math.ci:411:[.05fd46, .05fd50) exec(0), time(0.000 ms): <sinh+14>
cmplStd/lib/math.ci:409:[.05fd39, .05fd50) exec(1), time(0.001-0.001 ms): <sinh+1>
cmplStd/lib/math.ci:415:[.05fd60, .05fd77) exec(0), time(0.000 ms): <sinh+40>
cmplStd/lib/math.ci:414:[.05fd50, .05fd77) exec(1), time(0.000 ms): <sinh+24>
cmplStd/lib/math.ci:418:[.05fd77, .05fd78) exec(1), time(0.000 ms): <sinh+63>
cmplStd/lib/math.ci:420:[.05fd88, .05fda2) exec(1), time(0.025-0.025 ms): <sinh+80>
cmplStd/lib/math.ci:423:[.05fda6, .05fdab) exec(0), time(0.000 ms): <sinh+110>
cmplStd/lib/math.ci:424:[.05fdab, .05fde0) exec(0), time(0.000 ms): <sinh+115>
cmplStd/lib/math.ci:425:[.05fde0, .05fe0b) exec(0), time(0.000 ms): <sinh+168>
cmplStd/lib/math.ci:419:[.05fd78, .05fe0f) exec(1), time(0.026-0.026 ms): <sinh+64>
cmplStd/lib/math.ci:429:[.05fe18, .05fe22) exec(0), time(0.000 ms): <sinh+224>
cmplStd/lib/math.ci:428:[.05fe0f, .05fe22) exec(1), time(0.000 ms): <sinh+215>
cmplStd/lib/math.ci:431:[.05fe22, .05fe29) exec(1), time(0.004-0.004 ms): <sinh+234>
cmplStd/lib/math.ci:437:[.05fe38, .05fe3d) exec(0), time(0.000 ms): <cosh+8>
cmplStd/lib/math.ci:436:[.05fe30, .05fe3d) exec(1), time(0.001-0.001 ms): <cosh+0>
cmplStd/lib/math.ci:440:[.05fe4d, .05fe60) exec(0), time(0.000 ms): <cosh+29>
cmplStd/lib/math.ci:439:[.05fe3d, .05fe60) exec(1), time(0.001-0.001 ms): <cosh+13>
cmplStd/lib/math.ci:442:[.05fe60, .05fe7b) exec(1), time(0.027-0.027 ms): <cosh+48>
cmplStd/lib/math.ci:453:[.05fe88, .05fe8c) exec(0), time(0.000 ms): <asin+8>
cmplStd/lib/math.ci:451:[.05fe80, .05fe8c) exec(2), time(0.001-0.001 ms): <asin+0>
cmplStd/lib/math.ci:456:[.05fe8c, .05fe8d) exec(2), time(0.001-0.001 ms): <asin+12>
cmplStd/lib/math.ci:458:[.05fe95, .05fe9f) exec(0), time(0.000 ms): <asin+21>
cmplStd/lib/math.ci:459:[.05fe9f, .05fea4) exec(0), time(0.000 ms): <asin+31>
cmplStd/lib/math.ci:457:[.05fe8d, .05fea4) exec(2), time(0.001-0.001 ms): <asin+13>
cmplStd/lib/math.ci:464:[.05feb4, .05fec4) exec(0), time(0.000 ms): <asin+52>
cmplStd/lib/math.ci:462:[.05fea4, .05fec4) exec(2), time(0.001-0.001 ms): <asin+36>
cmplStd/lib/math.ci:467:[.05fec4, .05fed7) exec(2), time(0.025-0.025 ms): <asin+68>
cmplStd/lib/math.ci:469:[.05fee7, .05ff05) exec(0), time(0.000 ms): <asin+103>
cmplStd/lib/math.ci:472:[.05ff09, .05ff13) exec(2), time(0.025-0.025 ms): <asin+137>
cmplStd/lib/math.ci:468:[.05fed7, .05ff13) exec(2-2), time(0.000 ms): <asin+87>
cmplStd/lib/math.ci:476:[.05ff1c, .05ff26) exec(0), time(0.000 ms): <asin+156>
cmplStd/lib/math.ci:475:[.05ff13, .05ff26) exec(2), time(0.002-0.002 ms): <asin+147>
cmplStd/lib/math.ci:478:[.05ff26, .05ff2d) exec(2), time(0.008-0.008 ms): <asin+166>
cmplStd/lib/math/Complex.ci:26:[.05ff30, .05ff33) exec(0), time(0.000 ms): <Complex+0>
::[.05ff33, .05ff36) exec(0), time(0.000 ms): <Complex+3>
cmplStd/lib/math/Complex.ci:25:[.05ff30, .05ff37) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:33:[.05ff38, .05ff3b) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:34:[.05ff3b, .05ff3e) exec(0), time(0.000 ms): <Complex+3>
cmplStd/lib/math/Complex.ci:32:[.05ff38, .05ff3f) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:91:[.05ff6f, .05ff74) exec(0), time(0.000 ms): <div+47>
cmplStd/lib/math/Complex.ci:92:[.05ff74, .05ff7c) exec(0), time(0.000 ms): <div+52>
cmplStd/lib/math/Complex.ci:94:[.05ff7c, .05ff89) exec(0), time(0.000 ms): <div+60>
cmplStd/lib/math/Complex.ci:95:[.05ff89, .05ff96) exec(0), time(0.000 ms): <div+73>
cmplStd/lib/math/Complex.ci:93:[.05ff7c, .05ff9b) exec(0), time(0.000 ms): <div+60>
cmplStd/lib/math/Complex.ci:90:[.05ff40, .05ff9f) exec(0), time(0.000 ms): <div+0>
cmplStd/lib/math/Complex.ci:98:[.05ff9f, .05ffa4) exec(0), time(0.000 ms): <div+95>
cmplStd/lib/math/Complex.ci:99:[.05ffa4, .05ffac) exec(0), time(0.000 ms): <div+100>
cmplStd/lib/math/Complex.ci:101:[.05ffac, .05ffb9) exec(0), time(0.000 ms): <div+108>
cmplStd/lib/math/Complex.ci:102:[.05ffb9, .05ffc6) exec(0), time(0.000 ms): <div+121>
cmplStd/lib/math/Complex.ci:100:[.05ffac, .05ffcb) exec(0), time(0.000 ms): <div+108>
cmplStd/lib/math/Complex.ci:118:[.05ffd0, .05ffdb) exec(0), time(0.000 ms): <inv+0>
cmplStd/lib/math/Complex.ci:120:[.05ffdb, .05ffe2) exec(0), time(0.000 ms): <inv+11>
cmplStd/lib/math/Complex.ci:121:[.05ffe2, .05ffea) exec(0), time(0.000 ms): <inv+18>
cmplStd/lib/math/Complex.ci:119:[.05ffdb, .05ffef) exec(0), time(0.000 ms): <inv+11>
cmplStd/lib/math/Complex.ci:136:[.05fff0, .060007) exec(0), time(0.000 ms): <pow+0>
cmplStd/lib/math/Complex.ci:137:[.060007, .060017) exec(0), time(0.000 ms): <pow+23>
cmplStd/lib/math/Complex.ci:138:[.060017, .060026) exec(0), time(0.000 ms): <pow+39>
cmplStd/lib/math/Complex.ci:139:[.060026, .060039) exec(0), time(0.000 ms): <pow+54>
cmplStd/lib/math/Complex.ci:141:[.060039, .060044) exec(0), time(0.000 ms): <pow+73>
cmplStd/lib/math/Complex.ci:142:[.060044, .06004f) exec(0), time(0.000 ms): <pow+84>
cmplStd/lib/math/Complex.ci:140:[.060039, .060054) exec(0), time(0.000 ms): <pow+73>
cmplStd/lib/math/Matrix4f.ci:67:[.060058, .06005b) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:67:[.06005b, .06005e) exec(0), time(0.000 ms): <mat4f+3>
cmplStd/lib/math/Matrix4f.ci:67:[.06005e, .060061) exec(0), time(0.000 ms): <mat4f+6>
cmplStd/lib/math/Matrix4f.ci:67:[.060061, .060064) exec(0), time(0.000 ms): <mat4f+9>
cmplStd/lib/math/Matrix4f.ci:68:[.060064, .060067) exec(0), time(0.000 ms): <mat4f+12>
cmplStd/lib/math/Matrix4f.ci:68:[.060067, .06006a) exec(0), time(0.000 ms): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:68:[.06006a, .06006d) exec(0), time(0.000 ms): <mat4f+18>
cmplStd/lib/math/Matrix4f.ci:68:[.06006d, .060070) exec(0), time(0.000 ms): <mat4f+21>
cmplStd/lib/math/Matrix4f.ci:69:[.060070, .060073) exec(0), time(0.000 ms): <mat4f+24>
cmplStd/lib/math/Matrix4f.ci:69:[.060073, .060076) exec(0), time(0.000 ms): <mat4f+27>
cmplStd/lib/math/Matrix4f.ci:69:[.060076, .060079) exec(0), time(0.000 ms): <mat4f+30>
cmplStd/lib/math/Matrix4f.ci:69:[.060079, .06007c) exec(0), time(0.000 ms): <mat4f+33>
cmplStd/lib/math/Matrix4f.ci:70:[.06007c, .06007f) exec(0), time(0.000 ms): <mat4f+36>
cmplStd/lib/math/Matrix4f.ci:70:[.06007f, .060082) exec(0), time(0.000 ms): <mat4f+39>
cmplStd/lib/math/Matrix4f.ci:70:[.060082, .060085) exec(0), time(0.000 ms): <mat4f+42>
cmplStd/lib/math/Matrix4f.ci:70:[.060085, .060088) exec(0), time(0.000 ms): <mat4f+45>
cmplStd/lib/math/Matrix4f.ci:66:[.060058, .060089) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.060090, .060095) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.060095, .06009a) exec(0), time(0.000 ms): <mat4f+5>
cmplStd/lib/math/Matrix4f.ci:76:[.06009a, .06009f) exec(0), time(0.000 ms): <mat4f+10>
cmplStd/lib/math/Matrix4f.ci:76:[.06009f, .0600a4) exec(0), time(0.000 ms): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:76:[.060090, .0600a5) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:89:[.0600a8, .0600ab) exec(0), time(0.000 ms): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:89:[.0600ab, .0600ae) exec(0), time(0.000 ms): <transpose+3>
cmplStd/lib/math/Matrix4f.ci:89:[.0600ae, .0600b1) exec(0), time(0.000 ms): <transpose+6>
cmplStd/lib/math/Matrix4f.ci:89:[.0600b1, .0600b4) exec(0), time(0.000 ms): <transpose+9>
cmplStd/lib/math/Matrix4f.ci:90:[.0600b4, .0600b7) exec(0), time(0.000 ms): <transpose+12>
cmplStd/lib/math/Matrix4f.ci:90:[.0600b7, .0600ba) exec(0), time(0.000 ms): <transpose+15>
cmplStd/lib/math/Matrix4f.ci:90:[.0600ba, .0600bd) exec(0), time(0.000 ms): <transpose+18>
cmplStd/lib/math/Matrix4f.ci:90:[.0600bd, .0600c0) exec(0), time(0.000 ms): <transpose+21>
cmplStd/lib/math/Matrix4f.ci:91:[.0600c0, .0600c3) exec(0), time(0.000 ms): <transpose+24>
cmplStd/lib/math/Matrix4f.ci:91:[.0600c3, .0600c6) exec(0), time(0.000 ms): <transpose+27>
cmplStd/lib/math/Matrix4f.ci:91:[.0600c6, .0600c9) exec(0), time(0.000 ms): <transpose+30>
cmplStd/lib/math/Matrix4f.ci:91:[.0600c9, .0600cc) exec(0), time(0.000 ms): <transpose+33>
cmplStd/lib/math/Matrix4f.ci:92:[.0600cc, .0600cf) exec(0), time(0.000 ms): <transpose+36>
cmplStd/lib/math/Matrix4f.ci:92:[.0600cf, .0600d2) exec(0), time(0.000 ms): <transpose+39>
cmplStd/lib/math/Matrix4f.ci:92:[.0600d2, .0600d5) exec(0), time(0.000 ms): <transpose+42>
cmplStd/lib/math/Matrix4f.ci:92:[.0600d5, .0600d8) exec(0), time(0.000 ms): <transpose+45>
cmplStd/lib/math/Matrix4f.ci:88:[.0600a8, .0600d9) exec(0), time(0.000 ms): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:98:[.0600e0, .0600fc) exec(0), time(0.000 ms): <mul+0>
cmplStd/lib/math/Matrix4f.ci:100:[.0600fc, .06012e) exec(0), time(0.000 ms): <mul+28>
cmplStd/lib/math/Matrix4f.ci:101:[.06012e, .060164) exec(0), time(0.000 ms): <mul+78>
cmplStd/lib/math/Matrix4f.ci:102:[.060164, .06019a) exec(0), time(0.000 ms): <mul+132>
cmplStd/lib/math/Matrix4f.ci:103:[.06019a, .0601d0) exec(0), time(0.000 ms): <mul+186>
cmplStd/lib/math/Matrix4f.ci:99:[.0600fc, .0601d5) exec(0), time(0.000 ms): <mul+28>
cmplStd/lib/math/Matrix4f.ci:112:[.0601d8, .0601ea) exec(0), time(0.000 ms): <rotation+0>
cmplStd/lib/math/Matrix4f.ci:114:[.0601fb, .06021f) exec(0), time(0.000 ms): <rotation+35>
cmplStd/lib/math/Matrix4f.ci:116:[.06021f, .060225) exec(0), time(0.000 ms): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:117:[.060225, .06022b) exec(0), time(0.000 ms): <rotation+77>
cmplStd/lib/math/Matrix4f.ci:118:[.06022b, .060231) exec(0), time(0.000 ms): <rotation+83>
cmplStd/lib/math/Matrix4f.ci:119:[.060231, .060237) exec(0), time(0.000 ms): <rotation+89>
cmplStd/lib/math/Matrix4f.ci:115:[.06021f, .06023c) exec(0), time(0.000 ms): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:113:[.0601ea, .06023c) exec(0), time(0.000 ms): <rotation+18>
cmplStd/lib/math/Matrix4f.ci:122:[.06023c, .060242) exec(0), time(0.000 ms): <rotation+100>
cmplStd/lib/math/Matrix4f.ci:123:[.060242, .06024c) exec(0), time(0.000 ms): <rotation+106>
cmplStd/lib/math/Matrix4f.ci:124:[.06024c, .060256) exec(0), time(0.000 ms): <rotation+116>
cmplStd/lib/math/Matrix4f.ci:125:[.060256, .060259) exec(0), time(0.000 ms): <rotation+126>
cmplStd/lib/math/Matrix4f.ci:126:[.060259, .060260) exec(0), time(0.000 ms): <rotation+129>
cmplStd/lib/math/Matrix4f.ci:127:[.060260, .060267) exec(0), time(0.000 ms): <rotation+136>
cmplStd/lib/math/Matrix4f.ci:128:[.060267, .06026c) exec(0), time(0.000 ms): <rotation+143>
cmplStd/lib/math/Matrix4f.ci:129:[.06026c, .060271) exec(0), time(0.000 ms): <rotation+148>
cmplStd/lib/math/Matrix4f.ci:130:[.060271, .060276) exec(0), time(0.000 ms): <rotation+153>
cmplStd/lib/math/Matrix4f.ci:131:[.060276, .06027b) exec(0), time(0.000 ms): <rotation+158>
cmplStd/lib/math/Matrix4f.ci:132:[.06027b, .060280) exec(0), time(0.000 ms): <rotation+163>
cmplStd/lib/math/Matrix4f.ci:133:[.060280, .060285) exec(0), time(0.000 ms): <rotation+168>
cmplStd/lib/math/Matrix4f.ci:135:[.060285, .06028b) exec(0), time(0.000 ms): <rotation+173>
cmplStd/lib/math/Matrix4f.ci:136:[.06028b, .060291) exec(0), time(0.000 ms): <rotation+179>
cmplStd/lib/math/Matrix4f.ci:137:[.060291, .060299) exec(0), time(0.000 ms): <rotation+185>
cmplStd/lib/math/Matrix4f.ci:140:[.060299, .0602a6) exec(0), time(0.000 ms): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:141:[.0602a6, .0602b3) exec(0), time(0.000 ms): <rotation+206>
cmplStd/lib/math/Matrix4f.ci:142:[.0602b3, .0602c0) exec(0), time(0.000 ms): <rotation+219>
cmplStd/lib/math/Matrix4f.ci:143:[.0602c0, .0602eb) exec(0), time(0.000 ms): <rotation+232>
cmplStd/lib/math/Matrix4f.ci:145:[.0602eb, .0602f8) exec(0), time(0.000 ms): <rotation+275>
cmplStd/lib/math/Matrix4f.ci:146:[.0602f8, .060305) exec(0), time(0.000 ms): <rotation+288>
cmplStd/lib/math/Matrix4f.ci:147:[.060305, .060312) exec(0), time(0.000 ms): <rotation+301>
cmplStd/lib/math/Matrix4f.ci:148:[.060312, .06033d) exec(0), time(0.000 ms): <rotation+314>
cmplStd/lib/math/Matrix4f.ci:150:[.06033d, .06034a) exec(0), time(0.000 ms): <rotation+357>
cmplStd/lib/math/Matrix4f.ci:151:[.06034a, .060357) exec(0), time(0.000 ms): <rotation+370>
cmplStd/lib/math/Matrix4f.ci:152:[.060357, .060364) exec(0), time(0.000 ms): <rotation+383>
cmplStd/lib/math/Matrix4f.ci:153:[.060364, .06038f) exec(0), time(0.000 ms): <rotation+396>
cmplStd/lib/math/Matrix4f.ci:155:[.06038f, .060399) exec(0), time(0.000 ms): <rotation+439>
cmplStd/lib/math/Matrix4f.ci:139:[.060299, .06039e) exec(0), time(0.000 ms): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:165:[.0603a0, .0603a7) exec(0), time(0.000 ms): <translation+0>
cmplStd/lib/math/Matrix4f.ci:165:[.0603a7, .0603aa) exec(0), time(0.000 ms): <translation+7>
cmplStd/lib/math/Matrix4f.ci:165:[.0603aa, .0603ad) exec(0), time(0.000 ms): <translation+10>
cmplStd/lib/math/Matrix4f.ci:165:[.0603ad, .0603b5) exec(0), time(0.000 ms): <translation+13>
cmplStd/lib/math/Matrix4f.ci:166:[.0603b5, .0603b8) exec(0), time(0.000 ms): <translation+21>
cmplStd/lib/math/Matrix4f.ci:166:[.0603b8, .0603bf) exec(0), time(0.000 ms): <translation+24>
cmplStd/lib/math/Matrix4f.ci:166:[.0603bf, .0603c2) exec(0), time(0.000 ms): <translation+31>
cmplStd/lib/math/Matrix4f.ci:166:[.0603c2, .0603ce) exec(0), time(0.000 ms): <translation+34>
cmplStd/lib/math/Matrix4f.ci:167:[.0603ce, .0603d1) exec(0), time(0.000 ms): <translation+46>
cmplStd/lib/math/Matrix4f.ci:167:[.0603d1, .0603d4) exec(0), time(0.000 ms): <translation+49>
cmplStd/lib/math/Matrix4f.ci:167:[.0603d4, .0603db) exec(0), time(0.000 ms): <translation+52>
cmplStd/lib/math/Matrix4f.ci:167:[.0603db, .0603e7) exec(0), time(0.000 ms): <translation+59>
cmplStd/lib/math/Matrix4f.ci:168:[.0603e7, .0603ea) exec(0), time(0.000 ms): <translation+71>
cmplStd/lib/math/Matrix4f.ci:168:[.0603ea, .0603ed) exec(0), time(0.000 ms): <translation+74>
cmplStd/lib/math/Matrix4f.ci:168:[.0603ed, .0603f0) exec(0), time(0.000 ms): <translation+77>
cmplStd/lib/math/Matrix4f.ci:168:[.0603f0, .0603f7) exec(0), time(0.000 ms): <translation+80>
cmplStd/lib/math/Matrix4f.ci:164:[.0603a0, .0603f8) exec(0), time(0.000 ms): <translation+0>
cmplStd/lib/math/Matrix4f.ci:176:[.0603f8, .06042f) exec(0), time(0.000 ms): <scale+0>
cmplStd/lib/math/Matrix4f.ci:176:[.06042f, .060432) exec(0), time(0.000 ms): <scale+55>
cmplStd/lib/math/Matrix4f.ci:176:[.060432, .060435) exec(0), time(0.000 ms): <scale+58>
cmplStd/lib/math/Matrix4f.ci:176:[.060435, .060438) exec(0), time(0.000 ms): <scale+61>
cmplStd/lib/math/Matrix4f.ci:177:[.060438, .06043b) exec(0), time(0.000 ms): <scale+64>
cmplStd/lib/math/Matrix4f.ci:177:[.06043b, .060476) exec(0), time(0.000 ms): <scale+67>
cmplStd/lib/math/Matrix4f.ci:177:[.060476, .060479) exec(0), time(0.000 ms): <scale+126>
cmplStd/lib/math/Matrix4f.ci:177:[.060479, .06047c) exec(0), time(0.000 ms): <scale+129>
cmplStd/lib/math/Matrix4f.ci:178:[.06047c, .06047f) exec(0), time(0.000 ms): <scale+132>
cmplStd/lib/math/Matrix4f.ci:178:[.06047f, .060482) exec(0), time(0.000 ms): <scale+135>
cmplStd/lib/math/Matrix4f.ci:178:[.060482, .0604bd) exec(0), time(0.000 ms): <scale+138>
cmplStd/lib/math/Matrix4f.ci:178:[.0604bd, .0604c0) exec(0), time(0.000 ms): <scale+197>
cmplStd/lib/math/Matrix4f.ci:179:[.0604c0, .0604c3) exec(0), time(0.000 ms): <scale+200>
cmplStd/lib/math/Matrix4f.ci:179:[.0604c3, .0604c6) exec(0), time(0.000 ms): <scale+203>
cmplStd/lib/math/Matrix4f.ci:179:[.0604c6, .0604c9) exec(0), time(0.000 ms): <scale+206>
cmplStd/lib/math/Matrix4f.ci:179:[.0604c9, .0604d0) exec(0), time(0.000 ms): <scale+209>
cmplStd/lib/math/Matrix4f.ci:175:[.0603f8, .0604d1) exec(0), time(0.000 ms): <scale+0>
cmplStd/lib/math/Vector2d.ci:16:[.0604d8, .0604db) exec(0), time(0.000 ms): <vec2d+0>
cmplStd/lib/math/Vector2d.ci:17:[.0604db, .0604de) exec(0), time(0.000 ms): <vec2d+3>
cmplStd/lib/math/Vector2d.ci:15:[.0604d8, .0604df) exec(0), time(0.000 ms): <vec2d+0>
cmplStd/lib/string.ci:6:[.0604ec, .0604f0) exec(0), time(0.000 ms): <length+12>
cmplStd/lib/string.ci:5:[.0604e0, .0604f0) exec(0), time(0.000 ms): <length+0>
cmplStd/lib/string.ci:8:[.0604f0, .0604f1) exec(0), time(0.000 ms): <length+16>
cmplStd/lib/string.ci:9:[.0604f5, .0604f9) exec(0), time(0.000 ms): <length+21>
cmplStd/lib/string.ci:9:[.0604f9, .060503) exec(0), time(0.000 ms): <length+25>
cmplStd/lib/string.ci:9:[.0604f1, .060503) exec(0), time(0.000 ms): <length+17>
cmplStd/lib/string.ci:11:[.060503, .060506) exec(0), time(0.000 ms): <length+35>
cmplStd/lib/string.ci:18:[.06051d, .060520) exec(0), time(0.000 ms): <indexOf+21>
cmplStd/lib/string.ci:17:[.06050d, .060520) exec(0), time(0.000 ms): <indexOf+5>
cmplStd/lib/string.ci:16:[.060520, .060524) exec(0), time(0.000 ms): <indexOf+24>
cmplStd/lib/string.ci:16:[.060524, .06052e) exec(0), time(0.000 ms): <indexOf+28>
cmplStd/lib/string.ci:16:[.060508, .060532) exec(0), time(0.000 ms): <indexOf+0>
cmplStd/lib/string.ci:21:[.060532, .06053a) exec(0), time(0.000 ms): <indexOf+42>
cmplStd/lib/string.ci:26:[.060540, .060545) exec(0), time(0.000 ms): <lastIndexOf+0>
cmplStd/lib/string.ci:29:[.06055a, .06055d) exec(0), time(0.000 ms): <lastIndexOf+26>
cmplStd/lib/string.ci:28:[.06054a, .06055d) exec(0), time(0.000 ms): <lastIndexOf+10>
cmplStd/lib/string.ci:27:[.06055d, .060561) exec(0), time(0.000 ms): <lastIndexOf+29>
cmplStd/lib/string.ci:27:[.060561, .06056b) exec(0), time(0.000 ms): <lastIndexOf+33>
cmplStd/lib/string.ci:27:[.060545, .06056f) exec(0), time(0.000 ms): <lastIndexOf+5>
cmplStd/lib/string.ci:32:[.06056f, .060572) exec(0), time(0.000 ms): <lastIndexOf+47>
cmplStd/lib/string.ci:39:[.060597, .0605a2) exec(0), time(0.000 ms): <startsWith+31>
cmplStd/lib/string.ci:38:[.06057d, .0605a2) exec(0), time(0.000 ms): <startsWith+5>
cmplStd/lib/string.ci:37:[.0605a2, .0605a6) exec(0), time(0.000 ms): <startsWith+42>
cmplStd/lib/string.ci:37:[.0605a6, .0605b2) exec(0), time(0.000 ms): <startsWith+46>
cmplStd/lib/string.ci:37:[.060578, .0605b6) exec(0), time(0.000 ms): <startsWith+0>
cmplStd/lib/string.ci:42:[.0605b6, .0605c1) exec(0), time(0.000 ms): <startsWith+62>
cmplStd/lib/string.ci:47:[.0605c8, .0605d5) exec(0), time(0.000 ms): <endsWith+0>
cmplStd/lib/string.ci:48:[.0605d5, .0605e2) exec(0), time(0.000 ms): <endsWith+13>
cmplStd/lib/string.ci:50:[.0605eb, .0605f6) exec(0), time(0.000 ms): <endsWith+35>
cmplStd/lib/string.ci:49:[.0605e2, .0605f6) exec(0), time(0.000 ms): <endsWith+26>
cmplStd/lib/string.ci:54:[.06061b, .060626) exec(0), time(0.000 ms): <endsWith+83>
cmplStd/lib/string.ci:53:[.0605fb, .060626) exec(0), time(0.000 ms): <endsWith+51>
cmplStd/lib/string.ci:52:[.060626, .06062a) exec(0), time(0.000 ms): <endsWith+94>
cmplStd/lib/string.ci:52:[.06062a, .060633) exec(0), time(0.000 ms): <endsWith+98>
cmplStd/lib/string.ci:52:[.0605f6, .060637) exec(0), time(0.000 ms): <endsWith+46>
cmplStd/lib/string.ci:57:[.060637, .060646) exec(0), time(0.000 ms): <endsWith+111>
cmplStd/lib/string.ci:62:[.060648, .060649) exec(0), time(0.000 ms): <compare+0>
cmplStd/lib/string.ci:64:[.06064e, .060664) exec(0), time(0.000 ms): <compare+6>
cmplStd/lib/string.ci:66:[.060670, .060674) exec(0), time(0.000 ms): <compare+40>
cmplStd/lib/string.ci:65:[.060664, .060674) exec(0), time(0.000 ms): <compare+28>
cmplStd/lib/string.ci:63:[.060674, .060678) exec(0), time(0.000 ms): <compare+44>
cmplStd/lib/string.ci:63:[.060678, .060680) exec(0), time(0.000 ms): <compare+48>
cmplStd/lib/string.ci:63:[.060649, .060684) exec(0), time(0.000 ms): <compare+1>
cmplStd/lib/string.ci:69:[.060684, .060687) exec(0), time(0.000 ms): <compare+60>
cmplStd/lib/string.ci:76:[.060697, .0606a2) exec(0), time(0.000 ms): <ignCase+15>
cmplStd/lib/string.ci:75:[.060688, .0606a2) exec(0), time(0.000 ms): <ignCase+0>
cmplStd/lib/string.ci:79:[.0606b1, .0606bc) exec(0), time(0.000 ms): <ignCase+41>
cmplStd/lib/string.ci:78:[.0606a2, .0606bc) exec(0), time(0.000 ms): <ignCase+26>
cmplStd/lib/string.ci:81:[.0606bc, .0606cf) exec(0), time(0.000 ms): <ignCase+52>
cmplStd/lib/string.ci:84:[.0606d0, .0606f4) exec(0), time(0.000 ms): <ignCaseCmp+0>
cmplStd/lib/string.ci:89:[.0606f8, .060706) exec(0), time(0.000 ms): <caseCmp+0>
cmplStd/lib/string.ci:134:[.060716, .06071a) exec(0), time(0.000 ms): <append+14>
cmplStd/lib/string.ci:133:[.06070d, .06071a) exec(0), time(0.000 ms): <append+5>
cmplStd/lib/string.ci:136:[.06071a, .060726) exec(0), time(0.000 ms): <append+18>
cmplStd/lib/string.ci:137:[.060726, .06072e) exec(0), time(0.000 ms): <append+30>
cmplStd/lib/string.ci:132:[.06072e, .060732) exec(0), time(0.000 ms): <append+38>
cmplStd/lib/string.ci:132:[.060732, .06073c) exec(0), time(0.000 ms): <append+42>
cmplStd/lib/string.ci:132:[.060708, .060740) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:141:[.060749, .060751) exec(0), time(0.000 ms): <append+65>
cmplStd/lib/string.ci:140:[.060740, .060751) exec(0), time(0.000 ms): <append+56>
cmplStd/lib/string.ci:143:[.060751, .060758) exec(0), time(0.000 ms): <append+73>
cmplStd/lib/string.ci:144:[.060758, .06075c) exec(0), time(0.000 ms): <append+80>
cmplStd/lib/string.ci:152:[.060770, .060771) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:153:[.060771, .060775) exec(0), time(0.000 ms): <append+1>
cmplStd/lib/string.ci:157:[.060787, .060791) exec(0), time(0.000 ms): <append+23>
cmplStd/lib/string.ci:156:[.06077c, .060791) exec(0), time(0.000 ms): <append+12>
cmplStd/lib/string.ci:155:[.060775, .060791) exec(0), time(0.000 ms): <append+5>
cmplStd/lib/string.ci:161:[.060791, .060798) exec(0), time(0.000 ms): <append+33>
cmplStd/lib/string.ci:163:[.0607a0, .0607a7) exec(0), time(0.000 ms): <append+48>
cmplStd/lib/string.ci:162:[.060798, .0607a7) exec(0), time(0.000 ms): <append+40>
cmplStd/lib/string.ci:165:[.0607a7, .0607dd) exec(0), time(0.000 ms): <append+55>
cmplStd/lib/string.ci:166:[.0607dd, .060812) exec(0), time(0.000 ms): <append+109>
cmplStd/lib/string.ci:170:[.060816, .060833) exec(0), time(0.000 ms): <append+166>
cmplStd/lib/string.ci:169:[.060833, .06083b) exec(0), time(0.000 ms): <append+195>
cmplStd/lib/string.ci:169:[.06083b, .060843) exec(0), time(0.000 ms): <append+203>
cmplStd/lib/string.ci:169:[.060812, .060843) exec(0), time(0.000 ms): <append+162>
cmplStd/lib/string.ci:173:[.06084b, .060860) exec(0), time(0.000 ms): <append+219>
cmplStd/lib/string.ci:172:[.060843, .060860) exec(0), time(0.000 ms): <append+211>
cmplStd/lib/string.ci:176:[.060860, .06086a) exec(0), time(0.000 ms): <append+240>
cmplStd/lib/string.ci:178:[.06086a, .060871) exec(0), time(0.000 ms): <append+250>
cmplStd/lib/string.ci:180:[.06087c, .060886) exec(0), time(0.000 ms): <append+268>
cmplStd/lib/string.ci:179:[.060871, .060886) exec(0), time(0.000 ms): <append+257>
cmplStd/lib/string.ci:185:[.060891, .060899) exec(0), time(0.000 ms): <append+289>
cmplStd/lib/string.ci:189:[.0608b7, .0608eb) exec(0), time(0.000 ms): <append+327>
cmplStd/lib/string.ci:190:[.0608eb, .0608f6) exec(0), time(0.000 ms): <append+379>
cmplStd/lib/string.ci:191:[.0608f6, .0608fe) exec(0), time(0.000 ms): <append+390>
cmplStd/lib/string.ci:188:[.0608fe, .060906) exec(0), time(0.000 ms): <append+398>
cmplStd/lib/string.ci:188:[.060906, .06090e) exec(0), time(0.000 ms): <append+406>
cmplStd/lib/string.ci:188:[.0608b3, .06090e) exec(0), time(0.000 ms): <append+323>
cmplStd/lib/string.ci:186:[.060899, .06090e) exec(0), time(0.000 ms): <append+297>
cmplStd/lib/string.ci:194:[.06090e, .060942) exec(0), time(0.000 ms): <append+414>
cmplStd/lib/string.ci:195:[.060942, .06094d) exec(0), time(0.000 ms): <append+466>
cmplStd/lib/string.ci:196:[.06094d, .060955) exec(0), time(0.000 ms): <append+477>
cmplStd/lib/string.ci:184:[.060886, .060955) exec(0), time(0.000 ms): <append+278>
cmplStd/lib/string.ci:201:[.060959, .06098d) exec(0), time(0.000 ms): <append+489>
cmplStd/lib/string.ci:202:[.06098d, .060998) exec(0), time(0.000 ms): <append+541>
cmplStd/lib/string.ci:203:[.060998, .0609a0) exec(0), time(0.000 ms): <append+552>
cmplStd/lib/string.ci:200:[.0609a0, .0609a8) exec(0), time(0.000 ms): <append+560>
cmplStd/lib/string.ci:200:[.0609a8, .0609b0) exec(0), time(0.000 ms): <append+568>
cmplStd/lib/string.ci:200:[.060955, .0609b0) exec(0), time(0.000 ms): <append+485>
cmplStd/lib/string.ci:208:[.0609b5, .0609e9) exec(0), time(0.000 ms): <append+581>
cmplStd/lib/string.ci:209:[.0609e9, .0609fa) exec(0), time(0.000 ms): <append+633>
cmplStd/lib/string.ci:210:[.0609fa, .060a02) exec(0), time(0.000 ms): <append+650>
cmplStd/lib/string.ci:207:[.060a02, .060a06) exec(0), time(0.000 ms): <append+658>
cmplStd/lib/string.ci:207:[.060a06, .060a0f) exec(0), time(0.000 ms): <append+662>
cmplStd/lib/string.ci:207:[.0609b0, .060a13) exec(0), time(0.000 ms): <append+576>
cmplStd/lib/string.ci:214:[.060a1c, .060a24) exec(0), time(0.000 ms): <append+684>
cmplStd/lib/string.ci:213:[.060a13, .060a24) exec(0), time(0.000 ms): <append+675>
cmplStd/lib/string.ci:216:[.060a24, .060a2b) exec(0), time(0.000 ms): <append+692>
cmplStd/lib/string.ci:217:[.060a2b, .060a33) exec(0), time(0.000 ms): <append+699>
cmplStd/lib/string.ci:240:[.060a3c, .060a44) exec(0), time(0.000 ms): <append+4>
cmplStd/lib/string.ci:241:[.060a44, .060a47) exec(0), time(0.000 ms): <append+12>
cmplStd/lib/string.ci:242:[.060a47, .060a53) exec(0), time(0.000 ms): <append+15>
cmplStd/lib/string.ci:243:[.060a53, .060a64) exec(0), time(0.000 ms): <append+27>
cmplStd/lib/string.ci:239:[.060a38, .060a64) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:246:[.060a68, .060a6e) exec(0), time(0.000 ms): <append+48>
cmplStd/lib/string.ci:247:[.060a6e, .060a71) exec(0), time(0.000 ms): <append+54>
cmplStd/lib/string.ci:248:[.060a71, .060a7b) exec(0), time(0.000 ms): <append+57>
cmplStd/lib/string.ci:249:[.060a7b, .060a84) exec(0), time(0.000 ms): <append+67>
cmplStd/lib/string.ci:245:[.060a64, .060a84) exec(0), time(0.000 ms): <append+44>
cmplStd/lib/string.ci:252:[.060a84, .060a96) exec(0), time(0.000 ms): <append+76>
cmplStd/lib/string.ci:253:[.060a96, .060aba) exec(0), time(0.000 ms): <append+94>
cmplStd/lib/string.ci:254:[.060aba, .060ad7) exec(0), time(0.000 ms): <append+130>
cmplStd/lib/string.ci:256:[.060ad7, .060aed) exec(0), time(0.000 ms): <append+159>
cmplStd/lib/string.ci:257:[.060aed, .060b03) exec(0), time(0.000 ms): <append+181>
cmplStd/lib/string.ci:258:[.060b03, .060b1c) exec(0), time(0.000 ms): <append+203>
cmplStd/lib/string.ci:259:[.060b1c, .060b24) exec(0), time(0.000 ms): <append+228>
cmplStd/lib/string.ci:268:[.060b38, .060b77) exec(0), time(0.000 ms): <append+0>
cmplStd/test/std/tryExec.ci:16:[.060f30, .060f34) exec(128-1), time(0.032-0.032 ms): <stackOverflow+0>
cmplStd/test/std/tryExec.ci:17:[.060f34, .060f43) exec(127-127), time(0.000 ms): <stackOverflow+4>
cmplStd/test/std/tryExec.ci:21:[.060f48, .060f4f) exec(1-1), time(0.000 ms): <divisionByZero+0>
cmplStd/test/std/tryExec.ci:31:[.060f5c, .060f63) exec(1), time(0.000 ms): <abortExecution+4>
cmplStd/test/std/tryExec.ci:32:[.060f63, .060f6a) exec(1), time(0.000 ms): <abortExecution+11>
cmplStd/test/std/tryExec.ci:33:[.060f6a, .060f71) exec(1), time(0.000 ms): <abortExecution+18>
cmplStd/test/std/tryExec.ci:30:[.060f58, .060f71) exec(1-1), time(0.000 ms): <abortExecution+0>
cmplStd/test/std/tryExec.ci:35:[.060f71, .060f97) exec(1-1), time(0.000 ms): <abortExecution+25>
cmplStd/test/std/tryExec.ci:39:[.060fa0, .060fa5) exec(1), time(0.000 ms): <invalidMemoryAccess+0>
cmplStd/test/std/tryExec.ci:40:[.060fa5, .060fa8) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
cmplStd/test/std/tryExec.ci:44:[.060fb0, .060fb2) exec(1-1), time(0.000 ms): <invalidInstruction+0>
cmplStd/test/lang/function.ci:8:[.0612b8, .0612c0) exec(2), time(0.010-0.010 ms): <funAdd+0>
cmplStd/test/lang/function.ci:34:[.0612f8, .061300) exec(2), time(0.011-0.011 ms): <funMul+0>
cmplStd/test/lang/function.ci:40:[.06130c, .061310) exec(377), time(1.471-1.471 ms): <fib+12>
cmplStd/test/lang/function.ci:39:[.061300, .061310) exec(753-377), time(0.504-0.504 ms): <fib+0>
cmplStd/test/lang/function.ci:42:[.061310, .061336) exec(376-375), time(11.232-11.232 ms): <fib+16>
cmplStd/test/lang/init.method.ci:11:[.0614b0, .0614d6) exec(3), time(0.110-0.110 ms): <staticMethod+0>
cmplStd/test/lang/init.method.ci:41:[.0614e0, .061506) exec(4), time(0.141-0.141 ms): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:48:[.061508, .06152e) exec(0), time(0.000 ms): <forwardMethod+0>
cmplStd/test/lang/init.method.ci:58:[.061530, .061556) exec(0), time(0.000 ms): <globalFunction+0>
cmplStd/test/lang/init.method.ci:85:[.061568, .06158b) exec(1), time(0.014-0.014 ms): <staticMethod+0>
cmplStd/test/lang/init.method.ci:87:[.061599, .0615a9) exec(1), time(0.058-0.058 ms): <staticMethod+49>
cmplStd/test/lang/init.method.ci:86:[.06158b, .0615a9) exec(1-1), time(0.000 ms): <staticMethod+35>
cmplStd/test/lang/init.method.ci:91:[.0615b0, .0615d3) exec(1), time(0.014-0.014 ms): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:93:[.0615e1, .0615ee) exec(1), time(0.059-0.059 ms): <virtualMethod+49>
cmplStd/test/lang/init.method.ci:92:[.0615d3, .0615ee) exec(1-1), time(0.000 ms): <virtualMethod+35>
cmplStd/lib/string.ci:149:[.062034, .062042) exec(1), time(0.001-0.001 ms): <.main+0>
cmplStd/lib/string.ci:150:[.062042, .062050) exec(1), time(0.001-0.001 ms): <.main+14>
::[.062050, .062057) exec(1), time(0.001-0.001 ms): <.main+28>
::[.062057, .06205c) exec(1), time(0.000 ms): <.main+35>
::[.06205c, .062063) exec(1), time(0.001-0.001 ms): <.main+40>
::[.062063, .062068) exec(1), time(0.001-0.001 ms): <.main+47>
cmplStd/lib/string.ci:267:[.062050, .062068) exec(0), time(0.000 ms): <.main+28>
cmplStd/test/lang/emit.ci:3:[.062068, .06206d) exec(1), time(0.000 ms): <.main+52>
cmplStd/test/lang/emit.ci:4:[.06206d, .062072) exec(1), time(0.000 ms): <.main+57>
cmplStd/test/lang/emit.ci:6:[.062072, .06207b) exec(1), time(0.000 ms): <.main+62>
cmplStd/test/lang/emit.ci:7:[.06207b, .062084) exec(1), time(0.000 ms): <.main+71>
cmplStd/test/lang/emit.ci:10:[.062084, .062091) exec(1), time(0.001-0.001 ms): <.main+80>
cmplStd/test/lang/emit.ci:13:[.062091, .0620a0) exec(1), time(0.001-0.001 ms): <.main+93>
cmplStd/test/lang/emit.ci:16:[.0620a0, .0620b3) exec(1), time(0.021-0.021 ms): <.main+108>
cmplStd/test/lang/emit.ci:23:[.0620b3, .0620bc) exec(1), time(0.000 ms): <.main+127>
cmplStd/test/lang/emit.ci:24:[.0620bc, .0620c6) exec(1), time(0.001-0.001 ms): <.main+136>
cmplStd/test/lang/emit.ci:25:[.0620c6, .0620d4) exec(1), time(0.001-0.001 ms): <.main+146>
cmplStd/test/lang/emit.ci:26:[.0620d4, .0620e1) exec(1), time(0.000 ms): <.main+160>
cmplStd/test/lang/emit.ci:29:[.0620e1, .0620ef) exec(1), time(0.001-0.001 ms): <.main+173>
cmplStd/test/lang/inlineMacros.ci:10:[.0620ef, .0620f8) exec(1), time(0.001-0.001 ms): <.main+187>
cmplStd/test/lang/inlineMacros.ci:11:[.0620f8, .062101) exec(1), time(0.000 ms): <.main+196>
cmplStd/test/lang/inlineMacros.ci:12:[.062101, .06210a) exec(1), time(0.000 ms): <.main+205>
cmplStd/test/lang/inlineMacros.ci:13:[.06210a, .062113) exec(1), time(0.000 ms): <.main+214>
cmplStd/test/lang/inlineMacros.ci:15:[.062113, .062118) exec(1), time(0.000 ms): <.main+223>
cmplStd/test/lang/inlineMacros.ci:16:[.062118, .06211d) exec(1), time(0.001-0.001 ms): <.main+228>
cmplStd/test/lang/inlineMacros.ci:17:[.06211d, .062122) exec(1), time(0.001-0.001 ms): <.main+233>
cmplStd/test/lang/inlineMacros.ci:19:[.062122, .06212b) exec(1), time(0.001-0.001 ms): <.main+238>
cmplStd/test/lang/inlineMacros.ci:20:[.06212b, .062133) exec(1), time(0.001-0.001 ms): <.main+247>
cmplStd/test/lang/inlineMacros.ci:21:[.062133, .062143) exec(1), time(0.002-0.002 ms): <.main+255>
cmplStd/test/lang/inlineMacros.ci:23:[.062143, .062150) exec(1), time(0.001-0.001 ms): <.main+271>
cmplStd/test/lang/inlineMacros.ci:24:[.062150, .06215d) exec(1), time(0.001-0.001 ms): <.main+284>
cmplStd/test/lang/inlineMacros.ci:25:[.06215d, .062176) exec(1), time(0.002-0.002 ms): <.main+297>
cmplStd/test/lang/inlineMacros.ci:27:[.062176, .062192) exec(1), time(0.003-0.003 ms): <.main+322>
cmplStd/test/lang/inlineMacros.ci:28:[.062192, .0621ac) exec(1), time(0.003-0.003 ms): <.main+350>
cmplStd/test/lang/inlineMacros.ci:29:[.0621ac, .0621d2) exec(1), time(0.004-0.004 ms): <.main+376>
cmplStd/test/lang/inlineMacros.ci:31:[.0621d2, .0621f7) exec(1), time(0.005-0.005 ms): <.main+414>
cmplStd/test/lang/inlineMacros.ci:32:[.0621f7, .06221a) exec(1), time(0.005-0.005 ms): <.main+451>
cmplStd/test/lang/inlineMacros.ci:33:[.06221a, .062249) exec(1), time(0.006-0.006 ms): <.main+486>
cmplStd/test/lang/inlineMacros.ci:35:[.062249, .06226e) exec(1), time(0.004-0.004 ms): <.main+533>
cmplStd/test/lang/inlineMacros.ci:36:[.06226e, .062291) exec(1), time(0.004-0.004 ms): <.main+570>
cmplStd/test/lang/inlineMacros.ci:37:[.062291, .0622c0) exec(1), time(0.005-0.005 ms): <.main+605>
cmplStd/test/lang/inlineMacros.ci:41:[.0622c0, .0622d9) exec(1), time(0.003-0.003 ms): <.main+652>
cmplStd/test/lang/inlineMacros.ci:42:[.0622d9, .0622ee) exec(1), time(0.002-0.002 ms): <.main+677>
cmplStd/test/lang/inlineMacros.ci:43:[.0622ee, .062305) exec(1), time(0.003-0.003 ms): <.main+698>
cmplStd/test/lang/inlineMacros.ci:44:[.062305, .06231c) exec(1), time(0.003-0.003 ms): <.main+721>
cmplStd/test/lang/inlineMacros.ci:45:[.06231c, .062347) exec(1), time(0.005-0.005 ms): <.main+744>
cmplStd/test/lang/inlineMacros.ci:46:[.062347, .062372) exec(1), time(0.005-0.005 ms): <.main+787>
cmplStd/test/lang/inlineMacros.ci:50:[.062372, .0623b4) exec(1), time(0.003-0.003 ms): <.main+830>
cmplStd/test/lang/inlineMacros.ci:51:[.0623b4, .0623f6) exec(1), time(0.007-0.007 ms): <.main+896>
cmplStd/test/lang/inlineMacros.ci:52:[.0623f6, .062434) exec(1), time(0.003-0.003 ms): <.main+962>
cmplStd/test/lang/inlineMacros.ci:53:[.062434, .062472) exec(1), time(0.007-0.007 ms): <.main+1024>
cmplStd/test/lang/inlineMacros.ci:54:[.062472, .0624c4) exec(1), time(0.003-0.003 ms): <.main+1086>
cmplStd/test/lang/inlineMacros.ci:55:[.0624c4, .062516) exec(1), time(0.008-0.008 ms): <.main+1168>
cmplStd/test/lang/inlineMacros.ci:59:[.062516, .062573) exec(1), time(0.012-0.012 ms): <.main+1250>
cmplStd/test/lang/inlineMacros.ci:60:[.062573, .0625d0) exec(1), time(0.012-0.012 ms): <.main+1343>
cmplStd/test/lang/inlineMacros.ci:61:[.0625d0, .062629) exec(1), time(0.012-0.012 ms): <.main+1436>
cmplStd/test/lang/inlineMacros.ci:62:[.062629, .062682) exec(1), time(0.012-0.012 ms): <.main+1525>
cmplStd/test/lang/inlineMacros.ci:63:[.062682, .0626ef) exec(1), time(0.013-0.013 ms): <.main+1614>
cmplStd/test/lang/inlineMacros.ci:64:[.0626ef, .06275c) exec(1), time(0.014-0.014 ms): <.main+1723>
cmplStd/test/lang/inlineMacros.ci:68:[.06275c, .0627b9) exec(1), time(0.011-0.011 ms): <.main+1832>
cmplStd/test/lang/inlineMacros.ci:69:[.0627b9, .062816) exec(1), time(0.011-0.011 ms): <.main+1925>
cmplStd/test/lang/inlineMacros.ci:70:[.062816, .06286f) exec(1), time(0.011-0.011 ms): <.main+2018>
cmplStd/test/lang/inlineMacros.ci:71:[.06286f, .0628c8) exec(1), time(0.011-0.011 ms): <.main+2107>
cmplStd/test/lang/inlineMacros.ci:72:[.0628c8, .062935) exec(1), time(0.013-0.013 ms): <.main+2196>
cmplStd/test/lang/inlineMacros.ci:73:[.062935, .0629a2) exec(1), time(0.013-0.013 ms): <.main+2305>
cmplStd/test/lang/overload.inline.ci:9:[.0629a2, .0629ab) exec(1), time(0.000 ms): <.main+2414>
cmplStd/test/lang/overload.inline.ci:10:[.0629ab, .0629b4) exec(1), time(0.000 ms): <.main+2423>
cmplStd/test/lang/overload.inline.ci:11:[.0629b4, .0629bd) exec(1), time(0.001-0.001 ms): <.main+2432>
cmplStd/test/lang/overload.inline.ci:12:[.0629bd, .0629c6) exec(1), time(0.001-0.001 ms): <.main+2441>
cmplStd/test/lang/overload.inline.ci:13:[.0629c6, .0629cf) exec(1), time(0.001-0.001 ms): <.main+2450>
cmplStd/test/lang/overload.inline.ci:28:[.0629cf, .0629dc) exec(1), time(0.001-0.001 ms): <.main+2459>
cmplStd/test/lang/overload.inline.ci:29:[.0629dc, .0629f8) exec(1), time(0.002-0.002 ms): <.main+2472>
cmplStd/test/std/number.ci:3:[.0629f8, .062a05) exec(1), time(0.000 ms): <.main+2500>
cmplStd/test/std/number.ci:4:[.062a05, .062a12) exec(1), time(0.000 ms): <.main+2513>
cmplStd/test/std/number.ci:6:[.062a12, .062a1b) exec(1), time(0.001-0.001 ms): <.main+2526>
cmplStd/test/std/number.ci:7:[.062a1b, .062a24) exec(1), time(0.001-0.001 ms): <.main+2535>
cmplStd/test/std/number.ci:14:[.062a24, .062a2f) exec(1), time(0.001-0.001 ms): <.main+2544>
cmplStd/test/std/number.ci:15:[.062a2f, .062a3a) exec(1), time(0.001-0.001 ms): <.main+2555>
cmplStd/test/std/number.ci:16:[.062a3a, .062a45) exec(1), time(0.001-0.001 ms): <.main+2566>
cmplStd/test/std/number.ci:18:[.062a45, .062a6b) exec(1), time(0.006-0.006 ms): <.main+2577>
cmplStd/test/std/number.ci:19:[.062a6b, .062a8f) exec(1), time(0.005-0.005 ms): <.main+2615>
cmplStd/test/std/number.ci:21:[.062a8f, .062aa5) exec(1), time(0.016-0.016 ms): <.main+2651>
cmplStd/test/std/number.ci:22:[.062aa5, .062abb) exec(1), time(0.015-0.015 ms): <.main+2673>
cmplStd/test/std/number.ci:23:[.062abb, .062acd) exec(1), time(0.015-0.015 ms): <.main+2695>
cmplStd/test/std/number.ci:25:[.062acd, .062ae3) exec(1), time(0.015-0.015 ms): <.main+2713>
cmplStd/test/std/number.ci:26:[.062ae3, .062af9) exec(1), time(0.015-0.015 ms): <.main+2735>
cmplStd/test/std/number.ci:27:[.062af9, .062b0b) exec(1), time(0.015-0.015 ms): <.main+2757>
cmplStd/test/std/number.ci:29:[.062b0b, .062b21) exec(1), time(0.015-0.015 ms): <.main+2775>
cmplStd/test/std/number.ci:30:[.062b21, .062b37) exec(1), time(0.015-0.015 ms): <.main+2797>
cmplStd/test/std/number.ci:31:[.062b37, .062b49) exec(1), time(0.015-0.015 ms): <.main+2819>
cmplStd/test/std/number.ci:33:[.062b49, .062b5f) exec(1), time(0.015-0.015 ms): <.main+2837>
cmplStd/test/std/number.ci:34:[.062b5f, .062b75) exec(1), time(0.015-0.015 ms): <.main+2859>
cmplStd/test/std/number.ci:35:[.062b75, .062b87) exec(1), time(0.015-0.015 ms): <.main+2881>
cmplStd/test/std/number.ci:37:[.062b87, .062b9d) exec(1), time(0.022-0.022 ms): <.main+2899>
cmplStd/test/std/number.ci:38:[.062b9d, .062bb3) exec(1), time(0.015-0.015 ms): <.main+2921>
cmplStd/test/std/number.ci:39:[.062bb3, .062bc9) exec(1), time(0.016-0.016 ms): <.main+2943>
cmplStd/test/std/number.ci:40:[.062bc9, .062bdf) exec(1), time(0.016-0.016 ms): <.main+2965>
cmplStd/test/std/number.ci:41:[.062bdf, .062bf0) exec(1), time(0.014-0.014 ms): <.main+2987>
cmplStd/test/std/number.ci:42:[.062bf0, .062c0a) exec(1), time(0.015-0.015 ms): <.main+3004>
cmplStd/test/std/number.ci:43:[.062c0a, .062c1b) exec(1), time(0.015-0.015 ms): <.main+3030>
cmplStd/test/std/number.ci:44:[.062c1b, .062c30) exec(1), time(0.016-0.016 ms): <.main+3047>
cmplStd/test/std/number.ci:46:[.062c30, .062c42) exec(1), time(0.015-0.015 ms): <.main+3068>
cmplStd/test/std/number.ci:47:[.062c42, .062c54) exec(1), time(0.015-0.015 ms): <.main+3086>
cmplStd/test/std/number.ci:48:[.062c54, .062c66) exec(1), time(0.015-0.015 ms): <.main+3104>
cmplStd/test/std/number.ci:49:[.062c66, .062c7c) exec(1), time(0.016-0.016 ms): <.main+3122>
cmplStd/test/std/number.ci:50:[.062c7c, .062c89) exec(1), time(0.014-0.014 ms): <.main+3144>
cmplStd/test/std/number.ci:51:[.062c89, .062c9f) exec(1), time(0.016-0.016 ms): <.main+3157>
cmplStd/test/std/number.ci:52:[.062c9f, .062cb0) exec(1), time(0.015-0.015 ms): <.main+3179>
cmplStd/test/std/number.ci:53:[.062cb0, .062cc1) exec(1), time(0.015-0.015 ms): <.main+3196>
cmplStd/test/std/number.ci:55:[.062cc1, .062ccd) exec(1), time(0.015-0.015 ms): <.main+3213>
cmplStd/test/std/number.ci:56:[.062ccd, .062cd9) exec(1), time(0.015-0.015 ms): <.main+3225>
cmplStd/test/std/number.ci:57:[.062cd9, .062ce5) exec(1), time(0.014-0.014 ms): <.main+3237>
cmplStd/test/std/number.ci:58:[.062ce5, .062cf1) exec(1), time(0.014-0.014 ms): <.main+3249>
cmplStd/test/std/number.ci:59:[.062cf1, .062cfd) exec(1), time(0.014-0.014 ms): <.main+3261>
cmplStd/test/std/number.ci:60:[.062cfd, .062d09) exec(1), time(0.014-0.014 ms): <.main+3273>
cmplStd/test/std/number.ci:62:[.062d09, .062d1b) exec(1), time(0.015-0.015 ms): <.main+3285>
cmplStd/test/std/number.ci:63:[.062d1b, .062d2d) exec(1), time(0.015-0.015 ms): <.main+3303>
cmplStd/test/std/number.ci:65:[.062d2d, .062d41) exec(1), time(0.016-0.016 ms): <.main+3321>
cmplStd/test/std/number.ci:66:[.062d41, .062d55) exec(1), time(0.016-0.016 ms): <.main+3341>
cmplStd/test/std/memory.ci:7:[.062d55, .062d67) exec(1), time(0.015-0.015 ms): <.main+3361>
cmplStd/test/std/memory.ci:8:[.062d67, .062d79) exec(1), time(0.017-0.017 ms): <.main+3379>
cmplStd/test/std/memory.ci:9:[.062d79, .062d8b) exec(1), time(0.016-0.016 ms): <.main+3397>
cmplStd/test/std/memory.ci:10:[.062d8b, .062d9d) exec(1), time(0.015-0.015 ms): <.main+3415>
cmplStd/test/std/memory.ci:23:[.062d9d, .062daa) exec(1), time(0.001-0.001 ms): <.main+3433>
cmplStd/test/std/memory.ci:24:[.062daa, .062db7) exec(1), time(0.001-0.001 ms): <.main+3446>
cmplStd/test/std/tryExec.ci:47:[.062db7, .062dc9) exec(1), time(0.034-0.034 ms): <.main+3459>
cmplStd/test/std/tryExec.ci:48:[.062dc9, .062ddb) exec(1), time(0.016-0.016 ms): <.main+3477>
cmplStd/test/std/tryExec.ci:49:[.062ddb, .062ded) exec(1), time(1.569-1.569 ms): <.main+3495>
cmplStd/test/std/tryExec.ci:50:[.062ded, .062dff) exec(1), time(0.025-0.025 ms): <.main+3513>
cmplStd/test/std/tryExec.ci:51:[.062dff, .062e11) exec(1), time(0.024-0.024 ms): <.main+3531>
cmplStd/test/std/tryExec.ci:52:[.062e11, .062e23) exec(1), time(0.023-0.023 ms): <.main+3549>
cmplStd/test/std/tryExec.ci:53:[.062e23, .062e35) exec(1), time(0.094-0.094 ms): <.main+3567>
cmplStd/test/lang/init.reference.ci:7:[.062e35, .062e42) exec(1), time(0.001-0.001 ms): <.main+3585>
cmplStd/test/lang/init.reference.ci:8:[.062e42, .062e4b) exec(1), time(0.000 ms): <.main+3598>
cmplStd/test/lang/init.reference.ci:9:[.062e4b, .062e54) exec(1), time(0.001-0.001 ms): <.main+3607>
cmplStd/test/lang/init.reference.ci:10:[.062e54, .062e62) exec(1), time(0.002-0.002 ms): <.main+3616>
cmplStd/test/lang/init.reference.ci:12:[.062e62, .062e6b) exec(1), time(0.001-0.001 ms): <.main+3630>
cmplStd/test/lang/init.reference.ci:13:[.062e6b, .062e73) exec(1), time(0.001-0.001 ms): <.main+3639>
cmplStd/test/lang/init.reference.ci:14:[.062e73, .062e7b) exec(1), time(0.001-0.001 ms): <.main+3647>
cmplStd/test/lang/init.reference.ci:16:[.062e7b, .062e84) exec(1), time(0.000 ms): <.main+3655>
cmplStd/test/lang/init.reference.ci:17:[.062e84, .062e8d) exec(1), time(0.001-0.001 ms): <.main+3664>
cmplStd/test/lang/init.reference.ci:18:[.062e8d, .062e9b) exec(1), time(0.002-0.002 ms): <.main+3673>
cmplStd/test/lang/init.reference.ci:19:[.062e9b, .062ea4) exec(1), time(0.001-0.001 ms): <.main+3687>
cmplStd/test/lang/init.reference.ci:20:[.062ea4, .062ead) exec(1), time(0.000 ms): <.main+3696>
cmplStd/test/lang/init.reference.ci:21:[.062ead, .062eb6) exec(1), time(0.000 ms): <.main+3705>
cmplStd/test/lang/init.reference.ci:23:[.062eb6, .062ebf) exec(1), time(0.001-0.001 ms): <.main+3714>
cmplStd/test/lang/init.reference.ci:24:[.062ebf, .062ecd) exec(1), time(0.002-0.002 ms): <.main+3723>
cmplStd/test/lang/init.reference.ci:25:[.062ecd, .062ed6) exec(1), time(0.001-0.001 ms): <.main+3737>
cmplStd/test/lang/init.reference.ci:27:[.062ed6, .062ede) exec(1), time(0.000 ms): <.main+3746>
cmplStd/test/lang/init.reference.ci:28:[.062ede, .062ee6) exec(1), time(0.001-0.001 ms): <.main+3754>
cmplStd/test/lang/init.reference.ci:29:[.062ee6, .062eee) exec(1), time(0.001-0.001 ms): <.main+3762>
cmplStd/test/lang/init.reference.ci:30:[.062eee, .062ef6) exec(1), time(0.000 ms): <.main+3770>
cmplStd/test/lang/init.reference.ci:31:[.062ef6, .062efe) exec(1), time(0.001-0.001 ms): <.main+3778>
cmplStd/test/lang/init.reference.ci:32:[.062efe, .062f06) exec(1), time(0.001-0.001 ms): <.main+3786>
cmplStd/test/lang/init.reference.ci:35:[.062f06, .062f0f) exec(1), time(0.000 ms): <.main+3794>
cmplStd/test/lang/init.reference.ci:36:[.062f0f, .062f18) exec(1), time(0.001-0.001 ms): <.main+3803>
cmplStd/test/lang/init.reference.ci:37:[.062f18, .062f21) exec(1), time(0.001-0.001 ms): <.main+3812>
cmplStd/test/lang/init.reference.ci:38:[.062f21, .062f2a) exec(1), time(0.000 ms): <.main+3821>
cmplStd/test/lang/init.reference.ci:39:[.062f2a, .062f33) exec(1), time(0.001-0.001 ms): <.main+3830>
cmplStd/test/lang/init.reference.ci:40:[.062f33, .062f3c) exec(1), time(0.001-0.001 ms): <.main+3839>
cmplStd/test/lang/init.reference.ci:41:[.062f3c, .062f45) exec(1), time(0.000 ms): <.main+3848>
cmplStd/test/lang/init.reference.ci:42:[.062f45, .062f4e) exec(1), time(0.001-0.001 ms): <.main+3857>
cmplStd/test/lang/init.reference.ci:43:[.062f4e, .062f57) exec(1), time(0.001-0.001 ms): <.main+3866>
cmplStd/test/lang/init.reference.ci:44:[.062f57, .062f60) exec(1), time(0.000 ms): <.main+3875>
cmplStd/test/lang/init.reference.ci:45:[.062f60, .062f69) exec(1), time(0.001-0.001 ms): <.main+3884>
cmplStd/test/lang/init.reference.ci:46:[.062f69, .062f72) exec(1), time(0.001-0.001 ms): <.main+3893>
cmplStd/test/lang/init.reference.ci:47:[.062f72, .062f7b) exec(1), time(0.000 ms): <.main+3902>
cmplStd/test/lang/init.reference.ci:48:[.062f7b, .062f84) exec(1), time(0.001-0.001 ms): <.main+3911>
cmplStd/test/lang/init.reference.ci:49:[.062f84, .062f8d) exec(1), time(0.001-0.001 ms): <.main+3920>
cmplStd/test/lang/init.reference.ci:50:[.062f8d, .062f96) exec(1), time(0.001-0.001 ms): <.main+3929>
cmplStd/test/lang/init.reference.ci:51:[.062f96, .062f9f) exec(1), time(0.001-0.001 ms): <.main+3938>
cmplStd/test/lang/init.reference.ci:52:[.062f9f, .062fa8) exec(1), time(0.000 ms): <.main+3947>
cmplStd/test/lang/init.reference.ci:55:[.062fa8, .062fb6) exec(1), time(0.001-0.001 ms): <.main+3956>
cmplStd/test/lang/init.reference.ci:56:[.062fb6, .062fc4) exec(1), time(0.001-0.001 ms): <.main+3970>
cmplStd/test/lang/init.reference.ci:57:[.062fc4, .062fd2) exec(1), time(0.001-0.001 ms): <.main+3984>
cmplStd/test/lang/init.reference.ci:58:[.062fd2, .062fe0) exec(1), time(0.001-0.001 ms): <.main+3998>
cmplStd/test/lang/init.reference.ci:59:[.062fe0, .062fee) exec(1), time(0.002-0.002 ms): <.main+4012>
cmplStd/test/lang/init.reference.ci:60:[.062fee, .062ffc) exec(1), time(0.002-0.002 ms): <.main+4026>
cmplStd/test/lang/init.reference.ci:61:[.062ffc, .06300a) exec(1), time(0.001-0.001 ms): <.main+4040>
cmplStd/test/lang/init.reference.ci:62:[.06300a, .063018) exec(1), time(0.001-0.001 ms): <.main+4054>
cmplStd/test/lang/init.reference.ci:63:[.063018, .063026) exec(1), time(0.001-0.001 ms): <.main+4068>
cmplStd/test/lang/init.reference.ci:64:[.063026, .063034) exec(1), time(0.001-0.001 ms): <.main+4082>
cmplStd/test/lang/init.reference.ci:65:[.063034, .063042) exec(1), time(0.001-0.001 ms): <.main+4096>
cmplStd/test/lang/init.reference.ci:66:[.063042, .063050) exec(1), time(0.001-0.001 ms): <.main+4110>
cmplStd/test/lang/init.reference.ci:67:[.063050, .06305e) exec(1), time(0.001-0.001 ms): <.main+4124>
cmplStd/test/lang/init.reference.ci:68:[.06305e, .06306c) exec(1), time(0.001-0.001 ms): <.main+4138>
cmplStd/test/lang/init.reference.ci:69:[.06306c, .06307a) exec(1), time(0.001-0.001 ms): <.main+4152>
cmplStd/test/lang/init.reference.ci:70:[.06307a, .063088) exec(1), time(0.001-0.001 ms): <.main+4166>
cmplStd/test/lang/init.reference.ci:71:[.063088, .063096) exec(1), time(0.001-0.001 ms): <.main+4180>
cmplStd/test/lang/init.reference.ci:72:[.063096, .0630a4) exec(1), time(0.001-0.001 ms): <.main+4194>
cmplStd/test/lang/init.reference.ci:75:[.0630a4, .0630ad) exec(1), time(0.000 ms): <.main+4208>
cmplStd/test/lang/init.reference.ci:76:[.0630ad, .0630b6) exec(1), time(0.001-0.001 ms): <.main+4217>
cmplStd/test/lang/init.reference.ci:77:[.0630b6, .0630bf) exec(1), time(0.001-0.001 ms): <.main+4226>
cmplStd/test/lang/init.reference.ci:78:[.0630bf, .0630c8) exec(1), time(0.001-0.001 ms): <.main+4235>
cmplStd/test/lang/init.reference.ci:79:[.0630c8, .0630d1) exec(1), time(0.001-0.001 ms): <.main+4244>
cmplStd/test/lang/init.reference.ci:80:[.0630d1, .0630da) exec(1), time(0.000 ms): <.main+4253>
cmplStd/test/lang/init.reference.ci:81:[.0630da, .0630e3) exec(1), time(0.001-0.001 ms): <.main+4262>
cmplStd/test/lang/init.reference.ci:82:[.0630e3, .0630ec) exec(1), time(0.001-0.001 ms): <.main+4271>
cmplStd/test/lang/init.reference.ci:83:[.0630ec, .0630f5) exec(1), time(0.001-0.001 ms): <.main+4280>
cmplStd/test/lang/init.reference.ci:84:[.0630f5, .0630fe) exec(1), time(0.001-0.001 ms): <.main+4289>
cmplStd/test/lang/init.reference.ci:85:[.0630fe, .063107) exec(1), time(0.000 ms): <.main+4298>
cmplStd/test/lang/init.reference.ci:86:[.063107, .063110) exec(1), time(0.001-0.001 ms): <.main+4307>
cmplStd/test/lang/init.reference.ci:87:[.063110, .063119) exec(1), time(0.000 ms): <.main+4316>
cmplStd/test/lang/init.reference.ci:88:[.063119, .063122) exec(1), time(0.001-0.001 ms): <.main+4325>
cmplStd/test/lang/init.reference.ci:89:[.063122, .06312b) exec(1), time(0.001-0.001 ms): <.main+4334>
cmplStd/test/lang/init.reference.ci:90:[.06312b, .063134) exec(1), time(0.000 ms): <.main+4343>
cmplStd/test/lang/init.reference.ci:91:[.063134, .06313d) exec(1), time(0.001-0.001 ms): <.main+4352>
cmplStd/test/lang/init.reference.ci:92:[.06313d, .063146) exec(1), time(0.000 ms): <.main+4361>
cmplStd/test/lang/init.reference.ci:95:[.063146, .06314f) exec(1), time(0.001-0.001 ms): <.main+4370>
cmplStd/test/lang/init.reference.ci:96:[.06314f, .06315d) exec(1), time(0.002-0.002 ms): <.main+4379>
cmplStd/test/lang/init.reference.ci:97:[.06315d, .063166) exec(1), time(0.001-0.001 ms): <.main+4393>
cmplStd/test/lang/init.reference.ci:99:[.063166, .06316f) exec(1), time(0.000 ms): <.main+4402>
cmplStd/test/lang/init.reference.ci:105:[.06316f, .06317c) exec(1), time(0.001-0.001 ms): <.main+4411>
cmplStd/test/lang/init.reference.ci:108:[.06317c, .063184) exec(1), time(0.001-0.001 ms): <.main+4424>
cmplStd/test/lang/init.variable.ci:3:[.063184, .063189) exec(1), time(0.000 ms): <.main+4432>
cmplStd/test/lang/init.variable.ci:7:[.063189, .063192) exec(1), time(0.001-0.001 ms): <.main+4437>
cmplStd/test/lang/init.variable.ci:24:[.063192, .06319f) exec(1), time(0.001-0.001 ms): <.main+4446>
::[.06319f, .0631a4) exec(1), time(0.001-0.001 ms): <.main+4459>
cmplStd/test/lang/init.variable.ci:24:[.063192, .0631a4) exec(0), time(0.000 ms): <.main+4446>
cmplStd/test/lang/init.variable.ci:33:[.0631a4, .0631b1) exec(1), time(0.019-0.019 ms): <.main+4464>
cmplStd/test/lang/init.variable.ci:33:[.0631b1, .0631c3) exec(1), time(0.002-0.002 ms): <.main+4477>
::[.0631c3, .0631cd) exec(1), time(0.002-0.002 ms): <.main+4495>
cmplStd/test/lang/init.variable.ci:33:[.0631a4, .0631cd) exec(0), time(0.000 ms): <.main+4464>
cmplStd/test/lang/init.variable.ci:41:[.0631cd, .0631da) exec(1), time(0.018-0.018 ms): <.main+4505>
cmplStd/test/lang/init.variable.ci:41:[.0631da, .0631ec) exec(1), time(0.002-0.002 ms): <.main+4518>
::[.0631ec, .0631f6) exec(1), time(0.002-0.002 ms): <.main+4536>
cmplStd/test/lang/init.variable.ci:41:[.0631cd, .0631f6) exec(0), time(0.000 ms): <.main+4505>
cmplStd/test/lang/function.ci:12:[.0631f6, .06320f) exec(1), time(0.017-0.017 ms): <.main+4546>
cmplStd/test/lang/function.ci:15:[.06320f, .063218) exec(1), time(0.000 ms): <.main+4571>
cmplStd/test/lang/function.ci:18:[.063218, .063230) exec(1), time(0.017-0.017 ms): <.main+4580>
cmplStd/test/lang/function.ci:21:[.063230, .063239) exec(1), time(0.001-0.001 ms): <.main+4604>
cmplStd/test/lang/function.ci:24:[.063239, .063251) exec(1), time(0.016-0.016 ms): <.main+4613>
cmplStd/test/lang/function.ci:27:[.063251, .063259) exec(1), time(0.001-0.001 ms): <.main+4637>
cmplStd/test/lang/function.ci:30:[.063259, .063271) exec(1), time(0.016-0.016 ms): <.main+4645>
cmplStd/test/lang/function.ci:46:[.063271, .063285) exec(1), time(11.244-11.244 ms): <.main+4669>
cmplStd/test/lang/reflect.ci:3:[.063285, .063292) exec(1), time(0.015-0.015 ms): <.main+4689>
cmplStd/test/lang/reflect.ci:4:[.063292, .06329f) exec(1), time(0.015-0.015 ms): <.main+4702>
cmplStd/test/lang/reflect.ci:5:[.06329f, .0632ac) exec(1), time(0.015-0.015 ms): <.main+4715>
cmplStd/test/lang/reflect.ci:6:[.0632ac, .0632b9) exec(1), time(0.015-0.015 ms): <.main+4728>
cmplStd/test/lang/reflect.ci:7:[.0632b9, .0632c6) exec(1), time(0.015-0.015 ms): <.main+4741>
cmplStd/test/lang/reflect.ci:8:[.0632c6, .0632d3) exec(1), time(0.014-0.014 ms): <.main+4754>
cmplStd/test/lang/reflect.ci:9:[.0632d3, .0632e0) exec(1), time(0.015-0.015 ms): <.main+4767>
cmplStd/test/lang/reflect.ci:10:[.0632e0, .0632ed) exec(1), time(0.015-0.015 ms): <.main+4780>
cmplStd/test/lang/reflect.ci:11:[.0632ed, .0632fa) exec(1), time(0.016-0.016 ms): <.main+4793>
cmplStd/test/lang/reflect.ci:12:[.0632fa, .063307) exec(1), time(0.015-0.015 ms): <.main+4806>
cmplStd/test/lang/reflect.ci:13:[.063307, .063314) exec(1), time(0.016-0.016 ms): <.main+4819>
cmplStd/test/lang/reflect.ci:14:[.063314, .063321) exec(1), time(0.015-0.015 ms): <.main+4832>
cmplStd/test/lang/reflect.ci:15:[.063321, .06332e) exec(1), time(0.015-0.015 ms): <.main+4845>
cmplStd/test/lang/reflect.ci:16:[.06332e, .06333b) exec(1), time(0.015-0.015 ms): <.main+4858>
cmplStd/test/lang/reflect.ci:17:[.06333b, .063348) exec(1), time(0.015-0.015 ms): <.main+4871>
cmplStd/test/lang/reflect.ci:18:[.063348, .063355) exec(1), time(0.015-0.015 ms): <.main+4884>
cmplStd/test/lang/reflect.ci:19:[.063355, .063362) exec(1), time(0.015-0.015 ms): <.main+4897>
cmplStd/test/lang/reflect.ci:20:[.063362, .06336f) exec(1), time(0.014-0.014 ms): <.main+4910>
cmplStd/test/lang/reflect.ci:30:[.06336f, .063378) exec(1), time(0.001-0.001 ms): <.main+4923>
cmplStd/test/lang/reflect.ci:31:[.063378, .063384) exec(1), time(0.018-0.018 ms): <.main+4932>
cmplStd/test/lang/reflect.ci:32:[.063384, .063391) exec(1), time(0.002-0.002 ms): <.main+4944>
cmplStd/test/lang/reflect.ci:33:[.063391, .06339e) exec(1), time(0.002-0.002 ms): <.main+4957>
cmplStd/test/lang/reflect.ci:34:[.06339e, .0633aa) exec(1), time(0.018-0.018 ms): <.main+4970>
cmplStd/test/lang/reflect.ci:35:[.0633aa, .0633b6) exec(1), time(0.018-0.018 ms): <.main+4982>
cmplStd/test/lang/reflect.ci:37:[.0633b6, .0633c2) exec(1), time(0.018-0.018 ms): <.main+4994>
cmplStd/test/lang/reflect.ci:38:[.0633c2, .0633ce) exec(1), time(0.017-0.017 ms): <.main+5006>
cmplStd/test/lang/reflect.ci:39:[.0633ce, .0633db) exec(1), time(0.002-0.002 ms): <.main+5018>
cmplStd/test/lang/reflect.ci:40:[.0633db, .0633e8) exec(1), time(0.002-0.002 ms): <.main+5031>
cmplStd/test/lang/reflect.ci:41:[.0633e8, .0633f4) exec(1), time(0.018-0.018 ms): <.main+5044>
cmplStd/test/lang/reflect.ci:42:[.0633f4, .063400) exec(1), time(0.018-0.018 ms): <.main+5056>
cmplStd/test/lang/reflect.ci:44:[.063400, .06340c) exec(1), time(0.018-0.018 ms): <.main+5068>
cmplStd/test/lang/reflect.ci:45:[.06340c, .063419) exec(1), time(0.002-0.002 ms): <.main+5080>
cmplStd/test/lang/reflect.ci:46:[.063419, .063426) exec(1), time(0.002-0.002 ms): <.main+5093>
cmplStd/test/lang/reflect.ci:48:[.063426, .063432) exec(1), time(0.015-0.015 ms): <.main+5106>
cmplStd/test/lang/reflect.ci:49:[.063432, .06343f) exec(1), time(0.002-0.002 ms): <.main+5118>
cmplStd/test/lang/reflect.ci:50:[.06343f, .06344c) exec(1), time(0.002-0.002 ms): <.main+5131>
cmplStd/test/lang/init.member.ci:34:[.06344c, .063451) exec(1), time(0.001-0.001 ms): <.main+5144>
cmplStd/test/lang/init.member.ci:37:[.063451, .06345a) exec(1), time(0.001-0.001 ms): <.main+5149>
cmplStd/test/lang/init.member.ci:40:[.06345a, .063463) exec(1), time(0.001-0.001 ms): <.main+5158>
cmplStd/test/lang/init.member.ci:43:[.063463, .06346c) exec(1), time(0.001-0.001 ms): <.main+5167>
::[.06346c, .063471) exec(1), time(0.000 ms): <.main+5176>
cmplStd/test/lang/init.member.ci:43:[.063463, .063471) exec(0), time(0.000 ms): <.main+5167>
cmplStd/test/lang/init.member.ci:46:[.063471, .06347a) exec(1), time(0.001-0.001 ms): <.main+5181>
cmplStd/test/lang/init.member.ci:46:[.06347a, .063483) exec(1), time(0.001-0.001 ms): <.main+5190>
cmplStd/test/lang/init.member.ci:46:[.063471, .063483) exec(0), time(0.000 ms): <.main+5181>
cmplStd/test/lang/init.member.ci:49:[.063483, .06348c) exec(1), time(0.001-0.001 ms): <.main+5199>
cmplStd/test/lang/init.member.ci:49:[.06348c, .063495) exec(1), time(0.001-0.001 ms): <.main+5208>
cmplStd/test/lang/init.member.ci:49:[.063483, .063495) exec(0), time(0.000 ms): <.main+5199>
cmplStd/test/lang/init.member.ci:53:[.063495, .06349e) exec(1), time(0.000 ms): <.main+5217>
cmplStd/test/lang/init.member.ci:54:[.06349e, .0634a7) exec(1), time(0.001-0.001 ms): <.main+5226>
cmplStd/test/lang/init.member.ci:55:[.0634a7, .0634b0) exec(1), time(0.001-0.001 ms): <.main+5235>
cmplStd/test/lang/init.member.ci:56:[.0634b0, .0634b9) exec(1), time(0.001-0.001 ms): <.main+5244>
cmplStd/test/lang/init.member.ci:59:[.0634b9, .0634c2) exec(1), time(0.001-0.001 ms): <.main+5253>
cmplStd/test/lang/init.member.ci:60:[.0634c2, .0634cb) exec(1), time(0.001-0.001 ms): <.main+5262>
cmplStd/test/lang/init.member.ci:64:[.0634cb, .0634d4) exec(1), time(0.001-0.001 ms): <.main+5271>
cmplStd/test/lang/init.member.ci:65:[.0634d4, .0634dd) exec(1), time(0.000 ms): <.main+5280>
cmplStd/test/lang/init.member.ci:52:[.063495, .0634dd) exec(0), time(0.000 ms): <.main+5217>
cmplStd/test/lang/init.method.ci:18:[.0634dd, .0634e6) exec(1), time(0.001-0.001 ms): <.main+5289>
cmplStd/test/lang/init.method.ci:64:[.0634e6, .0634ef) exec(1), time(0.000 ms): <.main+5298>
::[.0634ef, .0634f7) exec(1), time(0.001-0.001 ms): <.main+5307>
::[.0634f7, .063500) exec(1), time(0.001-0.001 ms): <.main+5315>
cmplStd/test/lang/init.method.ci:62:[.0634e6, .063500) exec(0), time(0.000 ms): <.main+5298>
cmplStd/test/lang/recUnion.ci:26:[.063500, .063507) exec(1), time(0.002-0.002 ms): <.main+5324>
cmplStd/test/lang/recUnion.ci:26:[.063507, .06350e) exec(1), time(0.001-0.001 ms): <.main+5331>
cmplStd/test/lang/recUnion.ci:26:[.06350e, .063515) exec(1), time(0.001-0.001 ms): <.main+5338>
cmplStd/test/lang/recUnion.ci:26:[.063500, .063515) exec(0), time(0.000 ms): <.main+5324>
cmplStd/test/lang/recUnion.ci:27:[.063515, .06351c) exec(1), time(0.001-0.001 ms): <.main+5345>
cmplStd/test/lang/recUnion.ci:27:[.06351c, .063527) exec(1), time(0.002-0.002 ms): <.main+5352>
cmplStd/test/lang/recUnion.ci:27:[.063527, .06352e) exec(1), time(0.002-0.002 ms): <.main+5363>
cmplStd/test/lang/recUnion.ci:27:[.063515, .06352e) exec(0), time(0.000 ms): <.main+5345>
cmplStd/test/lang/recUnion.ci:28:[.06352e, .063539) exec(1), time(0.001-0.001 ms): <.main+5370>
cmplStd/test/lang/recUnion.ci:28:[.063539, .063544) exec(1), time(0.001-0.001 ms): <.main+5381>
cmplStd/test/lang/recUnion.ci:28:[.063544, .06354f) exec(1), time(0.002-0.002 ms): <.main+5392>
cmplStd/test/lang/recUnion.ci:28:[.06352e, .06354f) exec(0), time(0.000 ms): <.main+5370>
cmplStd/test/lang/recUnion.ci:30:[.06354f, .063558) exec(1), time(0.001-0.001 ms): <.main+5403>
cmplStd/test/lang/recUnion.ci:30:[.06354f, .063558) exec(0), time(0.000 ms): <.main+5403>
cmplStd/test/lang/recUnion.ci:31:[.063558, .06355f) exec(1), time(0.001-0.001 ms): <.main+5412>
cmplStd/test/lang/recUnion.ci:31:[.06355f, .063566) exec(1), time(0.002-0.002 ms): <.main+5419>
cmplStd/test/lang/recUnion.ci:31:[.063566, .063571) exec(1), time(0.002-0.002 ms): <.main+5426>
cmplStd/test/lang/recUnion.ci:31:[.063558, .063571) exec(0), time(0.000 ms): <.main+5412>
cmplStd/test/lang/useOperator.ci:5:[.063571, .06357a) exec(1), time(0.001-0.001 ms): <.main+5437>
cmplStd/test/lang/useOperator.ci:7:[.06357a, .063585) exec(1), time(0.002-0.002 ms): <.main+5446>
cmplStd/test/lang/useOperator.ci:8:[.063585, .063590) exec(1), time(0.001-0.001 ms): <.main+5457>
cmplStd/test/lang/useOperator.ci:17:[.063590, .0635a3) exec(1), time(0.004-0.004 ms): <.main+5468>
cmplStd/test/lang/useOperator.ci:18:[.0635a3, .0635b6) exec(1), time(0.004-0.004 ms): <.main+5487>
cmplStd/test/lang/useOperator.ci:19:[.0635b6, .0635c9) exec(1), time(0.004-0.004 ms): <.main+5506>
cmplStd/test/lang/useOperator.ci:22:[.0635c9, .0635d6) exec(1), time(0.003-0.003 ms): <.main+5525>
cmplStd/test/lang/useOperator.ci:23:[.0635d6, .0635e9) exec(1), time(0.004-0.004 ms): <.main+5538>
cmplStd/test/lang/useOperator.ci:24:[.0635e9, .0635fd) exec(1), time(0.004-0.004 ms): <.main+5557>
cmplStd/test/lang/useOperator.ci:25:[.0635fd, .063610) exec(1), time(0.004-0.004 ms): <.main+5577>
cmplStd/test/lang/useOperator.ci:26:[.063610, .063624) exec(1), time(0.005-0.005 ms): <.main+5596>
cmplStd/test/lang/useOperator.ci:27:[.063624, .063637) exec(1), time(0.004-0.004 ms): <.main+5616>
cmplStd/test/lang/useOperator.ci:28:[.063637, .06364b) exec(1), time(0.005-0.005 ms): <.main+5635>
cmplStd/test/lang/useOperator.ci:30:[.06364b, .063656) exec(1), time(0.001-0.001 ms): <.main+5655>
cmplStd/test/lang/useOperator.ci:31:[.063656, .063661) exec(1), time(0.001-0.001 ms): <.main+5666>
cmplStd/test/lang/useOperator.ci:32:[.063661, .06366d) exec(1), time(0.002-0.002 ms): <.main+5677>
cmplStd/test/lang/useOperator.ci:33:[.06366d, .06367a) exec(1), time(0.003-0.003 ms): <.main+5689>
cmplStd/test/lang/useOperator.ci:34:[.06367a, .063687) exec(1), time(0.002-0.002 ms): <.main+5702>
cmplStd/test/lang/useOperator.ci:35:[.063687, .06369a) exec(1), time(0.004-0.004 ms): <.main+5715>
cmplStd/test/lang/useOperator.ci:36:[.06369a, .0636ad) exec(1), time(0.004-0.004 ms): <.main+5734>
cmplStd/test/lang/useOperator.ci:37:[.0636ad, .0636c0) exec(1), time(0.004-0.004 ms): <.main+5753>
cmplStd/test/lang/useOperator.ci:38:[.0636c0, .0636d3) exec(1), time(0.004-0.004 ms): <.main+5772>
cmplStd/test/lang/useOperator.ci:39:[.0636d3, .0636e6) exec(1), time(0.004-0.004 ms): <.main+5791>
cmplStd/test/lang/useOperator.ci:40:[.0636e6, .0636f9) exec(1), time(0.004-0.004 ms): <.main+5810>
cmplStd/test/lang/useOperator.ci:41:[.0636f9, .06370c) exec(1), time(0.004-0.004 ms): <.main+5829>
cmplStd/test/lang/useOperator.ci:42:[.06370c, .06371f) exec(1), time(0.004-0.004 ms): <.main+5848>
cmplStd/test/lang/useOperator.ci:43:[.06371f, .063730) exec(1), time(0.003-0.003 ms): <.main+5867>
cmplStd/test/lang/useOperator.ci:44:[.063730, .063741) exec(1), time(0.004-0.004 ms): <.main+5884>
cmplStd/test/lang/useOperator.ci:45:[.063741, .06374f) exec(1), time(0.004-0.004 ms): <.main+5901>
cmplStd/test/lang/useOperator.ci:46:[.06374f, .063762) exec(1), time(0.004-0.004 ms): <.main+5915>
cmplStd/test/lang/useOperator.ci:47:[.063762, .063776) exec(1), time(0.005-0.005 ms): <.main+5934>
cmplStd/test/lang/useOperator.ci:48:[.063776, .063789) exec(1), time(0.004-0.004 ms): <.main+5954>
cmplStd/test/lang/useOperator.ci:49:[.063789, .06379d) exec(1), time(0.005-0.005 ms): <.main+5973>
cmplStd/test/lang/useOperator.ci:50:[.06379d, .0637b0) exec(1), time(0.005-0.005 ms): <.main+5993>
cmplStd/test/lang/useOperator.ci:51:[.0637b0, .0637c4) exec(1), time(0.005-0.005 ms): <.main+6012>
cmplStd/test/lang/useOperator.ci:53:[.0637c4, .0637cf) exec(1), time(0.001-0.001 ms): <.main+6032>
cmplStd/test/lang/useOperator.ci:54:[.0637cf, .0637da) exec(1), time(0.002-0.002 ms): <.main+6043>
cmplStd/test/lang/useOperator.ci:55:[.0637da, .0637e6) exec(1), time(0.002-0.002 ms): <.main+6054>
cmplStd/test/lang/useOperator.ci:56:[.0637e6, .0637f3) exec(1), time(0.002-0.002 ms): <.main+6066>
cmplStd/test/lang/useOperator.ci:57:[.0637f3, .063800) exec(1), time(0.003-0.003 ms): <.main+6079>
cmplStd/test/lang/useOperator.ci:58:[.063800, .063813) exec(1), time(0.004-0.004 ms): <.main+6092>
cmplStd/test/lang/useOperator.ci:59:[.063813, .063826) exec(1), time(0.004-0.004 ms): <.main+6111>
cmplStd/test/lang/useOperator.ci:60:[.063826, .063839) exec(1), time(0.004-0.004 ms): <.main+6130>
cmplStd/test/lang/useOperator.ci:61:[.063839, .06384c) exec(1), time(0.004-0.004 ms): <.main+6149>
cmplStd/test/lang/useOperator.ci:62:[.06384c, .06385f) exec(1), time(0.004-0.004 ms): <.main+6168>
cmplStd/test/lang/useOperator.ci:63:[.06385f, .063872) exec(1), time(0.004-0.004 ms): <.main+6187>
cmplStd/test/lang/useOperator.ci:64:[.063872, .063885) exec(1), time(0.004-0.004 ms): <.main+6206>
cmplStd/test/lang/useOperator.ci:65:[.063885, .063898) exec(1), time(0.004-0.004 ms): <.main+6225>
cmplStd/test/lang/useOperator.ci:66:[.063898, .0638a9) exec(1), time(0.003-0.003 ms): <.main+6244>
cmplStd/test/lang/useOperator.ci:67:[.0638a9, .0638ba) exec(1), time(0.003-0.003 ms): <.main+6261>
cmplStd/test/lang/useOperator.ci:68:[.0638ba, .0638c8) exec(1), time(0.004-0.004 ms): <.main+6278>
cmplStd/test/lang/useOperator.ci:69:[.0638c8, .0638db) exec(1), time(0.004-0.004 ms): <.main+6292>
cmplStd/test/lang/useOperator.ci:70:[.0638db, .0638ef) exec(1), time(0.005-0.005 ms): <.main+6311>
cmplStd/test/lang/useOperator.ci:71:[.0638ef, .063902) exec(1), time(0.004-0.004 ms): <.main+6331>
cmplStd/test/lang/useOperator.ci:72:[.063902, .063916) exec(1), time(0.005-0.005 ms): <.main+6350>
cmplStd/test/lang/useOperator.ci:73:[.063916, .063929) exec(1), time(0.004-0.004 ms): <.main+6370>
cmplStd/test/lang/useOperator.ci:74:[.063929, .06393d) exec(1), time(0.005-0.005 ms): <.main+6389>
cmplStd/test/lang/useOperator.ci:76:[.06393d, .063948) exec(1), time(0.001-0.001 ms): <.main+6409>
cmplStd/test/lang/useOperator.ci:77:[.063948, .063953) exec(1), time(0.001-0.001 ms): <.main+6420>
cmplStd/test/lang/useOperator.ci:78:[.063953, .06395f) exec(1), time(0.003-0.003 ms): <.main+6431>
cmplStd/test/lang/useOperator.ci:79:[.06395f, .06396c) exec(1), time(0.003-0.003 ms): <.main+6443>
cmplStd/test/lang/useOperator.ci:80:[.06396c, .063979) exec(1), time(0.003-0.003 ms): <.main+6456>
cmplStd/test/lang/useOperator.ci:81:[.063979, .06398c) exec(1), time(0.004-0.004 ms): <.main+6469>
cmplStd/test/lang/useOperator.ci:82:[.06398c, .06399f) exec(1), time(0.004-0.004 ms): <.main+6488>
cmplStd/test/lang/useOperator.ci:83:[.06399f, .0639b2) exec(1), time(0.004-0.004 ms): <.main+6507>
cmplStd/test/lang/useOperator.ci:84:[.0639b2, .0639c5) exec(1), time(0.004-0.004 ms): <.main+6526>
cmplStd/test/lang/useOperator.ci:85:[.0639c5, .0639d8) exec(1), time(0.004-0.004 ms): <.main+6545>
cmplStd/test/lang/useOperator.ci:86:[.0639d8, .0639eb) exec(1), time(0.004-0.004 ms): <.main+6564>
cmplStd/test/lang/useOperator.ci:87:[.0639eb, .0639fe) exec(1), time(0.005-0.005 ms): <.main+6583>
cmplStd/test/lang/useOperator.ci:88:[.0639fe, .063a11) exec(1), time(0.005-0.005 ms): <.main+6602>
cmplStd/test/lang/useOperator.ci:89:[.063a11, .063a22) exec(1), time(0.003-0.003 ms): <.main+6621>
cmplStd/test/lang/useOperator.ci:90:[.063a22, .063a33) exec(1), time(0.003-0.003 ms): <.main+6638>
cmplStd/test/lang/useOperator.ci:91:[.063a33, .063a41) exec(1), time(0.004-0.004 ms): <.main+6655>
cmplStd/test/lang/useOperator.ci:92:[.063a41, .063a54) exec(1), time(0.004-0.004 ms): <.main+6669>
cmplStd/test/lang/useOperator.ci:93:[.063a54, .063a68) exec(1), time(0.005-0.005 ms): <.main+6688>
cmplStd/test/lang/useOperator.ci:94:[.063a68, .063a7b) exec(1), time(0.004-0.004 ms): <.main+6708>
cmplStd/test/lang/useOperator.ci:95:[.063a7b, .063a8f) exec(1), time(0.005-0.005 ms): <.main+6727>
cmplStd/test/lang/useOperator.ci:96:[.063a8f, .063aa2) exec(1), time(0.004-0.004 ms): <.main+6747>
cmplStd/test/lang/useOperator.ci:97:[.063aa2, .063ab6) exec(1), time(0.005-0.005 ms): <.main+6766>
cmplStd/test/lang/useOperator.ci:99:[.063ab6, .063ac1) exec(1), time(0.001-0.001 ms): <.main+6786>
cmplStd/test/lang/useOperator.ci:100:[.063ac1, .063acc) exec(1), time(0.002-0.002 ms): <.main+6797>
cmplStd/test/lang/useOperator.ci:101:[.063acc, .063ad8) exec(1), time(0.002-0.002 ms): <.main+6808>
cmplStd/test/lang/useOperator.ci:102:[.063ad8, .063ae5) exec(1), time(0.003-0.003 ms): <.main+6820>
cmplStd/test/lang/useOperator.ci:103:[.063ae5, .063af2) exec(1), time(0.003-0.003 ms): <.main+6833>
cmplStd/test/lang/useOperator.ci:104:[.063af2, .063b05) exec(1), time(0.005-0.005 ms): <.main+6846>
cmplStd/test/lang/useOperator.ci:105:[.063b05, .063b18) exec(1), time(0.004-0.004 ms): <.main+6865>
cmplStd/test/lang/useOperator.ci:106:[.063b18, .063b2b) exec(1), time(0.004-0.004 ms): <.main+6884>
cmplStd/test/lang/useOperator.ci:107:[.063b2b, .063b3e) exec(1), time(0.004-0.004 ms): <.main+6903>
cmplStd/test/lang/useOperator.ci:108:[.063b3e, .063b51) exec(1), time(0.005-0.005 ms): <.main+6922>
cmplStd/test/lang/useOperator.ci:109:[.063b51, .063b64) exec(1), time(0.005-0.005 ms): <.main+6941>
cmplStd/test/lang/useOperator.ci:110:[.063b64, .063b77) exec(1), time(0.004-0.004 ms): <.main+6960>
cmplStd/test/lang/useOperator.ci:111:[.063b77, .063b8a) exec(1), time(0.004-0.004 ms): <.main+6979>
cmplStd/test/lang/useOperator.ci:112:[.063b8a, .063b9b) exec(1), time(0.004-0.004 ms): <.main+6998>
cmplStd/test/lang/useOperator.ci:113:[.063b9b, .063bac) exec(1), time(0.003-0.003 ms): <.main+7015>
cmplStd/test/lang/useOperator.ci:114:[.063bac, .063bba) exec(1), time(0.004-0.004 ms): <.main+7032>
cmplStd/test/lang/useOperator.ci:115:[.063bba, .063bcd) exec(1), time(0.004-0.004 ms): <.main+7046>
cmplStd/test/lang/useOperator.ci:116:[.063bcd, .063be1) exec(1), time(0.005-0.005 ms): <.main+7065>
cmplStd/test/lang/useOperator.ci:117:[.063be1, .063bf4) exec(1), time(0.004-0.004 ms): <.main+7085>
cmplStd/test/lang/useOperator.ci:118:[.063bf4, .063c08) exec(1), time(0.005-0.005 ms): <.main+7104>
cmplStd/test/lang/useOperator.ci:119:[.063c08, .063c1b) exec(1), time(0.004-0.004 ms): <.main+7124>
cmplStd/test/lang/useOperator.ci:120:[.063c1b, .063c2f) exec(1), time(0.005-0.005 ms): <.main+7143>
cmplStd/test/lang/useOperator.ci:122:[.063c2f, .063c3a) exec(1), time(0.002-0.002 ms): <.main+7163>
cmplStd/test/lang/useOperator.ci:123:[.063c3a, .063c45) exec(1), time(0.002-0.002 ms): <.main+7174>
cmplStd/test/lang/useOperator.ci:124:[.063c45, .063c51) exec(1), time(0.002-0.002 ms): <.main+7185>
cmplStd/test/lang/useOperator.ci:125:[.063c51, .063c5e) exec(1), time(0.003-0.003 ms): <.main+7197>
cmplStd/test/lang/useOperator.ci:126:[.063c5e, .063c6b) exec(1), time(0.003-0.003 ms): <.main+7210>
cmplStd/test/lang/useOperator.ci:127:[.063c6b, .063c7e) exec(1), time(0.004-0.004 ms): <.main+7223>
cmplStd/test/lang/useOperator.ci:128:[.063c7e, .063c91) exec(1), time(0.005-0.005 ms): <.main+7242>
cmplStd/test/lang/useOperator.ci:129:[.063c91, .063ca4) exec(1), time(0.005-0.005 ms): <.main+7261>
cmplStd/test/lang/useOperator.ci:130:[.063ca4, .063cb7) exec(1), time(0.004-0.004 ms): <.main+7280>
cmplStd/test/lang/useOperator.ci:131:[.063cb7, .063cca) exec(1), time(0.004-0.004 ms): <.main+7299>
cmplStd/test/lang/useOperator.ci:132:[.063cca, .063cdd) exec(1), time(0.005-0.005 ms): <.main+7318>
cmplStd/test/lang/useOperator.ci:133:[.063cdd, .063cf0) exec(1), time(0.004-0.004 ms): <.main+7337>
cmplStd/test/lang/useOperator.ci:134:[.063cf0, .063d03) exec(1), time(0.004-0.004 ms): <.main+7356>
cmplStd/test/lang/useOperator.ci:135:[.063d03, .063d14) exec(1), time(0.004-0.004 ms): <.main+7375>
cmplStd/test/lang/useOperator.ci:136:[.063d14, .063d25) exec(1), time(0.004-0.004 ms): <.main+7392>
cmplStd/test/lang/useOperator.ci:137:[.063d25, .063d33) exec(1), time(0.003-0.003 ms): <.main+7409>
cmplStd/test/lang/useOperator.ci:138:[.063d33, .063d46) exec(1), time(0.005-0.005 ms): <.main+7423>
cmplStd/test/lang/useOperator.ci:139:[.063d46, .063d5a) exec(1), time(0.005-0.005 ms): <.main+7442>
cmplStd/test/lang/useOperator.ci:140:[.063d5a, .063d6d) exec(1), time(0.004-0.004 ms): <.main+7462>
cmplStd/test/lang/useOperator.ci:141:[.063d6d, .063d81) exec(1), time(0.005-0.005 ms): <.main+7481>
cmplStd/test/lang/useOperator.ci:142:[.063d81, .063d94) exec(1), time(0.005-0.005 ms): <.main+7501>
cmplStd/test/lang/useOperator.ci:143:[.063d94, .063da8) exec(1), time(0.005-0.005 ms): <.main+7520>
cmplStd/test/lang/useOperator.ci:145:[.063da8, .063db1) exec(1), time(0.001-0.001 ms): <.main+7540>
cmplStd/test/lang/useOperator.ci:146:[.063db1, .063dba) exec(1), time(0.001-0.001 ms): <.main+7549>
cmplStd/test/lang/useOperator.ci:147:[.063dba, .063dc2) exec(1), time(0.001-0.001 ms): <.main+7558>
cmplStd/test/lang/useOperator.ci:148:[.063dc2, .063dcb) exec(1), time(0.002-0.002 ms): <.main+7566>
cmplStd/test/lang/useOperator.ci:149:[.063dcb, .063dd4) exec(1), time(0.002-0.002 ms): <.main+7575>
cmplStd/test/lang/useOperator.ci:150:[.063dd4, .063de1) exec(1), time(0.002-0.002 ms): <.main+7584>
cmplStd/test/lang/useOperator.ci:151:[.063de1, .063dee) exec(1), time(0.003-0.003 ms): <.main+7597>
cmplStd/test/lang/useOperator.ci:152:[.063dee, .063dfb) exec(1), time(0.002-0.002 ms): <.main+7610>
cmplStd/test/lang/useOperator.ci:153:[.063dfb, .063e08) exec(1), time(0.002-0.002 ms): <.main+7623>
cmplStd/test/lang/useOperator.ci:154:[.063e08, .063e15) exec(1), time(0.002-0.002 ms): <.main+7636>
cmplStd/test/lang/useOperator.ci:155:[.063e15, .063e22) exec(1), time(0.003-0.003 ms): <.main+7649>
cmplStd/test/lang/useOperator.ci:156:[.063e22, .063e2f) exec(1), time(0.002-0.002 ms): <.main+7662>
cmplStd/test/lang/useOperator.ci:157:[.063e2f, .063e3c) exec(1), time(0.002-0.002 ms): <.main+7675>
cmplStd/test/lang/useOperator.ci:158:[.063e3c, .063e49) exec(1), time(0.002-0.002 ms): <.main+7688>
cmplStd/test/lang/useOperator.ci:159:[.063e49, .063e56) exec(1), time(0.003-0.003 ms): <.main+7701>
cmplStd/test/lang/useOperator.ci:160:[.063e56, .063e62) exec(1), time(0.003-0.003 ms): <.main+7714>
cmplStd/test/lang/useOperator.ci:161:[.063e62, .063e71) exec(1), time(0.003-0.003 ms): <.main+7726>
cmplStd/test/lang/useOperator.ci:162:[.063e71, .063e81) exec(1), time(0.003-0.003 ms): <.main+7741>
cmplStd/test/lang/useOperator.ci:163:[.063e81, .063e90) exec(1), time(0.003-0.003 ms): <.main+7757>
cmplStd/test/lang/useOperator.ci:164:[.063e90, .063ea0) exec(1), time(0.004-0.004 ms): <.main+7772>
cmplStd/test/lang/useOperator.ci:165:[.063ea0, .063eaf) exec(1), time(0.003-0.003 ms): <.main+7788>
cmplStd/test/lang/useOperator.ci:166:[.063eaf, .063ebf) exec(1), time(0.004-0.004 ms): <.main+7803>
cmplStd/test/lang/useOperator.ci:168:[.063ebf, .063ec8) exec(1), time(0.001-0.001 ms): <.main+7819>
cmplStd/test/lang/useOperator.ci:169:[.063ec8, .063ed1) exec(1), time(0.001-0.001 ms): <.main+7828>
cmplStd/test/lang/useOperator.ci:170:[.063ed1, .063ed9) exec(1), time(0.001-0.001 ms): <.main+7837>
cmplStd/test/lang/useOperator.ci:171:[.063ed9, .063ee2) exec(1), time(0.002-0.002 ms): <.main+7845>
cmplStd/test/lang/useOperator.ci:172:[.063ee2, .063eeb) exec(1), time(0.002-0.002 ms): <.main+7854>
cmplStd/test/lang/useOperator.ci:173:[.063eeb, .063ef8) exec(1), time(0.002-0.002 ms): <.main+7863>
cmplStd/test/lang/useOperator.ci:174:[.063ef8, .063f05) exec(1), time(0.002-0.002 ms): <.main+7876>
cmplStd/test/lang/useOperator.ci:175:[.063f05, .063f12) exec(1), time(0.003-0.003 ms): <.main+7889>
cmplStd/test/lang/useOperator.ci:176:[.063f12, .063f1f) exec(1), time(0.002-0.002 ms): <.main+7902>
cmplStd/test/lang/useOperator.ci:177:[.063f1f, .063f2c) exec(1), time(0.002-0.002 ms): <.main+7915>
cmplStd/test/lang/useOperator.ci:178:[.063f2c, .063f39) exec(1), time(0.003-0.003 ms): <.main+7928>
cmplStd/test/lang/useOperator.ci:179:[.063f39, .063f46) exec(1), time(0.002-0.002 ms): <.main+7941>
cmplStd/test/lang/useOperator.ci:180:[.063f46, .063f53) exec(1), time(0.002-0.002 ms): <.main+7954>
cmplStd/test/lang/useOperator.ci:181:[.063f53, .063f60) exec(1), time(0.003-0.003 ms): <.main+7967>
cmplStd/test/lang/useOperator.ci:182:[.063f60, .063f6d) exec(1), time(0.002-0.002 ms): <.main+7980>
cmplStd/test/lang/useOperator.ci:183:[.063f6d, .063f79) exec(1), time(0.003-0.003 ms): <.main+7993>
cmplStd/test/lang/useOperator.ci:184:[.063f79, .063f88) exec(1), time(0.003-0.003 ms): <.main+8005>
cmplStd/test/lang/useOperator.ci:185:[.063f88, .063f98) exec(1), time(0.004-0.004 ms): <.main+8020>
cmplStd/test/lang/useOperator.ci:186:[.063f98, .063fa7) exec(1), time(0.003-0.003 ms): <.main+8036>
cmplStd/test/lang/useOperator.ci:187:[.063fa7, .063fb7) exec(1), time(0.004-0.004 ms): <.main+8051>
cmplStd/test/lang/useOperator.ci:188:[.063fb7, .063fc6) exec(1), time(0.003-0.003 ms): <.main+8067>
cmplStd/test/lang/useOperator.ci:189:[.063fc6, .063fd6) exec(1), time(0.004-0.004 ms): <.main+8082>
cmplStd/test/lang/useOperator.ci:191:[.063fd6, .063fe3) exec(1), time(0.001-0.001 ms): <.main+8098>
cmplStd/test/lang/useOperator.ci:192:[.063fe3, .063ff0) exec(1), time(0.001-0.001 ms): <.main+8111>
cmplStd/test/lang/useOperator.ci:193:[.063ff0, .063ff8) exec(1), time(0.000 ms): <.main+8124>
cmplStd/test/lang/useOperator.ci:194:[.063ff8, .064001) exec(1), time(0.002-0.002 ms): <.main+8132>
cmplStd/test/lang/useOperator.ci:195:[.064001, .06400a) exec(1), time(0.002-0.002 ms): <.main+8141>
cmplStd/test/lang/useOperator.ci:196:[.06400a, .064017) exec(1), time(0.002-0.002 ms): <.main+8150>
cmplStd/test/lang/useOperator.ci:197:[.064017, .064024) exec(1), time(0.003-0.003 ms): <.main+8163>
cmplStd/test/lang/useOperator.ci:198:[.064024, .064031) exec(1), time(0.003-0.003 ms): <.main+8176>
cmplStd/test/lang/useOperator.ci:199:[.064031, .06403e) exec(1), time(0.002-0.002 ms): <.main+8189>
cmplStd/test/lang/useOperator.ci:200:[.06403e, .06404b) exec(1), time(0.003-0.003 ms): <.main+8202>
cmplStd/test/lang/useOperator.ci:201:[.06404b, .064058) exec(1), time(0.002-0.002 ms): <.main+8215>
cmplStd/test/lang/useOperator.ci:202:[.064058, .064065) exec(1), time(0.003-0.003 ms): <.main+8228>
cmplStd/test/lang/useOperator.ci:203:[.064065, .064072) exec(1), time(0.003-0.003 ms): <.main+8241>
cmplStd/test/lang/useOperator.ci:204:[.064072, .06407f) exec(1), time(0.002-0.002 ms): <.main+8254>
cmplStd/test/lang/useOperator.ci:205:[.06407f, .06408c) exec(1), time(0.003-0.003 ms): <.main+8267>
cmplStd/test/lang/useOperator.ci:206:[.06408c, .064098) exec(1), time(0.003-0.003 ms): <.main+8280>
cmplStd/test/lang/useOperator.ci:207:[.064098, .0640a7) exec(1), time(0.003-0.003 ms): <.main+8292>
cmplStd/test/lang/useOperator.ci:208:[.0640a7, .0640b7) exec(1), time(0.004-0.004 ms): <.main+8307>
cmplStd/test/lang/useOperator.ci:209:[.0640b7, .0640c6) exec(1), time(0.003-0.003 ms): <.main+8323>
cmplStd/test/lang/useOperator.ci:210:[.0640c6, .0640d6) exec(1), time(0.004-0.004 ms): <.main+8338>
cmplStd/test/lang/useOperator.ci:211:[.0640d6, .0640e5) exec(1), time(0.003-0.003 ms): <.main+8354>
cmplStd/test/lang/useOperator.ci:212:[.0640e5, .0640f5) exec(1), time(0.004-0.004 ms): <.main+8369>
cmplStd/test/lang/useOperator.ci:214:[.0640f5, .064102) exec(1), time(0.001-0.001 ms): <.main+8385>
cmplStd/test/lang/useOperator.ci:215:[.064102, .06410f) exec(1), time(0.001-0.001 ms): <.main+8398>
cmplStd/test/lang/useOperator.ci:216:[.06410f, .064117) exec(1), time(0.001-0.001 ms): <.main+8411>
cmplStd/test/lang/useOperator.ci:217:[.064117, .064120) exec(1), time(0.002-0.002 ms): <.main+8419>
cmplStd/test/lang/useOperator.ci:218:[.064120, .064129) exec(1), time(0.001-0.001 ms): <.main+8428>
cmplStd/test/lang/useOperator.ci:219:[.064129, .064136) exec(1), time(0.003-0.003 ms): <.main+8437>
cmplStd/test/lang/useOperator.ci:220:[.064136, .064143) exec(1), time(0.002-0.002 ms): <.main+8450>
cmplStd/test/lang/useOperator.ci:221:[.064143, .064150) exec(1), time(0.003-0.003 ms): <.main+8463>
cmplStd/test/lang/useOperator.ci:222:[.064150, .06415d) exec(1), time(0.002-0.002 ms): <.main+8476>
cmplStd/test/lang/useOperator.ci:223:[.06415d, .06416a) exec(1), time(0.003-0.003 ms): <.main+8489>
cmplStd/test/lang/useOperator.ci:224:[.06416a, .064177) exec(1), time(0.003-0.003 ms): <.main+8502>
cmplStd/test/lang/useOperator.ci:225:[.064177, .064184) exec(1), time(0.002-0.002 ms): <.main+8515>
cmplStd/test/lang/useOperator.ci:226:[.064184, .064191) exec(1), time(0.003-0.003 ms): <.main+8528>
cmplStd/test/lang/useOperator.ci:227:[.064191, .06419e) exec(1), time(0.002-0.002 ms): <.main+8541>
cmplStd/test/lang/useOperator.ci:228:[.06419e, .0641ab) exec(1), time(0.003-0.003 ms): <.main+8554>
cmplStd/test/lang/useOperator.ci:229:[.0641ab, .0641b7) exec(1), time(0.003-0.003 ms): <.main+8567>
cmplStd/test/lang/useOperator.ci:230:[.0641b7, .0641c6) exec(1), time(0.004-0.004 ms): <.main+8579>
cmplStd/test/lang/useOperator.ci:231:[.0641c6, .0641d6) exec(1), time(0.004-0.004 ms): <.main+8594>
cmplStd/test/lang/useOperator.ci:232:[.0641d6, .0641e5) exec(1), time(0.004-0.004 ms): <.main+8610>
cmplStd/test/lang/useOperator.ci:233:[.0641e5, .0641f5) exec(1), time(0.004-0.004 ms): <.main+8625>
cmplStd/test/lang/useOperator.ci:234:[.0641f5, .064204) exec(1), time(0.003-0.003 ms): <.main+8641>
cmplStd/test/lang/useOperator.ci:235:[.064204, .064214) exec(1), time(0.004-0.004 ms): <.main+8656>
cmplStd/test/lang/useOperator.ci:237:[.064214, .06421d) exec(1), time(0.001-0.001 ms): <.main+8672>
cmplStd/test/lang/useOperator.ci:238:[.06421d, .064226) exec(1), time(0.001-0.001 ms): <.main+8681>
cmplStd/test/lang/useOperator.ci:239:[.064226, .06422e) exec(1), time(0.001-0.001 ms): <.main+8690>
cmplStd/test/lang/useOperator.ci:240:[.06422e, .064237) exec(1), time(0.002-0.002 ms): <.main+8698>
cmplStd/test/lang/useOperator.ci:242:[.064237, .064244) exec(1), time(0.003-0.003 ms): <.main+8707>
cmplStd/test/lang/useOperator.ci:243:[.064244, .064251) exec(1), time(0.003-0.003 ms): <.main+8720>
cmplStd/test/lang/useOperator.ci:244:[.064251, .06425e) exec(1), time(0.002-0.002 ms): <.main+8733>
cmplStd/test/lang/useOperator.ci:245:[.06425e, .06426b) exec(1), time(0.003-0.003 ms): <.main+8746>
cmplStd/test/lang/useOperator.ci:246:[.06426b, .064278) exec(1), time(0.002-0.002 ms): <.main+8759>
cmplStd/test/lang/useOperator.ci:252:[.064278, .064284) exec(1), time(0.004-0.004 ms): <.main+8772>
cmplStd/test/lang/useOperator.ci:253:[.064284, .064293) exec(1), time(0.003-0.003 ms): <.main+8784>
cmplStd/test/lang/useOperator.ci:254:[.064293, .0642a3) exec(1), time(0.004-0.004 ms): <.main+8799>
cmplStd/test/lang/useOperator.ci:255:[.0642a3, .0642b2) exec(1), time(0.004-0.004 ms): <.main+8815>
cmplStd/test/lang/useOperator.ci:256:[.0642b2, .0642c2) exec(1), time(0.004-0.004 ms): <.main+8830>
cmplStd/test/lang/useOperator.ci:257:[.0642c2, .0642d1) exec(1), time(0.003-0.003 ms): <.main+8846>
cmplStd/test/lang/useOperator.ci:258:[.0642d1, .0642e1) exec(1), time(0.004-0.004 ms): <.main+8861>
cmplStd/test/lang/useOperator.ci:260:[.0642e1, .0642ee) exec(1), time(0.001-0.001 ms): <.main+8877>
cmplStd/test/lang/useOperator.ci:261:[.0642ee, .0642fb) exec(1), time(0.001-0.001 ms): <.main+8890>
cmplStd/test/lang/useOperator.ci:262:[.0642fb, .064303) exec(1), time(0.001-0.001 ms): <.main+8903>
cmplStd/test/lang/useOperator.ci:263:[.064303, .06430c) exec(1), time(0.002-0.002 ms): <.main+8911>
cmplStd/test/lang/useOperator.ci:265:[.06430c, .064319) exec(1), time(0.002-0.002 ms): <.main+8920>
cmplStd/test/lang/useOperator.ci:266:[.064319, .064326) exec(1), time(0.003-0.003 ms): <.main+8933>
cmplStd/test/lang/useOperator.ci:267:[.064326, .064333) exec(1), time(0.002-0.002 ms): <.main+8946>
cmplStd/test/lang/useOperator.ci:268:[.064333, .064340) exec(1), time(0.003-0.003 ms): <.main+8959>
cmplStd/test/lang/useOperator.ci:269:[.064340, .06434d) exec(1), time(0.003-0.003 ms): <.main+8972>
cmplStd/test/lang/useOperator.ci:275:[.06434d, .064359) exec(1), time(0.003-0.003 ms): <.main+8985>
cmplStd/test/lang/useOperator.ci:276:[.064359, .064368) exec(1), time(0.004-0.004 ms): <.main+8997>
cmplStd/test/lang/useOperator.ci:277:[.064368, .064378) exec(1), time(0.004-0.004 ms): <.main+9012>
cmplStd/test/lang/useOperator.ci:278:[.064378, .064387) exec(1), time(0.003-0.003 ms): <.main+9028>
cmplStd/test/lang/useOperator.ci:279:[.064387, .064397) exec(1), time(0.004-0.004 ms): <.main+9043>
cmplStd/test/lang/useOperator.ci:280:[.064397, .0643a6) exec(1), time(0.004-0.004 ms): <.main+9059>
cmplStd/test/lang/useOperator.ci:281:[.0643a6, .0643b6) exec(1), time(0.005-0.005 ms): <.main+9074>
cmplStd/test/lang/useOperator.ci:283:[.0643b6, .0643bf) exec(1), time(0.001-0.001 ms): <.main+9090>
cmplStd/test/lang/useOperator.ci:284:[.0643bf, .0643c8) exec(1), time(0.001-0.001 ms): <.main+9099>
cmplStd/test/lang/useOperator.ci:299:[.0643c8, .0643d7) exec(1), time(0.004-0.004 ms): <.main+9108>
cmplStd/test/lang/useOperator.ci:300:[.0643d7, .0643e7) exec(1), time(0.004-0.004 ms): <.main+9123>
cmplStd/test/lang/stmt.if.ci:26:[.0643e7, .0643ec) exec(1), time(0.001-0.001 ms): <.main+9139>
cmplStd/test/lang/stmt.for.ci:12:[.0643ec, .0643f1) exec(1), time(0.001-0.001 ms): <.main+9144>
cmplStd/test/std/test.math.ci:3:[.0643f1, .064409) exec(1), time(0.023-0.023 ms): <.main+9149>
cmplStd/test/std/test.math.ci:4:[.064409, .064421) exec(1), time(0.020-0.020 ms): <.main+9173>
cmplStd/test/std/test.math.ci:5:[.064421, .064439) exec(1), time(0.020-0.020 ms): <.main+9197>
cmplStd/test/std/test.math.ci:6:[.064439, .064451) exec(1), time(0.028-0.028 ms): <.main+9221>
cmplStd/test/std/test.math.ci:7:[.064451, .064469) exec(1), time(0.028-0.028 ms): <.main+9245>
cmplStd/test/std/test.math.ci:8:[.064469, .064481) exec(1), time(0.027-0.027 ms): <.main+9269>
cmplStd/test/std/test.math.ci:10:[.064481, .06449e) exec(1), time(0.009-0.009 ms): <.main+9293>
cmplStd/test/std/test.math.ci:11:[.06449e, .0644b3) exec(1), time(0.010-0.010 ms): <.main+9322>
cmplStd/test/std/test.math.ci:12:[.0644b3, .0644d0) exec(1), time(0.009-0.009 ms): <.main+9343>
cmplStd/test/std/test.math.ci:13:[.0644d0, .0644e5) exec(1), time(0.009-0.009 ms): <.main+9372>
cmplStd/test/std/test.math.ci:14:[.0644e5, .0644f6) exec(1), time(0.008-0.008 ms): <.main+9393>
cmplStd/test/std/test.math.ci:15:[.0644f6, .06450b) exec(1), time(0.009-0.009 ms): <.main+9410>
cmplStd/test/std/test.math.ci:17:[.06450b, .06452b) exec(1), time(0.007-0.007 ms): <.main+9431>
cmplStd/test/std/test.math.ci:18:[.06452b, .064543) exec(1), time(0.006-0.006 ms): <.main+9463>
cmplStd/test/std/test.math.ci:19:[.064543, .064563) exec(1), time(0.007-0.007 ms): <.main+9487>
cmplStd/test/std/test.math.ci:20:[.064563, .064580) exec(1), time(0.007-0.007 ms): <.main+9519>
cmplStd/test/std/test.math.ci:21:[.064580, .064599) exec(1), time(0.007-0.007 ms): <.main+9548>
cmplStd/test/std/test.math.ci:22:[.064599, .0645b6) exec(1), time(0.008-0.008 ms): <.main+9573>
cmplStd/test/std/test.math.ci:24:[.0645b6, .0645dc) exec(1), time(0.010-0.010 ms): <.main+9602>
cmplStd/test/std/test.math.ci:25:[.0645dc, .064602) exec(1), time(0.008-0.008 ms): <.main+9640>
cmplStd/test/std/test.math.ci:26:[.064602, .06462f) exec(1), time(0.009-0.009 ms): <.main+9678>
cmplStd/test/std/test.math.ci:27:[.06462f, .06465c) exec(1), time(0.007-0.007 ms): <.main+9723>
cmplStd/test/std/test.math.ci:29:[.06465c, .064677) exec(1), time(0.016-0.016 ms): <.main+9768>
cmplStd/test/std/test.math.ci:30:[.064677, .064699) exec(1), time(0.015-0.015 ms): <.main+9795>
cmplStd/test/std/test.math.ci:32:[.064699, .0646b2) exec(1), time(0.009-0.009 ms): <.main+9829>
cmplStd/test/std/test.math.ci:33:[.0646b2, .0646d2) exec(1), time(0.008-0.008 ms): <.main+9854>
cmplStd/test/std/test.math.ci:35:[.0646d2, .064712) exec(1), time(0.031-0.031 ms): <.main+9886>
cmplStd/test/std/test.math.ci:36:[.064712, .064764) exec(1), time(0.029-0.029 ms): <.main+9950>
cmplStd/test/std/test.math.ci:38:[.064764, .06477d) exec(1), time(0.016-0.016 ms): <.main+10032>
cmplStd/test/std/test.math.ci:39:[.06477d, .0647eb) exec(1), time(0.037-0.037 ms): <.main+10057>
cmplStd/test/std/test.math.ci:40:[.0647eb, .064804) exec(1), time(0.016-0.016 ms): <.main+10167>
cmplStd/test/std/test.math.ci:41:[.064804, .064872) exec(1), time(0.038-0.038 ms): <.main+10192>
cmplStd/test/std/test.math.ci:43:[.064872, .06488b) exec(1), time(0.017-0.017 ms): <.main+10302>
cmplStd/test/std/test.math.ci:44:[.06488b, .0648b1) exec(1), time(0.020-0.020 ms): <.main+10327>
cmplStd/test/std/test.math.ci:45:[.0648b1, .0648e0) exec(1), time(0.022-0.022 ms): <.main+10365>
cmplStd/test/std/test.math.ci:46:[.0648e0, .064957) exec(1), time(0.041-0.041 ms): <.main+10412>
cmplStd/test/std/test.math.ci:48:[.064957, .064964) exec(1), time(0.001-0.001 ms): <.main+10531>
cmplStd/test/std/test.math.ci:49:[.064964, .064981) exec(1), time(0.018-0.018 ms): <.main+10544>
cmplStd/test/std/test.math.ci:50:[.064981, .06498e) exec(1), time(0.001-0.001 ms): <.main+10573>
cmplStd/test/std/test.math.ci:51:[.06498e, .0649aa) exec(1), time(0.005-0.005 ms): <.main+10586>
cmplStd/test/std/test.math.ci:52:[.0649aa, .0649d7) exec(1), time(0.009-0.009 ms): <.main+10614>
cmplStd/test/std/test.math.ci:53:[.0649d7, .064a15) exec(1), time(0.015-0.015 ms): <.main+10659>
cmplStd/test/std/test.math.ci:54:[.064a15, .064a63) exec(1), time(0.031-0.031 ms): <.main+10721>
cmplStd/test/std/test.math.ci:55:[.064a63, .064aba) exec(1), time(0.034-0.034 ms): <.main+10799>
cmplStd/test/std/test.math.ci:57:[.064aba, .064add) exec(1), time(0.027-0.027 ms): <.main+10886>
cmplStd/test/std/test.math.ci:58:[.064add, .064b17) exec(1), time(0.033-0.033 ms): <.main+10921>
cmplStd/test/std/test.math.ci:59:[.064b17, .064b39) exec(1), time(0.037-0.037 ms): <.main+10979>
cmplStd/test/std/test.math.ci:60:[.064b39, .064b5b) exec(1), time(0.047-0.047 ms): <.main+11013>
cmplStd/test/std/test.math.ci:61:[.064b5b, .064b7d) exec(1), time(0.041-0.041 ms): <.main+11047>
cmplStd/test/std/test.math.ci:63:[.064b7d, .064b95) exec(1), time(0.044-0.044 ms): <.main+11081>
cmplStd/test/std/test.math.ci:64:[.064b95, .064bc1) exec(1), time(0.047-0.047 ms): <.main+11105>
cmplStd/test/std/test.math.ci:67:[.064bc1, .064be3) exec(1), time(0.019-0.019 ms): <.main+11149>
cmplStd/test/std/test.math.ci:68:[.064be3, .064c11) exec(1), time(0.019-0.019 ms): <.main+11183>
cmplStd/test/std/test.math.ci:70:[.064c11, .064c32) exec(1), time(0.014-0.014 ms): <.main+11229>
cmplStd/test/std/test.math.ci:71:[.064c32, .064c4a) exec(1), time(0.013-0.013 ms): <.main+11262>
cmplStd/test/std/test.math.ci:72:[.064c4a, .064c6b) exec(1), time(0.014-0.014 ms): <.main+11286>
cmplStd/test/std/test.math.ci:74:[.064c6b, .064c8c) exec(1), time(0.014-0.014 ms): <.main+11319>
cmplStd/test/std/test.math.ci:75:[.064c8c, .064cad) exec(1), time(0.014-0.014 ms): <.main+11352>
cmplStd/test/std/test.math.ci:76:[.064cad, .064cce) exec(1), time(0.013-0.013 ms): <.main+11385>
cmplStd/test/std/test.math.ci:77:[.064cce, .064cef) exec(1), time(0.014-0.014 ms): <.main+11418>
cmplStd/test/std/test.math.ci:79:[.064cef, .064d10) exec(1), time(0.014-0.014 ms): <.main+11451>
cmplStd/test/std/test.math.ci:80:[.064d10, .064d31) exec(1), time(0.014-0.014 ms): <.main+11484>
cmplStd/test/std/test.math.ci:81:[.064d31, .064d52) exec(1), time(0.014-0.014 ms): <.main+11517>
cmplStd/test/std/test.math.ci:82:[.064d52, .064d73) exec(1), time(0.013-0.013 ms): <.main+11550>
cmplStd/test/std/test.math.ci:84:[.064d73, .064d8c) exec(1), time(0.013-0.013 ms): <.main+11583>
cmplStd/test/std/test.math.ci:85:[.064d8c, .064da1) exec(1), time(0.013-0.013 ms): <.main+11608>
cmplStd/test/std/test.math.ci:86:[.064da1, .064dba) exec(1), time(0.014-0.014 ms): <.main+11629>
cmplStd/test/std/test.math.ci:88:[.064dba, .064dd3) exec(1), time(0.014-0.014 ms): <.main+11654>
cmplStd/test/std/test.math.ci:89:[.064dd3, .064dec) exec(1), time(0.014-0.014 ms): <.main+11679>
cmplStd/test/std/test.math.ci:90:[.064dec, .064e05) exec(1), time(0.013-0.013 ms): <.main+11704>
cmplStd/test/std/test.math.ci:91:[.064e05, .064e1e) exec(1), time(0.014-0.014 ms): <.main+11729>
cmplStd/test/std/test.math.ci:93:[.064e1e, .064e37) exec(1), time(0.014-0.014 ms): <.main+11754>
cmplStd/test/std/test.math.ci:94:[.064e37, .064e50) exec(1), time(0.014-0.014 ms): <.main+11779>
cmplStd/test/std/test.math.ci:95:[.064e50, .064e69) exec(1), time(0.014-0.014 ms): <.main+11804>
cmplStd/test/std/test.math.ci:96:[.064e69, .064e82) exec(1), time(0.014-0.014 ms): <.main+11829>
cmplStd/test/std/memory.ci:13:[.064e82, .064e94) exec(1), time(0.019-0.019 ms): <.main+11854>
cmplStd/test/std/memory.ci:14:[.064e94, .064ea9) exec(1), time(0.019-0.019 ms): <.main+11872>
cmplStd/test/std/memory.ci:17:[.064ea9, .064eb6) exec(1), time(0.017-0.017 ms): <.main+11893>
cmplStd/test/std/memory.ci:18:[.064eb6, .064ec3) exec(1), time(0.018-0.018 ms): <.main+11906>
cmplStd/test/std/memory.ci:19:[.064ec3, .064ed0) exec(1), time(0.018-0.018 ms): <.main+11919>
cmplStd/test/std/memory.ci:20:[.064ed0, .064edd) exec(1), time(0.017-0.017 ms): <.main+11932>
cmplStd/test/std/memory.ci:26:[.064edd, .064f00) exec(1), time(0.022-0.022 ms): <.main+11945>
cmplStd/test/std/memory.ci:27:[.064f00, .064f23) exec(1), time(0.022-0.022 ms): <.main+11980>
cmplStd/test/std/memory.ci:29:[.064f23, .064f3e) exec(1), time(0.035-0.035 ms): <.main+12015>
cmplStd/test/std/memory.ci:30:[.064f3e, .064f55) exec(1), time(0.034-0.034 ms): <.main+12042>
cmplStd/test/std/memory.ci:32:[.064f55, .064f78) exec(1), time(0.022-0.022 ms): <.main+12065>
cmplStd/test/std/memory.ci:33:[.064f78, .064f9b) exec(1), time(0.024-0.024 ms): <.main+12100>
cmplStd/test/lang/init.method.ci:78:[.064f9b, .064fb0) exec(1), time(0.053-0.053 ms): <.main+12135>
cmplStd/test/lang/init.method.ci:79:[.064fb0, .064fc4) exec(1), time(0.052-0.052 ms): <.main+12156>
cmplStd/test/lang/init.method.ci:97:[.064fc4, .064fd7) exec(1), time(0.092-0.092 ms): <.main+12176>
cmplStd/test/lang/init.method.ci:98:[.064fd7, .064fea) exec(1), time(0.093-0.093 ms): <.main+12195>
cmplStd/test/lang/init.method.ci:101:[.064fea, .064fff) exec(1), time(0.051-0.051 ms): <.main+12214>
cmplStd/test/lang/init.method.ci:102:[.064fff, .065014) exec(1), time(0.050-0.050 ms): <.main+12235>
cmplStd/test/lang/init.method.ci:103:[.065014, .065028) exec(1), time(0.051-0.051 ms): <.main+12256>
cmplStd/test/lang/stmt.if.ci:4:[.065028, .06504f) exec(1), time(0.021-0.021 ms): <.main+12276>
cmplStd/test/lang/stmt.if.ci:12:[.06504f, .065076) exec(1), time(0.022-0.022 ms): <.main+12315>
cmplStd/test/lang/stmt.if.ci:22:[.065076, .06509d) exec(1), time(0.024-0.024 ms): <.main+12354>
cmplStd/test/lang/stmt.if.ci:29:[.0650a7, .0650ce) exec(1), time(0.025-0.025 ms): <.main+12403>
cmplStd/test/lang/stmt.if.ci:28:[.06509d, .0650ce) exec(1-1), time(0.000 ms): <.main+12393>
cmplStd/test/lang/stmt.if.ci:33:[.0650d8, .0650ff) exec(0), time(0.000 ms): <.main+12452>
cmplStd/test/lang/stmt.if.ci:32:[.0650ce, .0650ff) exec(1), time(0.003-0.003 ms): <.main+12442>
cmplStd/test/lang/stmt.if.ci:37:[.065109, .065130) exec(1), time(0.025-0.025 ms): <.main+12501>
cmplStd/test/lang/stmt.if.ci:40:[.065134, .06515b) exec(0), time(0.000 ms): <.main+12544>
cmplStd/test/lang/stmt.if.ci:36:[.0650ff, .06515b) exec(1), time(0.026-0.026 ms): <.main+12491>
cmplStd/test/lang/stmt.if.ci:44:[.065165, .06518c) exec(0), time(0.000 ms): <.main+12593>
cmplStd/test/lang/stmt.if.ci:47:[.065190, .0651b7) exec(1), time(0.024-0.024 ms): <.main+12636>
cmplStd/test/lang/stmt.if.ci:43:[.06515b, .0651b7) exec(1-1), time(0.000 ms): <.main+12583>
cmplStd/test/lang/stmt.if.ci:51:[.0651c1, .0651e8) exec(1), time(0.025-0.025 ms): <.main+12685>
cmplStd/test/lang/stmt.if.ci:54:[.0651fa, .065221) exec(0), time(0.000 ms): <.main+12742>
cmplStd/test/lang/stmt.if.ci:57:[.065233, .06525a) exec(0), time(0.000 ms): <.main+12799>
cmplStd/test/lang/stmt.if.ci:60:[.06526c, .065293) exec(0), time(0.000 ms): <.main+12856>
cmplStd/test/lang/stmt.if.ci:63:[.0652a5, .0652cc) exec(0), time(0.000 ms): <.main+12913>
cmplStd/test/lang/stmt.if.ci:66:[.0652de, .065305) exec(0), time(0.000 ms): <.main+12970>
cmplStd/test/lang/stmt.if.ci:69:[.065309, .065330) exec(0), time(0.000 ms): <.main+13013>
cmplStd/test/lang/stmt.if.ci:65:[.0652d0, .065330) exec(0), time(0.000 ms): <.main+12956>
cmplStd/test/lang/stmt.if.ci:62:[.065297, .065330) exec(0), time(0.000 ms): <.main+12899>
cmplStd/test/lang/stmt.if.ci:59:[.06525e, .065330) exec(0), time(0.000 ms): <.main+12842>
cmplStd/test/lang/stmt.if.ci:56:[.065225, .065330) exec(0), time(0.000 ms): <.main+12785>
cmplStd/test/lang/stmt.if.ci:53:[.0651ec, .065330) exec(0), time(0.000 ms): <.main+12728>
cmplStd/test/lang/stmt.if.ci:50:[.0651b7, .065330) exec(1), time(0.026-0.026 ms): <.main+12675>
cmplStd/test/lang/stmt.for.ci:4:[.065334, .065357) exec(1), time(0.020-0.020 ms): <.main+13056>
cmplStd/test/lang/stmt.for.ci:5:[.065357, .06535b) exec(1), time(0.000 ms): <.main+13091>
::[.06535b, .06535f) exec(1), time(0.000 ms): <.main+13095>
cmplStd/test/lang/stmt.for.ci:3:[.065330, .06535f) exec(1-1), time(0.000 ms): <.main+13052>
cmplStd/test/lang/stmt.for.ci:9:[.065364, .065386) exec(2), time(0.044-0.044 ms): <.main+13104>
cmplStd/test/lang/stmt.for.ci:8:[.065386, .06538a) exec(2), time(0.000 ms): <.main+13138>
cmplStd/test/lang/stmt.for.ci:8:[.06538a, .065396) exec(3), time(0.009-0.009 ms): <.main+13142>
cmplStd/test/lang/stmt.for.ci:8:[.06535f, .06539a) exec(1), time(0.004-0.004 ms): <.main+13099>
cmplStd/test/lang/stmt.for.ci:14:[.0653a3, .0653c6) exec(2), time(0.044-0.044 ms): <.main+13167>
cmplStd/test/lang/stmt.for.ci:13:[.0653c6, .0653d2) exec(2), time(0.004-0.004 ms): <.main+13202>
cmplStd/test/lang/stmt.for.ci:13:[.0653d2, .0653e0) exec(3), time(0.009-0.009 ms): <.main+13214>
cmplStd/test/lang/stmt.for.ci:13:[.06539a, .0653e0) exec(1-1), time(0.000 ms): <.main+13158>
cmplStd/test/lang/stmt.for.ci:19:[.0653f1, .0653f5) exec(2), time(0.001-0.001 ms): <.main+13245>
cmplStd/test/lang/stmt.for.ci:18:[.0653e5, .0653f5) exec(7-2), time(0.015-0.015 ms): <.main+13233>
cmplStd/test/lang/stmt.for.ci:21:[.0653f5, .065417) exec(5), time(0.111-0.111 ms): <.main+13249>
cmplStd/test/lang/stmt.for.ci:17:[.065417, .06541b) exec(7), time(0.000 ms): <.main+13283>
cmplStd/test/lang/stmt.for.ci:17:[.06541b, .065427) exec(8), time(0.024-0.024 ms): <.main+13287>
cmplStd/test/lang/stmt.for.ci:17:[.0653e0, .06542b) exec(1), time(0.004-0.004 ms): <.main+13228>
cmplStd/test/lang/stmt.for.ci:26:[.06543c, .065440) exec(1), time(0.000 ms): <.main+13320>
cmplStd/test/lang/stmt.for.ci:25:[.065430, .065440) exec(4-1), time(0.009-0.009 ms): <.main+13308>
cmplStd/test/lang/stmt.for.ci:28:[.065440, .065462) exec(3), time(0.066-0.066 ms): <.main+13324>
cmplStd/test/lang/stmt.for.ci:24:[.065462, .065466) exec(3), time(0.000 ms): <.main+13358>
cmplStd/test/lang/stmt.for.ci:24:[.065466, .065472) exec(4), time(0.012-0.012 ms): <.main+13362>
cmplStd/test/lang/stmt.for.ci:24:[.06542b, .065476) exec(1), time(0.001-0.001 ms): <.main+13303>

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
cmplStd/lib/debug.ci:48: NotEquals: typename(<NotEquals>)
cmplStd/lib/debug.ci:61: assertEq: function(<assertEq>)
cmplStd/lib/math.ci:22: Math.modf: function(<Math.modf>)
cmplStd/lib/math.ci:47: Math.floor: function(<Math.floor>)
cmplStd/lib/math.ci:77: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:85: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:147: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:158: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:189: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:203: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:217: Math.sum: function(<Math.sum>)
cmplStd/lib/math.ci:226: Math.mean: function(<Math.mean>)
cmplStd/lib/math.ci:243: Math.eval: function(<Math.eval>)
cmplStd/lib/math.ci:252: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:267: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:282: Math.sinCos: function(<Math.sinCos>)
cmplStd/lib/math.ci:339: Math.tan: function(<Math.tan>)
cmplStd/lib/math.ci:396: Math.sinh: function(<Math.sinh>)
cmplStd/lib/math.ci:435: Math.cosh: function(<Math.cosh>)
cmplStd/lib/math.ci:450: Math.asin: function(<Math.asin>)
cmplStd/lib/math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:24: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:31: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:86: div: function(<div>)
cmplStd/lib/math/Complex.ci:117: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:135: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:111: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:163: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:173: scale: function(<scale>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/string.ci:4: length: function(<length>)
cmplStd/lib/string.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/string.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/string.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/string.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/string.ci:61: compare: function(<compare>)
cmplStd/lib/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/string.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/string.ci:116: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/string.ci:131: append: function(<append>)
cmplStd/lib/string.ci:148: append: function(<append>)
cmplStd/lib/string.ci:238: append: function(<append>)
cmplStd/lib/string.ci:266: append: function(<append>)
cmplStd/test/lang/emit.ci:3: emitldz32: int32(0)
cmplStd/test/lang/emit.ci:4: emitldz64: int64(0)
cmplStd/test/lang/emit.ci:6: emitA: int32(42)
cmplStd/test/lang/emit.ci:7: emitB: int32(96)
cmplStd/test/lang/emit.ci:10: emitAddI32: int32(138)
cmplStd/test/lang/emit.ci:13: emitDivI32: int32(2)
cmplStd/test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
cmplStd/test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
cmplStd/test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
cmplStd/test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
cmplStd/test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
cmplStd/test/lang/emit.ci:29: emitSlice: char[]([3] {'s', 't', 'r'})
cmplStd/test/lang/inlineMacros.ci:10: i3: int32(3)
cmplStd/test/lang/inlineMacros.ci:11: i6: int32(6)
cmplStd/test/lang/inlineMacros.ci:12: i2: int32(2)
cmplStd/test/lang/inlineMacros.ci:13: i8: int32(8)
cmplStd/test/lang/inlineMacros.ci:15: zeroVal: int32(0)
cmplStd/test/lang/inlineMacros.ci:16: zeroVar: int32(0)
cmplStd/test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
cmplStd/test/lang/inlineMacros.ci:19: lastVal: int32(6)
cmplStd/test/lang/inlineMacros.ci:20: lastVar: int32(6)
cmplStd/test/lang/inlineMacros.ci:21: lastXpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:23: sum2Val: int32(9)
cmplStd/test/lang/inlineMacros.ci:24: sum2Var: int32(9)
cmplStd/test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
cmplStd/test/lang/inlineMacros.ci:27: any2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:28: any2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:31: min2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:32: min2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:35: max2Val: int32(6)
cmplStd/test/lang/inlineMacros.ci:36: max2Var: int32(6)
cmplStd/test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:59: minRlVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:60: minLrVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:61: minRlVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:62: minLrVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
cmplStd/test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
cmplStd/test/lang/overload.inline.ci:9: overload1: float32(1.000000)
cmplStd/test/lang/overload.inline.ci:10: overload2: float32(2.000000)
cmplStd/test/lang/overload.inline.ci:11: overload3: float32(3.000000)
cmplStd/test/lang/overload.inline.ci:12: overload4: float32(4.000000)
cmplStd/test/lang/overload.inline.ci:13: overload5: float32(5.000000)
cmplStd/test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
cmplStd/test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
cmplStd/test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
cmplStd/test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
cmplStd/test/std/number.ci:3: pi64: float64(3.141593)
cmplStd/test/std/number.ci:4: e64: float64(2.718282)
cmplStd/test/std/number.ci:6: pi32: float32(3.141593)
cmplStd/test/std/number.ci:7: e32: float32(2.718282)
cmplStd/test/std/number.ci:14: r_comp: int32(112)
cmplStd/test/std/number.ci:15: g_comp: int32(252)
cmplStd/test/std/number.ci:16: b_comp: int32(248)
cmplStd/test/std/number.ci:18: r5g6b5: int32(30719)
cmplStd/test/std/number.ci:19: r8g8b8: int32(7404792)
cmplStd/test/std/number.ci:21: zxtR5: int32(14)
cmplStd/test/std/number.ci:22: zxtG6: int32(63)
cmplStd/test/std/number.ci:23: zxtB5: int32(31)
cmplStd/test/std/number.ci:25: sxtR5: int32(14)
cmplStd/test/std/number.ci:26: sxtG6: int32(-1)
cmplStd/test/std/number.ci:27: sxtB5: int32(-1)
cmplStd/test/std/number.ci:29: zxtR8: int32(112)
cmplStd/test/std/number.ci:30: zxtG8: int32(252)
cmplStd/test/std/number.ci:31: zxtB8: int32(248)
cmplStd/test/std/number.ci:33: sxtR8: int32(112)
cmplStd/test/std/number.ci:34: sxtG8: int32(-4)
cmplStd/test/std/number.ci:35: sxtB8: int32(-8)
cmplStd/test/std/number.ci:37: testSin_f64: float64(1.000000)
cmplStd/test/std/number.ci:38: testCos_f64: float64(0.000000)
cmplStd/test/std/number.ci:39: testTan_f64: float64(1.000000)
cmplStd/test/std/number.ci:40: testLog_f64: float64(3.000000)
cmplStd/test/std/number.ci:41: testExp_f64: float64(2.718282)
cmplStd/test/std/number.ci:42: testPow_f64: float64(3.141593)
cmplStd/test/std/number.ci:43: testSqrt_f64: float64(3.141593)
cmplStd/test/std/number.ci:44: testAtan_f64: float64(1.262627)
cmplStd/test/std/number.ci:46: testSin_f32: float32(1.000000)
cmplStd/test/std/number.ci:47: testCos_f32: float32(-0.000000)
cmplStd/test/std/number.ci:48: testTan_f32: float32(1.000000)
cmplStd/test/std/number.ci:49: testLog_f32: float32(3.000000)
cmplStd/test/std/number.ci:50: testExp_f32: float32(2.718282)
cmplStd/test/std/number.ci:51: testPow_f32: float32(3.141593)
cmplStd/test/std/number.ci:52: testSqrt_f32: float32(3.141593)
cmplStd/test/std/number.ci:53: testAtan_f32: float32(1.262627)
cmplStd/test/std/number.ci:55: testPopulation_u32: int32(14)
cmplStd/test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
cmplStd/test/std/number.ci:57: testBitScanReverse_u32: int32(14)
cmplStd/test/std/number.ci:58: testBitScanForward_u32: int32(0)
cmplStd/test/std/number.ci:59: testHighBit_u32: int32(16384)
cmplStd/test/std/number.ci:60: testLowBit_u32: int32(1)
cmplStd/test/std/number.ci:62: testZeroExtend_u32: int32(31)
cmplStd/test/std/number.ci:63: testSignExtend_u32: int32(-1)
cmplStd/test/std/number.ci:65: testZeroExtend_u64: int32(31)
cmplStd/test/std/number.ci:66: testSignExtend_u64: int32(-1)
cmplStd/test/std/memory.ci:7: p1: pointer(<?>)
cmplStd/test/std/memory.ci:8: p2: pointer(<?>)
cmplStd/test/std/memory.ci:9: p3: pointer(<?>)
cmplStd/test/std/memory.ci:10: p4: pointer(<?>)
cmplStd/test/std/memory.ci:23: val1: int64(0)
cmplStd/test/std/memory.ci:24: val2: int64(42)
cmplStd/test/std/tryExec.ci:11: noError: function(<noError>)
cmplStd/test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
cmplStd/test/std/tryExec.ci:20: divisionByZero: function(<divisionByZero>)
cmplStd/test/std/tryExec.ci:24: abortExecution: function(<abortExecution>)
cmplStd/test/std/tryExec.ci:38: invalidMemoryAccess: function(<invalidMemoryAccess>)
cmplStd/test/std/tryExec.ci:43: invalidInstruction: function(<invalidInstruction>)
cmplStd/test/std/tryExec.ci:47: tryExecErr0: int32(0)
cmplStd/test/std/tryExec.ci:48: tryExecErr1: int32(1)
cmplStd/test/std/tryExec.ci:49: tryExecErr2: int32(2)
cmplStd/test/std/tryExec.ci:50: tryExecErr3: int32(3)
cmplStd/test/std/tryExec.ci:51: tryExecErr4: int32(4)
cmplStd/test/std/tryExec.ci:52: tryExecErr5: int32(5)
cmplStd/test/std/tryExec.ci:53: tryExecErr6: int32(6)
cmplStd/test/lang/init.reference.ci:7: value: int64(42)
cmplStd/test/lang/init.reference.ci:8: valueRef: int64(42)
cmplStd/test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:12: fromRef: int64(42)
cmplStd/test/lang/init.reference.ci:13: fromPtr: int64(42)
cmplStd/test/lang/init.reference.ci:14: fromVar: int64(42)
cmplStd/test/lang/init.reference.ci:16: nullRef: int64(null)
cmplStd/test/lang/init.reference.ci:17: nullPtr: pointer(null)
cmplStd/test/lang/init.reference.ci:18: nullVar: variant(null)
cmplStd/test/lang/init.reference.ci:19: nullTyp: typename(null)
cmplStd/test/lang/init.reference.ci:20: nullFun: function(null)
cmplStd/test/lang/init.reference.ci:21: nullObj: object(null)
cmplStd/test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:27: local: int64(42)
cmplStd/test/lang/init.reference.ci:28: copyVal: int64(42)
cmplStd/test/lang/init.reference.ci:29: copyRef: int64(42)
cmplStd/test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
cmplStd/test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
cmplStd/test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
cmplStd/test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
cmplStd/test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
cmplStd/test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
cmplStd/test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
cmplStd/test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
cmplStd/test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
cmplStd/test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
cmplStd/test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
cmplStd/test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
cmplStd/test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
cmplStd/test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
cmplStd/test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
cmplStd/test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
cmplStd/test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
cmplStd/test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
cmplStd/test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
cmplStd/test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
cmplStd/test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
cmplStd/test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
cmplStd/test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
cmplStd/test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
cmplStd/test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
cmplStd/test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
cmplStd/test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
cmplStd/test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
cmplStd/test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
cmplStd/test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
cmplStd/test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
cmplStd/test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
cmplStd/test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
cmplStd/test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
cmplStd/test/lang/init.reference.ci:75: typVoid: typename(<void>)
cmplStd/test/lang/init.reference.ci:76: typBool: typename(<bool>)
cmplStd/test/lang/init.reference.ci:77: typChar: typename(<char>)
cmplStd/test/lang/init.reference.ci:78: typInt8: typename(<int8>)
cmplStd/test/lang/init.reference.ci:79: typInt16: typename(<int16>)
cmplStd/test/lang/init.reference.ci:80: typInt32: typename(<int32>)
cmplStd/test/lang/init.reference.ci:81: typInt64: typename(<int64>)
cmplStd/test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
cmplStd/test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
cmplStd/test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
cmplStd/test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
cmplStd/test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
cmplStd/test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
cmplStd/test/lang/init.reference.ci:88: typTypename: typename(<typename>)
cmplStd/test/lang/init.reference.ci:89: typFunction: typename(<function>)
cmplStd/test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
cmplStd/test/lang/init.reference.ci:91: typVariant: typename(<variant>)
cmplStd/test/lang/init.reference.ci:92: typObject: typename(<object>)
cmplStd/test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
cmplStd/test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
cmplStd/test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
cmplStd/test/lang/init.variable.ci:3: variable: int32(0)
cmplStd/test/lang/init.variable.ci:7: constant: int32(42)
cmplStd/test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
cmplStd/test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
cmplStd/test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
cmplStd/test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/function.ci:4: empty: function(<empty>)
cmplStd/test/lang/function.ci:7: funAdd: function(<funAdd>)
cmplStd/test/lang/function.ci:12: funAddResult: int32(9)
cmplStd/test/lang/function.ci:15: funAddRef: function(<funAdd>)
cmplStd/test/lang/function.ci:18: funAddRefResult: int32(10)
cmplStd/test/lang/function.ci:21: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:24: funMulResult: int32(12)
cmplStd/test/lang/function.ci:27: funMulRef: function(<funMul>)
cmplStd/test/lang/function.ci:30: funMulRefResult: int32(14)
cmplStd/test/lang/function.ci:33: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:38: fib: function(<fib>)
cmplStd/test/lang/function.ci:46: fibonacci_13: uint32(233)
cmplStd/test/lang/reflect.ci:3: sizeofVoid: int32(0)
cmplStd/test/lang/reflect.ci:4: sizeofBool: int32(1)
cmplStd/test/lang/reflect.ci:5: sizeofChar: int32(1)
cmplStd/test/lang/reflect.ci:6: sizeofInt8: int32(1)
cmplStd/test/lang/reflect.ci:7: sizeofInt16: int32(2)
cmplStd/test/lang/reflect.ci:8: sizeofInt32: int32(4)
cmplStd/test/lang/reflect.ci:9: sizeofInt64: int32(8)
cmplStd/test/lang/reflect.ci:10: sizeofUint8: int32(1)
cmplStd/test/lang/reflect.ci:11: sizeofUint16: int32(2)
cmplStd/test/lang/reflect.ci:12: sizeofUint32: int32(4)
cmplStd/test/lang/reflect.ci:13: sizeofUint64: int32(8)
cmplStd/test/lang/reflect.ci:14: sizeofFloat32: int32(4)
cmplStd/test/lang/reflect.ci:15: sizeofFloat64: int32(8)
cmplStd/test/lang/reflect.ci:16: sizeofPointer: int32(4)
cmplStd/test/lang/reflect.ci:17: sizeofVariant: int32(8)
cmplStd/test/lang/reflect.ci:18: sizeofTypename: int32(4)
cmplStd/test/lang/reflect.ci:19: sizeofFunction: int32(4)
cmplStd/test/lang/reflect.ci:20: sizeofObject: int32(4)
cmplStd/test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
cmplStd/test/lang/reflect.ci:32: offsetOfRecord: int32(310352)
cmplStd/test/lang/reflect.ci:33: sizeOfRecord: int32(16)
cmplStd/test/lang/reflect.ci:34: fileOfRecord: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:35: lineOfRecord: int32(26)
cmplStd/test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
cmplStd/test/lang/reflect.ci:39: offsetOfBase: int32(310032)
cmplStd/test/lang/reflect.ci:40: sizeOfBase: int32(12)
cmplStd/test/lang/reflect.ci:41: fileOfBase: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:42: lineOfBase: int32(22)
cmplStd/test/lang/reflect.ci:44: typeofBase1: typename(<object>)
cmplStd/test/lang/reflect.ci:45: offsetOfBase1: int32(2880)
cmplStd/test/lang/reflect.ci:46: sizeOfBase1: int32(4)
cmplStd/test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
cmplStd/test/lang/reflect.ci:49: offsetOfBase2: int32(8)
cmplStd/test/lang/reflect.ci:50: sizeOfBase2: int32(160)
cmplStd/test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
cmplStd/test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
cmplStd/test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
cmplStd/test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
cmplStd/test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
cmplStd/test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
cmplStd/test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
cmplStd/test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
cmplStd/test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
cmplStd/test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
cmplStd/test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
cmplStd/test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
cmplStd/test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
cmplStd/test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
cmplStd/test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
cmplStd/test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
cmplStd/test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
cmplStd/test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
cmplStd/test/lang/recUnion.ci:16: color: typename(<color>)
cmplStd/test/lang/recUnion.ci:22: Color: typename(<Color>)
cmplStd/test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
cmplStd/test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535)
})
cmplStd/test/lang/recUnion.ci:31: blue: color({
	col: uint32(255)
})
cmplStd/test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
cmplStd/test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
cmplStd/test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
cmplStd/test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
cmplStd/test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
cmplStd/test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
cmplStd/test/lang/useOperator.ci:5: shift: int32(2)
cmplStd/test/lang/useOperator.ci:7: boolA: bool(1)
cmplStd/test/lang/useOperator.ci:8: boolB: bool(1)
cmplStd/test/lang/useOperator.ci:17: boolAnd: bool(1)
cmplStd/test/lang/useOperator.ci:18: boolIor: bool(1)
cmplStd/test/lang/useOperator.ci:19: boolXor: bool(0)
cmplStd/test/lang/useOperator.ci:22: boolNot: bool(0)
cmplStd/test/lang/useOperator.ci:23: boolCeq: bool(1)
cmplStd/test/lang/useOperator.ci:24: boolCne: bool(0)
cmplStd/test/lang/useOperator.ci:25: boolClt: bool(0)
cmplStd/test/lang/useOperator.ci:26: boolCle: bool(1)
cmplStd/test/lang/useOperator.ci:27: boolCgt: bool(0)
cmplStd/test/lang/useOperator.ci:28: boolCge: bool(1)
cmplStd/test/lang/useOperator.ci:30: chrA: char('a')
cmplStd/test/lang/useOperator.ci:31: chrB: char('b')
cmplStd/test/lang/useOperator.ci:32: chrPls: char('b')
cmplStd/test/lang/useOperator.ci:33: chrNeg: char('')
cmplStd/test/lang/useOperator.ci:34: chrCmt: char('')
cmplStd/test/lang/useOperator.ci:35: chrAdd: char('')
cmplStd/test/lang/useOperator.ci:36: chrSub: char('')
cmplStd/test/lang/useOperator.ci:37: chrMul: char('\"')
cmplStd/test/lang/useOperator.ci:38: chrDiv: char('')
cmplStd/test/lang/useOperator.ci:39: chrMod: char('a')
cmplStd/test/lang/useOperator.ci:40: chrAnd: char('`')
cmplStd/test/lang/useOperator.ci:41: chrIor: char('c')
cmplStd/test/lang/useOperator.ci:42: chrXor: char('')
cmplStd/test/lang/useOperator.ci:43: chrShl: char('')
cmplStd/test/lang/useOperator.ci:44: chrShr: char('')
cmplStd/test/lang/useOperator.ci:45: chrNot: bool(0)
cmplStd/test/lang/useOperator.ci:46: chrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:47: chrCne: bool(1)
cmplStd/test/lang/useOperator.ci:48: chrClt: bool(1)
cmplStd/test/lang/useOperator.ci:49: chrCle: bool(1)
cmplStd/test/lang/useOperator.ci:50: chrCgt: bool(0)
cmplStd/test/lang/useOperator.ci:51: chrCge: bool(0)
cmplStd/test/lang/useOperator.ci:53: i8A: int8(96)
cmplStd/test/lang/useOperator.ci:54: i8B: int8(42)
cmplStd/test/lang/useOperator.ci:55: i8Pls: int8(42)
cmplStd/test/lang/useOperator.ci:56: i8Neg: int8(-42)
cmplStd/test/lang/useOperator.ci:57: i8Cmt: int8(-43)
cmplStd/test/lang/useOperator.ci:58: i8Add: int8(-118)
cmplStd/test/lang/useOperator.ci:59: i8Sub: int8(54)
cmplStd/test/lang/useOperator.ci:60: i8Mul: int8(-64)
cmplStd/test/lang/useOperator.ci:61: i8Div: int8(2)
cmplStd/test/lang/useOperator.ci:62: i8Mod: int8(12)
cmplStd/test/lang/useOperator.ci:63: i8And: int8(32)
cmplStd/test/lang/useOperator.ci:64: i8Ior: int8(106)
cmplStd/test/lang/useOperator.ci:65: i8Xor: int8(74)
cmplStd/test/lang/useOperator.ci:66: i8Shl: int8(-128)
cmplStd/test/lang/useOperator.ci:67: i8Shr: int8(24)
cmplStd/test/lang/useOperator.ci:68: i8Not: bool(0)
cmplStd/test/lang/useOperator.ci:69: i8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:70: i8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:71: i8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:72: i8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:73: i8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:74: i8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:76: u8A: uint8(96)
cmplStd/test/lang/useOperator.ci:77: u8B: uint8(42)
cmplStd/test/lang/useOperator.ci:78: u8Pls: uint8(42)
cmplStd/test/lang/useOperator.ci:79: u8Neg: uint8(214)
cmplStd/test/lang/useOperator.ci:80: u8Cmt: uint8(213)
cmplStd/test/lang/useOperator.ci:81: u8Add: uint8(138)
cmplStd/test/lang/useOperator.ci:82: u8Sub: uint8(54)
cmplStd/test/lang/useOperator.ci:83: u8Mul: uint8(192)
cmplStd/test/lang/useOperator.ci:84: u8Div: uint8(2)
cmplStd/test/lang/useOperator.ci:85: u8Mod: uint8(12)
cmplStd/test/lang/useOperator.ci:86: u8And: uint8(32)
cmplStd/test/lang/useOperator.ci:87: u8Ior: uint8(106)
cmplStd/test/lang/useOperator.ci:88: u8Xor: uint8(74)
cmplStd/test/lang/useOperator.ci:89: u8Shl: uint8(128)
cmplStd/test/lang/useOperator.ci:90: u8Shr: uint8(24)
cmplStd/test/lang/useOperator.ci:91: u8Not: bool(0)
cmplStd/test/lang/useOperator.ci:92: u8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:93: u8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:94: u8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:95: u8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:96: u8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:97: u8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:99: i16A: int16(96)
cmplStd/test/lang/useOperator.ci:100: i16B: int16(42)
cmplStd/test/lang/useOperator.ci:101: i16Pls: int16(42)
cmplStd/test/lang/useOperator.ci:102: i16Neg: int16(-42)
cmplStd/test/lang/useOperator.ci:103: i16Cmt: int16(-43)
cmplStd/test/lang/useOperator.ci:104: i16Add: int16(138)
cmplStd/test/lang/useOperator.ci:105: i16Sub: int16(54)
cmplStd/test/lang/useOperator.ci:106: i16Mul: int16(4032)
cmplStd/test/lang/useOperator.ci:107: i16Div: int16(2)
cmplStd/test/lang/useOperator.ci:108: i16Mod: int16(12)
cmplStd/test/lang/useOperator.ci:109: i16And: int16(32)
cmplStd/test/lang/useOperator.ci:110: i16Ior: int16(106)
cmplStd/test/lang/useOperator.ci:111: i16Xor: int16(74)
cmplStd/test/lang/useOperator.ci:112: i16Shl: int16(384)
cmplStd/test/lang/useOperator.ci:113: i16Shr: int16(24)
cmplStd/test/lang/useOperator.ci:114: i16Not: bool(0)
cmplStd/test/lang/useOperator.ci:115: i16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:116: i16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:117: i16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:118: i16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:119: i16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:120: i16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:122: u16A: uint16(96)
cmplStd/test/lang/useOperator.ci:123: u16B: uint16(42)
cmplStd/test/lang/useOperator.ci:124: u16Pls: uint16(42)
cmplStd/test/lang/useOperator.ci:125: u16Neg: uint16(65494)
cmplStd/test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
cmplStd/test/lang/useOperator.ci:127: u16Add: uint16(138)
cmplStd/test/lang/useOperator.ci:128: u16Sub: uint16(54)
cmplStd/test/lang/useOperator.ci:129: u16Mul: uint16(4032)
cmplStd/test/lang/useOperator.ci:130: u16Div: uint16(2)
cmplStd/test/lang/useOperator.ci:131: u16Mod: uint16(12)
cmplStd/test/lang/useOperator.ci:132: u16And: uint16(32)
cmplStd/test/lang/useOperator.ci:133: u16Ior: uint16(106)
cmplStd/test/lang/useOperator.ci:134: u16Xor: uint16(74)
cmplStd/test/lang/useOperator.ci:135: u16Shl: uint16(384)
cmplStd/test/lang/useOperator.ci:136: u16Shr: uint16(24)
cmplStd/test/lang/useOperator.ci:137: u16Not: bool(0)
cmplStd/test/lang/useOperator.ci:138: u16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:139: u16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:140: u16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:141: u16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:142: u16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:143: u16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:145: i32A: int32(96)
cmplStd/test/lang/useOperator.ci:146: i32B: int32(42)
cmplStd/test/lang/useOperator.ci:147: i32Pls: int32(42)
cmplStd/test/lang/useOperator.ci:148: i32Neg: int32(-42)
cmplStd/test/lang/useOperator.ci:149: i32Cmt: int32(-43)
cmplStd/test/lang/useOperator.ci:150: i32Add: int32(138)
cmplStd/test/lang/useOperator.ci:151: i32Sub: int32(54)
cmplStd/test/lang/useOperator.ci:152: i32Mul: int32(4032)
cmplStd/test/lang/useOperator.ci:153: i32Div: int32(2)
cmplStd/test/lang/useOperator.ci:154: i32Mod: int32(12)
cmplStd/test/lang/useOperator.ci:155: i32And: int32(32)
cmplStd/test/lang/useOperator.ci:156: i32Ior: int32(106)
cmplStd/test/lang/useOperator.ci:157: i32Xor: int32(74)
cmplStd/test/lang/useOperator.ci:158: i32Shl: int32(384)
cmplStd/test/lang/useOperator.ci:159: i32Shr: int32(24)
cmplStd/test/lang/useOperator.ci:160: i32Not: bool(0)
cmplStd/test/lang/useOperator.ci:161: i32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:162: i32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:163: i32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:164: i32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:165: i32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:166: i32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:168: u32A: uint32(96)
cmplStd/test/lang/useOperator.ci:169: u32B: uint32(42)
cmplStd/test/lang/useOperator.ci:170: u32Pls: uint32(42)
cmplStd/test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
cmplStd/test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
cmplStd/test/lang/useOperator.ci:173: u32Add: uint32(138)
cmplStd/test/lang/useOperator.ci:174: u32Sub: uint32(54)
cmplStd/test/lang/useOperator.ci:175: u32Mul: uint32(4032)
cmplStd/test/lang/useOperator.ci:176: u32Div: uint32(2)
cmplStd/test/lang/useOperator.ci:177: u32Mod: uint32(12)
cmplStd/test/lang/useOperator.ci:178: u32And: uint32(32)
cmplStd/test/lang/useOperator.ci:179: u32Ior: uint32(106)
cmplStd/test/lang/useOperator.ci:180: u32Xor: uint32(74)
cmplStd/test/lang/useOperator.ci:181: u32Shl: uint32(384)
cmplStd/test/lang/useOperator.ci:182: u32Shr: uint32(24)
cmplStd/test/lang/useOperator.ci:183: u32Not: bool(0)
cmplStd/test/lang/useOperator.ci:184: u32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:185: u32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:186: u32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:187: u32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:188: u32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:189: u32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:191: i64A: int64(96)
cmplStd/test/lang/useOperator.ci:192: i64B: int64(42)
cmplStd/test/lang/useOperator.ci:193: i64Pls: int64(42)
cmplStd/test/lang/useOperator.ci:194: i64Neg: int64(-42)
cmplStd/test/lang/useOperator.ci:195: i64Cmt: int64(-43)
cmplStd/test/lang/useOperator.ci:196: i64Add: int64(138)
cmplStd/test/lang/useOperator.ci:197: i64Sub: int64(54)
cmplStd/test/lang/useOperator.ci:198: i64Mul: int64(4032)
cmplStd/test/lang/useOperator.ci:199: i64Div: int64(2)
cmplStd/test/lang/useOperator.ci:200: i64Mod: int64(12)
cmplStd/test/lang/useOperator.ci:201: i64And: int64(32)
cmplStd/test/lang/useOperator.ci:202: i64Ior: int64(106)
cmplStd/test/lang/useOperator.ci:203: i64Xor: int64(74)
cmplStd/test/lang/useOperator.ci:204: i64Shl: int64(384)
cmplStd/test/lang/useOperator.ci:205: i64Shr: int64(24)
cmplStd/test/lang/useOperator.ci:206: i64Not: bool(0)
cmplStd/test/lang/useOperator.ci:207: i64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:208: i64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:209: i64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:210: i64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:211: i64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:212: i64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:214: u64A: uint64(96)
cmplStd/test/lang/useOperator.ci:215: u64B: uint64(42)
cmplStd/test/lang/useOperator.ci:216: u64Pls: uint64(42)
cmplStd/test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
cmplStd/test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
cmplStd/test/lang/useOperator.ci:219: u64Add: uint64(138)
cmplStd/test/lang/useOperator.ci:220: u64Sub: uint64(54)
cmplStd/test/lang/useOperator.ci:221: u64Mul: uint64(4032)
cmplStd/test/lang/useOperator.ci:222: u64Div: uint64(2)
cmplStd/test/lang/useOperator.ci:223: u64Mod: uint64(12)
cmplStd/test/lang/useOperator.ci:224: u64And: uint64(32)
cmplStd/test/lang/useOperator.ci:225: u64Ior: uint64(106)
cmplStd/test/lang/useOperator.ci:226: u64Xor: uint64(74)
cmplStd/test/lang/useOperator.ci:227: u64Shl: uint64(384)
cmplStd/test/lang/useOperator.ci:228: u64Shr: uint64(24)
cmplStd/test/lang/useOperator.ci:229: u64Not: bool(0)
cmplStd/test/lang/useOperator.ci:230: u64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:231: u64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:232: u64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:233: u64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:234: u64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:235: u64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:237: f32A: float32(96.300003)
cmplStd/test/lang/useOperator.ci:238: f32B: float32(42.139999)
cmplStd/test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
cmplStd/test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
cmplStd/test/lang/useOperator.ci:242: f32Add: float32(138.440002)
cmplStd/test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
cmplStd/test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
cmplStd/test/lang/useOperator.ci:245: f32Div: float32(2.285240)
cmplStd/test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
cmplStd/test/lang/useOperator.ci:252: f32Not: bool(0)
cmplStd/test/lang/useOperator.ci:253: f32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:254: f32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:255: f32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:256: f32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:257: f32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:258: f32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:260: f64A: float64(96.300000)
cmplStd/test/lang/useOperator.ci:261: f64B: float64(42.140000)
cmplStd/test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
cmplStd/test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
cmplStd/test/lang/useOperator.ci:265: f64Add: float64(138.440000)
cmplStd/test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
cmplStd/test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
cmplStd/test/lang/useOperator.ci:268: f64Div: float64(2.285240)
cmplStd/test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
cmplStd/test/lang/useOperator.ci:275: f64Not: bool(0)
cmplStd/test/lang/useOperator.ci:276: f64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:277: f64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:278: f64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:279: f64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:280: f64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:281: f64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:283: ptrA: pointer(null)
cmplStd/test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
cmplStd/test/lang/useOperator.ci:299: ptrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:300: ptrCne: bool(1)
cmplStd/test/lang/stmt.if.ci:26: t: int32(0)
cmplStd/test/lang/stmt.for.ci:12: forIdx: int32(2)
cmplStd/test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
cmplStd/test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
cmplStd/test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
cmplStd/test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
cmplStd/test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
cmplStd/test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
cmplStd/test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
cmplStd/test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
cmplStd/test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
cmplStd/test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
cmplStd/test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
cmplStd/test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
cmplStd/test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
cmplStd/test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
cmplStd/test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
cmplStd/test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
cmplStd/test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
cmplStd/test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
cmplStd/test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
cmplStd/test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
cmplStd/test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
cmplStd/test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
cmplStd/test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
cmplStd/test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
cmplStd/test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
cmplStd/test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
cmplStd/test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
cmplStd/test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
cmplStd/test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
cmplStd/test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
cmplStd/test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
cmplStd/test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
cmplStd/test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
cmplStd/test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
cmplStd/test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
cmplStd/test/std/test.math.ci:67: testMathCmp_f32: bool(1)
cmplStd/test/std/test.math.ci:68: testMathCmp_f64: bool(1)
cmplStd/test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
cmplStd/test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
cmplStd/test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
cmplStd/test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
cmplStd/test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
cmplStd/test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
cmplStd/test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
cmplStd/test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
cmplStd/test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
cmplStd/test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
cmplStd/test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
cmplStd/test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
cmplStd/test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
cmplStd/test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
cmplStd/test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
cmplStd/test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
cmplStd/test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
cmplStd/test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
cmplStd/test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
cmplStd/test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
cmplStd/test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
cmplStd/test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194016(4.0 Mb)
memory[used] @000000; size: 414842(405.1 Kb)
memory[heap] @06547a; size: 2730622(2.6 Mb)
memory[stack] @1fff40; size: 1048504(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 391040(381.9 Kb)
memory[code] @000000; size: 18791(18.4 Kb)
memory[data] @000000; size: 2583(2.5 Kb)

---------- heap memory:
memory[free] @065490; size: 2144(2.1 Kb)
memory[used] @065d00; size: 32(32.0 bytes)
memory[used] @065d30; size: 32(32.0 bytes)
memory[free] @065d60; size: 2728320(2.6 Mb)

---------- Exitcode: 0, time: 18.652 ms
